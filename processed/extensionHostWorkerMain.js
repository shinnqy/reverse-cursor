/*!--------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
!(function () {
  try {
    var e =
        "undefined" != typeof window
          ? window
          : "undefined" != typeof global
            ? global
            : "undefined" != typeof self
              ? self
              : {},
      n = new e.Error().stack
    n &&
      ((e._sentryDebugIds = e._sentryDebugIds || {}),
      (e._sentryDebugIds[n] = "818245f6-c3b4-5059-af60-f9a3ab1f3b3a"))
  } catch (e) {}
})()
var Z8 = function (i, t) {
  return (
    (Z8 =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (e, r) {
          e.__proto__ = r
        }) ||
      function (e, r) {
        for (var s in r)
          Object.prototype.hasOwnProperty.call(r, s) && (e[s] = r[s])
      }),
    Z8(i, t)
  )
}
export function __extends(i, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError(
      "Class extends value " + String(t) + " is not a constructor or null",
    )
  Z8(i, t)
  function e() {
    this.constructor = i
  }
  i.prototype =
    t === null ? Object.create(t) : ((e.prototype = t.prototype), new e())
}
export var __assign = function () {
  return (
    (__assign =
      Object.assign ||
      function (t) {
        for (var e, r = 1, s = arguments.length; r < s; r++) {
          e = arguments[r]
          for (var a in e)
            Object.prototype.hasOwnProperty.call(e, a) && (t[a] = e[a])
        }
        return t
      }),
    __assign.apply(this, arguments)
  )
}
export function __rest(i, t) {
  var e = {}
  for (var r in i)
    Object.prototype.hasOwnProperty.call(i, r) &&
      t.indexOf(r) < 0 &&
      (e[r] = i[r])
  if (i != null && typeof Object.getOwnPropertySymbols == "function")
    for (var s = 0, r = Object.getOwnPropertySymbols(i); s < r.length; s++)
      t.indexOf(r[s]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(i, r[s]) &&
        (e[r[s]] = i[r[s]])
  return e
}
export function __decorate(i, t, e, r) {
  var s = arguments.length,
    a =
      s < 3 ? t : r === null ? (r = Object.getOwnPropertyDescriptor(t, e)) : r,
    o
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    a = Reflect.decorate(i, t, e, r)
  else
    for (var c = i.length - 1; c >= 0; c--)
      (o = i[c]) && (a = (s < 3 ? o(a) : s > 3 ? o(t, e, a) : o(t, e)) || a)
  return s > 3 && a && Object.defineProperty(t, e, a), a
}
export function __param(i, t) {
  return function (e, r) {
    t(e, r, i)
  }
}
export function __esDecorate(i, t, e, r, s, a) {
  function o(N) {
    if (N !== void 0 && typeof N != "function")
      throw new TypeError("Function expected")
    return N
  }
  for (
    var c = r.kind,
      u = c === "getter" ? "get" : c === "setter" ? "set" : "value",
      l = !t && i ? (r.static ? i : i.prototype) : null,
      m = t || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}),
      h,
      p = !1,
      g = e.length - 1;
    g >= 0;
    g--
  ) {
    var w = {}
    for (var T in r) w[T] = T === "access" ? {} : r[T]
    for (var T in r.access) w.access[T] = r.access[T]
    w.addInitializer = function (N) {
      if (p)
        throw new TypeError(
          "Cannot add initializers after decoration has completed",
        )
      a.push(o(N || null))
    }
    var b = (0, e[g])(c === "accessor" ? { get: m.get, set: m.set } : m[u], w)
    if (c === "accessor") {
      if (b === void 0) continue
      if (b === null || typeof b != "object")
        throw new TypeError("Object expected")
      ;(h = o(b.get)) && (m.get = h),
        (h = o(b.set)) && (m.set = h),
        (h = o(b.init)) && s.unshift(h)
    } else (h = o(b)) && (c === "field" ? s.unshift(h) : (m[u] = h))
  }
  l && Object.defineProperty(l, r.name, m), (p = !0)
}
export function __runInitializers(i, t, e) {
  for (var r = arguments.length > 2, s = 0; s < t.length; s++)
    e = r ? t[s].call(i, e) : t[s].call(i)
  return r ? e : void 0
}
export function __propKey(i) {
  return typeof i == "symbol" ? i : "".concat(i)
}
export function __setFunctionName(i, t, e) {
  return (
    typeof t == "symbol" &&
      (t = t.description ? "[".concat(t.description, "]") : ""),
    Object.defineProperty(i, "name", {
      configurable: !0,
      value: e ? "".concat(e, " ", t) : t,
    })
  )
}
export function __metadata(i, t) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(i, t)
}
export function __awaiter(i, t, e, r) {
  function s(a) {
    return a instanceof e
      ? a
      : new e(function (o) {
          o(a)
        })
  }
  return new (e || (e = Promise))(function (a, o) {
    function c(m) {
      try {
        l(r.next(m))
      } catch (h) {
        o(h)
      }
    }
    function u(m) {
      try {
        l(r.throw(m))
      } catch (h) {
        o(h)
      }
    }
    function l(m) {
      m.done ? a(m.value) : s(m.value).then(c, u)
    }
    l((r = r.apply(i, t || [])).next())
  })
}
export function __generator(i, t) {
  var e = {
      label: 0,
      sent: function () {
        if (a[0] & 1) throw a[1]
        return a[1]
      },
      trys: [],
      ops: [],
    },
    r,
    s,
    a,
    o
  return (
    (o = { next: c(0), throw: c(1), return: c(2) }),
    typeof Symbol == "function" &&
      (o[Symbol.iterator] = function () {
        return this
      }),
    o
  )
  function c(l) {
    return function (m) {
      return u([l, m])
    }
  }
  function u(l) {
    if (r) throw new TypeError("Generator is already executing.")
    for (; o && ((o = 0), l[0] && (e = 0)), e; )
      try {
        if (
          ((r = 1),
          s &&
            (a =
              l[0] & 2
                ? s.return
                : l[0]
                  ? s.throw || ((a = s.return) && a.call(s), 0)
                  : s.next) &&
            !(a = a.call(s, l[1])).done)
        )
          return a
        switch (((s = 0), a && (l = [l[0] & 2, a.value]), l[0])) {
          case 0:
          case 1:
            a = l
            break
          case 4:
            return e.label++, { value: l[1], done: !1 }
          case 5:
            e.label++, (s = l[1]), (l = [0])
            continue
          case 7:
            ;(l = e.ops.pop()), e.trys.pop()
            continue
          default:
            if (
              ((a = e.trys),
              !(a = a.length > 0 && a[a.length - 1]) &&
                (l[0] === 6 || l[0] === 2))
            ) {
              e = 0
              continue
            }
            if (l[0] === 3 && (!a || (l[1] > a[0] && l[1] < a[3]))) {
              e.label = l[1]
              break
            }
            if (l[0] === 6 && e.label < a[1]) {
              ;(e.label = a[1]), (a = l)
              break
            }
            if (a && e.label < a[2]) {
              ;(e.label = a[2]), e.ops.push(l)
              break
            }
            a[2] && e.ops.pop(), e.trys.pop()
            continue
        }
        l = t.call(i, e)
      } catch (m) {
        ;(l = [6, m]), (s = 0)
      } finally {
        r = a = 0
      }
    if (l[0] & 5) throw l[1]
    return { value: l[0] ? l[1] : void 0, done: !0 }
  }
}
export var __createBinding = Object.create
  ? function (i, t, e, r) {
      r === void 0 && (r = e)
      var s = Object.getOwnPropertyDescriptor(t, e)
      ;(!s || ("get" in s ? !t.__esModule : s.writable || s.configurable)) &&
        (s = {
          enumerable: !0,
          get: function () {
            return t[e]
          },
        }),
        Object.defineProperty(i, r, s)
    }
  : function (i, t, e, r) {
      r === void 0 && (r = e), (i[r] = t[e])
    }
export function __exportStar(i, t) {
  for (var e in i)
    e !== "default" &&
      !Object.prototype.hasOwnProperty.call(t, e) &&
      __createBinding(t, i, e)
}
export function __values(i) {
  var t = typeof Symbol == "function" && Symbol.iterator,
    e = t && i[t],
    r = 0
  if (e) return e.call(i)
  if (i && typeof i.length == "number")
    return {
      next: function () {
        return (
          i && r >= i.length && (i = void 0), { value: i && i[r++], done: !i }
        )
      },
    }
  throw new TypeError(
    t ? "Object is not iterable." : "Symbol.iterator is not defined.",
  )
}
export function __read(i, t) {
  var e = typeof Symbol == "function" && i[Symbol.iterator]
  if (!e) return i
  var r = e.call(i),
    s,
    a = [],
    o
  try {
    for (; (t === void 0 || t-- > 0) && !(s = r.next()).done; ) a.push(s.value)
  } catch (c) {
    o = { error: c }
  } finally {
    try {
      s && !s.done && (e = r.return) && e.call(r)
    } finally {
      if (o) throw o.error
    }
  }
  return a
}
export function __spread() {
  for (var i = [], t = 0; t < arguments.length; t++)
    i = i.concat(__read(arguments[t]))
  return i
}
export function __spreadArrays() {
  for (var i = 0, t = 0, e = arguments.length; t < e; t++)
    i += arguments[t].length
  for (var r = Array(i), s = 0, t = 0; t < e; t++)
    for (var a = arguments[t], o = 0, c = a.length; o < c; o++, s++) r[s] = a[o]
  return r
}
export function __spreadArray(i, t, e) {
  if (e || arguments.length === 2)
    for (var r = 0, s = t.length, a; r < s; r++)
      (a || !(r in t)) &&
        (a || (a = Array.prototype.slice.call(t, 0, r)), (a[r] = t[r]))
  return i.concat(a || Array.prototype.slice.call(t))
}
export function __await(i) {
  return this instanceof __await ? ((this.v = i), this) : new __await(i)
}
export function __asyncGenerator(i, t, e) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.")
  var r = e.apply(i, t || []),
    s,
    a = []
  return (
    (s = {}),
    c("next"),
    c("throw"),
    c("return", o),
    (s[Symbol.asyncIterator] = function () {
      return this
    }),
    s
  )
  function o(g) {
    return function (w) {
      return Promise.resolve(w).then(g, h)
    }
  }
  function c(g, w) {
    r[g] &&
      ((s[g] = function (T) {
        return new Promise(function (b, N) {
          a.push([g, T, b, N]) > 1 || u(g, T)
        })
      }),
      w && (s[g] = w(s[g])))
  }
  function u(g, w) {
    try {
      l(r[g](w))
    } catch (T) {
      p(a[0][3], T)
    }
  }
  function l(g) {
    g.value instanceof __await
      ? Promise.resolve(g.value.v).then(m, h)
      : p(a[0][2], g)
  }
  function m(g) {
    u("next", g)
  }
  function h(g) {
    u("throw", g)
  }
  function p(g, w) {
    g(w), a.shift(), a.length && u(a[0][0], a[0][1])
  }
}
export function __asyncDelegator(i) {
  var t, e
  return (
    (t = {}),
    r("next"),
    r("throw", function (s) {
      throw s
    }),
    r("return"),
    (t[Symbol.iterator] = function () {
      return this
    }),
    t
  )
  function r(s, a) {
    t[s] = i[s]
      ? function (o) {
          return (e = !e) ? { value: __await(i[s](o)), done: !1 } : a ? a(o) : o
        }
      : a
  }
}
export function __asyncValues(i) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.")
  var t = i[Symbol.asyncIterator],
    e
  return t
    ? t.call(i)
    : ((i = typeof __values == "function" ? __values(i) : i[Symbol.iterator]()),
      (e = {}),
      r("next"),
      r("throw"),
      r("return"),
      (e[Symbol.asyncIterator] = function () {
        return this
      }),
      e)
  function r(a) {
    e[a] =
      i[a] &&
      function (o) {
        return new Promise(function (c, u) {
          ;(o = i[a](o)), s(c, u, o.done, o.value)
        })
      }
  }
  function s(a, o, c, u) {
    Promise.resolve(u).then(function (l) {
      a({ value: l, done: c })
    }, o)
  }
}
export function __makeTemplateObject(i, t) {
  return (
    Object.defineProperty
      ? Object.defineProperty(i, "raw", { value: t })
      : (i.raw = t),
    i
  )
}
var Hst = Object.create
  ? function (i, t) {
      Object.defineProperty(i, "default", { enumerable: !0, value: t })
    }
  : function (i, t) {
      i.default = t
    }
export function __importStar(i) {
  if (i && i.__esModule) return i
  var t = {}
  if (i != null)
    for (var e in i)
      e !== "default" &&
        Object.prototype.hasOwnProperty.call(i, e) &&
        __createBinding(t, i, e)
  return Hst(t, i), t
}
export function __importDefault(i) {
  return i && i.__esModule ? i : { default: i }
}
export function __classPrivateFieldGet(i, t, e, r) {
  if (e === "a" && !r)
    throw new TypeError("Private accessor was defined without a getter")
  if (typeof t == "function" ? i !== t || !r : !t.has(i))
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it",
    )
  return e === "m" ? r : e === "a" ? r.call(i) : r ? r.value : t.get(i)
}
export function __classPrivateFieldSet(i, t, e, r, s) {
  if (r === "m") throw new TypeError("Private method is not writable")
  if (r === "a" && !s)
    throw new TypeError("Private accessor was defined without a setter")
  if (typeof t == "function" ? i !== t || !s : !t.has(i))
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it",
    )
  return r === "a" ? s.call(i, e) : s ? (s.value = e) : t.set(i, e), e
}
export function __classPrivateFieldIn(i, t) {
  if (t === null || (typeof t != "object" && typeof t != "function"))
    throw new TypeError("Cannot use 'in' operator on non-object")
  return typeof i == "function" ? t === i : i.has(t)
}
export function __addDisposableResource(i, t, e) {
  if (t != null) {
    if (typeof t != "object" && typeof t != "function")
      throw new TypeError("Object expected.")
    var r, s
    if (e) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.")
      r = t[Symbol.asyncDispose]
    }
    if (r === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.")
      ;(r = t[Symbol.dispose]), e && (s = r)
    }
    if (typeof r != "function") throw new TypeError("Object not disposable.")
    s &&
      (r = function () {
        try {
          s.call(this)
        } catch (a) {
          return Promise.reject(a)
        }
      }),
      i.stack.push({ value: t, dispose: r, async: e })
  } else e && i.stack.push({ async: !0 })
  return t
}
var Wst =
  typeof SuppressedError == "function"
    ? SuppressedError
    : function (i, t, e) {
        var r = new Error(e)
        return (
          (r.name = "SuppressedError"), (r.error = i), (r.suppressed = t), r
        )
      }
export function __disposeResources(i) {
  function t(r) {
    ;(i.error = i.hasError
      ? new Wst(r, i.error, "An error was suppressed during disposal.")
      : r),
      (i.hasError = !0)
  }
  function e() {
    for (; i.stack.length; ) {
      var r = i.stack.pop()
      try {
        var s = r.dispose && r.dispose.call(r.value)
        if (r.async)
          return Promise.resolve(s).then(e, function (a) {
            return t(a), e()
          })
      } catch (a) {
        t(a)
      }
    }
    if (i.hasError) throw i.error
  }
  return e()
}
export default {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
}
var qi = class {
    constructor(i) {
      ;(this.d = i), (this.a = !1)
    }
    get hasValue() {
      return this.a
    }
    get value() {
      if (!this.a)
        try {
          this.b = this.d()
        } catch (i) {
          this.c = i
        } finally {
          this.a = !0
        }
      if (this.c) throw this.c
      return this.b
    }
    get rawValue() {
      return this.b
    }
  },
  jst = class {
    constructor() {
      ;(this.b = []),
        (this.a = function (i) {
          setTimeout(() => {
            throw i.stack
              ? Kn.isErrorNoTelemetry(i)
                ? new Kn(
                    i.message +
                      `

` +
                      i.stack,
                  )
                : new Error(
                    i.message +
                      `

` +
                      i.stack,
                  )
              : i
          }, 0)
        })
    }
    addListener(i) {
      return (
        this.b.push(i),
        () => {
          this.d(i)
        }
      )
    }
    c(i) {
      this.b.forEach((t) => {
        t(i)
      })
    }
    d(i) {
      this.b.splice(this.b.indexOf(i), 1)
    }
    setUnexpectedErrorHandler(i) {
      this.a = i
    }
    getUnexpectedErrorHandler() {
      return this.a
    }
    onUnexpectedError(i) {
      this.a(i), this.c(i)
    }
    onUnexpectedExternalError(i) {
      this.a(i)
    }
  },
  OF = new jst()
function tB(i) {
  OF.setUnexpectedErrorHandler(i)
}
function qF(i) {
  OF.onUnexpectedError(i)
}
function Ui(i) {
  Xn(i) || OF.onUnexpectedError(i)
}
function eB(i) {
  Xn(i) || OF.onUnexpectedExternalError(i)
}
function ku(i) {
  if (i instanceof Error) {
    const { name: t, message: e } = i,
      r = i.stacktrace || i.stack
    return {
      $isError: !0,
      name: t,
      message: e,
      stack: r,
      noTelemetry: Kn.isErrorNoTelemetry(i),
    }
  }
  return i
}
function Vst(i) {
  let t
  return (
    i.noTelemetry ? (t = new Kn()) : ((t = new Error()), (t.name = i.name)),
    (t.message = i.message),
    (t.stack = i.stack),
    t
  )
}
var UF = "Canceled"
function Xn(i) {
  return i instanceof zr
    ? !0
    : i instanceof Error && i.name === UF && i.message === UF
}
var zr = class extends Error {
  constructor() {
    super(UF), (this.name = this.message)
  }
}
function xH() {
  const i = new Error(UF)
  return (i.name = i.message), i
}
function xt(i) {
  return i ? new Error(`Illegal argument: ${i}`) : new Error("Illegal argument")
}
function iB(i) {
  return i ? new Error(`Illegal state: ${i}`) : new Error("Illegal state")
}
var zs = class extends TypeError {
    constructor(i) {
      super(
        i
          ? `${i} is read-only and cannot be changed`
          : "Cannot change read-only property",
      )
    }
  },
  Gst = class extends Error {
    constructor(i) {
      super("NotImplemented"), i && (this.message = i)
    }
  },
  rB = class extends Error {
    constructor(i) {
      super("NotSupported"), i && (this.message = i)
    }
  },
  Kn = class nH extends Error {
    constructor(t) {
      super(t), (this.name = "CodeExpectedError")
    }
    static fromError(t) {
      if (t instanceof nH) return t
      const e = new nH()
      return (e.message = t.message), (e.stack = t.stack), e
    }
    static isErrorNoTelemetry(t) {
      return t.name === "CodeExpectedError"
    }
  },
  no = class pnt extends Error {
    constructor(t) {
      super(t || "An unexpected bug occurred."),
        Object.setPrototypeOf(this, pnt.prototype)
    }
  }
function zst(i, t) {
  const e = Yst(i, t)
  if (e !== -1) return i[e]
}
function Yst(i, t, e = i.length - 1) {
  for (let r = e; r >= 0; r--) {
    const s = i[r]
    if (t(s)) return r
  }
  return -1
}
function Qst(i, t, e = 0, r = i.length) {
  let s = e,
    a = r
  for (; s < a; ) {
    const o = Math.floor((s + a) / 2)
    t(i[o]) ? (s = o + 1) : (a = o)
  }
  return s - 1
}
var u8t = class gnt {
  static {
    this.assertInvariants = !1
  }
  constructor(t) {
    ;(this.e = t), (this.c = 0)
  }
  findLastMonotonous(t) {
    if (gnt.assertInvariants) {
      if (this.d) {
        for (const r of this.e)
          if (this.d(r) && !t(r))
            throw new Error(
              "MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.",
            )
      }
      this.d = t
    }
    const e = Qst(this.e, t, this.c)
    return (this.c = e + 1), e === -1 ? void 0 : this.e[e]
  }
}
function fn(i, t, e = (r, s) => r === s) {
  if (i === t) return !0
  if (!i || !t || i.length !== t.length) return !1
  for (let r = 0, s = i.length; r < s; r++) if (!e(i[r], t[r])) return !1
  return !0
}
function Xst(i, t) {
  const e = []
  let r
  for (const s of i.slice(0).sort(t))
    !r || t(r[0], s) !== 0 ? ((r = [s]), e.push(r)) : r.push(s)
  return e
}
function JH(i, t, e) {
  const r = []
  function s(c, u, l) {
    if (u === 0 && l.length === 0) return
    const m = r[r.length - 1]
    m && m.start + m.deleteCount === c
      ? ((m.deleteCount += u), m.toInsert.push(...l))
      : r.push({ start: c, deleteCount: u, toInsert: l })
  }
  let a = 0,
    o = 0
  for (;;) {
    if (a === i.length) {
      s(a, 0, t.slice(o))
      break
    }
    if (o === t.length) {
      s(a, i.length - a, [])
      break
    }
    const c = i[a],
      u = t[o],
      l = e(c, u)
    l === 0
      ? ((a += 1), (o += 1))
      : l < 0
        ? (s(a, 1, []), (a += 1))
        : l > 0 && (s(a, 0, [u]), (o += 1))
  }
  return r
}
function Kst(i, t, e) {
  const r = JH(i, t, e),
    s = [],
    a = []
  for (const o of r)
    s.push(...i.slice(o.start, o.start + o.deleteCount)), a.push(...o.toInsert)
  return { removed: s, added: a }
}
function Ge(i) {
  return i.filter((t) => !!t)
}
function Zst(i) {
  let t = 0
  for (let e = 0; e < i.length; e++) i[e] && ((i[t] = i[e]), (t += 1))
  i.length = t
}
function nB(i) {
  return !Array.isArray(i) || i.length === 0
}
function Su(i) {
  return Array.isArray(i) && i.length > 0
}
function so(i, t = (e) => e) {
  const e = new Set()
  return i.filter((r) => {
    const s = t(r)
    return e.has(s) ? !1 : (e.add(s), !0)
  })
}
function CH(i, t) {
  let e
  if (typeof t == "number") {
    let r = t
    e = () => {
      const s = Math.sin(r++) * 179426549
      return s - Math.floor(s)
    }
  } else e = Math.random
  for (let r = i.length - 1; r > 0; r -= 1) {
    const s = Math.floor(e() * (r + 1)),
      a = i[r]
    ;(i[r] = i[s]), (i[s] = a)
  }
}
function sB(i, t) {
  return Array.isArray(i) ? i.map(t) : t(i)
}
function Yr(i) {
  return Array.isArray(i) ? i : [i]
}
var aB
;(function (i) {
  function t(a) {
    return a < 0
  }
  i.isLessThan = t
  function e(a) {
    return a <= 0
  }
  i.isLessThanOrEqual = e
  function r(a) {
    return a > 0
  }
  i.isGreaterThan = r
  function s(a) {
    return a === 0
  }
  ;(i.isNeitherLessOrGreaterThan = s),
    (i.greaterThan = 1),
    (i.lessThan = -1),
    (i.neitherLessOrGreaterThan = 0)
})(aB || (aB = {}))
function tat(i, t) {
  return (e, r) => t(i(e), i(r))
}
var eat = (i, t) => i - t,
  l8t = class F8 {
    static {
      this.empty = new F8((t) => {})
    }
    constructor(t) {
      this.iterate = t
    }
    forEach(t) {
      this.iterate((e) => (t(e), !0))
    }
    toArray() {
      const t = []
      return this.iterate((e) => (t.push(e), !0)), t
    }
    filter(t) {
      return new F8((e) => this.iterate((r) => (t(r) ? e(r) : !0)))
    }
    map(t) {
      return new F8((e) => this.iterate((r) => e(t(r))))
    }
    some(t) {
      let e = !1
      return this.iterate((r) => ((e = t(r)), !e)), e
    }
    findFirst(t) {
      let e
      return this.iterate((r) => (t(r) ? ((e = r), !1) : !0)), e
    }
    findLast(t) {
      let e
      return this.iterate((r) => (t(r) && (e = r), !0)), e
    }
    findLastMaxBy(t) {
      let e,
        r = !0
      return (
        this.iterate(
          (s) => ((r || aB.isGreaterThan(t(s, e))) && ((r = !1), (e = s)), !0),
        ),
        e
      )
    }
  },
  LH
function RH(i, t) {
  const e = Object.create(null)
  for (const r of i) {
    const s = t(r)
    let a = e[s]
    a || (a = e[s] = []), a.push(r)
  }
  return e
}
function iat(i, t) {
  const e = [],
    r = []
  for (const s of i) t.has(s) || e.push(s)
  for (const s of t) i.has(s) || r.push(s)
  return { removed: e, added: r }
}
var d8t = class {
    static {
      LH = Symbol.toStringTag
    }
    constructor(i, t) {
      ;(this.b = t), (this.a = new Map()), (this[LH] = "SetWithKey")
      for (const e of i) this.add(e)
    }
    get size() {
      return this.a.size
    }
    add(i) {
      const t = this.b(i)
      return this.a.set(t, i), this
    }
    delete(i) {
      return this.a.delete(this.b(i))
    }
    has(i) {
      return this.a.has(this.b(i))
    }
    *entries() {
      for (const i of this.a.values()) yield [i, i]
    }
    keys() {
      return this.values()
    }
    *values() {
      for (const i of this.a.values()) yield i
    }
    clear() {
      this.a.clear()
    }
    forEach(i, t) {
      this.a.forEach((e) => i.call(t, e, e, this))
    }
    [Symbol.iterator]() {
      return this.values()
    }
  },
  DH,
  FH,
  _H
function rat(i, t, e) {
  let r = i.get(t)
  return r === void 0 && ((r = e), i.set(t, r)), r
}
var nat = class {
  constructor(i, t) {
    ;(this.uri = i), (this.value = t)
  }
}
function sat(i) {
  return Array.isArray(i)
}
var ei = class Ph {
    static {
      this.c = (t) => t.toString()
    }
    constructor(t, e) {
      if (((this[DH] = "ResourceMap"), t instanceof Ph))
        (this.d = new Map(t.d)), (this.e = e ?? Ph.c)
      else if (sat(t)) {
        ;(this.d = new Map()), (this.e = e ?? Ph.c)
        for (const [r, s] of t) this.set(r, s)
      } else (this.d = new Map()), (this.e = t ?? Ph.c)
    }
    set(t, e) {
      return this.d.set(this.e(t), new nat(t, e)), this
    }
    get(t) {
      return this.d.get(this.e(t))?.value
    }
    has(t) {
      return this.d.has(this.e(t))
    }
    get size() {
      return this.d.size
    }
    clear() {
      this.d.clear()
    }
    delete(t) {
      return this.d.delete(this.e(t))
    }
    forEach(t, e) {
      typeof e < "u" && (t = t.bind(e))
      for (const [r, s] of this.d) t(s.value, s.uri, this)
    }
    *values() {
      for (const t of this.d.values()) yield t.value
    }
    *keys() {
      for (const t of this.d.values()) yield t.uri
    }
    *entries() {
      for (const t of this.d.values()) yield [t.uri, t.value]
    }
    *[((DH = Symbol.toStringTag), Symbol.iterator)]() {
      for (const [, t] of this.d) yield [t.uri, t.value]
    }
  },
  AH = class {
    constructor(i, t) {
      ;(this[FH] = "ResourceSet"),
        !i || typeof i == "function"
          ? (this.c = new ei(i))
          : ((this.c = new ei(t)), i.forEach(this.add, this))
    }
    get size() {
      return this.c.size
    }
    add(i) {
      return this.c.set(i, i), this
    }
    clear() {
      this.c.clear()
    }
    delete(i) {
      return this.c.delete(i)
    }
    forEach(i, t) {
      this.c.forEach((e, r) => i.call(t, r, r, this))
    }
    has(i) {
      return this.c.has(i)
    }
    entries() {
      return this.c.entries()
    }
    keys() {
      return this.c.keys()
    }
    values() {
      return this.c.keys()
    }
    [((FH = Symbol.toStringTag), Symbol.iterator)]() {
      return this.keys()
    }
  },
  BH
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.AsOld = 1)] = "AsOld"),
    (i[(i.AsNew = 2)] = "AsNew")
})(BH || (BH = {}))
var aat = class {
    constructor() {
      ;(this[_H] = "LinkedMap"),
        (this.c = new Map()),
        (this.d = void 0),
        (this.e = void 0),
        (this.f = 0),
        (this.g = 0)
    }
    clear() {
      this.c.clear(),
        (this.d = void 0),
        (this.e = void 0),
        (this.f = 0),
        this.g++
    }
    isEmpty() {
      return !this.d && !this.e
    }
    get size() {
      return this.f
    }
    get first() {
      return this.d?.value
    }
    get last() {
      return this.e?.value
    }
    has(i) {
      return this.c.has(i)
    }
    get(i, t = 0) {
      const e = this.c.get(i)
      if (e) return t !== 0 && this.m(e, t), e.value
    }
    set(i, t, e = 0) {
      let r = this.c.get(i)
      if (r) (r.value = t), e !== 0 && this.m(r, e)
      else {
        switch (
          ((r = { key: i, value: t, next: void 0, previous: void 0 }), e)
        ) {
          case 0:
            this.k(r)
            break
          case 1:
            this.j(r)
            break
          case 2:
            this.k(r)
            break
          default:
            this.k(r)
            break
        }
        this.c.set(i, r), this.f++
      }
      return this
    }
    delete(i) {
      return !!this.remove(i)
    }
    remove(i) {
      const t = this.c.get(i)
      if (t) return this.c.delete(i), this.l(t), this.f--, t.value
    }
    shift() {
      if (!this.d && !this.e) return
      if (!this.d || !this.e) throw new Error("Invalid list")
      const i = this.d
      return this.c.delete(i.key), this.l(i), this.f--, i.value
    }
    forEach(i, t) {
      const e = this.g
      let r = this.d
      for (; r; ) {
        if (
          (t ? i.bind(t)(r.value, r.key, this) : i(r.value, r.key, this),
          this.g !== e)
        )
          throw new Error("LinkedMap got modified during iteration.")
        r = r.next
      }
    }
    keys() {
      const i = this,
        t = this.g
      let e = this.d
      const r = {
        [Symbol.iterator]() {
          return r
        },
        next() {
          if (i.g !== t)
            throw new Error("LinkedMap got modified during iteration.")
          if (e) {
            const s = { value: e.key, done: !1 }
            return (e = e.next), s
          } else return { value: void 0, done: !0 }
        },
      }
      return r
    }
    values() {
      const i = this,
        t = this.g
      let e = this.d
      const r = {
        [Symbol.iterator]() {
          return r
        },
        next() {
          if (i.g !== t)
            throw new Error("LinkedMap got modified during iteration.")
          if (e) {
            const s = { value: e.value, done: !1 }
            return (e = e.next), s
          } else return { value: void 0, done: !0 }
        },
      }
      return r
    }
    entries() {
      const i = this,
        t = this.g
      let e = this.d
      const r = {
        [Symbol.iterator]() {
          return r
        },
        next() {
          if (i.g !== t)
            throw new Error("LinkedMap got modified during iteration.")
          if (e) {
            const s = { value: [e.key, e.value], done: !1 }
            return (e = e.next), s
          } else return { value: void 0, done: !0 }
        },
      }
      return r
    }
    [((_H = Symbol.toStringTag), Symbol.iterator)]() {
      return this.entries()
    }
    h(i) {
      if (i >= this.size) return
      if (i === 0) {
        this.clear()
        return
      }
      let t = this.d,
        e = this.size
      for (; t && e > i; ) this.c.delete(t.key), (t = t.next), e--
      ;(this.d = t), (this.f = e), t && (t.previous = void 0), this.g++
    }
    i(i) {
      if (i >= this.size) return
      if (i === 0) {
        this.clear()
        return
      }
      let t = this.e,
        e = this.size
      for (; t && e > i; ) this.c.delete(t.key), (t = t.previous), e--
      ;(this.e = t), (this.f = e), t && (t.next = void 0), this.g++
    }
    j(i) {
      if (!this.d && !this.e) this.e = i
      else if (this.d) (i.next = this.d), (this.d.previous = i)
      else throw new Error("Invalid list")
      ;(this.d = i), this.g++
    }
    k(i) {
      if (!this.d && !this.e) this.d = i
      else if (this.e) (i.previous = this.e), (this.e.next = i)
      else throw new Error("Invalid list")
      ;(this.e = i), this.g++
    }
    l(i) {
      if (i === this.d && i === this.e) (this.d = void 0), (this.e = void 0)
      else if (i === this.d) {
        if (!i.next) throw new Error("Invalid list")
        ;(i.next.previous = void 0), (this.d = i.next)
      } else if (i === this.e) {
        if (!i.previous) throw new Error("Invalid list")
        ;(i.previous.next = void 0), (this.e = i.previous)
      } else {
        const t = i.next,
          e = i.previous
        if (!t || !e) throw new Error("Invalid list")
        ;(t.previous = e), (e.next = t)
      }
      ;(i.next = void 0), (i.previous = void 0), this.g++
    }
    m(i, t) {
      if (!this.d || !this.e) throw new Error("Invalid list")
      if (!(t !== 1 && t !== 2)) {
        if (t === 1) {
          if (i === this.d) return
          const e = i.next,
            r = i.previous
          i === this.e
            ? ((r.next = void 0), (this.e = r))
            : ((e.previous = r), (r.next = e)),
            (i.previous = void 0),
            (i.next = this.d),
            (this.d.previous = i),
            (this.d = i),
            this.g++
        } else if (t === 2) {
          if (i === this.e) return
          const e = i.next,
            r = i.previous
          i === this.d
            ? ((e.previous = void 0), (this.d = e))
            : ((e.previous = r), (r.next = e)),
            (i.next = void 0),
            (i.previous = this.e),
            (this.e.next = i),
            (this.e = i),
            this.g++
        }
      }
    }
    toJSON() {
      const i = []
      return (
        this.forEach((t, e) => {
          i.push([e, t])
        }),
        i
      )
    }
    fromJSON(i) {
      this.clear()
      for (const [t, e] of i) this.set(t, e)
    }
  },
  oat = class extends aat {
    constructor(i, t = 1) {
      super(), (this.n = i), (this.o = Math.min(Math.max(0, t), 1))
    }
    get limit() {
      return this.n
    }
    set limit(i) {
      ;(this.n = i), this.p()
    }
    get ratio() {
      return this.o
    }
    set ratio(i) {
      ;(this.o = Math.min(Math.max(0, i), 1)), this.p()
    }
    get(i, t = 2) {
      return super.get(i, t)
    }
    peek(i) {
      return super.get(i, 0)
    }
    set(i, t) {
      return super.set(i, t, 2), this
    }
    p() {
      this.size > this.n && this.q(Math.round(this.n * this.o))
    }
  },
  oB = class extends oat {
    constructor(i, t = 1) {
      super(i, t)
    }
    q(i) {
      this.h(i)
    }
    set(i, t) {
      return super.set(i, t), this.p(), this
    }
  },
  OH = class {
    constructor() {
      this.c = new Map()
    }
    add(i, t) {
      let e = this.c.get(i)
      e || ((e = new Set()), this.c.set(i, e)), e.add(t)
    }
    delete(i, t) {
      const e = this.c.get(i)
      e && (e.delete(t), e.size === 0 && this.c.delete(i))
    }
    forEach(i, t) {
      const e = this.c.get(i)
      e && e.forEach(t)
    }
    get(i) {
      const t = this.c.get(i)
      return t || new Set()
    }
  }
function cB(i, t) {
  const e = this
  let r = !1,
    s
  return function () {
    if (r) return s
    if (((r = !0), t))
      try {
        s = i.apply(e, arguments)
      } finally {
        t()
      }
    else s = i.apply(e, arguments)
    return s
  }
}
var Yi
;(function (i) {
  function t(U) {
    return U && typeof U == "object" && typeof U[Symbol.iterator] == "function"
  }
  i.is = t
  const e = Object.freeze([])
  function r() {
    return e
  }
  i.empty = r
  function* s(U) {
    yield U
  }
  i.single = s
  function a(U) {
    return t(U) ? U : s(U)
  }
  i.wrap = a
  function o(U) {
    return U || e
  }
  i.from = o
  function* c(U) {
    for (let q = U.length - 1; q >= 0; q--) yield U[q]
  }
  i.reverse = c
  function u(U) {
    return !U || U[Symbol.iterator]().next().done === !0
  }
  i.isEmpty = u
  function l(U) {
    return U[Symbol.iterator]().next().value
  }
  i.first = l
  function m(U, q) {
    let V = 0
    for (const lt of U) if (q(lt, V++)) return !0
    return !1
  }
  i.some = m
  function h(U, q) {
    for (const V of U) if (q(V)) return V
  }
  i.find = h
  function* p(U, q) {
    for (const V of U) q(V) && (yield V)
  }
  i.filter = p
  function* g(U, q) {
    let V = 0
    for (const lt of U) yield q(lt, V++)
  }
  i.map = g
  function* w(U, q) {
    let V = 0
    for (const lt of U) yield* q(lt, V++)
  }
  i.flatMap = w
  function* T(...U) {
    for (const q of U) yield* q
  }
  i.concat = T
  function b(U, q, V) {
    let lt = V
    for (const at of U) lt = q(lt, at)
    return lt
  }
  i.reduce = b
  function* N(U, q, V = U.length) {
    for (
      q < -U.length && (q = 0),
        q < 0 && (q += U.length),
        V < 0 ? (V += U.length) : V > U.length && (V = U.length);
      q < V;
      q++
    )
      yield U[q]
  }
  i.slice = N
  function $(U, q = Number.POSITIVE_INFINITY) {
    const V = []
    if (q === 0) return [V, U]
    const lt = U[Symbol.iterator]()
    for (let at = 0; at < q; at++) {
      const et = lt.next()
      if (et.done) return [V, i.empty()]
      V.push(et.value)
    }
    return [
      V,
      {
        [Symbol.iterator]() {
          return lt
        },
      },
    ]
  }
  i.consume = $
  async function L(U) {
    const q = []
    for await (const V of U) q.push(V)
    return Promise.resolve(q)
  }
  i.asyncToArray = L
})(Yi || (Yi = {}))
var cat = !1,
  ao = null,
  m8t = class vnt {
    constructor() {
      this.b = new Map()
    }
    static {
      this.a = 0
    }
    c(t) {
      let e = this.b.get(t)
      return (
        e ||
          ((e = {
            parent: null,
            source: null,
            isSingleton: !1,
            value: t,
            idx: vnt.a++,
          }),
          this.b.set(t, e)),
        e
      )
    }
    trackDisposable(t) {
      const e = this.c(t)
      e.source || (e.source = new Error().stack)
    }
    setParent(t, e) {
      const r = this.c(t)
      r.parent = e
    }
    markAsDisposed(t) {
      this.b.delete(t)
    }
    markAsSingleton(t) {
      this.c(t).isSingleton = !0
    }
    f(t, e) {
      const r = e.get(t)
      if (r) return r
      const s = t.parent ? this.f(this.c(t.parent), e) : t
      return e.set(t, s), s
    }
    getTrackedDisposables() {
      const t = new Map()
      return [...this.b.entries()]
        .filter(([, r]) => r.source !== null && !this.f(r, t).isSingleton)
        .flatMap(([r]) => r)
    }
    computeLeakingDisposables(t = 10, e) {
      let r
      if (e) r = e
      else {
        const u = new Map(),
          l = [...this.b.values()].filter(
            (h) => h.source !== null && !this.f(h, u).isSingleton,
          )
        if (l.length === 0) return
        const m = new Set(l.map((h) => h.value))
        if (
          ((r = l.filter((h) => !(h.parent && m.has(h.parent)))),
          r.length === 0)
        )
          throw new Error("There are cyclic diposable chains!")
      }
      if (!r) return
      function s(u) {
        function l(h, p) {
          for (
            ;
            h.length > 0 &&
            p.some((g) => (typeof g == "string" ? g === h[0] : h[0].match(g)));

          )
            h.shift()
        }
        const m = u.source
          .split(
            `
`,
          )
          .map((h) => h.trim().replace("at ", ""))
          .filter((h) => h !== "")
        return (
          l(m, [
            "Error",
            /^trackDisposable \(.*\)$/,
            /^DisposableTracker.trackDisposable \(.*\)$/,
          ]),
          m.reverse()
        )
      }
      const a = new OH()
      for (const u of r) {
        const l = s(u)
        for (let m = 0; m <= l.length; m++)
          a.add(
            l.slice(0, m).join(`
`),
            u,
          )
      }
      r.sort(tat((u) => u.idx, eat))
      let o = "",
        c = 0
      for (const u of r.slice(0, t)) {
        c++
        const l = s(u),
          m = []
        for (let h = 0; h < l.length; h++) {
          let p = l[h]
          p = `(shared with ${
            a.get(
              l.slice(0, h + 1).join(`
`),
            ).size
          }/${r.length} leaks) at ${p}`
          const w = a.get(
              l.slice(0, h).join(`
`),
            ),
            T = RH(
              [...w].map((b) => s(b)[h]),
              (b) => b,
            )
          delete T[l[h]]
          for (const [b, N] of Object.entries(T))
            m.unshift(
              `    - stacktraces of ${N.length} other leaks continue with ${b}`,
            )
          m.unshift(p)
        }
        o += `


==================== Leaking disposable ${c}/${r.length}: ${u.value.constructor.name} ====================
${m.join(`
`)}
============================================================

`
      }
      return (
        r.length > t &&
          (o += `


... and ${r.length - t} more leaking disposables

`),
        { leaks: r, details: o }
      )
    }
  }
function uat(i) {
  ao = i
}
if (cat) {
  const i = "__is_disposable_tracked__"
  uat(
    new (class {
      trackDisposable(t) {
        const e = new Error("Potentially leaked disposable").stack
        setTimeout(() => {
          t[i] || console.log(e)
        }, 3e3)
      }
      setParent(t, e) {
        if (t && t !== dt.None)
          try {
            t[i] = !0
          } catch {}
      }
      markAsDisposed(t) {
        if (t && t !== dt.None)
          try {
            t[i] = !0
          } catch {}
      }
      markAsSingleton(t) {}
    })(),
  )
}
function oo(i) {
  return ao?.trackDisposable(i), i
}
function co(i) {
  ao?.markAsDisposed(i)
}
function bu(i, t) {
  ao?.setParent(i, t)
}
function lat(i, t) {
  if (ao) for (const e of i) ao.setParent(e, t)
}
function dat(i) {
  return (
    typeof i == "object" &&
    i !== null &&
    typeof i.dispose == "function" &&
    i.dispose.length === 0
  )
}
function pn(i) {
  if (Yi.is(i)) {
    const t = []
    for (const e of i)
      if (e)
        try {
          e.dispose()
        } catch (r) {
          t.push(r)
        }
    if (t.length === 1) throw t[0]
    if (t.length > 1)
      throw new AggregateError(t, "Encountered errors while disposing of store")
    return Array.isArray(i) ? [] : i
  } else if (i) return i.dispose(), i
}
function qH(...i) {
  const t = it(() => pn(i))
  return lat(i, t), t
}
function it(i) {
  const t = oo({
    dispose: cB(() => {
      co(t), i()
    }),
  })
  return t
}
var bt = class wnt {
    static {
      this.DISABLE_DISPOSED_WARNING = !1
    }
    constructor() {
      ;(this.f = new Set()), (this.g = !1), oo(this)
    }
    dispose() {
      this.g || (co(this), (this.g = !0), this.clear())
    }
    get isDisposed() {
      return this.g
    }
    clear() {
      if (this.f.size !== 0)
        try {
          pn(this.f)
        } finally {
          this.f.clear()
        }
    }
    add(t) {
      if (!t) return t
      if (t === this) throw new Error("Cannot register a disposable on itself!")
      return (
        bu(t, this),
        this.g
          ? wnt.DISABLE_DISPOSED_WARNING ||
            console.warn(
              new Error(
                "Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!",
              ).stack,
            )
          : this.f.add(t),
        t
      )
    }
    delete(t) {
      if (t) {
        if (t === this)
          throw new Error("Cannot dispose a disposable on itself!")
        this.f.delete(t), t.dispose()
      }
    }
    deleteAndLeak(t) {
      t && this.f.has(t) && (this.f.delete(t), bu(t, null))
    }
  },
  dt = class {
    static {
      this.None = Object.freeze({ dispose() {} })
    }
    constructor() {
      ;(this.B = new bt()), oo(this), bu(this.B, this)
    }
    dispose() {
      co(this), this.B.dispose()
    }
    D(i) {
      if (i === this) throw new Error("Cannot register a disposable on itself!")
      return this.B.add(i)
    }
  },
  Zn = class {
    constructor() {
      ;(this.b = !1), oo(this)
    }
    get value() {
      return this.b ? void 0 : this.a
    }
    set value(i) {
      this.b ||
        i === this.a ||
        (this.a?.dispose(), i && bu(i, this), (this.a = i))
    }
    clear() {
      this.value = void 0
    }
    dispose() {
      ;(this.b = !0), co(this), this.a?.dispose(), (this.a = void 0)
    }
    clearAndLeak() {
      const i = this.a
      return (this.a = void 0), i && bu(i, null), i
    }
  },
  uB = class {
    constructor() {
      ;(this.a = new Map()), (this.b = !1), oo(this)
    }
    dispose() {
      co(this), (this.b = !0), this.clearAndDisposeAll()
    }
    clearAndDisposeAll() {
      if (this.a.size)
        try {
          pn(this.a.values())
        } finally {
          this.a.clear()
        }
    }
    has(i) {
      return this.a.has(i)
    }
    get size() {
      return this.a.size
    }
    get(i) {
      return this.a.get(i)
    }
    set(i, t, e = !1) {
      this.b &&
        console.warn(
          new Error(
            "Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!",
          ).stack,
        ),
        e || this.a.get(i)?.dispose(),
        this.a.set(i, t)
    }
    deleteAndDispose(i) {
      this.a.get(i)?.dispose(), this.a.delete(i)
    }
    deleteAndLeak(i) {
      const t = this.a.get(i)
      return this.a.delete(i), t
    }
    keys() {
      return this.a.keys()
    }
    values() {
      return this.a.values()
    }
    [Symbol.iterator]() {
      return this.a[Symbol.iterator]()
    }
  }
function mat(i, t) {
  return new Promise((e, r) => {
    const s = []
    hat(i, {
      onData: (a) => {
        t && s.push(a)
      },
      onError: (a) => {
        t ? r(a) : e(void 0)
      },
      onEnd: () => {
        e(t ? t(s) : void 0)
      },
    })
  })
}
function hat(i, t, e) {
  i.on("error", (r) => {
    e?.isCancellationRequested || t.onError(r)
  }),
    i.on("end", () => {
      e?.isCancellationRequested || t.onEnd()
    }),
    i.on("data", (r) => {
      e?.isCancellationRequested || t.onData(r)
    })
}
var MF = typeof Buffer < "u",
  fat = new qi(() => new Uint8Array(256)),
  lB,
  dB,
  Et = class gr {
    static alloc(t) {
      return MF ? new gr(Buffer.allocUnsafe(t)) : new gr(new Uint8Array(t))
    }
    static wrap(t) {
      return (
        MF &&
          !Buffer.isBuffer(t) &&
          (t = Buffer.from(t.buffer, t.byteOffset, t.byteLength)),
        new gr(t)
      )
    }
    static fromString(t, e) {
      return !(e?.dontUseNodeBuffer || !1) && MF
        ? new gr(Buffer.from(t))
        : (lB || (lB = new TextEncoder()), new gr(lB.encode(t)))
    }
    static fromByteArray(t) {
      const e = gr.alloc(t.length)
      for (let r = 0, s = t.length; r < s; r++) e.buffer[r] = t[r]
      return e
    }
    static concat(t, e) {
      if (typeof e > "u") {
        e = 0
        for (let a = 0, o = t.length; a < o; a++) e += t[a].byteLength
      }
      const r = gr.alloc(e)
      let s = 0
      for (let a = 0, o = t.length; a < o; a++) {
        const c = t[a]
        r.set(c, s), (s += c.byteLength)
      }
      return r
    }
    constructor(t) {
      ;(this.buffer = t), (this.byteLength = this.buffer.byteLength)
    }
    clone() {
      const t = gr.alloc(this.byteLength)
      return t.set(this), t
    }
    toString() {
      return MF
        ? this.buffer.toString()
        : (dB || (dB = new TextDecoder()), dB.decode(this.buffer))
    }
    slice(t, e) {
      return new gr(this.buffer.subarray(t, e))
    }
    set(t, e) {
      if (t instanceof gr) this.buffer.set(t.buffer, e)
      else if (t instanceof Uint8Array) this.buffer.set(t, e)
      else if (t instanceof ArrayBuffer) this.buffer.set(new Uint8Array(t), e)
      else if (ArrayBuffer.isView(t))
        this.buffer.set(new Uint8Array(t.buffer, t.byteOffset, t.byteLength), e)
      else throw new Error("Unknown argument 'array'")
    }
    readUInt32BE(t) {
      return HF(this.buffer, t)
    }
    writeUInt32BE(t, e) {
      WF(this.buffer, t, e)
    }
    readUInt32LE(t) {
      return wat(this.buffer, t)
    }
    writeUInt32LE(t, e) {
      yat(this.buffer, t, e)
    }
    readUInt8(t) {
      return Tat(this.buffer, t)
    }
    writeUInt8(t, e) {
      kat(this.buffer, t, e)
    }
    indexOf(t, e = 0) {
      return pat(this.buffer, t instanceof gr ? t.buffer : t, e)
    }
  }
function pat(i, t, e = 0) {
  const r = t.byteLength,
    s = i.byteLength
  if (r === 0) return 0
  if (r === 1) return i.indexOf(t[0])
  if (r > s - e) return -1
  const a = fat.value
  a.fill(t.length)
  for (let l = 0; l < t.length; l++) a[t[l]] = t.length - l - 1
  let o = e + t.length - 1,
    c = o,
    u = -1
  for (; o < s; )
    if (i[o] === t[c]) {
      if (c === 0) {
        u = o
        break
      }
      o--, c--
    } else (o += Math.max(t.length - c, a[i[o]])), (c = t.length - 1)
  return u
}
function gat(i, t) {
  return ((i[t + 0] << 0) >>> 0) | ((i[t + 1] << 8) >>> 0)
}
function vat(i, t, e) {
  ;(i[e + 0] = t & 255), (t = t >>> 8), (i[e + 1] = t & 255)
}
function HF(i, t) {
  return i[t] * 2 ** 24 + i[t + 1] * 2 ** 16 + i[t + 2] * 2 ** 8 + i[t + 3]
}
function WF(i, t, e) {
  ;(i[e + 3] = t),
    (t = t >>> 8),
    (i[e + 2] = t),
    (t = t >>> 8),
    (i[e + 1] = t),
    (t = t >>> 8),
    (i[e] = t)
}
function wat(i, t) {
  return (
    ((i[t + 0] << 0) >>> 0) |
    ((i[t + 1] << 8) >>> 0) |
    ((i[t + 2] << 16) >>> 0) |
    ((i[t + 3] << 24) >>> 0)
  )
}
function yat(i, t, e) {
  ;(i[e + 0] = t & 255),
    (t = t >>> 8),
    (i[e + 1] = t & 255),
    (t = t >>> 8),
    (i[e + 2] = t & 255),
    (t = t >>> 8),
    (i[e + 3] = t & 255)
}
function Tat(i, t) {
  return i[t]
}
function kat(i, t, e) {
  i[e] = t
}
function Sat(i) {
  return mat(i, (t) => Et.concat(t))
}
function jF(i) {
  let t = 0,
    e = 0,
    r = 0
  const s = new Uint8Array(Math.floor((i.length / 4) * 3)),
    a = (c) => {
      switch (e) {
        case 3:
          ;(s[r++] = t | c), (e = 0)
          break
        case 2:
          ;(s[r++] = t | (c >>> 2)), (t = c << 6), (e = 3)
          break
        case 1:
          ;(s[r++] = t | (c >>> 4)), (t = c << 4), (e = 2)
          break
        default:
          ;(t = c << 2), (e = 1)
      }
    }
  for (let c = 0; c < i.length; c++) {
    const u = i.charCodeAt(c)
    if (u >= 65 && u <= 90) a(u - 65)
    else if (u >= 97 && u <= 122) a(u - 97 + 26)
    else if (u >= 48 && u <= 57) a(u - 48 + 52)
    else if (u === 43 || u === 45) a(62)
    else if (u === 47 || u === 95) a(63)
    else {
      if (u === 61) break
      throw new SyntaxError(`Unexpected base64 character ${i[c]}`)
    }
  }
  const o = r
  for (; e > 0; ) a(0)
  return Et.wrap(s).slice(0, o)
}
var bat = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  Eat = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
function VF({ buffer: i }, t = !0, e = !1) {
  const r = e ? Eat : bat
  let s = ""
  const a = i.byteLength % 3
  let o = 0
  for (; o < i.byteLength - a; o += 3) {
    const c = i[o + 0],
      u = i[o + 1],
      l = i[o + 2]
    ;(s += r[c >>> 2]),
      (s += r[((c << 4) | (u >>> 4)) & 63]),
      (s += r[((u << 2) | (l >>> 6)) & 63]),
      (s += r[l & 63])
  }
  if (a === 1) {
    const c = i[o + 0]
    ;(s += r[c >>> 2]), (s += r[(c << 4) & 63]), t && (s += "==")
  } else if (a === 2) {
    const c = i[o + 0],
      u = i[o + 1]
    ;(s += r[c >>> 2]),
      (s += r[((c << 4) | (u >>> 4)) & 63]),
      (s += r[(u << 2) & 63]),
      t && (s += "=")
  }
  return s
}
var Je = class _8 {
    static {
      this.Undefined = new _8(void 0)
    }
    constructor(t) {
      ;(this.element = t),
        (this.next = _8.Undefined),
        (this.prev = _8.Undefined)
    }
  },
  Eu = class {
    constructor() {
      ;(this.a = Je.Undefined), (this.b = Je.Undefined), (this.c = 0)
    }
    get size() {
      return this.c
    }
    get first() {
      return this.a
    }
    isEmpty() {
      return this.a === Je.Undefined
    }
    clear() {
      let i = this.a
      for (; i !== Je.Undefined; ) {
        const t = i.next
        ;(i.prev = Je.Undefined), (i.next = Je.Undefined), (i = t)
      }
      ;(this.a = Je.Undefined), (this.b = Je.Undefined), (this.c = 0)
    }
    unshift(i) {
      return this.d(i, !1)
    }
    push(i) {
      return this.d(i, !0)
    }
    d(i, t) {
      const e = new Je(i)
      if (this.a === Je.Undefined) (this.a = e), (this.b = e)
      else if (t) {
        const s = this.b
        ;(this.b = e), (e.prev = s), (s.next = e)
      } else {
        const s = this.a
        ;(this.a = e), (e.next = s), (s.prev = e)
      }
      this.c += 1
      let r = !1
      return () => {
        r || ((r = !0), this.e(e))
      }
    }
    shift() {
      if (this.a !== Je.Undefined) {
        const i = this.a.element
        return this.e(this.a), i
      }
    }
    pop() {
      if (this.b !== Je.Undefined) {
        const i = this.b.element
        return this.e(this.b), i
      }
    }
    remove(i) {
      this.e(i)
    }
    e(i) {
      if (i.prev !== Je.Undefined && i.next !== Je.Undefined) {
        const t = i.prev
        ;(t.next = i.next), (i.next.prev = t)
      } else
        i.prev === Je.Undefined && i.next === Je.Undefined
          ? ((this.a = Je.Undefined), (this.b = Je.Undefined))
          : i.next === Je.Undefined
            ? ((this.b = this.b.prev), (this.b.next = Je.Undefined))
            : i.prev === Je.Undefined &&
              ((this.a = this.a.next), (this.a.prev = Je.Undefined))
      this.c -= 1
    }
    *[Symbol.iterator]() {
      let i = this.a
      for (; i !== Je.Undefined; ) yield i.element, (i = i.next)
    }
  },
  Iat =
    globalThis.performance && typeof globalThis.performance.now == "function",
  Ys = class ynt {
    static create(t) {
      return new ynt(t)
    }
    constructor(t) {
      ;(this.c =
        Iat && t === !1
          ? Date.now
          : globalThis.performance.now.bind(globalThis.performance)),
        (this.a = this.c()),
        (this.b = -1)
    }
    stop() {
      this.b = this.c()
    }
    reset() {
      ;(this.a = this.c()), (this.b = -1)
    }
    elapsed() {
      return this.b !== -1 ? this.b - this.a : this.c() - this.a
    }
  },
  Pat = !1,
  UH = !1,
  Nat = !1,
  Ee
;(function (i) {
  i.None = () => dt.None
  function t(G) {
    if (Nat) {
      const { onDidAddListener: W } = G,
        tt = mB.create()
      let X = 0
      G.onDidAddListener = () => {
        ++X === 2 &&
          (console.warn(
            "snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here",
          ),
          tt.print()),
          W?.()
      }
    }
  }
  function e(G, W) {
    return g(G, () => {}, 0, void 0, !0, void 0, W)
  }
  i.defer = e
  function r(G) {
    return (W, tt = null, X) => {
      let Z = !1,
        St
      return (
        (St = G(
          (Dt) => {
            if (!Z) return St ? St.dispose() : (Z = !0), W.call(tt, Dt)
          },
          null,
          X,
        )),
        Z && St.dispose(),
        St
      )
    }
  }
  i.once = r
  function s(G, W) {
    return i.once(i.filter(G, W))
  }
  i.onceIf = s
  function a(G, W, tt) {
    return h((X, Z = null, St) => G((Dt) => X.call(Z, W(Dt)), null, St), tt)
  }
  i.map = a
  function o(G, W, tt) {
    return h(
      (X, Z = null, St) =>
        G(
          (Dt) => {
            W(Dt), X.call(Z, Dt)
          },
          null,
          St,
        ),
      tt,
    )
  }
  i.forEach = o
  function c(G, W, tt) {
    return h(
      (X, Z = null, St) => G((Dt) => W(Dt) && X.call(Z, Dt), null, St),
      tt,
    )
  }
  i.filter = c
  function u(G) {
    return G
  }
  i.signal = u
  function l(...G) {
    return (W, tt = null, X) => {
      const Z = qH(...G.map((St) => St((Dt) => W.call(tt, Dt))))
      return p(Z, X)
    }
  }
  i.any = l
  function m(G, W, tt, X) {
    let Z = tt
    return a(G, (St) => ((Z = W(Z, St)), Z), X)
  }
  i.reduce = m
  function h(G, W) {
    let tt
    const X = {
      onWillAddFirstListener() {
        tt = G(Z.fire, Z)
      },
      onDidRemoveLastListener() {
        tt?.dispose()
      },
    }
    W || t(X)
    const Z = new C(X)
    return W?.add(Z), Z.event
  }
  function p(G, W) {
    return W instanceof Array ? W.push(G) : W && W.add(G), G
  }
  function g(G, W, tt = 100, X = !1, Z = !1, St, Dt) {
    let Pt,
      ie,
      Ze,
      Te = 0,
      si
    const wi = {
      leakWarningThreshold: St,
      onWillAddFirstListener() {
        Pt = G((mn) => {
          Te++,
            (ie = W(ie, mn)),
            X && !Ze && (le.fire(ie), (ie = void 0)),
            (si = () => {
              const eo = ie
              ;(ie = void 0),
                (Ze = void 0),
                (!X || Te > 1) && le.fire(eo),
                (Te = 0)
            }),
            typeof tt == "number"
              ? (clearTimeout(Ze), (Ze = setTimeout(si, tt)))
              : Ze === void 0 && ((Ze = 0), queueMicrotask(si))
        })
      },
      onWillRemoveListener() {
        Z && Te > 0 && si?.()
      },
      onDidRemoveLastListener() {
        ;(si = void 0), Pt.dispose()
      },
    }
    Dt || t(wi)
    const le = new C(wi)
    return Dt?.add(le), le.event
  }
  i.debounce = g
  function w(G, W = 0, tt) {
    return i.debounce(
      G,
      (X, Z) => (X ? (X.push(Z), X) : [Z]),
      W,
      void 0,
      !0,
      void 0,
      tt,
    )
  }
  i.accumulate = w
  function T(G, W = (X, Z) => X === Z, tt) {
    let X = !0,
      Z
    return c(
      G,
      (St) => {
        const Dt = X || !W(St, Z)
        return (X = !1), (Z = St), Dt
      },
      tt,
    )
  }
  i.latch = T
  function b(G, W, tt) {
    return [i.filter(G, W, tt), i.filter(G, (X) => !W(X), tt)]
  }
  i.split = b
  function N(G, W = !1, tt = [], X) {
    let Z = tt.slice(),
      St = G((ie) => {
        Z ? Z.push(ie) : Pt.fire(ie)
      })
    X && X.add(St)
    const Dt = () => {
        Z?.forEach((ie) => Pt.fire(ie)), (Z = null)
      },
      Pt = new C({
        onWillAddFirstListener() {
          St || ((St = G((ie) => Pt.fire(ie))), X && X.add(St))
        },
        onDidAddFirstListener() {
          Z && (W ? setTimeout(Dt) : Dt())
        },
        onDidRemoveLastListener() {
          St && St.dispose(), (St = null)
        },
      })
    return X && X.add(Pt), Pt.event
  }
  i.buffer = N
  function $(G, W) {
    return (X, Z, St) => {
      const Dt = W(new U())
      return G(
        function (Pt) {
          const ie = Dt.evaluate(Pt)
          ie !== L && X.call(Z, ie)
        },
        void 0,
        St,
      )
    }
  }
  i.chain = $
  const L = Symbol("HaltChainable")
  class U {
    constructor() {
      this.f = []
    }
    map(W) {
      return this.f.push(W), this
    }
    forEach(W) {
      return this.f.push((tt) => (W(tt), tt)), this
    }
    filter(W) {
      return this.f.push((tt) => (W(tt) ? tt : L)), this
    }
    reduce(W, tt) {
      let X = tt
      return this.f.push((Z) => ((X = W(X, Z)), X)), this
    }
    latch(W = (tt, X) => tt === X) {
      let tt = !0,
        X
      return (
        this.f.push((Z) => {
          const St = tt || !W(Z, X)
          return (tt = !1), (X = Z), St ? Z : L
        }),
        this
      )
    }
    evaluate(W) {
      for (const tt of this.f) if (((W = tt(W)), W === L)) break
      return W
    }
  }
  function q(G, W, tt = (X) => X) {
    const X = (...Pt) => Dt.fire(tt(...Pt)),
      Z = () => G.on(W, X),
      St = () => G.removeListener(W, X),
      Dt = new C({ onWillAddFirstListener: Z, onDidRemoveLastListener: St })
    return Dt.event
  }
  i.fromNodeEventEmitter = q
  function V(G, W, tt = (X) => X) {
    const X = (...Pt) => Dt.fire(tt(...Pt)),
      Z = () => G.addEventListener(W, X),
      St = () => G.removeEventListener(W, X),
      Dt = new C({ onWillAddFirstListener: Z, onDidRemoveLastListener: St })
    return Dt.event
  }
  i.fromDOMEventEmitter = V
  function lt(G) {
    return new Promise((W) => r(G)(W))
  }
  i.toPromise = lt
  function at(G) {
    const W = new C()
    return (
      G.then(
        (tt) => {
          W.fire(tt)
        },
        () => {
          W.fire(void 0)
        },
      ).finally(() => {
        W.dispose()
      }),
      W.event
    )
  }
  i.fromPromise = at
  function et(G, W) {
    return G((tt) => W.fire(tt))
  }
  i.forward = et
  function wt(G, W, tt) {
    return W(tt), G((X) => W(X))
  }
  i.runAndSubscribe = wt
  class zt {
    constructor(W, tt) {
      ;(this._observable = W), (this.f = 0), (this.g = !1)
      const X = {
        onWillAddFirstListener: () => {
          W.addObserver(this), this._observable.reportChanges()
        },
        onDidRemoveLastListener: () => {
          W.removeObserver(this)
        },
      }
      tt || t(X), (this.emitter = new C(X)), tt && tt.add(this.emitter)
    }
    beginUpdate(W) {
      this.f++
    }
    handlePossibleChange(W) {}
    handleChange(W, tt) {
      this.g = !0
    }
    endUpdate(W) {
      this.f--,
        this.f === 0 &&
          (this._observable.reportChanges(),
          this.g && ((this.g = !1), this.emitter.fire(this._observable.get())))
    }
  }
  function Ct(G, W) {
    return new zt(G, W).emitter.event
  }
  i.fromObservable = Ct
  function be(G) {
    return (W, tt, X) => {
      let Z = 0,
        St = !1
      const Dt = {
        beginUpdate() {
          Z++
        },
        endUpdate() {
          Z--, Z === 0 && (G.reportChanges(), St && ((St = !1), W.call(tt)))
        },
        handlePossibleChange() {},
        handleChange() {
          St = !0
        },
      }
      G.addObserver(Dt), G.reportChanges()
      const Pt = {
        dispose() {
          G.removeObserver(Dt)
        },
      }
      return X instanceof bt ? X.add(Pt) : Array.isArray(X) && X.push(Pt), Pt
    }
  }
  i.fromObservableLight = be
})(Ee || (Ee = {}))
var $at = class sH {
    static {
      this.all = new Set()
    }
    static {
      this.f = 0
    }
    constructor(t) {
      ;(this.listenerCount = 0),
        (this.invocationCount = 0),
        (this.elapsedOverall = 0),
        (this.durations = []),
        (this.name = `${t}_${sH.f++}`),
        sH.all.add(this)
    }
    start(t) {
      ;(this.g = new Ys()), (this.listenerCount = t)
    }
    stop() {
      if (this.g) {
        const t = this.g.elapsed()
        this.durations.push(t),
          (this.elapsedOverall += t),
          (this.invocationCount += 1),
          (this.g = void 0)
      }
    }
  },
  MH = -1,
  xat = class Tnt {
    static {
      this.f = 1
    }
    constructor(t, e, r = (Tnt.f++).toString(16).padStart(3, "0")) {
      ;(this.j = t), (this.threshold = e), (this.name = r), (this.h = 0)
    }
    dispose() {
      this.g?.clear()
    }
    check(t, e) {
      const r = this.threshold
      if (r <= 0 || e < r) return
      this.g || (this.g = new Map())
      const s = this.g.get(t.value) || 0
      if ((this.g.set(t.value, s + 1), (this.h -= 1), this.h <= 0)) {
        this.h = r * 0.5
        const [a, o] = this.getMostFrequentStack(),
          c = `[${this.name}] potential listener LEAK detected, having ${e} listeners already. MOST frequent listener (${o}):`
        console.warn(c), console.warn(a)
        const u = new Jat(c, a)
        this.j(u)
      }
      return () => {
        const a = this.g.get(t.value) || 0
        this.g.set(t.value, a - 1)
      }
    }
    getMostFrequentStack() {
      if (!this.g) return
      let t,
        e = 0
      for (const [r, s] of this.g) (!t || e < s) && ((t = [r, s]), (e = s))
      return t
    }
  },
  mB = class knt {
    static create() {
      const t = new Error()
      return new knt(t.stack ?? "")
    }
    constructor(t) {
      this.value = t
    }
    print() {
      console.warn(
        this.value
          .split(
            `
`,
          )
          .slice(2).join(`
`),
      )
    }
  },
  Jat = class extends Error {
    constructor(i, t) {
      super(i), (this.name = "ListenerLeakError"), (this.stack = t)
    }
  },
  Cat = class extends Error {
    constructor(i, t) {
      super(i), (this.name = "ListenerRefusalError"), (this.stack = t)
    }
  },
  Lat = 0,
  GF = class {
    constructor(i) {
      ;(this.value = i), (this.id = Lat++)
    }
  },
  Rat = 2,
  HH = (i, t) => {
    if (i instanceof GF) t(i)
    else
      for (let e = 0; e < i.length; e++) {
        const r = i[e]
        r && t(r)
      }
  },
  zF
if (Pat) {
  const i = []
  setInterval(() => {
    i.length !== 0 &&
      (console.warn(
        "[LEAKING LISTENERS] GC'ed these listeners that were NOT yet disposed:",
      ),
      console.warn(
        i.join(`
`),
      ),
      (i.length = 0))
  }, 3e3),
    (zF = new FinalizationRegistry((t) => {
      typeof t == "string" && i.push(t)
    }))
}
var C = class {
    constructor(i) {
      ;(this.z = 0),
        (this.f = i),
        (this.g =
          MH > 0 || this.f?.leakWarningThreshold
            ? new xat(
                i?.onListenerError ?? Ui,
                this.f?.leakWarningThreshold ?? MH,
              )
            : void 0),
        (this.j = this.f?._profName ? new $at(this.f._profName) : void 0),
        (this.w = this.f?.deliveryQueue)
    }
    dispose() {
      if (!this.m) {
        if (
          ((this.m = !0), this.w?.current === this && this.w.reset(), this.u)
        ) {
          if (UH) {
            const i = this.u
            queueMicrotask(() => {
              HH(i, (t) => t.stack?.print())
            })
          }
          ;(this.u = void 0), (this.z = 0)
        }
        this.f?.onDidRemoveLastListener?.(), this.g?.dispose()
      }
    }
    get event() {
      return (
        (this.q ??= (i, t, e) => {
          if (this.g && this.z > this.g.threshold ** 2) {
            const c = `[${this.g.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this.z} vs ${this.g.threshold})`
            console.warn(c)
            const u = this.g.getMostFrequentStack() ?? ["UNKNOWN stack", -1],
              l = new Cat(
                `${c}. HINT: Stack shows most frequent listener (${u[1]}-times)`,
                u[0],
              )
            return (this.f?.onListenerError || Ui)(l), dt.None
          }
          if (this.m) return dt.None
          t && (i = i.bind(t))
          const r = new GF(i)
          let s, a
          this.g &&
            this.z >= Math.ceil(this.g.threshold * 0.2) &&
            ((r.stack = mB.create()), (s = this.g.check(r.stack, this.z + 1))),
            UH && (r.stack = a ?? mB.create()),
            this.u
              ? this.u instanceof GF
                ? ((this.w ??= new Dat()), (this.u = [this.u, r]))
                : this.u.push(r)
              : (this.f?.onWillAddFirstListener?.(this),
                (this.u = r),
                this.f?.onDidAddFirstListener?.(this)),
            this.f?.onDidAddListener?.(this),
            this.z++
          const o = it(() => {
            zF?.unregister(o), s?.(), this.A(r)
          })
          if (
            (e instanceof bt ? e.add(o) : Array.isArray(e) && e.push(o), zF)
          ) {
            const c = new Error().stack
                .split(
                  `
`,
                )
                .slice(2, 3)
                .join(
                  `
`,
                )
                .trim(),
              u = /(file:|vscode-file:\/\/vscode-app)?(\/[^:]*:\d+:\d+)/.exec(c)
            zF.register(o, u?.[2] ?? c, o)
          }
          return o
        }),
        this.q
      )
    }
    A(i) {
      if ((this.f?.onWillRemoveListener?.(this), !this.u)) return
      if (this.z === 1) {
        ;(this.u = void 0),
          this.f?.onDidRemoveLastListener?.(this),
          (this.z = 0)
        return
      }
      const t = this.u,
        e = t.indexOf(i)
      if (e === -1)
        throw (
          (console.log("disposed?", this.m),
          console.log("size?", this.z),
          console.log("arr?", JSON.stringify(this.u)),
          new Error("Attempted to dispose unknown listener"))
        )
      this.z--, (t[e] = void 0)
      const r = this.w.current === this
      if (this.z * Rat <= t.length) {
        let s = 0
        for (let a = 0; a < t.length; a++)
          t[a]
            ? (t[s++] = t[a])
            : r && s < this.w.end && (this.w.end--, s < this.w.i && this.w.i--)
        t.length = s
      }
    }
    B(i, t) {
      if (!i) return
      const e = this.f?.onListenerError || Ui
      if (!e) {
        i.value(t)
        return
      }
      try {
        i.value(t)
      } catch (r) {
        e(r)
      }
    }
    C(i) {
      const t = i.current.u
      for (; i.i < i.end; ) this.B(t[i.i++], i.value)
      i.reset()
    }
    fire(i) {
      if (
        (this.w?.current && (this.C(this.w), this.j?.stop()),
        this.j?.start(this.z),
        this.u)
      )
        if (this.u instanceof GF) this.B(this.u, i)
        else {
          const t = this.w
          t.enqueue(this, i, this.u.length), this.C(t)
        }
      this.j?.stop()
    }
    hasListeners() {
      return this.z > 0
    }
  },
  Dat = class {
    constructor() {
      ;(this.i = -1), (this.end = 0)
    }
    enqueue(i, t, e) {
      ;(this.i = 0), (this.end = e), (this.current = i), (this.value = t)
    }
    reset() {
      ;(this.i = this.end), (this.current = void 0), (this.value = void 0)
    }
  },
  Iu = class extends C {
    async fireAsync(i, t, e) {
      if (this.u)
        for (
          this.h || (this.h = new Eu()),
            HH(this.u, (r) => this.h.push([r.value, i]));
          this.h.size > 0 && !t.isCancellationRequested;

        ) {
          const [r, s] = this.h.shift(),
            a = [],
            o = {
              ...s,
              token: t,
              waitUntil: (c) => {
                if (Object.isFrozen(a))
                  throw new Error("waitUntil can NOT be called asynchronous")
                e && (c = e(c, r)), a.push(c)
              },
            }
          try {
            r(o)
          } catch (c) {
            Ui(c)
            continue
          }
          Object.freeze(a),
            await Promise.allSettled(a).then((c) => {
              for (const u of c) u.status === "rejected" && Ui(u.reason)
            })
        }
    }
  },
  YF = class extends C {
    get isPaused() {
      return this.h !== 0
    }
    constructor(i) {
      super(i), (this.h = 0), (this.s = new Eu()), (this.t = i?.merge)
    }
    pause() {
      this.h++
    }
    resume() {
      if (this.h !== 0 && --this.h === 0)
        if (this.t) {
          if (this.s.size > 0) {
            const i = Array.from(this.s)
            this.s.clear(), super.fire(this.t(i))
          }
        } else for (; !this.h && this.s.size !== 0; ) super.fire(this.s.shift())
    }
    fire(i) {
      this.z && (this.h !== 0 ? this.s.push(i) : super.fire(i))
    }
  },
  Fat = class extends YF {
    constructor(i) {
      super(i), (this.k = i.delay ?? 100)
    }
    fire(i) {
      this.o ||
        (this.pause(),
        (this.o = setTimeout(() => {
          ;(this.o = void 0), this.resume()
        }, this.k))),
        super.fire(i)
    }
  },
  Pu
;(function (i) {
  ;(i[(i.Desktop = 1)] = "Desktop"), (i[(i.Web = 2)] = "Web")
})(Pu || (Pu = {}))
var WH
;(function (i) {
  ;(i[(i.VersionMismatch = 55)] = "VersionMismatch"),
    (i[(i.UnexpectedError = 81)] = "UnexpectedError")
})(WH || (WH = {}))
var jH
;(function (i) {
  ;(i[(i.Initialized = 0)] = "Initialized"),
    (i[(i.Ready = 1)] = "Ready"),
    (i[(i.Terminate = 2)] = "Terminate")
})(jH || (jH = {}))
function VH(i) {
  const t = Et.alloc(1)
  switch (i) {
    case 0:
      t.writeUInt8(1, 0)
      break
    case 1:
      t.writeUInt8(2, 0)
      break
    case 2:
      t.writeUInt8(3, 0)
      break
  }
  return t
}
function _at(i, t) {
  if (i.byteLength !== 1) return !1
  switch (i.readUInt8(0)) {
    case 1:
      return t === 0
    case 2:
      return t === 1
    case 3:
      return t === 2
    default:
      return !1
  }
}
var GH
;(function (i) {
  ;(i.Start = "START_NATIVE_LOG"), (i.End = "END_NATIVE_LOG")
})(GH || (GH = {}))
function hB(i) {
  const t = []
  typeof i == "number" && t.push("code/timeOrigin", i)
  function e(s, a) {
    t.push(s, a?.startTime ?? Date.now())
  }
  function r() {
    const s = []
    for (let a = 0; a < t.length; a += 2)
      s.push({ name: t[a], startTime: t[a + 1] })
    return s
  }
  return { mark: e, getMarks: r }
}
function Aat() {
  if (
    typeof performance == "object" &&
    typeof performance.mark == "function" &&
    !performance.nodeTiming
  )
    return typeof performance.timeOrigin != "number" && !performance.timing
      ? hB()
      : {
          mark(i, t) {
            performance.mark(i, t)
          },
          getMarks() {
            let i = performance.timeOrigin
            typeof i != "number" &&
              (i =
                performance.timing.navigationStart ||
                performance.timing.redirectStart ||
                performance.timing.fetchStart)
            const t = [{ name: "code/timeOrigin", startTime: Math.round(i) }]
            for (const e of performance.getEntriesByType("mark"))
              t.push({ name: e.name, startTime: Math.round(i + e.startTime) })
            return t
          },
        }
  if (typeof process == "object") {
    const i = performance?.timeOrigin
    return hB(i)
  } else return console.trace("perf-util loaded in UNKNOWN environment"), hB()
}
function Bat(i) {
  return (
    i.MonacoPerformanceMarks || (i.MonacoPerformanceMarks = Aat()),
    i.MonacoPerformanceMarks
  )
}
var zH = Bat(globalThis),
  Pi = zH.mark,
  Oat = zH.getMarks
function qat() {
  return globalThis._VSCODE_NLS_MESSAGES
}
function YH() {
  return globalThis._VSCODE_NLS_LANGUAGE
}
var Uat =
  YH() === "pseudo" ||
  (typeof document < "u" &&
    document.location &&
    typeof document.location.hash == "string" &&
    document.location.hash.indexOf("pseudo=true") >= 0)
function QF(i, t) {
  let e
  return (
    t.length === 0
      ? (e = i)
      : (e = i.replace(/\{(\d+)\}/g, (r, s) => {
          const a = s[0],
            o = t[a]
          let c = r
          return (
            typeof o == "string"
              ? (c = o)
              : (typeof o == "number" ||
                  typeof o == "boolean" ||
                  o === void 0 ||
                  o === null) &&
                (c = String(o)),
            c
          )
        })),
    Uat && (e = "\uFF3B" + e.replace(/[aouei]/g, "$&$&") + "\uFF3D"),
    e
  )
}
function f(i, t, ...e) {
  return QF(typeof i == "number" ? QH(i, t) : t, e)
}
function QH(i, t) {
  const e = qat()?.[i]
  if (typeof e != "string") {
    if (typeof t == "string") return t
    throw new Error(`!!! NLS MISSING: ${i} !!!`)
  }
  return e
}
function fB(i, t, ...e) {
  let r
  typeof i == "number" ? (r = QH(i, t)) : (r = t)
  const s = QF(r, e)
  return { value: s, original: t === r ? s : QF(t, e) }
}
var ts = "en",
  Nu = !1,
  $u = !1,
  xu = !1,
  Mat = !1,
  XH = !1,
  pB = !1,
  Hat = !1,
  KH = !1,
  ZH = !1,
  Wat = !1,
  XF = void 0,
  KF = ts,
  tW = ts,
  jat = void 0,
  gn = void 0,
  vn = globalThis,
  Qi = void 0
typeof vn.vscode < "u" && typeof vn.vscode.process < "u"
  ? (Qi = vn.vscode.process)
  : typeof process < "u" &&
    typeof process?.versions?.node == "string" &&
    (Qi = process)
var eW = typeof Qi?.versions?.electron == "string",
  Vat = eW && Qi?.type === "renderer"
if (typeof Qi == "object") {
  ;(Nu = Qi.platform === "win32"),
    ($u = Qi.platform === "darwin"),
    (xu = Qi.platform === "linux"),
    (Mat = xu && !!Qi.env.SNAP && !!Qi.env.SNAP_REVISION),
    (Hat = eW),
    (ZH = !!Qi.env.CI || !!Qi.env.BUILD_ARTIFACTSTAGINGDIRECTORY),
    (XF = ts),
    (KF = ts)
  const i = Qi.env.VSCODE_NLS_CONFIG
  if (i)
    try {
      const t = JSON.parse(i)
      ;(XF = t.userLocale),
        (tW = t.osLocale),
        (KF = t.resolvedLanguage || ts),
        (jat = t.languagePack?.translationsConfigFile)
    } catch {}
  XH = !0
} else
  typeof navigator == "object" && !Vat
    ? ((gn = navigator.userAgent),
      (Nu = gn.indexOf("Windows") >= 0),
      ($u = gn.indexOf("Macintosh") >= 0),
      (KH =
        (gn.indexOf("Macintosh") >= 0 ||
          gn.indexOf("iPad") >= 0 ||
          gn.indexOf("iPhone") >= 0) &&
        !!navigator.maxTouchPoints &&
        navigator.maxTouchPoints > 0),
      (xu = gn.indexOf("Linux") >= 0),
      (Wat = gn?.indexOf("Mobi") >= 0),
      (pB = !0),
      (KF = YH() || ts),
      (XF = navigator.language.toLowerCase()),
      (tW = XF))
    : console.error("Unable to resolve platform.")
var iW
;(function (i) {
  ;(i[(i.Web = 0)] = "Web"),
    (i[(i.Mac = 1)] = "Mac"),
    (i[(i.Linux = 2)] = "Linux"),
    (i[(i.Windows = 3)] = "Windows")
})(iW || (iW = {}))
function Gat(i) {
  switch (i) {
    case 0:
      return "Web"
    case 1:
      return "Mac"
    case 2:
      return "Linux"
    case 3:
      return "Windows"
  }
}
var gB = 0
$u ? (gB = 1) : Nu ? (gB = 3) : xu && (gB = 2)
var Mi = Nu,
  Tr = $u,
  es = xu,
  rW = XH,
  vB = pB,
  zat = pB && typeof vn.importScripts == "function",
  Yat = zat ? vn.origin : void 0,
  Qs = ZH,
  Qr = gn,
  is = KF,
  nW
;(function (i) {
  function t() {
    return is
  }
  i.value = t
  function e() {
    return is.length === 2
      ? is === "en"
      : is.length >= 3
        ? is[0] === "e" && is[1] === "n" && is[2] === "-"
        : !1
  }
  i.isDefaultVariant = e
  function r() {
    return is === "en"
  }
  i.isDefault = r
})(nW || (nW = {}))
var Qat = typeof vn.postMessage == "function" && !vn.importScripts,
  sW = (() => {
    if (Qat) {
      const i = []
      vn.addEventListener("message", (e) => {
        if (e.data && e.data.vscodeScheduleAsyncWork)
          for (let r = 0, s = i.length; r < s; r++) {
            const a = i[r]
            if (a.id === e.data.vscodeScheduleAsyncWork) {
              i.splice(r, 1), a.callback()
              return
            }
          }
      })
      let t = 0
      return (e) => {
        const r = ++t
        i.push({ id: r, callback: e }),
          vn.postMessage({ vscodeScheduleAsyncWork: r }, "*")
      }
    }
    return (i) => setTimeout(i)
  })(),
  aW
;(function (i) {
  ;(i[(i.Windows = 1)] = "Windows"),
    (i[(i.Macintosh = 2)] = "Macintosh"),
    (i[(i.Linux = 3)] = "Linux")
})(aW || (aW = {}))
var Xat = $u || KH ? 2 : Nu ? 1 : 3,
  oW = !0,
  cW = !1
function uW() {
  if (!cW) {
    cW = !0
    const i = new Uint8Array(2)
    ;(i[0] = 1), (i[1] = 2), (oW = new Uint16Array(i.buffer)[0] === 513)
  }
  return oW
}
var wB = !!(Qr && Qr.indexOf("Chrome") >= 0),
  Kat = !!(Qr && Qr.indexOf("Firefox") >= 0),
  Zat = !!(!wB && Qr && Qr.indexOf("Safari") >= 0),
  lW = !!(Qr && Qr.indexOf("Edg/") >= 0),
  h8t = !!(Qr && Qr.indexOf("Android") >= 0),
  Xs,
  yB = globalThis.vscode
if (typeof yB < "u" && typeof yB.process < "u") {
  const i = yB.process
  Xs = {
    get platform() {
      return i.platform
    },
    get arch() {
      return i.arch
    },
    get env() {
      return i.env
    },
    cwd() {
      return i.cwd()
    },
  }
} else
  typeof process < "u" && typeof process?.versions?.node == "string"
    ? (Xs = {
        get platform() {
          return process.platform
        },
        get arch() {
          return process.arch
        },
        get env() {
          return process.env
        },
        cwd() {
          return process.env.VSCODE_CWD || process.cwd()
        },
      })
    : (Xs = {
        get platform() {
          return Mi ? "win32" : Tr ? "darwin" : "linux"
        },
        get arch() {},
        get env() {
          return {}
        },
        cwd() {
          return "/"
        },
      })
var uo = Xs.cwd,
  Ju = Xs.env,
  tot = Xs.platform,
  f8t = Xs.arch,
  eot = 65,
  iot = 97,
  rot = 90,
  not = 122,
  rs = 46,
  oi = 47,
  Hi = 92,
  ns = 58,
  sot = 63,
  dW = class extends Error {
    constructor(i, t, e) {
      let r
      typeof t == "string" && t.indexOf("not ") === 0
        ? ((r = "must not be"), (t = t.replace(/^not /, "")))
        : (r = "must be")
      const s = i.indexOf(".") !== -1 ? "property" : "argument"
      let a = `The "${i}" ${s} ${r} of type ${t}`
      ;(a += `. Received type ${typeof e}`),
        super(a),
        (this.code = "ERR_INVALID_ARG_TYPE")
    }
  }
function aot(i, t) {
  if (i === null || typeof i != "object") throw new dW(t, "Object", i)
}
function De(i, t) {
  if (typeof i != "string") throw new dW(t, "string", i)
}
var Wi = tot === "win32"
function Ft(i) {
  return i === oi || i === Hi
}
function TB(i) {
  return i === oi
}
function ss(i) {
  return (i >= eot && i <= rot) || (i >= iot && i <= not)
}
function ZF(i, t, e, r) {
  let s = "",
    a = 0,
    o = -1,
    c = 0,
    u = 0
  for (let l = 0; l <= i.length; ++l) {
    if (l < i.length) u = i.charCodeAt(l)
    else {
      if (r(u)) break
      u = oi
    }
    if (r(u)) {
      if (!(o === l - 1 || c === 1))
        if (c === 2) {
          if (
            s.length < 2 ||
            a !== 2 ||
            s.charCodeAt(s.length - 1) !== rs ||
            s.charCodeAt(s.length - 2) !== rs
          ) {
            if (s.length > 2) {
              const m = s.lastIndexOf(e)
              m === -1
                ? ((s = ""), (a = 0))
                : ((s = s.slice(0, m)), (a = s.length - 1 - s.lastIndexOf(e))),
                (o = l),
                (c = 0)
              continue
            } else if (s.length !== 0) {
              ;(s = ""), (a = 0), (o = l), (c = 0)
              continue
            }
          }
          t && ((s += s.length > 0 ? `${e}..` : ".."), (a = 2))
        } else
          s.length > 0
            ? (s += `${e}${i.slice(o + 1, l)}`)
            : (s = i.slice(o + 1, l)),
            (a = l - o - 1)
      ;(o = l), (c = 0)
    } else u === rs && c !== -1 ? ++c : (c = -1)
  }
  return s
}
function oot(i) {
  return i ? `${i[0] === "." ? "" : "."}${i}` : ""
}
function mW(i, t) {
  aot(t, "pathObject")
  const e = t.dir || t.root,
    r = t.base || `${t.name || ""}${oot(t.ext)}`
  return e ? (e === t.root ? `${e}${r}` : `${e}${i}${r}`) : r
}
var Fe = {
    resolve(...i) {
      let t = "",
        e = "",
        r = !1
      for (let s = i.length - 1; s >= -1; s--) {
        let a
        if (s >= 0) {
          if (((a = i[s]), De(a, `paths[${s}]`), a.length === 0)) continue
        } else
          t.length === 0
            ? (a = uo())
            : ((a = Ju[`=${t}`] || uo()),
              (a === void 0 ||
                (a.slice(0, 2).toLowerCase() !== t.toLowerCase() &&
                  a.charCodeAt(2) === Hi)) &&
                (a = `${t}\\`))
        const o = a.length
        let c = 0,
          u = "",
          l = !1
        const m = a.charCodeAt(0)
        if (o === 1) Ft(m) && ((c = 1), (l = !0))
        else if (Ft(m))
          if (((l = !0), Ft(a.charCodeAt(1)))) {
            let h = 2,
              p = h
            for (; h < o && !Ft(a.charCodeAt(h)); ) h++
            if (h < o && h !== p) {
              const g = a.slice(p, h)
              for (p = h; h < o && Ft(a.charCodeAt(h)); ) h++
              if (h < o && h !== p) {
                for (p = h; h < o && !Ft(a.charCodeAt(h)); ) h++
                ;(h === o || h !== p) &&
                  ((u = `\\\\${g}\\${a.slice(p, h)}`), (c = h))
              }
            }
          } else c = 1
        else
          ss(m) &&
            a.charCodeAt(1) === ns &&
            ((u = a.slice(0, 2)),
            (c = 2),
            o > 2 && Ft(a.charCodeAt(2)) && ((l = !0), (c = 3)))
        if (u.length > 0)
          if (t.length > 0) {
            if (u.toLowerCase() !== t.toLowerCase()) continue
          } else t = u
        if (r) {
          if (t.length > 0) break
        } else if (((e = `${a.slice(c)}\\${e}`), (r = l), l && t.length > 0))
          break
      }
      return (e = ZF(e, !r, "\\", Ft)), r ? `${t}\\${e}` : `${t}${e}` || "."
    },
    normalize(i) {
      De(i, "path")
      const t = i.length
      if (t === 0) return "."
      let e = 0,
        r,
        s = !1
      const a = i.charCodeAt(0)
      if (t === 1) return TB(a) ? "\\" : i
      if (Ft(a))
        if (((s = !0), Ft(i.charCodeAt(1)))) {
          let c = 2,
            u = c
          for (; c < t && !Ft(i.charCodeAt(c)); ) c++
          if (c < t && c !== u) {
            const l = i.slice(u, c)
            for (u = c; c < t && Ft(i.charCodeAt(c)); ) c++
            if (c < t && c !== u) {
              for (u = c; c < t && !Ft(i.charCodeAt(c)); ) c++
              if (c === t) return `\\\\${l}\\${i.slice(u)}\\`
              c !== u && ((r = `\\\\${l}\\${i.slice(u, c)}`), (e = c))
            }
          }
        } else e = 1
      else
        ss(a) &&
          i.charCodeAt(1) === ns &&
          ((r = i.slice(0, 2)),
          (e = 2),
          t > 2 && Ft(i.charCodeAt(2)) && ((s = !0), (e = 3)))
      let o = e < t ? ZF(i.slice(e), !s, "\\", Ft) : ""
      return (
        o.length === 0 && !s && (o = "."),
        o.length > 0 && Ft(i.charCodeAt(t - 1)) && (o += "\\"),
        r === void 0 ? (s ? `\\${o}` : o) : s ? `${r}\\${o}` : `${r}${o}`
      )
    },
    isAbsolute(i) {
      De(i, "path")
      const t = i.length
      if (t === 0) return !1
      const e = i.charCodeAt(0)
      return (
        Ft(e) ||
        (t > 2 && ss(e) && i.charCodeAt(1) === ns && Ft(i.charCodeAt(2)))
      )
    },
    join(...i) {
      if (i.length === 0) return "."
      let t, e
      for (let a = 0; a < i.length; ++a) {
        const o = i[a]
        De(o, "path"),
          o.length > 0 && (t === void 0 ? (t = e = o) : (t += `\\${o}`))
      }
      if (t === void 0) return "."
      let r = !0,
        s = 0
      if (typeof e == "string" && Ft(e.charCodeAt(0))) {
        ++s
        const a = e.length
        a > 1 &&
          Ft(e.charCodeAt(1)) &&
          (++s, a > 2 && (Ft(e.charCodeAt(2)) ? ++s : (r = !1)))
      }
      if (r) {
        for (; s < t.length && Ft(t.charCodeAt(s)); ) s++
        s >= 2 && (t = `\\${t.slice(s)}`)
      }
      return Fe.normalize(t)
    },
    relative(i, t) {
      if ((De(i, "from"), De(t, "to"), i === t)) return ""
      const e = Fe.resolve(i),
        r = Fe.resolve(t)
      if (e === r || ((i = e.toLowerCase()), (t = r.toLowerCase()), i === t))
        return ""
      let s = 0
      for (; s < i.length && i.charCodeAt(s) === Hi; ) s++
      let a = i.length
      for (; a - 1 > s && i.charCodeAt(a - 1) === Hi; ) a--
      const o = a - s
      let c = 0
      for (; c < t.length && t.charCodeAt(c) === Hi; ) c++
      let u = t.length
      for (; u - 1 > c && t.charCodeAt(u - 1) === Hi; ) u--
      const l = u - c,
        m = o < l ? o : l
      let h = -1,
        p = 0
      for (; p < m; p++) {
        const w = i.charCodeAt(s + p)
        if (w !== t.charCodeAt(c + p)) break
        w === Hi && (h = p)
      }
      if (p !== m) {
        if (h === -1) return r
      } else {
        if (l > m) {
          if (t.charCodeAt(c + p) === Hi) return r.slice(c + p + 1)
          if (p === 2) return r.slice(c + p)
        }
        o > m && (i.charCodeAt(s + p) === Hi ? (h = p) : p === 2 && (h = 3)),
          h === -1 && (h = 0)
      }
      let g = ""
      for (p = s + h + 1; p <= a; ++p)
        (p === a || i.charCodeAt(p) === Hi) &&
          (g += g.length === 0 ? ".." : "\\..")
      return (
        (c += h),
        g.length > 0
          ? `${g}${r.slice(c, u)}`
          : (r.charCodeAt(c) === Hi && ++c, r.slice(c, u))
      )
    },
    toNamespacedPath(i) {
      if (typeof i != "string" || i.length === 0) return i
      const t = Fe.resolve(i)
      if (t.length <= 2) return i
      if (t.charCodeAt(0) === Hi) {
        if (t.charCodeAt(1) === Hi) {
          const e = t.charCodeAt(2)
          if (e !== sot && e !== rs) return `\\\\?\\UNC\\${t.slice(2)}`
        }
      } else if (
        ss(t.charCodeAt(0)) &&
        t.charCodeAt(1) === ns &&
        t.charCodeAt(2) === Hi
      )
        return `\\\\?\\${t}`
      return i
    },
    dirname(i) {
      De(i, "path")
      const t = i.length
      if (t === 0) return "."
      let e = -1,
        r = 0
      const s = i.charCodeAt(0)
      if (t === 1) return Ft(s) ? i : "."
      if (Ft(s)) {
        if (((e = r = 1), Ft(i.charCodeAt(1)))) {
          let c = 2,
            u = c
          for (; c < t && !Ft(i.charCodeAt(c)); ) c++
          if (c < t && c !== u) {
            for (u = c; c < t && Ft(i.charCodeAt(c)); ) c++
            if (c < t && c !== u) {
              for (u = c; c < t && !Ft(i.charCodeAt(c)); ) c++
              if (c === t) return i
              c !== u && (e = r = c + 1)
            }
          }
        }
      } else
        ss(s) &&
          i.charCodeAt(1) === ns &&
          ((e = t > 2 && Ft(i.charCodeAt(2)) ? 3 : 2), (r = e))
      let a = -1,
        o = !0
      for (let c = t - 1; c >= r; --c)
        if (Ft(i.charCodeAt(c))) {
          if (!o) {
            a = c
            break
          }
        } else o = !1
      if (a === -1) {
        if (e === -1) return "."
        a = e
      }
      return i.slice(0, a)
    },
    basename(i, t) {
      t !== void 0 && De(t, "suffix"), De(i, "path")
      let e = 0,
        r = -1,
        s = !0,
        a
      if (
        (i.length >= 2 &&
          ss(i.charCodeAt(0)) &&
          i.charCodeAt(1) === ns &&
          (e = 2),
        t !== void 0 && t.length > 0 && t.length <= i.length)
      ) {
        if (t === i) return ""
        let o = t.length - 1,
          c = -1
        for (a = i.length - 1; a >= e; --a) {
          const u = i.charCodeAt(a)
          if (Ft(u)) {
            if (!s) {
              e = a + 1
              break
            }
          } else
            c === -1 && ((s = !1), (c = a + 1)),
              o >= 0 &&
                (u === t.charCodeAt(o)
                  ? --o === -1 && (r = a)
                  : ((o = -1), (r = c)))
        }
        return e === r ? (r = c) : r === -1 && (r = i.length), i.slice(e, r)
      }
      for (a = i.length - 1; a >= e; --a)
        if (Ft(i.charCodeAt(a))) {
          if (!s) {
            e = a + 1
            break
          }
        } else r === -1 && ((s = !1), (r = a + 1))
      return r === -1 ? "" : i.slice(e, r)
    },
    extname(i) {
      De(i, "path")
      let t = 0,
        e = -1,
        r = 0,
        s = -1,
        a = !0,
        o = 0
      i.length >= 2 &&
        i.charCodeAt(1) === ns &&
        ss(i.charCodeAt(0)) &&
        (t = r = 2)
      for (let c = i.length - 1; c >= t; --c) {
        const u = i.charCodeAt(c)
        if (Ft(u)) {
          if (!a) {
            r = c + 1
            break
          }
          continue
        }
        s === -1 && ((a = !1), (s = c + 1)),
          u === rs
            ? e === -1
              ? (e = c)
              : o !== 1 && (o = 1)
            : e !== -1 && (o = -1)
      }
      return e === -1 ||
        s === -1 ||
        o === 0 ||
        (o === 1 && e === s - 1 && e === r + 1)
        ? ""
        : i.slice(e, s)
    },
    format: mW.bind(null, "\\"),
    parse(i) {
      De(i, "path")
      const t = { root: "", dir: "", base: "", ext: "", name: "" }
      if (i.length === 0) return t
      const e = i.length
      let r = 0,
        s = i.charCodeAt(0)
      if (e === 1)
        return Ft(s) ? ((t.root = t.dir = i), t) : ((t.base = t.name = i), t)
      if (Ft(s)) {
        if (((r = 1), Ft(i.charCodeAt(1)))) {
          let h = 2,
            p = h
          for (; h < e && !Ft(i.charCodeAt(h)); ) h++
          if (h < e && h !== p) {
            for (p = h; h < e && Ft(i.charCodeAt(h)); ) h++
            if (h < e && h !== p) {
              for (p = h; h < e && !Ft(i.charCodeAt(h)); ) h++
              h === e ? (r = h) : h !== p && (r = h + 1)
            }
          }
        }
      } else if (ss(s) && i.charCodeAt(1) === ns) {
        if (e <= 2) return (t.root = t.dir = i), t
        if (((r = 2), Ft(i.charCodeAt(2)))) {
          if (e === 3) return (t.root = t.dir = i), t
          r = 3
        }
      }
      r > 0 && (t.root = i.slice(0, r))
      let a = -1,
        o = r,
        c = -1,
        u = !0,
        l = i.length - 1,
        m = 0
      for (; l >= r; --l) {
        if (((s = i.charCodeAt(l)), Ft(s))) {
          if (!u) {
            o = l + 1
            break
          }
          continue
        }
        c === -1 && ((u = !1), (c = l + 1)),
          s === rs
            ? a === -1
              ? (a = l)
              : m !== 1 && (m = 1)
            : a !== -1 && (m = -1)
      }
      return (
        c !== -1 &&
          (a === -1 || m === 0 || (m === 1 && a === c - 1 && a === o + 1)
            ? (t.base = t.name = i.slice(o, c))
            : ((t.name = i.slice(o, a)),
              (t.base = i.slice(o, c)),
              (t.ext = i.slice(a, c)))),
        o > 0 && o !== r ? (t.dir = i.slice(0, o - 1)) : (t.dir = t.root),
        t
      )
    },
    sep: "\\",
    delimiter: ";",
    win32: null,
    posix: null,
  },
  cot = (() => {
    if (Wi) {
      const i = /\\/g
      return () => {
        const t = uo().replace(i, "/")
        return t.slice(t.indexOf("/"))
      }
    }
    return () => uo()
  })(),
  Ut = {
    resolve(...i) {
      let t = "",
        e = !1
      for (let r = i.length - 1; r >= -1 && !e; r--) {
        const s = r >= 0 ? i[r] : cot()
        De(s, `paths[${r}]`),
          s.length !== 0 && ((t = `${s}/${t}`), (e = s.charCodeAt(0) === oi))
      }
      return (t = ZF(t, !e, "/", TB)), e ? `/${t}` : t.length > 0 ? t : "."
    },
    normalize(i) {
      if ((De(i, "path"), i.length === 0)) return "."
      const t = i.charCodeAt(0) === oi,
        e = i.charCodeAt(i.length - 1) === oi
      return (
        (i = ZF(i, !t, "/", TB)),
        i.length === 0
          ? t
            ? "/"
            : e
              ? "./"
              : "."
          : (e && (i += "/"), t ? `/${i}` : i)
      )
    },
    isAbsolute(i) {
      return De(i, "path"), i.length > 0 && i.charCodeAt(0) === oi
    },
    join(...i) {
      if (i.length === 0) return "."
      let t
      for (let e = 0; e < i.length; ++e) {
        const r = i[e]
        De(r, "path"), r.length > 0 && (t === void 0 ? (t = r) : (t += `/${r}`))
      }
      return t === void 0 ? "." : Ut.normalize(t)
    },
    relative(i, t) {
      if (
        (De(i, "from"),
        De(t, "to"),
        i === t || ((i = Ut.resolve(i)), (t = Ut.resolve(t)), i === t))
      )
        return ""
      const e = 1,
        r = i.length,
        s = r - e,
        a = 1,
        o = t.length - a,
        c = s < o ? s : o
      let u = -1,
        l = 0
      for (; l < c; l++) {
        const h = i.charCodeAt(e + l)
        if (h !== t.charCodeAt(a + l)) break
        h === oi && (u = l)
      }
      if (l === c)
        if (o > c) {
          if (t.charCodeAt(a + l) === oi) return t.slice(a + l + 1)
          if (l === 0) return t.slice(a + l)
        } else
          s > c && (i.charCodeAt(e + l) === oi ? (u = l) : l === 0 && (u = 0))
      let m = ""
      for (l = e + u + 1; l <= r; ++l)
        (l === r || i.charCodeAt(l) === oi) &&
          (m += m.length === 0 ? ".." : "/..")
      return `${m}${t.slice(a + u)}`
    },
    toNamespacedPath(i) {
      return i
    },
    dirname(i) {
      if ((De(i, "path"), i.length === 0)) return "."
      const t = i.charCodeAt(0) === oi
      let e = -1,
        r = !0
      for (let s = i.length - 1; s >= 1; --s)
        if (i.charCodeAt(s) === oi) {
          if (!r) {
            e = s
            break
          }
        } else r = !1
      return e === -1 ? (t ? "/" : ".") : t && e === 1 ? "//" : i.slice(0, e)
    },
    basename(i, t) {
      t !== void 0 && De(t, "ext"), De(i, "path")
      let e = 0,
        r = -1,
        s = !0,
        a
      if (t !== void 0 && t.length > 0 && t.length <= i.length) {
        if (t === i) return ""
        let o = t.length - 1,
          c = -1
        for (a = i.length - 1; a >= 0; --a) {
          const u = i.charCodeAt(a)
          if (u === oi) {
            if (!s) {
              e = a + 1
              break
            }
          } else
            c === -1 && ((s = !1), (c = a + 1)),
              o >= 0 &&
                (u === t.charCodeAt(o)
                  ? --o === -1 && (r = a)
                  : ((o = -1), (r = c)))
        }
        return e === r ? (r = c) : r === -1 && (r = i.length), i.slice(e, r)
      }
      for (a = i.length - 1; a >= 0; --a)
        if (i.charCodeAt(a) === oi) {
          if (!s) {
            e = a + 1
            break
          }
        } else r === -1 && ((s = !1), (r = a + 1))
      return r === -1 ? "" : i.slice(e, r)
    },
    extname(i) {
      De(i, "path")
      let t = -1,
        e = 0,
        r = -1,
        s = !0,
        a = 0
      for (let o = i.length - 1; o >= 0; --o) {
        const c = i.charCodeAt(o)
        if (c === oi) {
          if (!s) {
            e = o + 1
            break
          }
          continue
        }
        r === -1 && ((s = !1), (r = o + 1)),
          c === rs
            ? t === -1
              ? (t = o)
              : a !== 1 && (a = 1)
            : t !== -1 && (a = -1)
      }
      return t === -1 ||
        r === -1 ||
        a === 0 ||
        (a === 1 && t === r - 1 && t === e + 1)
        ? ""
        : i.slice(t, r)
    },
    format: mW.bind(null, "/"),
    parse(i) {
      De(i, "path")
      const t = { root: "", dir: "", base: "", ext: "", name: "" }
      if (i.length === 0) return t
      const e = i.charCodeAt(0) === oi
      let r
      e ? ((t.root = "/"), (r = 1)) : (r = 0)
      let s = -1,
        a = 0,
        o = -1,
        c = !0,
        u = i.length - 1,
        l = 0
      for (; u >= r; --u) {
        const m = i.charCodeAt(u)
        if (m === oi) {
          if (!c) {
            a = u + 1
            break
          }
          continue
        }
        o === -1 && ((c = !1), (o = u + 1)),
          m === rs
            ? s === -1
              ? (s = u)
              : l !== 1 && (l = 1)
            : s !== -1 && (l = -1)
      }
      if (o !== -1) {
        const m = a === 0 && e ? 1 : a
        s === -1 || l === 0 || (l === 1 && s === o - 1 && s === a + 1)
          ? (t.base = t.name = i.slice(m, o))
          : ((t.name = i.slice(m, s)),
            (t.base = i.slice(m, o)),
            (t.ext = i.slice(s, o)))
      }
      return a > 0 ? (t.dir = i.slice(0, a - 1)) : e && (t.dir = "/"), t
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null,
  }
;(Ut.win32 = Fe.win32 = Fe), (Ut.posix = Fe.posix = Ut)
var lo = Wi ? Fe.normalize : Ut.normalize,
  t_ = Wi ? Fe.isAbsolute : Ut.isAbsolute,
  kB = Wi ? Fe.join : Ut.join,
  uot = Wi ? Fe.resolve : Ut.resolve,
  Cu = Wi ? Fe.relative : Ut.relative,
  mo = Wi ? Fe.dirname : Ut.dirname,
  ji = Wi ? Fe.basename : Ut.basename,
  SB = Wi ? Fe.extname : Ut.extname,
  p8t = Wi ? Fe.format : Ut.format,
  g8t = Wi ? Fe.parse : Ut.parse,
  v8t = Wi ? Fe.toNamespacedPath : Ut.toNamespacedPath,
  kr = Wi ? Fe.sep : Ut.sep,
  w8t = Wi ? Fe.delimiter : Ut.delimiter,
  lot = /^\w[\w\d+.-]*$/,
  dot = /^\//,
  mot = /^\/\//
function hot(i, t) {
  if (!i.scheme && t)
    throw new Error(
      `[UriError]: Scheme is missing: {scheme: "", authority: "${i.authority}", path: "${i.path}", query: "${i.query}", fragment: "${i.fragment}"}`,
    )
  if (i.scheme && !lot.test(i.scheme))
    throw new Error("[UriError]: Scheme contains illegal characters.")
  if (i.path) {
    if (i.authority) {
      if (!dot.test(i.path))
        throw new Error(
          '[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character',
        )
    } else if (mot.test(i.path))
      throw new Error(
        '[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")',
      )
  }
}
function fot(i, t) {
  return !i && !t ? "file" : i
}
function pot(i, t) {
  switch (i) {
    case "https":
    case "http":
    case "file":
      t ? t[0] !== Sr && (t = Sr + t) : (t = Sr)
      break
  }
  return t
}
var he = "",
  Sr = "/",
  got = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/,
  S = class A8 {
    static isUri(t) {
      return t instanceof A8
        ? !0
        : t
          ? typeof t.authority == "string" &&
            typeof t.fragment == "string" &&
            typeof t.path == "string" &&
            typeof t.query == "string" &&
            typeof t.scheme == "string" &&
            typeof t.fsPath == "string" &&
            typeof t.with == "function" &&
            typeof t.toString == "function"
          : !1
    }
    constructor(t, e, r, s, a, o = !1) {
      typeof t == "object"
        ? ((this.scheme = t.scheme || he),
          (this.authority = t.authority || he),
          (this.path = t.path || he),
          (this.query = t.query || he),
          (this.fragment = t.fragment || he))
        : ((this.scheme = fot(t, o)),
          (this.authority = e || he),
          (this.path = pot(this.scheme, r || he)),
          (this.query = s || he),
          (this.fragment = a || he),
          hot(this, o))
    }
    get fsPath() {
      return e_(this, !1)
    }
    with(t) {
      if (!t) return this
      let { scheme: e, authority: r, path: s, query: a, fragment: o } = t
      return (
        e === void 0 ? (e = this.scheme) : e === null && (e = he),
        r === void 0 ? (r = this.authority) : r === null && (r = he),
        s === void 0 ? (s = this.path) : s === null && (s = he),
        a === void 0 ? (a = this.query) : a === null && (a = he),
        o === void 0 ? (o = this.fragment) : o === null && (o = he),
        e === this.scheme &&
        r === this.authority &&
        s === this.path &&
        a === this.query &&
        o === this.fragment
          ? this
          : new ho(e, r, s, a, o)
      )
    }
    static parse(t, e = !1) {
      const r = got.exec(t)
      return r
        ? new ho(
            r[2] || he,
            i_(r[4] || he),
            i_(r[5] || he),
            i_(r[7] || he),
            i_(r[9] || he),
            e,
          )
        : new ho(he, he, he, he, he)
    }
    static file(t) {
      let e = he
      if ((Mi && (t = t.replace(/\\/g, Sr)), t[0] === Sr && t[1] === Sr)) {
        const r = t.indexOf(Sr, 2)
        r === -1
          ? ((e = t.substring(2)), (t = Sr))
          : ((e = t.substring(2, r)), (t = t.substring(r) || Sr))
      }
      return new ho("file", e, t, he, he)
    }
    static from(t, e) {
      return new ho(t.scheme, t.authority, t.path, t.query, t.fragment, e)
    }
    static joinPath(t, ...e) {
      if (!t.path)
        throw new Error("[UriError]: cannot call joinPath on URI without path")
      let r
      return (
        Mi && t.scheme === "file"
          ? (r = A8.file(Fe.join(e_(t, !0), ...e)).path)
          : (r = Ut.join(t.path, ...e)),
        t.with({ path: r })
      )
    }
    toString(t = !1) {
      return bB(this, t)
    }
    toJSON() {
      return this
    }
    static revive(t) {
      if (t) {
        if (t instanceof A8) return t
        {
          const e = new ho(t)
          return (
            (e._formatted = t.external ?? null),
            (e._fsPath = t._sep === fW ? (t.fsPath ?? null) : null),
            e
          )
        }
      } else return t
    }
    [Symbol.for("debug.description")]() {
      return `URI(${this.toString()})`
    }
  }
function hW(i) {
  return !i || typeof i != "object"
    ? !1
    : typeof i.scheme == "string" &&
        (typeof i.authority == "string" || typeof i.authority > "u") &&
        (typeof i.path == "string" || typeof i.path > "u") &&
        (typeof i.query == "string" || typeof i.query > "u") &&
        (typeof i.fragment == "string" || typeof i.fragment > "u")
}
var fW = Mi ? 1 : void 0,
  ho = class extends S {
    constructor() {
      super(...arguments), (this._formatted = null), (this._fsPath = null)
    }
    get fsPath() {
      return this._fsPath || (this._fsPath = e_(this, !1)), this._fsPath
    }
    toString(i = !1) {
      return i
        ? bB(this, !0)
        : (this._formatted || (this._formatted = bB(this, !1)), this._formatted)
    }
    toJSON() {
      const i = { $mid: 1 }
      return (
        this._fsPath && ((i.fsPath = this._fsPath), (i._sep = fW)),
        this._formatted && (i.external = this._formatted),
        this.path && (i.path = this.path),
        this.scheme && (i.scheme = this.scheme),
        this.authority && (i.authority = this.authority),
        this.query && (i.query = this.query),
        this.fragment && (i.fragment = this.fragment),
        i
      )
    }
  },
  pW = {
    58: "%3A",
    47: "%2F",
    63: "%3F",
    35: "%23",
    91: "%5B",
    93: "%5D",
    64: "%40",
    33: "%21",
    36: "%24",
    38: "%26",
    39: "%27",
    40: "%28",
    41: "%29",
    42: "%2A",
    43: "%2B",
    44: "%2C",
    59: "%3B",
    61: "%3D",
    32: "%20",
  }
function gW(i, t, e) {
  let r,
    s = -1
  for (let a = 0; a < i.length; a++) {
    const o = i.charCodeAt(a)
    if (
      (o >= 97 && o <= 122) ||
      (o >= 65 && o <= 90) ||
      (o >= 48 && o <= 57) ||
      o === 45 ||
      o === 46 ||
      o === 95 ||
      o === 126 ||
      (t && o === 47) ||
      (e && o === 91) ||
      (e && o === 93) ||
      (e && o === 58)
    )
      s !== -1 && ((r += encodeURIComponent(i.substring(s, a))), (s = -1)),
        r !== void 0 && (r += i.charAt(a))
    else {
      r === void 0 && (r = i.substr(0, a))
      const c = pW[o]
      c !== void 0
        ? (s !== -1 && ((r += encodeURIComponent(i.substring(s, a))), (s = -1)),
          (r += c))
        : s === -1 && (s = a)
    }
  }
  return (
    s !== -1 && (r += encodeURIComponent(i.substring(s))), r !== void 0 ? r : i
  )
}
function vot(i) {
  let t
  for (let e = 0; e < i.length; e++) {
    const r = i.charCodeAt(e)
    r === 35 || r === 63
      ? (t === void 0 && (t = i.substr(0, e)), (t += pW[r]))
      : t !== void 0 && (t += i[e])
  }
  return t !== void 0 ? t : i
}
function e_(i, t) {
  let e
  return (
    i.authority && i.path.length > 1 && i.scheme === "file"
      ? (e = `//${i.authority}${i.path}`)
      : i.path.charCodeAt(0) === 47 &&
          ((i.path.charCodeAt(1) >= 65 && i.path.charCodeAt(1) <= 90) ||
            (i.path.charCodeAt(1) >= 97 && i.path.charCodeAt(1) <= 122)) &&
          i.path.charCodeAt(2) === 58
        ? t
          ? (e = i.path.substr(1))
          : (e = i.path[1].toLowerCase() + i.path.substr(2))
        : (e = i.path),
    Mi && (e = e.replace(/\//g, "\\")),
    e
  )
}
function bB(i, t) {
  const e = t ? vot : gW
  let r = "",
    { scheme: s, authority: a, path: o, query: c, fragment: u } = i
  if (
    (s && ((r += s), (r += ":")),
    (a || s === "file") && ((r += Sr), (r += Sr)),
    a)
  ) {
    let l = a.indexOf("@")
    if (l !== -1) {
      const m = a.substr(0, l)
      ;(a = a.substr(l + 1)),
        (l = m.lastIndexOf(":")),
        l === -1
          ? (r += e(m, !1, !1))
          : ((r += e(m.substr(0, l), !1, !1)),
            (r += ":"),
            (r += e(m.substr(l + 1), !1, !0))),
        (r += "@")
    }
    ;(a = a.toLowerCase()),
      (l = a.lastIndexOf(":")),
      l === -1
        ? (r += e(a, !1, !0))
        : ((r += e(a.substr(0, l), !1, !0)), (r += a.substr(l)))
  }
  if (o) {
    if (o.length >= 3 && o.charCodeAt(0) === 47 && o.charCodeAt(2) === 58) {
      const l = o.charCodeAt(1)
      l >= 65 &&
        l <= 90 &&
        (o = `/${String.fromCharCode(l + 32)}:${o.substr(3)}`)
    } else if (o.length >= 2 && o.charCodeAt(1) === 58) {
      const l = o.charCodeAt(0)
      l >= 65 &&
        l <= 90 &&
        (o = `${String.fromCharCode(l + 32)}:${o.substr(2)}`)
    }
    r += e(o, !0, !1)
  }
  return (
    c && ((r += "?"), (r += e(c, !1, !1))),
    u && ((r += "#"), (r += t ? u : gW(u, !1, !1))),
    r
  )
}
function vW(i) {
  try {
    return decodeURIComponent(i)
  } catch {
    return i.length > 3 ? i.substr(0, 3) + vW(i.substr(3)) : i
  }
}
var wW = /(%[0-9A-Za-z][0-9A-Za-z])+/g
function i_(i) {
  return i.match(wW) ? i.replace(wW, (t) => vW(t)) : i
}
var yW = class Snt {
    static {
      this.count = 0
    }
    constructor(t) {
      ;(this._proxyIdentifierBrand = void 0),
        (this.sid = t),
        (this.nid = ++Snt.count)
    }
  },
  TW = []
function _(i) {
  const t = new yW(i)
  return (TW[t.nid] = t), t
}
function r_(i) {
  return TW[i].sid
}
var Xi = class {
    constructor(i) {
      this.value = i
    }
  },
  kW
;(function (i) {
  ;(i[(i.Default = 0)] = "Default"),
    (i[(i.InCenter = 1)] = "InCenter"),
    (i[(i.InCenterIfOutsideViewport = 2)] = "InCenterIfOutsideViewport"),
    (i[(i.AtTop = 3)] = "AtTop")
})(kW || (kW = {}))
var SW
;(function (i) {
  ;(i[(i.UnknownInput = 0)] = "UnknownInput"),
    (i[(i.TextInput = 1)] = "TextInput"),
    (i[(i.TextDiffInput = 2)] = "TextDiffInput"),
    (i[(i.TextMergeInput = 3)] = "TextMergeInput"),
    (i[(i.NotebookInput = 4)] = "NotebookInput"),
    (i[(i.NotebookDiffInput = 5)] = "NotebookDiffInput"),
    (i[(i.CustomEditorInput = 6)] = "CustomEditorInput"),
    (i[(i.WebviewEditorInput = 7)] = "WebviewEditorInput"),
    (i[(i.TerminalEditorInput = 8)] = "TerminalEditorInput"),
    (i[(i.InteractiveEditorInput = 9)] = "InteractiveEditorInput"),
    (i[(i.ChatEditorInput = 10)] = "ChatEditorInput"),
    (i[(i.MultiDiffEditorInput = 11)] = "MultiDiffEditorInput")
})(SW || (SW = {}))
var bW
;(function (i) {
  ;(i[(i.TAB_OPEN = 0)] = "TAB_OPEN"),
    (i[(i.TAB_CLOSE = 1)] = "TAB_CLOSE"),
    (i[(i.TAB_UPDATE = 2)] = "TAB_UPDATE"),
    (i[(i.TAB_MOVE = 3)] = "TAB_MOVE")
})(bW || (bW = {}))
var EW
;(function (i) {
  ;(i[(i.Editable = 0)] = "Editable"),
    (i[(i.SupportsHotExit = 1)] = "SupportsHotExit")
})(EW || (EW = {}))
var IW
;(function (i) {
  ;(i[(i.Int8Array = 1)] = "Int8Array"),
    (i[(i.Uint8Array = 2)] = "Uint8Array"),
    (i[(i.Uint8ClampedArray = 3)] = "Uint8ClampedArray"),
    (i[(i.Int16Array = 4)] = "Int16Array"),
    (i[(i.Uint16Array = 5)] = "Uint16Array"),
    (i[(i.Int32Array = 6)] = "Int32Array"),
    (i[(i.Uint32Array = 7)] = "Uint32Array"),
    (i[(i.Float32Array = 8)] = "Float32Array"),
    (i[(i.Float64Array = 9)] = "Float64Array"),
    (i[(i.BigInt64Array = 10)] = "BigInt64Array"),
    (i[(i.BigUint64Array = 11)] = "BigUint64Array")
})(IW || (IW = {}))
var PW
;(function (i) {
  ;(i[(i.Text = 1)] = "Text"),
    (i[(i.Error = 2)] = "Error"),
    (i[(i.Rich = 3)] = "Rich")
})(PW || (PW = {}))
var NW
;(function (i) {
  ;(i[(i.Default = 0)] = "Default"),
    (i[(i.InCenter = 1)] = "InCenter"),
    (i[(i.InCenterIfOutsideViewport = 2)] = "InCenterIfOutsideViewport"),
    (i[(i.AtTop = 3)] = "AtTop")
})(NW || (NW = {}))
var EB
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Process = 1)] = "Process"),
    (i[(i.Output = 2)] = "Output"),
    (i[(i.Hybrid = 3)] = "Hybrid")
})(EB || (EB = {}))
var y8t = class bnt {
    static {
      this.a = 0
    }
    static mixin(t) {
      return (t._id = bnt.a++), t
    }
  },
  $W
;(function (i) {
  ;(i.label = "a"),
    (i.kind = "b"),
    (i.detail = "c"),
    (i.documentation = "d"),
    (i.sortText = "e"),
    (i.filterText = "f"),
    (i.preselect = "g"),
    (i.insertText = "h"),
    (i.insertTextRules = "i"),
    (i.range = "j"),
    (i.commitCharacters = "k"),
    (i.additionalTextEdits = "l"),
    (i.kindModifier = "m"),
    (i.commandIdent = "n"),
    (i.commandId = "o"),
    (i.commandArguments = "p")
})($W || ($W = {}))
var xW
;(function (i) {
  ;(i.defaultRanges = "a"),
    (i.completions = "b"),
    (i.isIncomplete = "c"),
    (i.duration = "d")
})(xW || (xW = {}))
var JW
;(function (i) {
  ;(i[(i.Workspace = 0)] = "Workspace"),
    (i[(i.TextDocument = 1)] = "TextDocument")
})(JW || (JW = {}))
var z = {
    MainThreadAuthentication: _("MainThreadAuthentication"),
    MainThreadBulkEdits: _("MainThreadBulkEdits"),
    MainThreadLanguageModels: _("MainThreadLanguageModels"),
    MainThreadEmbeddings: _("MainThreadEmbeddings"),
    MainThreadChatAgents2: _("MainThreadChatAgents2"),
    MainThreadCodeMapper: _("MainThreadCodeMapper"),
    MainThreadChatVariables: _("MainThreadChatVariables"),
    MainThreadLanguageModelTools: _("MainThreadChatSkills"),
    MainThreadClipboard: _("MainThreadClipboard"),
    MainThreadCommands: _("MainThreadCommands"),
    MainThreadComments: _("MainThreadComments"),
    MainThreadConfiguration: _("MainThreadConfiguration"),
    MainThreadConsole: _("MainThreadConsole"),
    MainThreadDebugService: _("MainThreadDebugService"),
    MainThreadDecorations: _("MainThreadDecorations"),
    MainThreadDiagnostics: _("MainThreadDiagnostics"),
    MainThreadDialogs: _("MainThreadDiaglogs"),
    MainThreadDocuments: _("MainThreadDocuments"),
    MainThreadDocumentContentProviders: _("MainThreadDocumentContentProviders"),
    MainThreadTextEditors: _("MainThreadTextEditors"),
    MainThreadEditorInsets: _("MainThreadEditorInsets"),
    MainThreadEditorTabs: _("MainThreadEditorTabs"),
    MainThreadErrors: _("MainThreadErrors"),
    MainThreadTreeViews: _("MainThreadTreeViews"),
    MainThreadDownloadService: _("MainThreadDownloadService"),
    MainThreadLanguageFeatures: _("MainThreadLanguageFeatures"),
    MainThreadLanguages: _("MainThreadLanguages"),
    MainThreadLogger: _("MainThreadLogger"),
    MainThreadMessageService: _("MainThreadMessageService"),
    MainThreadOutputService: _("MainThreadOutputService"),
    MainThreadProgress: _("MainThreadProgress"),
    MainThreadQuickDiff: _("MainThreadQuickDiff"),
    MainThreadQuickOpen: _("MainThreadQuickOpen"),
    MainThreadStatusBar: _("MainThreadStatusBar"),
    MainThreadSecretState: _("MainThreadSecretState"),
    MainThreadStorage: _("MainThreadStorage"),
    MainThreadSpeech: _("MainThreadSpeechProvider"),
    MainThreadTelemetry: _("MainThreadTelemetry"),
    MainThreadTerminalService: _("MainThreadTerminalService"),
    MainThreadTerminalShellIntegration: _("MainThreadTerminalShellIntegration"),
    MainThreadWebviews: _("MainThreadWebviews"),
    MainThreadWebviewPanels: _("MainThreadWebviewPanels"),
    MainThreadWebviewViews: _("MainThreadWebviewViews"),
    MainThreadCustomEditors: _("MainThreadCustomEditors"),
    MainThreadUrls: _("MainThreadUrls"),
    MainThreadUriOpeners: _("MainThreadUriOpeners"),
    MainThreadProfileContentHandlers: _("MainThreadProfileContentHandlers"),
    MainThreadWorkspace: _("MainThreadWorkspace"),
    MainThreadFileSystem: _("MainThreadFileSystem"),
    MainThreadFileSystemEventService: _("MainThreadFileSystemEventService"),
    MainThreadExtensionService: _("MainThreadExtensionService"),
    MainThreadSCM: _("MainThreadSCM"),
    MainThreadSearch: _("MainThreadSearch"),
    MainThreadShare: _("MainThreadShare"),
    MainThreadTask: _("MainThreadTask"),
    MainThreadWindow: _("MainThreadWindow"),
    MainThreadLabelService: _("MainThreadLabelService"),
    MainThreadNotebook: _("MainThreadNotebook"),
    MainThreadNotebookDocuments: _("MainThreadNotebookDocumentsShape"),
    MainThreadNotebookEditors: _("MainThreadNotebookEditorsShape"),
    MainThreadNotebookKernels: _("MainThreadNotebookKernels"),
    MainThreadNotebookRenderers: _("MainThreadNotebookRenderers"),
    MainThreadInteractive: _("MainThreadInteractive"),
    MainThreadTheming: _("MainThreadTheming"),
    MainThreadTunnelService: _("MainThreadTunnelService"),
    MainThreadManagedSockets: _("MainThreadManagedSockets"),
    MainThreadTimeline: _("MainThreadTimeline"),
    MainThreadTesting: _("MainThreadTesting"),
    MainThreadLocalization: _("MainThreadLocalizationShape"),
    MainThreadAiRelatedInformation: _("MainThreadAiRelatedInformation"),
    MainThreadAiEmbeddingVector: _("MainThreadAiEmbeddingVector"),
    MainThreadCursor: _("MainThreadCursor"),
  },
  rt = {
    ExtHostCodeMapper: _("ExtHostCodeMapper"),
    ExtHostCommands: _("ExtHostCommands"),
    ExtHostConfiguration: _("ExtHostConfiguration"),
    ExtHostDiagnostics: _("ExtHostDiagnostics"),
    ExtHostDebugService: _("ExtHostDebugService"),
    ExtHostDecorations: _("ExtHostDecorations"),
    ExtHostDocumentsAndEditors: _("ExtHostDocumentsAndEditors"),
    ExtHostDocuments: _("ExtHostDocuments"),
    ExtHostDocumentContentProviders: _("ExtHostDocumentContentProviders"),
    ExtHostDocumentSaveParticipant: _("ExtHostDocumentSaveParticipant"),
    ExtHostEditors: _("ExtHostEditors"),
    ExtHostTreeViews: _("ExtHostTreeViews"),
    ExtHostFileSystem: _("ExtHostFileSystem"),
    ExtHostFileSystemInfo: _("ExtHostFileSystemInfo"),
    ExtHostFileSystemEventService: _("ExtHostFileSystemEventService"),
    ExtHostLanguages: _("ExtHostLanguages"),
    ExtHostLanguageFeatures: _("ExtHostLanguageFeatures"),
    ExtHostQuickOpen: _("ExtHostQuickOpen"),
    ExtHostQuickDiff: _("ExtHostQuickDiff"),
    ExtHostStatusBar: _("ExtHostStatusBar"),
    ExtHostShare: _("ExtHostShare"),
    ExtHostExtensionService: _("ExtHostExtensionService"),
    ExtHostLogLevelServiceShape: _("ExtHostLogLevelServiceShape"),
    ExtHostTerminalService: _("ExtHostTerminalService"),
    ExtHostTerminalShellIntegration: _("ExtHostTerminalShellIntegration"),
    ExtHostSCM: _("ExtHostSCM"),
    ExtHostSearch: _("ExtHostSearch"),
    ExtHostTask: _("ExtHostTask"),
    ExtHostWorkspace: _("ExtHostWorkspace"),
    ExtHostWindow: _("ExtHostWindow"),
    ExtHostWebviews: _("ExtHostWebviews"),
    ExtHostWebviewPanels: _("ExtHostWebviewPanels"),
    ExtHostCustomEditors: _("ExtHostCustomEditors"),
    ExtHostWebviewViews: _("ExtHostWebviewViews"),
    ExtHostEditorInsets: _("ExtHostEditorInsets"),
    ExtHostEditorTabs: _("ExtHostEditorTabs"),
    ExtHostProgress: _("ExtHostProgress"),
    ExtHostComments: _("ExtHostComments"),
    ExtHostSecretState: _("ExtHostSecretState"),
    ExtHostStorage: _("ExtHostStorage"),
    ExtHostUrls: _("ExtHostUrls"),
    ExtHostUriOpeners: _("ExtHostUriOpeners"),
    ExtHostProfileContentHandlers: _("ExtHostProfileContentHandlers"),
    ExtHostOutputService: _("ExtHostOutputService"),
    ExtHostLabelService: _("ExtHostLabelService"),
    ExtHostNotebook: _("ExtHostNotebook"),
    ExtHostNotebookDocuments: _("ExtHostNotebookDocuments"),
    ExtHostNotebookEditors: _("ExtHostNotebookEditors"),
    ExtHostNotebookKernels: _("ExtHostNotebookKernels"),
    ExtHostNotebookRenderers: _("ExtHostNotebookRenderers"),
    ExtHostNotebookDocumentSaveParticipant: _(
      "ExtHostNotebookDocumentSaveParticipant",
    ),
    ExtHostInteractive: _("ExtHostInteractive"),
    ExtHostChatAgents2: _("ExtHostChatAgents"),
    ExtHostChatVariables: _("ExtHostChatVariables"),
    ExtHostLanguageModelTools: _("ExtHostChatSkills"),
    ExtHostChatProvider: _("ExtHostChatProvider"),
    ExtHostSpeech: _("ExtHostSpeech"),
    ExtHostEmbeddings: _("ExtHostEmbeddings"),
    ExtHostAiRelatedInformation: _("ExtHostAiRelatedInformation"),
    ExtHostAiEmbeddingVector: _("ExtHostAiEmbeddingVector"),
    ExtHostTheming: _("ExtHostTheming"),
    ExtHostTunnelService: _("ExtHostTunnelService"),
    ExtHostManagedSockets: _("ExtHostManagedSockets"),
    ExtHostAuthentication: _("ExtHostAuthentication"),
    ExtHostTimeline: _("ExtHostTimeline"),
    ExtHostTesting: _("ExtHostTesting"),
    ExtHostTelemetry: _("ExtHostTelemetry"),
    ExtHostLocalization: _("ExtHostLocalization"),
    ExtHostCursor: _("ExtHostCursor"),
  },
  CW = Object.freeze(function (i, t) {
    const e = setTimeout(i.bind(t), 0)
    return {
      dispose() {
        clearTimeout(e)
      },
    }
  }),
  fe
;(function (i) {
  function t(e) {
    return e === i.None || e === i.Cancelled || e instanceof n_
      ? !0
      : !e || typeof e != "object"
        ? !1
        : typeof e.isCancellationRequested == "boolean" &&
          typeof e.onCancellationRequested == "function"
  }
  ;(i.isCancellationToken = t),
    (i.None = Object.freeze({
      isCancellationRequested: !1,
      onCancellationRequested: Ee.None,
    })),
    (i.Cancelled = Object.freeze({
      isCancellationRequested: !0,
      onCancellationRequested: CW,
    }))
})(fe || (fe = {}))
var n_ = class {
    constructor() {
      ;(this.a = !1), (this.b = null)
    }
    cancel() {
      this.a || ((this.a = !0), this.b && (this.b.fire(void 0), this.dispose()))
    }
    get isCancellationRequested() {
      return this.a
    }
    get onCancellationRequested() {
      return this.a ? CW : (this.b || (this.b = new C()), this.b.event)
    }
    dispose() {
      this.b && (this.b.dispose(), (this.b = null))
    }
  },
  Ie = class {
    constructor(i) {
      ;(this.f = void 0),
        (this.g = void 0),
        (this.g = i && i.onCancellationRequested(this.cancel, this))
    }
    get token() {
      return this.f || (this.f = new n_()), this.f
    }
    cancel() {
      this.f ? this.f instanceof n_ && this.f.cancel() : (this.f = fe.Cancelled)
    }
    dispose(i = !1) {
      i && this.cancel(),
        this.g?.dispose(),
        this.f ? this.f instanceof n_ && this.f.dispose() : (this.f = fe.None)
    }
  }
function wot(i) {
  return i
}
var yot = class {
  constructor(i, t) {
    ;(this.a = void 0),
      (this.b = void 0),
      typeof i == "function"
        ? ((this.c = i), (this.d = wot))
        : ((this.c = t), (this.d = i.getCacheKey))
  }
  get(i) {
    const t = this.d(i)
    return this.b !== t && ((this.b = t), (this.a = this.c(i))), this.a
  }
}
function s_(i) {
  return !i || typeof i != "string" ? !0 : i.trim().length === 0
}
var Tot = /{([^}]+)}/g
function LW(i, t) {
  return Object.keys(t).length === 0 ? i : i.replace(Tot, (e, r) => t[r] ?? e)
}
function Ks(i) {
  return i.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&")
}
function kot(i, t) {
  let e = 0,
    r = i.indexOf(t)
  for (; r !== -1; ) e++, (r = i.indexOf(t, r + t.length))
  return e
}
function Sot(i, t) {
  if (!i || !t) return i
  const e = t.length
  if (e === 0 || i.length === 0) return i
  let r = 0
  for (; i.indexOf(t, r) === r; ) r = r + e
  return i.substring(r)
}
function IB(i, t) {
  if (!i || !t) return i
  const e = t.length,
    r = i.length
  if (e === 0 || r === 0) return i
  let s = r,
    a = -1
  for (; (a = i.lastIndexOf(t, s - 1)), !(a === -1 || a + e !== s); ) {
    if (a === 0) return ""
    s = a
  }
  return i.substring(0, s)
}
function bot(i, t, e = {}) {
  if (!i) throw new Error("Cannot create regex from empty string")
  t || (i = Ks(i)),
    e.wholeWord &&
      (/\B/.test(i.charAt(0)) || (i = "\\b" + i),
      /\B/.test(i.charAt(i.length - 1)) || (i = i + "\\b"))
  let r = ""
  return (
    e.global && (r += "g"),
    e.matchCase || (r += "i"),
    e.multiline && (r += "m"),
    e.unicode && (r += "u"),
    new RegExp(i, r)
  )
}
function RW(i) {
  return i.source === "^" ||
    i.source === "^$" ||
    i.source === "$" ||
    i.source === "^\\s*$"
    ? !1
    : !!(i.exec("") && i.lastIndex === 0)
}
function DW(i) {
  return i.split(/\r\n|\r|\n/)
}
function PB(i) {
  for (let t = 0, e = i.length; t < e; t++) {
    const r = i.charCodeAt(t)
    if (r !== 32 && r !== 9) return t
  }
  return -1
}
function Eot(i, t = i.length - 1) {
  for (let e = t; e >= 0; e--) {
    const r = i.charCodeAt(e)
    if (r !== 32 && r !== 9) return e
  }
  return -1
}
function Iot(i, t, e) {
  const r = []
  let s = 0
  for (const a of i.matchAll(t)) {
    if ((r.push(i.slice(s, a.index)), a.index === void 0))
      throw new Error("match.index should be defined")
    ;(s = a.index + a[0].length),
      r.push(e(a[0], ...a.slice(1), a.index, i, a.groups))
  }
  return r.push(i.slice(s)), Promise.all(r).then((a) => a.join(""))
}
function Zs(i, t) {
  return i < t ? -1 : i > t ? 1 : 0
}
function NB(i, t, e = 0, r = i.length, s = 0, a = t.length) {
  for (; e < r && s < a; e++, s++) {
    const u = i.charCodeAt(e),
      l = t.charCodeAt(s)
    if (u < l) return -1
    if (u > l) return 1
  }
  const o = r - e,
    c = a - s
  return o < c ? -1 : o > c ? 1 : 0
}
function FW(i, t) {
  return Lu(i, t, 0, i.length, 0, t.length)
}
function Lu(i, t, e = 0, r = i.length, s = 0, a = t.length) {
  for (; e < r && s < a; e++, s++) {
    let u = i.charCodeAt(e),
      l = t.charCodeAt(s)
    if (u === l) continue
    if (u >= 128 || l >= 128)
      return NB(i.toLowerCase(), t.toLowerCase(), e, r, s, a)
    _W(u) && (u -= 32), _W(l) && (l -= 32)
    const m = u - l
    if (m !== 0) return m
  }
  const o = r - e,
    c = a - s
  return o < c ? -1 : o > c ? 1 : 0
}
function _W(i) {
  return i >= 97 && i <= 122
}
function as(i, t) {
  return i.length === t.length && Lu(i, t) === 0
}
function $B(i, t) {
  const e = t.length
  return t.length > i.length ? !1 : Lu(i, t, 0, e) === 0
}
function Pot(i, t) {
  const e = Math.min(i.length, t.length)
  let r
  for (r = 0; r < e; r++) if (i.charCodeAt(r) !== t.charCodeAt(r)) return r
  return e
}
function a_(i) {
  return 55296 <= i && i <= 56319
}
function o_(i) {
  return 56320 <= i && i <= 57343
}
function xB(i, t) {
  return ((i - 55296) << 10) + (t - 56320) + 65536
}
function AW(i, t, e) {
  const r = i.charCodeAt(e)
  if (a_(r) && e + 1 < t) {
    const s = i.charCodeAt(e + 1)
    if (o_(s)) return xB(r, s)
  }
  return r
}
function Not(i, t) {
  const e = i.charCodeAt(t - 1)
  if (o_(e) && t > 1) {
    const r = i.charCodeAt(t - 2)
    if (a_(r)) return xB(r, e)
  }
  return e
}
var $ot = class {
    get offset() {
      return this.e
    }
    constructor(i, t = 0) {
      ;(this.c = i), (this.d = i.length), (this.e = t)
    }
    setOffset(i) {
      this.e = i
    }
    prevCodePoint() {
      const i = Not(this.c, this.e)
      return (this.e -= i >= 65536 ? 2 : 1), i
    }
    nextCodePoint() {
      const i = AW(this.c, this.d, this.e)
      return (this.e += i >= 65536 ? 2 : 1), i
    }
    eol() {
      return this.e >= this.d
    }
  },
  xot = class {
    get offset() {
      return this.c.offset
    }
    constructor(i, t = 0) {
      this.c = new $ot(i, t)
    }
    nextGraphemeLength() {
      const i = WW.getInstance(),
        t = this.c,
        e = t.offset
      let r = i.getGraphemeBreakType(t.nextCodePoint())
      for (; !t.eol(); ) {
        const s = t.offset,
          a = i.getGraphemeBreakType(t.nextCodePoint())
        if (MW(r, a)) {
          t.setOffset(s)
          break
        }
        r = a
      }
      return t.offset - e
    }
    prevGraphemeLength() {
      const i = WW.getInstance(),
        t = this.c,
        e = t.offset
      let r = i.getGraphemeBreakType(t.prevCodePoint())
      for (; t.offset > 0; ) {
        const s = t.offset,
          a = i.getGraphemeBreakType(t.prevCodePoint())
        if (MW(a, r)) {
          t.setOffset(s)
          break
        }
        r = a
      }
      return e - t.offset
    }
    eol() {
      return this.c.eol()
    }
  }
function BW(i, t) {
  return new xot(i, t).nextGraphemeLength()
}
var JB = void 0
function Jot() {
  return /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDC7\uFDF0-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE35\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDD23\uDE80-\uDEA9\uDEAD-\uDF45\uDF51-\uDF81\uDF86-\uDFF6]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD4B-\uDFFF]|\uD83B[\uDC00-\uDEBB])/
}
function OW(i) {
  return JB || (JB = Jot()), JB.test(i)
}
var Cot = /^[\t\n\r\x20-\x7E]*$/
function Lot(i) {
  return Cot.test(i)
}
var Rot = /[\u2028\u2029]/
function qW(i) {
  return Rot.test(i)
}
var Dot = "\uFEFF"
function Fot(i) {
  return !!(i && i.length > 0 && i.charCodeAt(0) === 65279)
}
function UW(i, t = !1) {
  return i ? (t && (i = i.replace(/\\./g, "")), i.toLowerCase() !== i) : !1
}
function _ot(i, t = 1) {
  if (t === 0) return ""
  let e = -1
  do
    (e = i.indexOf(
      `
`,
      e + 1,
    )),
      t--
  while (t > 0 && e >= 0)
  return e === -1 ? i : (i[e - 1] === "\r" && e--, i.substr(0, e))
}
function MW(i, t) {
  return i === 0
    ? t !== 5 && t !== 7
    : i === 2 && t === 3
      ? !1
      : i === 4 || i === 2 || i === 3 || t === 4 || t === 2 || t === 3
        ? !0
        : !(
            (i === 8 && (t === 8 || t === 9 || t === 11 || t === 12)) ||
            ((i === 11 || i === 9) && (t === 9 || t === 10)) ||
            ((i === 12 || i === 10) && t === 10) ||
            t === 5 ||
            t === 13 ||
            t === 7 ||
            i === 1 ||
            (i === 13 && t === 14) ||
            (i === 6 && t === 6)
          )
}
var HW
;(function (i) {
  ;(i[(i.Other = 0)] = "Other"),
    (i[(i.Prepend = 1)] = "Prepend"),
    (i[(i.CR = 2)] = "CR"),
    (i[(i.LF = 3)] = "LF"),
    (i[(i.Control = 4)] = "Control"),
    (i[(i.Extend = 5)] = "Extend"),
    (i[(i.Regional_Indicator = 6)] = "Regional_Indicator"),
    (i[(i.SpacingMark = 7)] = "SpacingMark"),
    (i[(i.L = 8)] = "L"),
    (i[(i.V = 9)] = "V"),
    (i[(i.T = 10)] = "T"),
    (i[(i.LV = 11)] = "LV"),
    (i[(i.LVT = 12)] = "LVT"),
    (i[(i.ZWJ = 13)] = "ZWJ"),
    (i[(i.Extended_Pictographic = 14)] = "Extended_Pictographic")
})(HW || (HW = {}))
var WW = class Nh {
  static {
    this.c = null
  }
  static getInstance() {
    return Nh.c || (Nh.c = new Nh()), Nh.c
  }
  constructor() {
    this.d = Aot()
  }
  getGraphemeBreakType(t) {
    if (t < 32) return t === 10 ? 3 : t === 13 ? 2 : 4
    if (t < 127) return 0
    const e = this.d,
      r = e.length / 3
    let s = 1
    for (; s <= r; )
      if (t < e[3 * s]) s = 2 * s
      else if (t > e[3 * s + 1]) s = 2 * s + 1
      else return e[3 * s + 2]
    return 0
  }
}
function Aot() {
  return JSON.parse(
    "[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]",
  )
}
var jW
;(function (i) {
  ;(i[(i.zwj = 8205)] = "zwj"),
    (i[(i.emojiVariantSelector = 65039)] = "emojiVariantSelector"),
    (i[(i.enclosingKeyCap = 8419)] = "enclosingKeyCap")
})(jW || (jW = {}))
var T8t = class $h {
    static {
      this.c = new qi(() =>
        JSON.parse(
          '{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}',
        ),
      )
    }
    static {
      this.d = new yot({ getCacheKey: JSON.stringify }, (t) => {
        function e(m) {
          const h = new Map()
          for (let p = 0; p < m.length; p += 2) h.set(m[p], m[p + 1])
          return h
        }
        function r(m, h) {
          const p = new Map(m)
          for (const [g, w] of h) p.set(g, w)
          return p
        }
        function s(m, h) {
          if (!m) return h
          const p = new Map()
          for (const [g, w] of m) h.has(g) && p.set(g, w)
          return p
        }
        const a = this.c.value
        let o = t.filter((m) => !m.startsWith("_") && m in a)
        o.length === 0 && (o = ["_default"])
        let c
        for (const m of o) {
          const h = e(a[m])
          c = s(c, h)
        }
        const u = e(a._common),
          l = r(u, c)
        return new $h(l)
      })
    }
    static getInstance(t) {
      return $h.d.get(Array.from(t))
    }
    static {
      this.e = new qi(() =>
        Object.keys($h.c.value).filter((t) => !t.startsWith("_")),
      )
    }
    static getLocales() {
      return $h.e.value
    }
    constructor(t) {
      this.f = t
    }
    isAmbiguous(t) {
      return this.f.has(t)
    }
    containsAmbiguousCharacter(t) {
      for (let e = 0; e < t.length; e++) {
        const r = t.codePointAt(e)
        if (typeof r == "number" && this.isAmbiguous(r)) return !0
      }
      return !1
    }
    getPrimaryConfusable(t) {
      return this.f.get(t)
    }
    getConfusableCodePoints() {
      return new Set(this.f.keys())
    }
  },
  k8t = class xh {
    static c() {
      return JSON.parse(
        "[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]",
      )
    }
    static {
      this.d = void 0
    }
    static e() {
      return this.d || (this.d = new Set(xh.c())), this.d
    }
    static isInvisibleCharacter(t) {
      return xh.e().has(t)
    }
    static containsInvisibleCharacter(t) {
      for (let e = 0; e < t.length; e++) {
        const r = t.codePointAt(e)
        if (typeof r == "number" && xh.isInvisibleCharacter(r)) return !0
      }
      return !1
    }
    static get codePoints() {
      return xh.e()
    }
  }
function Bt(i) {
  return typeof i == "string"
}
function Bot(i) {
  return Array.isArray(i) && i.every((t) => Bt(t))
}
function Ce(i) {
  return (
    typeof i == "object" &&
    i !== null &&
    !Array.isArray(i) &&
    !(i instanceof RegExp) &&
    !(i instanceof Date)
  )
}
function Oot(i) {
  const t = Object.getPrototypeOf(Uint8Array)
  return typeof i == "object" && i instanceof t
}
function os(i) {
  return typeof i == "number" && !isNaN(i)
}
function Ru(i) {
  return typeof i > "u"
}
function ta(i) {
  return !Le(i)
}
function Le(i) {
  return Ru(i) || i === null
}
function VW(i, t) {
  if (!i)
    throw new Error(t ? `Unexpected type, expected '${t}'` : "Unexpected type")
}
function fo(i) {
  if (Le(i)) throw new Error("Assertion Failed: argument is undefined or null")
  return i
}
var qot = Object.prototype.hasOwnProperty
function GW(i) {
  if (!Ce(i)) return !1
  for (const t in i) if (qot.call(i, t)) return !1
  return !0
}
function Uot(i) {
  return typeof i == "function"
}
function Mot(i, t) {
  if (Bt(t)) {
    if (typeof i !== t)
      throw new Error(`argument does not match constraint: typeof ${t}`)
  } else if (Uot(t)) {
    try {
      if (i instanceof t) return
    } catch {}
    if (
      (!Le(i) && i.constructor === t) ||
      (t.length === 1 && t.call(void 0, i) === !0)
    )
      return
    throw new Error(
      "argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true",
    )
  }
}
function cs(i) {
  return i === 47 || i === 92
}
function zW(i) {
  return i.replace(/[\\/]/g, Ut.sep)
}
function Hot(i) {
  return (
    i.indexOf("/") === -1 && (i = zW(i)),
    /^[a-zA-Z]:(\/|$)/.test(i) && (i = "/" + i),
    i
  )
}
function YW(i, t = Ut.sep) {
  if (!i) return ""
  const e = i.length,
    r = i.charCodeAt(0)
  if (cs(r)) {
    if (cs(i.charCodeAt(1)) && !cs(i.charCodeAt(2))) {
      let a = 3
      const o = a
      for (; a < e && !cs(i.charCodeAt(a)); a++);
      if (o !== a && !cs(i.charCodeAt(a + 1))) {
        for (a += 1; a < e; a++)
          if (cs(i.charCodeAt(a))) return i.slice(0, a + 1).replace(/[\\/]/g, t)
      }
    }
    return t
  } else if (QW(r) && i.charCodeAt(1) === 58)
    return cs(i.charCodeAt(2)) ? i.slice(0, 2) + t : i.slice(0, 2)
  let s = i.indexOf("://")
  if (s !== -1) {
    for (s += 3; s < e; s++) if (cs(i.charCodeAt(s))) return i.slice(0, s + 1)
  }
  return ""
}
var Wot = /[\\/:\*\?"<>\|]/g,
  jot = /[/]/g,
  Vot = /^(con|prn|aux|clock\$|nul|lpt[0-9]|com[0-9])(\.(.*?))?$/i
function Got(i, t = Mi) {
  const e = t ? Wot : jot
  return !(
    !i ||
    i.length === 0 ||
    /^\s+$/.test(i) ||
    ((e.lastIndex = 0), e.test(i)) ||
    (t && Vot.test(i)) ||
    i === "." ||
    i === ".." ||
    (t && i[i.length - 1] === ".") ||
    (t && i.length !== i.trim().length) ||
    i.length > 255
  )
}
function c_(i, t, e, r = kr) {
  if (i === t) return !0
  if (!i || !t || t.length > i.length) return !1
  if (e) {
    if (!$B(i, t)) return !1
    if (t.length === i.length) return !0
    let a = t.length
    return t.charAt(t.length - 1) === r && a--, i.charAt(a) === r
  }
  return t.charAt(t.length - 1) !== r && (t += r), i.indexOf(t) === 0
}
function QW(i) {
  return (i >= 65 && i <= 90) || (i >= 97 && i <= 122)
}
function zot(i, t = Mi) {
  return t ? QW(i.charCodeAt(0)) && i.charCodeAt(1) === 58 : !1
}
var Q
;(function (i) {
  ;(i.inMemory = "inmemory"),
    (i.vscode = "vscode"),
    (i.internal = "private"),
    (i.walkThrough = "walkThrough"),
    (i.walkThroughSnippet = "walkThroughSnippet"),
    (i.http = "http"),
    (i.https = "https"),
    (i.file = "file"),
    (i.mailto = "mailto"),
    (i.untitled = "untitled"),
    (i.data = "data"),
    (i.command = "command"),
    (i.vscodeRemote = "vscode-remote"),
    (i.vscodeRemoteResource = "vscode-remote-resource"),
    (i.vscodeManagedRemoteResource = "vscode-managed-remote-resource"),
    (i.vscodeUserData = "vscode-userdata"),
    (i.vscodeCustomEditor = "vscode-custom-editor"),
    (i.vscodeNotebook = "vscode-notebook"),
    (i.vscodeNotebookCell = "vscode-notebook-cell"),
    (i.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata"),
    (i.vscodeNotebookCellMetadataDiff = "vscode-notebook-cell-metadata-diff"),
    (i.vscodeNotebookCellOutput = "vscode-notebook-cell-output"),
    (i.vscodeNotebookCellOutputDiff = "vscode-notebook-cell-output-diff"),
    (i.vscodeNotebookMetadata = "vscode-notebook-metadata"),
    (i.vscodeInteractiveInput = "vscode-interactive-input"),
    (i.vscodeSettings = "vscode-settings"),
    (i.vscodeWorkspaceTrust = "vscode-workspace-trust"),
    (i.vscodeTerminal = "vscode-terminal"),
    (i.vscodeChatCodeBlock = "vscode-chat-code-block"),
    (i.vscodeChatCodeCompareBlock = "vscode-chat-code-compare-block"),
    (i.vscodeChatSesssion = "vscode-chat-editor"),
    (i.webviewPanel = "webview-panel"),
    (i.vscodeWebview = "vscode-webview"),
    (i.extension = "extension"),
    (i.aiChat = "cursor.aichat"),
    (i.notepad = "cursor.notepad"),
    (i.contextObject = "cursor.context-object"),
    (i.composer = "cursor.composer"),
    (i.aiSettings = "cursor.aisettings"),
    (i.tinderDiffEditor = "cursor.tinderdiffeditor"),
    (i.aiReader = "cursor.aireader"),
    (i.vscodeFileResource = "vscode-file"),
    (i.tmp = "tmp"),
    (i.vsls = "vsls"),
    (i.vscodeSourceControl = "vscode-scm"),
    (i.commentsInput = "comment"),
    (i.codeSetting = "code-setting"),
    (i.cursorDev = "cursor-dev"),
    (i.outputChannel = "output"),
    (i.accessibleView = "accessible-view"),
    (i.bugbot = "cursor.bugbot")
})(Q || (Q = {}))
function CB(i, t) {
  return S.isUri(i) ? as(i.scheme, t) : $B(i, t + ":")
}
function Yot(i, ...t) {
  return t.some((e) => CB(i, e))
}
var Qot = "tkn",
  Xot = class {
    constructor() {
      ;(this.a = Object.create(null)),
        (this.b = Object.create(null)),
        (this.c = Object.create(null)),
        (this.d = "http"),
        (this.e = null),
        (this.f = "/")
    }
    setPreferredWebSchema(i) {
      this.d = i
    }
    setDelegate(i) {
      this.e = i
    }
    setServerRootPath(i, t) {
      this.f = Zot(i, t)
    }
    getServerRootPath() {
      return this.f
    }
    get g() {
      return Ut.join(this.f, Q.vscodeRemoteResource)
    }
    set(i, t, e) {
      ;(this.a[i] = t), (this.b[i] = e)
    }
    setConnectionToken(i, t) {
      this.c[i] = t
    }
    getPreferredWebSchema() {
      return this.d
    }
    rewrite(i) {
      if (this.e)
        try {
          return this.e(i)
        } catch (o) {
          return Ui(o), i
        }
      const t = i.authority
      let e = this.a[t]
      e && e.indexOf(":") !== -1 && e.indexOf("[") === -1 && (e = `[${e}]`)
      const r = this.b[t],
        s = this.c[t]
      let a = `path=${encodeURIComponent(i.path)}`
      return (
        typeof s == "string" && (a += `&${Qot}=${encodeURIComponent(s)}`),
        S.from({
          scheme: vB ? this.d : Q.vscodeRemoteResource,
          authority: `${e}:${r}`,
          path: this.g,
          query: a,
        })
      )
    }
  },
  Kot = new Xot()
function Zot(i, t) {
  return Ut.join(t ?? "/", `${i.quality ?? "oss"}-${i.commit ?? "dev"}`)
}
var tct = "vscode-app",
  ect = class B8 {
    static {
      this.a = tct
    }
    asBrowserUri(t) {
      const e = this.b(t)
      return this.uriToBrowserUri(e)
    }
    uriToBrowserUri(t) {
      return t.scheme === Q.vscodeRemote
        ? Kot.rewrite(t)
        : t.scheme === Q.file &&
            (rW || Yat === `${Q.vscodeFileResource}://${B8.a}`)
          ? t.with({
              scheme: Q.vscodeFileResource,
              authority: t.authority || B8.a,
              query: null,
              fragment: null,
            })
          : t
    }
    asFileUri(t) {
      const e = this.b(t)
      return this.uriToFileUri(e)
    }
    uriToFileUri(t) {
      return t.scheme === Q.vscodeFileResource
        ? t.with({
            scheme: Q.file,
            authority: t.authority !== B8.a ? t.authority : null,
            query: null,
            fragment: null,
          })
        : t
    }
    b(t, e) {
      if (S.isUri(t)) return t
      if (globalThis._VSCODE_FILE_ROOT) {
        const r = globalThis._VSCODE_FILE_ROOT
        if (/^\w[\w\d+.-]*:\/\//.test(r)) return S.joinPath(S.parse(r, !0), t)
        const s = kB(r, t)
        return S.file(s)
      }
      return S.parse(e.toUrl(t))
    }
  },
  ict = new ect(),
  XW
;(function (i) {
  const t = new Map([
    ["1", { "Cross-Origin-Opener-Policy": "same-origin" }],
    ["2", { "Cross-Origin-Embedder-Policy": "require-corp" }],
    [
      "3",
      {
        "Cross-Origin-Opener-Policy": "same-origin",
        "Cross-Origin-Embedder-Policy": "require-corp",
      },
    ],
  ])
  i.CoopAndCoep = Object.freeze(t.get("3"))
  const e = "vscode-coi"
  function r(a) {
    let o
    typeof a == "string"
      ? (o = new URL(a).searchParams)
      : a instanceof URL
        ? (o = a.searchParams)
        : S.isUri(a) && (o = new URL(a.toString(!0)).searchParams)
    const c = o?.get(e)
    if (c) return t.get(c)
  }
  i.getHeadersFromQuery = r
  function s(a, o, c) {
    if (!globalThis.crossOriginIsolated) return
    const u = o && c ? "3" : c ? "2" : "1"
    a instanceof URLSearchParams ? a.set(e, u) : (a[e] = u)
  }
  i.addSearchParam = s
})(XW || (XW = {}))
function br(i) {
  return e_(i, !0)
}
var Du = class {
    constructor(i) {
      this.a = i
    }
    compare(i, t, e = !1) {
      return i === t
        ? 0
        : Zs(this.getComparisonKey(i, e), this.getComparisonKey(t, e))
    }
    isEqual(i, t, e = !1) {
      return i === t
        ? !0
        : !i || !t
          ? !1
          : this.getComparisonKey(i, e) === this.getComparisonKey(t, e)
    }
    getComparisonKey(i, t = !1) {
      return i
        .with({
          path: this.a(i) ? i.path.toLowerCase() : void 0,
          fragment: t ? null : void 0,
        })
        .toString()
    }
    ignorePathCasing(i) {
      return this.a(i)
    }
    isEqualOrParent(i, t, e = !1) {
      if (i.scheme === t.scheme) {
        if (i.scheme === Q.file)
          return (
            c_(br(i), br(t), this.a(i)) &&
            i.query === t.query &&
            (e || i.fragment === t.fragment)
          )
        if (tj(i.authority, t.authority))
          return (
            c_(i.path, t.path, this.a(i), "/") &&
            i.query === t.query &&
            (e || i.fragment === t.fragment)
          )
      }
      return !1
    }
    joinPath(i, ...t) {
      return S.joinPath(i, ...t)
    }
    basenameOrAuthority(i) {
      return us(i) || i.authority
    }
    basename(i) {
      return Ut.basename(i.path)
    }
    extname(i) {
      return Ut.extname(i.path)
    }
    dirname(i) {
      if (i.path.length === 0) return i
      let t
      return (
        i.scheme === Q.file
          ? (t = S.file(mo(br(i))).path)
          : ((t = Ut.dirname(i.path)),
            i.authority &&
              t.length &&
              t.charCodeAt(0) !== 47 &&
              (console.error(
                `dirname("${i.toString})) resulted in a relative path`,
              ),
              (t = "/"))),
        i.with({ path: t })
      )
    }
    normalizePath(i) {
      if (!i.path.length) return i
      let t
      return (
        i.scheme === Q.file
          ? (t = S.file(lo(br(i))).path)
          : (t = Ut.normalize(i.path)),
        i.with({ path: t })
      )
    }
    relativePath(i, t) {
      if (i.scheme !== t.scheme || !tj(i.authority, t.authority)) return
      if (i.scheme === Q.file) {
        const s = Cu(br(i), br(t))
        return Mi ? zW(s) : s
      }
      let e = i.path || "/"
      const r = t.path || "/"
      if (this.a(i)) {
        let s = 0
        for (
          const a = Math.min(e.length, r.length);
          s < a &&
          !(
            e.charCodeAt(s) !== r.charCodeAt(s) &&
            e.charAt(s).toLowerCase() !== r.charAt(s).toLowerCase()
          );
          s++
        );
        e = r.substr(0, s) + e.substr(s)
      }
      return Ut.relative(e, r)
    }
    resolvePath(i, t) {
      if (i.scheme === Q.file) {
        const e = S.file(uot(br(i), t))
        return i.with({ authority: e.authority, path: e.path })
      }
      return (t = Hot(t)), i.with({ path: Ut.resolve(i.path, t) })
    }
    isAbsolutePath(i) {
      return !!i.path && i.path[0] === "/"
    }
    isEqualAuthority(i, t) {
      return i === t || (i !== void 0 && t !== void 0 && as(i, t))
    }
    hasTrailingPathSeparator(i, t = kr) {
      if (i.scheme === Q.file) {
        const e = br(i)
        return e.length > YW(e).length && e[e.length - 1] === t
      } else {
        const e = i.path
        return (
          e.length > 1 &&
          e.charCodeAt(e.length - 1) === 47 &&
          !/^[a-zA-Z]:(\/$|\\$)/.test(i.fsPath)
        )
      }
    }
    removeTrailingPathSeparator(i, t = kr) {
      return ej(i, t)
        ? i.with({ path: i.path.substr(0, i.path.length - 1) })
        : i
    }
    addTrailingPathSeparator(i, t = kr) {
      let e = !1
      if (i.scheme === Q.file) {
        const r = br(i)
        e = r !== void 0 && r.length === YW(r).length && r[r.length - 1] === t
      } else {
        t = "/"
        const r = i.path
        e = r.length === 1 && r.charCodeAt(r.length - 1) === 47
      }
      return !e && !ej(i, t) ? i.with({ path: i.path + "/" }) : i
    }
  },
  jt = new Du(() => !1),
  rct = new Du((i) => (i.scheme === Q.file ? !es : !0)),
  nct = new Du((i) => !0),
  KW = jt.isEqual.bind(jt),
  S8t = jt.isEqualOrParent.bind(jt),
  b8t = jt.getComparisonKey.bind(jt),
  LB = jt.basenameOrAuthority.bind(jt),
  us = jt.basename.bind(jt),
  E8t = jt.extname.bind(jt),
  RB = jt.dirname.bind(jt),
  Ti = jt.joinPath.bind(jt),
  I8t = jt.normalizePath.bind(jt),
  ZW = jt.relativePath.bind(jt),
  P8t = jt.resolvePath.bind(jt),
  sct = jt.isAbsolutePath.bind(jt),
  tj = jt.isEqualAuthority.bind(jt),
  ej = jt.hasTrailingPathSeparator.bind(jt),
  N8t = jt.removeTrailingPathSeparator.bind(jt),
  $8t = jt.addTrailingPathSeparator.bind(jt),
  ij
;(function (i) {
  ;(i.META_DATA_LABEL = "label"),
    (i.META_DATA_DESCRIPTION = "description"),
    (i.META_DATA_SIZE = "size"),
    (i.META_DATA_MIME = "mime")
  function t(e) {
    const r = new Map()
    e.path
      .substring(e.path.indexOf(";") + 1, e.path.lastIndexOf(";"))
      .split(";")
      .forEach((o) => {
        const [c, u] = o.split(":")
        c && u && r.set(c, u)
      })
    const a = e.path.substring(0, e.path.indexOf(";"))
    return a && r.set(i.META_DATA_MIME, a), r
  }
  i.parseMetaData = t
})(ij || (ij = {}))
var act = Symbol("MicrotaskDelay")
function wn(i) {
  return !!i && typeof i.then == "function"
}
function oct(i) {
  const t = new Ie(),
    e = i(t.token),
    r = new Promise((s, a) => {
      const o = t.token.onCancellationRequested(() => {
        o.dispose(), a(new zr())
      })
      Promise.resolve(e).then(
        (c) => {
          o.dispose(), t.dispose(), s(c)
        },
        (c) => {
          o.dispose(), t.dispose(), a(c)
        },
      )
    })
  return new (class {
    cancel() {
      t.cancel(), t.dispose()
    }
    then(s, a) {
      return r.then(s, a)
    }
    catch(s) {
      return this.then(void 0, s)
    }
    finally(s) {
      return r.finally(s)
    }
  })()
}
function rj(i, t, e) {
  return new Promise((r, s) => {
    const a = t.onCancellationRequested(() => {
      a.dispose(), r(e)
    })
    i.then(r, s).finally(() => a.dispose())
  })
}
function cct(i, t) {
  return new Promise((e, r) => {
    const s = t.onCancellationRequested(() => {
      s.dispose(), r(new zr())
    })
    i.then(e, r).finally(() => s.dispose())
  })
}
function gi(i) {
  return new Promise((t, e) => {
    const r = i()
    wn(r) ? r.then(t, e) : t(r)
  })
}
function uct() {
  let i, t
  return {
    promise: new Promise((r, s) => {
      ;(i = r), (t = s)
    }),
    resolve: i,
    reject: t,
  }
}
var lct = class {
    constructor() {
      ;(this.f = !1), (this.a = null), (this.b = null), (this.d = null)
    }
    queue(i) {
      if (this.f) return Promise.reject(new Error("Throttler is disposed"))
      if (this.a) {
        if (((this.d = i), !this.b)) {
          const t = () => {
            if (((this.b = null), this.f)) return
            const e = this.queue(this.d)
            return (this.d = null), e
          }
          this.b = new Promise((e) => {
            this.a.then(t, t).then(e)
          })
        }
        return new Promise((t, e) => {
          this.b.then(t, e)
        })
      }
      return (
        (this.a = i()),
        new Promise((t, e) => {
          this.a.then(
            (r) => {
              ;(this.a = null), t(r)
            },
            (r) => {
              ;(this.a = null), e(r)
            },
          )
        })
      )
    }
    dispose() {
      this.f = !0
    }
  },
  dct = (i, t) => {
    let e = !0
    const r = setTimeout(() => {
      ;(e = !1), t()
    }, i)
    return {
      isTriggered: () => e,
      dispose: () => {
        clearTimeout(r), (e = !1)
      },
    }
  },
  mct = (i) => {
    let t = !0
    return (
      queueMicrotask(() => {
        t && ((t = !1), i())
      }),
      {
        isTriggered: () => t,
        dispose: () => {
          t = !1
        },
      }
    )
  },
  hct = class {
    constructor(i) {
      ;(this.defaultDelay = i),
        (this.a = null),
        (this.b = null),
        (this.d = null),
        (this.f = null),
        (this.g = null)
    }
    trigger(i, t = this.defaultDelay) {
      ;(this.g = i),
        this.h(),
        this.b ||
          (this.b = new Promise((r, s) => {
            ;(this.d = r), (this.f = s)
          }).then(() => {
            if (((this.b = null), (this.d = null), this.g)) {
              const r = this.g
              return (this.g = null), r()
            }
          }))
      const e = () => {
        ;(this.a = null), this.d?.(null)
      }
      return (this.a = t === act ? mct(e) : dct(t, e)), this.b
    }
    isTriggered() {
      return !!this.a?.isTriggered()
    }
    cancel() {
      this.h(), this.b && (this.f?.(new zr()), (this.b = null))
    }
    h() {
      this.a?.dispose(), (this.a = null)
    }
    dispose() {
      this.cancel()
    }
  },
  fct = class {
    constructor(i) {
      ;(this.a = new hct(i)), (this.b = new lct())
    }
    trigger(i, t) {
      return this.a.trigger(() => this.b.queue(i), t)
    }
    isTriggered() {
      return this.a.isTriggered()
    }
    cancel() {
      this.a.cancel()
    }
    dispose() {
      this.a.dispose(), this.b.dispose()
    }
  },
  Xr = class {
    constructor() {
      ;(this.a = !1),
        (this.b = new Promise((i, t) => {
          this.d = i
        }))
    }
    isOpen() {
      return this.a
    }
    open() {
      ;(this.a = !0), this.d(!0)
    }
    wait() {
      return this.b
    }
  }
function Kr(i, t) {
  return t
    ? new Promise((e, r) => {
        const s = setTimeout(() => {
            a.dispose(), e()
          }, i),
          a = t.onCancellationRequested(() => {
            clearTimeout(s), a.dispose(), r(new zr())
          })
      })
    : oct((e) => Kr(i, e))
}
function pct(i, t = 0, e) {
  const r = setTimeout(() => {
      i(), e && s.dispose()
    }, t),
    s = it(() => {
      clearTimeout(r), e?.deleteAndLeak(s)
    })
  return e?.add(s), s
}
var gct = class {
    constructor(i) {
      ;(this.a = 0),
        (this.b = !1),
        (this.f = i),
        (this.g = []),
        (this.d = 0),
        (this.h = new C())
    }
    whenIdle() {
      return this.size > 0 ? Ee.toPromise(this.onDrained) : Promise.resolve()
    }
    get onDrained() {
      return this.h.event
    }
    get size() {
      return this.a
    }
    queue(i) {
      if (this.b) throw new Error("Object has been disposed")
      return (
        this.a++,
        new Promise((t, e) => {
          this.g.push({ factory: i, c: t, e }), this.j()
        })
      )
    }
    j() {
      for (; this.g.length && this.d < this.f; ) {
        const i = this.g.shift()
        this.d++
        const t = i.factory()
        t.then(i.c, i.e),
          t.then(
            () => this.k(),
            () => this.k(),
          )
      }
    }
    k() {
      this.b ||
        (this.d--,
        --this.a === 0 && this.h.fire(),
        this.g.length > 0 && this.j())
    }
    clear() {
      if (this.b) throw new Error("Object has been disposed")
      ;(this.g.length = 0), (this.a = this.d)
    }
    dispose() {
      ;(this.b = !0), (this.g.length = 0), (this.a = 0), this.h.dispose()
    }
  },
  vct = class extends gct {
    constructor() {
      super(1)
    }
  },
  wct = class {
    constructor() {
      ;(this.a = new Map()),
        (this.b = new Set()),
        (this.d = void 0),
        (this.f = 0)
    }
    async whenDrained() {
      if (this.g()) return
      const i = new go()
      return this.b.add(i), i.p
    }
    g() {
      for (const [, i] of this.a) if (i.size > 0) return !1
      return !0
    }
    queueSize(i, t = jt) {
      const e = t.getComparisonKey(i)
      return this.a.get(e)?.size ?? 0
    }
    queueFor(i, t, e = jt) {
      const r = e.getComparisonKey(i)
      let s = this.a.get(r)
      if (!s) {
        s = new vct()
        const a = this.f++,
          o = Ee.once(s.onDrained)(() => {
            s?.dispose(),
              this.a.delete(r),
              this.h(),
              this.d?.deleteAndDispose(a),
              this.d?.size === 0 && (this.d.dispose(), (this.d = void 0))
          })
        this.d || (this.d = new uB()), this.d.set(a, o), this.a.set(r, s)
      }
      return s.queue(t)
    }
    h() {
      this.g() && this.j()
    }
    j() {
      for (const i of this.b) i.complete()
      this.b.clear()
    }
    dispose() {
      for (const [, i] of this.a) i.dispose()
      this.a.clear(), this.j(), this.d?.dispose()
    }
  },
  yct = class {
    constructor() {
      ;(this.d = void 0), (this.f = !1)
    }
    cancel() {
      this.d?.dispose(), (this.d = void 0)
    }
    cancelAndSet(i, t, e = globalThis) {
      if (this.f)
        throw new no("Calling 'cancelAndSet' on a disposed IntervalTimer")
      this.cancel()
      const r = e.setInterval(() => {
        i()
      }, t)
      this.d = it(() => {
        e.clearInterval(r), (this.d = void 0)
      })
    }
    dispose() {
      this.cancel(), (this.f = !0)
    }
  },
  po = class {
    constructor(i, t) {
      ;(this.b = -1), (this.a = i), (this.d = t), (this.f = this.g.bind(this))
    }
    dispose() {
      this.cancel(), (this.a = null)
    }
    cancel() {
      this.isScheduled() && (clearTimeout(this.b), (this.b = -1))
    }
    schedule(i = this.d) {
      this.cancel(), (this.b = setTimeout(this.f, i))
    }
    get delay() {
      return this.d
    }
    set delay(i) {
      this.d = i
    }
    isScheduled() {
      return this.b !== -1
    }
    flush() {
      this.isScheduled() && (this.cancel(), this.h())
    }
    g() {
      ;(this.b = -1), this.a && this.h()
    }
    h() {
      this.a?.()
    }
  },
  nj,
  u_
;(function () {
  typeof globalThis.requestIdleCallback != "function" ||
  typeof globalThis.cancelIdleCallback != "function"
    ? (u_ = (i, t, e) => {
        sW(() => {
          if (r) return
          const s = Date.now() + 15
          t(
            Object.freeze({
              didTimeout: !0,
              timeRemaining() {
                return Math.max(0, s - Date.now())
              },
            }),
          )
        })
        let r = !1
        return {
          dispose() {
            r || (r = !0)
          },
        }
      })
    : (u_ = (i, t, e) => {
        const r = i.requestIdleCallback(
          t,
          typeof e == "number" ? { timeout: e } : void 0,
        )
        let s = !1
        return {
          dispose() {
            s || ((s = !0), i.cancelIdleCallback(r))
          },
        }
      }),
    (nj = (i, t) => u_(globalThis, i, t))
})()
var Tct = class {
    constructor(i, t) {
      ;(this.g = !1),
        (this.d = () => {
          try {
            this.j = t()
          } catch (e) {
            this.l = e
          } finally {
            this.g = !0
          }
        }),
        (this.f = u_(i, () => this.d()))
    }
    dispose() {
      this.f.dispose()
    }
    get value() {
      if ((this.g || (this.f.dispose(), this.d()), this.l)) throw this.l
      return this.j
    }
    get isInitialized() {
      return this.g
    }
  },
  kct = class extends Tct {
    constructor(i) {
      super(globalThis, i)
    }
  },
  sj
;(function (i) {
  ;(i[(i.Resolved = 0)] = "Resolved"), (i[(i.Rejected = 1)] = "Rejected")
})(sj || (sj = {}))
var go = class {
    get isRejected() {
      return this.d?.outcome === 1
    }
    get isResolved() {
      return this.d?.outcome === 0
    }
    get isSettled() {
      return !!this.d
    }
    get value() {
      return this.d?.outcome === 0 ? this.d?.value : void 0
    }
    constructor() {
      this.p = new Promise((i, t) => {
        ;(this.a = i), (this.b = t)
      })
    }
    complete(i) {
      return new Promise((t) => {
        this.a(i), (this.d = { outcome: 0, value: i }), t()
      })
    }
    error(i) {
      return new Promise((t) => {
        this.b(i), (this.d = { outcome: 1, value: i }), t()
      })
    }
    cancel() {
      return this.error(new zr())
    }
  },
  vo
;(function (i) {
  async function t(r) {
    let s
    const a = await Promise.all(
      r.map((o) =>
        o.then(
          (c) => c,
          (c) => {
            s || (s = c)
          },
        ),
      ),
    )
    if (typeof s < "u") throw s
    return a
  }
  i.settled = t
  function e(r) {
    return new Promise(async (s, a) => {
      try {
        await r(s, a)
      } catch (o) {
        a(o)
      }
    })
  }
  i.withAsyncBody = e
})(vo || (vo = {}))
var aj
;(function (i) {
  ;(i[(i.Initial = 0)] = "Initial"),
    (i[(i.DoneOK = 1)] = "DoneOK"),
    (i[(i.DoneError = 2)] = "DoneError")
})(aj || (aj = {}))
var Fu = class ar {
    static fromArray(t) {
      return new ar((e) => {
        e.emitMany(t)
      })
    }
    static fromPromise(t) {
      return new ar(async (e) => {
        e.emitMany(await t)
      })
    }
    static fromPromisesResolveOrder(t) {
      return new ar(async (e) => {
        await Promise.all(t.map(async (r) => e.emitOne(await r)))
      })
    }
    static merge(t) {
      return new ar(async (e) => {
        await Promise.all(
          t.map(async (r) => {
            for await (const s of r) e.emitOne(s)
          }),
        )
      })
    }
    static {
      this.EMPTY = ar.fromArray([])
    }
    constructor(t, e) {
      ;(this.a = 0),
        (this.b = []),
        (this.d = null),
        (this.f = e),
        (this.g = new C()),
        queueMicrotask(async () => {
          const r = {
            emitOne: (s) => this.h(s),
            emitMany: (s) => this.j(s),
            reject: (s) => this.l(s),
          }
          try {
            await Promise.resolve(t(r)), this.k()
          } catch (s) {
            this.l(s)
          } finally {
            ;(r.emitOne = void 0), (r.emitMany = void 0), (r.reject = void 0)
          }
        })
    }
    [Symbol.asyncIterator]() {
      let t = 0
      return {
        next: async () => {
          do {
            if (this.a === 2) throw this.d
            if (t < this.b.length) return { done: !1, value: this.b[t++] }
            if (this.a === 1) return { done: !0, value: void 0 }
            await Ee.toPromise(this.g.event)
          } while (!0)
        },
        return: async () => (this.f?.(), { done: !0, value: void 0 }),
      }
    }
    static map(t, e) {
      return new ar(async (r) => {
        for await (const s of t) r.emitOne(e(s))
      })
    }
    map(t) {
      return ar.map(this, t)
    }
    static filter(t, e) {
      return new ar(async (r) => {
        for await (const s of t) e(s) && r.emitOne(s)
      })
    }
    filter(t) {
      return ar.filter(this, t)
    }
    static coalesce(t) {
      return ar.filter(t, (e) => !!e)
    }
    coalesce() {
      return ar.coalesce(this)
    }
    static async toPromise(t) {
      const e = []
      for await (const r of t) e.push(r)
      return e
    }
    toPromise() {
      return ar.toPromise(this)
    }
    h(t) {
      this.a === 0 && (this.b.push(t), this.g.fire())
    }
    j(t) {
      this.a === 0 && ((this.b = this.b.concat(t)), this.g.fire())
    }
    k() {
      this.a === 0 && ((this.a = 1), this.g.fire())
    }
    l(t) {
      this.a === 0 && ((this.a = 2), (this.d = t), this.g.fire())
    }
  },
  DB = class {
    constructor(i) {
      ;(this.a = new go()),
        (this.b = new Fu((r) => {
          if (t) {
            r.reject(t)
            return
          }
          return (
            e && r.emitMany(e),
            (this.d = (s) => r.reject(s)),
            (this.f = (s) => r.emitOne(s)),
            this.a.p
          )
        }, i))
      let t, e
      ;(this.f = (r) => {
        e || (e = []), e.push(r)
      }),
        (this.d = (r) => {
          t || (t = r)
        })
    }
    get asyncIterable() {
      return this.b
    }
    resolve() {
      this.a.complete()
    }
    reject(i) {
      this.d(i), this.a.complete()
    }
    emitOne(i) {
      this.f(i)
    }
  },
  x8t = new (class {
    transformIncoming(i) {
      return i
    }
    transformOutgoing(i) {
      return i
    }
    transformOutgoingURI(i) {
      return i
    }
    transformOutgoingScheme(i) {
      return i
    }
  })()
function oj(i, t, e, r) {
  if (!i || r > 200) return null
  if (typeof i == "object") {
    if (i.$mid === 1)
      return e ? S.revive(t.transformIncoming(i)) : t.transformIncoming(i)
    if (i instanceof Et) return null
    for (const s in i)
      if (Object.hasOwnProperty.call(i, s)) {
        const a = oj(i[s], t, e, r + 1)
        a !== null && (i[s] = a)
      }
  }
  return null
}
function _u(i, t) {
  const e = oj(i, t, !1, 0)
  return e === null ? i : e
}
var cj = class {
    constructor() {
      ;(this.a = null),
        (this.b = null),
        (this.d = null),
        (this.f = !1),
        (this.g = null),
        (this.h = !1),
        (this.i = null)
    }
    get [Symbol.toStringTag]() {
      return this.toString()
    }
    j() {
      return (
        this.a ||
          (this.a = new Promise((i, t) => {
            ;(this.b = i),
              (this.d = t),
              this.f && this.b(this.g),
              this.h && this.d(this.i)
          })),
        this.a
      )
    }
    resolveOk(i) {
      this.f || this.h || ((this.f = !0), (this.g = i), this.a && this.b(i))
    }
    resolveErr(i) {
      this.f ||
        this.h ||
        ((this.h = !0), (this.i = i), this.a ? this.d(i) : Ui(i))
    }
    then(i, t) {
      return this.j().then(i, t)
    }
    catch(i) {
      return this.j().then(void 0, i)
    }
    finally(i) {
      return this.j().finally(i)
    }
  },
  Sct = class extends cj {
    constructor() {
      super(), (this.h = !0), (this.i = new zr())
    }
  },
  uj
function FB(i, t) {
  try {
    return JSON.stringify(i, t)
  } catch {
    return "null"
  }
}
var _B = "$$ref$$",
  bct = { [_B]: -1 }
function lj(i, t = null, e = !1) {
  const r = []
  return {
    jsonString: (e ? FB : JSON.stringify)(i, (a, o) => {
      if (typeof o > "u") return bct
      if (typeof o == "object") {
        if (o instanceof Et) {
          const c = r.push(o) - 1
          return { [_B]: c }
        }
        if (t) return t(a, o)
      }
      return o
    }),
    referencedBuffers: r,
  }
}
function dj(i, t, e) {
  return JSON.parse(i, (r, s) => {
    if (s) {
      const a = s[_B]
      if (typeof a == "number") return t[a]
      if (e && s.$mid === 1) return e.transformIncoming(s)
    }
    return s
  })
}
function mj(i, t) {
  return JSON.stringify(i, t)
}
function Ect(i) {
  return i ? (t, e) => (e && e.$mid === 1 ? i.transformOutgoing(e) : e) : null
}
var hj
;(function (i) {
  ;(i[(i.LocalSide = 0)] = "LocalSide"), (i[(i.OtherSide = 1)] = "OtherSide")
})(hj || (hj = {}))
var fj
;(function (i) {
  ;(i[(i.Responsive = 0)] = "Responsive"),
    (i[(i.Unresponsive = 1)] = "Unresponsive")
})(fj || (fj = {}))
var Ict = () => {},
  Pct = Symbol.for("rpcProtocol"),
  Nct = Symbol.for("rpcProxy"),
  $ct = class aH extends dt {
    static {
      uj = Pct
    }
    static {
      this.a = 3 * 1e3
    }
    constructor(t, e = null, r = null) {
      super(),
        (this[uj] = !0),
        (this.b = this.D(new C())),
        (this.onDidChangeResponsiveState = this.b.event),
        (this.c = t),
        (this.f = e),
        (this.g = r),
        (this.h = Ect(this.g)),
        (this.j = !1),
        (this.m = []),
        (this.q = [])
      for (let s = 0, a = yW.count; s < a; s++)
        (this.m[s] = null), (this.q[s] = null)
      ;(this.s = 0),
        (this.t = Object.create(null)),
        (this.u = {}),
        (this.w = 0),
        (this.y = 0),
        (this.z = 0),
        (this.C = this.D(new po(() => this.H(), 1e3))),
        this.D(this.c.onMessage((s) => this.L(s)))
    }
    dispose() {
      ;(this.j = !0),
        Object.keys(this.u).forEach((t) => {
          const e = this.u[t]
          delete this.u[t], e.resolveErr(xH())
        }),
        super.dispose()
    }
    drain() {
      return typeof this.c.drain == "function"
        ? this.c.drain()
        : Promise.resolve()
    }
    F(t) {
      this.y === 0 && (this.z = Date.now() + aH.a),
        this.y++,
        this.C.isScheduled() || this.C.schedule()
    }
    G(t) {
      ;(this.z = Date.now() + aH.a),
        this.y--,
        this.y === 0 && this.C.cancel(),
        this.I(0)
    }
    H() {
      this.y !== 0 && (Date.now() > this.z ? this.I(1) : this.C.schedule())
    }
    I(t) {
      this.w !== t && ((this.w = t), this.b.fire(this.w))
    }
    get responsiveState() {
      return this.w
    }
    transformIncomingURIs(t) {
      return this.g ? _u(t, this.g) : t
    }
    getProxy(t) {
      const { nid: e, sid: r } = t
      return this.q[e] || (this.q[e] = this.J(e, r)), this.q[e]
    }
    J(t, e) {
      const r = {
        get: (s, a) => (
          typeof a == "string" &&
            !s[a] &&
            a.charCodeAt(0) === 36 &&
            (s[a] = (...o) => this.U(t, a, o)),
          a === Nct ? e : s[a]
        ),
      }
      return new Proxy(Object.create(null), r)
    }
    set(t, e) {
      return (this.m[t.nid] = e), e
    }
    assertRegistered(t) {
      for (let e = 0, r = t.length; e < r; e++) {
        const s = t[e]
        if (!this.m[s.nid]) throw new Error(`Missing proxy instance ${s.sid}`)
      }
    }
    L(t) {
      if (this.j) return
      const e = t.byteLength,
        r = Re.read(t, 0),
        s = r.readUInt8(),
        a = r.readUInt32()
      switch (s) {
        case 1:
        case 2: {
          let {
            rpcId: o,
            method: c,
            args: u,
          } = lr.deserializeRequestJSONArgs(r)
          this.g && (u = _u(u, this.g)), this.M(e, a, o, c, u, s === 2)
          break
        }
        case 3:
        case 4: {
          let {
            rpcId: o,
            method: c,
            args: u,
          } = lr.deserializeRequestMixedArgs(r)
          this.g && (u = _u(u, this.g)), this.M(e, a, o, c, u, s === 4)
          break
        }
        case 5: {
          this.f?.logIncoming(e, a, 0, "ack"), this.G(a)
          break
        }
        case 6: {
          this.N(e, a)
          break
        }
        case 7: {
          this.O(e, a, void 0)
          break
        }
        case 9: {
          let o = lr.deserializeReplyOKJSON(r)
          this.g && (o = _u(o, this.g)), this.O(e, a, o)
          break
        }
        case 10: {
          const o = lr.deserializeReplyOKJSONWithBuffers(r, this.g)
          this.O(e, a, o)
          break
        }
        case 8: {
          const o = lr.deserializeReplyOKVSBuffer(r)
          this.O(e, a, o)
          break
        }
        case 11: {
          let o = lr.deserializeReplyErrError(r)
          this.g && (o = _u(o, this.g)), this.P(e, a, o)
          break
        }
        case 12: {
          this.P(e, a, void 0)
          break
        }
        default:
          console.error("received unexpected message"), console.error(t)
      }
    }
    M(t, e, r, s, a, o) {
      this.f?.logIncoming(t, e, 1, `receiveRequest ${r_(r)}.${s}(`, a)
      const c = String(e)
      let u, l
      if (o) {
        const h = new Ie()
        a.push(h.token), (u = this.Q(r, s, a)), (l = () => h.cancel())
      } else (u = this.Q(r, s, a)), (l = Ict)
      this.t[c] = l
      const m = lr.serializeAcknowledged(e)
      this.f?.logOutgoing(m.byteLength, e, 1, "ack"),
        this.c.send(m),
        u.then(
          (h) => {
            delete this.t[c]
            const p = lr.serializeReplyOK(e, h, this.h)
            this.f?.logOutgoing(p.byteLength, e, 1, "reply:", h), this.c.send(p)
          },
          (h) => {
            delete this.t[c]
            const p = lr.serializeReplyErr(e, h)
            this.f?.logOutgoing(p.byteLength, e, 1, "replyErr:", h),
              this.c.send(p)
          },
        )
    }
    N(t, e) {
      this.f?.logIncoming(t, e, 1, "receiveCancel")
      const r = String(e)
      this.t[r]?.()
    }
    O(t, e, r) {
      this.f?.logIncoming(t, e, 0, "receiveReply:", r)
      const s = String(e)
      if (!this.u.hasOwnProperty(s)) return
      const a = this.u[s]
      delete this.u[s], a.resolveOk(r)
    }
    P(t, e, r) {
      this.f?.logIncoming(t, e, 0, "receiveReplyErr:", r)
      const s = String(e)
      if (!this.u.hasOwnProperty(s)) return
      const a = this.u[s]
      delete this.u[s]
      let o
      r &&
        (r.$isError
          ? ((o = new Error()),
            (o.name = r.name),
            (o.message = r.message),
            (o.stack = r.stack))
          : (o = r)),
        a.resolveErr(o)
    }
    Q(t, e, r) {
      try {
        return Promise.resolve(this.S(t, e, r))
      } catch (s) {
        return Promise.reject(s)
      }
    }
    S(t, e, r) {
      const s = this.m[t]
      if (!s) throw new Error("Unknown actor " + r_(t))
      const a = s[e]
      if (typeof a != "function")
        throw new Error("Unknown method " + e + " on actor " + r_(t))
      return a.apply(s, r)
    }
    U(t, e, r) {
      if (this.j) return new Sct()
      let s = null
      if (
        (r.length > 0 &&
          fe.isCancellationToken(r[r.length - 1]) &&
          (s = r.pop()),
        s && s.isCancellationRequested)
      )
        return Promise.reject(xH())
      const a = lr.serializeRequestArguments(r, this.h),
        o = ++this.s,
        c = String(o),
        u = new cj(),
        l = new bt()
      s &&
        l.add(
          s.onCancellationRequested(() => {
            const h = lr.serializeCancel(o)
            this.f?.logOutgoing(h.byteLength, o, 0, "cancel"), this.c.send(h)
          }),
        ),
        (this.u[c] = new xct(u, l)),
        this.F(o)
      const m = lr.serializeRequest(o, t, e, a, !!s)
      return (
        this.f?.logOutgoing(m.byteLength, o, 0, `request: ${r_(t)}.${e}(`, r),
        this.c.send(m),
        u
      )
    }
  },
  xct = class {
    constructor(i, t) {
      ;(this.a = i), (this.b = t)
    }
    resolveOk(i) {
      this.a.resolveOk(i), this.b.dispose()
    }
    resolveErr(i) {
      this.a.resolveErr(i), this.b.dispose()
    }
  },
  Re = class oH {
    static alloc(t, e, r) {
      const s = new oH(Et.alloc(r + 1 + 4), 0)
      return s.writeUInt8(t), s.writeUInt32(e), s
    }
    static read(t, e) {
      return new oH(t, e)
    }
    get buffer() {
      return this.a
    }
    constructor(t, e) {
      ;(this.a = t), (this.b = e)
    }
    static sizeUInt8() {
      return 1
    }
    static {
      this.sizeUInt32 = 4
    }
    writeUInt8(t) {
      this.a.writeUInt8(t, this.b), (this.b += 1)
    }
    readUInt8() {
      const t = this.a.readUInt8(this.b)
      return (this.b += 1), t
    }
    writeUInt32(t) {
      this.a.writeUInt32BE(t, this.b), (this.b += 4)
    }
    readUInt32() {
      const t = this.a.readUInt32BE(this.b)
      return (this.b += 4), t
    }
    static sizeShortString(t) {
      return 1 + t.byteLength
    }
    writeShortString(t) {
      this.a.writeUInt8(t.byteLength, this.b),
        (this.b += 1),
        this.a.set(t, this.b),
        (this.b += t.byteLength)
    }
    readShortString() {
      const t = this.a.readUInt8(this.b)
      this.b += 1
      const r = this.a.slice(this.b, this.b + t).toString()
      return (this.b += t), r
    }
    static sizeLongString(t) {
      return 4 + t.byteLength
    }
    writeLongString(t) {
      this.a.writeUInt32BE(t.byteLength, this.b),
        (this.b += 4),
        this.a.set(t, this.b),
        (this.b += t.byteLength)
    }
    readLongString() {
      const t = this.a.readUInt32BE(this.b)
      this.b += 4
      const r = this.a.slice(this.b, this.b + t).toString()
      return (this.b += t), r
    }
    writeBuffer(t) {
      this.a.writeUInt32BE(t.byteLength, this.b),
        (this.b += 4),
        this.a.set(t, this.b),
        (this.b += t.byteLength)
    }
    static sizeVSBuffer(t) {
      return 4 + t.byteLength
    }
    writeVSBuffer(t) {
      this.a.writeUInt32BE(t.byteLength, this.b),
        (this.b += 4),
        this.a.set(t, this.b),
        (this.b += t.byteLength)
    }
    readVSBuffer() {
      const t = this.a.readUInt32BE(this.b)
      this.b += 4
      const e = this.a.slice(this.b, this.b + t)
      return (this.b += t), e
    }
    static sizeMixedArray(t) {
      let e = 0
      e += 1
      for (let r = 0, s = t.length; r < s; r++) {
        const a = t[r]
        switch (((e += 1), a.type)) {
          case 1:
            e += this.sizeLongString(a.value)
            break
          case 2:
            e += this.sizeVSBuffer(a.value)
            break
          case 3:
            ;(e += this.sizeUInt32), (e += this.sizeLongString(a.value))
            for (let o = 0; o < a.buffers.length; ++o)
              e += this.sizeVSBuffer(a.buffers[o])
            break
          case 4:
            break
        }
      }
      return e
    }
    writeMixedArray(t) {
      this.a.writeUInt8(t.length, this.b), (this.b += 1)
      for (let e = 0, r = t.length; e < r; e++) {
        const s = t[e]
        switch (s.type) {
          case 1:
            this.writeUInt8(1), this.writeLongString(s.value)
            break
          case 2:
            this.writeUInt8(2), this.writeVSBuffer(s.value)
            break
          case 3:
            this.writeUInt8(3),
              this.writeUInt32(s.buffers.length),
              this.writeLongString(s.value)
            for (let a = 0; a < s.buffers.length; ++a)
              this.writeBuffer(s.buffers[a])
            break
          case 4:
            this.writeUInt8(4)
            break
        }
      }
    }
    readMixedArray() {
      const t = this.a.readUInt8(this.b)
      this.b += 1
      const e = new Array(t)
      for (let r = 0; r < t; r++)
        switch (this.readUInt8()) {
          case 1:
            e[r] = this.readLongString()
            break
          case 2:
            e[r] = this.readVSBuffer()
            break
          case 3: {
            const a = this.readUInt32(),
              o = this.readLongString(),
              c = []
            for (let u = 0; u < a; ++u) c.push(this.readVSBuffer())
            e[r] = new Xi(dj(o, c, null))
            break
          }
          case 4:
            e[r] = void 0
            break
        }
      return e
    }
  },
  pj
;(function (i) {
  ;(i[(i.Simple = 0)] = "Simple"), (i[(i.Mixed = 1)] = "Mixed")
})(pj || (pj = {}))
var lr = class {
    static a(i) {
      for (let t = 0, e = i.length; t < e; t++)
        if (i[t] instanceof Et || i[t] instanceof Xi || typeof i[t] > "u")
          return !0
      return !1
    }
    static serializeRequestArguments(i, t) {
      if (this.a(i)) {
        const e = []
        for (let r = 0, s = i.length; r < s; r++) {
          const a = i[r]
          if (a instanceof Et) e[r] = { type: 2, value: a }
          else if (typeof a > "u") e[r] = { type: 4 }
          else if (a instanceof Xi) {
            const { jsonString: o, referencedBuffers: c } = lj(a.value, t)
            e[r] = { type: 3, value: Et.fromString(o), buffers: c }
          } else e[r] = { type: 1, value: Et.fromString(mj(a, t)) }
        }
        return { type: 1, args: e }
      }
      return { type: 0, args: mj(i, t) }
    }
    static serializeRequest(i, t, e, r, s) {
      switch (r.type) {
        case 0:
          return this.b(i, t, e, r.args, s)
        case 1:
          return this.c(i, t, e, r.args, s)
      }
    }
    static b(i, t, e, r, s) {
      const a = Et.fromString(e),
        o = Et.fromString(r)
      let c = 0
      ;(c += Re.sizeUInt8()),
        (c += Re.sizeShortString(a)),
        (c += Re.sizeLongString(o))
      const u = Re.alloc(s ? 2 : 1, i, c)
      return (
        u.writeUInt8(t), u.writeShortString(a), u.writeLongString(o), u.buffer
      )
    }
    static deserializeRequestJSONArgs(i) {
      const t = i.readUInt8(),
        e = i.readShortString(),
        r = i.readLongString()
      return { rpcId: t, method: e, args: JSON.parse(r) }
    }
    static c(i, t, e, r, s) {
      const a = Et.fromString(e)
      let o = 0
      ;(o += Re.sizeUInt8()),
        (o += Re.sizeShortString(a)),
        (o += Re.sizeMixedArray(r))
      const c = Re.alloc(s ? 4 : 3, i, o)
      return (
        c.writeUInt8(t), c.writeShortString(a), c.writeMixedArray(r), c.buffer
      )
    }
    static deserializeRequestMixedArgs(i) {
      const t = i.readUInt8(),
        e = i.readShortString(),
        r = i.readMixedArray(),
        s = new Array(r.length)
      for (let a = 0, o = r.length; a < o; a++) {
        const c = r[a]
        typeof c == "string" ? (s[a] = JSON.parse(c)) : (s[a] = c)
      }
      return { rpcId: t, method: e, args: s }
    }
    static serializeAcknowledged(i) {
      return Re.alloc(5, i, 0).buffer
    }
    static serializeCancel(i) {
      return Re.alloc(6, i, 0).buffer
    }
    static serializeReplyOK(i, t, e) {
      if (typeof t > "u") return this.d(i)
      if (t instanceof Et) return this.e(i, t)
      if (t instanceof Xi) {
        const { jsonString: r, referencedBuffers: s } = lj(t.value, e, !0)
        return this.g(i, r, s)
      } else return this.f(i, FB(t, e))
    }
    static d(i) {
      return Re.alloc(7, i, 0).buffer
    }
    static e(i, t) {
      let e = 0
      e += Re.sizeVSBuffer(t)
      const r = Re.alloc(8, i, e)
      return r.writeVSBuffer(t), r.buffer
    }
    static deserializeReplyOKVSBuffer(i) {
      return i.readVSBuffer()
    }
    static f(i, t) {
      const e = Et.fromString(t)
      let r = 0
      r += Re.sizeLongString(e)
      const s = Re.alloc(9, i, r)
      return s.writeLongString(e), s.buffer
    }
    static g(i, t, e) {
      const r = Et.fromString(t)
      let s = 0
      ;(s += Re.sizeUInt32), (s += Re.sizeLongString(r))
      for (const o of e) s += Re.sizeVSBuffer(o)
      const a = Re.alloc(10, i, s)
      a.writeUInt32(e.length), a.writeLongString(r)
      for (const o of e) a.writeBuffer(o)
      return a.buffer
    }
    static deserializeReplyOKJSON(i) {
      const t = i.readLongString()
      return JSON.parse(t)
    }
    static deserializeReplyOKJSONWithBuffers(i, t) {
      const e = i.readUInt32(),
        r = i.readLongString(),
        s = []
      for (let a = 0; a < e; ++a) s.push(i.readVSBuffer())
      return new Xi(dj(r, s, t))
    }
    static serializeReplyErr(i, t) {
      const e = t ? FB(ku(t), null) : void 0
      if (typeof e != "string") return this.h(i)
      const r = Et.fromString(e)
      let s = 0
      s += Re.sizeLongString(r)
      const a = Re.alloc(11, i, s)
      return a.writeLongString(r), a.buffer
    }
    static deserializeReplyErrError(i) {
      const t = i.readLongString()
      return JSON.parse(t)
    }
    static h(i) {
      return Re.alloc(12, i, 0).buffer
    }
  },
  gj
;(function (i) {
  ;(i[(i.RequestJSONArgs = 1)] = "RequestJSONArgs"),
    (i[(i.RequestJSONArgsWithCancellation = 2)] =
      "RequestJSONArgsWithCancellation"),
    (i[(i.RequestMixedArgs = 3)] = "RequestMixedArgs"),
    (i[(i.RequestMixedArgsWithCancellation = 4)] =
      "RequestMixedArgsWithCancellation"),
    (i[(i.Acknowledged = 5)] = "Acknowledged"),
    (i[(i.Cancel = 6)] = "Cancel"),
    (i[(i.ReplyOKEmpty = 7)] = "ReplyOKEmpty"),
    (i[(i.ReplyOKVSBuffer = 8)] = "ReplyOKVSBuffer"),
    (i[(i.ReplyOKJSON = 9)] = "ReplyOKJSON"),
    (i[(i.ReplyOKJSONWithBuffers = 10)] = "ReplyOKJSONWithBuffers"),
    (i[(i.ReplyErrError = 11)] = "ReplyErrError"),
    (i[(i.ReplyErrEmpty = 12)] = "ReplyErrEmpty")
})(gj || (gj = {}))
var vj
;(function (i) {
  ;(i[(i.String = 1)] = "String"),
    (i[(i.VSBuffer = 2)] = "VSBuffer"),
    (i[(i.SerializedObjectWithBuffers = 3)] = "SerializedObjectWithBuffers"),
    (i[(i.Undefined = 4)] = "Undefined")
})(vj || (vj = {}))
function AB(i, t) {
  return t && (i.stack || i.stacktrace)
    ? f(110, null, yj(i), wj(i.stack) || wj(i.stacktrace))
    : yj(i)
}
function wj(i) {
  return Array.isArray(i)
    ? i.join(`
`)
    : i
}
function yj(i) {
  return i.code === "ERR_UNC_HOST_NOT_ALLOWED"
    ? `${i.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`
    : typeof i.code == "string" &&
        typeof i.errno == "number" &&
        typeof i.syscall == "string"
      ? f(111, null, i.message)
      : i.message || f(112, null)
}
function ea(i = null, t = !1) {
  if (!i) return f(113, null)
  if (Array.isArray(i)) {
    const e = Ge(i),
      r = ea(e[0], t)
    return e.length > 1 ? f(114, null, r, e.length) : r
  }
  if (Bt(i)) return i
  if (i.detail) {
    const e = i.detail
    if (e.error) return AB(e.error, t)
    if (e.exception) return AB(e.exception, t)
  }
  return i.stack ? AB(i, t) : i.message ? i.message : f(115, null)
}
function Au(i) {
  return BB(i, 0)
}
function BB(i, t) {
  switch (typeof i) {
    case "object":
      return i === null ? yn(349, t) : Array.isArray(i) ? Cct(i, t) : Lct(i, t)
    case "string":
      return Tj(i, t)
    case "boolean":
      return Jct(i, t)
    case "number":
      return yn(i, t)
    case "undefined":
      return yn(937, t)
    default:
      return yn(617, t)
  }
}
function yn(i, t) {
  return ((t << 5) - t + i) | 0
}
function Jct(i, t) {
  return yn(i ? 433 : 863, t)
}
function Tj(i, t) {
  t = yn(149417, t)
  for (let e = 0, r = i.length; e < r; e++) t = yn(i.charCodeAt(e), t)
  return t
}
function Cct(i, t) {
  return (t = yn(104579, t)), i.reduce((e, r) => BB(r, e), t)
}
function Lct(i, t) {
  return (
    (t = yn(181387, t)),
    Object.keys(i)
      .sort()
      .reduce((e, r) => ((e = Tj(r, e)), BB(i[r], e)), t)
  )
}
var kj
;(function (i) {
  ;(i[(i.BLOCK_SIZE = 64)] = "BLOCK_SIZE"),
    (i[(i.UNICODE_REPLACEMENT = 65533)] = "UNICODE_REPLACEMENT")
})(kj || (kj = {}))
function OB(i, t, e = 32) {
  const r = e - t,
    s = ~((1 << r) - 1)
  return ((i << t) | ((s & i) >>> r)) >>> 0
}
function Bu(i, t = 32) {
  return i instanceof ArrayBuffer
    ? Array.from(new Uint8Array(i))
        .map((e) => e.toString(16).padStart(2, "0"))
        .join("")
    : (i >>> 0).toString(16).padStart(t / 4, "0")
}
var J8t = class Ent {
    static {
      this.g = new DataView(new ArrayBuffer(320))
    }
    constructor() {
      ;(this.h = 1732584193),
        (this.l = 4023233417),
        (this.m = 2562383102),
        (this.n = 271733878),
        (this.o = 3285377520),
        (this.p = new Uint8Array(67)),
        (this.q = new DataView(this.p.buffer)),
        (this.r = 0),
        (this.t = 0),
        (this.u = 0),
        (this.v = !1)
    }
    update(t) {
      const e = t.length
      if (e === 0) return
      const r = this.p
      let s = this.r,
        a = this.u,
        o,
        c
      for (
        a !== 0
          ? ((o = a), (c = -1), (a = 0))
          : ((o = t.charCodeAt(0)), (c = 0));
        ;

      ) {
        let u = o
        if (a_(o))
          if (c + 1 < e) {
            const l = t.charCodeAt(c + 1)
            o_(l) ? (c++, (u = xB(o, l))) : (u = 65533)
          } else {
            a = o
            break
          }
        else o_(o) && (u = 65533)
        if (((s = this.w(r, s, u)), c++, c < e)) o = t.charCodeAt(c)
        else break
      }
      ;(this.r = s), (this.u = a)
    }
    w(t, e, r) {
      return (
        r < 128
          ? (t[e++] = r)
          : r < 2048
            ? ((t[e++] = 192 | ((r & 1984) >>> 6)),
              (t[e++] = 128 | ((r & 63) >>> 0)))
            : r < 65536
              ? ((t[e++] = 224 | ((r & 61440) >>> 12)),
                (t[e++] = 128 | ((r & 4032) >>> 6)),
                (t[e++] = 128 | ((r & 63) >>> 0)))
              : ((t[e++] = 240 | ((r & 1835008) >>> 18)),
                (t[e++] = 128 | ((r & 258048) >>> 12)),
                (t[e++] = 128 | ((r & 4032) >>> 6)),
                (t[e++] = 128 | ((r & 63) >>> 0))),
        e >= 64 &&
          (this.y(),
          (e -= 64),
          (this.t += 64),
          (t[0] = t[64]),
          (t[1] = t[65]),
          (t[2] = t[66])),
        e
      )
    }
    digest() {
      return (
        this.v ||
          ((this.v = !0),
          this.u && ((this.u = 0), (this.r = this.w(this.p, this.r, 65533))),
          (this.t += this.r),
          this.x()),
        Bu(this.h) + Bu(this.l) + Bu(this.m) + Bu(this.n) + Bu(this.o)
      )
    }
    x() {
      ;(this.p[this.r++] = 128),
        this.p.subarray(this.r).fill(0),
        this.r > 56 && (this.y(), this.p.fill(0))
      const t = 8 * this.t
      this.q.setUint32(56, Math.floor(t / 4294967296), !1),
        this.q.setUint32(60, t % 4294967296, !1),
        this.y()
    }
    y() {
      const t = Ent.g,
        e = this.q
      for (let h = 0; h < 64; h += 4) t.setUint32(h, e.getUint32(h, !1), !1)
      for (let h = 64; h < 320; h += 4)
        t.setUint32(
          h,
          OB(
            t.getUint32(h - 12, !1) ^
              t.getUint32(h - 32, !1) ^
              t.getUint32(h - 56, !1) ^
              t.getUint32(h - 64, !1),
            1,
          ),
          !1,
        )
      let r = this.h,
        s = this.l,
        a = this.m,
        o = this.n,
        c = this.o,
        u,
        l,
        m
      for (let h = 0; h < 80; h++)
        h < 20
          ? ((u = (s & a) | (~s & o)), (l = 1518500249))
          : h < 40
            ? ((u = s ^ a ^ o), (l = 1859775393))
            : h < 60
              ? ((u = (s & a) | (s & o) | (a & o)), (l = 2400959708))
              : ((u = s ^ a ^ o), (l = 3395469782)),
          (m = (OB(r, 5) + u + c + l + t.getUint32(h * 4, !1)) & 4294967295),
          (c = o),
          (o = a),
          (a = OB(s, 30)),
          (s = r),
          (r = m)
      ;(this.h = (this.h + r) & 4294967295),
        (this.l = (this.l + s) & 4294967295),
        (this.m = (this.m + a) & 4294967295),
        (this.n = (this.n + o) & 4294967295),
        (this.o = (this.o + c) & 4294967295)
    }
  },
  Sj
;(function (i) {
  ;(i[(i.LParen = 0)] = "LParen"),
    (i[(i.RParen = 1)] = "RParen"),
    (i[(i.Neg = 2)] = "Neg"),
    (i[(i.Eq = 3)] = "Eq"),
    (i[(i.NotEq = 4)] = "NotEq"),
    (i[(i.Lt = 5)] = "Lt"),
    (i[(i.LtEq = 6)] = "LtEq"),
    (i[(i.Gt = 7)] = "Gt"),
    (i[(i.GtEq = 8)] = "GtEq"),
    (i[(i.RegexOp = 9)] = "RegexOp"),
    (i[(i.RegexStr = 10)] = "RegexStr"),
    (i[(i.True = 11)] = "True"),
    (i[(i.False = 12)] = "False"),
    (i[(i.In = 13)] = "In"),
    (i[(i.Not = 14)] = "Not"),
    (i[(i.And = 15)] = "And"),
    (i[(i.Or = 16)] = "Or"),
    (i[(i.Str = 17)] = "Str"),
    (i[(i.QuotedStr = 18)] = "QuotedStr"),
    (i[(i.Error = 19)] = "Error"),
    (i[(i.EOF = 20)] = "EOF")
})(Sj || (Sj = {}))
function qB(...i) {
  switch (i.length) {
    case 1:
      return f(1736, null, i[0])
    case 2:
      return f(1737, null, i[0], i[1])
    case 3:
      return f(1738, null, i[0], i[1], i[2])
    default:
      return
  }
}
var Rct = f(1739, null),
  Dct = f(1740, null),
  Ou = class cH {
    constructor() {
      ;(this.c = ""),
        (this.d = 0),
        (this.e = 0),
        (this.f = []),
        (this.g = []),
        (this.m = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy)
    }
    static getLexeme(t) {
      switch (t.type) {
        case 0:
          return "("
        case 1:
          return ")"
        case 2:
          return "!"
        case 3:
          return t.isTripleEq ? "===" : "=="
        case 4:
          return t.isTripleEq ? "!==" : "!="
        case 5:
          return "<"
        case 6:
          return "<="
        case 7:
          return ">="
        case 8:
          return ">="
        case 9:
          return "=~"
        case 10:
          return t.lexeme
        case 11:
          return "true"
        case 12:
          return "false"
        case 13:
          return "in"
        case 14:
          return "not"
        case 15:
          return "&&"
        case 16:
          return "||"
        case 17:
          return t.lexeme
        case 18:
          return t.lexeme
        case 19:
          return t.lexeme
        case 20:
          return "EOF"
        default:
          throw iB(
            `unhandled token type: ${JSON.stringify(t)}; have you forgotten to add a case?`,
          )
      }
    }
    static {
      this.a = new Set(
        ["i", "g", "s", "m", "y", "u"].map((t) => t.charCodeAt(0)),
      )
    }
    static {
      this.b = new Map([
        ["not", 14],
        ["in", 13],
        ["false", 12],
        ["true", 11],
      ])
    }
    get errors() {
      return this.g
    }
    reset(t) {
      return (
        (this.c = t),
        (this.d = 0),
        (this.e = 0),
        (this.f = []),
        (this.g = []),
        this
      )
    }
    scan() {
      for (; !this.r(); )
        switch (((this.d = this.e), this.i())) {
          case 40:
            this.k(0)
            break
          case 41:
            this.k(1)
            break
          case 33:
            if (this.h(61)) {
              const e = this.h(61)
              this.f.push({ type: 4, offset: this.d, isTripleEq: e })
            } else this.k(2)
            break
          case 39:
            this.o()
            break
          case 47:
            this.q()
            break
          case 61:
            if (this.h(61)) {
              const e = this.h(61)
              this.f.push({ type: 3, offset: this.d, isTripleEq: e })
            } else this.h(126) ? this.k(9) : this.l(qB("==", "=~"))
            break
          case 60:
            this.k(this.h(61) ? 6 : 5)
            break
          case 62:
            this.k(this.h(61) ? 8 : 7)
            break
          case 38:
            this.h(38) ? this.k(15) : this.l(qB("&&"))
            break
          case 124:
            this.h(124) ? this.k(16) : this.l(qB("||"))
            break
          case 32:
          case 13:
          case 9:
          case 10:
          case 160:
            break
          default:
            this.n()
        }
      return (this.d = this.e), this.k(20), Array.from(this.f)
    }
    h(t) {
      return this.r() || this.c.charCodeAt(this.e) !== t ? !1 : (this.e++, !0)
    }
    i() {
      return this.c.charCodeAt(this.e++)
    }
    j() {
      return this.r() ? 0 : this.c.charCodeAt(this.e)
    }
    k(t) {
      this.f.push({ type: t, offset: this.d })
    }
    l(t) {
      const e = this.d,
        r = this.c.substring(this.d, this.e),
        s = { type: 19, offset: this.d, lexeme: r }
      this.g.push({ offset: e, lexeme: r, additionalInfo: t }), this.f.push(s)
    }
    n() {
      this.m.lastIndex = this.d
      const t = this.m.exec(this.c)
      if (t) {
        this.e = this.d + t[0].length
        const e = this.c.substring(this.d, this.e),
          r = cH.b.get(e)
        r ? this.k(r) : this.f.push({ type: 17, lexeme: e, offset: this.d })
      }
    }
    o() {
      for (; this.j() !== 39 && !this.r(); ) this.i()
      if (this.r()) {
        this.l(Rct)
        return
      }
      this.i(),
        this.f.push({
          type: 18,
          lexeme: this.c.substring(this.d + 1, this.e - 1),
          offset: this.d + 1,
        })
    }
    q() {
      let t = this.e,
        e = !1,
        r = !1
      for (;;) {
        if (t >= this.c.length) {
          ;(this.e = t), this.l(Dct)
          return
        }
        const a = this.c.charCodeAt(t)
        if (e) e = !1
        else if (a === 47 && !r) {
          t++
          break
        } else a === 91 ? (r = !0) : a === 92 ? (e = !0) : a === 93 && (r = !1)
        t++
      }
      for (; t < this.c.length && cH.a.has(this.c.charCodeAt(t)); ) t++
      this.e = t
      const s = this.c.substring(this.d, this.e)
      this.f.push({ type: 10, lexeme: s, offset: this.d })
    }
    r() {
      return this.e >= this.c.length
    }
  },
  Er
;(function (i) {
  ;(i.serviceIds = new Map()),
    (i.DI_TARGET = "$di$target"),
    (i.DI_DEPENDENCIES = "$di$dependencies")
  function t(e) {
    return e[i.DI_DEPENDENCIES] || []
  }
  i.getServiceDependencies = t
})(Er || (Er = {}))
var l_ = Y("instantiationService")
function Fct(i, t, e) {
  t[Er.DI_TARGET] === t
    ? t[Er.DI_DEPENDENCIES].push({ id: i, index: e })
    : ((t[Er.DI_DEPENDENCIES] = [{ id: i, index: e }]), (t[Er.DI_TARGET] = t))
}
function Y(i) {
  if (Er.serviceIds.has(i)) return Er.serviceIds.get(i)
  const t = function (e, r, s) {
    if (arguments.length !== 3)
      throw new Error(
        "@IServiceName-decorator can only be used to decorate a parameter",
      )
    Fct(t, e, s)
  }
  return (t.toString = () => i), Er.serviceIds.set(i, t), t
}
function C8t(i) {
  return i
}
var ii = new Map()
ii.set("false", !1),
  ii.set("true", !0),
  ii.set("isMac", Tr),
  ii.set("isLinux", es),
  ii.set("isWindows", Mi),
  ii.set("isWeb", vB),
  ii.set("isMacNative", Tr && !vB),
  ii.set("isEdge", lW),
  ii.set("isFirefox", Kat),
  ii.set("isChrome", wB),
  ii.set("isSafari", Zat)
var _ct = Object.prototype.hasOwnProperty,
  bj
;(function (i) {
  ;(i[(i.False = 0)] = "False"),
    (i[(i.True = 1)] = "True"),
    (i[(i.Defined = 2)] = "Defined"),
    (i[(i.Not = 3)] = "Not"),
    (i[(i.Equals = 4)] = "Equals"),
    (i[(i.NotEquals = 5)] = "NotEquals"),
    (i[(i.And = 6)] = "And"),
    (i[(i.Regex = 7)] = "Regex"),
    (i[(i.NotRegex = 8)] = "NotRegex"),
    (i[(i.Or = 9)] = "Or"),
    (i[(i.In = 10)] = "In"),
    (i[(i.NotIn = 11)] = "NotIn"),
    (i[(i.Greater = 12)] = "Greater"),
    (i[(i.GreaterEquals = 13)] = "GreaterEquals"),
    (i[(i.Smaller = 14)] = "Smaller"),
    (i[(i.SmallerEquals = 15)] = "SmallerEquals"),
    (i[(i.Function = 16)] = "Function")
})(bj || (bj = {}))
var Act = { regexParsingWithErrorRecovery: !0 },
  Bct = f(1716, null),
  Oct = f(1717, null),
  qct = f(1718, null),
  Ej = f(1719, null),
  Uct = f(1720, null),
  Mct = f(1721, null),
  Hct = f(1722, null),
  Wct = f(1723, null),
  Ij = class Jh {
    static {
      this.c = new Error()
    }
    get lexingErrors() {
      return this.d.errors
    }
    get parsingErrors() {
      return this.h
    }
    constructor(t = Act) {
      ;(this.k = t),
        (this.d = new Ou()),
        (this.f = []),
        (this.g = 0),
        (this.h = []),
        (this.v = /g|y/g)
    }
    parse(t) {
      if (t === "") {
        this.h.push({
          message: Bct,
          offset: 0,
          lexeme: "",
          additionalInfo: Oct,
        })
        return
      }
      ;(this.f = this.d.reset(t).scan()), (this.g = 0), (this.h = [])
      try {
        const e = this.l()
        if (!this.E()) {
          const r = this.D(),
            s = r.type === 17 ? Mct : void 0
          throw (
            (this.h.push({
              message: Uct,
              offset: r.offset,
              lexeme: Ou.getLexeme(r),
              additionalInfo: s,
            }),
            Jh.c)
          )
        }
        return e
      } catch (e) {
        if (e !== Jh.c) throw e
        return
      }
    }
    l() {
      return this.m()
    }
    m() {
      const t = [this.o()]
      for (; this.y(16); ) {
        const e = this.o()
        t.push(e)
      }
      return t.length === 1 ? t[0] : ze.or(...t)
    }
    o() {
      const t = [this.s()]
      for (; this.y(15); ) {
        const e = this.s()
        t.push(e)
      }
      return t.length === 1 ? t[0] : ze.and(...t)
    }
    s() {
      if (this.y(2)) {
        const t = this.D()
        switch (t.type) {
          case 11:
            return this.z(), Ni.INSTANCE
          case 12:
            return this.z(), Vi.INSTANCE
          case 0: {
            this.z()
            const e = this.l()
            return this.A(1, Ej), e?.negate()
          }
          case 17:
            return this.z(), Mu.create(t.lexeme)
          default:
            throw this.B("KEY | true | false | '(' expression ')'", t)
        }
      }
      return this.t()
    }
    t() {
      const t = this.D()
      switch (t.type) {
        case 11:
          return this.z(), ze.true()
        case 12:
          return this.z(), ze.false()
        case 0: {
          this.z()
          const e = this.l()
          return this.A(1, Ej), e
        }
        case 17: {
          const e = t.lexeme
          if ((this.z(), this.y(9))) {
            const s = this.D()
            if (!this.k.regexParsingWithErrorRecovery) {
              if ((this.z(), s.type !== 10)) throw this.B("REGEX", s)
              const a = s.lexeme,
                o = a.lastIndexOf("/"),
                c = o === a.length - 1 ? void 0 : this.w(a.substring(o + 1))
              let u
              try {
                u = new RegExp(a.substring(1, o), c)
              } catch {
                throw this.B("REGEX", s)
              }
              return GB.create(e, u)
            }
            switch (s.type) {
              case 10:
              case 19: {
                const a = [s.lexeme]
                this.z()
                let o = this.D(),
                  c = 0
                for (let p = 0; p < s.lexeme.length; p++)
                  s.lexeme.charCodeAt(p) === 40
                    ? c++
                    : s.lexeme.charCodeAt(p) === 41 && c--
                for (; !this.E() && o.type !== 15 && o.type !== 16; ) {
                  switch (o.type) {
                    case 0:
                      c++
                      break
                    case 1:
                      c--
                      break
                    case 10:
                    case 18:
                      for (let p = 0; p < o.lexeme.length; p++)
                        o.lexeme.charCodeAt(p) === 40
                          ? c++
                          : s.lexeme.charCodeAt(p) === 41 && c--
                  }
                  if (c < 0) break
                  a.push(Ou.getLexeme(o)), this.z(), (o = this.D())
                }
                const u = a.join(""),
                  l = u.lastIndexOf("/"),
                  m = l === u.length - 1 ? void 0 : this.w(u.substring(l + 1))
                let h
                try {
                  h = new RegExp(u.substring(1, l), m)
                } catch {
                  throw this.B("REGEX", s)
                }
                return ze.regex(e, h)
              }
              case 18: {
                const a = s.lexeme
                this.z()
                let o = null
                if (!s_(a)) {
                  const c = a.indexOf("/"),
                    u = a.lastIndexOf("/")
                  if (c !== u && c >= 0) {
                    const l = a.slice(c + 1, u),
                      m = a[u + 1] === "i" ? "i" : ""
                    try {
                      o = new RegExp(l, m)
                    } catch {
                      throw this.B("REGEX", s)
                    }
                  }
                }
                if (o === null) throw this.B("REGEX", s)
                return GB.create(e, o)
              }
              default:
                throw this.B("REGEX", this.D())
            }
          }
          if (this.y(14)) {
            this.A(13, qct)
            const s = this.u()
            return ze.notIn(e, s)
          }
          switch (this.D().type) {
            case 3: {
              this.z()
              const s = this.u()
              if (this.x().type === 18) return ze.equals(e, s)
              switch (s) {
                case "true":
                  return ze.has(e)
                case "false":
                  return ze.not(e)
                default:
                  return ze.equals(e, s)
              }
            }
            case 4: {
              this.z()
              const s = this.u()
              if (this.x().type === 18) return ze.notEquals(e, s)
              switch (s) {
                case "true":
                  return ze.not(e)
                case "false":
                  return ze.has(e)
                default:
                  return ze.notEquals(e, s)
              }
            }
            case 5:
              return this.z(), jB.create(e, this.u())
            case 6:
              return this.z(), VB.create(e, this.u())
            case 7:
              return this.z(), HB.create(e, this.u())
            case 8:
              return this.z(), WB.create(e, this.u())
            case 13:
              return this.z(), ze.in(e, this.u())
            default:
              return ze.has(e)
          }
        }
        case 20:
          throw (
            (this.h.push({
              message: Hct,
              offset: t.offset,
              lexeme: "",
              additionalInfo: Wct,
            }),
            Jh.c)
          )
        default:
          throw this.B(
            `true | false | KEY 
	| KEY '=~' REGEX 
	| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`,
            this.D(),
          )
      }
    }
    u() {
      const t = this.D()
      switch (t.type) {
        case 17:
        case 18:
          return this.z(), t.lexeme
        case 11:
          return this.z(), "true"
        case 12:
          return this.z(), "false"
        case 13:
          return this.z(), "in"
        default:
          return ""
      }
    }
    w(t) {
      return t.replaceAll(this.v, "")
    }
    x() {
      return this.f[this.g - 1]
    }
    y(t) {
      return this.C(t) ? (this.z(), !0) : !1
    }
    z() {
      return this.E() || this.g++, this.x()
    }
    A(t, e) {
      if (this.C(t)) return this.z()
      throw this.B(e, this.D())
    }
    B(t, e, r) {
      const s = f(1724, null, t, Ou.getLexeme(e)),
        a = e.offset,
        o = Ou.getLexeme(e)
      return (
        this.h.push({ message: s, offset: a, lexeme: o, additionalInfo: r }),
        Jh.c
      )
    }
    C(t) {
      return this.D().type === t
    }
    D() {
      return this.f[this.g]
    }
    E() {
      return this.D().type === 20
    }
  },
  ze = class {
    static false() {
      return Ni.INSTANCE
    }
    static true() {
      return Vi.INSTANCE
    }
    static has(i) {
      return Uu.create(i)
    }
    static equals(i, t) {
      return UB.create(i, t)
    }
    static notEquals(i, t) {
      return MB.create(i, t)
    }
    static regex(i, t) {
      return GB.create(i, t)
    }
    static in(i, t) {
      return Pj.create(i, t)
    }
    static notIn(i, t) {
      return Nj.create(i, t)
    }
    static not(i) {
      return Mu.create(i)
    }
    static and(...i) {
      return xj.create(i, null, !0)
    }
    static or(...i) {
      return zB.create(i, null, !0)
    }
    static greater(i, t) {
      return HB.create(i, t)
    }
    static greaterEquals(i, t) {
      return WB.create(i, t)
    }
    static smaller(i, t) {
      return jB.create(i, t)
    }
    static smallerEquals(i, t) {
      return VB.create(i, t)
    }
    static function(i) {
      return Vct.create(i)
    }
    static {
      this.c = new Ij({ regexParsingWithErrorRecovery: !1 })
    }
    static deserialize(i) {
      return i == null ? void 0 : this.c.parse(i)
    }
  }
function jct(i) {
  const t = new Ij({ regexParsingWithErrorRecovery: !1 })
  return i.map(
    (e) => (
      t.parse(e),
      t.lexingErrors.length > 0
        ? t.lexingErrors.map((r) => ({
            errorMessage: r.additionalInfo
              ? f(1725, null, r.additionalInfo)
              : f(1726, null),
            offset: r.offset,
            length: r.lexeme.length,
          }))
        : t.parsingErrors.length > 0
          ? t.parsingErrors.map((r) => ({
              errorMessage: r.additionalInfo
                ? `${r.message}. ${r.additionalInfo}`
                : r.message,
              offset: r.offset,
              length: r.lexeme.length,
            }))
          : []
    ),
  )
}
function qu(i, t) {
  return i.cmp(t)
}
var Vct = class uH {
    static create(t) {
      return new uH(t)
    }
    constructor(t) {
      ;(this.type = 16), (this.c = t)
    }
    cmp(t) {
      return this.type - t.type
    }
    equals(t) {
      return t.type === this.type && t.c === this.c
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      return this.c()
    }
    serialize() {
      return "(arbitrary function)"
    }
    keys() {
      return []
    }
    map(t) {
      return this
    }
    negate() {
      return new uH(() => !this.c())
    }
  },
  Ni = class Int {
    static {
      this.INSTANCE = new Int()
    }
    constructor() {
      this.type = 0
    }
    cmp(t) {
      return this.type - t.type
    }
    equals(t) {
      return t.type === this.type
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      return !1
    }
    serialize() {
      return "false"
    }
    keys() {
      return []
    }
    map(t) {
      return this
    }
    negate() {
      return Vi.INSTANCE
    }
  },
  Vi = class Pnt {
    static {
      this.INSTANCE = new Pnt()
    }
    constructor() {
      this.type = 1
    }
    cmp(t) {
      return this.type - t.type
    }
    equals(t) {
      return t.type === this.type
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      return !0
    }
    serialize() {
      return "true"
    }
    keys() {
      return []
    }
    map(t) {
      return this
    }
    negate() {
      return Ni.INSTANCE
    }
  },
  Uu = class Nnt {
    static create(t, e = null) {
      const r = ii.get(t)
      return typeof r == "boolean"
        ? r
          ? Vi.INSTANCE
          : Ni.INSTANCE
        : new Nnt(t, e)
    }
    constructor(t, e) {
      ;(this.key = t), (this.c = e), (this.type = 2)
    }
    cmp(t) {
      return t.type !== this.type ? this.type - t.type : Jj(this.key, t.key)
    }
    equals(t) {
      return t.type === this.type ? this.key === t.key : !1
    }
    substituteConstants() {
      const t = ii.get(this.key)
      return typeof t == "boolean" ? (t ? Vi.INSTANCE : Ni.INSTANCE) : this
    }
    evaluate(t) {
      return !!t.getValue(this.key)
    }
    serialize() {
      return this.key
    }
    keys() {
      return [this.key]
    }
    map(t) {
      return t.mapDefined(this.key)
    }
    negate() {
      return this.c || (this.c = Mu.create(this.key, this)), this.c
    }
  },
  UB = class $nt {
    static create(t, e, r = null) {
      if (typeof e == "boolean") return e ? Uu.create(t, r) : Mu.create(t, r)
      const s = ii.get(t)
      return typeof s == "boolean"
        ? e === (s ? "true" : "false")
          ? Vi.INSTANCE
          : Ni.INSTANCE
        : new $nt(t, e, r)
    }
    constructor(t, e, r) {
      ;(this.c = t), (this.d = e), (this.f = r), (this.type = 4)
    }
    cmp(t) {
      return t.type !== this.type
        ? this.type - t.type
        : ia(this.c, this.d, t.c, t.d)
    }
    equals(t) {
      return t.type === this.type ? this.c === t.c && this.d === t.d : !1
    }
    substituteConstants() {
      const t = ii.get(this.c)
      if (typeof t == "boolean") {
        const e = t ? "true" : "false"
        return this.d === e ? Vi.INSTANCE : Ni.INSTANCE
      }
      return this
    }
    evaluate(t) {
      return t.getValue(this.c) == this.d
    }
    serialize() {
      return `${this.c} == '${this.d}'`
    }
    keys() {
      return [this.c]
    }
    map(t) {
      return t.mapEquals(this.c, this.d)
    }
    negate() {
      return this.f || (this.f = MB.create(this.c, this.d, this)), this.f
    }
  },
  Pj = class xnt {
    static create(t, e) {
      return new xnt(t, e)
    }
    constructor(t, e) {
      ;(this.d = t), (this.f = e), (this.type = 10), (this.c = null)
    }
    cmp(t) {
      return t.type !== this.type
        ? this.type - t.type
        : ia(this.d, this.f, t.d, t.f)
    }
    equals(t) {
      return t.type === this.type ? this.d === t.d && this.f === t.f : !1
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      const e = t.getValue(this.f),
        r = t.getValue(this.d)
      return Array.isArray(e)
        ? e.includes(r)
        : typeof r == "string" && typeof e == "object" && e !== null
          ? _ct.call(e, r)
          : !1
    }
    serialize() {
      return `${this.d} in '${this.f}'`
    }
    keys() {
      return [this.d, this.f]
    }
    map(t) {
      return t.mapIn(this.d, this.f)
    }
    negate() {
      return this.c || (this.c = Nj.create(this.d, this.f)), this.c
    }
  },
  Nj = class Jnt {
    static create(t, e) {
      return new Jnt(t, e)
    }
    constructor(t, e) {
      ;(this.d = t), (this.f = e), (this.type = 11), (this.c = Pj.create(t, e))
    }
    cmp(t) {
      return t.type !== this.type ? this.type - t.type : this.c.cmp(t.c)
    }
    equals(t) {
      return t.type === this.type ? this.c.equals(t.c) : !1
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      return !this.c.evaluate(t)
    }
    serialize() {
      return `${this.d} not in '${this.f}'`
    }
    keys() {
      return this.c.keys()
    }
    map(t) {
      return t.mapNotIn(this.d, this.f)
    }
    negate() {
      return this.c
    }
  },
  MB = class Cnt {
    static create(t, e, r = null) {
      if (typeof e == "boolean") return e ? Mu.create(t, r) : Uu.create(t, r)
      const s = ii.get(t)
      return typeof s == "boolean"
        ? e === (s ? "true" : "false")
          ? Ni.INSTANCE
          : Vi.INSTANCE
        : new Cnt(t, e, r)
    }
    constructor(t, e, r) {
      ;(this.c = t), (this.d = e), (this.f = r), (this.type = 5)
    }
    cmp(t) {
      return t.type !== this.type
        ? this.type - t.type
        : ia(this.c, this.d, t.c, t.d)
    }
    equals(t) {
      return t.type === this.type ? this.c === t.c && this.d === t.d : !1
    }
    substituteConstants() {
      const t = ii.get(this.c)
      if (typeof t == "boolean") {
        const e = t ? "true" : "false"
        return this.d === e ? Ni.INSTANCE : Vi.INSTANCE
      }
      return this
    }
    evaluate(t) {
      return t.getValue(this.c) != this.d
    }
    serialize() {
      return `${this.c} != '${this.d}'`
    }
    keys() {
      return [this.c]
    }
    map(t) {
      return t.mapNotEquals(this.c, this.d)
    }
    negate() {
      return this.f || (this.f = UB.create(this.c, this.d, this)), this.f
    }
  },
  Mu = class Lnt {
    static create(t, e = null) {
      const r = ii.get(t)
      return typeof r == "boolean"
        ? r
          ? Ni.INSTANCE
          : Vi.INSTANCE
        : new Lnt(t, e)
    }
    constructor(t, e) {
      ;(this.c = t), (this.d = e), (this.type = 3)
    }
    cmp(t) {
      return t.type !== this.type ? this.type - t.type : Jj(this.c, t.c)
    }
    equals(t) {
      return t.type === this.type ? this.c === t.c : !1
    }
    substituteConstants() {
      const t = ii.get(this.c)
      return typeof t == "boolean" ? (t ? Ni.INSTANCE : Vi.INSTANCE) : this
    }
    evaluate(t) {
      return !t.getValue(this.c)
    }
    serialize() {
      return `!${this.c}`
    }
    keys() {
      return [this.c]
    }
    map(t) {
      return t.mapNot(this.c)
    }
    negate() {
      return this.d || (this.d = Uu.create(this.c, this)), this.d
    }
  }
function d_(i, t) {
  if (typeof i == "string") {
    const e = parseFloat(i)
    isNaN(e) || (i = e)
  }
  return typeof i == "string" || typeof i == "number" ? t(i) : Ni.INSTANCE
}
var HB = class Rnt {
    static create(t, e, r = null) {
      return d_(e, (s) => new Rnt(t, s, r))
    }
    constructor(t, e, r) {
      ;(this.c = t), (this.d = e), (this.f = r), (this.type = 12)
    }
    cmp(t) {
      return t.type !== this.type
        ? this.type - t.type
        : ia(this.c, this.d, t.c, t.d)
    }
    equals(t) {
      return t.type === this.type ? this.c === t.c && this.d === t.d : !1
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      return typeof this.d == "string"
        ? !1
        : parseFloat(t.getValue(this.c)) > this.d
    }
    serialize() {
      return `${this.c} > ${this.d}`
    }
    keys() {
      return [this.c]
    }
    map(t) {
      return t.mapGreater(this.c, this.d)
    }
    negate() {
      return this.f || (this.f = VB.create(this.c, this.d, this)), this.f
    }
  },
  WB = class Dnt {
    static create(t, e, r = null) {
      return d_(e, (s) => new Dnt(t, s, r))
    }
    constructor(t, e, r) {
      ;(this.c = t), (this.d = e), (this.f = r), (this.type = 13)
    }
    cmp(t) {
      return t.type !== this.type
        ? this.type - t.type
        : ia(this.c, this.d, t.c, t.d)
    }
    equals(t) {
      return t.type === this.type ? this.c === t.c && this.d === t.d : !1
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      return typeof this.d == "string"
        ? !1
        : parseFloat(t.getValue(this.c)) >= this.d
    }
    serialize() {
      return `${this.c} >= ${this.d}`
    }
    keys() {
      return [this.c]
    }
    map(t) {
      return t.mapGreaterEquals(this.c, this.d)
    }
    negate() {
      return this.f || (this.f = jB.create(this.c, this.d, this)), this.f
    }
  },
  jB = class Fnt {
    static create(t, e, r = null) {
      return d_(e, (s) => new Fnt(t, s, r))
    }
    constructor(t, e, r) {
      ;(this.c = t), (this.d = e), (this.f = r), (this.type = 14)
    }
    cmp(t) {
      return t.type !== this.type
        ? this.type - t.type
        : ia(this.c, this.d, t.c, t.d)
    }
    equals(t) {
      return t.type === this.type ? this.c === t.c && this.d === t.d : !1
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      return typeof this.d == "string"
        ? !1
        : parseFloat(t.getValue(this.c)) < this.d
    }
    serialize() {
      return `${this.c} < ${this.d}`
    }
    keys() {
      return [this.c]
    }
    map(t) {
      return t.mapSmaller(this.c, this.d)
    }
    negate() {
      return this.f || (this.f = WB.create(this.c, this.d, this)), this.f
    }
  },
  VB = class _nt {
    static create(t, e, r = null) {
      return d_(e, (s) => new _nt(t, s, r))
    }
    constructor(t, e, r) {
      ;(this.c = t), (this.d = e), (this.f = r), (this.type = 15)
    }
    cmp(t) {
      return t.type !== this.type
        ? this.type - t.type
        : ia(this.c, this.d, t.c, t.d)
    }
    equals(t) {
      return t.type === this.type ? this.c === t.c && this.d === t.d : !1
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      return typeof this.d == "string"
        ? !1
        : parseFloat(t.getValue(this.c)) <= this.d
    }
    serialize() {
      return `${this.c} <= ${this.d}`
    }
    keys() {
      return [this.c]
    }
    map(t) {
      return t.mapSmallerEquals(this.c, this.d)
    }
    negate() {
      return this.f || (this.f = HB.create(this.c, this.d, this)), this.f
    }
  },
  GB = class Ant {
    static create(t, e) {
      return new Ant(t, e)
    }
    constructor(t, e) {
      ;(this.d = t), (this.f = e), (this.type = 7), (this.c = null)
    }
    cmp(t) {
      if (t.type !== this.type) return this.type - t.type
      if (this.d < t.d) return -1
      if (this.d > t.d) return 1
      const e = this.f ? this.f.source : "",
        r = t.f ? t.f.source : ""
      return e < r ? -1 : e > r ? 1 : 0
    }
    equals(t) {
      if (t.type === this.type) {
        const e = this.f ? this.f.source : "",
          r = t.f ? t.f.source : ""
        return this.d === t.d && e === r
      }
      return !1
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      const e = t.getValue(this.d)
      return this.f ? this.f.test(e) : !1
    }
    serialize() {
      const t = this.f ? `/${this.f.source}/${this.f.flags}` : "/invalid/"
      return `${this.d} =~ ${t}`
    }
    keys() {
      return [this.d]
    }
    map(t) {
      return t.mapRegex(this.d, this.f)
    }
    negate() {
      return this.c || (this.c = Gct.create(this)), this.c
    }
  },
  Gct = class lH {
    static create(t) {
      return new lH(t)
    }
    constructor(t) {
      ;(this.c = t), (this.type = 8)
    }
    cmp(t) {
      return t.type !== this.type ? this.type - t.type : this.c.cmp(t.c)
    }
    equals(t) {
      return t.type === this.type ? this.c.equals(t.c) : !1
    }
    substituteConstants() {
      return this
    }
    evaluate(t) {
      return !this.c.evaluate(t)
    }
    serialize() {
      return `!(${this.c.serialize()})`
    }
    keys() {
      return this.c.keys()
    }
    map(t) {
      return new lH(this.c.map(t))
    }
    negate() {
      return this.c
    }
  }
function $j(i) {
  let t = null
  for (let e = 0, r = i.length; e < r; e++) {
    const s = i[e].substituteConstants()
    if (i[e] !== s && t === null) {
      t = []
      for (let a = 0; a < e; a++) t[a] = i[a]
    }
    t !== null && (t[e] = s)
  }
  return t === null ? i : t
}
var xj = class Yc {
    static create(t, e, r) {
      return Yc.d(t, e, r)
    }
    constructor(t, e) {
      ;(this.expr = t), (this.c = e), (this.type = 6)
    }
    cmp(t) {
      if (t.type !== this.type) return this.type - t.type
      if (this.expr.length < t.expr.length) return -1
      if (this.expr.length > t.expr.length) return 1
      for (let e = 0, r = this.expr.length; e < r; e++) {
        const s = qu(this.expr[e], t.expr[e])
        if (s !== 0) return s
      }
      return 0
    }
    equals(t) {
      if (t.type === this.type) {
        if (this.expr.length !== t.expr.length) return !1
        for (let e = 0, r = this.expr.length; e < r; e++)
          if (!this.expr[e].equals(t.expr[e])) return !1
        return !0
      }
      return !1
    }
    substituteConstants() {
      const t = $j(this.expr)
      return t === this.expr ? this : Yc.create(t, this.c, !1)
    }
    evaluate(t) {
      for (let e = 0, r = this.expr.length; e < r; e++)
        if (!this.expr[e].evaluate(t)) return !1
      return !0
    }
    static d(t, e, r) {
      const s = []
      let a = !1
      for (const o of t)
        if (o) {
          if (o.type === 1) {
            a = !0
            continue
          }
          if (o.type === 0) return Ni.INSTANCE
          if (o.type === 6) {
            s.push(...o.expr)
            continue
          }
          s.push(o)
        }
      if (s.length === 0 && a) return Vi.INSTANCE
      if (s.length !== 0) {
        if (s.length === 1) return s[0]
        s.sort(qu)
        for (let o = 1; o < s.length; o++)
          s[o - 1].equals(s[o]) && (s.splice(o, 1), o--)
        if (s.length === 1) return s[0]
        for (; s.length > 1; ) {
          const o = s[s.length - 1]
          if (o.type !== 9) break
          s.pop()
          const c = s.pop(),
            u = s.length === 0,
            l = zB.create(
              o.expr.map((m) => Yc.create([m, c], null, r)),
              null,
              u,
            )
          l && (s.push(l), s.sort(qu))
        }
        if (s.length === 1) return s[0]
        if (r) {
          for (let o = 0; o < s.length; o++)
            for (let c = o + 1; c < s.length; c++)
              if (s[o].negate().equals(s[c])) return Ni.INSTANCE
          if (s.length === 1) return s[0]
        }
        return new Yc(s, e)
      }
    }
    serialize() {
      return this.expr.map((t) => t.serialize()).join(" && ")
    }
    keys() {
      const t = []
      for (const e of this.expr) t.push(...e.keys())
      return t
    }
    map(t) {
      return new Yc(
        this.expr.map((e) => e.map(t)),
        null,
      )
    }
    negate() {
      if (!this.c) {
        const t = []
        for (const e of this.expr) t.push(e.negate())
        this.c = zB.create(t, this, !0)
      }
      return this.c
    }
  },
  zB = class Qa {
    static create(t, e, r) {
      return Qa.d(t, e, r)
    }
    constructor(t, e) {
      ;(this.expr = t), (this.c = e), (this.type = 9)
    }
    cmp(t) {
      if (t.type !== this.type) return this.type - t.type
      if (this.expr.length < t.expr.length) return -1
      if (this.expr.length > t.expr.length) return 1
      for (let e = 0, r = this.expr.length; e < r; e++) {
        const s = qu(this.expr[e], t.expr[e])
        if (s !== 0) return s
      }
      return 0
    }
    equals(t) {
      if (t.type === this.type) {
        if (this.expr.length !== t.expr.length) return !1
        for (let e = 0, r = this.expr.length; e < r; e++)
          if (!this.expr[e].equals(t.expr[e])) return !1
        return !0
      }
      return !1
    }
    substituteConstants() {
      const t = $j(this.expr)
      return t === this.expr ? this : Qa.create(t, this.c, !1)
    }
    evaluate(t) {
      for (let e = 0, r = this.expr.length; e < r; e++)
        if (this.expr[e].evaluate(t)) return !0
      return !1
    }
    static d(t, e, r) {
      let s = [],
        a = !1
      if (t) {
        for (let o = 0, c = t.length; o < c; o++) {
          const u = t[o]
          if (u) {
            if (u.type === 0) {
              a = !0
              continue
            }
            if (u.type === 1) return Vi.INSTANCE
            if (u.type === 9) {
              s = s.concat(u.expr)
              continue
            }
            s.push(u)
          }
        }
        if (s.length === 0 && a) return Ni.INSTANCE
        s.sort(qu)
      }
      if (s.length !== 0) {
        if (s.length === 1) return s[0]
        for (let o = 1; o < s.length; o++)
          s[o - 1].equals(s[o]) && (s.splice(o, 1), o--)
        if (s.length === 1) return s[0]
        if (r) {
          for (let o = 0; o < s.length; o++)
            for (let c = o + 1; c < s.length; c++)
              if (s[o].negate().equals(s[c])) return Vi.INSTANCE
          if (s.length === 1) return s[0]
        }
        return new Qa(s, e)
      }
    }
    serialize() {
      return this.expr.map((t) => t.serialize()).join(" || ")
    }
    keys() {
      const t = []
      for (const e of this.expr) t.push(...e.keys())
      return t
    }
    map(t) {
      return new Qa(
        this.expr.map((e) => e.map(t)),
        null,
      )
    }
    negate() {
      if (!this.c) {
        const t = []
        for (const e of this.expr) t.push(e.negate())
        for (; t.length > 1; ) {
          const e = t.shift(),
            r = t.shift(),
            s = []
          for (const a of Cj(e))
            for (const o of Cj(r)) s.push(xj.create([a, o], null, !1))
          t.unshift(Qa.create(s, null, !1))
        }
        this.c = Qa.create(t, this, !0)
      }
      return this.c
    }
  },
  H = class O8 extends Uu {
    static {
      this.d = []
    }
    static all() {
      return O8.d.values()
    }
    constructor(t, e, r) {
      super(t, null),
        (this.f = e),
        typeof r == "object"
          ? O8.d.push({ ...r, key: t })
          : r !== !0 &&
            O8.d.push({
              key: t,
              description: r,
              type: e != null ? typeof e : void 0,
            })
    }
    bindTo(t) {
      return t.createKey(this.key, this.f)
    }
    getValue(t) {
      return t.getContextKeyValue(this.key)
    }
    toNegated() {
      return this.negate()
    }
    isEqualTo(t) {
      return UB.create(this.key, t)
    }
    notEqualsTo(t) {
      return MB.create(this.key, t)
    }
  },
  zct = Y("contextKeyService")
function Jj(i, t) {
  return i < t ? -1 : i > t ? 1 : 0
}
function ia(i, t, e, r) {
  return i < e ? -1 : i > e ? 1 : t < r ? -1 : t > r ? 1 : 0
}
function Cj(i) {
  return i.type === 9 ? i.expr : [i]
}
var Kt = Y("logService"),
  Hu = Y("loggerService")
function Yct(i) {
  return os(i)
}
var Mt
;(function (i) {
  ;(i[(i.Off = 0)] = "Off"),
    (i[(i.Trace = 1)] = "Trace"),
    (i[(i.Debug = 2)] = "Debug"),
    (i[(i.Info = 3)] = "Info"),
    (i[(i.Warning = 4)] = "Warning"),
    (i[(i.Error = 5)] = "Error")
})(Mt || (Mt = {}))
var Qct = Mt.Info
function Xct(i, t, e) {
  switch (t) {
    case Mt.Trace:
      i.trace(e)
      break
    case Mt.Debug:
      i.debug(e)
      break
    case Mt.Info:
      i.info(e)
      break
    case Mt.Warning:
      i.warn(e)
      break
    case Mt.Error:
      i.error(e)
      break
    case Mt.Off:
      break
    default:
      throw new Error(`Invalid log level ${t}`)
  }
}
function wo(i, t = !1) {
  let e = ""
  for (let r = 0; r < i.length; r++) {
    let s = i[r]
    if ((s instanceof Error && (s = ea(s, t)), typeof s == "object"))
      try {
        s = JSON.stringify(s)
      } catch {}
    e += (r > 0 ? " " : "") + s
  }
  return e
}
var Lj = class extends dt {
    constructor() {
      super(...arguments),
        (this.b = Qct),
        (this.c = this.D(new C())),
        (this.onDidChangeLogLevel = this.c.event)
    }
    setLevel(i) {
      this.b !== i && ((this.b = i), this.c.fire(this.b))
    }
    getLevel() {
      return this.b
    }
    f(i) {
      return this.b !== Mt.Off && this.b <= i
    }
    g(i) {
      return this.B.isDisposed ? !1 : this.f(i)
    }
  },
  Rj = class extends Lj {
    constructor(i) {
      super(), (this.h = i)
    }
    f(i) {
      return this.h || super.f(i)
    }
    trace(i, ...t) {
      this.g(Mt.Trace) && this.m(Mt.Trace, wo([i, ...t], !0))
    }
    debug(i, ...t) {
      this.g(Mt.Debug) && this.m(Mt.Debug, wo([i, ...t]))
    }
    info(i, ...t) {
      this.g(Mt.Info) && this.m(Mt.Info, wo([i, ...t]))
    }
    warn(i, ...t) {
      this.g(Mt.Warning) && this.m(Mt.Warning, wo([i, ...t]))
    }
    error(i, ...t) {
      if (this.g(Mt.Error))
        if (i instanceof Error) {
          const e = Array.prototype.slice.call(arguments)
          ;(e[0] = i.stack), this.m(Mt.Error, wo(e))
        } else this.m(Mt.Error, wo([i, ...t]))
    }
    flush() {}
  },
  Kct = class extends Lj {
    constructor(i) {
      super(), (this.h = i), i.length && this.setLevel(i[0].getLevel())
    }
    setLevel(i) {
      for (const t of this.h) t.setLevel(i)
      super.setLevel(i)
    }
    trace(i, ...t) {
      for (const e of this.h) e.trace(i, ...t)
    }
    debug(i, ...t) {
      for (const e of this.h) e.debug(i, ...t)
    }
    info(i, ...t) {
      for (const e of this.h) e.info(i, ...t)
    }
    warn(i, ...t) {
      for (const e of this.h) e.warn(i, ...t)
    }
    error(i, ...t) {
      for (const e of this.h) e.error(i, ...t)
    }
    flush() {
      for (const i of this.h) i.flush()
    }
    dispose() {
      for (const i of this.h) i.dispose()
      super.dispose()
    }
  },
  Zct = class extends dt {
    constructor(i, t, e) {
      if (
        (super(),
        (this.h = i),
        (this.j = t),
        (this.b = new ei()),
        (this.c = this.D(new C())),
        (this.onDidChangeLoggers = this.c.event),
        (this.f = this.D(new C())),
        (this.onDidChangeLogLevel = this.f.event),
        (this.g = this.D(new C())),
        (this.onDidChangeVisibility = this.g.event),
        e)
      )
        for (const r of e) this.b.set(r.resource, { logger: void 0, info: r })
    }
    m(i) {
      return Bt(i)
        ? [...this.b.values()].find((t) => t.info.id === i)
        : this.b.get(i)
    }
    getLogger(i) {
      return this.m(i)?.logger
    }
    createLogger(i, t) {
      const e = this.n(i),
        r = Bt(i) ? i : (t?.id ?? Au(e.toString()).toString(16))
      let s = this.b.get(e)?.logger
      const a = t?.logLevel === "always" ? Mt.Trace : t?.logLevel
      s || (s = this.q(e, a ?? this.getLogLevel(e) ?? this.h, { ...t, id: r }))
      const o = {
        logger: s,
        info: {
          resource: e,
          id: r,
          logLevel: a,
          name: t?.name,
          hidden: t?.hidden,
          extensionId: t?.extensionId,
          when: t?.when,
        },
      }
      return this.registerLogger(o.info), this.b.set(e, o), s
    }
    n(i) {
      return Bt(i) ? Ti(this.j, `${i}.log`) : i
    }
    setLogLevel(i, t) {
      if (S.isUri(i)) {
        const e = i,
          r = t,
          s = this.b.get(e)
        s &&
          r !== s.info.logLevel &&
          ((s.info.logLevel = r === this.h ? void 0 : r),
          s.logger?.setLevel(r),
          this.b.set(s.info.resource, s),
          this.f.fire([e, r]))
      } else {
        this.h = i
        for (const [e, r] of this.b.entries())
          this.b.get(e)?.info.logLevel === void 0 && r.logger?.setLevel(this.h)
        this.f.fire(this.h)
      }
    }
    setVisibility(i, t) {
      const e = this.m(i)
      e &&
        t !== !e.info.hidden &&
        ((e.info.hidden = !t),
        this.b.set(e.info.resource, e),
        this.g.fire([e.info.resource, t]))
    }
    getLogLevel(i) {
      let t
      return i && (t = this.b.get(i)?.info.logLevel), t ?? this.h
    }
    registerLogger(i) {
      const t = this.b.get(i.resource)
      t
        ? t.info.hidden !== i.hidden &&
          this.setVisibility(i.resource, !i.hidden)
        : (this.b.set(i.resource, { info: i, logger: void 0 }),
          this.c.fire({ added: [i], removed: [] }))
    }
    deregisterLogger(i) {
      const t = this.b.get(i)
      t &&
        (t.logger && t.logger.dispose(),
        this.b.delete(i),
        this.c.fire({ added: [], removed: [t.info] }))
    }
    *getRegisteredLoggers() {
      for (const i of this.b.values()) yield i.info
    }
    getRegisteredLogger(i) {
      return this.b.get(i)?.info
    }
    dispose() {
      this.b.forEach((i) => i.logger?.dispose()),
        this.b.clear(),
        super.dispose()
    }
  }
function tut(i) {
  switch (i) {
    case Mt.Trace:
      return "trace"
    case Mt.Debug:
      return "debug"
    case Mt.Info:
      return "info"
    case Mt.Warning:
      return "warn"
    case Mt.Error:
      return "error"
    case Mt.Off:
      return "off"
  }
}
function eut(i) {
  switch (i) {
    case "trace":
      return Mt.Trace
    case "debug":
      return Mt.Debug
    case "info":
      return Mt.Info
    case "warn":
      return Mt.Warning
    case "error":
      return Mt.Error
    case "critical":
      return Mt.Error
    case "off":
      return Mt.Off
  }
}
var L8t = new H("logLevel", tut(Mt.Info)),
  Tn = class {
    constructor(i, t = [], e = !1) {
      ;(this.ctor = i),
        (this.staticArguments = t),
        (this.supportsDelayedInstantiation = e)
    }
  },
  Dj = [],
  Fj
;(function (i) {
  ;(i[(i.Eager = 0)] = "Eager"), (i[(i.Delayed = 1)] = "Delayed")
})(Fj || (Fj = {}))
function Zt(i, t, e) {
  t instanceof Tn || (t = new Tn(t, [], !!e)), Dj.push([i, t])
}
function iut() {
  return Dj
}
var YB = class {
    constructor(...i) {
      this.a = new Map()
      for (const [t, e] of i) this.set(t, e)
    }
    set(i, t) {
      const e = this.a.get(i)
      return this.a.set(i, t), e
    }
    has(i) {
      return this.a.has(i)
    }
    get(i) {
      return this.a.get(i)
    }
  },
  ci = Y("IExtHostInitDataService"),
  rut = class {
    constructor(i, t) {
      ;(this.key = i),
        (this.data = t),
        (this.incoming = new Map()),
        (this.outgoing = new Map())
    }
  },
  _j = class {
    constructor(i) {
      ;(this.b = i), (this.a = new Map())
    }
    roots() {
      const i = []
      for (const t of this.a.values()) t.outgoing.size === 0 && i.push(t)
      return i
    }
    insertEdge(i, t) {
      const e = this.lookupOrInsertNode(i),
        r = this.lookupOrInsertNode(t)
      e.outgoing.set(r.key, r), r.incoming.set(e.key, e)
    }
    removeNode(i) {
      const t = this.b(i)
      this.a.delete(t)
      for (const e of this.a.values())
        e.outgoing.delete(t), e.incoming.delete(t)
    }
    lookupOrInsertNode(i) {
      const t = this.b(i)
      let e = this.a.get(t)
      return e || ((e = new rut(t, i)), this.a.set(t, e)), e
    }
    lookup(i) {
      return this.a.get(this.b(i))
    }
    isEmpty() {
      return this.a.size === 0
    }
    toString() {
      const i = []
      for (const [t, e] of this.a)
        i.push(`${t}
	(-> incoming)[${[...e.incoming.keys()].join(", ")}]
	(outgoing ->)[${[...e.outgoing.keys()].join(",")}]
`)
      return i.join(`
`)
    }
    findCycleSlow() {
      for (const [i, t] of this.a) {
        const e = new Set([i]),
          r = this.c(t, e)
        if (r) return r
      }
    }
    c(i, t) {
      for (const [e, r] of i.outgoing) {
        if (t.has(e)) return [...t, e].join(" -> ")
        t.add(e)
        const s = this.c(r, t)
        if (s) return s
        t.delete(e)
      }
    }
  },
  nut = !1,
  Aj = class extends Error {
    constructor(i, t) {
      super("cyclic dependency between services"),
        (this.message =
          `REASON: ${t}
` +
          (i.findCycleSlow() ??
            `UNABLE to detect cycle, dumping graph: 
${i.toString()}`))
    }
  },
  sut = class dH {
    constructor(t = new YB(), e = !1, r, s = nut) {
      ;(this.i = t),
        (this.j = e),
        (this.k = r),
        (this.l = s),
        (this.f = !1),
        (this.g = new Set()),
        (this.h = new Set()),
        (this.t = new Set()),
        this.i.set(l_, this),
        (this._globalGraph = s ? (r?._globalGraph ?? new _j((a) => a)) : void 0)
    }
    dispose() {
      if (!this.f) {
        ;(this.f = !0), pn(this.h), this.h.clear()
        for (const t of this.g) dat(t) && t.dispose()
        this.g.clear()
      }
    }
    m() {
      if (this.f) throw new Error("InstantiationService has been disposed")
    }
    createChild(t, e) {
      this.m()
      const r = this,
        s = new (class extends dH {
          dispose() {
            r.h.delete(s), super.dispose()
          }
        })(t, this.j, this, this.l)
      return this.h.add(s), e?.add(s), s
    }
    invokeFunction(t, ...e) {
      this.m()
      const r = QB.traceInvocation(this.l, t)
      let s = !1
      try {
        return t(
          {
            get: (o) => {
              if (s)
                throw iB(
                  "service accessor is only valid during the invocation of its target method",
                )
              const c = this.s(o, r)
              if (!c) throw new Error(`[invokeFunction] unknown service '${o}'`)
              return c
            },
          },
          ...e,
        )
      } finally {
        ;(s = !0), r.stop()
      }
    }
    createInstance(t, ...e) {
      this.m()
      let r, s
      return (
        t instanceof Tn
          ? ((r = QB.traceCreation(this.l, t.ctor)),
            (s = this.o(t.ctor, t.staticArguments.concat(e), r)))
          : ((r = QB.traceCreation(this.l, t)), (s = this.o(t, e, r))),
        r.stop(),
        s
      )
    }
    o(t, e = [], r) {
      const s = Er.getServiceDependencies(t).sort((c, u) => c.index - u.index),
        a = []
      for (const c of s) {
        const u = this.s(c.id, r)
        u ||
          this.y(
            `[createInstance] ${t.name} depends on UNKNOWN service ${c.id}.`,
            !1,
          ),
          a.push(u)
      }
      const o = s.length > 0 ? s[0].index : e.length
      if (e.length !== o) {
        console.trace(
          `[createInstance] First service dependency of ${t.name} at position ${o + 1} conflicts with ${e.length} static arguments`,
        )
        const c = o - e.length
        c > 0 ? (e = e.concat(new Array(c))) : (e = e.slice(0, o))
      }
      return Reflect.construct(t, e.concat(a))
    }
    q(t, e) {
      if (this.i.get(t) instanceof Tn) this.i.set(t, e)
      else if (this.k) this.k.q(t, e)
      else throw new Error("illegalState - setting UNKNOWN service instance")
    }
    r(t) {
      const e = this.i.get(t)
      return !e && this.k ? this.k.r(t) : e
    }
    s(t, e) {
      this._globalGraph &&
        this.c &&
        this._globalGraph.insertEdge(this.c, String(t))
      const r = this.r(t)
      return r instanceof Tn
        ? this.u(t, r, e.branch(t, !0))
        : (e.branch(t, !1), r)
    }
    u(t, e, r) {
      if (this.t.has(t))
        throw new Error(
          `illegal state - RECURSIVELY instantiating service '${t}'`,
        )
      this.t.add(t)
      try {
        return this.v(t, e, r)
      } finally {
        this.t.delete(t)
      }
    }
    v(t, e, r) {
      const s = new _j((u) => u.id.toString())
      let a = 0
      const o = [{ id: t, desc: e, _trace: r }],
        c = new Set()
      for (; o.length; ) {
        const u = o.pop()
        if (!c.has(String(u.id))) {
          if ((c.add(String(u.id)), s.lookupOrInsertNode(u), a++ > 1e4))
            throw new Aj(s, "cycle count more than 1000")
          for (const l of Er.getServiceDependencies(u.desc.ctor)) {
            const m = this.r(l.id)
            if (
              (m ||
                this.y(
                  `[createInstance] ${t} depends on ${l.id} which is NOT registered.`,
                  !0,
                ),
              this._globalGraph?.insertEdge(String(u.id), String(l.id)),
              m instanceof Tn)
            ) {
              const h = { id: l.id, desc: m, _trace: u._trace.branch(l.id, !0) }
              s.insertEdge(u, h), o.push(h)
            }
          }
        }
      }
      for (;;) {
        const u = s.roots()
        if (u.length === 0) {
          if (!s.isEmpty())
            throw new Aj(s, "no more roots but still nodes in the graph")
          break
        }
        for (const { data: l } of u) {
          if (this.r(l.id) instanceof Tn) {
            const h = this.w(
              l.id,
              l.desc.ctor,
              l.desc.staticArguments,
              l.desc.supportsDelayedInstantiation,
              l._trace,
            )
            this.q(l.id, h)
          }
          s.removeNode(l)
        }
      }
      return this.r(t)
    }
    w(t, e, r = [], s, a) {
      if (this.i.get(t) instanceof Tn) return this.x(t, e, r, s, a, this.g)
      if (this.k) return this.k.w(t, e, r, s, a)
      throw new Error(
        `illegalState - creating UNKNOWN service instance ${e.name}`,
      )
    }
    x(t, e, r = [], s, a, o) {
      if (s) {
        const c = new dH(void 0, this.j, this, this.l)
        c.c = String(t)
        const u = new Map(),
          l = new kct(() => {
            const m = c.o(e, r, a)
            for (const [h, p] of u) {
              const g = m[h]
              if (typeof g == "function")
                for (const w of p) w.disposable = g.apply(m, w.listener)
            }
            return u.clear(), o.add(m), m
          })
        return new Proxy(Object.create(null), {
          get(m, h) {
            if (
              !l.isInitialized &&
              typeof h == "string" &&
              (h.startsWith("onDid") || h.startsWith("onWill"))
            ) {
              let w = u.get(h)
              return (
                w || ((w = new Eu()), u.set(h, w)),
                (b, N, $) => {
                  if (l.isInitialized) return l.value[h](b, N, $)
                  {
                    const L = { listener: [b, N, $], disposable: void 0 },
                      U = w.push(L)
                    return it(() => {
                      U(), L.disposable?.dispose()
                    })
                  }
                }
              )
            }
            if (h in m) return m[h]
            const p = l.value
            let g = p[h]
            return typeof g != "function" || ((g = g.bind(p)), (m[h] = g)), g
          },
          set(m, h, p) {
            return (l.value[h] = p), !0
          },
          getPrototypeOf(m) {
            return e.prototype
          },
        })
      } else {
        const c = this.o(e, r, a)
        return o.add(c), c
      }
    }
    y(t, e) {
      if ((e && console.warn(t), this.j)) throw new Error(t)
    }
  },
  Bj
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Creation = 1)] = "Creation"),
    (i[(i.Invocation = 2)] = "Invocation"),
    (i[(i.Branch = 3)] = "Branch")
})(Bj || (Bj = {}))
var QB = class dn {
    static {
      this.all = new Set()
    }
    static {
      this.c = new (class extends dn {
        constructor() {
          super(0, null)
        }
        stop() {}
        branch() {
          return this
        }
      })()
    }
    static traceInvocation(t, e) {
      return t
        ? new dn(
            2,
            e.name ||
              new Error().stack
                .split(
                  `
`,
                )
                .slice(3, 4).join(`
`),
          )
        : dn.c
    }
    static traceCreation(t, e) {
      return t ? new dn(1, e.name) : dn.c
    }
    static {
      this.f = 0
    }
    constructor(t, e) {
      ;(this.type = t), (this.name = e), (this.g = Date.now()), (this.h = [])
    }
    branch(t, e) {
      const r = new dn(3, t.toString())
      return this.h.push([t, e, r]), r
    }
    stop() {
      const t = Date.now() - this.g
      dn.f += t
      let e = !1
      function r(a, o) {
        const c = [],
          u = new Array(a + 1).join("	")
        for (const [l, m, h] of o.h)
          if (m && h) {
            ;(e = !0), c.push(`${u}CREATES -> ${l}`)
            const p = r(a + 1, h)
            p && c.push(p)
          } else c.push(`${u}uses -> ${l}`)
        return c.join(`
`)
      }
      const s = [
        `${this.type === 1 ? "CREATE" : "CALL"} ${this.name}`,
        `${r(1, this)}`,
        `DONE, took ${t.toFixed(2)}ms (grand total ${dn.f.toFixed(2)}ms)`,
      ]
      ;(t > 2 || e) &&
        dn.all.add(
          s.join(`
`),
        )
    }
  },
  Vt = Y("IExtHostRpcService"),
  aut = class {
    constructor(i) {
      ;(this.getProxy = i.getProxy.bind(i)),
        (this.set = i.set.bind(i)),
        (this.dispose = i.dispose.bind(i)),
        (this.assertRegistered = i.assertRegistered.bind(i)),
        (this.drain = i.drain.bind(i))
    }
  },
  m_ = Y("IURITransformerService"),
  out = class {
    constructor(i) {
      i
        ? ((this.transformIncoming = i.transformIncoming.bind(i)),
          (this.transformOutgoing = i.transformOutgoing.bind(i)),
          (this.transformOutgoingURI = i.transformOutgoingURI.bind(i)),
          (this.transformOutgoingScheme = i.transformOutgoingScheme.bind(i)))
        : ((this.transformIncoming = (t) => t),
          (this.transformOutgoing = (t) => t),
          (this.transformOutgoingURI = (t) => t),
          (this.transformOutgoingScheme = (t) => t))
    }
  },
  cut = class {
    constructor() {
      ;(this.b = ""), (this.c = 0)
    }
    reset(i) {
      return (this.b = i), (this.c = 0), this
    }
    next() {
      return (this.c += 1), this
    }
    hasNext() {
      return this.c < this.b.length - 1
    }
    cmp(i) {
      const t = i.charCodeAt(0),
        e = this.b.charCodeAt(this.c)
      return t - e
    }
    value() {
      return this.b[this.c]
    }
  },
  uut = class {
    constructor(i = !0) {
      this.e = i
    }
    reset(i) {
      return (this.b = i), (this.c = 0), (this.d = 0), this.next()
    }
    hasNext() {
      return this.d < this.b.length
    }
    next() {
      this.c = this.d
      let i = !0
      for (; this.d < this.b.length; this.d++)
        if (this.b.charCodeAt(this.d) === 46)
          if (i) this.c++
          else break
        else i = !1
      return this
    }
    cmp(i) {
      return this.e
        ? NB(i, this.b, 0, i.length, this.c, this.d)
        : Lu(i, this.b, 0, i.length, this.c, this.d)
    }
    value() {
      return this.b.substring(this.c, this.d)
    }
  },
  Oj = class {
    constructor(i = !0, t = !0) {
      ;(this.f = i), (this.g = t)
    }
    reset(i) {
      ;(this.d = 0), (this.e = 0), (this.b = i), (this.c = i.length)
      for (let t = i.length - 1; t >= 0; t--, this.c--) {
        const e = this.b.charCodeAt(t)
        if (!(e === 47 || (this.f && e === 92))) break
      }
      return this.next()
    }
    hasNext() {
      return this.e < this.c
    }
    next() {
      this.d = this.e
      let i = !0
      for (; this.e < this.c; this.e++) {
        const t = this.b.charCodeAt(this.e)
        if (t === 47 || (this.f && t === 92))
          if (i) this.d++
          else break
        else i = !1
      }
      return this
    }
    cmp(i) {
      return this.g
        ? NB(i, this.b, 0, i.length, this.d, this.e)
        : Lu(i, this.b, 0, i.length, this.d, this.e)
    }
    value() {
      return this.b.substring(this.d, this.e)
    }
  },
  qj
;(function (i) {
  ;(i[(i.Scheme = 1)] = "Scheme"),
    (i[(i.Authority = 2)] = "Authority"),
    (i[(i.Path = 3)] = "Path"),
    (i[(i.Query = 4)] = "Query"),
    (i[(i.Fragment = 5)] = "Fragment")
})(qj || (qj = {}))
var Uj = class {
    constructor(i, t) {
      ;(this.f = i), (this.g = t), (this.d = []), (this.e = 0)
    }
    reset(i) {
      return (
        (this.c = i),
        (this.d = []),
        this.c.scheme && this.d.push(1),
        this.c.authority && this.d.push(2),
        this.c.path &&
          ((this.b = new Oj(!1, !this.f(i))),
          this.b.reset(i.path),
          this.b.value() && this.d.push(3)),
        this.g(i) ||
          (this.c.query && this.d.push(4), this.c.fragment && this.d.push(5)),
        (this.e = 0),
        this
      )
    }
    next() {
      return (
        this.d[this.e] === 3 && this.b.hasNext()
          ? this.b.next()
          : (this.e += 1),
        this
      )
    }
    hasNext() {
      return (
        (this.d[this.e] === 3 && this.b.hasNext()) || this.e < this.d.length - 1
      )
    }
    cmp(i) {
      if (this.d[this.e] === 1) return FW(i, this.c.scheme)
      if (this.d[this.e] === 2) return FW(i, this.c.authority)
      if (this.d[this.e] === 3) return this.b.cmp(i)
      if (this.d[this.e] === 4) return Zs(i, this.c.query)
      if (this.d[this.e] === 5) return Zs(i, this.c.fragment)
      throw new Error()
    }
    value() {
      if (this.d[this.e] === 1) return this.c.scheme
      if (this.d[this.e] === 2) return this.c.authority
      if (this.d[this.e] === 3) return this.b.value()
      if (this.d[this.e] === 4) return this.c.query
      if (this.d[this.e] === 5) return this.c.fragment
      throw new Error()
    }
  },
  h_ = class {
    constructor() {
      this.height = 1
    }
    isEmpty() {
      return !this.left && !this.mid && !this.right && !this.value
    }
    rotateLeft() {
      const i = this.right
      return (
        (this.right = i.left),
        (i.left = this),
        this.updateHeight(),
        i.updateHeight(),
        i
      )
    }
    rotateRight() {
      const i = this.left
      return (
        (this.left = i.right),
        (i.right = this),
        this.updateHeight(),
        i.updateHeight(),
        i
      )
    }
    updateHeight() {
      this.height = 1 + Math.max(this.heightLeft, this.heightRight)
    }
    balanceFactor() {
      return this.heightRight - this.heightLeft
    }
    get heightLeft() {
      return this.left?.height ?? 0
    }
    get heightRight() {
      return this.right?.height ?? 0
    }
  },
  Mj
;(function (i) {
  ;(i[(i.Left = -1)] = "Left"),
    (i[(i.Mid = 0)] = "Mid"),
    (i[(i.Right = 1)] = "Right")
})(Mj || (Mj = {}))
var ls = class Ch {
  static forUris(t = () => !1, e = () => !1) {
    return new Ch(new Uj(t, e))
  }
  static forPaths(t = !1) {
    return new Ch(new Oj(void 0, !t))
  }
  static forStrings() {
    return new Ch(new cut())
  }
  static forConfigKeys() {
    return new Ch(new uut())
  }
  constructor(t) {
    this.b = t
  }
  clear() {
    this.c = void 0
  }
  fill(t, e) {
    if (e) {
      const r = e.slice(0)
      CH(r)
      for (const s of r) this.set(s, t)
    } else {
      const r = t.slice(0)
      CH(r)
      for (const s of r) this.set(s[0], s[1])
    }
  }
  set(t, e) {
    const r = this.b.reset(t)
    let s
    this.c || ((this.c = new h_()), (this.c.segment = r.value()))
    const a = []
    for (s = this.c; ; ) {
      const c = r.cmp(s.segment)
      if (c > 0)
        s.left || ((s.left = new h_()), (s.left.segment = r.value())),
          a.push([-1, s]),
          (s = s.left)
      else if (c < 0)
        s.right || ((s.right = new h_()), (s.right.segment = r.value())),
          a.push([1, s]),
          (s = s.right)
      else if (r.hasNext())
        r.next(),
          s.mid || ((s.mid = new h_()), (s.mid.segment = r.value())),
          a.push([0, s]),
          (s = s.mid)
      else break
    }
    const o = s.value
    ;(s.value = e), (s.key = t)
    for (let c = a.length - 1; c >= 0; c--) {
      const u = a[c][1]
      u.updateHeight()
      const l = u.balanceFactor()
      if (l < -1 || l > 1) {
        const m = a[c][0],
          h = a[c + 1][0]
        if (m === 1 && h === 1) a[c][1] = u.rotateLeft()
        else if (m === -1 && h === -1) a[c][1] = u.rotateRight()
        else if (m === 1 && h === -1)
          (u.right = a[c + 1][1] = a[c + 1][1].rotateRight()),
            (a[c][1] = u.rotateLeft())
        else if (m === -1 && h === 1)
          (u.left = a[c + 1][1] = a[c + 1][1].rotateLeft()),
            (a[c][1] = u.rotateRight())
        else throw new Error()
        if (c > 0)
          switch (a[c - 1][0]) {
            case -1:
              a[c - 1][1].left = a[c][1]
              break
            case 1:
              a[c - 1][1].right = a[c][1]
              break
            case 0:
              a[c - 1][1].mid = a[c][1]
              break
          }
        else this.c = a[0][1]
      }
    }
    return o
  }
  get(t) {
    return this.d(t)?.value
  }
  d(t) {
    const e = this.b.reset(t)
    let r = this.c
    for (; r; ) {
      const s = e.cmp(r.segment)
      if (s > 0) r = r.left
      else if (s < 0) r = r.right
      else if (e.hasNext()) e.next(), (r = r.mid)
      else break
    }
    return r
  }
  has(t) {
    const e = this.d(t)
    return !(e?.value === void 0 && e?.mid === void 0)
  }
  delete(t) {
    return this.e(t, !1)
  }
  deleteSuperstr(t) {
    return this.e(t, !0)
  }
  e(t, e) {
    const r = this.b.reset(t),
      s = []
    let a = this.c
    for (; a; ) {
      const o = r.cmp(a.segment)
      if (o > 0) s.push([-1, a]), (a = a.left)
      else if (o < 0) s.push([1, a]), (a = a.right)
      else if (r.hasNext()) r.next(), s.push([0, a]), (a = a.mid)
      else break
    }
    if (a) {
      if (
        (e
          ? ((a.left = void 0),
            (a.mid = void 0),
            (a.right = void 0),
            (a.height = 1))
          : ((a.key = void 0), (a.value = void 0)),
        !a.mid && !a.value)
      )
        if (a.left && a.right) {
          const o = this.f(a.right)
          if (o.key) {
            const { key: c, value: u, segment: l } = o
            this.e(o.key, !1), (a.key = c), (a.value = u), (a.segment = l)
          }
        } else {
          const o = a.left ?? a.right
          if (s.length > 0) {
            const [c, u] = s[s.length - 1]
            switch (c) {
              case -1:
                u.left = o
                break
              case 0:
                u.mid = o
                break
              case 1:
                u.right = o
                break
            }
          } else this.c = o
        }
      for (let o = s.length - 1; o >= 0; o--) {
        const c = s[o][1]
        c.updateHeight()
        const u = c.balanceFactor()
        if (
          (u > 1
            ? (c.right.balanceFactor() >= 0 ||
                (c.right = c.right.rotateRight()),
              (s[o][1] = c.rotateLeft()))
            : u < -1 &&
              (c.left.balanceFactor() <= 0 || (c.left = c.left.rotateLeft()),
              (s[o][1] = c.rotateRight())),
          o > 0)
        )
          switch (s[o - 1][0]) {
            case -1:
              s[o - 1][1].left = s[o][1]
              break
            case 1:
              s[o - 1][1].right = s[o][1]
              break
            case 0:
              s[o - 1][1].mid = s[o][1]
              break
          }
        else this.c = s[0][1]
      }
    }
  }
  f(t) {
    for (; t.left; ) t = t.left
    return t
  }
  findSubstr(t) {
    const e = this.b.reset(t)
    let r = this.c,
      s
    for (; r; ) {
      const a = e.cmp(r.segment)
      if (a > 0) r = r.left
      else if (a < 0) r = r.right
      else if (e.hasNext()) e.next(), (s = r.value || s), (r = r.mid)
      else break
    }
    return (r && r.value) || s
  }
  findSuperstr(t) {
    return this.g(t, !1)
  }
  g(t, e) {
    const r = this.b.reset(t)
    let s = this.c
    for (; s; ) {
      const a = r.cmp(s.segment)
      if (a > 0) s = s.left
      else if (a < 0) s = s.right
      else if (r.hasNext()) r.next(), (s = s.mid)
      else return s.mid ? this.h(s.mid) : e ? s.value : void 0
    }
  }
  hasElementOrSubtree(t) {
    return this.g(t, !0) !== void 0
  }
  forEach(t) {
    for (const [e, r] of this) t(r, e)
  }
  *[Symbol.iterator]() {
    yield* this.h(this.c)
  }
  h(t) {
    const e = []
    return this.j(t, e), e[Symbol.iterator]()
  }
  j(t, e) {
    t &&
      (t.left && this.j(t.left, e),
      t.value && e.push([t.key, t.value]),
      t.mid && this.j(t.mid, e),
      t.right && this.j(t.right, e))
  }
  _isBalanced() {
    const t = (e) => {
      if (!e) return !0
      const r = e.balanceFactor()
      return r < -1 || r > 1 ? !1 : t(e.left) && t(e.right)
    }
    return t(this.c)
  }
}
function pe(i) {
  if (!i || typeof i != "object" || i instanceof RegExp) return i
  const t = Array.isArray(i) ? [] : {}
  return (
    Object.entries(i).forEach(([e, r]) => {
      t[e] = r && typeof r == "object" ? pe(r) : r
    }),
    t
  )
}
function Hj(i) {
  if (!i || typeof i != "object") return i
  const t = [i]
  for (; t.length > 0; ) {
    const e = t.shift()
    Object.freeze(e)
    for (const r in e)
      if (Wj.call(e, r)) {
        const s = e[r]
        typeof s == "object" && !Object.isFrozen(s) && !Oot(s) && t.push(s)
      }
  }
  return i
}
var Wj = Object.prototype.hasOwnProperty
function yo(i, t) {
  return XB(i, t, new Set())
}
function XB(i, t, e) {
  if (Le(i)) return i
  const r = t(i)
  if (typeof r < "u") return r
  if (Array.isArray(i)) {
    const s = []
    for (const a of i) s.push(XB(a, t, e))
    return s
  }
  if (Ce(i)) {
    if (e.has(i)) throw new Error("Cannot clone recursive data-structure")
    e.add(i)
    const s = {}
    for (const a in i) Wj.call(i, a) && (s[a] = XB(i[a], t, e))
    return e.delete(i), s
  }
  return i
}
function ra(i, t, e = !0) {
  return Ce(i)
    ? (Ce(t) &&
        Object.keys(t).forEach((r) => {
          r in i
            ? e && (Ce(i[r]) && Ce(t[r]) ? ra(i[r], t[r], e) : (i[r] = t[r]))
            : (i[r] = t[r])
        }),
      i)
    : t
}
function Ir(i, t) {
  if (i === t) return !0
  if (
    i == null ||
    t === null ||
    t === void 0 ||
    typeof i != typeof t ||
    typeof i != "object" ||
    Array.isArray(i) !== Array.isArray(t)
  )
    return !1
  let e, r
  if (Array.isArray(i)) {
    if (i.length !== t.length) return !1
    for (e = 0; e < i.length; e++) if (!Ir(i[e], t[e])) return !1
  } else {
    const s = []
    for (r in i) s.push(r)
    s.sort()
    const a = []
    for (r in t) a.push(r)
    if ((a.sort(), !Ir(s, a))) return !1
    for (e = 0; e < s.length; e++) if (!Ir(i[s[e]], t[s[e]])) return !1
  }
  return !0
}
function lut(i) {
  const t = new Set()
  return JSON.stringify(i, (e, r) => {
    if (Ce(r) || Array.isArray(r)) {
      if (t.has(r)) return "[Circular]"
      t.add(r)
    }
    return typeof r == "bigint" ? `[BigInt ${r.toString()}]` : r
  })
}
function jj(i, t) {
  const e = Object.create(null)
  for (const [r, s] of Object.entries(i)) t(r, s) && (e[r] = s)
  return e
}
var dut = class {
    constructor() {
      this.a = 0
    }
    getNext() {
      return this.a++
    }
  },
  Wu
;(function (i) {
  ;(i[(i.Ignore = 0)] = "Ignore"),
    (i[(i.Info = 1)] = "Info"),
    (i[(i.Warning = 2)] = "Warning"),
    (i[(i.Error = 3)] = "Error"),
    (i[(i.AI = 4)] = "AI")
})(Wu || (Wu = {})),
  (function (i) {
    const t = "error",
      e = "warning",
      r = "warn",
      s = "info",
      a = "ignore"
    function o(u) {
      return u
        ? as(t, u)
          ? i.Error
          : as(e, u) || as(r, u)
            ? i.Warning
            : as(s, u)
              ? i.Info
              : i.Ignore
        : i.Ignore
    }
    i.fromValue = o
    function c(u) {
      switch (u) {
        case i.Error:
          return t
        case i.Warning:
          return e
        case i.Info:
          return s
        default:
          return a
      }
    }
    i.toString = c
  })(Wu || (Wu = {}))
var ke = Wu,
  mut = ke,
  R8t = Y("notificationService"),
  Vj
;(function (i) {
  ;(i[(i.DEFAULT = 0)] = "DEFAULT"),
    (i[(i.SILENT = 1)] = "SILENT"),
    (i[(i.URGENT = 2)] = "URGENT")
})(Vj || (Vj = {}))
var Gj
;(function (i) {
  ;(i[(i.WORKSPACE = 0)] = "WORKSPACE"),
    (i[(i.PROFILE = 1)] = "PROFILE"),
    (i[(i.APPLICATION = 2)] = "APPLICATION")
})(Gj || (Gj = {}))
var zj
;(function (i) {
  ;(i[(i.OFF = 0)] = "OFF"), (i[(i.ERROR = 1)] = "ERROR")
})(zj || (zj = {}))
var KB = Y("contextService")
function hut(i) {
  const t = i
  return typeof t?.id == "string" && S.isUri(t.uri)
}
function fut(i) {
  const t = i
  return typeof t?.id == "string" && S.isUri(t.configPath)
}
var Yj
;(function (i) {
  ;(i[(i.EMPTY = 1)] = "EMPTY"),
    (i[(i.FOLDER = 2)] = "FOLDER"),
    (i[(i.WORKSPACE = 3)] = "WORKSPACE")
})(Yj || (Yj = {}))
var put = class {
    constructor(i, t, e, r, s) {
      ;(this.h = i),
        (this.j = e),
        (this.k = r),
        (this.l = s),
        (this.c = ls.forUris(this.l, () => !0)),
        (this.folders = t)
    }
    update(i) {
      ;(this.h = i.id),
        (this.k = i.configuration),
        (this.j = i.transient),
        (this.l = i.l),
        (this.folders = i.folders)
    }
    get folders() {
      return this.g
    }
    set folders(i) {
      ;(this.g = i), this.n()
    }
    get id() {
      return this.h
    }
    get transient() {
      return this.j
    }
    get configuration() {
      return this.k
    }
    set configuration(i) {
      this.k = i
    }
    getFolder(i) {
      return (i && this.c.findSubstr(i)) || null
    }
    n() {
      this.c = ls.forUris(this.l, () => !0)
      for (const i of this.folders) this.c.set(i.uri, i)
    }
    toJSON() {
      return {
        id: this.id,
        folders: this.folders,
        transient: this.transient,
        configuration: this.configuration,
      }
    }
  },
  Qj = class {
    constructor(i, t) {
      ;(this.raw = t),
        (this.uri = i.uri),
        (this.index = i.index),
        (this.name = i.name)
    }
    toResource(i) {
      return Ti(this.uri, i)
    }
    toJSON() {
      return { uri: this.uri, name: this.name, index: this.index }
    }
  }
function ZB(i) {
  return new Qj({ uri: i, index: 0, name: LB(i) }, { uri: i.toString() })
}
var Xj = "code-workspace",
  D8t = `.${Xj}`,
  F8t = [{ name: f(2540, null), extensions: [Xj] }],
  gut = class {
    constructor() {
      ;(this.a = new Set(Object.keys(Q))),
        (this.b = new Map()),
        (this.extUri = new Du((i) => {
          const t = this.b.get(i.scheme)
          return !(t === void 0 || t & 1024)
        }))
    }
    $acceptProviderInfos(i, t) {
      t === null ? this.b.delete(i.scheme) : this.b.set(i.scheme, t)
    }
    isFreeScheme(i) {
      return !this.b.has(i) && !this.a.has(i)
    }
    getCapabilities(i) {
      return this.b.get(i)
    }
  },
  To = Y("IExtHostFileSystemInfo"),
  Ki = (function () {
    if (typeof crypto == "object" && typeof crypto.randomUUID == "function")
      return crypto.randomUUID.bind(crypto)
    let i
    typeof crypto == "object" && typeof crypto.getRandomValues == "function"
      ? (i = crypto.getRandomValues.bind(crypto))
      : (i = function (r) {
          for (let s = 0; s < r.length; s++)
            r[s] = Math.floor(Math.random() * 256)
          return r
        })
    const t = new Uint8Array(16),
      e = []
    for (let r = 0; r < 256; r++) e.push(r.toString(16).padStart(2, "0"))
    return function () {
      i(t), (t[6] = (t[6] & 15) | 64), (t[8] = (t[8] & 63) | 128)
      let s = 0,
        a = ""
      return (
        (a += e[t[s++]]),
        (a += e[t[s++]]),
        (a += e[t[s++]]),
        (a += e[t[s++]]),
        (a += "-"),
        (a += e[t[s++]]),
        (a += e[t[s++]]),
        (a += "-"),
        (a += e[t[s++]]),
        (a += e[t[s++]]),
        (a += "-"),
        (a += e[t[s++]]),
        (a += e[t[s++]]),
        (a += "-"),
        (a += e[t[s++]]),
        (a += e[t[s++]]),
        (a += e[t[s++]]),
        (a += e[t[s++]]),
        (a += e[t[s++]]),
        (a += e[t[s++]]),
        a
      )
    }
  })(),
  t3 = Object.freeze({
    create: (i) =>
      so(i.map((t) => t.toString())).join(`\r
`),
    split: (i) =>
      i.split(`\r
`),
    parse: (i) => t3.split(i).filter((t) => !t.startsWith("#")),
  }),
  _8t = new Uint32Array(10),
  Kj
;(function (i) {
  ;(i[(i.InitialConsonant = 4352)] = "InitialConsonant"),
    (i[(i.Vowel = 4449)] = "Vowel"),
    (i[(i.FinalConsonant = 4520)] = "FinalConsonant"),
    (i[(i.CompatibilityJamo = 12593)] = "CompatibilityJamo")
})(Kj || (Kj = {}))
var Zj
;(function (i) {
  ;(i[(i.NUL = 0)] = "NUL"),
    (i[(i.A = 65)] = "A"),
    (i[(i.B = 66)] = "B"),
    (i[(i.C = 67)] = "C"),
    (i[(i.D = 68)] = "D"),
    (i[(i.E = 69)] = "E"),
    (i[(i.F = 70)] = "F"),
    (i[(i.G = 71)] = "G"),
    (i[(i.H = 72)] = "H"),
    (i[(i.I = 73)] = "I"),
    (i[(i.J = 74)] = "J"),
    (i[(i.K = 75)] = "K"),
    (i[(i.L = 76)] = "L"),
    (i[(i.M = 77)] = "M"),
    (i[(i.N = 78)] = "N"),
    (i[(i.O = 79)] = "O"),
    (i[(i.P = 80)] = "P"),
    (i[(i.Q = 81)] = "Q"),
    (i[(i.R = 82)] = "R"),
    (i[(i.S = 83)] = "S"),
    (i[(i.T = 84)] = "T"),
    (i[(i.U = 85)] = "U"),
    (i[(i.V = 86)] = "V"),
    (i[(i.W = 87)] = "W"),
    (i[(i.X = 88)] = "X"),
    (i[(i.Y = 89)] = "Y"),
    (i[(i.Z = 90)] = "Z"),
    (i[(i.a = 97)] = "a"),
    (i[(i.b = 98)] = "b"),
    (i[(i.c = 99)] = "c"),
    (i[(i.d = 100)] = "d"),
    (i[(i.e = 101)] = "e"),
    (i[(i.f = 102)] = "f"),
    (i[(i.g = 103)] = "g"),
    (i[(i.h = 104)] = "h"),
    (i[(i.i = 105)] = "i"),
    (i[(i.j = 106)] = "j"),
    (i[(i.k = 107)] = "k"),
    (i[(i.l = 108)] = "l"),
    (i[(i.m = 109)] = "m"),
    (i[(i.n = 110)] = "n"),
    (i[(i.o = 111)] = "o"),
    (i[(i.p = 112)] = "p"),
    (i[(i.q = 113)] = "q"),
    (i[(i.r = 114)] = "r"),
    (i[(i.s = 115)] = "s"),
    (i[(i.t = 116)] = "t"),
    (i[(i.u = 117)] = "u"),
    (i[(i.v = 118)] = "v"),
    (i[(i.w = 119)] = "w"),
    (i[(i.x = 120)] = "x"),
    (i[(i.y = 121)] = "y"),
    (i[(i.z = 122)] = "z")
})(Zj || (Zj = {}))
var tV
;(function (i) {
  ;(i[(i.fa = 24934)] = "fa"),
    (i[(i.fg = 26470)] = "fg"),
    (i[(i.fq = 29030)] = "fq"),
    (i[(i.fr = 29286)] = "fr"),
    (i[(i.ft = 29798)] = "ft"),
    (i[(i.fv = 30310)] = "fv"),
    (i[(i.fx = 30822)] = "fx"),
    (i[(i.hk = 27496)] = "hk"),
    (i[(i.hl = 27752)] = "hl"),
    (i[(i.ho = 28520)] = "ho"),
    (i[(i.ml = 27757)] = "ml"),
    (i[(i.nj = 27246)] = "nj"),
    (i[(i.nl = 27758)] = "nl"),
    (i[(i.np = 28782)] = "np"),
    (i[(i.qt = 29809)] = "qt"),
    (i[(i.rt = 29810)] = "rt"),
    (i[(i.sg = 26483)] = "sg"),
    (i[(i.sw = 30579)] = "sw")
})(tV || (tV = {}))
var A8t = new Uint8Array([
    114, 82, 115, 101, 69, 102, 97, 113, 81, 116, 84, 100, 119, 87, 99, 122,
    120, 118, 103,
  ]),
  B8t = new Uint16Array([
    107, 111, 105, 79, 106, 112, 117, 80, 104, 27496, 28520, 27752, 121, 110,
    27246, 28782, 27758, 98, 109, 27757, 108,
  ]),
  O8t = new Uint16Array([
    114, 82, 29810, 115, 30579, 26483, 101, 102, 29286, 24934, 29030, 29798,
    30822, 30310, 26470, 97, 113, 29809, 116, 84, 100, 119, 99, 122, 120, 118,
    103,
  ]),
  q8t = new Uint16Array([
    114, 82, 29810, 115, 30579, 26483, 101, 69, 102, 29286, 24934, 29030, 29798,
    30822, 30310, 26470, 97, 113, 81, 29809, 116, 84, 100, 119, 87, 99, 122,
    120, 118, 103, 107, 111, 105, 79, 106, 112, 117, 80, 104, 27496, 28520,
    27752, 121, 110, 27246, 28782, 27758, 98, 109, 27757, 108,
  ])
function eV(...i) {
  return function (t, e) {
    for (let r = 0, s = i.length; r < s; r++) {
      const a = i[r](t, e)
      if (a) return a
    }
    return null
  }
}
var U8t = rV.bind(void 0, !1),
  iV = rV.bind(void 0, !0)
function rV(i, t, e) {
  if (!e || e.length < t.length) return null
  let r
  return (
    i ? (r = $B(e, t)) : (r = e.indexOf(t) === 0),
    r ? (t.length > 0 ? [{ start: 0, end: t.length }] : []) : null
  )
}
function vut(i, t) {
  const e = t.toLowerCase().indexOf(i.toLowerCase())
  return e === -1 ? null : [{ start: e, end: e + i.length }]
}
function wut(i, t) {
  return e3(i.toLowerCase(), t.toLowerCase(), 0, 0)
}
function e3(i, t, e, r) {
  if (e === i.length) return []
  if (r === t.length) return null
  if (i[e] === t[r]) {
    let s = null
    return (s = e3(i, t, e + 1, r + 1)) ? sV({ start: r, end: r + 1 }, s) : null
  }
  return e3(i, t, e, r + 1)
}
function i3(i) {
  return 97 <= i && i <= 122
}
function f_(i) {
  return 65 <= i && i <= 90
}
function r3(i) {
  return 48 <= i && i <= 57
}
function yut(i) {
  return i === 32 || i === 9 || i === 10 || i === 13
}
var Tut = new Set()
"()[]{}<>`'\"-/;:,.?!".split("").forEach((i) => Tut.add(i.charCodeAt(0)))
function nV(i) {
  return i3(i) || f_(i) || r3(i)
}
function sV(i, t) {
  return (
    t.length === 0
      ? (t = [i])
      : i.end === t[0].start
        ? (t[0].start = i.start)
        : t.unshift(i),
    t
  )
}
function aV(i, t) {
  for (let e = t; e < i.length; e++) {
    const r = i.charCodeAt(e)
    if (f_(r) || r3(r) || (e > 0 && !nV(i.charCodeAt(e - 1)))) return e
  }
  return i.length
}
function n3(i, t, e, r) {
  if (e === i.length) return []
  if (r === t.length) return null
  if (i[e] !== t[r].toLowerCase()) return null
  {
    let s = null,
      a = r + 1
    for (s = n3(i, t, e + 1, r + 1); !s && (a = aV(t, a)) < t.length; )
      (s = n3(i, t, e + 1, a)), a++
    return s === null ? null : sV({ start: r, end: r + 1 }, s)
  }
}
function kut(i) {
  let t = 0,
    e = 0,
    r = 0,
    s = 0,
    a = 0
  for (let m = 0; m < i.length; m++)
    (a = i.charCodeAt(m)),
      f_(a) && t++,
      i3(a) && e++,
      nV(a) && r++,
      r3(a) && s++
  const o = t / i.length,
    c = e / i.length,
    u = r / i.length,
    l = s / i.length
  return {
    upperPercent: o,
    lowerPercent: c,
    alphaPercent: u,
    numericPercent: l,
  }
}
function Sut(i) {
  const { upperPercent: t, lowerPercent: e } = i
  return e === 0 && t > 0.6
}
function but(i) {
  const {
    upperPercent: t,
    lowerPercent: e,
    alphaPercent: r,
    numericPercent: s,
  } = i
  return e > 0.2 && t < 0.8 && r > 0.6 && s < 0.2
}
function Eut(i) {
  let t = 0,
    e = 0,
    r = 0,
    s = 0
  for (let a = 0; a < i.length; a++)
    (r = i.charCodeAt(a)), f_(r) && t++, i3(r) && e++, yut(r) && s++
  return (t === 0 || e === 0) && s === 0 ? i.length <= 30 : t <= 5
}
function oV(i, t) {
  if (!t || ((t = t.trim()), t.length === 0) || !Eut(i)) return null
  t.length > 60 && (t = t.substring(0, 60))
  const e = kut(t)
  if (!but(e)) {
    if (!Sut(e)) return null
    t = t.toLowerCase()
  }
  let r = null,
    s = 0
  for (i = i.toLowerCase(); s < t.length && (r = n3(i, t, 0, s)) === null; )
    s = aV(t, s + 1)
  return r
}
var M8t = eV(iV, oV, vut),
  H8t = eV(iV, oV, wut),
  W8t = new oB(1e4),
  p_ = 128
function s3() {
  const i = [],
    t = []
  for (let e = 0; e <= p_; e++) t[e] = 0
  for (let e = 0; e <= p_; e++) i.push(t.slice(0))
  return i
}
function cV(i) {
  const t = []
  for (let e = 0; e <= i; e++) t[e] = 0
  return t
}
var j8t = cV(2 * p_),
  V8t = cV(2 * p_),
  G8t = s3(),
  z8t = s3(),
  Y8t = s3(),
  uV
;(function (i) {
  ;(i[(i.Diag = 1)] = "Diag"),
    (i[(i.Left = 2)] = "Left"),
    (i[(i.LeftLeft = 3)] = "LeftLeft")
})(uV || (uV = {}))
var lV
;(function (i) {
  i.Default = [-100, 0]
  function t(e) {
    return !e || (e.length === 2 && e[0] === -100 && e[1] === 0)
  }
  i.isDefault = t
})(lV || (lV = {}))
var Q8t = class {
    static {
      this.default = { boostFullMatch: !0, firstMatchCanBeWeak: !1 }
    }
    constructor(i, t) {
      ;(this.firstMatchCanBeWeak = i), (this.boostFullMatch = t)
    }
  },
  a3 = Object.create(null)
function v(i, t) {
  if (Bt(t)) {
    const e = a3[t]
    if (e === void 0)
      throw new Error(`${i} references an unknown codicon: ${t}`)
    t = e
  }
  return (a3[i] = t), { id: i }
}
function Iut() {
  return a3
}
var Put = {
    semantic: v("semantic", 62e3),
    githubCopilot: v("github-copilot", 62001),
    plusCircle: v("plus-circle", 62002),
    smileySad: v("smiley-sad", 62003),
    smileyHappy: v("smiley-happy", 62004),
    smileyMedium: v("smiley-medium", 62005),
    sparkleStrikethrough: v("sparkle-strikethrough", 62006),
    keyPlusSparkle: v("key-plus-sparkle", 62007),
    paperclip: v("paperclip", 60500),
    atSign: v("at-sign", 60501),
    image: v("image", 60502),
    logo: v("logo", 60503),
    sparkleTwo: v("sparkle-two", 60504),
    logoSlash: v("logo-slash", 60505),
    add: v("add", 6e4),
    plus: v("plus", 6e4),
    gistNew: v("gist-new", 6e4),
    repoCreate: v("repo-create", 6e4),
    lightbulb: v("lightbulb", 60001),
    lightBulb: v("light-bulb", 60001),
    repo: v("repo", 60002),
    repoDelete: v("repo-delete", 60002),
    gistFork: v("gist-fork", 60003),
    repoForked: v("repo-forked", 60003),
    gitPullRequest: v("git-pull-request", 60004),
    gitPullRequestAbandoned: v("git-pull-request-abandoned", 60004),
    recordKeys: v("record-keys", 60005),
    keyboard: v("keyboard", 60005),
    tag: v("tag", 60006),
    gitPullRequestLabel: v("git-pull-request-label", 60006),
    tagAdd: v("tag-add", 60006),
    tagRemove: v("tag-remove", 60006),
    person: v("person", 60007),
    personFollow: v("person-follow", 60007),
    personOutline: v("person-outline", 60007),
    personFilled: v("person-filled", 60007),
    gitBranch: v("git-branch", 60008),
    gitBranchCreate: v("git-branch-create", 60008),
    gitBranchDelete: v("git-branch-delete", 60008),
    sourceControl: v("source-control", 60008),
    mirror: v("mirror", 60009),
    mirrorPublic: v("mirror-public", 60009),
    star: v("star", 60010),
    starAdd: v("star-add", 60010),
    starDelete: v("star-delete", 60010),
    starEmpty: v("star-empty", 60010),
    comment: v("comment", 60011),
    commentAdd: v("comment-add", 60011),
    alert: v("alert", 60012),
    warning: v("warning", 60012),
    search: v("search", 60013),
    searchSave: v("search-save", 60013),
    logOut: v("log-out", 60014),
    signOut: v("sign-out", 60014),
    logIn: v("log-in", 60015),
    signIn: v("sign-in", 60015),
    eye: v("eye", 60016),
    eyeUnwatch: v("eye-unwatch", 60016),
    eyeWatch: v("eye-watch", 60016),
    circleFilled: v("circle-filled", 60017),
    primitiveDot: v("primitive-dot", 60017),
    closeDirty: v("close-dirty", 60017),
    debugBreakpoint: v("debug-breakpoint", 60017),
    debugBreakpointDisabled: v("debug-breakpoint-disabled", 60017),
    debugHint: v("debug-hint", 60017),
    terminalDecorationSuccess: v("terminal-decoration-success", 60017),
    primitiveSquare: v("primitive-square", 60018),
    edit: v("edit", 60019),
    pencil: v("pencil", 60019),
    info: v("info", 60020),
    issueOpened: v("issue-opened", 60020),
    gistPrivate: v("gist-private", 60021),
    gitForkPrivate: v("git-fork-private", 60021),
    lock: v("lock", 60021),
    mirrorPrivate: v("mirror-private", 60021),
    close: v("close", 60022),
    removeClose: v("remove-close", 60022),
    x: v("x", 60022),
    repoSync: v("repo-sync", 60023),
    sync: v("sync", 60023),
    clone: v("clone", 60024),
    desktopDownload: v("desktop-download", 60024),
    beaker: v("beaker", 60025),
    microscope: v("microscope", 60025),
    vm: v("vm", 60026),
    deviceDesktop: v("device-desktop", 60026),
    file: v("file", 60027),
    fileText: v("file-text", 60027),
    more: v("more", 60028),
    ellipsis: v("ellipsis", 60028),
    kebabHorizontal: v("kebab-horizontal", 60028),
    mailReply: v("mail-reply", 60029),
    reply: v("reply", 60029),
    organization: v("organization", 60030),
    organizationFilled: v("organization-filled", 60030),
    organizationOutline: v("organization-outline", 60030),
    newFile: v("new-file", 60031),
    fileAdd: v("file-add", 60031),
    newFolder: v("new-folder", 60032),
    fileDirectoryCreate: v("file-directory-create", 60032),
    trash: v("trash", 60033),
    trashcan: v("trashcan", 60033),
    history: v("history", 60034),
    clock: v("clock", 60034),
    folder: v("folder", 60035),
    fileDirectory: v("file-directory", 60035),
    symbolFolder: v("symbol-folder", 60035),
    logoGithub: v("logo-github", 60036),
    markGithub: v("mark-github", 60036),
    github: v("github", 60036),
    terminal: v("terminal", 60037),
    console: v("console", 60037),
    repl: v("repl", 60037),
    zap: v("zap", 60038),
    symbolEvent: v("symbol-event", 60038),
    error: v("error", 60039),
    stop: v("stop", 60039),
    variable: v("variable", 60040),
    symbolVariable: v("symbol-variable", 60040),
    array: v("array", 60042),
    symbolArray: v("symbol-array", 60042),
    symbolModule: v("symbol-module", 60043),
    symbolPackage: v("symbol-package", 60043),
    symbolNamespace: v("symbol-namespace", 60043),
    symbolObject: v("symbol-object", 60043),
    symbolMethod: v("symbol-method", 60044),
    symbolFunction: v("symbol-function", 60044),
    symbolConstructor: v("symbol-constructor", 60044),
    symbolBoolean: v("symbol-boolean", 60047),
    symbolNull: v("symbol-null", 60047),
    symbolNumeric: v("symbol-numeric", 60048),
    symbolNumber: v("symbol-number", 60048),
    symbolStructure: v("symbol-structure", 60049),
    symbolStruct: v("symbol-struct", 60049),
    symbolParameter: v("symbol-parameter", 60050),
    symbolTypeParameter: v("symbol-type-parameter", 60050),
    symbolKey: v("symbol-key", 60051),
    symbolText: v("symbol-text", 60051),
    symbolReference: v("symbol-reference", 60052),
    goToFile: v("go-to-file", 60052),
    symbolEnum: v("symbol-enum", 60053),
    symbolValue: v("symbol-value", 60053),
    symbolRuler: v("symbol-ruler", 60054),
    symbolUnit: v("symbol-unit", 60054),
    activateBreakpoints: v("activate-breakpoints", 60055),
    archive: v("archive", 60056),
    arrowBoth: v("arrow-both", 60057),
    arrowDown: v("arrow-down", 60058),
    arrowLeft: v("arrow-left", 60059),
    arrowRight: v("arrow-right", 60060),
    arrowSmallDown: v("arrow-small-down", 60061),
    arrowSmallLeft: v("arrow-small-left", 60062),
    arrowSmallRight: v("arrow-small-right", 60063),
    arrowSmallUp: v("arrow-small-up", 60064),
    arrowUp: v("arrow-up", 60065),
    bell: v("bell", 60066),
    bold: v("bold", 60067),
    book: v("book", 60068),
    bookmark: v("bookmark", 60069),
    debugBreakpointConditionalUnverified: v(
      "debug-breakpoint-conditional-unverified",
      60070,
    ),
    debugBreakpointConditional: v("debug-breakpoint-conditional", 60071),
    debugBreakpointConditionalDisabled: v(
      "debug-breakpoint-conditional-disabled",
      60071,
    ),
    debugBreakpointDataUnverified: v("debug-breakpoint-data-unverified", 60072),
    debugBreakpointData: v("debug-breakpoint-data", 60073),
    debugBreakpointDataDisabled: v("debug-breakpoint-data-disabled", 60073),
    debugBreakpointLogUnverified: v("debug-breakpoint-log-unverified", 60074),
    debugBreakpointLog: v("debug-breakpoint-log", 60075),
    debugBreakpointLogDisabled: v("debug-breakpoint-log-disabled", 60075),
    briefcase: v("briefcase", 60076),
    broadcast: v("broadcast", 60077),
    browser: v("browser", 60078),
    bug: v("bug", 60079),
    calendar: v("calendar", 60080),
    caseSensitive: v("case-sensitive", 60081),
    check: v("check", 60082),
    checklist: v("checklist", 60083),
    chevronDown: v("chevron-down", 60084),
    chevronLeft: v("chevron-left", 60085),
    chevronRight: v("chevron-right", 60086),
    chevronUp: v("chevron-up", 60087),
    chromeClose: v("chrome-close", 60088),
    chromeMaximize: v("chrome-maximize", 60089),
    chromeMinimize: v("chrome-minimize", 60090),
    chromeRestore: v("chrome-restore", 60091),
    circleOutline: v("circle-outline", 60092),
    circle: v("circle", 60092),
    debugBreakpointUnverified: v("debug-breakpoint-unverified", 60092),
    terminalDecorationIncomplete: v("terminal-decoration-incomplete", 60092),
    circleSlash: v("circle-slash", 60093),
    circuitBoard: v("circuit-board", 60094),
    clearAll: v("clear-all", 60095),
    clippy: v("clippy", 60096),
    closeAll: v("close-all", 60097),
    cloudDownload: v("cloud-download", 60098),
    cloudUpload: v("cloud-upload", 60099),
    code: v("code", 60100),
    collapseAll: v("collapse-all", 60101),
    colorMode: v("color-mode", 60102),
    commentDiscussion: v("comment-discussion", 60103),
    creditCard: v("credit-card", 60105),
    dash: v("dash", 60108),
    dashboard: v("dashboard", 60109),
    database: v("database", 60110),
    debugContinue: v("debug-continue", 60111),
    debugDisconnect: v("debug-disconnect", 60112),
    debugPause: v("debug-pause", 60113),
    debugRestart: v("debug-restart", 60114),
    debugStart: v("debug-start", 60115),
    debugStepInto: v("debug-step-into", 60116),
    debugStepOut: v("debug-step-out", 60117),
    debugStepOver: v("debug-step-over", 60118),
    debugStop: v("debug-stop", 60119),
    debug: v("debug", 60120),
    deviceCameraVideo: v("device-camera-video", 60121),
    deviceCamera: v("device-camera", 60122),
    deviceMobile: v("device-mobile", 60123),
    diffAdded: v("diff-added", 60124),
    diffIgnored: v("diff-ignored", 60125),
    diffModified: v("diff-modified", 60126),
    diffRemoved: v("diff-removed", 60127),
    diffRenamed: v("diff-renamed", 60128),
    diff: v("diff", 60129),
    diffSidebyside: v("diff-sidebyside", 60129),
    discard: v("discard", 60130),
    editorLayout: v("editor-layout", 60131),
    emptyWindow: v("empty-window", 60132),
    exclude: v("exclude", 60133),
    extensions: v("extensions", 60134),
    eyeClosed: v("eye-closed", 60135),
    fileBinary: v("file-binary", 60136),
    fileCode: v("file-code", 60137),
    fileMedia: v("file-media", 60138),
    filePdf: v("file-pdf", 60139),
    fileSubmodule: v("file-submodule", 60140),
    fileSymlinkDirectory: v("file-symlink-directory", 60141),
    fileSymlinkFile: v("file-symlink-file", 60142),
    fileZip: v("file-zip", 60143),
    files: v("files", 60144),
    filter: v("filter", 60145),
    flame: v("flame", 60146),
    foldDown: v("fold-down", 60147),
    foldUp: v("fold-up", 60148),
    fold: v("fold", 60149),
    folderActive: v("folder-active", 60150),
    folderOpened: v("folder-opened", 60151),
    gear: v("gear", 60152),
    gift: v("gift", 60153),
    gistSecret: v("gist-secret", 60154),
    gist: v("gist", 60155),
    gitCommit: v("git-commit", 60156),
    gitCompare: v("git-compare", 60157),
    compareChanges: v("compare-changes", 60157),
    gitMerge: v("git-merge", 60158),
    githubAction: v("github-action", 60159),
    githubAlt: v("github-alt", 60160),
    globe: v("globe", 60161),
    grabber: v("grabber", 60162),
    graph: v("graph", 60163),
    gripper: v("gripper", 60164),
    heart: v("heart", 60165),
    home: v("home", 60166),
    horizontalRule: v("horizontal-rule", 60167),
    hubot: v("hubot", 60168),
    inbox: v("inbox", 60169),
    issueReopened: v("issue-reopened", 60171),
    issues: v("issues", 60172),
    italic: v("italic", 60173),
    jersey: v("jersey", 60174),
    json: v("json", 60175),
    kebabVertical: v("kebab-vertical", 60176),
    key: v("key", 60177),
    law: v("law", 60178),
    lightbulbAutofix: v("lightbulb-autofix", 60179),
    linkExternal: v("link-external", 60180),
    link: v("link", 60181),
    listOrdered: v("list-ordered", 60182),
    listUnordered: v("list-unordered", 60183),
    liveShare: v("live-share", 60184),
    loading: v("loading", 60185),
    location: v("location", 60186),
    mailRead: v("mail-read", 60187),
    mail: v("mail", 60188),
    markdown: v("markdown", 60189),
    megaphone: v("megaphone", 60190),
    mention: v("mention", 60191),
    milestone: v("milestone", 60192),
    gitPullRequestMilestone: v("git-pull-request-milestone", 60192),
    mortarBoard: v("mortar-board", 60193),
    move: v("move", 60194),
    multipleWindows: v("multiple-windows", 60195),
    mute: v("mute", 60196),
    noNewline: v("no-newline", 60197),
    note: v("note", 60198),
    octoface: v("octoface", 60199),
    openPreview: v("open-preview", 60200),
    package: v("package", 60201),
    paintcan: v("paintcan", 60202),
    pin: v("pin", 60203),
    play: v("play", 60204),
    run: v("run", 60204),
    plug: v("plug", 60205),
    preserveCase: v("preserve-case", 60206),
    preview: v("preview", 60207),
    project: v("project", 60208),
    pulse: v("pulse", 60209),
    question: v("question", 60210),
    quote: v("quote", 60211),
    radioTower: v("radio-tower", 60212),
    reactions: v("reactions", 60213),
    references: v("references", 60214),
    refresh: v("refresh", 60215),
    regex: v("regex", 60216),
    remoteExplorer: v("remote-explorer", 60217),
    remote: v("remote", 60218),
    remove: v("remove", 60219),
    replaceAll: v("replace-all", 60220),
    replace: v("replace", 60221),
    repoClone: v("repo-clone", 60222),
    repoForcePush: v("repo-force-push", 60223),
    repoPull: v("repo-pull", 60224),
    repoPush: v("repo-push", 60225),
    report: v("report", 60226),
    requestChanges: v("request-changes", 60227),
    rocket: v("rocket", 60228),
    rootFolderOpened: v("root-folder-opened", 60229),
    rootFolder: v("root-folder", 60230),
    rss: v("rss", 60231),
    ruby: v("ruby", 60232),
    saveAll: v("save-all", 60233),
    saveAs: v("save-as", 60234),
    save: v("save", 60235),
    screenFull: v("screen-full", 60236),
    screenNormal: v("screen-normal", 60237),
    searchStop: v("search-stop", 60238),
    server: v("server", 60240),
    settingsGear: v("settings-gear", 60241),
    settings: v("settings", 60242),
    shield: v("shield", 60243),
    smiley: v("smiley", 60244),
    sortPrecedence: v("sort-precedence", 60245),
    splitHorizontal: v("split-horizontal", 60246),
    splitVertical: v("split-vertical", 60247),
    squirrel: v("squirrel", 60248),
    starFull: v("star-full", 60249),
    starHalf: v("star-half", 60250),
    symbolClass: v("symbol-class", 60251),
    symbolColor: v("symbol-color", 60252),
    symbolConstant: v("symbol-constant", 60253),
    symbolEnumMember: v("symbol-enum-member", 60254),
    symbolField: v("symbol-field", 60255),
    symbolFile: v("symbol-file", 60256),
    symbolInterface: v("symbol-interface", 60257),
    symbolKeyword: v("symbol-keyword", 60258),
    symbolMisc: v("symbol-misc", 60259),
    symbolOperator: v("symbol-operator", 60260),
    symbolProperty: v("symbol-property", 60261),
    wrench: v("wrench", 60261),
    wrenchSubaction: v("wrench-subaction", 60261),
    symbolSnippet: v("symbol-snippet", 60262),
    tasklist: v("tasklist", 60263),
    telescope: v("telescope", 60264),
    textSize: v("text-size", 60265),
    threeBars: v("three-bars", 60266),
    thumbsdown: v("thumbsdown", 60267),
    thumbsup: v("thumbsup", 60268),
    tools: v("tools", 60269),
    triangleDown: v("triangle-down", 60270),
    triangleLeft: v("triangle-left", 60271),
    triangleRight: v("triangle-right", 60272),
    triangleUp: v("triangle-up", 60273),
    twitter: v("twitter", 60274),
    unfold: v("unfold", 60275),
    unlock: v("unlock", 60276),
    unmute: v("unmute", 60277),
    unverified: v("unverified", 60278),
    verified: v("verified", 60279),
    versions: v("versions", 60280),
    vmActive: v("vm-active", 60281),
    vmOutline: v("vm-outline", 60282),
    vmRunning: v("vm-running", 60283),
    watch: v("watch", 60284),
    whitespace: v("whitespace", 60285),
    wholeWord: v("whole-word", 60286),
    window: v("window", 60287),
    wordWrap: v("word-wrap", 60288),
    zoomIn: v("zoom-in", 60289),
    zoomOut: v("zoom-out", 60290),
    listFilter: v("list-filter", 60291),
    listFlat: v("list-flat", 60292),
    listSelection: v("list-selection", 60293),
    selection: v("selection", 60293),
    listTree: v("list-tree", 60294),
    debugBreakpointFunctionUnverified: v(
      "debug-breakpoint-function-unverified",
      60295,
    ),
    debugBreakpointFunction: v("debug-breakpoint-function", 60296),
    debugBreakpointFunctionDisabled: v(
      "debug-breakpoint-function-disabled",
      60296,
    ),
    debugStackframeActive: v("debug-stackframe-active", 60297),
    circleSmallFilled: v("circle-small-filled", 60298),
    debugStackframeDot: v("debug-stackframe-dot", 60298),
    terminalDecorationMark: v("terminal-decoration-mark", 60298),
    debugStackframe: v("debug-stackframe", 60299),
    debugStackframeFocused: v("debug-stackframe-focused", 60299),
    debugBreakpointUnsupported: v("debug-breakpoint-unsupported", 60300),
    symbolString: v("symbol-string", 60301),
    debugReverseContinue: v("debug-reverse-continue", 60302),
    debugStepBack: v("debug-step-back", 60303),
    debugRestartFrame: v("debug-restart-frame", 60304),
    debugAlt: v("debug-alt", 60305),
    callIncoming: v("call-incoming", 60306),
    callOutgoing: v("call-outgoing", 60307),
    menu: v("menu", 60308),
    expandAll: v("expand-all", 60309),
    feedback: v("feedback", 60310),
    gitPullRequestReviewer: v("git-pull-request-reviewer", 60310),
    groupByRefType: v("group-by-ref-type", 60311),
    ungroupByRefType: v("ungroup-by-ref-type", 60312),
    account: v("account", 60313),
    gitPullRequestAssignee: v("git-pull-request-assignee", 60313),
    bellDot: v("bell-dot", 60314),
    debugConsole: v("debug-console", 60315),
    library: v("library", 60316),
    output: v("output", 60317),
    runAll: v("run-all", 60318),
    syncIgnored: v("sync-ignored", 60319),
    pinned: v("pinned", 60320),
    githubInverted: v("github-inverted", 60321),
    serverProcess: v("server-process", 60322),
    serverEnvironment: v("server-environment", 60323),
    pass: v("pass", 60324),
    issueClosed: v("issue-closed", 60324),
    stopCircle: v("stop-circle", 60325),
    playCircle: v("play-circle", 60326),
    record: v("record", 60327),
    debugAltSmall: v("debug-alt-small", 60328),
    vmConnect: v("vm-connect", 60329),
    cloud: v("cloud", 60330),
    merge: v("merge", 60331),
    export: v("export", 60332),
    graphLeft: v("graph-left", 60333),
    magnet: v("magnet", 60334),
    notebook: v("notebook", 60335),
    redo: v("redo", 60336),
    checkAll: v("check-all", 60337),
    pinnedDirty: v("pinned-dirty", 60338),
    passFilled: v("pass-filled", 60339),
    circleLargeFilled: v("circle-large-filled", 60340),
    circleLarge: v("circle-large", 60341),
    circleLargeOutline: v("circle-large-outline", 60341),
    combine: v("combine", 60342),
    gather: v("gather", 60342),
    table: v("table", 60343),
    variableGroup: v("variable-group", 60344),
    typeHierarchy: v("type-hierarchy", 60345),
    typeHierarchySub: v("type-hierarchy-sub", 60346),
    typeHierarchySuper: v("type-hierarchy-super", 60347),
    gitPullRequestCreate: v("git-pull-request-create", 60348),
    runAbove: v("run-above", 60349),
    runBelow: v("run-below", 60350),
    notebookTemplate: v("notebook-template", 60351),
    debugRerun: v("debug-rerun", 60352),
    workspaceTrusted: v("workspace-trusted", 60353),
    workspaceUntrusted: v("workspace-untrusted", 60354),
    workspaceUnknown: v("workspace-unknown", 60355),
    terminalCmd: v("terminal-cmd", 60356),
    terminalDebian: v("terminal-debian", 60357),
    terminalLinux: v("terminal-linux", 60358),
    terminalPowershell: v("terminal-powershell", 60359),
    terminalTmux: v("terminal-tmux", 60360),
    terminalUbuntu: v("terminal-ubuntu", 60361),
    terminalBash: v("terminal-bash", 60362),
    arrowSwap: v("arrow-swap", 60363),
    copy: v("copy", 60364),
    personAdd: v("person-add", 60365),
    filterFilled: v("filter-filled", 60366),
    wand: v("wand", 60367),
    debugLineByLine: v("debug-line-by-line", 60368),
    inspect: v("inspect", 60369),
    layers: v("layers", 60370),
    layersDot: v("layers-dot", 60371),
    layersActive: v("layers-active", 60372),
    compass: v("compass", 60373),
    compassDot: v("compass-dot", 60374),
    compassActive: v("compass-active", 60375),
    azure: v("azure", 60376),
    issueDraft: v("issue-draft", 60377),
    gitPullRequestClosed: v("git-pull-request-closed", 60378),
    gitPullRequestDraft: v("git-pull-request-draft", 60379),
    debugAll: v("debug-all", 60380),
    debugCoverage: v("debug-coverage", 60381),
    runErrors: v("run-errors", 60382),
    folderLibrary: v("folder-library", 60383),
    debugContinueSmall: v("debug-continue-small", 60384),
    beakerStop: v("beaker-stop", 60385),
    graphLine: v("graph-line", 60386),
    graphScatter: v("graph-scatter", 60387),
    pieChart: v("pie-chart", 60388),
    bracket: v("bracket", 60175),
    bracketDot: v("bracket-dot", 60389),
    bracketError: v("bracket-error", 60390),
    lockSmall: v("lock-small", 60391),
    azureDevops: v("azure-devops", 60392),
    verifiedFilled: v("verified-filled", 60393),
    newline: v("newline", 60394),
    layout: v("layout", 60395),
    layoutActivitybarLeft: v("layout-activitybar-left", 60396),
    layoutActivitybarRight: v("layout-activitybar-right", 60397),
    layoutPanelLeft: v("layout-panel-left", 60398),
    layoutPanelCenter: v("layout-panel-center", 60399),
    layoutPanelJustify: v("layout-panel-justify", 60400),
    layoutPanelRight: v("layout-panel-right", 60401),
    layoutPanel: v("layout-panel", 60402),
    layoutSidebarLeft: v("layout-sidebar-left", 60403),
    layoutSidebarRight: v("layout-sidebar-right", 60404),
    layoutStatusbar: v("layout-statusbar", 60405),
    layoutMenubar: v("layout-menubar", 60406),
    layoutCentered: v("layout-centered", 60407),
    target: v("target", 60408),
    indent: v("indent", 60409),
    recordSmall: v("record-small", 60410),
    errorSmall: v("error-small", 60411),
    terminalDecorationError: v("terminal-decoration-error", 60411),
    arrowCircleDown: v("arrow-circle-down", 60412),
    arrowCircleLeft: v("arrow-circle-left", 60413),
    arrowCircleRight: v("arrow-circle-right", 60414),
    arrowCircleUp: v("arrow-circle-up", 60415),
    layoutSidebarRightOff: v("layout-sidebar-right-off", 60416),
    layoutPanelOff: v("layout-panel-off", 60417),
    layoutSidebarLeftOff: v("layout-sidebar-left-off", 60418),
    blank: v("blank", 60419),
    heartFilled: v("heart-filled", 60420),
    map: v("map", 60421),
    mapHorizontal: v("map-horizontal", 60421),
    foldHorizontal: v("fold-horizontal", 60421),
    mapFilled: v("map-filled", 60422),
    mapHorizontalFilled: v("map-horizontal-filled", 60422),
    foldHorizontalFilled: v("fold-horizontal-filled", 60422),
    circleSmall: v("circle-small", 60423),
    bellSlash: v("bell-slash", 60424),
    bellSlashDot: v("bell-slash-dot", 60425),
    commentUnresolved: v("comment-unresolved", 60426),
    gitPullRequestGoToChanges: v("git-pull-request-go-to-changes", 60427),
    gitPullRequestNewChanges: v("git-pull-request-new-changes", 60428),
    searchFuzzy: v("search-fuzzy", 60429),
    commentDraft: v("comment-draft", 60430),
    send: v("send", 60431),
    sparkle: v("sparkle", 60432),
    insert: v("insert", 60433),
    mic: v("mic", 60434),
    thumbsdownFilled: v("thumbsdown-filled", 60435),
    thumbsupFilled: v("thumbsup-filled", 60436),
    coffee: v("coffee", 60437),
    snake: v("snake", 60438),
    game: v("game", 60439),
    vr: v("vr", 60440),
    chip: v("chip", 60441),
    piano: v("piano", 60442),
    music: v("music", 60443),
    micFilled: v("mic-filled", 60444),
    repoFetch: v("repo-fetch", 60445),
    copilot: v("copilot", 60446),
    lightbulbSparkle: v("lightbulb-sparkle", 60447),
    robot: v("robot", 60448),
    sparkleFilled: v("sparkle-filled", 60449),
    diffSingle: v("diff-single", 60450),
    diffMultiple: v("diff-multiple", 60451),
    surroundWith: v("surround-with", 60452),
    share: v("share", 60453),
    gitStash: v("git-stash", 60454),
    gitStashApply: v("git-stash-apply", 60455),
    gitStashPop: v("git-stash-pop", 60456),
    vscode: v("vscode", 60457),
    vscodeInsiders: v("vscode-insiders", 60458),
    codeOss: v("code-oss", 60459),
    runCoverage: v("run-coverage", 60460),
    runAllCoverage: v("run-all-coverage", 60461),
    coverage: v("coverage", 60462),
    githubProject: v("github-project", 60463),
    mapVertical: v("map-vertical", 60464),
    foldVertical: v("fold-vertical", 60464),
    mapVerticalFilled: v("map-vertical-filled", 60465),
    foldVerticalFilled: v("fold-vertical-filled", 60465),
    goToSearch: v("go-to-search", 60466),
    percentage: v("percentage", 60467),
    sortPercentage: v("sort-percentage", 60467),
    attach: v("attach", 60468),
    goToEditingSession: v("go-to-editing-session", 60469),
    editSession: v("edit-session", 60470),
    codeReview: v("code-review", 60471),
    copilotWarning: v("copilot-warning", 60472),
    python: v("python", 60473),
    copilotLarge: v("copilot-large", 60474),
    copilotWarningLarge: v("copilot-warning-large", 60475),
  },
  Nut = {
    dialogError: v("dialog-error", "error"),
    dialogWarning: v("dialog-warning", "warning"),
    dialogInfo: v("dialog-info", "info"),
    dialogClose: v("dialog-close", "close"),
    treeItemExpanded: v("tree-item-expanded", "chevron-down"),
    treeFilterOnTypeOn: v("tree-filter-on-type-on", "list-filter"),
    treeFilterOnTypeOff: v("tree-filter-on-type-off", "list-selection"),
    treeFilterClear: v("tree-filter-clear", "close"),
    treeItemLoading: v("tree-item-loading", "loading"),
    menuSelection: v("menu-selection", "check"),
    menuSubmenu: v("menu-submenu", "chevron-right"),
    menuBarMore: v("menubar-more", "more"),
    scrollbarButtonLeft: v("scrollbar-button-left", "triangle-left"),
    scrollbarButtonRight: v("scrollbar-button-right", "triangle-right"),
    scrollbarButtonUp: v("scrollbar-button-up", "triangle-up"),
    scrollbarButtonDown: v("scrollbar-button-down", "triangle-down"),
    toolBarMore: v("toolbar-more", "more"),
    quickInputBack: v("quick-input-back", "arrow-left"),
    dropDownButton: v("drop-down-button", 60084),
    symbolCustomColor: v("symbol-customcolor", 60252),
    exportIcon: v("export", 60332),
    workspaceUnspecified: v("workspace-unspecified", 60355),
    newLine: v("newline", 60394),
    thumbsDownFilled: v("thumbsdown-filled", 60435),
    thumbsUpFilled: v("thumbsup-filled", 60436),
    gitFetch: v("git-fetch", 60445),
    lightbulbSparkleAutofix: v("lightbulb-sparkle-autofix", 60447),
    debugBreakpointPending: v("debug-breakpoint-pending", 60377),
  },
  ut = { ...Put, ...Nut },
  ko
;(function (i) {
  function t(e) {
    return e && typeof e == "object" && typeof e.id == "string"
  }
  i.isThemeColor = t
})(ko || (ko = {}))
var ri
;(function (i) {
  ;(i.iconNameSegment = "[A-Za-z0-9]+"),
    (i.iconNameExpression = "[A-Za-z0-9-]+"),
    (i.iconModifierExpression = "~[A-Za-z]+"),
    (i.iconNameCharacter = "[A-Za-z0-9~-]")
  const t = new RegExp(
    `^(${i.iconNameExpression})(${i.iconModifierExpression})?$`,
  )
  function e(p) {
    const g = t.exec(p.id)
    if (!g) return e(ut.error)
    const [, w, T] = g,
      b = ["codicon", "codicon-" + w]
    return T && b.push("codicon-modifier-" + T.substring(1)), b
  }
  i.asClassNameArray = e
  function r(p) {
    return e(p).join(" ")
  }
  i.asClassName = r
  function s(p) {
    return "." + e(p).join(".")
  }
  i.asCSSSelector = s
  function a(p) {
    return (
      p &&
      typeof p == "object" &&
      typeof p.id == "string" &&
      (typeof p.color > "u" || ko.isThemeColor(p.color))
    )
  }
  i.isThemeIcon = a
  const o = new RegExp(
    `^\\$\\((${i.iconNameExpression}(?:${i.iconModifierExpression})?)\\)$`,
  )
  function c(p) {
    const g = o.exec(p)
    if (!g) return
    const [, w] = g
    return { id: w }
  }
  i.fromString = c
  function u(p) {
    return { id: p }
  }
  i.fromId = u
  function l(p, g) {
    let w = p.id
    const T = w.lastIndexOf("~")
    return (
      T !== -1 && (w = w.substring(0, T)), g && (w = `${w}~${g}`), { id: w }
    )
  }
  i.modify = l
  function m(p) {
    const g = p.id.lastIndexOf("~")
    if (g !== -1) return p.id.substring(g + 1)
  }
  i.getModifier = m
  function h(p, g) {
    return p.id === g.id && p.color?.id === g.color?.id
  }
  i.isEqual = h
})(ri || (ri = {}))
var o3 = new RegExp(
    `\\$\\(${ri.iconNameExpression}(?:${ri.iconModifierExpression})?\\)`,
    "g",
  ),
  $ut = new RegExp(`(\\\\)?${o3.source}`, "g")
function xut(i) {
  return i.replace($ut, (t, e) => (e ? t : `\\${t}`))
}
var X8t = new RegExp(`\\\\${o3.source}`, "g"),
  K8t = new RegExp(`(\\s)?(\\\\)?${o3.source}(\\s)?`, "g"),
  Z8t = new RegExp(`\\$\\(${ri.iconNameCharacter}+\\)`, "g"),
  dV
;(function (i) {
  ;(i[(i.Paragraph = 0)] = "Paragraph"), (i[(i.Break = 1)] = "Break")
})(dV || (dV = {}))
var mV = class {
  constructor(i = "", t = !1) {
    if (((this.value = i), typeof this.value != "string")) throw xt("value")
    typeof t == "boolean"
      ? ((this.isTrusted = t),
        (this.supportThemeIcons = !1),
        (this.supportHtml = !1))
      : ((this.isTrusted = t.isTrusted ?? void 0),
        (this.supportThemeIcons = t.supportThemeIcons ?? !1),
        (this.supportHtml = t.supportHtml ?? !1))
  }
  appendText(i, t = 0) {
    return (
      (this.value += Jut(this.supportThemeIcons ? xut(i) : i)
        .replace(/([ \t]+)/g, (e, r) => "&nbsp;".repeat(r.length))
        .replace(/\>/gm, "\\>")
        .replace(
          /\n/g,
          t === 1
            ? `\\
`
            : `

`,
        )),
      this
    )
  }
  appendMarkdown(i) {
    return (this.value += i), this
  }
  appendCodeblock(i, t) {
    return (
      (this.value += `
${Cut(t, i)}
`),
      this
    )
  }
  appendLink(i, t, e) {
    return (
      (this.value += "["),
      (this.value += this.c(t, "]")),
      (this.value += "]("),
      (this.value += this.c(String(i), ")")),
      e && (this.value += ` "${this.c(this.c(e, '"'), ")")}"`),
      (this.value += ")"),
      this
    )
  }
  c(i, t) {
    const e = new RegExp(Ks(t), "g")
    return i.replace(e, (r, s) => (i.charAt(s - 1) !== "\\" ? `\\${r}` : r))
  }
}
function na(i) {
  return i instanceof mV
    ? !0
    : i && typeof i == "object"
      ? typeof i.value == "string" &&
        (typeof i.isTrusted == "boolean" ||
          typeof i.isTrusted == "object" ||
          i.isTrusted === void 0) &&
        (typeof i.supportThemeIcons == "boolean" ||
          i.supportThemeIcons === void 0)
      : !1
}
function Jut(i) {
  return i.replace(/[\\`*_{}[\]()#+\-!~]/g, "\\$&")
}
function Cut(i, t) {
  const e =
      i.match(/^`+/gm)?.reduce((s, a) => (s.length > a.length ? s : a))
        .length ?? 0,
    r = e >= 3 ? e + 1 : 3
  return [`${"`".repeat(r)}${t}`, i, `${"`".repeat(r)}`].join(`
`)
}
function Lut(i) {
  const t = [],
    e = i.split("|").map((s) => s.trim())
  i = e[0]
  const r = e[1]
  if (r) {
    const s = /height=(\d+)/.exec(r),
      a = /width=(\d+)/.exec(r),
      o = s ? s[1] : "",
      c = a ? a[1] : "",
      u = isFinite(parseInt(c)),
      l = isFinite(parseInt(o))
    u && t.push(`width="${c}"`), l && t.push(`height="${o}"`)
  }
  return { href: i, dimensions: t }
}
function c3() {
  return {
    async: !1,
    breaks: !1,
    extensions: null,
    gfm: !0,
    hooks: null,
    pedantic: !1,
    renderer: null,
    silent: !1,
    tokenizer: null,
    walkTokens: null,
  }
}
var sa = c3()
function hV(i) {
  sa = i
}
var fV = /[&<>"']/,
  Rut = new RegExp(fV.source, "g"),
  pV = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
  Dut = new RegExp(pV.source, "g"),
  Fut = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" },
  gV = (i) => Fut[i]
function Zi(i, t) {
  if (t) {
    if (fV.test(i)) return i.replace(Rut, gV)
  } else if (pV.test(i)) return i.replace(Dut, gV)
  return i
}
var _ut = /(^|[^\[])\^/g
function de(i, t) {
  let e = typeof i == "string" ? i : i.source
  t = t || ""
  const r = {
    replace: (s, a) => {
      let o = typeof a == "string" ? a : a.source
      return (o = o.replace(_ut, "$1")), (e = e.replace(s, o)), r
    },
    getRegex: () => new RegExp(e, t),
  }
  return r
}
function vV(i) {
  try {
    i = encodeURI(i).replace(/%25/g, "%")
  } catch {
    return null
  }
  return i
}
var ju = { exec: () => null }
function wV(i, t) {
  const e = i.replace(/\|/g, (a, o, c) => {
      let u = !1,
        l = o
      for (; --l >= 0 && c[l] === "\\"; ) u = !u
      return u ? "|" : " |"
    }),
    r = e.split(/ \|/)
  let s = 0
  if (
    (r[0].trim() || r.shift(),
    r.length > 0 && !r[r.length - 1].trim() && r.pop(),
    t)
  )
    if (r.length > t) r.splice(t)
    else for (; r.length < t; ) r.push("")
  for (; s < r.length; s++) r[s] = r[s].trim().replace(/\\\|/g, "|")
  return r
}
function Vu(i, t, e) {
  const r = i.length
  if (r === 0) return ""
  let s = 0
  for (; s < r; ) {
    const a = i.charAt(r - s - 1)
    if (a === t && !e) s++
    else if (a !== t && e) s++
    else break
  }
  return i.slice(0, r - s)
}
function Aut(i, t) {
  if (i.indexOf(t[1]) === -1) return -1
  let e = 0
  for (let r = 0; r < i.length; r++)
    if (i[r] === "\\") r++
    else if (i[r] === t[0]) e++
    else if (i[r] === t[1] && (e--, e < 0)) return r
  return -1
}
function yV(i, t, e, r) {
  const s = t.href,
    a = t.title ? Zi(t.title) : null,
    o = i[1].replace(/\\([\[\]])/g, "$1")
  if (i[0].charAt(0) !== "!") {
    r.state.inLink = !0
    const c = {
      type: "link",
      raw: e,
      href: s,
      title: a,
      text: o,
      tokens: r.inlineTokens(o),
    }
    return (r.state.inLink = !1), c
  }
  return { type: "image", raw: e, href: s, title: a, text: Zi(o) }
}
function But(i, t) {
  const e = i.match(/^(\s+)(?:```)/)
  if (e === null) return t
  const r = e[1]
  return t
    .split(
      `
`,
    )
    .map((s) => {
      const a = s.match(/^\s+/)
      if (a === null) return s
      const [o] = a
      return o.length >= r.length ? s.slice(r.length) : s
    }).join(`
`)
}
var g_ = class {
    options
    rules
    lexer
    constructor(i) {
      this.options = i || sa
    }
    space(i) {
      const t = this.rules.block.newline.exec(i)
      if (t && t[0].length > 0) return { type: "space", raw: t[0] }
    }
    code(i) {
      const t = this.rules.block.code.exec(i)
      if (t) {
        const e = t[0].replace(/^ {1,4}/gm, "")
        return {
          type: "code",
          raw: t[0],
          codeBlockStyle: "indented",
          text: this.options.pedantic
            ? e
            : Vu(
                e,
                `
`,
              ),
        }
      }
    }
    fences(i) {
      const t = this.rules.block.fences.exec(i)
      if (t) {
        const e = t[0],
          r = But(e, t[3] || "")
        return {
          type: "code",
          raw: e,
          lang: t[2]
            ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1")
            : t[2],
          text: r,
        }
      }
    }
    heading(i) {
      const t = this.rules.block.heading.exec(i)
      if (t) {
        let e = t[2].trim()
        if (/#$/.test(e)) {
          const r = Vu(e, "#")
          ;(this.options.pedantic || !r || / $/.test(r)) && (e = r.trim())
        }
        return {
          type: "heading",
          raw: t[0],
          depth: t[1].length,
          text: e,
          tokens: this.lexer.inline(e),
        }
      }
    }
    hr(i) {
      const t = this.rules.block.hr.exec(i)
      if (t)
        return {
          type: "hr",
          raw: Vu(
            t[0],
            `
`,
          ),
        }
    }
    blockquote(i) {
      const t = this.rules.block.blockquote.exec(i)
      if (t) {
        let e = Vu(
            t[0],
            `
`,
          ).split(`
`),
          r = "",
          s = ""
        const a = []
        for (; e.length > 0; ) {
          let o = !1
          const c = []
          let u
          for (u = 0; u < e.length; u++)
            if (/^ {0,3}>/.test(e[u])) c.push(e[u]), (o = !0)
            else if (!o) c.push(e[u])
            else break
          e = e.slice(u)
          const l = c.join(`
`),
            m = l
              .replace(
                /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
                `
    $1`,
              )
              .replace(/^ {0,3}>[ \t]?/gm, "")
          ;(r = r
            ? `${r}
${l}`
            : l),
            (s = s
              ? `${s}
${m}`
              : m)
          const h = this.lexer.state.top
          if (
            ((this.lexer.state.top = !0),
            this.lexer.blockTokens(m, a, !0),
            (this.lexer.state.top = h),
            e.length === 0)
          )
            break
          const p = a[a.length - 1]
          if (p?.type === "code") break
          if (p?.type === "blockquote") {
            const g = p,
              w =
                g.raw +
                `
` +
                e.join(`
`),
              T = this.blockquote(w)
            ;(a[a.length - 1] = T),
              (r = r.substring(0, r.length - g.raw.length) + T.raw),
              (s = s.substring(0, s.length - g.text.length) + T.text)
            break
          } else if (p?.type === "list") {
            const g = p,
              w =
                g.raw +
                `
` +
                e.join(`
`),
              T = this.list(w)
            ;(a[a.length - 1] = T),
              (r = r.substring(0, r.length - p.raw.length) + T.raw),
              (s = s.substring(0, s.length - g.raw.length) + T.raw),
              (e = w.substring(a[a.length - 1].raw.length).split(`
`))
            continue
          }
        }
        return { type: "blockquote", raw: r, tokens: a, text: s }
      }
    }
    list(i) {
      let t = this.rules.block.list.exec(i)
      if (t) {
        let e = t[1].trim()
        const r = e.length > 1,
          s = {
            type: "list",
            raw: "",
            ordered: r,
            start: r ? +e.slice(0, -1) : "",
            loose: !1,
            items: [],
          }
        ;(e = r ? `\\d{1,9}\\${e.slice(-1)}` : `\\${e}`),
          this.options.pedantic && (e = r ? e : "[*+-]")
        const a = new RegExp(`^( {0,3}${e})((?:[	 ][^\\n]*)?(?:\\n|$))`)
        let o = !1
        for (; i; ) {
          let c = !1,
            u = "",
            l = ""
          if (!(t = a.exec(i)) || this.rules.block.hr.test(i)) break
          ;(u = t[0]), (i = i.substring(u.length))
          let m = t[2]
              .split(
                `
`,
                1,
              )[0]
              .replace(/^\t+/, (b) => " ".repeat(3 * b.length)),
            h = i.split(
              `
`,
              1,
            )[0],
            p = !m.trim(),
            g = 0
          if (
            (this.options.pedantic
              ? ((g = 2), (l = m.trimStart()))
              : p
                ? (g = t[1].length + 1)
                : ((g = t[2].search(/[^ ]/)),
                  (g = g > 4 ? 1 : g),
                  (l = m.slice(g)),
                  (g += t[1].length)),
            p &&
              /^ *$/.test(h) &&
              ((u +=
                h +
                `
`),
              (i = i.substring(h.length + 1)),
              (c = !0)),
            !c)
          ) {
            const b = new RegExp(
                `^ {0,${Math.min(3, g - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`,
              ),
              N = new RegExp(
                `^ {0,${Math.min(3, g - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`,
              ),
              $ = new RegExp(`^ {0,${Math.min(3, g - 1)}}(?:\`\`\`|~~~)`),
              L = new RegExp(`^ {0,${Math.min(3, g - 1)}}#`)
            for (; i; ) {
              const U = i.split(
                `
`,
                1,
              )[0]
              if (
                ((h = U),
                this.options.pedantic &&
                  (h = h.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")),
                $.test(h) || L.test(h) || b.test(h) || N.test(i))
              )
                break
              if (h.search(/[^ ]/) >= g || !h.trim())
                l +=
                  `
` + h.slice(g)
              else {
                if (
                  p ||
                  m.search(/[^ ]/) >= 4 ||
                  $.test(m) ||
                  L.test(m) ||
                  N.test(m)
                )
                  break
                l +=
                  `
` + h
              }
              !p && !h.trim() && (p = !0),
                (u +=
                  U +
                  `
`),
                (i = i.substring(U.length + 1)),
                (m = h.slice(g))
            }
          }
          s.loose || (o ? (s.loose = !0) : /\n *\n *$/.test(u) && (o = !0))
          let w = null,
            T
          this.options.gfm &&
            ((w = /^\[[ xX]\] /.exec(l)),
            w && ((T = w[0] !== "[ ] "), (l = l.replace(/^\[[ xX]\] +/, "")))),
            s.items.push({
              type: "list_item",
              raw: u,
              task: !!w,
              checked: T,
              loose: !1,
              text: l,
              tokens: [],
            }),
            (s.raw += u)
        }
        ;(s.items[s.items.length - 1].raw =
          s.items[s.items.length - 1].raw.trimEnd()),
          (s.items[s.items.length - 1].text =
            s.items[s.items.length - 1].text.trimEnd()),
          (s.raw = s.raw.trimEnd())
        for (let c = 0; c < s.items.length; c++)
          if (
            ((this.lexer.state.top = !1),
            (s.items[c].tokens = this.lexer.blockTokens(s.items[c].text, [])),
            !s.loose)
          ) {
            const u = s.items[c].tokens.filter((m) => m.type === "space"),
              l = u.length > 0 && u.some((m) => /\n.*\n/.test(m.raw))
            s.loose = l
          }
        if (s.loose)
          for (let c = 0; c < s.items.length; c++) s.items[c].loose = !0
        return s
      }
    }
    html(i) {
      const t = this.rules.block.html.exec(i)
      if (t)
        return {
          type: "html",
          block: !0,
          raw: t[0],
          pre: t[1] === "pre" || t[1] === "script" || t[1] === "style",
          text: t[0],
        }
    }
    def(i) {
      const t = this.rules.block.def.exec(i)
      if (t) {
        const e = t[1].toLowerCase().replace(/\s+/g, " "),
          r = t[2]
            ? t[2]
                .replace(/^<(.*)>$/, "$1")
                .replace(this.rules.inline.anyPunctuation, "$1")
            : "",
          s = t[3]
            ? t[3]
                .substring(1, t[3].length - 1)
                .replace(this.rules.inline.anyPunctuation, "$1")
            : t[3]
        return { type: "def", tag: e, raw: t[0], href: r, title: s }
      }
    }
    table(i) {
      const t = this.rules.block.table.exec(i)
      if (!t || !/[:|]/.test(t[2])) return
      const e = wV(t[1]),
        r = t[2].replace(/^\||\| *$/g, "").split("|"),
        s =
          t[3] && t[3].trim()
            ? t[3].replace(/\n[ \t]*$/, "").split(`
`)
            : [],
        a = { type: "table", raw: t[0], header: [], align: [], rows: [] }
      if (e.length === r.length) {
        for (const o of r)
          /^ *-+: *$/.test(o)
            ? a.align.push("right")
            : /^ *:-+: *$/.test(o)
              ? a.align.push("center")
              : /^ *:-+ *$/.test(o)
                ? a.align.push("left")
                : a.align.push(null)
        for (let o = 0; o < e.length; o++)
          a.header.push({
            text: e[o],
            tokens: this.lexer.inline(e[o]),
            header: !0,
            align: a.align[o],
          })
        for (const o of s)
          a.rows.push(
            wV(o, a.header.length).map((c, u) => ({
              text: c,
              tokens: this.lexer.inline(c),
              header: !1,
              align: a.align[u],
            })),
          )
        return a
      }
    }
    lheading(i) {
      const t = this.rules.block.lheading.exec(i)
      if (t)
        return {
          type: "heading",
          raw: t[0],
          depth: t[2].charAt(0) === "=" ? 1 : 2,
          text: t[1],
          tokens: this.lexer.inline(t[1]),
        }
    }
    paragraph(i) {
      const t = this.rules.block.paragraph.exec(i)
      if (t) {
        const e =
          t[1].charAt(t[1].length - 1) ===
          `
`
            ? t[1].slice(0, -1)
            : t[1]
        return {
          type: "paragraph",
          raw: t[0],
          text: e,
          tokens: this.lexer.inline(e),
        }
      }
    }
    text(i) {
      const t = this.rules.block.text.exec(i)
      if (t)
        return {
          type: "text",
          raw: t[0],
          text: t[0],
          tokens: this.lexer.inline(t[0]),
        }
    }
    escape(i) {
      const t = this.rules.inline.escape.exec(i)
      if (t) return { type: "escape", raw: t[0], text: Zi(t[1]) }
    }
    tag(i) {
      const t = this.rules.inline.tag.exec(i)
      if (t)
        return (
          !this.lexer.state.inLink && /^<a /i.test(t[0])
            ? (this.lexer.state.inLink = !0)
            : this.lexer.state.inLink &&
              /^<\/a>/i.test(t[0]) &&
              (this.lexer.state.inLink = !1),
          !this.lexer.state.inRawBlock &&
          /^<(pre|code|kbd|script)(\s|>)/i.test(t[0])
            ? (this.lexer.state.inRawBlock = !0)
            : this.lexer.state.inRawBlock &&
              /^<\/(pre|code|kbd|script)(\s|>)/i.test(t[0]) &&
              (this.lexer.state.inRawBlock = !1),
          {
            type: "html",
            raw: t[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            block: !1,
            text: t[0],
          }
        )
    }
    link(i) {
      const t = this.rules.inline.link.exec(i)
      if (t) {
        const e = t[2].trim()
        if (!this.options.pedantic && /^</.test(e)) {
          if (!/>$/.test(e)) return
          const a = Vu(e.slice(0, -1), "\\")
          if ((e.length - a.length) % 2 === 0) return
        } else {
          const a = Aut(t[2], "()")
          if (a > -1) {
            const c = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + a
            ;(t[2] = t[2].substring(0, a)),
              (t[0] = t[0].substring(0, c).trim()),
              (t[3] = "")
          }
        }
        let r = t[2],
          s = ""
        if (this.options.pedantic) {
          const a = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(r)
          a && ((r = a[1]), (s = a[3]))
        } else s = t[3] ? t[3].slice(1, -1) : ""
        return (
          (r = r.trim()),
          /^</.test(r) &&
            (this.options.pedantic && !/>$/.test(e)
              ? (r = r.slice(1))
              : (r = r.slice(1, -1))),
          yV(
            t,
            {
              href: r && r.replace(this.rules.inline.anyPunctuation, "$1"),
              title: s && s.replace(this.rules.inline.anyPunctuation, "$1"),
            },
            t[0],
            this.lexer,
          )
        )
      }
    }
    reflink(i, t) {
      let e
      if (
        (e = this.rules.inline.reflink.exec(i)) ||
        (e = this.rules.inline.nolink.exec(i))
      ) {
        const r = (e[2] || e[1]).replace(/\s+/g, " "),
          s = t[r.toLowerCase()]
        if (!s) {
          const a = e[0].charAt(0)
          return { type: "text", raw: a, text: a }
        }
        return yV(e, s, e[0], this.lexer)
      }
    }
    emStrong(i, t, e = "") {
      let r = this.rules.inline.emStrongLDelim.exec(i)
      if (!r || (r[3] && e.match(/[\p{L}\p{N}]/u))) return
      if (
        !(r[1] || r[2] || "") ||
        !e ||
        this.rules.inline.punctuation.exec(e)
      ) {
        const a = [...r[0]].length - 1
        let o,
          c,
          u = a,
          l = 0
        const m =
          r[0][0] === "*"
            ? this.rules.inline.emStrongRDelimAst
            : this.rules.inline.emStrongRDelimUnd
        for (
          m.lastIndex = 0, t = t.slice(-1 * i.length + a);
          (r = m.exec(t)) != null;

        ) {
          if (((o = r[1] || r[2] || r[3] || r[4] || r[5] || r[6]), !o)) continue
          if (((c = [...o].length), r[3] || r[4])) {
            u += c
            continue
          } else if ((r[5] || r[6]) && a % 3 && !((a + c) % 3)) {
            l += c
            continue
          }
          if (((u -= c), u > 0)) continue
          c = Math.min(c, c + u + l)
          const h = [...r[0]][0].length,
            p = i.slice(0, a + r.index + h + c)
          if (Math.min(a, c) % 2) {
            const w = p.slice(1, -1)
            return {
              type: "em",
              raw: p,
              text: w,
              tokens: this.lexer.inlineTokens(w),
            }
          }
          const g = p.slice(2, -2)
          return {
            type: "strong",
            raw: p,
            text: g,
            tokens: this.lexer.inlineTokens(g),
          }
        }
      }
    }
    codespan(i) {
      const t = this.rules.inline.code.exec(i)
      if (t) {
        let e = t[2].replace(/\n/g, " ")
        const r = /[^ ]/.test(e),
          s = /^ /.test(e) && / $/.test(e)
        return (
          r && s && (e = e.substring(1, e.length - 1)),
          (e = Zi(e, !0)),
          { type: "codespan", raw: t[0], text: e }
        )
      }
    }
    br(i) {
      const t = this.rules.inline.br.exec(i)
      if (t) return { type: "br", raw: t[0] }
    }
    del(i) {
      const t = this.rules.inline.del.exec(i)
      if (t)
        return {
          type: "del",
          raw: t[0],
          text: t[2],
          tokens: this.lexer.inlineTokens(t[2]),
        }
    }
    autolink(i) {
      const t = this.rules.inline.autolink.exec(i)
      if (t) {
        let e, r
        return (
          t[2] === "@"
            ? ((e = Zi(t[1])), (r = "mailto:" + e))
            : ((e = Zi(t[1])), (r = e)),
          {
            type: "link",
            raw: t[0],
            text: e,
            href: r,
            tokens: [{ type: "text", raw: e, text: e }],
          }
        )
      }
    }
    url(i) {
      let t
      if ((t = this.rules.inline.url.exec(i))) {
        let e, r
        if (t[2] === "@") (e = Zi(t[0])), (r = "mailto:" + e)
        else {
          let s
          do
            (s = t[0]),
              (t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? "")
          while (s !== t[0])
          ;(e = Zi(t[0])), t[1] === "www." ? (r = "http://" + t[0]) : (r = t[0])
        }
        return {
          type: "link",
          raw: t[0],
          text: e,
          href: r,
          tokens: [{ type: "text", raw: e, text: e }],
        }
      }
    }
    inlineText(i) {
      const t = this.rules.inline.text.exec(i)
      if (t) {
        let e
        return (
          this.lexer.state.inRawBlock ? (e = t[0]) : (e = Zi(t[0])),
          { type: "text", raw: t[0], text: e }
        )
      }
    }
  },
  Out = /^(?: *(?:\n|$))+/,
  qut = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  Uut =
    /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  Gu = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  Mut = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  TV = /(?:[*+-]|\d{1,9}[.)])/,
  kV = de(
    /^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  )
    .replace(/bull/g, TV)
    .replace(/blockCode/g, / {4}/)
    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/)
    .replace(/blockquote/g, / {0,3}>/)
    .replace(/heading/g, / {0,3}#{1,6}/)
    .replace(/html/g, / {0,3}<[^\n>]+>\n/)
    .getRegex(),
  u3 =
    /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  Hut = /^[^\n]+/,
  l3 = /(?!\s*\])(?:\\.|[^\[\]\\])+/,
  Wut = de(
    /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  )
    .replace("label", l3)
    .replace(
      "title",
      /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/,
    )
    .getRegex(),
  jut = de(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/)
    .replace(/bull/g, TV)
    .getRegex(),
  v_ =
    "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",
  d3 = /<!--(?:-?>|[\s\S]*?(?:-->|$))/,
  Vut = de(
    "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
    "i",
  )
    .replace("comment", d3)
    .replace("tag", v_)
    .replace(
      "attribute",
      / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/,
    )
    .getRegex(),
  SV = de(u3)
    .replace("hr", Gu)
    .replace("heading", " {0,3}#{1,6}(?:\\s|$)")
    .replace("|lheading", "")
    .replace("|table", "")
    .replace("blockquote", " {0,3}>")
    .replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
    .replace("list", " {0,3}(?:[*+-]|1[.)]) ")
    .replace(
      "html",
      "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)",
    )
    .replace("tag", v_)
    .getRegex(),
  Gut = de(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/)
    .replace("paragraph", SV)
    .getRegex(),
  m3 = {
    blockquote: Gut,
    code: qut,
    def: Wut,
    fences: Uut,
    heading: Mut,
    hr: Gu,
    html: Vut,
    lheading: kV,
    list: jut,
    newline: Out,
    paragraph: SV,
    table: ju,
    text: Hut,
  },
  bV = de(
    "^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)",
  )
    .replace("hr", Gu)
    .replace("heading", " {0,3}#{1,6}(?:\\s|$)")
    .replace("blockquote", " {0,3}>")
    .replace("code", " {4}[^\\n]")
    .replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
    .replace("list", " {0,3}(?:[*+-]|1[.)]) ")
    .replace(
      "html",
      "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)",
    )
    .replace("tag", v_)
    .getRegex(),
  zut = {
    ...m3,
    table: bV,
    paragraph: de(u3)
      .replace("hr", Gu)
      .replace("heading", " {0,3}#{1,6}(?:\\s|$)")
      .replace("|lheading", "")
      .replace("table", bV)
      .replace("blockquote", " {0,3}>")
      .replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
      .replace("list", " {0,3}(?:[*+-]|1[.)]) ")
      .replace(
        "html",
        "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)",
      )
      .replace("tag", v_)
      .getRegex(),
  },
  Yut = {
    ...m3,
    html: de(
      `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`,
    )
      .replace("comment", d3)
      .replace(
        /tag/g,
        "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b",
      )
      .getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: ju,
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: de(u3)
      .replace("hr", Gu)
      .replace(
        "heading",
        ` *#{1,6} *[^
]`,
      )
      .replace("lheading", kV)
      .replace("|table", "")
      .replace("blockquote", " {0,3}>")
      .replace("|fences", "")
      .replace("|list", "")
      .replace("|html", "")
      .replace("|tag", "")
      .getRegex(),
  },
  EV = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  Qut = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  IV = /^( {2,}|\\)\n(?!\s*$)/,
  Xut =
    /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  zu = "\\p{P}\\p{S}",
  Kut = de(/^((?![*_])[\spunctuation])/, "u")
    .replace(/punctuation/g, zu)
    .getRegex(),
  Zut = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g,
  tlt = de(
    /^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/,
    "u",
  )
    .replace(/punct/g, zu)
    .getRegex(),
  elt = de(
    "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])",
    "gu",
  )
    .replace(/punct/g, zu)
    .getRegex(),
  ilt = de(
    "^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])",
    "gu",
  )
    .replace(/punct/g, zu)
    .getRegex(),
  rlt = de(/\\([punct])/, "gu")
    .replace(/punct/g, zu)
    .getRegex(),
  nlt = de(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/)
    .replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)
    .replace(
      "email",
      /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/,
    )
    .getRegex(),
  slt = de(d3).replace("(?:-->|$)", "-->").getRegex(),
  alt = de(
    "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  )
    .replace("comment", slt)
    .replace(
      "attribute",
      /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/,
    )
    .getRegex(),
  w_ = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,
  olt = de(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/)
    .replace("label", w_)
    .replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/)
    .replace(
      "title",
      /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/,
    )
    .getRegex(),
  PV = de(/^!?\[(label)\]\[(ref)\]/)
    .replace("label", w_)
    .replace("ref", l3)
    .getRegex(),
  NV = de(/^!?\[(ref)\](?:\[\])?/)
    .replace("ref", l3)
    .getRegex(),
  clt = de("reflink|nolink(?!\\()", "g")
    .replace("reflink", PV)
    .replace("nolink", NV)
    .getRegex(),
  h3 = {
    _backpedal: ju,
    anyPunctuation: rlt,
    autolink: nlt,
    blockSkip: Zut,
    br: IV,
    code: Qut,
    del: ju,
    emStrongLDelim: tlt,
    emStrongRDelimAst: elt,
    emStrongRDelimUnd: ilt,
    escape: EV,
    link: olt,
    nolink: NV,
    punctuation: Kut,
    reflink: PV,
    reflinkSearch: clt,
    tag: alt,
    text: Xut,
    url: ju,
  },
  ult = {
    ...h3,
    link: de(/^!?\[(label)\]\((.*?)\)/)
      .replace("label", w_)
      .getRegex(),
    reflink: de(/^!?\[(label)\]\s*\[([^\]]*)\]/)
      .replace("label", w_)
      .getRegex(),
  },
  f3 = {
    ...h3,
    escape: de(EV).replace("])", "~|])").getRegex(),
    url: de(
      /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      "i",
    )
      .replace(
        "email",
        /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      )
      .getRegex(),
    _backpedal:
      /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/,
  },
  llt = {
    ...f3,
    br: de(IV).replace("{2,}", "*").getRegex(),
    text: de(f3.text)
      .replace("\\b_", "\\b_| {2,}\\n")
      .replace(/\{2,\}/g, "*")
      .getRegex(),
  },
  y_ = { normal: m3, gfm: zut, pedantic: Yut },
  Yu = { normal: h3, gfm: f3, breaks: llt, pedantic: ult },
  aa = class mH {
    tokens
    options
    state
    tokenizer
    inlineQueue
    constructor(t) {
      ;(this.tokens = []),
        (this.tokens.links = Object.create(null)),
        (this.options = t || sa),
        (this.options.tokenizer = this.options.tokenizer || new g_()),
        (this.tokenizer = this.options.tokenizer),
        (this.tokenizer.options = this.options),
        (this.tokenizer.lexer = this),
        (this.inlineQueue = []),
        (this.state = { inLink: !1, inRawBlock: !1, top: !0 })
      const e = { block: y_.normal, inline: Yu.normal }
      this.options.pedantic
        ? ((e.block = y_.pedantic), (e.inline = Yu.pedantic))
        : this.options.gfm &&
          ((e.block = y_.gfm),
          this.options.breaks ? (e.inline = Yu.breaks) : (e.inline = Yu.gfm)),
        (this.tokenizer.rules = e)
    }
    static get rules() {
      return { block: y_, inline: Yu }
    }
    static lex(t, e) {
      return new mH(e).lex(t)
    }
    static lexInline(t, e) {
      return new mH(e).inlineTokens(t)
    }
    lex(t) {
      ;(t = t.replace(
        /\r\n|\r/g,
        `
`,
      )),
        this.blockTokens(t, this.tokens)
      for (let e = 0; e < this.inlineQueue.length; e++) {
        const r = this.inlineQueue[e]
        this.inlineTokens(r.src, r.tokens)
      }
      return (this.inlineQueue = []), this.tokens
    }
    blockTokens(t, e = [], r = !1) {
      this.options.pedantic
        ? (t = t.replace(/\t/g, "    ").replace(/^ +$/gm, ""))
        : (t = t.replace(
            /^( *)(\t+)/gm,
            (c, u, l) => u + "    ".repeat(l.length),
          ))
      let s, a, o
      for (; t; )
        if (
          !(
            this.options.extensions &&
            this.options.extensions.block &&
            this.options.extensions.block.some((c) =>
              (s = c.call({ lexer: this }, t, e))
                ? ((t = t.substring(s.raw.length)), e.push(s), !0)
                : !1,
            )
          )
        ) {
          if ((s = this.tokenizer.space(t))) {
            ;(t = t.substring(s.raw.length)),
              s.raw.length === 1 && e.length > 0
                ? (e[e.length - 1].raw += `
`)
                : e.push(s)
            continue
          }
          if ((s = this.tokenizer.code(t))) {
            ;(t = t.substring(s.raw.length)),
              (a = e[e.length - 1]),
              a && (a.type === "paragraph" || a.type === "text")
                ? ((a.raw +=
                    `
` + s.raw),
                  (a.text +=
                    `
` + s.text),
                  (this.inlineQueue[this.inlineQueue.length - 1].src = a.text))
                : e.push(s)
            continue
          }
          if ((s = this.tokenizer.fences(t))) {
            ;(t = t.substring(s.raw.length)), e.push(s)
            continue
          }
          if ((s = this.tokenizer.heading(t))) {
            ;(t = t.substring(s.raw.length)), e.push(s)
            continue
          }
          if ((s = this.tokenizer.hr(t))) {
            ;(t = t.substring(s.raw.length)), e.push(s)
            continue
          }
          if ((s = this.tokenizer.blockquote(t))) {
            ;(t = t.substring(s.raw.length)), e.push(s)
            continue
          }
          if ((s = this.tokenizer.list(t))) {
            ;(t = t.substring(s.raw.length)), e.push(s)
            continue
          }
          if ((s = this.tokenizer.html(t))) {
            ;(t = t.substring(s.raw.length)), e.push(s)
            continue
          }
          if ((s = this.tokenizer.def(t))) {
            ;(t = t.substring(s.raw.length)),
              (a = e[e.length - 1]),
              a && (a.type === "paragraph" || a.type === "text")
                ? ((a.raw +=
                    `
` + s.raw),
                  (a.text +=
                    `
` + s.raw),
                  (this.inlineQueue[this.inlineQueue.length - 1].src = a.text))
                : this.tokens.links[s.tag] ||
                  (this.tokens.links[s.tag] = { href: s.href, title: s.title })
            continue
          }
          if ((s = this.tokenizer.table(t))) {
            ;(t = t.substring(s.raw.length)), e.push(s)
            continue
          }
          if ((s = this.tokenizer.lheading(t))) {
            ;(t = t.substring(s.raw.length)), e.push(s)
            continue
          }
          if (
            ((o = t),
            this.options.extensions && this.options.extensions.startBlock)
          ) {
            let c = 1 / 0
            const u = t.slice(1)
            let l
            this.options.extensions.startBlock.forEach((m) => {
              ;(l = m.call({ lexer: this }, u)),
                typeof l == "number" && l >= 0 && (c = Math.min(c, l))
            }),
              c < 1 / 0 && c >= 0 && (o = t.substring(0, c + 1))
          }
          if (this.state.top && (s = this.tokenizer.paragraph(o))) {
            ;(a = e[e.length - 1]),
              r && a?.type === "paragraph"
                ? ((a.raw +=
                    `
` + s.raw),
                  (a.text +=
                    `
` + s.text),
                  this.inlineQueue.pop(),
                  (this.inlineQueue[this.inlineQueue.length - 1].src = a.text))
                : e.push(s),
              (r = o.length !== t.length),
              (t = t.substring(s.raw.length))
            continue
          }
          if ((s = this.tokenizer.text(t))) {
            ;(t = t.substring(s.raw.length)),
              (a = e[e.length - 1]),
              a && a.type === "text"
                ? ((a.raw +=
                    `
` + s.raw),
                  (a.text +=
                    `
` + s.text),
                  this.inlineQueue.pop(),
                  (this.inlineQueue[this.inlineQueue.length - 1].src = a.text))
                : e.push(s)
            continue
          }
          if (t) {
            const c = "Infinite loop on byte: " + t.charCodeAt(0)
            if (this.options.silent) {
              console.error(c)
              break
            } else throw new Error(c)
          }
        }
      return (this.state.top = !0), e
    }
    inline(t, e = []) {
      return this.inlineQueue.push({ src: t, tokens: e }), e
    }
    inlineTokens(t, e = []) {
      let r,
        s,
        a,
        o = t,
        c,
        u,
        l
      if (this.tokens.links) {
        const m = Object.keys(this.tokens.links)
        if (m.length > 0)
          for (
            ;
            (c = this.tokenizer.rules.inline.reflinkSearch.exec(o)) != null;

          )
            m.includes(c[0].slice(c[0].lastIndexOf("[") + 1, -1)) &&
              (o =
                o.slice(0, c.index) +
                "[" +
                "a".repeat(c[0].length - 2) +
                "]" +
                o.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))
      }
      for (; (c = this.tokenizer.rules.inline.blockSkip.exec(o)) != null; )
        o =
          o.slice(0, c.index) +
          "[" +
          "a".repeat(c[0].length - 2) +
          "]" +
          o.slice(this.tokenizer.rules.inline.blockSkip.lastIndex)
      for (; (c = this.tokenizer.rules.inline.anyPunctuation.exec(o)) != null; )
        o =
          o.slice(0, c.index) +
          "++" +
          o.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex)
      for (; t; )
        if (
          (u || (l = ""),
          (u = !1),
          !(
            this.options.extensions &&
            this.options.extensions.inline &&
            this.options.extensions.inline.some((m) =>
              (r = m.call({ lexer: this }, t, e))
                ? ((t = t.substring(r.raw.length)), e.push(r), !0)
                : !1,
            )
          ))
        ) {
          if ((r = this.tokenizer.escape(t))) {
            ;(t = t.substring(r.raw.length)), e.push(r)
            continue
          }
          if ((r = this.tokenizer.tag(t))) {
            ;(t = t.substring(r.raw.length)),
              (s = e[e.length - 1]),
              s && r.type === "text" && s.type === "text"
                ? ((s.raw += r.raw), (s.text += r.text))
                : e.push(r)
            continue
          }
          if ((r = this.tokenizer.link(t))) {
            ;(t = t.substring(r.raw.length)), e.push(r)
            continue
          }
          if ((r = this.tokenizer.reflink(t, this.tokens.links))) {
            ;(t = t.substring(r.raw.length)),
              (s = e[e.length - 1]),
              s && r.type === "text" && s.type === "text"
                ? ((s.raw += r.raw), (s.text += r.text))
                : e.push(r)
            continue
          }
          if ((r = this.tokenizer.emStrong(t, o, l))) {
            ;(t = t.substring(r.raw.length)), e.push(r)
            continue
          }
          if ((r = this.tokenizer.codespan(t))) {
            ;(t = t.substring(r.raw.length)), e.push(r)
            continue
          }
          if ((r = this.tokenizer.br(t))) {
            ;(t = t.substring(r.raw.length)), e.push(r)
            continue
          }
          if ((r = this.tokenizer.del(t))) {
            ;(t = t.substring(r.raw.length)), e.push(r)
            continue
          }
          if ((r = this.tokenizer.autolink(t))) {
            ;(t = t.substring(r.raw.length)), e.push(r)
            continue
          }
          if (!this.state.inLink && (r = this.tokenizer.url(t))) {
            ;(t = t.substring(r.raw.length)), e.push(r)
            continue
          }
          if (
            ((a = t),
            this.options.extensions && this.options.extensions.startInline)
          ) {
            let m = 1 / 0
            const h = t.slice(1)
            let p
            this.options.extensions.startInline.forEach((g) => {
              ;(p = g.call({ lexer: this }, h)),
                typeof p == "number" && p >= 0 && (m = Math.min(m, p))
            }),
              m < 1 / 0 && m >= 0 && (a = t.substring(0, m + 1))
          }
          if ((r = this.tokenizer.inlineText(a))) {
            ;(t = t.substring(r.raw.length)),
              r.raw.slice(-1) !== "_" && (l = r.raw.slice(-1)),
              (u = !0),
              (s = e[e.length - 1]),
              s && s.type === "text"
                ? ((s.raw += r.raw), (s.text += r.text))
                : e.push(r)
            continue
          }
          if (t) {
            const m = "Infinite loop on byte: " + t.charCodeAt(0)
            if (this.options.silent) {
              console.error(m)
              break
            } else throw new Error(m)
          }
        }
      return e
    }
  },
  T_ = class {
    options
    parser
    constructor(i) {
      this.options = i || sa
    }
    space(i) {
      return ""
    }
    code({ text: i, lang: t, escaped: e }) {
      const r = (t || "").match(/^\S*/)?.[0],
        s =
          i.replace(/\n$/, "") +
          `
`
      return r
        ? '<pre><code class="language-' +
            Zi(r) +
            '">' +
            (e ? s : Zi(s, !0)) +
            `</code></pre>
`
        : "<pre><code>" +
            (e ? s : Zi(s, !0)) +
            `</code></pre>
`
    }
    blockquote({ tokens: i }) {
      return `<blockquote>
${this.parser.parse(i)}</blockquote>
`
    }
    html({ text: i }) {
      return i
    }
    heading({ tokens: i, depth: t }) {
      return `<h${t}>${this.parser.parseInline(i)}</h${t}>
`
    }
    hr(i) {
      return `<hr>
`
    }
    list(i) {
      const t = i.ordered,
        e = i.start
      let r = ""
      for (let o = 0; o < i.items.length; o++) {
        const c = i.items[o]
        r += this.listitem(c)
      }
      const s = t ? "ol" : "ul",
        a = t && e !== 1 ? ' start="' + e + '"' : ""
      return (
        "<" +
        s +
        a +
        `>
` +
        r +
        "</" +
        s +
        `>
`
      )
    }
    listitem(i) {
      let t = ""
      if (i.task) {
        const e = this.checkbox({ checked: !!i.checked })
        i.loose
          ? i.tokens.length > 0 && i.tokens[0].type === "paragraph"
            ? ((i.tokens[0].text = e + " " + i.tokens[0].text),
              i.tokens[0].tokens &&
                i.tokens[0].tokens.length > 0 &&
                i.tokens[0].tokens[0].type === "text" &&
                (i.tokens[0].tokens[0].text =
                  e + " " + i.tokens[0].tokens[0].text))
            : i.tokens.unshift({ type: "text", raw: e + " ", text: e + " " })
          : (t += e + " ")
      }
      return (
        (t += this.parser.parse(i.tokens, !!i.loose)),
        `<li>${t}</li>
`
      )
    }
    checkbox({ checked: i }) {
      return (
        "<input " + (i ? 'checked="" ' : "") + 'disabled="" type="checkbox">'
      )
    }
    paragraph({ tokens: i }) {
      return `<p>${this.parser.parseInline(i)}</p>
`
    }
    table(i) {
      let t = "",
        e = ""
      for (let s = 0; s < i.header.length; s++) e += this.tablecell(i.header[s])
      t += this.tablerow({ text: e })
      let r = ""
      for (let s = 0; s < i.rows.length; s++) {
        const a = i.rows[s]
        e = ""
        for (let o = 0; o < a.length; o++) e += this.tablecell(a[o])
        r += this.tablerow({ text: e })
      }
      return (
        r && (r = `<tbody>${r}</tbody>`),
        `<table>
<thead>
` +
          t +
          `</thead>
` +
          r +
          `</table>
`
      )
    }
    tablerow({ text: i }) {
      return `<tr>
${i}</tr>
`
    }
    tablecell(i) {
      const t = this.parser.parseInline(i.tokens),
        e = i.header ? "th" : "td"
      return (
        (i.align ? `<${e} align="${i.align}">` : `<${e}>`) +
        t +
        `</${e}>
`
      )
    }
    strong({ tokens: i }) {
      return `<strong>${this.parser.parseInline(i)}</strong>`
    }
    em({ tokens: i }) {
      return `<em>${this.parser.parseInline(i)}</em>`
    }
    codespan({ text: i }) {
      return `<code>${i}</code>`
    }
    br(i) {
      return "<br>"
    }
    del({ tokens: i }) {
      return `<del>${this.parser.parseInline(i)}</del>`
    }
    link({ href: i, title: t, tokens: e }) {
      const r = this.parser.parseInline(e),
        s = vV(i)
      if (s === null) return r
      i = s
      let a = '<a href="' + i + '"'
      return t && (a += ' title="' + t + '"'), (a += ">" + r + "</a>"), a
    }
    image({ href: i, title: t, text: e }) {
      const r = vV(i)
      if (r === null) return e
      i = r
      let s = `<img src="${i}" alt="${e}"`
      return t && (s += ` title="${t}"`), (s += ">"), s
    }
    text(i) {
      return "tokens" in i && i.tokens
        ? this.parser.parseInline(i.tokens)
        : i.text
    }
  },
  p3 = class {
    strong({ text: i }) {
      return i
    }
    em({ text: i }) {
      return i
    }
    codespan({ text: i }) {
      return i
    }
    del({ text: i }) {
      return i
    }
    html({ text: i }) {
      return i
    }
    text({ text: i }) {
      return i
    }
    link({ text: i }) {
      return "" + i
    }
    image({ text: i }) {
      return "" + i
    }
    br() {
      return ""
    }
  },
  oa = class hH {
    options
    renderer
    textRenderer
    constructor(t) {
      ;(this.options = t || sa),
        (this.options.renderer = this.options.renderer || new T_()),
        (this.renderer = this.options.renderer),
        (this.renderer.options = this.options),
        (this.renderer.parser = this),
        (this.textRenderer = new p3())
    }
    static parse(t, e) {
      return new hH(e).parse(t)
    }
    static parseInline(t, e) {
      return new hH(e).parseInline(t)
    }
    parse(t, e = !0) {
      let r = ""
      for (let s = 0; s < t.length; s++) {
        const a = t[s]
        if (
          this.options.extensions &&
          this.options.extensions.renderers &&
          this.options.extensions.renderers[a.type]
        ) {
          const c = a,
            u = this.options.extensions.renderers[c.type].call(
              { parser: this },
              c,
            )
          if (
            u !== !1 ||
            ![
              "space",
              "hr",
              "heading",
              "code",
              "table",
              "blockquote",
              "list",
              "html",
              "paragraph",
              "text",
            ].includes(c.type)
          ) {
            r += u || ""
            continue
          }
        }
        const o = a
        switch (o.type) {
          case "space": {
            r += this.renderer.space(o)
            continue
          }
          case "hr": {
            r += this.renderer.hr(o)
            continue
          }
          case "heading": {
            r += this.renderer.heading(o)
            continue
          }
          case "code": {
            r += this.renderer.code(o)
            continue
          }
          case "table": {
            r += this.renderer.table(o)
            continue
          }
          case "blockquote": {
            r += this.renderer.blockquote(o)
            continue
          }
          case "list": {
            r += this.renderer.list(o)
            continue
          }
          case "html": {
            r += this.renderer.html(o)
            continue
          }
          case "paragraph": {
            r += this.renderer.paragraph(o)
            continue
          }
          case "text": {
            let c = o,
              u = this.renderer.text(c)
            for (; s + 1 < t.length && t[s + 1].type === "text"; )
              (c = t[++s]),
                (u +=
                  `
` + this.renderer.text(c))
            e
              ? (r += this.renderer.paragraph({
                  type: "paragraph",
                  raw: u,
                  text: u,
                  tokens: [{ type: "text", raw: u, text: u }],
                }))
              : (r += u)
            continue
          }
          default: {
            const c = 'Token with "' + o.type + '" type was not found.'
            if (this.options.silent) return console.error(c), ""
            throw new Error(c)
          }
        }
      }
      return r
    }
    parseInline(t, e) {
      e = e || this.renderer
      let r = ""
      for (let s = 0; s < t.length; s++) {
        const a = t[s]
        if (
          this.options.extensions &&
          this.options.extensions.renderers &&
          this.options.extensions.renderers[a.type]
        ) {
          const c = this.options.extensions.renderers[a.type].call(
            { parser: this },
            a,
          )
          if (
            c !== !1 ||
            ![
              "escape",
              "html",
              "link",
              "image",
              "strong",
              "em",
              "codespan",
              "br",
              "del",
              "text",
            ].includes(a.type)
          ) {
            r += c || ""
            continue
          }
        }
        const o = a
        switch (o.type) {
          case "escape": {
            r += e.text(o)
            break
          }
          case "html": {
            r += e.html(o)
            break
          }
          case "link": {
            r += e.link(o)
            break
          }
          case "image": {
            r += e.image(o)
            break
          }
          case "strong": {
            r += e.strong(o)
            break
          }
          case "em": {
            r += e.em(o)
            break
          }
          case "codespan": {
            r += e.codespan(o)
            break
          }
          case "br": {
            r += e.br(o)
            break
          }
          case "del": {
            r += e.del(o)
            break
          }
          case "text": {
            r += e.text(o)
            break
          }
          default: {
            const c = 'Token with "' + o.type + '" type was not found.'
            if (this.options.silent) return console.error(c), ""
            throw new Error(c)
          }
        }
      }
      return r
    }
  },
  k_ = class {
    options
    constructor(i) {
      this.options = i || sa
    }
    static passThroughHooks = new Set([
      "preprocess",
      "postprocess",
      "processAllTokens",
    ])
    preprocess(i) {
      return i
    }
    postprocess(i) {
      return i
    }
    processAllTokens(i) {
      return i
    }
  },
  dlt = class {
    defaults = c3()
    options = this.setOptions
    parse = this.parseMarkdown(aa.lex, oa.parse)
    parseInline = this.parseMarkdown(aa.lexInline, oa.parseInline)
    Parser = oa
    Renderer = T_
    TextRenderer = p3
    Lexer = aa
    Tokenizer = g_
    Hooks = k_
    constructor(...i) {
      this.use(...i)
    }
    walkTokens(i, t) {
      let e = []
      for (const r of i)
        switch (((e = e.concat(t.call(this, r))), r.type)) {
          case "table": {
            const s = r
            for (const a of s.header) e = e.concat(this.walkTokens(a.tokens, t))
            for (const a of s.rows)
              for (const o of a) e = e.concat(this.walkTokens(o.tokens, t))
            break
          }
          case "list": {
            const s = r
            e = e.concat(this.walkTokens(s.items, t))
            break
          }
          default: {
            const s = r
            this.defaults.extensions?.childTokens?.[s.type]
              ? this.defaults.extensions.childTokens[s.type].forEach((a) => {
                  const o = s[a].flat(1 / 0)
                  e = e.concat(this.walkTokens(o, t))
                })
              : s.tokens && (e = e.concat(this.walkTokens(s.tokens, t)))
          }
        }
      return e
    }
    use(...i) {
      const t = this.defaults.extensions || { renderers: {}, childTokens: {} }
      return (
        i.forEach((e) => {
          const r = { ...e }
          if (
            ((r.async = this.defaults.async || r.async || !1),
            e.extensions &&
              (e.extensions.forEach((s) => {
                if (!s.name) throw new Error("extension name required")
                if ("renderer" in s) {
                  const a = t.renderers[s.name]
                  a
                    ? (t.renderers[s.name] = function (...o) {
                        let c = s.renderer.apply(this, o)
                        return c === !1 && (c = a.apply(this, o)), c
                      })
                    : (t.renderers[s.name] = s.renderer)
                }
                if ("tokenizer" in s) {
                  if (!s.level || (s.level !== "block" && s.level !== "inline"))
                    throw new Error(
                      "extension level must be 'block' or 'inline'",
                    )
                  const a = t[s.level]
                  a ? a.unshift(s.tokenizer) : (t[s.level] = [s.tokenizer]),
                    s.start &&
                      (s.level === "block"
                        ? t.startBlock
                          ? t.startBlock.push(s.start)
                          : (t.startBlock = [s.start])
                        : s.level === "inline" &&
                          (t.startInline
                            ? t.startInline.push(s.start)
                            : (t.startInline = [s.start])))
                }
                "childTokens" in s &&
                  s.childTokens &&
                  (t.childTokens[s.name] = s.childTokens)
              }),
              (r.extensions = t)),
            e.renderer)
          ) {
            const s = this.defaults.renderer || new T_(this.defaults)
            for (const a in e.renderer) {
              if (!(a in s)) throw new Error(`renderer '${a}' does not exist`)
              if (["options", "parser"].includes(a)) continue
              const o = a,
                c = e.renderer[o],
                u = s[o]
              s[o] = (...l) => {
                let m = c.apply(s, l)
                return m === !1 && (m = u.apply(s, l)), m || ""
              }
            }
            r.renderer = s
          }
          if (e.tokenizer) {
            const s = this.defaults.tokenizer || new g_(this.defaults)
            for (const a in e.tokenizer) {
              if (!(a in s)) throw new Error(`tokenizer '${a}' does not exist`)
              if (["options", "rules", "lexer"].includes(a)) continue
              const o = a,
                c = e.tokenizer[o],
                u = s[o]
              s[o] = (...l) => {
                let m = c.apply(s, l)
                return m === !1 && (m = u.apply(s, l)), m
              }
            }
            r.tokenizer = s
          }
          if (e.hooks) {
            const s = this.defaults.hooks || new k_()
            for (const a in e.hooks) {
              if (!(a in s)) throw new Error(`hook '${a}' does not exist`)
              if (a === "options") continue
              const o = a,
                c = e.hooks[o],
                u = s[o]
              k_.passThroughHooks.has(a)
                ? (s[o] = (l) => {
                    if (this.defaults.async)
                      return Promise.resolve(c.call(s, l)).then((h) =>
                        u.call(s, h),
                      )
                    const m = c.call(s, l)
                    return u.call(s, m)
                  })
                : (s[o] = (...l) => {
                    let m = c.apply(s, l)
                    return m === !1 && (m = u.apply(s, l)), m
                  })
            }
            r.hooks = s
          }
          if (e.walkTokens) {
            const s = this.defaults.walkTokens,
              a = e.walkTokens
            r.walkTokens = function (o) {
              let c = []
              return (
                c.push(a.call(this, o)), s && (c = c.concat(s.call(this, o))), c
              )
            }
          }
          this.defaults = { ...this.defaults, ...r }
        }),
        this
      )
    }
    setOptions(i) {
      return (this.defaults = { ...this.defaults, ...i }), this
    }
    lexer(i, t) {
      return aa.lex(i, t ?? this.defaults)
    }
    parser(i, t) {
      return oa.parse(i, t ?? this.defaults)
    }
    parseMarkdown(i, t) {
      return (r, s) => {
        const a = { ...s },
          o = { ...this.defaults, ...a },
          c = this.onError(!!o.silent, !!o.async)
        if (this.defaults.async === !0 && a.async === !1)
          return c(
            new Error(
              "marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.",
            ),
          )
        if (typeof r > "u" || r === null)
          return c(new Error("marked(): input parameter is undefined or null"))
        if (typeof r != "string")
          return c(
            new Error(
              "marked(): input parameter is of type " +
                Object.prototype.toString.call(r) +
                ", string expected",
            ),
          )
        if ((o.hooks && (o.hooks.options = o), o.async))
          return Promise.resolve(o.hooks ? o.hooks.preprocess(r) : r)
            .then((u) => i(u, o))
            .then((u) => (o.hooks ? o.hooks.processAllTokens(u) : u))
            .then((u) =>
              o.walkTokens
                ? Promise.all(this.walkTokens(u, o.walkTokens)).then(() => u)
                : u,
            )
            .then((u) => t(u, o))
            .then((u) => (o.hooks ? o.hooks.postprocess(u) : u))
            .catch(c)
        try {
          o.hooks && (r = o.hooks.preprocess(r))
          let u = i(r, o)
          o.hooks && (u = o.hooks.processAllTokens(u)),
            o.walkTokens && this.walkTokens(u, o.walkTokens)
          let l = t(u, o)
          return o.hooks && (l = o.hooks.postprocess(l)), l
        } catch (u) {
          return c(u)
        }
      }
    }
    onError(i, t) {
      return (e) => {
        if (
          ((e.message += `
Please report this to https://github.com/markedjs/marked.`),
          i)
        ) {
          const r =
            "<p>An error occurred:</p><pre>" + Zi(e.message + "", !0) + "</pre>"
          return t ? Promise.resolve(r) : r
        }
        if (t) return Promise.reject(e)
        throw e
      }
    }
  },
  ca = new dlt()
function oe(i, t) {
  return ca.parse(i, t)
}
;(oe.options = oe.setOptions =
  function (i) {
    return ca.setOptions(i), (oe.defaults = ca.defaults), hV(oe.defaults), oe
  }),
  (oe.getDefaults = c3),
  (oe.defaults = sa),
  (oe.use = function (...i) {
    return ca.use(...i), (oe.defaults = ca.defaults), hV(oe.defaults), oe
  }),
  (oe.walkTokens = function (i, t) {
    return ca.walkTokens(i, t)
  }),
  (oe.parseInline = ca.parseInline),
  (oe.Parser = oa),
  (oe.parser = oa.parse),
  (oe.Renderer = T_),
  (oe.TextRenderer = p3),
  (oe.Lexer = aa),
  (oe.lexer = aa.lex),
  (oe.Tokenizer = g_),
  (oe.Hooks = k_),
  (oe.parse = oe)
var tBt = oe.options,
  eBt = oe.setOptions,
  iBt = oe.use,
  rBt = oe.walkTokens,
  nBt = oe.parseInline,
  sBt = oa.parse,
  aBt = aa.lex
function mlt(i) {
  return JSON.stringify(i, hlt)
}
function $V(i) {
  let t = JSON.parse(i)
  return (t = $i(t)), t
}
function hlt(i, t) {
  return t instanceof RegExp ? { $mid: 2, source: t.source, flags: t.flags } : t
}
function $i(i, t = 0) {
  if (!i || t > 200) return i
  if (typeof i == "object") {
    switch (i.$mid) {
      case 1:
        return S.revive(i)
      case 2:
        return new RegExp(i.source, i.flags)
      case 17:
        return new Date(i.source)
    }
    if (i instanceof Et || i instanceof Uint8Array) return i
    if (Array.isArray(i))
      for (let e = 0; e < i.length; ++e) i[e] = $i(i[e], t + 1)
    else
      for (const e in i)
        Object.hasOwnProperty.call(i, e) && (i[e] = $i(i[e], t + 1))
  }
  return i
}
var kn = Object.freeze({
    text: "text/plain",
    binary: "application/octet-stream",
    unknown: "application/unknown",
    markdown: "text/markdown",
    latex: "text/latex",
    uriList: "text/uri-list",
  }),
  flt = /^(.+)\/(.+?)(;.+)?$/
function xV(i, t) {
  const e = flt.exec(i)
  return e
    ? `${e[1].toLowerCase()}/${e[2].toLowerCase()}${e[3] ?? ""}`
    : t
      ? void 0
      : i
}
var ki = Symbol("unset"),
  plt = class {
    constructor() {
      ;(this.root = new g3()), (this.a = 0)
    }
    get size() {
      return this.a
    }
    get nodes() {
      return this.root.children?.values() || Yi.empty()
    }
    get entries() {
      return this.root.children?.entries() || Yi.empty()
    }
    insert(i, t, e) {
      this.c(i, (r) => (r._value = t), e)
    }
    mutate(i, t) {
      this.c(i, (e) => (e._value = t(e._value === ki ? void 0 : e._value)))
    }
    mutatePath(i, t) {
      this.c(
        i,
        () => {},
        (e) => t(e),
      )
    }
    delete(i) {
      const t = this.b(i)
      if (!t) return
      let e = t.length - 1
      const r = t[e].node._value
      if (r !== ki) {
        for (this.a--, t[e].node._value = ki; e > 0; e--) {
          const { node: s, part: a } = t[e]
          if (s.children?.size || s._value !== ki) break
          t[e - 1].node.children.delete(a)
        }
        return r
      }
    }
    *deleteRecursive(i) {
      const t = this.b(i)
      if (!t) return
      const e = t[t.length - 1].node
      for (let r = t.length - 1; r > 0; r--) {
        const s = t[r - 1]
        if (
          (s.node.children.delete(t[r].part),
          s.node.children.size > 0 || s.node._value !== ki)
        )
          break
      }
      for (const r of JV(e)) r._value !== ki && (this.a--, yield r._value)
      e === this.root &&
        ((this.root._value = ki), (this.root.children = void 0))
    }
    find(i) {
      let t = this.root
      for (const e of i) {
        const r = t.children?.get(e)
        if (!r) return
        t = r
      }
      return t._value === ki ? void 0 : t._value
    }
    hasKeyOrParent(i) {
      let t = this.root
      for (const e of i) {
        const r = t.children?.get(e)
        if (!r) return !1
        if (r._value !== ki) return !0
        t = r
      }
      return !1
    }
    hasKeyOrChildren(i) {
      let t = this.root
      for (const e of i) {
        const r = t.children?.get(e)
        if (!r) return !1
        t = r
      }
      return !0
    }
    hasKey(i) {
      let t = this.root
      for (const e of i) {
        const r = t.children?.get(e)
        if (!r) return !1
        t = r
      }
      return t._value !== ki
    }
    b(i) {
      const t = [{ part: "", node: this.root }]
      let e = 0
      for (const r of i) {
        const s = t[e].node.children?.get(r)
        if (!s) return
        t.push({ part: r, node: s }), e++
      }
      return t
    }
    c(i, t, e) {
      let r = this.root
      for (const o of i) {
        if (r.children)
          if (r.children.has(o)) r = r.children.get(o)
          else {
            const c = new g3()
            r.children.set(o, c), (r = c)
          }
        else {
          const c = new g3()
          ;(r.children = new Map([[o, c]])), (r = c)
        }
        e?.(r)
      }
      const s = r._value === ki ? 0 : 1
      t(r)
      const a = r._value === ki ? 0 : 1
      this.a += a - s
    }
    *values() {
      for (const { _value: i } of JV(this.root)) i !== ki && (yield i)
    }
  }
function* JV(i) {
  const t = [i]
  for (; t.length > 0; ) {
    const e = t.pop()
    if ((yield e, e.children)) for (const r of e.children.values()) t.push(r)
  }
}
var g3 = class {
    constructor() {
      this._value = ki
    }
    get value() {
      return this._value === ki ? void 0 : this._value
    }
    set value(i) {
      this._value = i === void 0 ? ki : i
    }
  },
  tr = class Xa {
    constructor(t, e) {
      ;(this.lineNumber = t), (this.column = e)
    }
    with(t = this.lineNumber, e = this.column) {
      return t === this.lineNumber && e === this.column ? this : new Xa(t, e)
    }
    delta(t = 0, e = 0) {
      return this.with(this.lineNumber + t, this.column + e)
    }
    equals(t) {
      return Xa.equals(this, t)
    }
    static equals(t, e) {
      return !t && !e
        ? !0
        : !!t && !!e && t.lineNumber === e.lineNumber && t.column === e.column
    }
    isBefore(t) {
      return Xa.isBefore(this, t)
    }
    static isBefore(t, e) {
      return t.lineNumber < e.lineNumber
        ? !0
        : e.lineNumber < t.lineNumber
          ? !1
          : t.column < e.column
    }
    isBeforeOrEqual(t) {
      return Xa.isBeforeOrEqual(this, t)
    }
    static isBeforeOrEqual(t, e) {
      return t.lineNumber < e.lineNumber
        ? !0
        : e.lineNumber < t.lineNumber
          ? !1
          : t.column <= e.column
    }
    static compare(t, e) {
      const r = t.lineNumber | 0,
        s = e.lineNumber | 0
      if (r === s) {
        const a = t.column | 0,
          o = e.column | 0
        return a - o
      }
      return r - s
    }
    clone() {
      return new Xa(this.lineNumber, this.column)
    }
    toString() {
      return "(" + this.lineNumber + "," + this.column + ")"
    }
    static lift(t) {
      return new Xa(t.lineNumber, t.column)
    }
    static isIPosition(t) {
      return t && typeof t.lineNumber == "number" && typeof t.column == "number"
    }
    toJSON() {
      return { lineNumber: this.lineNumber, column: this.column }
    }
  },
  re = class Se {
    constructor(t, e, r, s) {
      let a, o, c, u
      t == null || typeof t == "number" || Number.isNaN(t)
        ? ((a = t), (o = e), (c = r), (u = s))
        : "startLineNumber" in t && "startColumn" in t
          ? ((a = t.startLineNumber),
            (o = t.startColumn),
            (c = t.endLineNumber),
            (u = t.endColumn))
          : ((a = t.startLineNumber),
            (o = 1),
            (c = t.endLineNumberExclusive),
            (u = 1)),
        a > c || (a === c && o > u)
          ? ((this.startLineNumber = c),
            (this.startColumn = u),
            (this.endLineNumber = a),
            (this.endColumn = o))
          : ((this.startLineNumber = a),
            (this.startColumn = o),
            (this.endLineNumber = c),
            (this.endColumn = u))
    }
    asIRange() {
      return {
        startLineNumber: this.startLineNumber,
        startColumn: this.startColumn,
        endLineNumber: this.endLineNumber,
        endColumn: this.endColumn,
      }
    }
    isEmpty() {
      return Se.isEmpty(this)
    }
    static isEmpty(t) {
      return (
        t.startLineNumber === t.endLineNumber && t.startColumn === t.endColumn
      )
    }
    containsPosition(t) {
      return Se.containsPosition(this, t)
    }
    static containsPosition(t, e) {
      return !(
        e.lineNumber < t.startLineNumber ||
        e.lineNumber > t.endLineNumber ||
        (e.lineNumber === t.startLineNumber && e.column < t.startColumn) ||
        (e.lineNumber === t.endLineNumber && e.column > t.endColumn)
      )
    }
    static strictContainsPosition(t, e) {
      return !(
        e.lineNumber < t.startLineNumber ||
        e.lineNumber > t.endLineNumber ||
        (e.lineNumber === t.startLineNumber && e.column <= t.startColumn) ||
        (e.lineNumber === t.endLineNumber && e.column >= t.endColumn)
      )
    }
    containsRange(t) {
      return Se.containsRange(this, t)
    }
    static containsRange(t, e) {
      return !(
        e.startLineNumber < t.startLineNumber ||
        e.endLineNumber < t.startLineNumber ||
        e.startLineNumber > t.endLineNumber ||
        e.endLineNumber > t.endLineNumber ||
        (e.startLineNumber === t.startLineNumber &&
          e.startColumn < t.startColumn) ||
        (e.endLineNumber === t.endLineNumber && e.endColumn > t.endColumn)
      )
    }
    strictContainsRange(t) {
      return Se.strictContainsRange(this, t)
    }
    static strictContainsRange(t, e) {
      return !(
        e.startLineNumber < t.startLineNumber ||
        e.endLineNumber < t.startLineNumber ||
        e.startLineNumber > t.endLineNumber ||
        e.endLineNumber > t.endLineNumber ||
        (e.startLineNumber === t.startLineNumber &&
          e.startColumn <= t.startColumn) ||
        (e.endLineNumber === t.endLineNumber && e.endColumn >= t.endColumn)
      )
    }
    plusRange(t) {
      return Se.plusRange(this, t)
    }
    static getRangeAbove(t, e) {
      const r = Math.max(t.startLineNumber - e, 1),
        s = t.startLineNumber
      return new Se(r, t.startColumn, s, t.startColumn)
    }
    static getRangeOnBelow(t, e, r) {
      const s = t.endLineNumber,
        a = Math.min(t.endLineNumber + e, r)
      return new Se(s, t.endColumn, a, t.endColumn)
    }
    static getExtendedRange(t, e, r) {
      const s = Math.max(t.startLineNumber - e, 0),
        a = Math.min(t.endLineNumber + e, r)
      return new Se(s, t.startColumn, a, t.endColumn)
    }
    static plusRange(t, e) {
      let r, s, a, o
      return (
        e.startLineNumber < t.startLineNumber
          ? ((r = e.startLineNumber), (s = e.startColumn))
          : e.startLineNumber === t.startLineNumber
            ? ((r = e.startLineNumber),
              (s = Math.min(e.startColumn, t.startColumn)))
            : ((r = t.startLineNumber), (s = t.startColumn)),
        e.endLineNumber > t.endLineNumber
          ? ((a = e.endLineNumber), (o = e.endColumn))
          : e.endLineNumber === t.endLineNumber
            ? ((a = e.endLineNumber), (o = Math.max(e.endColumn, t.endColumn)))
            : ((a = t.endLineNumber), (o = t.endColumn)),
        new Se(r, s, a, o)
      )
    }
    intersectRanges(t) {
      return Se.intersectRanges(this, t)
    }
    static intersectRanges(t, e) {
      let r = t.startLineNumber,
        s = t.startColumn,
        a = t.endLineNumber,
        o = t.endColumn
      const c = e.startLineNumber,
        u = e.startColumn,
        l = e.endLineNumber,
        m = e.endColumn
      return (
        r < c ? ((r = c), (s = u)) : r === c && (s = Math.max(s, u)),
        a > l ? ((a = l), (o = m)) : a === l && (o = Math.min(o, m)),
        r > a || (r === a && s > o) ? null : new Se(r, s, a, o)
      )
    }
    static inverseEditRange(t, e) {
      return {
        startLineNumber: t.startLineNumber,
        startColumn: t.startColumn,
        endLineNumber:
          t.startLineNumber +
          e.split(`
`).length -
          1,
        endColumn:
          e.lastIndexOf(`
`) === -1
            ? t.startColumn + e.length
            : e.length -
              e.lastIndexOf(`
`),
      }
    }
    whereIs(t) {
      return t.endLineNumber < this.startLineNumber ||
        (t.endLineNumber === this.startLineNumber &&
          t.endColumn <= this.startColumn)
        ? "before"
        : t.startLineNumber > this.endLineNumber ||
            (t.startLineNumber === this.endLineNumber &&
              t.startColumn >= this.endColumn)
          ? "after"
          : "overlapping"
    }
    static rangeAfterEdit(t, e) {
      const r = Se.lift(t).whereIs(e.range)
      switch (r) {
        case "overlapping":
          throw new Error(
            "Range is overlapping. The range after edit is ambiguous.",
          )
        case "after":
          return t
        case "before": {
          const s =
            e.text.split(`
`).length -
            1 -
            (e.range.endLineNumber - e.range.startLineNumber)
          if (e.range.endLineNumber < t.startLineNumber)
            return {
              startLineNumber: t.startLineNumber + s,
              startColumn: t.startColumn,
              endLineNumber: t.endLineNumber + s,
              endColumn: t.endColumn,
            }
          {
            const a =
                e.text.lastIndexOf(`
`) === -1
                  ? e.text.length
                  : e.text.length -
                    e.text.lastIndexOf(`
`) -
                    1,
              o =
                e.range.startLineNumber === e.range.endLineNumber
                  ? e.range.endColumn - e.range.startColumn
                  : e.range.endColumn - 1,
              c = a - o
            return {
              startLineNumber: t.startLineNumber + s,
              startColumn: t.startColumn + c,
              endLineNumber: t.endLineNumber + s,
              endColumn:
                t.startLineNumber === t.endLineNumber
                  ? t.endColumn + c
                  : t.endColumn,
            }
          }
        }
        default: {
          const s = r
          return t
        }
      }
    }
    equalsRange(t) {
      return Se.equalsRange(this, t)
    }
    static equalsRange(t, e) {
      return !t && !e
        ? !0
        : !!t &&
            !!e &&
            t.startLineNumber === e.startLineNumber &&
            t.startColumn === e.startColumn &&
            t.endLineNumber === e.endLineNumber &&
            t.endColumn === e.endColumn
    }
    getEndPosition() {
      return Se.getEndPosition(this)
    }
    static getEndPosition(t) {
      return new tr(t.endLineNumber, t.endColumn)
    }
    getStartPosition() {
      return Se.getStartPosition(this)
    }
    static getStartPosition(t) {
      return new tr(t.startLineNumber, t.startColumn)
    }
    toString() {
      return (
        "[" +
        this.startLineNumber +
        "," +
        this.startColumn +
        " -> " +
        this.endLineNumber +
        "," +
        this.endColumn +
        "]"
      )
    }
    setEndPosition(t, e) {
      return new Se(this.startLineNumber, this.startColumn, t, e)
    }
    setStartPosition(t, e) {
      return new Se(t, e, this.endLineNumber, this.endColumn)
    }
    collapseToStart() {
      return Se.collapseToStart(this)
    }
    static collapseToStart(t) {
      return new Se(
        t.startLineNumber,
        t.startColumn,
        t.startLineNumber,
        t.startColumn,
      )
    }
    collapseToEnd() {
      return Se.collapseToEnd(this)
    }
    static collapseToEnd(t) {
      return new Se(t.endLineNumber, t.endColumn, t.endLineNumber, t.endColumn)
    }
    delta(t) {
      return new Se(
        this.startLineNumber + t,
        this.startColumn,
        this.endLineNumber + t,
        this.endColumn,
      )
    }
    static fromPositions(t, e = t) {
      return new Se(t.lineNumber, t.column, e.lineNumber, e.column)
    }
    static lift(t) {
      return t
        ? new Se(t.startLineNumber, t.startColumn, t.endLineNumber, t.endColumn)
        : null
    }
    static isIRange(t) {
      return (
        t &&
        typeof t.startLineNumber == "number" &&
        typeof t.startColumn == "number" &&
        typeof t.endLineNumber == "number" &&
        typeof t.endColumn == "number"
      )
    }
    static areIntersectingOrTouching(t, e) {
      return !(
        t.endLineNumber < e.startLineNumber ||
        (t.endLineNumber === e.startLineNumber &&
          t.endColumn < e.startColumn) ||
        e.endLineNumber < t.startLineNumber ||
        (e.endLineNumber === t.startLineNumber && e.endColumn < t.startColumn)
      )
    }
    static areIntersecting(t, e) {
      return !(
        t.endLineNumber < e.startLineNumber ||
        (t.endLineNumber === e.startLineNumber &&
          t.endColumn <= e.startColumn) ||
        e.endLineNumber < t.startLineNumber ||
        (e.endLineNumber === t.startLineNumber && e.endColumn <= t.startColumn)
      )
    }
    static compareRangesUsingStarts(t, e) {
      if (t && e) {
        const a = t.startLineNumber | 0,
          o = e.startLineNumber | 0
        if (a === o) {
          const c = t.startColumn | 0,
            u = e.startColumn | 0
          if (c === u) {
            const l = t.endLineNumber | 0,
              m = e.endLineNumber | 0
            if (l === m) {
              const h = t.endColumn | 0,
                p = e.endColumn | 0
              return h - p
            }
            return l - m
          }
          return c - u
        }
        return a - o
      }
      return (t ? 1 : 0) - (e ? 1 : 0)
    }
    static compareRangesUsingEnds(t, e) {
      return t.endLineNumber === e.endLineNumber
        ? t.endColumn === e.endColumn
          ? t.startLineNumber === e.startLineNumber
            ? t.startColumn - e.startColumn
            : t.startLineNumber - e.startLineNumber
          : t.endColumn - e.endColumn
        : t.endLineNumber - e.endLineNumber
    }
    static spansMultipleLines(t) {
      return t.endLineNumber > t.startLineNumber
    }
    toJSON() {
      return this
    }
  },
  CV = class {
    constructor() {
      ;(this.a = new Map()),
        (this.b = new Map()),
        (this.c = new C()),
        (this.onDidChange = this.c.event),
        (this.d = null)
    }
    handleChange(i) {
      this.c.fire({ changedLanguages: i, changedColorMap: !1 })
    }
    register(i, t) {
      return (
        this.a.set(i, t),
        this.handleChange([i]),
        it(() => {
          this.a.get(i) === t && (this.a.delete(i), this.handleChange([i]))
        })
      )
    }
    get(i) {
      return this.a.get(i) || null
    }
    registerFactory(i, t) {
      this.b.get(i)?.dispose()
      const e = new glt(this, i, t)
      return (
        this.b.set(i, e),
        it(() => {
          const r = this.b.get(i)
          !r || r !== e || (this.b.delete(i), r.dispose())
        })
      )
    }
    async getOrCreate(i) {
      const t = this.get(i)
      if (t) return t
      const e = this.b.get(i)
      return !e || e.isResolved ? null : (await e.resolve(), this.get(i))
    }
    isResolved(i) {
      if (this.get(i)) return !0
      const e = this.b.get(i)
      return !!(!e || e.isResolved)
    }
    setColorMap(i) {
      ;(this.d = i),
        this.c.fire({
          changedLanguages: Array.from(this.a.keys()),
          changedColorMap: !0,
        })
    }
    getColorMap() {
      return this.d
    }
    getDefaultBackground() {
      return this.d && this.d.length > 2 ? this.d[2] : null
    }
  },
  glt = class extends dt {
    get isResolved() {
      return this.c
    }
    constructor(i, t, e) {
      super(),
        (this.f = i),
        (this.g = t),
        (this.h = e),
        (this.a = !1),
        (this.b = null),
        (this.c = !1)
    }
    dispose() {
      ;(this.a = !0), super.dispose()
    }
    async resolve() {
      return this.b || (this.b = this.j()), this.b
    }
    async j() {
      const i = await this.h.tokenizationSupport
      ;(this.c = !0), i && !this.a && this.D(this.f.register(this.g, i))
    }
  },
  LV
;(function (i) {
  ;(i[(i.Increase = 0)] = "Increase"), (i[(i.Decrease = 1)] = "Decrease")
})(LV || (LV = {}))
var RV
;(function (i) {
  ;(i[(i.Method = 0)] = "Method"),
    (i[(i.Function = 1)] = "Function"),
    (i[(i.Constructor = 2)] = "Constructor"),
    (i[(i.Field = 3)] = "Field"),
    (i[(i.Variable = 4)] = "Variable"),
    (i[(i.Class = 5)] = "Class"),
    (i[(i.Struct = 6)] = "Struct"),
    (i[(i.Interface = 7)] = "Interface"),
    (i[(i.Module = 8)] = "Module"),
    (i[(i.Property = 9)] = "Property"),
    (i[(i.Event = 10)] = "Event"),
    (i[(i.Operator = 11)] = "Operator"),
    (i[(i.Unit = 12)] = "Unit"),
    (i[(i.Value = 13)] = "Value"),
    (i[(i.Constant = 14)] = "Constant"),
    (i[(i.Enum = 15)] = "Enum"),
    (i[(i.EnumMember = 16)] = "EnumMember"),
    (i[(i.Keyword = 17)] = "Keyword"),
    (i[(i.Text = 18)] = "Text"),
    (i[(i.Color = 19)] = "Color"),
    (i[(i.File = 20)] = "File"),
    (i[(i.Reference = 21)] = "Reference"),
    (i[(i.Customcolor = 22)] = "Customcolor"),
    (i[(i.Folder = 23)] = "Folder"),
    (i[(i.TypeParameter = 24)] = "TypeParameter"),
    (i[(i.User = 25)] = "User"),
    (i[(i.Issue = 26)] = "Issue"),
    (i[(i.Snippet = 27)] = "Snippet")
})(RV || (RV = {}))
var DV
;(function (i) {
  const t = new Map()
  t.set(0, ut.symbolMethod),
    t.set(1, ut.symbolFunction),
    t.set(2, ut.symbolConstructor),
    t.set(3, ut.symbolField),
    t.set(4, ut.symbolVariable),
    t.set(5, ut.symbolClass),
    t.set(6, ut.symbolStruct),
    t.set(7, ut.symbolInterface),
    t.set(8, ut.symbolModule),
    t.set(9, ut.symbolProperty),
    t.set(10, ut.symbolEvent),
    t.set(11, ut.symbolOperator),
    t.set(12, ut.symbolUnit),
    t.set(13, ut.symbolValue),
    t.set(15, ut.symbolEnum),
    t.set(14, ut.symbolConstant),
    t.set(15, ut.symbolEnum),
    t.set(16, ut.symbolEnumMember),
    t.set(17, ut.symbolKeyword),
    t.set(27, ut.symbolSnippet),
    t.set(18, ut.symbolText),
    t.set(19, ut.symbolColor),
    t.set(20, ut.symbolFile),
    t.set(21, ut.symbolReference),
    t.set(22, ut.symbolCustomColor),
    t.set(23, ut.symbolFolder),
    t.set(24, ut.symbolTypeParameter),
    t.set(25, ut.account),
    t.set(26, ut.issues)
  function e(a) {
    let o = t.get(a)
    return (
      o ||
        (console.info("No codicon found for CompletionItemKind " + a),
        (o = ut.symbolProperty)),
      o
    )
  }
  i.toIcon = e
  const r = new Map()
  r.set("method", 0),
    r.set("function", 1),
    r.set("constructor", 2),
    r.set("field", 3),
    r.set("variable", 4),
    r.set("class", 5),
    r.set("struct", 6),
    r.set("interface", 7),
    r.set("module", 8),
    r.set("property", 9),
    r.set("event", 10),
    r.set("operator", 11),
    r.set("unit", 12),
    r.set("value", 13),
    r.set("constant", 14),
    r.set("enum", 15),
    r.set("enum-member", 16),
    r.set("enumMember", 16),
    r.set("keyword", 17),
    r.set("snippet", 27),
    r.set("text", 18),
    r.set("color", 19),
    r.set("file", 20),
    r.set("reference", 21),
    r.set("customcolor", 22),
    r.set("folder", 23),
    r.set("type-parameter", 24),
    r.set("typeParameter", 24),
    r.set("account", 25),
    r.set("issue", 26)
  function s(a, o) {
    let c = r.get(a)
    return typeof c > "u" && !o && (c = 9), c
  }
  i.fromString = s
})(DV || (DV = {}))
var FV
;(function (i) {
  i[(i.Deprecated = 1)] = "Deprecated"
})(FV || (FV = {}))
var _V
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.KeepWhitespace = 1)] = "KeepWhitespace"),
    (i[(i.InsertAsSnippet = 4)] = "InsertAsSnippet")
})(_V || (_V = {}))
var AV
;(function (i) {
  ;(i[(i.Word = 0)] = "Word"),
    (i[(i.Line = 1)] = "Line"),
    (i[(i.Suggest = 2)] = "Suggest")
})(AV || (AV = {}))
var BV
;(function (i) {
  ;(i[(i.Invoke = 0)] = "Invoke"),
    (i[(i.TriggerCharacter = 1)] = "TriggerCharacter"),
    (i[(i.TriggerForIncompleteCompletions = 2)] =
      "TriggerForIncompleteCompletions")
})(BV || (BV = {}))
var S_
;(function (i) {
  ;(i[(i.Automatic = 0)] = "Automatic"), (i[(i.Explicit = 1)] = "Explicit")
})(S_ || (S_ = {}))
var OV
;(function (i) {
  ;(i[(i.Invoke = 1)] = "Invoke"), (i[(i.Auto = 2)] = "Auto")
})(OV || (OV = {}))
var qV
;(function (i) {
  ;(i[(i.Automatic = 0)] = "Automatic"), (i[(i.PasteAs = 1)] = "PasteAs")
})(qV || (qV = {}))
var UV
;(function (i) {
  ;(i[(i.Invoke = 1)] = "Invoke"),
    (i[(i.TriggerCharacter = 2)] = "TriggerCharacter"),
    (i[(i.ContentChange = 3)] = "ContentChange")
})(UV || (UV = {}))
var MV
;(function (i) {
  ;(i[(i.Text = 0)] = "Text"),
    (i[(i.Read = 1)] = "Read"),
    (i[(i.Write = 2)] = "Write")
})(MV || (MV = {}))
function vlt(i) {
  return (
    i &&
    S.isUri(i.uri) &&
    re.isIRange(i.range) &&
    (re.isIRange(i.originSelectionRange) || re.isIRange(i.targetSelectionRange))
  )
}
var HV
;(function (i) {
  ;(i[(i.File = 0)] = "File"),
    (i[(i.Module = 1)] = "Module"),
    (i[(i.Namespace = 2)] = "Namespace"),
    (i[(i.Package = 3)] = "Package"),
    (i[(i.Class = 4)] = "Class"),
    (i[(i.Method = 5)] = "Method"),
    (i[(i.Property = 6)] = "Property"),
    (i[(i.Field = 7)] = "Field"),
    (i[(i.Constructor = 8)] = "Constructor"),
    (i[(i.Enum = 9)] = "Enum"),
    (i[(i.Interface = 10)] = "Interface"),
    (i[(i.Function = 11)] = "Function"),
    (i[(i.Variable = 12)] = "Variable"),
    (i[(i.Constant = 13)] = "Constant"),
    (i[(i.String = 14)] = "String"),
    (i[(i.Number = 15)] = "Number"),
    (i[(i.Boolean = 16)] = "Boolean"),
    (i[(i.Array = 17)] = "Array"),
    (i[(i.Object = 18)] = "Object"),
    (i[(i.Key = 19)] = "Key"),
    (i[(i.Null = 20)] = "Null"),
    (i[(i.EnumMember = 21)] = "EnumMember"),
    (i[(i.Struct = 22)] = "Struct"),
    (i[(i.Event = 23)] = "Event"),
    (i[(i.Operator = 24)] = "Operator"),
    (i[(i.TypeParameter = 25)] = "TypeParameter")
})(HV || (HV = {}))
var oBt = {
    17: f(806, null),
    16: f(807, null),
    4: f(808, null),
    13: f(809, null),
    8: f(810, null),
    9: f(811, null),
    21: f(812, null),
    23: f(813, null),
    7: f(814, null),
    0: f(815, null),
    11: f(816, null),
    10: f(817, null),
    19: f(818, null),
    5: f(819, null),
    1: f(820, null),
    2: f(821, null),
    20: f(822, null),
    15: f(823, null),
    18: f(824, null),
    24: f(825, null),
    3: f(826, null),
    6: f(827, null),
    14: f(828, null),
    22: f(829, null),
    25: f(830, null),
    12: f(831, null),
  },
  WV
;(function (i) {
  i[(i.Deprecated = 1)] = "Deprecated"
})(WV || (WV = {}))
var jV
;(function (i) {
  const t = new Map()
  t.set(0, ut.symbolFile),
    t.set(1, ut.symbolModule),
    t.set(2, ut.symbolNamespace),
    t.set(3, ut.symbolPackage),
    t.set(4, ut.symbolClass),
    t.set(5, ut.symbolMethod),
    t.set(6, ut.symbolProperty),
    t.set(7, ut.symbolField),
    t.set(8, ut.symbolConstructor),
    t.set(9, ut.symbolEnum),
    t.set(10, ut.symbolInterface),
    t.set(11, ut.symbolFunction),
    t.set(12, ut.symbolVariable),
    t.set(13, ut.symbolConstant),
    t.set(14, ut.symbolString),
    t.set(15, ut.symbolNumber),
    t.set(16, ut.symbolBoolean),
    t.set(17, ut.symbolArray),
    t.set(18, ut.symbolObject),
    t.set(19, ut.symbolKey),
    t.set(20, ut.symbolNull),
    t.set(21, ut.symbolEnumMember),
    t.set(22, ut.symbolStruct),
    t.set(23, ut.symbolEvent),
    t.set(24, ut.symbolOperator),
    t.set(25, ut.symbolTypeParameter)
  function e(a) {
    let o = t.get(a)
    return (
      o ||
        (console.info("No codicon found for SymbolKind " + a),
        (o = ut.symbolProperty)),
      o
    )
  }
  i.toIcon = e
  const r = new Map()
  r.set(0, 20),
    r.set(1, 8),
    r.set(2, 8),
    r.set(3, 8),
    r.set(4, 5),
    r.set(5, 0),
    r.set(6, 9),
    r.set(7, 3),
    r.set(8, 2),
    r.set(9, 15),
    r.set(10, 7),
    r.set(11, 1),
    r.set(12, 4),
    r.set(13, 14),
    r.set(14, 18),
    r.set(15, 13),
    r.set(16, 13),
    r.set(17, 13),
    r.set(18, 13),
    r.set(19, 17),
    r.set(20, 13),
    r.set(21, 16),
    r.set(22, 6),
    r.set(23, 10),
    r.set(24, 11),
    r.set(25, 24)
  function s(a) {
    let o = r.get(a)
    return (
      o === void 0 &&
        (console.info("No completion kind found for SymbolKind " + a),
        (o = 20)),
      o
    )
  }
  i.toCompletionKind = s
})(jV || (jV = {}))
var So = class Hs {
    static {
      this.Comment = new Hs("comment")
    }
    static {
      this.Imports = new Hs("imports")
    }
    static {
      this.Region = new Hs("region")
    }
    static fromValue(t) {
      switch (t) {
        case "comment":
          return Hs.Comment
        case "imports":
          return Hs.Imports
        case "region":
          return Hs.Region
      }
      return new Hs(t)
    }
    constructor(t) {
      this.value = t
    }
  },
  VV
;(function (i) {
  i[(i.AIGenerated = 1)] = "AIGenerated"
})(VV || (VV = {}))
var b_
;(function (i) {
  ;(i[(i.Invoke = 0)] = "Invoke"), (i[(i.Automatic = 1)] = "Automatic")
})(b_ || (b_ = {}))
var v3
;(function (i) {
  function t(e) {
    return !e || typeof e != "object"
      ? !1
      : typeof e.id == "string" && typeof e.title == "string"
  }
  i.is = t
})(v3 || (v3 = {}))
var bo
;(function (i) {
  ;(i[(i.Collapsed = 0)] = "Collapsed"), (i[(i.Expanded = 1)] = "Expanded")
})(bo || (bo = {}))
var Qu
;(function (i) {
  ;(i[(i.Unresolved = 0)] = "Unresolved"), (i[(i.Resolved = 1)] = "Resolved")
})(Qu || (Qu = {}))
var Xu
;(function (i) {
  ;(i[(i.Current = 0)] = "Current"), (i[(i.Outdated = 1)] = "Outdated")
})(Xu || (Xu = {}))
var GV
;(function (i) {
  ;(i[(i.Editing = 0)] = "Editing"), (i[(i.Preview = 1)] = "Preview")
})(GV || (GV = {}))
var zV
;(function (i) {
  ;(i[(i.Published = 0)] = "Published"), (i[(i.Draft = 1)] = "Draft")
})(zV || (zV = {}))
var YV
;(function (i) {
  ;(i[(i.Type = 1)] = "Type"), (i[(i.Parameter = 2)] = "Parameter")
})(YV || (YV = {}))
var cBt = new CV(),
  uBt = new CV(),
  QV
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Option = 1)] = "Option"),
    (i[(i.Default = 2)] = "Default"),
    (i[(i.Preferred = 3)] = "Preferred")
})(QV || (QV = {}))
var E_
;(function (i) {
  ;(i[(i.Invoke = 0)] = "Invoke"), (i[(i.Automatic = 1)] = "Automatic")
})(E_ || (E_ = {}))
var XV
;(function (i) {
  ;(i[(i.Unnecessary = 1)] = "Unnecessary"),
    (i[(i.Deprecated = 2)] = "Deprecated")
})(XV || (XV = {}))
var xi
;(function (i) {
  ;(i[(i.Hint = 1)] = "Hint"),
    (i[(i.Info = 2)] = "Info"),
    (i[(i.AI = 3)] = "AI"),
    (i[(i.Warning = 4)] = "Warning"),
    (i[(i.Error = 8)] = "Error")
})(xi || (xi = {})),
  (function (i) {
    function t(o, c) {
      return c - o
    }
    i.compare = t
    const e = Object.create(null)
    ;(e[i.Error] = f(2010, null)),
      (e[i.Warning] = f(2011, null)),
      (e[i.Info] = f(2012, null)),
      (e[i.AI] = "AI Hint")
    function r(o) {
      return e[o] || ""
    }
    i.toString = r
    function s(o) {
      switch (o) {
        case ke.Error:
          return i.Error
        case ke.Warning:
          return i.Warning
        case ke.Info:
          return i.Info
        case ke.Ignore:
          return i.Hint
        case ke.AI:
          return i.AI
      }
    }
    i.fromSeverity = s
    function a(o) {
      switch (o) {
        case i.Error:
          return ke.Error
        case i.Warning:
          return ke.Warning
        case i.Info:
          return ke.Info
        case i.Hint:
          return ke.Ignore
        case i.AI:
          return ke.AI
      }
    }
    i.toSeverity = a
  })(xi || (xi = {}))
var KV
;(function (i) {
  const t = ""
  function e(s) {
    return r(s, !0)
  }
  i.makeKey = e
  function r(s, a) {
    const o = [t]
    return (
      s.source ? o.push(s.source.replace("\xA6", "\\\xA6")) : o.push(t),
      s.code
        ? typeof s.code == "string"
          ? o.push(s.code.replace("\xA6", "\\\xA6"))
          : o.push(s.code.value.replace("\xA6", "\\\xA6"))
        : o.push(t),
      s.severity !== void 0 && s.severity !== null
        ? o.push(xi.toString(s.severity))
        : o.push(t),
      s.message && a ? o.push(s.message.replace("\xA6", "\\\xA6")) : o.push(t),
      s.startLineNumber !== void 0 && s.startLineNumber !== null
        ? o.push(s.startLineNumber.toString())
        : o.push(t),
      s.startColumn !== void 0 && s.startColumn !== null
        ? o.push(s.startColumn.toString())
        : o.push(t),
      s.endLineNumber !== void 0 && s.endLineNumber !== null
        ? o.push(s.endLineNumber.toString())
        : o.push(t),
      s.endColumn !== void 0 && s.endColumn !== null
        ? o.push(s.endColumn.toString())
        : o.push(t),
      o.push(t),
      o.join("\xA6")
    )
  }
  i.makeKeyOptionalMessage = r
})(KV || (KV = {}))
var lBt = Y("markerService")
function Ji(i, t) {
  if (!i) throw new Error(t ? `Assertion failed (${t})` : "Assertion Failed")
}
function wlt(i, t = "Unreachable") {
  throw new Error(t)
}
function ZV(i) {
  if (!i()) {
    debugger
    i(), Ui(new no("Assertion Failed"))
  }
}
var ylt = class {
    constructor() {
      this.a = new Map()
    }
    add(i, t) {
      Ji(Bt(i)),
        Ji(Ce(t)),
        Ji(!this.a.has(i), "There is already an extension with this id"),
        this.a.set(i, t)
    }
    knows(i) {
      return this.a.has(i)
    }
    as(i) {
      return this.a.get(i) || null
    }
  },
  ui = new ylt(),
  Tlt = Y("fileService"),
  ua
;(function (i) {
  ;(i[(i.Unknown = 0)] = "Unknown"),
    (i[(i.File = 1)] = "File"),
    (i[(i.Directory = 2)] = "Directory"),
    (i[(i.SymbolicLink = 64)] = "SymbolicLink")
})(ua || (ua = {}))
var Eo
;(function (i) {
  ;(i[(i.Readonly = 1)] = "Readonly"), (i[(i.Locked = 2)] = "Locked")
})(Eo || (Eo = {}))
var tG
;(function (i) {
  ;(i[(i.UPDATED = 2)] = "UPDATED"),
    (i[(i.ADDED = 4)] = "ADDED"),
    (i[(i.DELETED = 8)] = "DELETED")
})(tG || (tG = {}))
var eG
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.FileReadWrite = 2)] = "FileReadWrite"),
    (i[(i.FileOpenReadWriteClose = 4)] = "FileOpenReadWriteClose"),
    (i[(i.FileReadStream = 16)] = "FileReadStream"),
    (i[(i.FileFolderCopy = 8)] = "FileFolderCopy"),
    (i[(i.PathCaseSensitive = 1024)] = "PathCaseSensitive"),
    (i[(i.Readonly = 2048)] = "Readonly"),
    (i[(i.Trash = 4096)] = "Trash"),
    (i[(i.FileWriteUnlock = 8192)] = "FileWriteUnlock"),
    (i[(i.FileAtomicRead = 16384)] = "FileAtomicRead"),
    (i[(i.FileAtomicWrite = 32768)] = "FileAtomicWrite"),
    (i[(i.FileAtomicDelete = 65536)] = "FileAtomicDelete"),
    (i[(i.FileClone = 131072)] = "FileClone")
})(eG || (eG = {}))
var It
;(function (i) {
  ;(i.FileExists = "EntryExists"),
    (i.FileNotFound = "EntryNotFound"),
    (i.FileNotADirectory = "EntryNotADirectory"),
    (i.FileIsADirectory = "EntryIsADirectory"),
    (i.FileExceedsStorageQuota = "EntryExceedsStorageQuota"),
    (i.FileTooLarge = "EntryTooLarge"),
    (i.FileWriteLocked = "EntryWriteLocked"),
    (i.NoPermissions = "NoPermissions"),
    (i.Unavailable = "Unavailable"),
    (i.Unknown = "Unknown")
})(It || (It = {}))
var iG = class Bnt extends Error {
  static create(t, e) {
    const r = new Bnt(t.toString(), e)
    return rG(r, e), r
  }
  constructor(t, e) {
    super(t), (this.code = e)
  }
}
function rG(i, t) {
  return (i.name = t ? `${t} (FileSystemError)` : "FileSystemError"), i
}
function I_(i) {
  if (!i) return It.Unknown
  if (i instanceof iG) return i.code
  const t = /^(.+) \(FileSystemError\)$/.exec(i.name)
  if (!t) return It.Unknown
  switch (t[1]) {
    case It.FileExists:
      return It.FileExists
    case It.FileIsADirectory:
      return It.FileIsADirectory
    case It.FileNotADirectory:
      return It.FileNotADirectory
    case It.FileNotFound:
      return It.FileNotFound
    case It.FileTooLarge:
      return It.FileTooLarge
    case It.FileWriteLocked:
      return It.FileWriteLocked
    case It.NoPermissions:
      return It.NoPermissions
    case It.Unavailable:
      return It.Unavailable
  }
  return It.Unknown
}
function klt(i) {
  if (i instanceof w3) return i.fileOperationResult
  switch (I_(i)) {
    case It.FileNotFound:
      return 1
    case It.FileIsADirectory:
      return 0
    case It.FileNotADirectory:
      return 9
    case It.FileWriteLocked:
      return 5
    case It.NoPermissions:
      return 6
    case It.FileExists:
      return 4
    case It.FileTooLarge:
      return 7
    default:
      return 10
  }
}
var nG
;(function (i) {
  ;(i[(i.CREATE = 0)] = "CREATE"),
    (i[(i.DELETE = 1)] = "DELETE"),
    (i[(i.MOVE = 2)] = "MOVE"),
    (i[(i.COPY = 3)] = "COPY"),
    (i[(i.WRITE = 4)] = "WRITE")
})(nG || (nG = {}))
var sG
;(function (i) {
  ;(i[(i.UPDATED = 0)] = "UPDATED"),
    (i[(i.ADDED = 1)] = "ADDED"),
    (i[(i.DELETED = 2)] = "DELETED")
})(sG || (sG = {}))
var dBt = class q8 {
    static {
      this.a = null
    }
    constructor(t, e) {
      ;(this.c = e),
        (this.b = void 0),
        (this.d = new qi(() => {
          const r = ls.forUris(() => this.c)
          return r.fill(this.rawAdded.map((s) => [s, !0])), r
        })),
        (this.f = new qi(() => {
          const r = ls.forUris(() => this.c)
          return r.fill(this.rawUpdated.map((s) => [s, !0])), r
        })),
        (this.g = new qi(() => {
          const r = ls.forUris(() => this.c)
          return r.fill(this.rawDeleted.map((s) => [s, !0])), r
        })),
        (this.rawAdded = []),
        (this.rawUpdated = []),
        (this.rawDeleted = [])
      for (const r of t) {
        switch (r.type) {
          case 1:
            this.rawAdded.push(r.resource)
            break
          case 0:
            this.rawUpdated.push(r.resource)
            break
          case 2:
            this.rawDeleted.push(r.resource)
            break
        }
        this.b !== q8.a &&
          (typeof r.cId == "number"
            ? this.b === void 0
              ? (this.b = r.cId)
              : this.b !== r.cId && (this.b = q8.a)
            : this.b !== void 0 && (this.b = q8.a))
      }
    }
    contains(t, ...e) {
      return this.h(t, { includeChildren: !1 }, ...e)
    }
    affects(t, ...e) {
      return this.h(t, { includeChildren: !0 }, ...e)
    }
    h(t, e, ...r) {
      if (!t) return !1
      const s = r.length > 0
      return !!(
        ((!s || r.includes(1)) &&
          (this.d.value.get(t) ||
            (e.includeChildren && this.d.value.findSuperstr(t)))) ||
        ((!s || r.includes(0)) &&
          (this.f.value.get(t) ||
            (e.includeChildren && this.f.value.findSuperstr(t)))) ||
        ((!s || r.includes(2)) &&
          (this.g.value.findSubstr(t) ||
            (e.includeChildren && this.g.value.findSuperstr(t))))
      )
    }
    gotAdded() {
      return this.rawAdded.length > 0
    }
    gotDeleted() {
      return this.rawDeleted.length > 0
    }
    gotUpdated() {
      return this.rawUpdated.length > 0
    }
    correlates(t) {
      return this.b === t
    }
    hasCorrelation() {
      return typeof this.b == "number"
    }
  },
  w3 = class extends Error {
    constructor(i, t, e) {
      super(i), (this.fileOperationResult = t), (this.options = e)
    }
  },
  aG
;(function (i) {
  ;(i[(i.FILE_IS_DIRECTORY = 0)] = "FILE_IS_DIRECTORY"),
    (i[(i.FILE_NOT_FOUND = 1)] = "FILE_NOT_FOUND"),
    (i[(i.FILE_NOT_MODIFIED_SINCE = 2)] = "FILE_NOT_MODIFIED_SINCE"),
    (i[(i.FILE_MODIFIED_SINCE = 3)] = "FILE_MODIFIED_SINCE"),
    (i[(i.FILE_MOVE_CONFLICT = 4)] = "FILE_MOVE_CONFLICT"),
    (i[(i.FILE_WRITE_LOCKED = 5)] = "FILE_WRITE_LOCKED"),
    (i[(i.FILE_PERMISSION_DENIED = 6)] = "FILE_PERMISSION_DENIED"),
    (i[(i.FILE_TOO_LARGE = 7)] = "FILE_TOO_LARGE"),
    (i[(i.FILE_INVALID_PATH = 8)] = "FILE_INVALID_PATH"),
    (i[(i.FILE_NOT_DIRECTORY = 9)] = "FILE_NOT_DIRECTORY"),
    (i[(i.FILE_OTHER_ERROR = 10)] = "FILE_OTHER_ERROR")
})(aG || (aG = {}))
var oG
;(function (i) {
  ;(i[(i.FILE = 0)] = "FILE"),
    (i[(i.FOLDER = 1)] = "FOLDER"),
    (i[(i.ROOT_FOLDER = 2)] = "ROOT_FOLDER")
})(oG || (oG = {}))
var Slt = ""
function cG(i) {
  if (!(typeof i.size != "number" || typeof i.mtime != "number"))
    return i.mtime.toString(29) + i.size.toString(31)
}
var mBt = class Bi {
    static {
      this.KB = 1024
    }
    static {
      this.MB = Bi.KB * Bi.KB
    }
    static {
      this.GB = Bi.MB * Bi.KB
    }
    static {
      this.TB = Bi.GB * Bi.KB
    }
    static formatSize(t) {
      return (
        os(t) || (t = 0),
        t < Bi.KB
          ? f(1923, null, t.toFixed(0))
          : t < Bi.MB
            ? f(1924, null, (t / Bi.KB).toFixed(2))
            : t < Bi.GB
              ? f(1925, null, (t / Bi.MB).toFixed(2))
              : t < Bi.TB
                ? f(1926, null, (t / Bi.GB).toFixed(2))
                : f(1927, null, (t / Bi.TB).toFixed(2))
      )
    }
  },
  blt = class extends dt {
    constructor(i, t = "", e = "", r = !0, s) {
      super(),
        (this.j = this.D(new C())),
        (this.onDidChange = this.j.event),
        (this.w = !0),
        (this.m = i),
        (this.n = t),
        (this.u = e),
        (this.w = r),
        (this.C = s)
    }
    get id() {
      return this.m
    }
    get label() {
      return this.n
    }
    set label(i) {
      this.F(i)
    }
    F(i) {
      this.n !== i && ((this.n = i), this.j.fire({ label: i }))
    }
    get tooltip() {
      return this.q || ""
    }
    set tooltip(i) {
      this.G(i)
    }
    G(i) {
      this.q !== i && ((this.q = i), this.j.fire({ tooltip: i }))
    }
    get class() {
      return this.u
    }
    set class(i) {
      this.H(i)
    }
    H(i) {
      this.u !== i && ((this.u = i), this.j.fire({ class: i }))
    }
    get enabled() {
      return this.w
    }
    set enabled(i) {
      this.I(i)
    }
    I(i) {
      this.w !== i && ((this.w = i), this.j.fire({ enabled: i }))
    }
    get checked() {
      return this.z
    }
    set checked(i) {
      this.J(i)
    }
    J(i) {
      this.z !== i && ((this.z = i), this.j.fire({ checked: i }))
    }
    async run(i, t) {
      this.C && (await this.C(i))
    }
  },
  hBt = class fH {
    constructor() {
      ;(this.id = fH.ID),
        (this.label = ""),
        (this.tooltip = ""),
        (this.class = "separator"),
        (this.enabled = !1),
        (this.checked = !1)
    }
    static join(...t) {
      let e = []
      for (const r of t)
        r.length && (e.length ? (e = [...e, new fH(), ...r]) : (e = r))
      return e
    }
    static {
      this.ID = "vs.actions.separator"
    }
    async run() {}
  },
  fBt = class Ont extends blt {
    static {
      this.ID = "vs.actions.empty"
    }
    constructor() {
      super(Ont.ID, f(44, null), void 0, !1)
    }
  },
  Elt = {
    EditorPane: "workbench.contributions.editors",
    EditorFactory: "workbench.contributions.editor.inputFactories",
  },
  Ilt = {
    id: "default",
    displayName: f(4149, null),
    providerDisplayName: f(4150, null),
  },
  uG
;(function (i) {
  ;(i[(i.PROGRAMMATIC = 1)] = "PROGRAMMATIC"),
    (i[(i.USER = 2)] = "USER"),
    (i[(i.EDIT = 3)] = "EDIT"),
    (i[(i.NAVIGATION = 4)] = "NAVIGATION"),
    (i[(i.JUMP = 5)] = "JUMP")
})(uG || (uG = {}))
var lG
;(function (i) {
  ;(i[(i.IDENTICAL = 1)] = "IDENTICAL"),
    (i[(i.SIMILAR = 2)] = "SIMILAR"),
    (i[(i.DIFFERENT = 3)] = "DIFFERENT")
})(lG || (lG = {}))
function P_(i) {
  if (Sn(i)) return !1
  const t = i
  return t?.original !== void 0 && t.modified !== void 0
}
function dG(i) {
  if (Sn(i)) return !1
  const t = i
  return !t || (t.resources && !Array.isArray(t.resources))
    ? !1
    : !!t.resources || !!t.multiDiffSource
}
function mG(i) {
  if (Sn(i)) return !1
  const t = i
  return Array.isArray(t?.resources) && t.resources.every((e) => S.isUri(e))
}
function y3(i) {
  if (Sn(i) || P_(i)) return !1
  const t = i
  return t?.primary !== void 0 && t.secondary !== void 0
}
function N_(i) {
  if (Sn(i)) return !1
  const t = i
  return (
    S.isUri(t?.base?.resource) &&
    S.isUri(t?.input1?.resource) &&
    S.isUri(t?.input2?.resource) &&
    S.isUri(t?.result?.resource)
  )
}
var hG
;(function (i) {
  ;(i[(i.SHORT = 0)] = "SHORT"),
    (i[(i.MEDIUM = 1)] = "MEDIUM"),
    (i[(i.LONG = 2)] = "LONG")
})(hG || (hG = {}))
var fG
;(function (i) {
  ;(i[(i.EXPLICIT = 1)] = "EXPLICIT"),
    (i[(i.AUTO = 2)] = "AUTO"),
    (i[(i.FOCUS_CHANGE = 3)] = "FOCUS_CHANGE"),
    (i[(i.WINDOW_CHANGE = 4)] = "WINDOW_CHANGE")
})(fG || (fG = {}))
var Plt = class {
    constructor() {
      this.a = new Map()
    }
    registerSource(i, t) {
      let e = this.a.get(i)
      return e || ((e = { source: i, label: t }), this.a.set(i, e)), e.source
    }
    getSourceLabel(i) {
      return this.a.get(i)?.label ?? i
    }
  },
  pBt = new Plt(),
  pG
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Readonly = 2)] = "Readonly"),
    (i[(i.Untitled = 4)] = "Untitled"),
    (i[(i.Singleton = 8)] = "Singleton"),
    (i[(i.RequiresTrust = 16)] = "RequiresTrust"),
    (i[(i.CanSplitInGroup = 32)] = "CanSplitInGroup"),
    (i[(i.ForceDescription = 64)] = "ForceDescription"),
    (i[(i.CanDropIntoEditor = 128)] = "CanDropIntoEditor"),
    (i[(i.MultipleEditors = 256)] = "MultipleEditors"),
    (i[(i.Scratchpad = 512)] = "Scratchpad")
})(pG || (pG = {}))
var Nlt = class extends dt {}
function Sn(i) {
  return i instanceof Nlt
}
function $lt(i) {
  const t = i
  return S.isUri(t?.preferredResource)
}
function xlt(i) {
  const t = i
  return Sn(t?.primary) && Sn(t?.secondary)
}
function Jlt(i) {
  const t = i
  return Sn(t?.modified) && Sn(t?.original)
}
var gG
;(function (i) {
  ;(i[(i.UNKNOWN = 0)] = "UNKNOWN"),
    (i[(i.REPLACE = 1)] = "REPLACE"),
    (i[(i.MOVE = 2)] = "MOVE"),
    (i[(i.UNPIN = 3)] = "UNPIN")
})(gG || (gG = {}))
var vG
;(function (i) {
  ;(i[(i.GROUP_ACTIVE = 0)] = "GROUP_ACTIVE"),
    (i[(i.GROUP_INDEX = 1)] = "GROUP_INDEX"),
    (i[(i.GROUP_LABEL = 2)] = "GROUP_LABEL"),
    (i[(i.GROUP_LOCKED = 3)] = "GROUP_LOCKED"),
    (i[(i.EDITORS_SELECTION = 4)] = "EDITORS_SELECTION"),
    (i[(i.EDITOR_OPEN = 5)] = "EDITOR_OPEN"),
    (i[(i.EDITOR_CLOSE = 6)] = "EDITOR_CLOSE"),
    (i[(i.EDITOR_MOVE = 7)] = "EDITOR_MOVE"),
    (i[(i.EDITOR_ACTIVE = 8)] = "EDITOR_ACTIVE"),
    (i[(i.EDITOR_LABEL = 9)] = "EDITOR_LABEL"),
    (i[(i.EDITOR_CAPABILITIES = 10)] = "EDITOR_CAPABILITIES"),
    (i[(i.EDITOR_PIN = 11)] = "EDITOR_PIN"),
    (i[(i.EDITOR_TRANSIENT = 12)] = "EDITOR_TRANSIENT"),
    (i[(i.EDITOR_STICKY = 13)] = "EDITOR_STICKY"),
    (i[(i.EDITOR_DIRTY = 14)] = "EDITOR_DIRTY"),
    (i[(i.EDITOR_WILL_DISPOSE = 15)] = "EDITOR_WILL_DISPOSE")
})(vG || (vG = {}))
var ds
;(function (i) {
  ;(i[(i.PRIMARY = 1)] = "PRIMARY"),
    (i[(i.SECONDARY = 2)] = "SECONDARY"),
    (i[(i.BOTH = 3)] = "BOTH"),
    (i[(i.ANY = 4)] = "ANY")
})(ds || (ds = {}))
var Clt = class {
    getOriginalUri(i, t) {
      if (!i) return
      if (N_(i)) return yG.getOriginalUri(i.result, t)
      if (t?.supportSideBySide) {
        const { primary: r, secondary: s } = this.a(i)
        if (r && s) {
          if (t?.supportSideBySide === ds.BOTH)
            return {
              primary: this.getOriginalUri(r, {
                filterByScheme: t.filterByScheme,
              }),
              secondary: this.getOriginalUri(s, {
                filterByScheme: t.filterByScheme,
              }),
            }
          if (t?.supportSideBySide === ds.ANY)
            return (
              this.getOriginalUri(r, { filterByScheme: t.filterByScheme }) ??
              this.getOriginalUri(s, { filterByScheme: t.filterByScheme })
            )
          i = t.supportSideBySide === ds.PRIMARY ? r : s
        }
      }
      if (P_(i) || dG(i) || y3(i) || N_(i) || mG(i)) return
      const e = $lt(i) ? i.preferredResource : i.resource
      return !e || !t || !t.filterByScheme ? e : this.b(e, t.filterByScheme)
    }
    a(i) {
      return xlt(i) || y3(i)
        ? { primary: i.primary, secondary: i.secondary }
        : Jlt(i) || P_(i)
          ? { primary: i.modified, secondary: i.original }
          : { primary: void 0, secondary: void 0 }
    }
    getCanonicalUri(i, t) {
      if (!i) return
      if (N_(i)) return yG.getCanonicalUri(i.result, t)
      if (t?.supportSideBySide) {
        const { primary: r, secondary: s } = this.a(i)
        if (r && s) {
          if (t?.supportSideBySide === ds.BOTH)
            return {
              primary: this.getCanonicalUri(r, {
                filterByScheme: t.filterByScheme,
              }),
              secondary: this.getCanonicalUri(s, {
                filterByScheme: t.filterByScheme,
              }),
            }
          if (t?.supportSideBySide === ds.ANY)
            return (
              this.getCanonicalUri(r, { filterByScheme: t.filterByScheme }) ??
              this.getCanonicalUri(s, { filterByScheme: t.filterByScheme })
            )
          i = t.supportSideBySide === ds.PRIMARY ? r : s
        }
      }
      if (P_(i) || dG(i) || y3(i) || N_(i) || mG(i)) return
      const e = i.resource
      return !e || !t || !t.filterByScheme ? e : this.b(e, t.filterByScheme)
    }
    b(i, t) {
      if (Array.isArray(t)) {
        if (t.some((e) => i.scheme === e)) return i
      } else if (t === i.scheme) return i
    }
  },
  wG
;(function (i) {
  ;(i[(i.UNKNOWN = 0)] = "UNKNOWN"),
    (i[(i.KEYBOARD = 1)] = "KEYBOARD"),
    (i[(i.MOUSE = 2)] = "MOUSE")
})(wG || (wG = {}))
var yG = new Clt(),
  TG
;(function (i) {
  ;(i[(i.LEFT = 0)] = "LEFT"), (i[(i.RIGHT = 1)] = "RIGHT")
})(TG || (TG = {}))
var Llt = class {
  constructor() {
    ;(this.c = new Map()), (this.d = new Map())
  }
  start(i) {
    const t = (this.a = i.get(l_))
    for (const [e, r] of this.c) this.e(e, r, t)
    this.c.clear()
  }
  e(i, t, e) {
    const r = e.createInstance(t)
    this.d.set(i, r)
  }
  registerFileEditorFactory(i) {
    if (this.b) throw new Error("Can only register one file editor factory.")
    this.b = i
  }
  getFileEditorFactory() {
    return fo(this.b)
  }
  registerEditorSerializer(i, t) {
    if (this.c.has(i) || this.d.has(i))
      throw new Error(
        `A editor serializer with type ID '${i}' was already registered.`,
      )
    return (
      this.a ? this.e(i, t, this.a) : this.c.set(i, t),
      it(() => {
        this.c.delete(i), this.d.delete(i)
      })
    )
  }
  getEditorSerializer(i) {
    return this.d.get(typeof i == "string" ? i : i.typeId)
  }
}
ui.add(Elt.EditorFactory, new Llt())
var kG
;(function (i) {
  ;(i[(i.MOST_RECENTLY_ACTIVE = 0)] = "MOST_RECENTLY_ACTIVE"),
    (i[(i.SEQUENTIAL = 1)] = "SEQUENTIAL")
})(kG || (kG = {}))
var Ku = class {
    constructor(i, t, e) {
      ;(this.owner = i), (this.debugNameSource = t), (this.referenceFn = e)
    }
    getDebugName(i) {
      return Rlt(i, this)
    }
  },
  SG = new Map(),
  T3 = new WeakMap()
function Rlt(i, t) {
  const e = T3.get(i)
  if (e) return e
  const r = Dlt(i, t)
  if (r) {
    let s = SG.get(r) ?? 0
    s++, SG.set(r, s)
    const a = s === 1 ? r : `${r}#${s}`
    return T3.set(i, a), a
  }
}
function Dlt(i, t) {
  const e = T3.get(i)
  if (e) return e
  const r = t.owner ? _lt(t.owner) + "." : ""
  let s
  const a = t.debugNameSource
  if (a !== void 0)
    if (typeof a == "function") {
      if (((s = a()), s !== void 0)) return r + s
    } else return r + a
  const o = t.referenceFn
  if (o !== void 0 && ((s = k3(o)), s !== void 0)) return r + s
  if (t.owner !== void 0) {
    const c = Flt(t.owner, i)
    if (c !== void 0) return r + c
  }
}
function Flt(i, t) {
  for (const e in i) if (i[e] === t) return e
}
var bG = new Map(),
  EG = new WeakMap()
function _lt(i) {
  const t = EG.get(i)
  if (t) return t
  const e = Alt(i)
  let r = bG.get(e) ?? 0
  r++, bG.set(e, r)
  const s = r === 1 ? e : `${e}#${r}`
  return EG.set(i, s), s
}
function Alt(i) {
  const t = i.constructor
  return t ? t.name : "Object"
}
function k3(i) {
  const t = i.toString(),
    r = /\/\*\*\s*@description\s*([^*]*)\*\//.exec(t)
  return (r ? r[1] : void 0)?.trim()
}
var S3 = (i, t) => i === t
function b3(i, t) {
  if (i === t) return !0
  if (Array.isArray(i) && Array.isArray(t)) {
    if (i.length !== t.length) return !1
    for (let e = 0; e < i.length; e++) if (!b3(i[e], t[e])) return !1
    return !0
  }
  if (
    i &&
    typeof i == "object" &&
    t &&
    typeof t == "object" &&
    Object.getPrototypeOf(i) === Object.prototype &&
    Object.getPrototypeOf(t) === Object.prototype
  ) {
    const e = i,
      r = t,
      s = Object.keys(e),
      a = Object.keys(r),
      o = new Set(a)
    if (s.length !== a.length) return !1
    for (const c of s) if (!o.has(c) || !b3(e[c], r[c])) return !1
    return !0
  }
  return !1
}
var IG
function Blt(i) {
  IG = i
}
function Zr() {
  return IG
}
var Olt = class {
  constructor() {
    ;(this.a = 0), (this.d = new WeakMap())
  }
  b(i) {
    return qlt([Io(Hlt("|  ", this.a)), i])
  }
  c(i) {
    return i.hadValue
      ? i.didChange
        ? [
            Io(" "),
            Pr(tl(i.oldValue, 70), { color: "red", strikeThrough: !0 }),
            Io(" "),
            Pr(tl(i.newValue, 60), { color: "green" }),
          ]
        : [Io(" (unchanged)")]
      : [Io(" "), Pr(tl(i.newValue, 60), { color: "green" }), Io(" (initial)")]
  }
  handleObservableChanged(i, t) {
    console.log(
      ...this.b([
        Zu("observable value changed"),
        Pr(i.debugName, { color: "BlueViolet" }),
        ...this.c(t),
      ]),
    )
  }
  formatChanges(i) {
    if (i.size !== 0)
      return Pr(
        " (changed deps: " + [...i].map((t) => t.debugName).join(", ") + ")",
        { color: "gray" },
      )
  }
  handleDerivedCreated(i) {
    const t = i.handleChange
    this.d.set(i, new Set()),
      (i.handleChange = (e, r) => (this.d.get(i).add(e), t.apply(i, [e, r])))
  }
  handleDerivedRecomputed(i, t) {
    const e = this.d.get(i)
    console.log(
      ...this.b([
        Zu("derived recomputed"),
        Pr(i.debugName, { color: "BlueViolet" }),
        ...this.c(t),
        this.formatChanges(e),
        { data: [{ fn: i._debugNameData.referenceFn ?? i._computeFn }] },
      ]),
    ),
      e.clear()
  }
  handleFromEventObservableTriggered(i, t) {
    console.log(
      ...this.b([
        Zu("observable from event triggered"),
        Pr(i.debugName, { color: "BlueViolet" }),
        ...this.c(t),
        { data: [{ fn: i._getValue }] },
      ]),
    )
  }
  handleAutorunCreated(i) {
    const t = i.handleChange
    this.d.set(i, new Set()),
      (i.handleChange = (e, r) => (this.d.get(i).add(e), t.apply(i, [e, r])))
  }
  handleAutorunTriggered(i) {
    const t = this.d.get(i)
    console.log(
      ...this.b([
        Zu("autorun"),
        Pr(i.debugName, { color: "BlueViolet" }),
        this.formatChanges(t),
        { data: [{ fn: i._debugNameData.referenceFn ?? i._runFn }] },
      ]),
    ),
      t.clear(),
      this.a++
  }
  handleAutorunFinished(i) {
    this.a--
  }
  handleBeginTransaction(i) {
    let t = i.getDebugName()
    t === void 0 && (t = ""),
      console.log(
        ...this.b([
          Zu("transaction"),
          Pr(t, { color: "BlueViolet" }),
          { data: [{ fn: i._fn }] },
        ]),
      ),
      this.a++
  }
  handleEndTransaction() {
    this.a--
  }
}
function qlt(i) {
  const t = new Array(),
    e = []
  let r = ""
  function s(o) {
    if ("length" in o) for (const c of o) c && s(c)
    else
      "text" in o
        ? ((r += `%c${o.text}`), t.push(o.style), o.data && e.push(...o.data))
        : "data" in o && e.push(...o.data)
  }
  s(i)
  const a = [r, ...t]
  return a.push(...e), a
}
function Io(i) {
  return Pr(i, { color: "black" })
}
function Zu(i) {
  return Pr(Wlt(`${i}: `, 10), { color: "black", bold: !0 })
}
function Pr(i, t = { color: "black" }) {
  function e(s) {
    return Object.entries(s).reduce((a, [o, c]) => `${a}${o}:${c};`, "")
  }
  const r = { color: t.color }
  return (
    t.strikeThrough && (r["text-decoration"] = "line-through"),
    t.bold && (r["font-weight"] = "bold"),
    { text: i, style: e(r) }
  )
}
function tl(i, t) {
  switch (typeof i) {
    case "number":
      return "" + i
    case "string":
      return i.length + 2 <= t ? `"${i}"` : `"${i.substr(0, t - 7)}"+...`
    case "boolean":
      return i ? "true" : "false"
    case "undefined":
      return "undefined"
    case "object":
      return i === null ? "null" : Array.isArray(i) ? Ult(i, t) : Mlt(i, t)
    case "symbol":
      return i.toString()
    case "function":
      return `[[Function${i.name ? " " + i.name : ""}]]`
    default:
      return "" + i
  }
}
function Ult(i, t) {
  let e = "[ ",
    r = !0
  for (const s of i) {
    if ((r || (e += ", "), e.length - 5 > t)) {
      e += "..."
      break
    }
    ;(r = !1), (e += `${tl(s, t - e.length)}`)
  }
  return (e += " ]"), e
}
function Mlt(i, t) {
  let e = "{ ",
    r = !0
  for (const [s, a] of Object.entries(i)) {
    if ((r || (e += ", "), e.length - 5 > t)) {
      e += "..."
      break
    }
    ;(r = !1), (e += `${s}: ${tl(a, t - e.length)}`)
  }
  return (e += " }"), e
}
function Hlt(i, t) {
  let e = ""
  for (let r = 1; r <= t; r++) e += i
  return e
}
function Wlt(i, t) {
  for (; i.length < t; ) i += " "
  return i
}
var PG
function jlt(i) {
  PG = i
}
var NG
function Vlt(i) {
  NG = i
}
var E3
function Glt(i) {
  E3 = i
}
var zlt = class {
    get TChange() {
      return null
    }
    reportChanges() {
      this.get()
    }
    read(i) {
      return i ? i.readObservable(this) : this.get()
    }
    map(i, t) {
      const e = t === void 0 ? void 0 : i,
        r = t === void 0 ? i : t
      return E3(
        {
          owner: e,
          debugName: () => {
            const s = k3(r)
            if (s !== void 0) return s
            const o =
              /^\s*\(?\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)?\s*=>\s*\1(?:\??)\.([a-zA-Z_$][a-zA-Z_$0-9]*)\s*$/.exec(
                r.toString(),
              )
            if (o) return `${this.debugName}.${o[2]}`
            if (!e) return `${this.debugName} (mapped)`
          },
          debugReferenceFn: r,
        },
        (s) => r(this.read(s), s),
      )
    }
    flatten() {
      return E3(
        { owner: void 0, debugName: () => `${this.debugName} (flattened)` },
        (i) => this.read(i).read(i),
      )
    }
    recomputeInitiallyAndOnChange(i, t) {
      return i.add(PG(this, t)), this
    }
    keepObserved(i) {
      return i.add(NG(this)), this
    }
    get a() {
      return this.get()
    }
  },
  I3 = class extends zlt {
    constructor() {
      super(...arguments), (this.b = new Set())
    }
    addObserver(i) {
      const t = this.b.size
      this.b.add(i), t === 0 && this.c()
    }
    removeObserver(i) {
      this.b.delete(i) && this.b.size === 0 && this.f()
    }
    c() {}
    f() {}
  }
function Ylt(i, t) {
  const e = new $G(i, t)
  try {
    i(e)
  } finally {
    e.finish()
  }
}
function Qlt(i, t, e) {
  i ? t(i) : Ylt(t, e)
}
var $G = class {
  constructor(i, t) {
    ;(this._fn = i),
      (this.b = t),
      (this.a = []),
      Zr()?.handleBeginTransaction(this)
  }
  getDebugName() {
    return this.b ? this.b() : k3(this._fn)
  }
  updateObserver(i, t) {
    this.a.push({ observer: i, observable: t }), i.beginUpdate(t)
  }
  finish() {
    const i = this.a
    for (let t = 0; t < i.length; t++) {
      const { observer: e, observable: r } = i[t]
      e.endUpdate(r)
    }
    ;(this.a = null), Zr()?.handleEndTransaction()
  }
}
function Xlt(i, t) {
  let e
  return (
    typeof i == "string"
      ? (e = new Ku(void 0, i, void 0))
      : (e = new Ku(i, void 0, void 0)),
    new Klt(e, t, S3)
  )
}
var Klt = class extends I3 {
  get debugName() {
    return this.e.getDebugName(this) ?? "ObservableValue"
  }
  constructor(i, t, e) {
    super(), (this.e = i), (this.g = e), (this.d = t)
  }
  get() {
    return this.d
  }
  set(i, t, e) {
    if (e === void 0 && this.g(this.d, i)) return
    let r
    t ||
      (t = r =
        new $G(
          () => {},
          () => `Setting ${this.debugName}`,
        ))
    try {
      const s = this.d
      this.h(i),
        Zr()?.handleObservableChanged(this, {
          oldValue: s,
          newValue: i,
          change: e,
          didChange: !0,
          hadValue: !0,
        })
      for (const a of this.b) t.updateObserver(a, this), a.handleChange(this, e)
    } finally {
      r && r.finish()
    }
  }
  toString() {
    return `${this.debugName}: ${this.d}`
  }
  h(i) {
    this.d = i
  }
}
function xG(i) {
  return new CG(new Ku(void 0, void 0, i), i, void 0, void 0)
}
var JG
;(function (i) {
  ;(i[(i.dependenciesMightHaveChanged = 1)] = "dependenciesMightHaveChanged"),
    (i[(i.stale = 2)] = "stale"),
    (i[(i.upToDate = 3)] = "upToDate")
})(JG || (JG = {}))
var CG = class {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "(anonymous)"
  }
  constructor(i, t, e, r) {
    ;(this._debugNameData = i),
      (this._runFn = t),
      (this.i = e),
      (this.j = r),
      (this.a = 2),
      (this.b = 0),
      (this.c = !1),
      (this.f = new Set()),
      (this.g = new Set()),
      (this.l = !1),
      (this.h = this.i?.()),
      Zr()?.handleAutorunCreated(this),
      this.k(),
      oo(this)
  }
  dispose() {
    this.c = !0
    for (const i of this.f) i.removeObserver(this)
    this.f.clear(), co(this)
  }
  k() {
    if (this.a === 3) return
    const i = this.g
    ;(this.g = this.f), (this.f = i), (this.a = 3)
    const t = this.c
    try {
      if (!t) {
        Zr()?.handleAutorunTriggered(this)
        const e = this.h
        try {
          ;(this.h = this.i?.()), (this.l = !0), this._runFn(this, e)
        } catch (r) {
          qF(r)
        } finally {
          this.l = !1
        }
      }
    } finally {
      t || Zr()?.handleAutorunFinished(this)
      for (const e of this.g) e.removeObserver(this)
      this.g.clear()
    }
  }
  toString() {
    return `Autorun<${this.debugName}>`
  }
  beginUpdate() {
    this.a === 3 && (this.a = 1), this.b++
  }
  endUpdate() {
    try {
      if (this.b === 1)
        do {
          if (this.a === 1) {
            this.a = 3
            for (const i of this.f) if ((i.reportChanges(), this.a === 2)) break
          }
          this.k()
        } while (this.a !== 3)
    } finally {
      this.b--
    }
    ZV(() => this.b >= 0)
  }
  handlePossibleChange(i) {
    this.a === 3 && this.f.has(i) && !this.g.has(i) && (this.a = 1)
  }
  handleChange(i, t) {
    if (this.f.has(i) && !this.g.has(i))
      try {
        ;(this.j
          ? this.j(
              { changedObservable: i, change: t, didChange: (r) => r === i },
              this.h,
            )
          : !0) && (this.a = 2)
      } catch (e) {
        qF(e)
      }
  }
  readObservable(i) {
    if (!this.l)
      throw new no(
        "The reader object cannot be used outside its compute function!",
      )
    if (this.c) return i.get()
    i.addObserver(this)
    const t = i.get()
    return this.f.add(i), this.g.delete(i), t
  }
}
;(function (i) {
  i.Observer = CG
})(xG || (xG = {}))
function Zlt(i, t) {
  return new tdt(
    new Ku(i.owner, i.debugName, i.debugReferenceFn),
    t,
    void 0,
    void 0,
    i.onLastObserverRemoved,
    i.equalsFn ?? S3,
  )
}
Glt(Zlt)
var LG
;(function (i) {
  ;(i[(i.initial = 0)] = "initial"),
    (i[(i.dependenciesMightHaveChanged = 1)] = "dependenciesMightHaveChanged"),
    (i[(i.stale = 2)] = "stale"),
    (i[(i.upToDate = 3)] = "upToDate")
})(LG || (LG = {}))
var tdt = class extends I3 {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "(anonymous)"
  }
  constructor(i, t, e, r, s = void 0, a) {
    super(),
      (this._debugNameData = i),
      (this._computeFn = t),
      (this.q = e),
      (this.s = r),
      (this.t = s),
      (this.u = a),
      (this.g = 0),
      (this.h = void 0),
      (this.j = 0),
      (this.k = new Set()),
      (this.l = new Set()),
      (this.m = void 0),
      (this.n = !1),
      (this.p = !1),
      (this.x = !1),
      (this.m = this.q?.()),
      Zr()?.handleDerivedCreated(this)
  }
  f() {
    ;(this.g = 0), (this.h = void 0)
    for (const i of this.k) i.removeObserver(this)
    this.k.clear(), this.t?.()
  }
  get() {
    if (this.p) throw new no("Cyclic deriveds are not supported yet!")
    if (this.b.size === 0) {
      let i
      try {
        ;(this.x = !0), (i = this._computeFn(this, this.q?.()))
      } finally {
        this.x = !1
      }
      return this.f(), i
    } else {
      do {
        if (this.g === 1) {
          for (const i of this.k) if ((i.reportChanges(), this.g === 2)) break
        }
        this.g === 1 && (this.g = 3), this.w()
      } while (this.g !== 3)
      return this.h
    }
  }
  w() {
    if (this.g === 3) return
    const i = this.l
    ;(this.l = this.k), (this.k = i)
    const t = this.g !== 0,
      e = this.h
    this.g = 3
    let r = !1
    this.p = !1
    try {
      const s = this.m
      this.m = this.q?.()
      try {
        ;(this.x = !0), (this.h = this._computeFn(this, s))
      } finally {
        this.x = !1
        for (const a of this.l) a.removeObserver(this)
        this.l.clear()
      }
      ;(r = t && !this.u(e, this.h)),
        Zr()?.handleDerivedRecomputed(this, {
          oldValue: e,
          newValue: this.h,
          change: void 0,
          didChange: r,
          hadValue: t,
        })
    } catch (s) {
      qF(s)
    }
    if (((this.p = !1), r)) for (const s of this.b) s.handleChange(this, void 0)
  }
  toString() {
    return `LazyDerived<${this.debugName}>`
  }
  beginUpdate(i) {
    if (this.n) throw new no("Cyclic deriveds are not supported yet!")
    this.j++, (this.n = !0)
    try {
      const t = this.j === 1
      if (this.g === 3 && ((this.g = 1), !t))
        for (const e of this.b) e.handlePossibleChange(this)
      if (t) for (const e of this.b) e.beginUpdate(this)
    } finally {
      this.n = !1
    }
  }
  endUpdate(i) {
    if ((this.j--, this.j === 0)) {
      const t = [...this.b]
      for (const e of t) e.endUpdate(this)
    }
    ZV(() => this.j >= 0)
  }
  handlePossibleChange(i) {
    if (this.g === 3 && this.k.has(i) && !this.l.has(i)) {
      this.g = 1
      for (const t of this.b) t.handlePossibleChange(this)
    }
  }
  handleChange(i, t) {
    if (this.k.has(i) && !this.l.has(i)) {
      let e = !1
      try {
        e = this.s
          ? this.s(
              { changedObservable: i, change: t, didChange: (s) => s === i },
              this.m,
            )
          : !0
      } catch (s) {
        qF(s)
      }
      const r = this.g === 3
      if (e && (this.g === 1 || r) && ((this.g = 2), r))
        for (const s of this.b) s.handlePossibleChange(this)
    }
  }
  readObservable(i) {
    if (!this.x)
      throw new no(
        "The reader object cannot be used outside its compute function!",
      )
    i.addObserver(this)
    const t = i.get()
    return this.k.add(i), this.l.delete(i), t
  }
  addObserver(i) {
    const t = !this.b.has(i) && this.j > 0
    super.addObserver(i), t && i.beginUpdate(this)
  }
  removeObserver(i) {
    const t = this.b.has(i) && this.j > 0
    super.removeObserver(i), t && i.endUpdate(this)
  }
}
function RG(...i) {
  let t, e, r
  return (
    i.length === 3 ? ([t, e, r] = i) : ([e, r] = i),
    new Po(new Ku(t, void 0, r), e, r, () => Po.globalTransaction, S3)
  )
}
var Po = class extends I3 {
  constructor(i, t, e, r, s) {
    super(),
      (this.k = i),
      (this.l = t),
      (this._getValue = e),
      (this.n = r),
      (this.p = s),
      (this.h = !1),
      (this.s = (a) => {
        const o = this._getValue(a),
          c = this.g,
          u = !this.h || !this.p(c, o)
        let l = !1
        u &&
          ((this.g = o),
          this.h &&
            ((l = !0),
            Qlt(
              this.n(),
              (m) => {
                Zr()?.handleFromEventObservableTriggered(this, {
                  oldValue: c,
                  newValue: o,
                  change: void 0,
                  didChange: u,
                  hadValue: this.h,
                })
                for (const h of this.b)
                  m.updateObserver(h, this), h.handleChange(this, void 0)
              },
              () => {
                const m = this.q()
                return "Event fired" + (m ? `: ${m}` : "")
              },
            )),
          (this.h = !0)),
          l ||
            Zr()?.handleFromEventObservableTriggered(this, {
              oldValue: c,
              newValue: o,
              change: void 0,
              didChange: u,
              hadValue: this.h,
            })
      })
  }
  q() {
    return this.k.getDebugName(this)
  }
  get debugName() {
    const i = this.q()
    return "From Event" + (i ? `: ${i}` : "")
  }
  c() {
    this.j = this.l(this.s)
  }
  f() {
    this.j.dispose(), (this.j = void 0), (this.h = !1), (this.g = void 0)
  }
  get() {
    return this.j ? (this.h || this.s(void 0), this.g) : this._getValue(void 0)
  }
}
;(function (i) {
  i.Observer = Po
  function t(e, r) {
    let s = !1
    Po.globalTransaction === void 0 && ((Po.globalTransaction = e), (s = !0))
    try {
      r()
    } finally {
      s && (Po.globalTransaction = void 0)
    }
  }
  i.batchEventsGlobally = t
})(RG || (RG = {}))
function edt(i) {
  const t = new DG(!1, void 0)
  return (
    i.addObserver(t),
    it(() => {
      i.removeObserver(t)
    })
  )
}
Vlt(edt)
function idt(i, t) {
  const e = new DG(!0, t)
  return (
    i.addObserver(e),
    t ? t(i.get()) : i.reportChanges(),
    it(() => {
      i.removeObserver(e)
    })
  )
}
jlt(idt)
var DG = class {
    constructor(i, t) {
      ;(this.b = i), (this.c = t), (this.a = 0)
    }
    beginUpdate(i) {
      this.a++
    }
    endUpdate(i) {
      this.a--,
        this.a === 0 && this.b && (this.c ? this.c(i.get()) : i.reportChanges())
    }
    handlePossibleChange(i) {}
    handleChange(i, t) {}
  },
  rdt = !1
rdt && Blt(new Olt())
function P3(i) {
  if (!i) return
  const t = i.indexOf("+")
  return t < 0 ? i : i.substr(0, t)
}
var ndt = [
    "AI",
    "Azure",
    "Chat",
    "Data Science",
    "Debuggers",
    "Extension Packs",
    "Education",
    "Formatters",
    "Keymaps",
    "Language Packs",
    "Linters",
    "Machine Learning",
    "Notebooks",
    "Programming Languages",
    "SCM Providers",
    "Snippets",
    "Testing",
    "Themes",
    "Visualization",
    "Other",
  ],
  FG
;(function (i) {
  ;(i[(i.System = 0)] = "System"), (i[(i.User = 1)] = "User")
})(FG || (FG = {}))
var _G
;(function (i) {
  ;(i.WIN32_X64 = "win32-x64"),
    (i.WIN32_ARM64 = "win32-arm64"),
    (i.LINUX_X64 = "linux-x64"),
    (i.LINUX_ARM64 = "linux-arm64"),
    (i.LINUX_ARMHF = "linux-armhf"),
    (i.ALPINE_X64 = "alpine-x64"),
    (i.ALPINE_ARM64 = "alpine-arm64"),
    (i.DARWIN_X64 = "darwin-x64"),
    (i.DARWIN_ARM64 = "darwin-arm64"),
    (i.WEB = "web"),
    (i.UNIVERSAL = "universal"),
    (i.UNKNOWN = "unknown"),
    (i.UNDEFINED = "undefined")
})(_G || (_G = {}))
var te = class {
    constructor(i) {
      ;(this.value = i), (this._lower = i.toLowerCase())
    }
    static equals(i, t) {
      if (typeof i > "u" || i === null) return typeof t > "u" || t === null
      if (typeof t > "u" || t === null) return !1
      if (typeof i == "string" || typeof t == "string") {
        const e = typeof i == "string" ? i : i.value,
          r = typeof t == "string" ? t : t.value
        return as(e, r)
      }
      return i._lower === t._lower
    }
    static toKey(i) {
      return typeof i == "string" ? i.toLowerCase() : i._lower
    }
  },
  la = class {
    get size() {
      return this.c.size
    }
    constructor(i) {
      if (((this.c = new Set()), i)) for (const t of i) this.add(t)
    }
    add(i) {
      this.c.add(te.toKey(i))
    }
    delete(i) {
      return this.c.delete(te.toKey(i))
    }
    has(i) {
      return this.c.has(te.toKey(i))
    }
  },
  bn = class {
    constructor() {
      this.c = new Map()
    }
    clear() {
      this.c.clear()
    }
    delete(i) {
      this.c.delete(te.toKey(i))
    }
    get(i) {
      return this.c.get(te.toKey(i))
    }
    has(i) {
      return this.c.has(te.toKey(i))
    }
    set(i, t) {
      this.c.set(te.toKey(i), t)
    }
    values() {
      return this.c.values()
    }
    forEach(i) {
      this.c.forEach(i)
    }
    [Symbol.iterator]() {
      return this.c[Symbol.iterator]()
    }
  },
  gBt = Y("IBuiltinExtensionsScannerService"),
  sdt = Y("productService"),
  adt = "vscode://schemas/vscode-product",
  $_ = Y("configurationService"),
  AG
;(function (i) {
  ;(i[(i.APPLICATION = 1)] = "APPLICATION"),
    (i[(i.USER = 2)] = "USER"),
    (i[(i.USER_LOCAL = 3)] = "USER_LOCAL"),
    (i[(i.USER_REMOTE = 4)] = "USER_REMOTE"),
    (i[(i.WORKSPACE = 5)] = "WORKSPACE"),
    (i[(i.WORKSPACE_FOLDER = 6)] = "WORKSPACE_FOLDER"),
    (i[(i.DEFAULT = 7)] = "DEFAULT"),
    (i[(i.MEMORY = 8)] = "MEMORY")
})(AG || (AG = {}))
function N3(i, t) {
  const e = Object.create(null)
  for (const r in i) BG(e, r, i[r], t)
  return e
}
function BG(i, t, e, r) {
  const s = t.split("."),
    a = s.pop()
  let o = i
  for (let c = 0; c < s.length; c++) {
    const u = s[c]
    let l = o[u]
    switch (typeof l) {
      case "undefined":
        l = o[u] = Object.create(null)
        break
      case "object":
        if (l === null) {
          r(`Ignoring ${t} as ${s.slice(0, c + 1).join(".")} is null`)
          return
        }
        break
      default:
        r(
          `Ignoring ${t} as ${s.slice(0, c + 1).join(".")} is ${JSON.stringify(l)}`,
        )
        return
    }
    o = l
  }
  if (typeof o == "object" && o !== null)
    try {
      o[a] = e
    } catch {
      r(`Ignoring ${t} as ${s.join(".")} is ${JSON.stringify(o)}`)
    }
  else r(`Ignoring ${t} as ${s.join(".")} is ${JSON.stringify(o)}`)
}
function odt(i, t) {
  const e = t.split(".")
  OG(i, e)
}
function OG(i, t) {
  const e = t.shift()
  if (t.length === 0) {
    delete i[e]
    return
  }
  if (Object.keys(i).indexOf(e) !== -1) {
    const r = i[e]
    typeof r == "object" &&
      !Array.isArray(r) &&
      (OG(r, t), Object.keys(r).length === 0 && delete i[e])
  }
}
function x_(i, t, e) {
  function r(o, c) {
    let u = o
    for (const l of c) {
      if (typeof u != "object" || u === null) return
      u = u[l]
    }
    return u
  }
  const s = t.split("."),
    a = r(i, s)
  return typeof a > "u" ? e : a
}
function cdt(i) {
  return i.replace(/[\[\]]/g, "")
}
function udt(i) {
  let t = !1
  const e = new Map(),
    r = new Map()
  if (
    (ldt(i, (m) => {
      if (i === m) return !0
      const h = JSON.stringify(m)
      if (h.length < 30) return !0
      const p = e.get(h)
      if (!p) {
        const g = { schemas: [m] }
        return e.set(h, g), r.set(m, g), !0
      }
      return p.schemas.push(m), r.set(m, p), (t = !0), !1
    }),
    e.clear(),
    !t)
  )
    return JSON.stringify(i)
  let a = "$defs"
  for (; i.hasOwnProperty(a); ) a += "_"
  const o = []
  function c(m) {
    return JSON.stringify(m, (h, p) => {
      if (p !== m) {
        const g = r.get(p)
        if (g && g.schemas.length > 1)
          return (
            g.id || ((g.id = `_${o.length}`), o.push(g.schemas[0])),
            { $ref: `#/${a}/${g.id}` }
          )
      }
      return p
    })
  }
  const u = c(i),
    l = []
  for (let m = 0; m < o.length; m++) l.push(`"_${m}":${c(o[m])}`)
  return l.length
    ? `${u.substring(0, u.length - 1)},"${a}":{${l.join(",")}}}`
    : u
}
function No(i) {
  return typeof i == "object" && i !== null
}
function ldt(i, t) {
  if (!i || typeof i != "object") return
  const e = (...u) => {
      for (const l of u) No(l) && o.push(l)
    },
    r = (...u) => {
      for (const l of u)
        if (No(l))
          for (const m in l) {
            const h = l[m]
            No(h) && o.push(h)
          }
    },
    s = (...u) => {
      for (const l of u)
        if (Array.isArray(l)) for (const m of l) No(m) && o.push(m)
    },
    a = (u) => {
      if (Array.isArray(u)) for (const l of u) No(l) && o.push(l)
      else No(u) && o.push(u)
    },
    o = [i]
  let c = o.pop()
  for (; c; )
    t(c) &&
      (e(
        c.additionalItems,
        c.additionalProperties,
        c.not,
        c.contains,
        c.propertyNames,
        c.if,
        c.then,
        c.else,
        c.unevaluatedItems,
        c.unevaluatedProperties,
      ),
      r(
        c.definitions,
        c.$defs,
        c.properties,
        c.patternProperties,
        c.dependencies,
        c.dependentSchemas,
      ),
      s(c.anyOf, c.allOf, c.oneOf, c.prefixItems),
      a(c.items)),
      (c = o.pop())
}
var J_ = { JSONContribution: "base.contributions.json" }
function ddt(i) {
  return i.length > 0 && i.charAt(i.length - 1) === "#"
    ? i.substring(0, i.length - 1)
    : i
}
var mdt = class {
    constructor() {
      ;(this.b = new C()),
        (this.onDidChangeSchema = this.b.event),
        (this.a = {})
    }
    registerSchema(i, t) {
      ;(this.a[ddt(i)] = t), this.b.fire(i)
    }
    notifySchemaChanged(i) {
      this.b.fire(i)
    }
    getSchemaContributions() {
      return { schemas: this.a }
    }
    getSchemaContent(i) {
      const t = this.a[i]
      return t ? udt(t) : void 0
    }
    hasSchemaContent(i) {
      return !!this.a[i]
    }
  },
  hdt = new mdt()
ui.add(J_.JSONContribution, hdt)
var qG
;(function (i) {
  ;(i.Multiline = "multilineText"), (i.Singleline = "singlelineText")
})(qG || (qG = {}))
var $o = { Configuration: "base.contributions.configuration" },
  UG
;(function (i) {
  ;(i[(i.APPLICATION = 1)] = "APPLICATION"),
    (i[(i.MACHINE = 2)] = "MACHINE"),
    (i[(i.WINDOW = 3)] = "WINDOW"),
    (i[(i.RESOURCE = 4)] = "RESOURCE"),
    (i[(i.LANGUAGE_OVERRIDABLE = 5)] = "LANGUAGE_OVERRIDABLE"),
    (i[(i.MACHINE_OVERRIDABLE = 6)] = "MACHINE_OVERRIDABLE")
})(UG || (UG = {}))
var C_ = { properties: {}, patternProperties: {} },
  L_ = { properties: {}, patternProperties: {} },
  R_ = { properties: {}, patternProperties: {} },
  D_ = { properties: {}, patternProperties: {} },
  F_ = { properties: {}, patternProperties: {} },
  el = { properties: {}, patternProperties: {} },
  da = "vscode://schemas/settings/resourceLanguage",
  __ = ui.as(J_.JSONContribution),
  fdt = class {
    constructor() {
      ;(this.a = []),
        (this.i = new Set()),
        (this.j = new C()),
        (this.onDidSchemaChange = this.j.event),
        (this.k = new C()),
        (this.onDidUpdateConfiguration = this.k.event),
        (this.b = new Map()),
        (this.c = {
          id: "defaultOverrides",
          title: f(1705, null),
          properties: {},
        }),
        (this.d = [this.c]),
        (this.h = {
          properties: {},
          patternProperties: {},
          additionalProperties: !0,
          allowTrailingCommas: !0,
          allowComments: !0,
        }),
        (this.e = {}),
        (this.f = new Map()),
        (this.g = {}),
        __.registerSchema(da, this.h),
        this.z()
    }
    registerConfiguration(i, t = !0) {
      this.registerConfigurations([i], t)
    }
    registerConfigurations(i, t = !0) {
      const e = new Set()
      this.r(i, t, e),
        __.registerSchema(da, this.h),
        this.j.fire(),
        this.k.fire({ properties: e })
    }
    deregisterConfigurations(i) {
      const t = new Set()
      this.s(i, t),
        __.registerSchema(da, this.h),
        this.j.fire(),
        this.k.fire({ properties: t })
    }
    updateConfigurations({ add: i, remove: t }) {
      const e = new Set()
      this.s(t, e),
        this.r(i, !1, e),
        __.registerSchema(da, this.h),
        this.j.fire(),
        this.k.fire({ properties: e })
    }
    registerDefaultConfigurations(i) {
      const t = new Set()
      this.l(i, t),
        this.j.fire(),
        this.k.fire({ properties: t, defaultsOverrides: !0 })
    }
    l(i, t) {
      this.a.push(...i)
      const e = []
      for (const { overrides: r, source: s } of i)
        for (const a in r) {
          t.add(a)
          const o =
              this.b.get(a) ??
              this.b.set(a, { configurationDefaultOverrides: [] }).get(a),
            c = r[a]
          if (
            (o.configurationDefaultOverrides.push({ value: c, source: s }),
            tn.test(a))
          ) {
            const u = this.o(a, c, s, o.configurationDefaultOverrideValue)
            if (!u) continue
            ;(o.configurationDefaultOverrideValue = u),
              this.n(a, u, s),
              e.push(...il(a))
          } else {
            const u = this.p(a, c, s, o.configurationDefaultOverrideValue)
            if (!u) continue
            o.configurationDefaultOverrideValue = u
            const l = this.e[a]
            l && (this.A(a, l), this.w(a, l))
          }
        }
      this.q(e)
    }
    deregisterDefaultConfigurations(i) {
      const t = new Set()
      this.m(i, t),
        this.j.fire(),
        this.k.fire({ properties: t, defaultsOverrides: !0 })
    }
    m(i, t) {
      for (const e of i) {
        const r = this.a.indexOf(e)
        r !== -1 && this.a.splice(r, 1)
      }
      for (const { overrides: e, source: r } of i)
        for (const s in e) {
          const a = this.b.get(s)
          if (!a) continue
          const o = a.configurationDefaultOverrides.findIndex((c) =>
            r ? c.source?.id === r.id : c.value === e[s],
          )
          if (o !== -1) {
            if (
              (a.configurationDefaultOverrides.splice(o, 1),
              a.configurationDefaultOverrides.length === 0 && this.b.delete(s),
              tn.test(s))
            ) {
              let c
              for (const u of a.configurationDefaultOverrides)
                c = this.o(s, u.value, u.source, c)
              c && !GW(c.value)
                ? ((a.configurationDefaultOverrideValue = c), this.n(s, c, r))
                : (this.b.delete(s),
                  delete this.e[s],
                  delete this.c.properties[s])
            } else {
              let c
              for (const l of a.configurationDefaultOverrides)
                c = this.p(s, l.value, l.source, c)
              a.configurationDefaultOverrideValue = c
              const u = this.e[s]
              u && (this.A(s, u), this.w(s, u))
            }
            t.add(s)
          }
        }
      this.y()
    }
    n(i, t, e) {
      const r = {
        type: "object",
        default: t.value,
        description: f(1706, null, cdt(i)),
        $ref: da,
        defaultDefaultValue: t.value,
        source: e,
        defaultValueSource: e,
      }
      ;(this.e[i] = r), (this.c.properties[i] = r)
    }
    o(i, t, e, r) {
      const s = r?.value || {},
        a = r?.source ?? new Map()
      if (!(a instanceof Map)) {
        console.error("objectConfigurationSources is not a Map")
        return
      }
      for (const o of Object.keys(t)) {
        const c = t[o]
        if (Ce(c) && (Ru(s[o]) || Ce(s[o]))) {
          if (((s[o] = { ...(s[o] ?? {}), ...c }), e))
            for (const l in c) a.set(`${o}.${l}`, e)
        } else (s[o] = c), e ? a.set(o, e) : a.delete(o)
      }
      return { value: s, source: a }
    }
    p(i, t, e, r) {
      const s = this.e[i],
        a = r?.value ?? s?.defaultDefaultValue
      let o = e
      if (
        Ce(t) &&
        ((s !== void 0 && s.type === "object") ||
          (s === void 0 && (Ru(a) || Ce(a))))
      ) {
        if (((o = r?.source ?? new Map()), !(o instanceof Map))) {
          console.error("defaultValueSource is not a Map")
          return
        }
        for (const u in t) e && o.set(`${i}.${u}`, e)
        t = { ...(Ce(a) ? a : {}), ...t }
      }
      return { value: t, source: o }
    }
    deltaConfiguration(i) {
      let t = !1
      const e = new Set()
      i.removedDefaults && (this.m(i.removedDefaults, e), (t = !0)),
        i.addedDefaults && (this.l(i.addedDefaults, e), (t = !0)),
        i.removedConfigurations && this.s(i.removedConfigurations, e),
        i.addedConfigurations && this.r(i.addedConfigurations, !1, e),
        this.j.fire(),
        this.k.fire({ properties: e, defaultsOverrides: t })
    }
    notifyConfigurationSchemaUpdated(...i) {
      this.j.fire()
    }
    registerOverrideIdentifiers(i) {
      this.q(i), this.j.fire()
    }
    q(i) {
      for (const t of i) this.i.add(t)
      this.y()
    }
    r(i, t, e) {
      i.forEach((r) => {
        this.u(r, t, r.extensionInfo, r.restrictedProperties, void 0, e),
          this.d.push(r),
          this.v(r)
      })
    }
    s(i, t) {
      const e = (r) => {
        if (r.properties)
          for (const s in r.properties) {
            t.add(s)
            const a = this.e[s]
            a?.policy?.name && this.f.delete(a.policy.name),
              delete this.e[s],
              this.x(s, r.properties[s])
          }
        r.allOf?.forEach((s) => e(s))
      }
      for (const r of i) {
        e(r)
        const s = this.d.indexOf(r)
        s !== -1 && this.d.splice(s, 1)
      }
    }
    u(i, t = !0, e, r, s = 3, a) {
      s = Le(i.scope) ? s : i.scope
      const o = i.properties
      if (o)
        for (const u in o) {
          const l = o[u]
          if (t && gdt(u, l)) {
            delete o[u]
            continue
          }
          if (
            ((l.source = e),
            (l.defaultDefaultValue = o[u].default),
            this.A(u, l),
            tn.test(u)
              ? (l.scope = void 0)
              : ((l.scope = Le(l.scope) ? s : l.scope),
                (l.restricted = Le(l.restricted)
                  ? !!r?.includes(u)
                  : l.restricted)),
            o[u].hasOwnProperty("included") && !o[u].included)
          ) {
            ;(this.g[u] = o[u]), delete o[u]
            continue
          } else
            (this.e[u] = o[u]),
              o[u].policy?.name && this.f.set(o[u].policy.name, u)
          !o[u].deprecationMessage &&
            o[u].markdownDeprecationMessage &&
            (o[u].deprecationMessage = o[u].markdownDeprecationMessage),
            a.add(u)
        }
      const c = i.allOf
      if (c) for (const u of c) this.u(u, t, e, r, s, a)
    }
    getConfigurations() {
      return this.d
    }
    getConfigurationProperties() {
      return this.e
    }
    getPolicyConfigurations() {
      return this.f
    }
    getExcludedConfigurationProperties() {
      return this.g
    }
    getRegisteredDefaultConfigurations() {
      return [...this.a]
    }
    getConfigurationDefaultsOverrides() {
      const i = new Map()
      for (const [t, e] of this.b)
        e.configurationDefaultOverrideValue &&
          i.set(t, e.configurationDefaultOverrideValue)
      return i
    }
    v(i) {
      const t = (e) => {
        const r = e.properties
        if (r) for (const a in r) this.w(a, r[a])
        e.allOf?.forEach(t)
      }
      t(i)
    }
    w(i, t) {
      switch (((C_.properties[i] = t), t.scope)) {
        case 1:
          L_.properties[i] = t
          break
        case 2:
          R_.properties[i] = t
          break
        case 6:
          D_.properties[i] = t
          break
        case 3:
          F_.properties[i] = t
          break
        case 4:
          el.properties[i] = t
          break
        case 5:
          ;(el.properties[i] = t), (this.h.properties[i] = t)
          break
      }
    }
    x(i, t) {
      switch ((delete C_.properties[i], t.scope)) {
        case 1:
          delete L_.properties[i]
          break
        case 2:
          delete R_.properties[i]
          break
        case 6:
          delete D_.properties[i]
          break
        case 3:
          delete F_.properties[i]
          break
        case 4:
        case 5:
          delete el.properties[i], delete this.h.properties[i]
          break
      }
    }
    y() {
      for (const i of this.i.values()) {
        const t = `[${i}]`,
          e = {
            type: "object",
            description: f(1707, null),
            errorMessage: f(1708, null),
            $ref: da,
          }
        this.A(t, e),
          (C_.properties[t] = e),
          (L_.properties[t] = e),
          (R_.properties[t] = e),
          (D_.properties[t] = e),
          (F_.properties[t] = e),
          (el.properties[t] = e)
      }
    }
    z() {
      const i = {
        type: "object",
        description: f(1709, null),
        errorMessage: f(1710, null),
        $ref: da,
      }
      ;(C_.patternProperties[ma] = i),
        (L_.patternProperties[ma] = i),
        (R_.patternProperties[ma] = i),
        (D_.patternProperties[ma] = i),
        (F_.patternProperties[ma] = i),
        (el.patternProperties[ma] = i),
        this.j.fire()
    }
    A(i, t) {
      const e = this.b.get(i)?.configurationDefaultOverrideValue
      let r, s
      e &&
        (!t.disallowConfigurationDefault || !e.source) &&
        ((r = e.value), (s = e.source)),
        Ru(r) && ((r = t.defaultDefaultValue), (s = void 0)),
        Ru(r) && (r = pdt(t.type)),
        (t.default = r),
        (t.defaultValueSource = s)
    }
  },
  MG = "\\[([^\\]]+)\\]",
  HG = new RegExp(MG, "g"),
  ma = `^(${MG})+$`,
  tn = new RegExp(ma)
function il(i) {
  const t = []
  if (tn.test(i)) {
    let e = HG.exec(i)
    for (; e?.length; ) {
      const r = e[1].trim()
      r && t.push(r), (e = HG.exec(i))
    }
  }
  return so(t)
}
function pdt(i) {
  switch (Array.isArray(i) ? i[0] : i) {
    case "boolean":
      return !1
    case "integer":
    case "number":
      return 0
    case "string":
      return ""
    case "array":
      return []
    case "object":
      return {}
    default:
      return null
  }
}
var A_ = new fdt()
ui.add($o.Configuration, A_)
function gdt(i, t) {
  return i.trim()
    ? tn.test(i)
      ? f(1712, null, i)
      : A_.getConfigurationProperties()[i] !== void 0
        ? f(1713, null, i)
        : t.policy?.name &&
            A_.getPolicyConfigurations().get(t.policy?.name) !== void 0
          ? f(
              1714,
              null,
              i,
              t.policy?.name,
              A_.getPolicyConfigurations().get(t.policy?.name),
            )
          : null
    : f(1711, null)
}
var vdt = Y("requestService")
function wdt(i) {
  return (
    (i.res.statusCode && i.res.statusCode >= 200 && i.res.statusCode < 300) ||
    i.res.statusCode === 1223
  )
}
function ydt(i) {
  return i.res.statusCode === 204
}
async function Tdt(i) {
  if (!wdt(i)) throw new Error("Server returned " + i.res.statusCode)
  if (ydt(i)) return null
  const e = (await Sat(i.stream)).toString()
  try {
    return JSON.parse(e)
  } catch (r) {
    throw (
      ((r.message +=
        `:
` + e),
      r)
    )
  }
}
var $3
function kdt(i) {
  const t = ui.as($o.Configuration),
    e = $3
  ;($3 = {
    id: "http",
    order: 15,
    title: f(2107, null),
    type: "object",
    scope: i,
    properties: {
      "http.proxy": {
        type: "string",
        pattern:
          "^(https?|socks|socks4a?|socks5h?)://([^:]*(:[^@]*)?@)?([^:]+|\\[[:0-9a-fA-F]+\\])(:\\d+)?/?$|^$",
        markdownDescription: f(2108, null),
        restricted: !0,
      },
      "http.proxyStrictSSL": {
        type: "boolean",
        default: !0,
        description: f(2109, null),
        restricted: !0,
      },
      "http.proxyKerberosServicePrincipal": {
        type: "string",
        markdownDescription: f(2110, null),
        restricted: !0,
      },
      "http.noProxy": {
        type: "array",
        items: { type: "string" },
        markdownDescription: f(2111, null),
        restricted: !0,
      },
      "http.proxyAuthorization": {
        type: ["null", "string"],
        default: null,
        markdownDescription: f(2112, null),
        restricted: !0,
      },
      "http.proxySupport": {
        type: "string",
        enum: ["off", "on", "fallback", "override"],
        enumDescriptions: [
          f(2113, null),
          f(2114, null),
          f(2115, null),
          f(2116, null),
        ],
        default: "override",
        description: f(2117, null),
        restricted: !0,
      },
      "http.systemCertificates": {
        type: "boolean",
        default: !0,
        description: f(2118, null),
        restricted: !0,
      },
      "http.experimental.systemCertificatesV2": {
        type: "boolean",
        tags: ["experimental"],
        default: !1,
        description: f(2119, null),
        restricted: !0,
      },
      "http.electronFetch": {
        type: "boolean",
        default: !1,
        description: f(2120, null),
        restricted: !0,
      },
      "http.fetchAdditionalSupport": {
        type: "boolean",
        default: !0,
        markdownDescription: f(
          2121,
          null,
          "`#http.proxySupport#`",
          "`#http.systemCertificates#`",
        ),
        restricted: !0,
      },
    },
  }),
    t.updateConfigurations({ add: [$3], remove: e ? [e] : [] })
}
kdt(1)
var rl
;(function (i) {
  ;(i[(i.STORAGE_DOES_NOT_EXIST = 0)] = "STORAGE_DOES_NOT_EXIST"),
    (i[(i.STORAGE_IN_MEMORY = 1)] = "STORAGE_IN_MEMORY")
})(rl || (rl = {}))
var Nr
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Initialized = 1)] = "Initialized"),
    (i[(i.Closed = 2)] = "Closed")
})(Nr || (Nr = {}))
var vBt = class qnt extends dt {
    static {
      this.a = 100
    }
    constructor(t, e = Object.create(null)) {
      super(),
        (this.q = t),
        (this.r = e),
        (this.b = this.D(new YF())),
        (this.onDidChangeStorage = this.b.event),
        (this.c = Nr.None),
        (this.f = new Map()),
        (this.g = this.D(new fct(qnt.a))),
        (this.h = new Set()),
        (this.j = new Map()),
        (this.m = void 0),
        (this.n = []),
        this.s()
    }
    s() {
      this.D(this.q.onDidChangeItemsExternal((t) => this.t(t)))
    }
    t(t) {
      this.b.pause()
      try {
        t.changed?.forEach((e, r) => this.u(r, e)),
          t.deleted?.forEach((e) => this.u(e, void 0))
      } finally {
        this.b.resume()
      }
    }
    u(t, e) {
      if (this.c === Nr.Closed) return
      let r = !1
      Le(e)
        ? (r = this.f.delete(t))
        : this.f.get(t) !== e && (this.f.set(t, e), (r = !0)),
        r && this.b.fire({ key: t, external: !0 })
    }
    get items() {
      return this.f
    }
    get size() {
      return this.f.size
    }
    async init() {
      this.c === Nr.None &&
        ((this.c = Nr.Initialized),
        this.r.hint !== rl.STORAGE_DOES_NOT_EXIST &&
          (this.f = await this.q.getItems()))
    }
    cursorDiskKVGet(t) {
      return this.q.cursorDiskKVGet(t)
    }
    cursorDiskKVSet(t, e) {
      return this.q.cursorDiskKVSet(t, e)
    }
    get(t, e) {
      const r = this.f.get(t)
      return Le(r) ? e : r
    }
    getBoolean(t, e) {
      const r = this.get(t)
      return Le(r) ? e : r === "true"
    }
    getNumber(t, e) {
      const r = this.get(t)
      return Le(r) ? e : parseInt(r, 10)
    }
    getObject(t, e) {
      const r = this.get(t)
      return Le(r) ? e : $V(r)
    }
    async set(t, e, r = !1) {
      if (this.c === Nr.Closed) return
      if (Le(e)) return this.delete(t, r)
      const s = Ce(e) || Array.isArray(e) ? mlt(e) : String(e)
      if (this.f.get(t) !== s)
        return (
          this.f.set(t, s),
          this.j.set(t, s),
          this.h.delete(t),
          this.b.fire({ key: t, external: r }),
          this.C()
        )
    }
    async delete(t, e = !1) {
      if (!(this.c === Nr.Closed || !this.f.delete(t)))
        return (
          this.h.has(t) || this.h.add(t),
          this.j.delete(t),
          this.b.fire({ key: t, external: e }),
          this.C()
        )
    }
    async optimize() {
      if (this.c !== Nr.Closed) return await this.flush(0), this.q.optimize()
    }
    async close() {
      return this.m || (this.m = this.w()), this.m
    }
    async w() {
      this.c = Nr.Closed
      try {
        await this.C(0)
      } catch {}
      await this.q.close(() => this.f)
    }
    get y() {
      return this.j.size > 0 || this.h.size > 0
    }
    async z() {
      if (!this.y) return
      const t = { insert: this.j, delete: this.h }
      return (
        (this.h = new Set()),
        (this.j = new Map()),
        this.q.updateItems(t).finally(() => {
          if (!this.y) for (; this.n.length; ) this.n.pop()?.()
        })
      )
    }
    async flush(t) {
      if (!(this.c === Nr.Closed || this.m)) return this.C(t)
    }
    async C(t) {
      return this.r.hint === rl.STORAGE_IN_MEMORY
        ? this.z()
        : this.g.trigger(() => this.z(), t)
    }
    async whenFlushed() {
      if (this.y) return new Promise((t) => this.n.push(t))
    }
    isInMemory() {
      return this.r.hint === rl.STORAGE_IN_MEMORY
    }
  },
  x3 = Y("environmentService"),
  wBt = x3,
  WG = Y("IUriIdentityService"),
  jG
;(function (i) {
  ;(i.Settings = "settings"),
    (i.Keybindings = "keybindings"),
    (i.Snippets = "snippets"),
    (i.Tasks = "tasks"),
    (i.Extensions = "extensions"),
    (i.GlobalState = "globalState")
})(jG || (jG = {}))
function Sdt(i) {
  const t = i
  return !!(
    t &&
    typeof t == "object" &&
    typeof t.id == "string" &&
    typeof t.isDefault == "boolean" &&
    typeof t.name == "string" &&
    S.isUri(t.location) &&
    S.isUri(t.globalStorageHome) &&
    S.isUri(t.settingsResource) &&
    S.isUri(t.keybindingsResource) &&
    S.isUri(t.tasksResource) &&
    S.isUri(t.snippetsHome) &&
    S.isUri(t.extensionsResource)
  )
}
var bdt = Y("IUserDataProfilesService")
function B_(i, t, e, r, s, a) {
  return {
    id: i,
    name: t,
    location: e,
    isDefault: !1,
    icon: s?.icon,
    globalStorageHome:
      a && s?.useDefaultFlags?.globalState
        ? a.globalStorageHome
        : Ti(e, "globalStorage"),
    settingsResource:
      a && s?.useDefaultFlags?.settings
        ? a.settingsResource
        : Ti(e, "settings.json"),
    keybindingsResource:
      a && s?.useDefaultFlags?.keybindings
        ? a.keybindingsResource
        : Ti(e, "keybindings.json"),
    tasksResource:
      a && s?.useDefaultFlags?.tasks ? a.tasksResource : Ti(e, "tasks.json"),
    snippetsHome:
      a && s?.useDefaultFlags?.snippets ? a.snippetsHome : Ti(e, "snippets"),
    extensionsResource:
      a && s?.useDefaultFlags?.extensions
        ? a.extensionsResource
        : Ti(e, "extensions.json"),
    cacheHome: Ti(r, i),
    useDefaultFlags: s?.useDefaultFlags,
    isTransient: s?.transient,
    workspaces: s?.workspaces,
  }
}
var VG = class extends dt {
  static {
    this.b = "userDataProfiles"
  }
  static {
    this.c = "profileAssociations"
  }
  get defaultProfile() {
    return this.profiles[0]
  }
  get profiles() {
    return [...this.z.profiles, ...this.q.profiles]
  }
  constructor(t, e, r, s) {
    super(),
      (this.r = t),
      (this.s = e),
      (this.t = r),
      (this.u = s),
      (this.g = this.D(new C())),
      (this.onDidChangeProfiles = this.g.event),
      (this.h = this.D(new C())),
      (this.onWillCreateProfile = this.h.event),
      (this.j = this.D(new C())),
      (this.onWillRemoveProfile = this.j.event),
      (this.m = this.D(new C())),
      (this.onDidResetWorkspaces = this.m.event),
      (this.n = new Map()),
      (this.q = { profiles: [], emptyWindows: new Map() }),
      (this.profilesHome = Ti(this.r.userRoamingDataHome, "profiles")),
      (this.f = Ti(this.r.cacheHome, "CachedProfilesData"))
  }
  init() {
    this.y = void 0
  }
  get z() {
    if (!this.y) {
      const t = this.C(),
        e = [t]
      try {
        for (const s of this.N()) {
          if (!s.name || !Bt(s.name) || !s.location) {
            this.u.warn(
              "Skipping the invalid stored profile",
              s.location || s.name,
            )
            continue
          }
          e.push(
            B_(
              us(s.location),
              s.name,
              s.location,
              this.f,
              { icon: s.icon, useDefaultFlags: s.useDefaultFlags },
              t,
            ),
          )
        }
      } catch (s) {
        this.u.error(s)
      }
      const r = new Map()
      if (e.length)
        try {
          const s = this.P()
          if (s.workspaces)
            for (const [a, o] of Object.entries(s.workspaces)) {
              const c = S.parse(a),
                u = e.find((l) => l.id === o)
              if (u) {
                const l = u.workspaces ? u.workspaces.slice(0) : []
                l.push(c), (u.workspaces = l)
              }
            }
          if (s.emptyWindows)
            for (const [a, o] of Object.entries(s.emptyWindows)) {
              const c = e.find((u) => u.id === o)
              c && r.set(a, c)
            }
        } catch (s) {
          this.u.error(s)
        }
      this.y = { profiles: e, emptyWindows: r }
    }
    return this.y
  }
  C() {
    const t = B_(
      "__default__profile__",
      f(2493, null),
      this.r.userRoamingDataHome,
      this.f,
    )
    return {
      ...t,
      extensionsResource: this.R() ?? t.extensionsResource,
      isDefault: !0,
    }
  }
  async createTransientProfile(t) {
    const e = "Temp",
      r = new RegExp(`${Ks(e)}\\s(\\d+)`)
    let s = 0
    for (const o of this.profiles) {
      const c = r.exec(o.name),
        u = c ? parseInt(c[1]) : 0
      s = u > s ? u : s
    }
    const a = `${e} ${s + 1}`
    return this.createProfile(Au(Ki()).toString(16), a, { transient: !0 }, t)
  }
  async createNamedProfile(t, e, r) {
    return this.createProfile(Au(Ki()).toString(16), t, e, r)
  }
  async createProfile(t, e, r, s) {
    return await this.F(t, e, r, s)
  }
  async F(t, e, r, s) {
    if (!Bt(e) || !e)
      throw new Error(
        "Name of the profile is mandatory and must be of type `string`",
      )
    let a = this.n.get(e)
    return (
      a ||
        ((a = (async () => {
          try {
            if (
              this.profiles.find(
                (m) =>
                  m.id === t ||
                  (!m.isTransient && !r?.transient && m.name === e),
              )
            )
              throw new Error(`Profile with ${e} name already exists`)
            const c = s ? this.G(s) : void 0
            S.isUri(c) && (r = { ...r, workspaces: [c] })
            const u = B_(
              t,
              e,
              Ti(this.profilesHome, t),
              this.f,
              r,
              this.defaultProfile,
            )
            await this.s.createFolder(u.location)
            const l = []
            return (
              this.h.fire({
                profile: u,
                join(m) {
                  l.push(m)
                },
              }),
              await vo.settled(l),
              c && !S.isUri(c) && this.L(c, u, !!u.isTransient),
              this.I([u], [], []),
              u
            )
          } finally {
            this.n.delete(e)
          }
        })()),
        this.n.set(e, a)),
      a
    )
  }
  async updateProfile(t, e) {
    const r = []
    for (const a of this.profiles) {
      let o
      if (t.id === a.id)
        a.isDefault
          ? e.workspaces && ((o = a), (o.workspaces = e.workspaces))
          : (o = B_(
              a.id,
              e.name ?? a.name,
              a.location,
              this.f,
              {
                icon: e.icon === null ? void 0 : (e.icon ?? a.icon),
                transient: e.transient ?? a.isTransient,
                useDefaultFlags: e.useDefaultFlags ?? a.useDefaultFlags,
                workspaces: e.workspaces ?? a.workspaces,
              },
              this.defaultProfile,
            ))
      else if (e.workspaces) {
        const c = a.workspaces?.filter(
          (u) => !e.workspaces?.some((l) => this.t.extUri.isEqual(u, l)),
        )
        a.workspaces?.length !== c?.length && ((o = a), (o.workspaces = c))
      }
      o && r.push(o)
    }
    if (!r.length)
      throw t.isDefault
        ? new Error("Cannot update default profile")
        : new Error(`Profile '${t.name}' does not exist`)
    this.I([], [], r)
    const s = this.profiles.find((a) => a.id === t.id)
    if (!s) throw new Error(`Profile '${t.name}' was not updated`)
    return s
  }
  async removeProfile(t) {
    if (t.isDefault) throw new Error("Cannot remove default profile")
    const e = this.profiles.find((s) => s.id === t.id)
    if (!e) throw new Error(`Profile '${t.name}' does not exist`)
    const r = []
    this.j.fire({
      profile: e,
      join(s) {
        r.push(s)
      },
    })
    try {
      await Promise.allSettled(r)
    } catch (s) {
      this.u.error(s)
    }
    this.I([], [e], [])
    try {
      await this.s.del(e.cacheHome, { recursive: !0 })
    } catch (s) {
      klt(s) !== 1 && this.u.error(s)
    }
  }
  async setProfileForWorkspace(t, e) {
    const r = this.profiles.find((a) => a.id === e.id)
    if (!r) throw new Error(`Profile '${e.name}' does not exist`)
    const s = this.G(t)
    if (S.isUri(s)) {
      const a = r.workspaces ? [...r.workspaces] : []
      a.some((o) => this.t.extUri.isEqual(o, s)) ||
        (a.push(s), await this.updateProfile(r, { workspaces: a }))
    } else this.L(s, r, !1), this.M(this.profiles)
  }
  unsetWorkspace(t, e = !1) {
    const r = this.G(t)
    if (S.isUri(r)) {
      const s = this.getProfileForWorkspace(t)
      s &&
        this.updateProfile(s, {
          workspaces: s.workspaces?.filter((a) => !this.t.extUri.isEqual(a, r)),
        })
    } else this.L(r, void 0, e), this.M(this.profiles)
  }
  async resetWorkspaces() {
    this.q.emptyWindows.clear(), this.z.emptyWindows.clear()
    for (const t of this.profiles) t.workspaces = void 0
    this.I([], [], this.profiles), this.m.fire()
  }
  async cleanUp() {
    if (await this.s.exists(this.profilesHome)) {
      const t = await this.s.resolve(this.profilesHome)
      await Promise.all(
        (t.children || [])
          .filter(
            (e) =>
              e.isDirectory &&
              this.profiles.every(
                (r) => !this.t.extUri.isEqual(r.location, e.resource),
              ),
          )
          .map((e) => this.s.del(e.resource, { recursive: !0 })),
      )
    }
  }
  async cleanUpTransientProfiles() {
    const t = this.q.profiles.filter((e) => !this.H(e))
    await Promise.allSettled(t.map((e) => this.removeProfile(e)))
  }
  getProfileForWorkspace(t) {
    const e = this.G(t)
    return S.isUri(e)
      ? this.profiles.find((r) =>
          r.workspaces?.some((s) => this.t.extUri.isEqual(s, e)),
        )
      : (this.z.emptyWindows.get(e) ?? this.q.emptyWindows.get(e))
  }
  G(t) {
    return hut(t) ? t.uri : fut(t) ? t.configPath : t.id
  }
  H(t) {
    return !!(
      t.workspaces?.length ||
      [...this.z.emptyWindows.values()].some((e) =>
        this.t.extUri.isEqual(e.location, t.location),
      ) ||
      [...this.q.emptyWindows.values()].some((e) =>
        this.t.extUri.isEqual(e.location, t.location),
      )
    )
  }
  I(t, e, r) {
    const s = [...this.profiles, ...t],
      a = this.q.profiles
    this.q.profiles = []
    const o = []
    for (let c of s) {
      if (e.some((u) => c.id === u.id)) {
        for (const u of [...this.z.emptyWindows.keys()])
          c.id === this.z.emptyWindows.get(u)?.id &&
            this.z.emptyWindows.delete(u)
        continue
      }
      if (!c.isDefault) {
        c = r.find((l) => c.id === l.id) ?? c
        const u = a.find((l) => c.id === l.id)
        if (c.isTransient) this.q.profiles.push(c)
        else if (u) {
          for (const [l, m] of this.q.emptyWindows.entries())
            if (c.id === m.id) {
              this.q.emptyWindows.delete(l), this.z.emptyWindows.set(l, c)
              break
            }
        }
      }
      c.workspaces?.length === 0 && (c.workspaces = void 0), o.push(c)
    }
    this.M(o), this.J(t, e, r)
  }
  J(t, e, r) {
    this.g.fire({ added: t, removed: e, updated: r, all: this.profiles })
  }
  L(t, e, r) {
    ;(r = e?.isTransient ? !0 : r),
      r
        ? e
          ? this.q.emptyWindows.set(t, e)
          : this.q.emptyWindows.delete(t)
        : (this.q.emptyWindows.delete(t),
          e ? this.z.emptyWindows.set(t, e) : this.z.emptyWindows.delete(t))
  }
  M(t) {
    const e = [],
      r = {},
      s = {}
    for (const a of t)
      if (
        !a.isTransient &&
        (a.isDefault ||
          e.push({
            location: a.location,
            name: a.name,
            icon: a.icon,
            useDefaultFlags: a.useDefaultFlags,
          }),
        a.workspaces)
      )
        for (const o of a.workspaces) r[o.toString()] = a.id
    for (const [a, o] of this.z.emptyWindows.entries()) s[a.toString()] = o.id
    this.Q({ workspaces: r, emptyWindows: s }), this.O(e), (this.y = void 0)
  }
  N() {
    return []
  }
  O(t) {
    throw new Error("not implemented")
  }
  P() {
    return {}
  }
  Q(t) {
    throw new Error("not implemented")
  }
  R() {}
}
VG = __decorate(
  [__param(0, x3), __param(1, Tlt), __param(2, WG), __param(3, Kt)],
  VG,
)
var Edt = "__$__isNewStorageMarker",
  O_ = "__$__targetStorageMarker",
  Idt = Y("storageService"),
  xo
;(function (i) {
  ;(i[(i.NONE = 0)] = "NONE"), (i[(i.SHUTDOWN = 1)] = "SHUTDOWN")
})(xo || (xo = {}))
var GG
;(function (i) {
  ;(i[(i.APPLICATION = -1)] = "APPLICATION"),
    (i[(i.PROFILE = 0)] = "PROFILE"),
    (i[(i.WORKSPACE = 1)] = "WORKSPACE")
})(GG || (GG = {}))
var zG
;(function (i) {
  ;(i[(i.USER = 0)] = "USER"), (i[(i.MACHINE = 1)] = "MACHINE")
})(zG || (zG = {}))
function Pdt(i) {
  const t = i.get(O_)
  if (t)
    try {
      return JSON.parse(t)
    } catch {}
  return Object.create(null)
}
var TBt = class Unt extends dt {
  static {
    this.a = 60 * 1e3
  }
  constructor(t = { flushInterval: Unt.a }) {
    super(),
      (this.n = t),
      (this.b = this.D(new YF())),
      (this.f = this.D(new YF())),
      (this.onDidChangeTarget = this.f.event),
      (this.g = this.D(new C())),
      (this.onWillSaveState = this.g.event),
      (this.j = this.D(new po(() => this.q(), this.n.flushInterval))),
      (this.m = this.D(new Zn())),
      (this.C = void 0),
      (this.G = void 0),
      (this.I = void 0),
      (this.N = [])
  }
  onDidChangeValue(t, e, r) {
    return Ee.filter(
      this.b.event,
      (s) => s.scope === t && (e === void 0 || s.key === e),
      r,
    )
  }
  q() {
    this.m.value = nj(() => {
      this.r() && this.flush(), this.j.schedule()
    })
  }
  r() {
    return !0
  }
  t() {
    pn([this.m, this.j])
  }
  initialize() {
    return (
      this.h ||
        (this.h = (async () => {
          Pi("code/willInitStorage")
          try {
            await this.Q()
          } finally {
            Pi("code/didInitStorage")
          }
          this.j.schedule()
        })()),
      this.h
    )
  }
  u(t, e) {
    const { key: r, external: s } = e
    if (r === O_) {
      switch (t) {
        case -1:
          this.I = void 0
          break
        case 0:
          this.G = void 0
          break
        case 1:
          this.C = void 0
          break
      }
      this.f.fire({ scope: t })
    } else this.b.fire({ scope: t, key: r, target: this.L(t)[r], external: s })
  }
  w(t) {
    this.g.fire({ reason: t })
  }
  get(t, e, r) {
    return this.R(e)?.get(t, r)
  }
  getBoolean(t, e, r) {
    return this.R(e)?.getBoolean(t, r)
  }
  getNumber(t, e, r) {
    return this.R(e)?.getNumber(t, r)
  }
  getObject(t, e, r) {
    return this.R(e)?.getObject(t, r)
  }
  storeAll(t, e) {
    this.y(() => {
      for (const r of t) this.store(r.key, r.value, r.scope, r.target, e)
    })
  }
  store(t, e, r, s, a = !1) {
    if (Le(e)) {
      this.remove(t, r, a)
      return
    }
    this.y(() => {
      this.z(t, r, s), this.R(r)?.set(t, e, a)
    })
  }
  remove(t, e, r = !1) {
    this.y(() => {
      this.z(t, e, void 0), this.R(e)?.delete(t, r)
    })
  }
  y(t) {
    this.b.pause(), this.f.pause()
    try {
      t()
    } finally {
      this.b.resume(), this.f.resume()
    }
  }
  keys(t, e) {
    const r = [],
      s = this.L(t)
    for (const a of Object.keys(s)) s[a] === e && r.push(a)
    return r
  }
  z(t, e, r, s = !1) {
    const a = this.L(e)
    typeof r == "number"
      ? a[t] !== r && ((a[t] = r), this.R(e)?.set(O_, JSON.stringify(a), s))
      : typeof a[t] == "number" &&
        (delete a[t], this.R(e)?.set(O_, JSON.stringify(a), s))
  }
  get F() {
    return this.C || (this.C = this.M(1)), this.C
  }
  get H() {
    return this.G || (this.G = this.M(0)), this.G
  }
  get J() {
    return this.I || (this.I = this.M(-1)), this.I
  }
  L(t) {
    switch (t) {
      case -1:
        return this.J
      case 0:
        return this.H
      default:
        return this.F
    }
  }
  M(t) {
    const e = this.R(t)
    return e ? Pdt(e) : Object.create(null)
  }
  isNew(t) {
    return this.getBoolean(Edt, t) === !0
  }
  async cursorDiskKVGet(t) {
    return this.R(-1)?.cursorDiskKVGet(t)
  }
  async cursorDiskKVSet(t, e) {
    return this.R(-1)?.cursorDiskKVSet(t, e)
  }
  cursorDiskKVOnShouldSave(t) {
    return (
      this.N.push(t),
      {
        dispose: () => {
          this.N = this.N.filter((e) => e !== t)
        },
      }
    )
  }
  async flush(t = xo.NONE) {
    this.g.fire({ reason: t })
    const e = this.R(-1),
      r = this.R(0),
      s = this.R(1)
    switch (t) {
      case xo.NONE:
        for (const a of this.N)
          try {
            a().catch(console.error)
          } catch {}
        await vo.settled([
          e?.whenFlushed() ?? Promise.resolve(),
          r?.whenFlushed() ?? Promise.resolve(),
          s?.whenFlushed() ?? Promise.resolve(),
        ])
        break
      case xo.SHUTDOWN:
        for (const a of this.N)
          try {
            await a()
          } catch (o) {
            console.error(o)
          }
        await vo.settled([
          e?.flush(0) ?? Promise.resolve(),
          r?.flush(0) ?? Promise.resolve(),
          s?.flush(0) ?? Promise.resolve(),
        ])
        break
    }
  }
  async log() {
    const t = this.R(-1)?.items ?? new Map(),
      e = this.R(0)?.items ?? new Map(),
      r = this.R(1)?.items ?? new Map()
    return Ndt(t, e, r, this.S(-1) ?? "", this.S(0) ?? "", this.S(1) ?? "")
  }
  async optimize(t) {
    return await this.flush(), this.R(t)?.optimize()
  }
  async switch(t, e) {
    return this.w(xo.NONE), Sdt(t) ? this.U(t, e) : this.W(t, e)
  }
  O(t, e) {
    return !(t.id === e.id || (YG(e) && YG(t)))
  }
  P(t, e, r) {
    this.y(() => {
      const s = new Set()
      for (const [a, o] of t)
        s.add(a), e.get(a) !== o && this.u(r, { key: a, external: !0 })
      for (const [a] of e.items) s.has(a) || this.u(r, { key: a, external: !0 })
    })
  }
}
function YG(i) {
  return i.isDefault || !!i.useDefaultFlags?.globalState
}
async function Ndt(i, t, e, r, s, a) {
  const o = (T) => {
      try {
        return JSON.parse(T)
      } catch {
        return T
      }
    },
    c = new Map(),
    u = new Map()
  i.forEach((T, b) => {
    c.set(b, T), u.set(b, o(T))
  })
  const l = new Map(),
    m = new Map()
  t.forEach((T, b) => {
    l.set(b, T), m.set(b, o(T))
  })
  const h = new Map(),
    p = new Map()
  e.forEach((T, b) => {
    h.set(b, T), p.set(b, o(T))
  }),
    console.group(
      r !== s
        ? `Storage: Application (path: ${r})`
        : `Storage: Application & Profile (path: ${r}, default profile)`,
    )
  const g = []
  if (
    (c.forEach((T, b) => {
      g.push({ key: b, value: T })
    }),
    console.table(g),
    console.groupEnd(),
    console.log(u),
    r !== s)
  ) {
    console.group(`Storage: Profile (path: ${s}, profile specific)`)
    const T = []
    l.forEach((b, N) => {
      T.push({ key: N, value: b })
    }),
      console.table(T),
      console.groupEnd(),
      console.log(m)
  }
  console.group(`Storage: Workspace (path: ${a})`)
  const w = []
  h.forEach((T, b) => {
    w.push({ key: b, value: T })
  }),
    console.table(w),
    console.groupEnd(),
    console.log(p)
}
var nl
;(function (i) {
  ;(i.responseVote = new H("chatSessionResponseVote", "", {
    type: "string",
    description: f(5103, null),
  })),
    (i.responseDetectedAgentCommand = new H(
      "chatSessionResponseDetectedAgentOrCommand",
      !1,
      { type: "boolean", description: f(5104, null) },
    )),
    (i.responseSupportsIssueReporting = new H(
      "chatResponseSupportsIssueReporting",
      !1,
      { type: "boolean", description: f(5105, null) },
    )),
    (i.responseIsFiltered = new H("chatSessionResponseFiltered", !1, {
      type: "boolean",
      description: f(5106, null),
    })),
    (i.responseHasError = new H("chatSessionResponseError", !1, {
      type: "boolean",
      description: f(5107, null),
    })),
    (i.requestInProgress = new H("chatSessionRequestInProgress", !1, {
      type: "boolean",
      description: f(5108, null),
    })),
    (i.isResponse = new H("chatResponse", !1, {
      type: "boolean",
      description: f(5109, null),
    })),
    (i.isRequest = new H("chatRequest", !1, {
      type: "boolean",
      description: f(5110, null),
    })),
    (i.itemId = new H("chatItemId", "", {
      type: "string",
      description: f(5111, null),
    })),
    (i.lastItemId = new H("chatLastItemId", [], {
      type: "string",
      description: f(5112, null),
    })),
    (i.editApplied = new H("chatEditApplied", !1, {
      type: "boolean",
      description: f(5113, null),
    })),
    (i.inputHasText = new H("chatInputHasText", !1, {
      type: "boolean",
      description: f(5114, null),
    })),
    (i.inputHasFocus = new H("chatInputHasFocus", !1, {
      type: "boolean",
      description: f(5115, null),
    })),
    (i.inChatInput = new H("inChatInput", !1, {
      type: "boolean",
      description: f(5116, null),
    })),
    (i.inChatSession = new H("inChat", !1, {
      type: "boolean",
      description: f(5117, null),
    })),
    (i.enabled = new H("chatIsEnabled", !1, {
      type: "boolean",
      description: f(5118, null),
    })),
    (i.panelParticipantRegistered = new H(
      "chatPanelParticipantRegistered",
      !1,
      { type: "boolean", description: f(5119, null) },
    )),
    (i.editingParticipantRegistered = new H(
      "chatEditingParticipantRegistered",
      !1,
      { type: "boolean", description: f(5120, null) },
    )),
    (i.chatEditingCanUndo = new H("chatEditingCanUndo", !1, {
      type: "boolean",
      description: f(5121, null),
    })),
    (i.chatEditingCanRedo = new H("chatEditingCanRedo", !1, {
      type: "boolean",
      description: f(5122, null),
    })),
    (i.extensionInvalid = new H("chatExtensionInvalid", !1, {
      type: "boolean",
      description: f(5123, null),
    })),
    (i.inputCursorAtTop = new H("chatCursorAtTop", !1)),
    (i.inputHasAgent = new H("chatInputHasAgent", !1)),
    (i.location = new H("chatLocation", void 0)),
    (i.inQuickChat = new H("quickChatHasFocus", !1, {
      type: "boolean",
      description: f(5124, null),
    })),
    (i.hasFileAttachments = new H("chatHasFileAttachments", !1, {
      type: "boolean",
      description: f(5125, null),
    })),
    (i.languageModelsAreUserSelectable = new H(
      "chatModelsAreUserSelectable",
      !1,
      { type: "boolean", description: f(5126, null) },
    )),
    (i.Setup = {
      canSignUp: new H("chatSetupCanSignUp", !1, !0),
      signedOut: new H("chatSetupSignedOut", !1, !0),
      limited: new H("chatSetupLimited", !1, !0),
      triggered: new H("chatSetupTriggered", !1, !0),
      installed: new H("chatSetupInstalled", !1, !0),
    }),
    (i.chatQuotaExceeded = new H("chatQuotaExceeded", !1, !0)),
    (i.completionsQuotaExceeded = new H("completionsQuotaExceeded", !1, !0))
})(nl || (nl = {}))
var sl, li
;(function (i) {
  ;(i.Panel = "panel"),
    (i.Terminal = "terminal"),
    (i.Notebook = "notebook"),
    (i.Editor = "editor"),
    (i.EditingSession = "editing-session")
})(li || (li = {})),
  (function (i) {
    function t(e) {
      switch (e) {
        case "panel":
          return i.Panel
        case "terminal":
          return i.Terminal
        case "notebook":
          return i.Notebook
        case "editor":
          return i.Editor
        case "editing-session":
          return i.EditingSession
      }
      return i.Panel
    }
    i.fromRaw = t
  })(li || (li = {}))
var kBt = Y("chatAgentService"),
  QG = class extends dt {
    static {
      this.AGENT_LEADER = "@"
    }
    constructor(t) {
      super(),
        (this.q = t),
        (this.b = new Map()),
        (this.f = new C()),
        (this.onDidChangeAgents = this.f.event),
        (this.g = new Set()),
        (this.n = new Map()),
        (this.t = new Map()),
        (this.h = nl.enabled.bindTo(this.q)),
        (this.j = nl.panelParticipantRegistered.bindTo(this.q)),
        (this.m = nl.editingParticipantRegistered.bindTo(this.q)),
        this.D(
          t.onDidChangeContext((e) => {
            e.affectsSome(this.g) && this.s()
          }),
        )
    }
    registerAgent(t, e) {
      if (this.getAgent(t))
        throw new Error(`Agent already registered: ${JSON.stringify(t)}`)
      const s = this,
        a = e.slashCommands
      e = {
        ...e,
        get slashCommands() {
          return a.filter(
            (c) => !c.when || s.q.contextMatchesRules(ze.deserialize(c.when)),
          )
        },
      }
      const o = { data: e }
      return (
        this.b.set(t, o),
        this.r(),
        this.s(),
        this.f.fire(void 0),
        it(() => {
          this.b.delete(t), this.r(), this.s(), this.f.fire(void 0)
        })
      )
    }
    r() {
      this.g.clear()
      for (const t of this.b.values())
        if (t.data.when) {
          const e = ze.deserialize(t.data.when)
          for (const r of e?.keys() || []) this.g.add(r)
        }
    }
    s() {
      let t = !1,
        e = !1
      for (const r of this.getAgents())
        r.isDefault && r.locations.includes(li.EditingSession)
          ? (t = !0)
          : r.isDefault && (e = !0)
      this.m.set(t), this.j.set(e)
    }
    registerAgentImplementation(t, e) {
      const r = this.b.get(t)
      if (!r) throw new Error(`Unknown agent: ${JSON.stringify(t)}`)
      if (r.impl)
        throw new Error(
          `Agent already has implementation: ${JSON.stringify(t)}`,
        )
      return (
        r.data.isDefault && this.h.set(!0),
        (r.impl = e),
        this.f.fire(new q_(r.data, e)),
        it(() => {
          ;(r.impl = void 0),
            this.f.fire(void 0),
            r.data.isDefault && this.h.set(!1)
        })
      )
    }
    registerDynamicAgent(t, e) {
      t.isDynamic = !0
      const r = { data: t, impl: e }
      return (
        this.b.set(t.id, r),
        this.f.fire(new q_(t, e)),
        it(() => {
          this.b.delete(t.id), this.f.fire(void 0)
        })
      )
    }
    registerAgentCompletionProvider(t, e) {
      return (
        this.t.set(t, e),
        {
          dispose: () => {
            this.t.delete(t)
          },
        }
      )
    }
    async getAgentCompletionItems(t, e, r) {
      return (await this.t.get(t)?.(e, r)) ?? []
    }
    updateAgent(t, e) {
      const r = this.b.get(t)
      if (!r?.impl)
        throw new Error(
          `No activated agent with id ${JSON.stringify(t)} registered`,
        )
      ;(r.data.metadata = { ...r.data.metadata, ...e }),
        this.f.fire(new q_(r.data, r.impl))
    }
    getDefaultAgent(t) {
      return zst(
        this.getActivatedAgents(),
        (e) => !!e.isDefault && e.locations.includes(t),
      )
    }
    getContributedDefaultAgent(t) {
      return this.getAgents().find(
        (e) => !!e.isDefault && e.locations.includes(t),
      )
    }
    getSecondaryAgent() {
      return Yi.find(this.b.values(), (t) => !!t.data.metadata.isSecondary)
        ?.data
    }
    getAgent(t, e = !1) {
      if (!(!this.u(t) && !e)) return this.b.get(t)?.data
    }
    u(t) {
      const e = this.b.get(t)
      return (
        !e?.data.when || this.q.contextMatchesRules(ze.deserialize(e.data.when))
      )
    }
    getAgentByFullyQualifiedId(t) {
      const e = Yi.find(this.b.values(), (r) => $dt(r.data) === t)?.data
      if (!(e && !this.u(e.id))) return e
    }
    getAgents() {
      return Array.from(this.b.values())
        .map((t) => t.data)
        .filter((t) => this.u(t.id))
    }
    getActivatedAgents() {
      return Array.from(this.b.values())
        .filter((t) => !!t.impl)
        .filter((t) => this.u(t.data.id))
        .map((t) => new q_(t.data, t.impl))
    }
    getAgentsByName(t) {
      return this.getAgents().filter((e) => e.name === t)
    }
    agentHasDupeName(t) {
      const e = this.getAgent(t)
      return e
        ? this.getAgentsByName(e.name).filter(
            (r) => r.extensionId.value !== e.extensionId.value,
          ).length > 0
        : !1
    }
    async invokeAgent(t, e, r, s, a) {
      const o = this.b.get(t)
      if (!o?.impl) throw new Error(`No activated agent with id "${t}"`)
      return await o.impl.invoke(e, r, s, a)
    }
    async getFollowups(t, e, r, s, a) {
      const o = this.b.get(t)
      if (!o?.impl) throw new Error(`No activated agent with id "${t}"`)
      return o.impl?.provideFollowups ? o.impl.provideFollowups(e, r, s, a) : []
    }
    async getChatTitle(t, e, r) {
      const s = this.b.get(t)
      if (!s?.impl) throw new Error(`No activated agent with id "${t}"`)
      if (s.impl?.provideChatTitle) return s.impl.provideChatTitle(e, r)
    }
    registerChatParticipantDetectionProvider(t, e) {
      return (
        this.n.set(t, e),
        it(() => {
          this.n.delete(t)
        })
      )
    }
    hasChatParticipantDetectionProviders() {
      return this.n.size > 0
    }
    async detectAgentOrCommand(t, e, r, s) {
      const a = Yi.first(this.n.values())
      if (!a) return
      const o = this.getAgents().reduce((m, h) => {
          if (h.locations.includes(r.location)) {
            m.push({
              participant: h.id,
              disambiguation: h.disambiguation ?? [],
            })
            for (const p of h.slashCommands)
              m.push({
                participant: h.id,
                command: p.name,
                disambiguation: p.disambiguation ?? [],
              })
          }
          return m
        }, []),
        c = await a.provideParticipantDetection(
          t,
          e,
          { ...r, participants: o },
          s,
        )
      if (!c) return
      const u = this.getAgent(c.participant)
      if (!u) return
      if (!c.command) return { agent: u }
      const l = u?.slashCommands.find((m) => m.name === c.command)
      if (l) return { agent: u, command: l }
    }
  }
QG = __decorate([__param(0, zct)], QG)
var q_ = class {
    constructor(i, t) {
      ;(this.b = i), (this.d = t)
    }
    get id() {
      return this.b.id
    }
    get name() {
      return this.b.name ?? ""
    }
    get fullName() {
      return this.b.fullName ?? ""
    }
    get description() {
      return this.b.description ?? ""
    }
    get extensionId() {
      return this.b.extensionId
    }
    get extensionPublisherId() {
      return this.b.extensionPublisherId
    }
    get extensionPublisherDisplayName() {
      return this.b.publisherDisplayName
    }
    get extensionDisplayName() {
      return this.b.extensionDisplayName
    }
    get isDefault() {
      return this.b.isDefault
    }
    get metadata() {
      return this.b.metadata
    }
    get slashCommands() {
      return this.b.slashCommands
    }
    get locations() {
      return this.b.locations
    }
    get disambiguation() {
      return this.b.disambiguation
    }
    async invoke(i, t, e, r) {
      return this.d.invoke(i, t, e, r)
    }
    async provideFollowups(i, t, e, r) {
      return this.d.provideFollowups ? this.d.provideFollowups(i, t, e, r) : []
    }
    provideWelcomeMessage(i) {
      if (this.d.provideWelcomeMessage) return this.d.provideWelcomeMessage(i)
    }
    provideSampleQuestions(i, t) {
      if (this.d.provideSampleQuestions)
        return this.d.provideSampleQuestions(i, t)
    }
    toJSON() {
      return this.b
    }
  },
  bBt = Y("chatAgentNameService"),
  XG = class {
    static {
      sl = this
    }
    static {
      this.b = "chat.participantNameRegistry"
    }
    constructor(t, e, r, s) {
      if (
        ((this.h = e),
        (this.i = r),
        (this.j = s),
        (this.f = Xlt(this, Object.create(null))),
        (this.g = !1),
        !t.chatParticipantRegistry)
      )
        return
      this.d = t.chatParticipantRegistry
      const a = s.get(sl.b, -1)
      try {
        this.f.set(JSON.parse(a ?? "{}"), void 0)
      } catch {
        s.remove(sl.b, -1)
      }
      this.k()
    }
    k() {
      this.g ||
        this.l()
          .catch((t) =>
            this.i.warn("Failed to fetch chat participant registry", t),
          )
          .then(() => Kr(5 * 60 * 1e3))
          .then(() => this.k())
    }
    async l() {
      const t = await this.h.request({ type: "GET", url: this.d }, fe.None)
      if (t.res.statusCode !== 200)
        throw new Error("Could not get extensions report.")
      const e = await Tdt(t)
      if (!e || e.version !== 1)
        throw new Error("Unexpected chat participant registry response.")
      const r = e.restrictedChatParticipants
      this.f.set(r, void 0), this.j.store(sl.b, JSON.stringify(r), -1, 1)
    }
    getAgentNameRestriction(t) {
      const e = this.m(t.name, t).get(),
        r = !t.fullName || this.m(t.fullName.replace(/\s/g, ""), t).get()
      return e && r
    }
    m(t, e) {
      return this.f
        .map((s) => s[t.toLowerCase()])
        .map((s) =>
          s
            ? s.some((a) =>
                as(
                  a,
                  a.includes(".")
                    ? e.extensionId.value
                    : e.extensionPublisherId,
                ),
              )
            : !0,
        )
    }
    dispose() {
      this.g = !0
    }
  }
XG = sl = __decorate(
  [__param(0, sdt), __param(1, vdt), __param(2, Kt), __param(3, Idt)],
  XG,
)
function $dt(i) {
  return `${i.extensionId.value}.${i.id}`
}
var ha = "**",
  J3 = "/",
  U_ = "[/\\\\]",
  M_ = "[^/\\\\]",
  xdt = /\//g
function KG(i, t) {
  switch (i) {
    case 0:
      return ""
    case 1:
      return `${M_}*?`
    default:
      return `(?:${U_}|${M_}+${U_}${t ? `|${U_}${M_}+` : ""})*?`
  }
}
function C3(i, t) {
  if (!i) return []
  const e = []
  let r = !1,
    s = !1,
    a = ""
  for (const o of i) {
    switch (o) {
      case t:
        if (!r && !s) {
          e.push(a), (a = "")
          continue
        }
        break
      case "{":
        r = !0
        break
      case "}":
        r = !1
        break
      case "[":
        s = !0
        break
      case "]":
        s = !1
        break
    }
    a += o
  }
  return a && e.push(a), e
}
function ZG(i) {
  if (!i) return ""
  let t = ""
  const e = C3(i, J3)
  if (e.every((r) => r === ha)) t = ".*"
  else {
    let r = !1
    e.forEach((s, a) => {
      if (s === ha) {
        if (r) return
        t += KG(2, a === e.length - 1)
      } else {
        let o = !1,
          c = "",
          u = !1,
          l = ""
        for (const m of s) {
          if (m !== "}" && o) {
            c += m
            continue
          }
          if (u && (m !== "]" || !l)) {
            let h
            m === "-"
              ? (h = m)
              : (m === "^" || m === "!") && !l
                ? (h = "^")
                : m === J3
                  ? (h = "")
                  : (h = Ks(m)),
              (l += h)
            continue
          }
          switch (m) {
            case "{":
              o = !0
              continue
            case "[":
              u = !0
              continue
            case "}": {
              const p = `(?:${C3(c, ",")
                .map((g) => ZG(g))
                .join("|")})`
              ;(t += p), (o = !1), (c = "")
              break
            }
            case "]": {
              ;(t += "[" + l + "]"), (u = !1), (l = "")
              break
            }
            case "?":
              t += M_
              continue
            case "*":
              t += KG(1)
              continue
            default:
              t += Ks(m)
          }
        }
        a < e.length - 1 && (e[a + 1] !== ha || a + 2 < e.length) && (t += U_)
      }
      r = s === ha
    })
  }
  return t
}
var Jdt = /^\*\*\/\*\.[\w\.-]+$/,
  Cdt = /^\*\*\/([\w\.-]+)\/?$/,
  Ldt = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/,
  Rdt = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/,
  Ddt = /^\*\*((\/[\w\.-]+)+)\/?$/,
  Fdt = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/,
  tz = new oB(1e4),
  ez = function () {
    return !1
  },
  en = function () {
    return null
  }
function L3(i, t) {
  if (!i) return en
  let e
  typeof i != "string" ? (e = i.pattern) : (e = i), (e = e.trim())
  const r = `${e}_${!!t.trimForExclusions}`
  let s = tz.get(r)
  if (s) return iz(s, i)
  let a
  return (
    Jdt.test(e)
      ? (s = _dt(e.substr(4), e))
      : (a = Cdt.exec(R3(e, t)))
        ? (s = Adt(a[1], e))
        : (t.trimForExclusions ? Rdt : Ldt).test(e)
          ? (s = Bdt(e, t))
          : (a = Ddt.exec(R3(e, t)))
            ? (s = rz(a[1].substr(1), e, !0))
            : (a = Fdt.exec(R3(e, t)))
              ? (s = rz(a[1], e, !1))
              : (s = Odt(e)),
    tz.set(r, s),
    iz(s, i)
  )
}
function iz(i, t) {
  if (typeof t == "string") return i
  const e = function (r, s) {
    return c_(r, t.base, !es) ? i(Sot(r.substr(t.base.length), kr), s) : null
  }
  return (
    (e.allBasenames = i.allBasenames),
    (e.allPaths = i.allPaths),
    (e.basenames = i.basenames),
    (e.patterns = i.patterns),
    e
  )
}
function R3(i, t) {
  return t.trimForExclusions && i.endsWith("/**")
    ? i.substr(0, i.length - 2)
    : i
}
function _dt(i, t) {
  return function (e, r) {
    return typeof e == "string" && e.endsWith(i) ? t : null
  }
}
function Adt(i, t) {
  const e = `/${i}`,
    r = `\\${i}`,
    s = function (o, c) {
      return typeof o != "string"
        ? null
        : c
          ? c === i
            ? t
            : null
          : o === i || o.endsWith(e) || o.endsWith(r)
            ? t
            : null
    },
    a = [i]
  return (s.basenames = a), (s.patterns = [t]), (s.allBasenames = a), s
}
function Bdt(i, t) {
  const e = nz(
      i
        .slice(1, -1)
        .split(",")
        .map((c) => L3(c, t))
        .filter((c) => c !== en),
      i,
    ),
    r = e.length
  if (!r) return en
  if (r === 1) return e[0]
  const s = function (c, u) {
      for (let l = 0, m = e.length; l < m; l++) if (e[l](c, u)) return i
      return null
    },
    a = e.find((c) => !!c.allBasenames)
  a && (s.allBasenames = a.allBasenames)
  const o = e.reduce((c, u) => (u.allPaths ? c.concat(u.allPaths) : c), [])
  return o.length && (s.allPaths = o), s
}
function rz(i, t, e) {
  const r = kr === Ut.sep,
    s = r ? i : i.replace(xdt, kr),
    a = kr + s,
    o = Ut.sep + i
  let c
  return (
    e
      ? (c = function (u, l) {
          return typeof u == "string" &&
            (u === s || u.endsWith(a) || (!r && (u === i || u.endsWith(o))))
            ? t
            : null
        })
      : (c = function (u, l) {
          return typeof u == "string" && (u === s || (!r && u === i)) ? t : null
        }),
    (c.allPaths = [(e ? "*/" : "./") + i]),
    c
  )
}
function Odt(i) {
  try {
    const t = new RegExp(`^${ZG(i)}$`)
    return function (e) {
      return (t.lastIndex = 0), typeof e == "string" && t.test(e) ? i : null
    }
  } catch {
    return en
  }
}
function al(i, t, e) {
  return !i || typeof t != "string" ? !1 : Jo(i)(t, void 0, e)
}
function Jo(i, t = {}) {
  if (!i) return ez
  if (typeof i == "string" || qdt(i)) {
    const e = L3(i, t)
    if (e === en) return ez
    const r = function (s, a) {
      return !!e(s, a)
    }
    return (
      e.allBasenames && (r.allBasenames = e.allBasenames),
      e.allPaths && (r.allPaths = e.allPaths),
      r
    )
  }
  return Udt(i, t)
}
function qdt(i) {
  const t = i
  return t ? typeof t.base == "string" && typeof t.pattern == "string" : !1
}
function Udt(i, t) {
  const e = nz(
      Object.getOwnPropertyNames(i)
        .map((c) => Mdt(c, i[c], t))
        .filter((c) => c !== en),
    ),
    r = e.length
  if (!r) return en
  if (!e.some((c) => !!c.requiresSiblings)) {
    if (r === 1) return e[0]
    const c = function (m, h) {
        let p
        for (let g = 0, w = e.length; g < w; g++) {
          const T = e[g](m, h)
          if (typeof T == "string") return T
          wn(T) && (p || (p = []), p.push(T))
        }
        return p
          ? (async () => {
              for (const g of p) {
                const w = await g
                if (typeof w == "string") return w
              }
              return null
            })()
          : null
      },
      u = e.find((m) => !!m.allBasenames)
    u && (c.allBasenames = u.allBasenames)
    const l = e.reduce((m, h) => (h.allPaths ? m.concat(h.allPaths) : m), [])
    return l.length && (c.allPaths = l), c
  }
  const s = function (c, u, l) {
      let m, h
      for (let p = 0, g = e.length; p < g; p++) {
        const w = e[p]
        w.requiresSiblings &&
          l &&
          (u || (u = ji(c)), m || (m = u.substr(0, u.length - SB(c).length)))
        const T = w(c, u, m, l)
        if (typeof T == "string") return T
        wn(T) && (h || (h = []), h.push(T))
      }
      return h
        ? (async () => {
            for (const p of h) {
              const g = await p
              if (typeof g == "string") return g
            }
            return null
          })()
        : null
    },
    a = e.find((c) => !!c.allBasenames)
  a && (s.allBasenames = a.allBasenames)
  const o = e.reduce((c, u) => (u.allPaths ? c.concat(u.allPaths) : c), [])
  return o.length && (s.allPaths = o), s
}
function Mdt(i, t, e) {
  if (t === !1) return en
  const r = L3(i, e)
  if (r === en) return en
  if (typeof t == "boolean") return r
  if (t) {
    const s = t.when
    if (typeof s == "string") {
      const a = (o, c, u, l) => {
        if (!l || !r(o, c)) return null
        const m = s.replace("$(basename)", () => u),
          h = l(m)
        return wn(h) ? h.then((p) => (p ? i : null)) : h ? i : null
      }
      return (a.requiresSiblings = !0), a
    }
  }
  return r
}
function nz(i, t) {
  const e = i.filter((c) => !!c.basenames)
  if (e.length < 2) return i
  const r = e.reduce((c, u) => {
    const l = u.basenames
    return l ? c.concat(l) : c
  }, [])
  let s
  if (t) {
    s = []
    for (let c = 0, u = r.length; c < u; c++) s.push(t)
  } else
    s = e.reduce((c, u) => {
      const l = u.patterns
      return l ? c.concat(l) : c
    }, [])
  const a = function (c, u) {
    if (typeof c != "string") return null
    if (!u) {
      let m
      for (m = c.length; m > 0; m--) {
        const h = c.charCodeAt(m - 1)
        if (h === 47 || h === 92) break
      }
      u = c.substr(m)
    }
    const l = r.indexOf(u)
    return l !== -1 ? s[l] : null
  }
  ;(a.basenames = r), (a.patterns = s), (a.allBasenames = r)
  const o = i.filter((c) => !c.basenames)
  return o.push(a), o
}
var Hdt = Y("notebookDocumentService"),
  D3 = ["W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f"],
  Wdt = new RegExp(`^[${D3.join("")}]+`),
  sz = 7
function az(i) {
  if (i.scheme !== Q.vscodeNotebookCell) return
  const t = i.fragment.indexOf("s")
  if (t < 0) return
  const e = parseInt(i.fragment.substring(0, t).replace(Wdt, ""), sz),
    r = jF(i.fragment.substring(t + 1)).toString()
  if (!isNaN(e))
    return { handle: e, notebook: i.with({ scheme: r, fragment: null }) }
}
function jdt(i, t) {
  const e = t.toString(sz),
    s = `${e.length < D3.length ? D3[e.length - 1] : "z"}${e}s${VF(Et.fromString(i.scheme), !0, !0)}`
  return i.with({ scheme: Q.vscodeNotebookCell, fragment: s })
}
function Vdt(i) {
  if (i.scheme !== Q.vscodeNotebookMetadata) return
  const t = jF(i.fragment).toString()
  return i.with({ scheme: t, fragment: null })
}
function Gdt(i) {
  const t = `${VF(Et.fromString(i.scheme), !0, !0)}`
  return i.with({ scheme: Q.vscodeNotebookMetadata, fragment: t })
}
var zdt = class {
  constructor() {
    this.a = new ei()
  }
  getNotebook(i) {
    if (i.scheme === Q.vscodeNotebookCell) {
      const t = az(i)
      if (t) {
        const e = this.a.get(t.notebook)
        if (e) return e
      }
    }
    return this.a.get(i)
  }
  addNotebookDocument(i) {
    this.a.set(i.uri, i)
  }
  removeNotebookDocument(i) {
    this.a.delete(i.uri)
  }
}
Zt(Hdt, zdt, 1)
var Co
;(function (i) {
  ;(i[(i.Markup = 1)] = "Markup"), (i[(i.Code = 2)] = "Code")
})(Co || (Co = {}))
var IBt = [
    "application/json",
    "application/javascript",
    "text/html",
    "image/svg+xml",
    kn.latex,
    kn.markdown,
    "image/png",
    "image/jpeg",
    kn.text,
  ],
  PBt = [
    kn.latex,
    kn.markdown,
    "application/json",
    "text/html",
    "image/svg+xml",
    "image/png",
    "image/jpeg",
    kn.text,
  ],
  oz
;(function (i) {
  ;(i[(i.Running = 1)] = "Running"), (i[(i.Idle = 2)] = "Idle")
})(oz || (oz = {}))
var ol
;(function (i) {
  ;(i[(i.Unconfirmed = 1)] = "Unconfirmed"),
    (i[(i.Pending = 2)] = "Pending"),
    (i[(i.Executing = 3)] = "Executing")
})(ol || (ol = {}))
var cz
;(function (i) {
  ;(i[(i.Unconfirmed = 1)] = "Unconfirmed"),
    (i[(i.Pending = 2)] = "Pending"),
    (i[(i.Executing = 3)] = "Executing")
})(cz || (cz = {}))
var uz
;(function (i) {
  ;(i[(i.WithHardKernelDependency = 0)] = "WithHardKernelDependency"),
    (i[(i.WithOptionalKernelDependency = 1)] = "WithOptionalKernelDependency"),
    (i[(i.Pure = 2)] = "Pure"),
    (i[(i.Never = 3)] = "Never")
})(uz || (uz = {}))
var lz
;(function (i) {
  ;(i.Always = "always"), (i.Never = "never"), (i.Optional = "optional")
})(lz || (lz = {}))
var $r
;(function (i) {
  ;(i[(i.ModelChange = 1)] = "ModelChange"),
    (i[(i.Move = 2)] = "Move"),
    (i[(i.ChangeCellLanguage = 5)] = "ChangeCellLanguage"),
    (i[(i.Initialize = 6)] = "Initialize"),
    (i[(i.ChangeCellMetadata = 7)] = "ChangeCellMetadata"),
    (i[(i.Output = 8)] = "Output"),
    (i[(i.OutputItem = 9)] = "OutputItem"),
    (i[(i.ChangeCellContent = 10)] = "ChangeCellContent"),
    (i[(i.ChangeDocumentMetadata = 11)] = "ChangeDocumentMetadata"),
    (i[(i.ChangeCellInternalMetadata = 12)] = "ChangeCellInternalMetadata"),
    (i[(i.ChangeCellMime = 13)] = "ChangeCellMime"),
    (i[(i.Unknown = 100)] = "Unknown")
})($r || ($r = {}))
var dz
;(function (i) {
  ;(i[(i.Handle = 0)] = "Handle"), (i[(i.Index = 1)] = "Index")
})(dz || (dz = {}))
var mz
;(function (i) {
  ;(i[(i.Replace = 1)] = "Replace"),
    (i[(i.Output = 2)] = "Output"),
    (i[(i.Metadata = 3)] = "Metadata"),
    (i[(i.CellLanguage = 4)] = "CellLanguage"),
    (i[(i.DocumentMetadata = 5)] = "DocumentMetadata"),
    (i[(i.Move = 6)] = "Move"),
    (i[(i.OutputItems = 7)] = "OutputItems"),
    (i[(i.PartialMetadata = 8)] = "PartialMetadata"),
    (i[(i.PartialInternalMetadata = 9)] = "PartialInternalMetadata")
})(mz || (mz = {}))
var hz
;(function (i) {
  i.scheme = Q.vscodeNotebookMetadata
  function t(r) {
    return Gdt(r)
  }
  i.generate = t
  function e(r) {
    return Vdt(r)
  }
  i.parse = e
})(hz || (hz = {}))
var fz
;(function (i) {
  i.scheme = Q.vscodeNotebookCell
  function t(c, u) {
    return jdt(c, u)
  }
  i.generate = t
  function e(c) {
    return az(c)
  }
  i.parse = e
  function r(c, u) {
    return c.with({
      scheme: Q.vscodeNotebookCellOutput,
      fragment: `op${u ?? ""},${c.scheme !== Q.file ? c.scheme : ""}`,
    })
  }
  i.generateCellOutputUri = r
  function s(c) {
    if (c.scheme !== Q.vscodeNotebookCellOutput) return
    const u =
      /^op([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})?\,(.*)$/i.exec(
        c.fragment,
      )
    if (!u) return
    const l = u[1] && u[1] !== "" ? u[1] : void 0,
      m = u[2]
    return {
      outputId: l,
      notebook: c.with({ scheme: m || Q.file, fragment: null }),
    }
  }
  i.parseCellOutputUri = s
  function a(c, u, l) {
    return i.generate(c, u).with({ scheme: l })
  }
  i.generateCellPropertyUri = a
  function o(c, u) {
    if (c.scheme === u) return i.parse(c.with({ scheme: i.scheme }))
  }
  i.parseCellPropertyUri = o
})(fz || (fz = {}))
var NBt = new H("notebookEditorCursorAtBoundary", "none"),
  $Bt = new H("notebookEditorCursorAtLineBoundary", "none"),
  pz
;(function (i) {
  ;(i.default = "default"), (i.option = "option")
})(pz || (pz = {}))
var gz
;(function (i) {
  ;(i.Cells = "cells"), (i.Text = "text"), (i.None = "none")
})(gz || (gz = {}))
var vz
;(function (i) {
  ;(i[(i.Left = 1)] = "Left"), (i[(i.Right = 2)] = "Right")
})(vz || (vz = {}))
var xBt = class U8 {
  static {
    this.d = "notebook/"
  }
  static create(t, e) {
    return `${U8.d}${t}/${e ?? t}`
  }
  static parse(t) {
    if (t.startsWith(U8.d)) {
      const e = t.substring(U8.d.length).split("/")
      if (e.length === 2) return { notebookType: e[0], viewType: e[1] }
    }
  }
}
function wz(i) {
  return [
    "application/vnd.code.notebook.stdout",
    "application/vnd.code.notebook.stderr",
  ].includes(i)
}
var Ydt = new TextDecoder()
function Qdt(i) {
  const t = []
  let e = !1
  for (const o of i) (t.length === 0 || e) && (t.push(o), (e = !0))
  let r = Kdt(t)
  const s = Et.concat(t.map((o) => Et.wrap(o))),
    a = rmt(s)
  return (
    (r = r || a.byteLength !== s.byteLength), { data: a, didCompression: r }
  )
}
var H_ = "\x1B[A",
  F3 = H_.split("").map((i) => i.charCodeAt(0)),
  Xdt = 10
function Kdt(i) {
  let t = !1
  return (
    i.forEach((e, r) => {
      if (r === 0 || e.length < H_.length) return
      const s = i[r - 1],
        a = e.subarray(0, H_.length)
      if (a[0] === F3[0] && a[1] === F3[1] && a[2] === F3[2]) {
        const o = s.lastIndexOf(Xdt)
        if (o === -1) return
        ;(t = !0), (i[r - 1] = s.subarray(0, o)), (i[r] = e.subarray(H_.length))
      }
    }),
    t
  )
}
function Zdt(i) {
  let t = i
  do (i = t), (t = i.replace(/[^\n]\x08/gm, ""))
  while (t.length < i.length)
  return i
}
function tmt(i) {
  for (
    i = i.replace(
      /\r+\n/gm,
      `
`,
    );
    i.search(/\r[^$]/g) > -1;

  ) {
    const t = i.match(/^(.*)\r+/m)[1]
    let e = i.match(/\r+(.*)$/m)[1]
    ;(e = e + t.slice(e.length, t.length)),
      (i = i.replace(/\r+.*$/m, "\r").replace(/^.*\r/m, e))
  }
  return i
}
var emt = 8,
  imt = 13
function rmt(i) {
  return !i.buffer.includes(emt) && !i.buffer.includes(imt)
    ? i
    : Et.fromString(tmt(Zdt(Ydt.decode(i.buffer))))
}
var yz
;(function (i) {
  i.Delimiter = "\0"
})(yz || (yz = {}))
var Tz
;(function (i) {
  ;(i[(i.IsSame = 0)] = "IsSame"),
    (i[(i.Disconnected = 1)] = "Disconnected"),
    (i[(i.IsChild = 2)] = "IsChild"),
    (i[(i.IsParent = 3)] = "IsParent")
})(Tz || (Tz = {}))
var Ot = class vr {
    static fromExtHostTestItem(t, e, r = t.parent) {
      if (t._isRoot) return new vr([e])
      const s = [t.id]
      for (let a = r; a && a.id !== e; a = a.parent) s.push(a.id)
      return s.push(e), new vr(s.reverse())
    }
    static isRoot(t) {
      return !t.includes("\0")
    }
    static root(t) {
      const e = t.indexOf("\0")
      return e === -1 ? t : t.slice(0, e)
    }
    static fromString(t) {
      return new vr(t.split("\0"))
    }
    static join(t, e) {
      return new vr([...t.path, e])
    }
    static joinToString(t, e) {
      return t.toString() + "\0" + e
    }
    static parentId(t) {
      const e = t.lastIndexOf("\0")
      return e === -1 ? void 0 : t.slice(0, e)
    }
    static localId(t) {
      const e = t.lastIndexOf("\0")
      return e === -1 ? t : t.slice(e + 1)
    }
    static isChild(t, e) {
      return e[t.length] === "\0" && e.startsWith(t)
    }
    static compare(t, e) {
      return t === e ? 0 : vr.isChild(t, e) ? 2 : vr.isChild(e, t) ? 3 : 1
    }
    static getLengthOfCommonPrefix(t, e) {
      if (t === 0) return 0
      let r = 0
      for (; r < t - 1; ) {
        for (let s = 1; s < t; s++) {
          const a = e(s - 1),
            o = e(s)
          if (a.path[r] !== o.path[r]) return r
        }
        r++
      }
      return r
    }
    constructor(t, e = t.length) {
      if (((this.path = t), (this.d = e), t.length === 0 || e < 1))
        throw new Error("cannot create test with empty path")
    }
    get rootId() {
      return new vr(this.path, 1)
    }
    get parentId() {
      return this.d > 1 ? new vr(this.path, this.d - 1) : void 0
    }
    get localId() {
      return this.path[this.d - 1]
    }
    get controllerId() {
      return this.path[0]
    }
    get isRoot() {
      return this.d === 1
    }
    *idsFromRoot() {
      for (let t = 1; t <= this.d; t++) yield new vr(this.path, t)
    }
    *idsToRoot() {
      for (let t = this.d; t > 0; t--) yield new vr(this.path, t)
    }
    compare(t) {
      if (typeof t == "string") return vr.compare(this.toString(), t)
      for (let e = 0; e < t.d && e < this.d; e++)
        if (t.path[e] !== this.path[e]) return 1
      return t.d > this.d ? 2 : t.d < this.d ? 3 : 0
    }
    toJSON() {
      return this.toString()
    }
    toString() {
      if (!this.c) {
        this.c = this.path[0]
        for (let t = 1; t < this.d; t++)
          (this.c += "\0"), (this.c += this.path[t])
      }
      return this.c
    }
  },
  kz
;(function (i) {
  ;(i[(i.Unset = 0)] = "Unset"),
    (i[(i.Queued = 1)] = "Queued"),
    (i[(i.Running = 2)] = "Running"),
    (i[(i.Passed = 3)] = "Passed"),
    (i[(i.Failed = 4)] = "Failed"),
    (i[(i.Skipped = 5)] = "Skipped"),
    (i[(i.Errored = 6)] = "Errored")
})(kz || (kz = {}))
var Sz
;(function (i) {
  ;(i[(i.Run = 1)] = "Run"),
    (i[(i.Debug = 2)] = "Debug"),
    (i[(i.Coverage = 3)] = "Coverage")
})(Sz || (Sz = {}))
var bz
;(function (i) {
  ;(i[(i.Refresh = 2)] = "Refresh"),
    (i[(i.CodeRelatedToTest = 4)] = "CodeRelatedToTest"),
    (i[(i.TestRelatedToCode = 8)] = "TestRelatedToCode")
})(bz || (bz = {}))
var Ez
;(function (i) {
  ;(i[(i.Run = 2)] = "Run"),
    (i[(i.Debug = 4)] = "Debug"),
    (i[(i.Coverage = 8)] = "Coverage"),
    (i[(i.HasNonDefaultProfile = 16)] = "HasNonDefaultProfile"),
    (i[(i.HasConfigurable = 32)] = "HasConfigurable"),
    (i[(i.SupportsContinuousRun = 64)] = "SupportsContinuousRun")
})(Ez || (Ez = {}))
var JBt = { 2: f(11434, null), 4: f(11435, null), 8: f(11436, null) },
  nmt = (i) => "runId" in i,
  Lo
;(function (i) {
  ;(i.serialize = (t) => ({ range: t.range.toJSON(), uri: t.uri.toJSON() })),
    (i.deserialize = (t, e) => ({
      range: re.lift(e.range),
      uri: t.asCanonicalUri(S.revive(e.uri)),
    }))
})(Lo || (Lo = {}))
var Iz
;(function (i) {
  ;(i[(i.Error = 0)] = "Error"), (i[(i.Output = 1)] = "Output")
})(Iz || (Iz = {}))
var W_
;(function (i) {
  ;(i.serialize = (t) => ({
    label: t.label,
    uri: t.uri?.toJSON(),
    position: t.position?.toJSON(),
  })),
    (i.deserialize = (t, e) => ({
      label: e.label,
      uri: e.uri ? t.asCanonicalUri(S.revive(e.uri)) : void 0,
      position: e.position ? tr.lift(e.position) : void 0,
    }))
})(W_ || (W_ = {}))
var j_
;(function (i) {
  ;(i.serialize = (t) => ({
    message: t.message,
    type: 0,
    expected: t.expected,
    actual: t.actual,
    contextValue: t.contextValue,
    location: t.location && Lo.serialize(t.location),
    stackTrace: t.stackTrace?.map(W_.serialize),
  })),
    (i.deserialize = (t, e) => ({
      message: e.message,
      type: 0,
      expected: e.expected,
      actual: e.actual,
      contextValue: e.contextValue,
      location: e.location && Lo.deserialize(t, e.location),
      stackTrace: e.stackTrace && e.stackTrace.map((r) => W_.deserialize(t, r)),
    }))
})(j_ || (j_ = {}))
var V_
;(function (i) {
  ;(i.serialize = (t) => ({
    message: t.message,
    type: 1,
    offset: t.offset,
    length: t.length,
    location: t.location && Lo.serialize(t.location),
  })),
    (i.deserialize = (t, e) => ({
      message: e.message,
      type: 1,
      offset: e.offset,
      length: e.length,
      location: e.location && Lo.deserialize(t, e.location),
    }))
})(V_ || (V_ = {}))
var G_
;(function (i) {
  ;(i.serialize = (t) => (t.type === 0 ? j_.serialize(t) : V_.serialize(t))),
    (i.deserialize = (t, e) =>
      e.type === 0 ? j_.deserialize(t, e) : V_.deserialize(t, e)),
    (i.isDiffable = (t) =>
      t.type === 0 && t.actual !== void 0 && t.expected !== void 0)
})(G_ || (G_ = {}))
var cl
;(function (i) {
  ;(i.serializeWithoutMessages = (t) => ({
    state: t.state,
    duration: t.duration,
    messages: [],
  })),
    (i.serialize = (t) => ({
      state: t.state,
      duration: t.duration,
      messages: t.messages.map(G_.serialize),
    })),
    (i.deserialize = (t, e) => ({
      state: e.state,
      duration: e.duration,
      messages: e.messages.map((r) => G_.deserialize(t, r)),
    }))
})(cl || (cl = {}))
var Pz = "\0",
  z_ = (i, t) => i + Pz + t,
  Nz = (i) => {
    const t = i.indexOf(Pz)
    return { ctrlId: i.slice(0, t), tagId: i.slice(t + 1) }
  },
  Y_
;(function (i) {
  ;(i.serialize = (t) => ({
    extId: t.extId,
    label: t.label,
    tags: t.tags,
    busy: t.busy,
    children: void 0,
    uri: t.uri?.toJSON(),
    range: t.range?.toJSON() || null,
    description: t.description,
    error: t.error,
    sortText: t.sortText,
  })),
    (i.deserialize = (t, e) => ({
      extId: e.extId,
      label: e.label,
      tags: e.tags,
      busy: e.busy,
      children: void 0,
      uri: e.uri ? t.asCanonicalUri(S.revive(e.uri)) : void 0,
      range: e.range ? re.lift(e.range) : null,
      description: e.description,
      error: e.error,
      sortText: e.sortText,
    }))
})(Y_ || (Y_ = {}))
var $z
;(function (i) {
  ;(i[(i.NotExpandable = 0)] = "NotExpandable"),
    (i[(i.Expandable = 1)] = "Expandable"),
    (i[(i.BusyExpanding = 2)] = "BusyExpanding"),
    (i[(i.Expanded = 3)] = "Expanded")
})($z || ($z = {}))
var ms
;(function (i) {
  ;(i.serialize = (t) => ({ expand: t.expand, item: Y_.serialize(t.item) })),
    (i.deserialize = (t, e) => ({
      controllerId: Ot.root(e.item.extId),
      expand: e.expand,
      item: Y_.deserialize(t, e.item),
    }))
})(ms || (ms = {}))
var ul
;(function (i) {
  ;(i.serialize = (t) => {
    let e
    return (
      t.item &&
        ((e = {}),
        t.item.label !== void 0 && (e.label = t.item.label),
        t.item.tags !== void 0 && (e.tags = t.item.tags),
        t.item.busy !== void 0 && (e.busy = t.item.busy),
        t.item.uri !== void 0 && (e.uri = t.item.uri?.toJSON()),
        t.item.range !== void 0 && (e.range = t.item.range?.toJSON()),
        t.item.description !== void 0 && (e.description = t.item.description),
        t.item.error !== void 0 && (e.error = t.item.error),
        t.item.sortText !== void 0 && (e.sortText = t.item.sortText)),
      { extId: t.extId, expand: t.expand, item: e }
    )
  }),
    (i.deserialize = (t) => {
      let e
      return (
        t.item &&
          ((e = {}),
          t.item.label !== void 0 && (e.label = t.item.label),
          t.item.tags !== void 0 && (e.tags = t.item.tags),
          t.item.busy !== void 0 && (e.busy = t.item.busy),
          t.item.range !== void 0 &&
            (e.range = t.item.range ? re.lift(t.item.range) : null),
          t.item.description !== void 0 && (e.description = t.item.description),
          t.item.error !== void 0 && (e.error = t.item.error),
          t.item.sortText !== void 0 && (e.sortText = t.item.sortText)),
        { extId: t.extId, expand: t.expand, item: e }
      )
    })
})(ul || (ul = {}))
var _3 = (i, t) => {
    t.expand !== void 0 && (i.expand = t.expand),
      t.item !== void 0 &&
        (i.item = i.item ? Object.assign(i.item, t.item) : t.item)
  },
  xz
;(function (i) {
  ;(i.serializeWithoutMessages = (t) => ({
    ...ms.serialize(t),
    ownComputedState: t.ownComputedState,
    computedState: t.computedState,
    tasks: t.tasks.map(cl.serializeWithoutMessages),
  })),
    (i.serialize = (t) => ({
      ...ms.serialize(t),
      ownComputedState: t.ownComputedState,
      computedState: t.computedState,
      tasks: t.tasks.map(cl.serialize),
    })),
    (i.deserialize = (t, e) => ({
      ...ms.deserialize(t, e),
      ownComputedState: e.ownComputedState,
      computedState: e.computedState,
      tasks: e.tasks.map((r) => cl.deserialize(t, r)),
      retired: !0,
    }))
})(xz || (xz = {}))
var A3
;(function (i) {
  ;(i.empty = () => ({ covered: 0, total: 0 })),
    (i.sum = (t, e) => {
      ;(t.covered += e.covered), (t.total += e.total)
    })
})(A3 || (A3 = {}))
var Jz
;(function (i) {
  ;(i.serialize = (t) => ({
    id: t.id,
    statement: t.statement,
    branch: t.branch,
    declaration: t.declaration,
    testIds: t.testIds,
    uri: t.uri.toJSON(),
  })),
    (i.deserialize = (t, e) => ({
      id: e.id,
      statement: e.statement,
      branch: e.branch,
      declaration: e.declaration,
      testIds: e.testIds,
      uri: t.asCanonicalUri(S.revive(e.uri)),
    })),
    (i.empty = (t, e) => ({ id: t, uri: e, statement: A3.empty() }))
})(Jz || (Jz = {}))
function B3(i) {
  return { ...i, location: i.location?.toJSON() }
}
function O3(i) {
  return (
    (i.location = i.location
      ? tr.isIPosition(i.location)
        ? tr.lift(i.location)
        : re.lift(i.location)
      : void 0),
    i
  )
}
var Cz
;(function (i) {
  ;(i[(i.Declaration = 0)] = "Declaration"),
    (i[(i.Statement = 1)] = "Statement"),
    (i[(i.Branch = 2)] = "Branch")
})(Cz || (Cz = {}))
var Lz
;(function (i) {
  ;(i.serialize = (t) => (t.type === 0 ? X_.serialize(t) : K_.serialize(t))),
    (i.deserialize = (t) =>
      t.type === 0 ? X_.deserialize(t) : K_.deserialize(t))
})(Lz || (Lz = {}))
var Q_
;(function (i) {
  ;(i.serialize = B3), (i.deserialize = O3)
})(Q_ || (Q_ = {}))
var X_
;(function (i) {
  ;(i.serialize = B3), (i.deserialize = O3)
})(X_ || (X_ = {}))
var K_
;(function (i) {
  ;(i.serialize = (t) => ({
    ...B3(t),
    branches: t.branches?.map(Q_.serialize),
  })),
    (i.deserialize = (t) => ({
      ...O3(t),
      branches: t.branches?.map(Q_.deserialize),
    }))
})(K_ || (K_ = {}))
var Rz
;(function (i) {
  ;(i[(i.Add = 0)] = "Add"),
    (i[(i.Update = 1)] = "Update"),
    (i[(i.DocumentSynced = 2)] = "DocumentSynced"),
    (i[(i.Remove = 3)] = "Remove"),
    (i[(i.IncrementPendingExtHosts = 4)] = "IncrementPendingExtHosts"),
    (i[(i.Retire = 5)] = "Retire"),
    (i[(i.AddTag = 6)] = "AddTag"),
    (i[(i.RemoveTag = 7)] = "RemoveTag")
})(Rz || (Rz = {}))
var Z_
;(function (i) {
  ;(i.deserialize = (t, e) =>
    e.op === 0
      ? { op: e.op, item: ms.deserialize(t, e.item) }
      : e.op === 1
        ? { op: e.op, item: ul.deserialize(e.item) }
        : e.op === 2
          ? { op: e.op, uri: t.asCanonicalUri(S.revive(e.uri)), docv: e.docv }
          : e),
    (i.serialize = (t) =>
      t.op === 0
        ? { op: t.op, item: ms.serialize(t.item) }
        : t.op === 1
          ? { op: t.op, item: ul.serialize(t.item) }
          : t)
})(Z_ || (Z_ = {}))
var smt = class {
    constructor(i) {
      ;(this.l = i),
        (this.f = new Map()),
        (this.g = new Map()),
        (this.h = new Set()),
        (this.j = 0),
        (this.k = 0),
        (this.tags = this.f)
    }
    apply(i) {
      const t = this.x()
      for (const e of i)
        switch (e.op) {
          case 0:
            this.p(ms.deserialize(this.l, e.item), t)
            break
          case 1:
            this.q(ul.deserialize(e.item), t)
            break
          case 3:
            this.v(e.itemId, t)
            break
          case 5:
            this.w(e.itemId)
            break
          case 4:
            this.updatePendingRoots(e.amount)
            break
          case 6:
            this.f.set(e.tag.id, e.tag)
            break
          case 7:
            this.f.delete(e.id)
            break
        }
      t.complete?.()
    }
    p(i, t) {
      const e = Ot.parentId(i.item.extId)?.toString()
      let r
      if (!e) (r = this.y(i)), this.h.add(r), this.g.set(i.item.extId, r)
      else if (this.g.has(e)) {
        const s = this.g.get(e)
        s.children.add(i.item.extId),
          (r = this.y(i, s)),
          this.g.set(i.item.extId, r)
      } else {
        console.error(`Test with unknown parent ID: ${JSON.stringify(i)}`)
        return
      }
      return t.add?.(r), i.expand === 2 && this.j++, r
    }
    q(i, t) {
      const e = this.g.get(i.extId)
      if (e)
        return (
          i.expand !== void 0 &&
            (e.expand === 2 && this.j--, i.expand === 2 && this.j++),
          _3(e, i),
          t.update?.(e),
          e
        )
    }
    v(i, t) {
      const e = this.g.get(i)
      if (!e) return
      const r = Ot.parentId(e.item.extId)?.toString()
      r ? this.g.get(r).children.delete(e.item.extId) : this.h.delete(e)
      const s = [[i]]
      for (; s.length; )
        for (const a of s.pop()) {
          const o = this.g.get(a)
          o &&
            (s.push(o.children),
            this.g.delete(a),
            t.remove?.(o, o !== e),
            o.expand === 2 && this.j--)
        }
    }
    w(i) {}
    updatePendingRoots(i) {
      this.k += i
    }
    x() {
      return {}
    }
  },
  amt = Y("editorGroupsService"),
  Dz
;(function (i) {
  ;(i[(i.UP = 0)] = "UP"),
    (i[(i.DOWN = 1)] = "DOWN"),
    (i[(i.LEFT = 2)] = "LEFT"),
    (i[(i.RIGHT = 3)] = "RIGHT")
})(Dz || (Dz = {}))
var Fz
;(function (i) {
  ;(i[(i.HORIZONTAL = 0)] = "HORIZONTAL"), (i[(i.VERTICAL = 1)] = "VERTICAL")
})(Fz || (Fz = {}))
var _z
;(function (i) {
  ;(i[(i.FIRST = 0)] = "FIRST"),
    (i[(i.LAST = 1)] = "LAST"),
    (i[(i.NEXT = 2)] = "NEXT"),
    (i[(i.PREVIOUS = 3)] = "PREVIOUS")
})(_z || (_z = {}))
var Az
;(function (i) {
  ;(i[(i.MAXIMIZE = 0)] = "MAXIMIZE"),
    (i[(i.EXPAND = 1)] = "EXPAND"),
    (i[(i.EVEN = 2)] = "EVEN")
})(Az || (Az = {}))
var Bz
;(function (i) {
  ;(i[(i.COPY_EDITORS = 0)] = "COPY_EDITORS"),
    (i[(i.MOVE_EDITORS = 1)] = "MOVE_EDITORS")
})(Bz || (Bz = {}))
var Oz
;(function (i) {
  ;(i[(i.CREATION_TIME = 0)] = "CREATION_TIME"),
    (i[(i.MOST_RECENTLY_ACTIVE = 1)] = "MOST_RECENTLY_ACTIVE"),
    (i[(i.GRID_APPEARANCE = 2)] = "GRID_APPEARANCE")
})(Oz || (Oz = {}))
var qz
;(function (i) {
  ;(i[(i.NEW_EDITOR = 1)] = "NEW_EDITOR"),
    (i[(i.MOVE_EDITOR = 2)] = "MOVE_EDITOR"),
    (i[(i.COPY_EDITOR = 3)] = "COPY_EDITOR")
})(qz || (qz = {}))
var CBt = Y("editorService"),
  omt = -1,
  cmt = -2,
  Uz
;(function (i) {
  ;(i[(i.Upsert = 0)] = "Upsert"),
    (i[(i.SetTags = 1)] = "SetTags"),
    (i[(i.UpdateCanResolveChildren = 2)] = "UpdateCanResolveChildren"),
    (i[(i.RemoveChild = 3)] = "RemoveChild"),
    (i[(i.SetProp = 4)] = "SetProp"),
    (i[(i.Bulk = 5)] = "Bulk"),
    (i[(i.DocumentSynced = 6)] = "DocumentSynced")
})(Uz || (Uz = {}))
var ll = (i, t) => i === t,
  umt = {
    range: (i, t) => (i === t ? !0 : !i || !t ? !1 : i.equalsRange(t)),
    busy: ll,
    label: ll,
    description: ll,
    error: ll,
    sortText: ll,
    tags: (i, t) => !(i.length !== t.length || i.some((e) => !t.includes(e))),
  },
  lmt = Object.entries(umt),
  dmt = (i, t) => {
    let e
    for (const [r, s] of lmt)
      s(i[r], t[r]) || (e ? (e[r] = t[r]) : (e = { [r]: t[r] }))
    return e
  },
  mmt = class extends dt {
    get root() {
      return this.q.root
    }
    constructor(i) {
      super(),
        (this.q = i),
        (this.f = this.D(new po(() => this.flushDiff(), 200))),
        (this.g = this.D(new C())),
        (this.tree = new Map()),
        (this.j = new Map()),
        (this.m = []),
        (this.onDidGenerateDiff = this.g.event),
        (this.root.canResolveChildren = !0),
        this.y(this.root, void 0)
    }
    set resolveHandler(i) {
      this.h = i
      for (const t of this.tree.values()) this.J(t)
    }
    get resolveHandler() {
      return this.h
    }
    collectDiff() {
      const i = this.m
      return (this.m = []), i
    }
    pushDiff(i) {
      switch (i.op) {
        case 2: {
          for (const t of this.m)
            if (t.op === 2 && t.uri === i.uri) {
              t.docv = i.docv
              return
            }
          break
        }
        case 1: {
          const t = this.m[this.m.length - 1]
          if (t) {
            if (t.op === 1 && t.item.extId === i.item.extId) {
              _3(t.item, i.item)
              return
            }
            if (t.op === 0 && t.item.item.extId === i.item.extId) {
              _3(t.item, i.item)
              return
            }
          }
          break
        }
      }
      this.m.push(i), this.f.isScheduled() || this.f.schedule()
    }
    expand(i, t) {
      const e = this.tree.get(i)
      if (e) {
        if (
          ((e.expandLevels === void 0 || t > e.expandLevels) &&
            (e.expandLevels = t),
          e.expand === 1)
        ) {
          const r = this.M(e)
          return r.isOpen()
            ? this.L(e, t - 1)
            : r.wait().then(() => this.L(e, t - 1))
        } else if (e.expand === 3)
          return e.resolveBarrier?.isOpen() === !1
            ? e.resolveBarrier.wait().then(() => this.L(e, t - 1))
            : this.L(e, t - 1)
      }
    }
    dispose() {
      for (const i of this.tree.values())
        this.q.getApiFor(i.actual).listener = void 0
      this.tree.clear(), (this.m = []), super.dispose()
    }
    s(i, t) {
      switch (t.op) {
        case 3:
          this.O(Ot.joinToString(i.fullId, t.id))
          break
        case 0:
          this.y(t.item, i)
          break
        case 5:
          for (const e of t.ops) this.s(i, e)
          break
        case 1:
          this.z(t.new, t.old, i.fullId.toString())
          break
        case 2:
          this.J(i)
          break
        case 4:
          this.pushDiff({
            op: 1,
            item: { extId: i.fullId.toString(), item: t.update },
          })
          break
        case 6:
          this.w(i.actual.uri)
          break
        default:
          wlt(t)
      }
    }
    w(i) {
      i && this.pushDiff({ op: 2, uri: i, docv: this.q.getDocumentVersion(i) })
    }
    y(i, t) {
      const e = Ot.fromExtHostTestItem(i, this.root.id, t?.actual),
        r = this.q.getApiFor(i)
      r.parent &&
        r.parent !== t?.actual &&
        this.q.getChildren(r.parent).delete(i.id)
      let s = this.tree.get(e.toString())
      if (!s) {
        ;(s = {
          fullId: e,
          actual: i,
          expandLevels: t?.expandLevels ? t.expandLevels - 1 : void 0,
          expand: 0,
        }),
          i.tags.forEach(this.C, this),
          this.tree.set(s.fullId.toString(), s),
          this.G(i, t),
          this.pushDiff({
            op: 0,
            item: {
              controllerId: this.q.controllerId,
              expand: s.expand,
              item: this.q.toITestItem(i),
            },
          }),
          this.I(i, s, t)
        return
      }
      if (s.actual === i) {
        this.H(i, s, t)
        return
      }
      if (s.actual.uri?.toString() !== i.uri?.toString())
        return this.O(e.toString()), this.y(i, t)
      const a = this.q.getChildren(s.actual),
        o = s.actual,
        c = dmt(this.q.toITestItem(o), this.q.toITestItem(i))
      ;(this.q.getApiFor(o).listener = void 0),
        (s.actual = i),
        (s.resolveBarrier = void 0),
        (s.expand = 0),
        c &&
          (c.hasOwnProperty("tags") &&
            (this.z(i.tags, o.tags, e.toString()), delete c.tags),
          this.s(s, { op: 4, update: c })),
        this.I(i, s, t)
      for (const [l, m] of a)
        this.q.getChildren(i).get(m.id) || this.O(Ot.joinToString(e, m.id))
      const u = s.expandLevels
      u !== void 0 &&
        queueMicrotask(() => {
          s.expand === 1 &&
            ((s.expandLevels = void 0), this.expand(e.toString(), u))
        }),
        this.w(s.actual.uri)
    }
    z(i, t, e) {
      const r = new Set(t.map((s) => s.id))
      for (const s of i) r.delete(s.id) || this.C(s)
      this.pushDiff({
        op: 1,
        item: {
          extId: e,
          item: { tags: i.map((s) => z_(this.q.controllerId, s.id)) },
        },
      }),
        r.forEach(this.F, this)
    }
    C(i) {
      const t = this.j.get(i.id)
      t
        ? t.refCount++
        : (this.j.set(i.id, { refCount: 1 }),
          this.pushDiff({ op: 6, tag: { id: z_(this.q.controllerId, i.id) } }))
    }
    F(i) {
      const t = this.j.get(i)
      t &&
        !--t.refCount &&
        (this.j.delete(i),
        this.pushDiff({ op: 7, id: z_(this.q.controllerId, i) }))
    }
    G(i, t) {
      this.q.getApiFor(i).parent =
        t && t.actual !== this.root ? t.actual : void 0
    }
    H(i, t, e) {
      this.G(i, e)
      const r = this.q.getApiFor(i)
      ;(r.parent = e?.actual), (r.listener = (s) => this.s(t, s)), this.J(t)
    }
    I(i, t, e) {
      this.H(i, t, e)
      for (const [r, s] of this.q.getChildren(i)) this.y(s, t)
    }
    J(i) {
      let t
      this.h
        ? i.resolveBarrier
          ? (t = i.resolveBarrier.isOpen() ? 3 : 2)
          : (t = i.actual.canResolveChildren ? 1 : 0)
        : (t = 0),
        t !== i.expand &&
          ((i.expand = t),
          this.pushDiff({
            op: 1,
            item: { extId: i.fullId.toString(), expand: t },
          }),
          t === 1 && i.expandLevels !== void 0 && this.M(i))
    }
    L(i, t) {
      if (t < 0) return
      const e = []
      for (const [r, s] of this.q.getChildren(i.actual)) {
        const a = this.expand(Ot.joinToString(i.fullId, s.id), t)
        wn(a) && e.push(a)
      }
      if (e.length) return Promise.all(e).then(() => {})
    }
    M(i) {
      if (i.resolveBarrier) return i.resolveBarrier
      if (!this.h) {
        const s = new Xr()
        return s.open(), s
      }
      ;(i.expand = 2), this.N(i)
      const t = (i.resolveBarrier = new Xr()),
        e = (s) => {
          console.error(
            `Unhandled error in resolveHandler of test controller "${this.q.controllerId}"`,
            s,
          )
        }
      let r
      try {
        r = this.h(i.actual === this.root ? void 0 : i.actual)
      } catch (s) {
        e(s)
      }
      return (
        wn(r)
          ? r.catch(e).then(() => {
              t.open(), this.J(i)
            })
          : (t.open(), this.J(i)),
        i.resolveBarrier
      )
    }
    N(i) {
      this.pushDiff({
        op: 1,
        item: { extId: i.fullId.toString(), expand: i.expand },
      })
    }
    O(i) {
      const t = this.tree.get(i)
      if (!t) throw new Error("attempting to remove non-existent child")
      this.pushDiff({ op: 3, itemId: i })
      const e = [t]
      for (; e.length; ) {
        const r = e.pop()
        if (r) {
          this.q.getApiFor(r.actual).listener = void 0
          for (const s of r.actual.tags) this.F(s.id)
          this.tree.delete(r.fullId.toString())
          for (const [s, a] of this.q.getChildren(r.actual))
            e.push(this.tree.get(Ot.joinToString(r.fullId, a.id)))
        }
      }
    }
    flushDiff() {
      const i = this.collectDiff()
      i.length && this.g.fire(i)
    }
  },
  hmt = class extends Error {
    constructor(i) {
      super(`Attempted to insert a duplicate test item ID ${i}`)
    }
  },
  t6 = class extends Error {
    constructor(i) {
      super(
        `TestItem with ID "${i}" is invalid. Make sure to create it from the createTestItem method.`,
      )
    }
  },
  fmt = class extends Error {
    constructor(i, t, e) {
      super(
        `TestItem with ID "${i}" is from controller "${t}" and cannot be added as a child of an item from controller "${e}".`,
      )
    }
  },
  pmt = (i, t, e) => {
    let r = new Map()
    return {
      get size() {
        return r.size
      },
      forEach(s, a) {
        for (const o of r.values()) s.call(a, o, this)
      },
      [Symbol.iterator]() {
        return r.entries()
      },
      replace(s) {
        const a = new Map(),
          o = new Set(r.keys()),
          c = { op: 5, ops: [] }
        for (const u of s) {
          if (!(u instanceof e)) throw new t6(u.id)
          const l = t(u).controllerId
          if (l !== i.controllerId) throw new fmt(u.id, l, i.controllerId)
          if (a.has(u.id)) throw new hmt(u.id)
          a.set(u.id, u), o.delete(u.id), c.ops.push({ op: 0, item: u })
        }
        for (const u of o.keys()) c.ops.push({ op: 3, id: u })
        i.listener?.(c), (r = a)
      },
      add(s) {
        if (!(s instanceof e)) throw new t6(s.id)
        r.set(s.id, s), i.listener?.({ op: 0, item: s })
      },
      delete(s) {
        r.delete(s) && i.listener?.({ op: 3, id: s })
      },
      get(s) {
        return r.get(s)
      },
      toJSON() {
        return Array.from(r.values())
      },
    }
  },
  Mz = new WeakMap(),
  gmt = (i, t) => {
    const e = { controllerId: t }
    return Mz.set(i, e), e
  },
  e6 = (i) => {
    const t = Mz.get(i)
    if (!t) throw new t6(i?.id || "<unknown>")
    return t
  },
  LBt = Y("remoteAuthorityResolverService"),
  Hz
;(function (i) {
  ;(i[(i.WebSocket = 0)] = "WebSocket"), (i[(i.Managed = 1)] = "Managed")
})(Hz || (Hz = {}))
var vmt = class {
    constructor(i) {
      ;(this.id = i), (this.type = 1)
    }
    toString() {
      return `Managed(${this.id})`
    }
  },
  wmt = class {
    constructor(i, t) {
      ;(this.host = i), (this.port = t), (this.type = 0)
    }
    toString() {
      return `WebSocket(${this.host}:${this.port})`
    }
  },
  En
;(function (i) {
  ;(i.Unknown = "Unknown"),
    (i.NotAvailable = "NotAvailable"),
    (i.TemporarilyNotAvailable = "TemporarilyNotAvailable"),
    (i.NoResolverFound = "NoResolverFound"),
    (i.InvalidAuthority = "InvalidAuthority")
})(En || (En = {}))
function Wz(i) {
  const t = i.indexOf("+")
  return t === -1 ? i : i.substring(0, t)
}
var q3, fa, In, U3, pa, hs, ga, M3, H3, i6, dl, W3, rn, nn, j3, Ci, V3
function st(i) {
  return Object.assign(i, {
    apply: function (...e) {
      if (e.length === 0) return Reflect.construct(i, [])
      {
        const r = e.length === 1 ? [] : e[1]
        return Reflect.construct(i, r, e[0].constructor)
      }
    },
    call: function (...e) {
      if (e.length === 0) return Reflect.construct(i, [])
      {
        const [r, ...s] = e
        return Reflect.construct(i, s, r.constructor)
      }
    },
  })
}
var G3
;(function (i) {
  ;(i[(i.Top = 0)] = "Top"), (i[(i.Bottom = 1)] = "Bottom")
})(G3 || (G3 = {}))
var jz
;(function (i) {
  ;(i[(i.TerminalCommand = 0)] = "TerminalCommand"),
    (i[(i.Opener = 1)] = "Opener"),
    (i[(i.Command = 3)] = "Command")
})(jz || (jz = {}))
var At = (q3 = class {
  static from(...t) {
    let e = t
    return new q3(function () {
      if (e) {
        for (const r of e) r && typeof r.dispose == "function" && r.dispose()
        e = void 0
      }
    })
  }
  #t
  constructor(t) {
    this.#t = t
  }
  dispose() {
    typeof this.#t == "function" && (this.#t(), (this.#t = void 0))
  }
})
At = q3 = __decorate([st], At)
var Lt = (fa = class {
  static Min(...t) {
    if (t.length === 0) throw new TypeError()
    let e = t[0]
    for (let r = 1; r < t.length; r++) {
      const s = t[r]
      s.isBefore(e) && (e = s)
    }
    return e
  }
  static Max(...t) {
    if (t.length === 0) throw new TypeError()
    let e = t[0]
    for (let r = 1; r < t.length; r++) {
      const s = t[r]
      s.isAfter(e) && (e = s)
    }
    return e
  }
  static isPosition(t) {
    if (!t) return !1
    if (t instanceof fa) return !0
    const { line: e, character: r } = t
    return typeof e == "number" && typeof r == "number"
  }
  static of(t) {
    if (t instanceof fa) return t
    if (this.isPosition(t)) return new fa(t.line, t.character)
    throw new Error("Invalid argument, is NOT a position-like object")
  }
  get line() {
    return this.c
  }
  get character() {
    return this.e
  }
  constructor(t, e) {
    if (t < 0) throw xt("line must be non-negative")
    if (e < 0) throw xt("character must be non-negative")
    ;(this.c = t), (this.e = e)
  }
  isBefore(t) {
    return this.c < t.c ? !0 : t.c < this.c ? !1 : this.e < t.e
  }
  isBeforeOrEqual(t) {
    return this.c < t.c ? !0 : t.c < this.c ? !1 : this.e <= t.e
  }
  isAfter(t) {
    return !this.isBeforeOrEqual(t)
  }
  isAfterOrEqual(t) {
    return !this.isBefore(t)
  }
  isEqual(t) {
    return this.c === t.c && this.e === t.e
  }
  compareTo(t) {
    return this.c < t.c
      ? -1
      : this.c > t.line
        ? 1
        : this.e < t.e
          ? -1
          : this.e > t.e
            ? 1
            : 0
  }
  translate(t, e = 0) {
    if (t === null || e === null) throw xt()
    let r
    return (
      typeof t > "u"
        ? (r = 0)
        : typeof t == "number"
          ? (r = t)
          : ((r = typeof t.lineDelta == "number" ? t.lineDelta : 0),
            (e = typeof t.characterDelta == "number" ? t.characterDelta : 0)),
      r === 0 && e === 0 ? this : new fa(this.line + r, this.character + e)
    )
  }
  with(t, e = this.character) {
    if (t === null || e === null) throw xt()
    let r
    return (
      typeof t > "u"
        ? (r = this.line)
        : typeof t == "number"
          ? (r = t)
          : ((r = typeof t.line == "number" ? t.line : this.line),
            (e =
              typeof t.character == "number" ? t.character : this.character)),
      r === this.line && e === this.character ? this : new fa(r, e)
    )
  }
  toJSON() {
    return { line: this.line, character: this.character }
  }
  [Symbol.for("debug.description")]() {
    return `(${this.line}:${this.character})`
  }
})
Lt = fa = __decorate([st], Lt)
var Nt = (In = class {
  static isRange(t) {
    return t instanceof In
      ? !0
      : t
        ? Lt.isPosition(t.start) && Lt.isPosition(t.end)
        : !1
  }
  static of(t) {
    if (t instanceof In) return t
    if (this.isRange(t)) return new In(t.start, t.end)
    throw new Error("Invalid argument, is NOT a range-like object")
  }
  get start() {
    return this.c
  }
  get end() {
    return this.e
  }
  constructor(t, e, r, s) {
    let a, o
    if (
      (typeof t == "number" &&
      typeof e == "number" &&
      typeof r == "number" &&
      typeof s == "number"
        ? ((a = new Lt(t, e)), (o = new Lt(r, s)))
        : Lt.isPosition(t) &&
          Lt.isPosition(e) &&
          ((a = Lt.of(t)), (o = Lt.of(e))),
      !a || !o)
    )
      throw new Error("Invalid arguments")
    a.isBefore(o) ? ((this.c = a), (this.e = o)) : ((this.c = o), (this.e = a))
  }
  contains(t) {
    return In.isRange(t)
      ? this.contains(t.start) && this.contains(t.end)
      : Lt.isPosition(t)
        ? !(Lt.of(t).isBefore(this.c) || this.e.isBefore(t))
        : !1
  }
  isEqual(t) {
    return this.c.isEqual(t.c) && this.e.isEqual(t.e)
  }
  intersection(t) {
    const e = Lt.Max(t.start, this.c),
      r = Lt.Min(t.end, this.e)
    if (!e.isAfter(r)) return new In(e, r)
  }
  union(t) {
    if (this.contains(t)) return this
    if (t.contains(this)) return t
    const e = Lt.Min(t.start, this.c),
      r = Lt.Max(t.end, this.end)
    return new In(e, r)
  }
  get isEmpty() {
    return this.c.isEqual(this.e)
  }
  get isSingleLine() {
    return this.c.line === this.e.line
  }
  with(t, e = this.end) {
    if (t === null || e === null) throw xt()
    let r
    return (
      t
        ? Lt.isPosition(t)
          ? (r = t)
          : ((r = t.start || this.start), (e = t.end || this.end))
        : (r = this.start),
      r.isEqual(this.c) && e.isEqual(this.end) ? this : new In(r, e)
    )
  }
  toJSON() {
    return [this.start, this.end]
  }
  [Symbol.for("debug.description")]() {
    return Vz(this)
  }
})
Nt = In = __decorate([st], Nt)
var Pn = (U3 = class extends Nt {
  static isSelection(t) {
    return t instanceof U3
      ? !0
      : t
        ? Nt.isRange(t) &&
          Lt.isPosition(t.anchor) &&
          Lt.isPosition(t.active) &&
          typeof t.isReversed == "boolean"
        : !1
  }
  get anchor() {
    return this.f
  }
  get active() {
    return this.g
  }
  constructor(t, e, r, s) {
    let a, o
    if (
      (typeof t == "number" &&
      typeof e == "number" &&
      typeof r == "number" &&
      typeof s == "number"
        ? ((a = new Lt(t, e)), (o = new Lt(r, s)))
        : Lt.isPosition(t) &&
          Lt.isPosition(e) &&
          ((a = Lt.of(t)), (o = Lt.of(e))),
      !a || !o)
    )
      throw new Error("Invalid arguments")
    super(a, o), (this.f = a), (this.g = o)
  }
  get isReversed() {
    return this.f === this.e
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end,
      active: this.active,
      anchor: this.anchor,
    }
  }
  [Symbol.for("debug.description")]() {
    return ymt(this)
  }
})
Pn = U3 = __decorate([st], Pn)
function Vz(i) {
  return i.isEmpty
    ? `[${i.start.line}:${i.start.character})`
    : `[${i.start.line}:${i.start.character} -> ${i.end.line}:${i.end.character})`
}
function ymt(i) {
  let t = Vz(i)
  return (
    i.isEmpty || (i.active.isEqual(i.start) ? (t = `|${t}`) : (t = `${t}|`)), t
  )
}
var Gz = (i) => {
    if (typeof i != "string" || i.length === 0 || !/^[0-9A-Za-z_\-]+$/.test(i))
      throw xt("connectionToken")
  },
  Tmt = class {
    static isResolvedAuthority(i) {
      return (
        i &&
        typeof i == "object" &&
        typeof i.host == "string" &&
        typeof i.port == "number" &&
        (i.connectionToken === void 0 || typeof i.connectionToken == "string")
      )
    }
    constructor(i, t, e) {
      if (typeof i != "string" || i.length === 0) throw xt("host")
      if (typeof t != "number" || t === 0 || Math.round(t) !== t)
        throw xt("port")
      typeof e < "u" && Gz(e),
        (this.host = i),
        (this.port = Math.round(t)),
        (this.connectionToken = e)
    }
  },
  r6 = class {
    static isManagedResolvedAuthority(i) {
      return (
        i &&
        typeof i == "object" &&
        typeof i.makeConnection == "function" &&
        (i.connectionToken === void 0 || typeof i.connectionToken == "string")
      )
    }
    constructor(i, t) {
      ;(this.makeConnection = i),
        (this.connectionToken = t),
        typeof t < "u" && Gz(t)
    }
  },
  Ro = class M8 extends Error {
    static NotAvailable(t, e) {
      return new M8(t, En.NotAvailable, e)
    }
    static TemporarilyNotAvailable(t) {
      return new M8(t, En.TemporarilyNotAvailable)
    }
    constructor(t, e = En.Unknown, r) {
      super(t),
        (this._message = t),
        (this._code = e),
        (this._detail = r),
        Object.setPrototypeOf(this, M8.prototype)
    }
  },
  xr
;(function (i) {
  ;(i[(i.LF = 1)] = "LF"), (i[(i.CRLF = 2)] = "CRLF")
})(xr || (xr = {}))
var Do
;(function (i) {
  ;(i[(i.Replace = 1)] = "Replace"),
    (i[(i.Append = 2)] = "Append"),
    (i[(i.Prepend = 3)] = "Prepend")
})(Do || (Do = {}))
var fs = (pa = class {
  static isTextEdit(t) {
    return t instanceof pa
      ? !0
      : t
        ? Nt.isRange(t) && typeof t.newText == "string"
        : !1
  }
  static replace(t, e) {
    return new pa(t, e)
  }
  static insert(t, e) {
    return pa.replace(new Nt(t, t), e)
  }
  static delete(t) {
    return pa.replace(t, "")
  }
  static setEndOfLine(t) {
    const e = new pa(new Nt(new Lt(0, 0), new Lt(0, 0)), "")
    return (e.newEol = t), e
  }
  get range() {
    return this.c
  }
  set range(t) {
    if (t && !Nt.isRange(t)) throw xt("range")
    this.c = t
  }
  get newText() {
    return this.e || ""
  }
  set newText(t) {
    if (t && typeof t != "string") throw xt("newText")
    this.e = t
  }
  get newEol() {
    return this.f
  }
  set newEol(t) {
    if (t && typeof t != "number") throw xt("newEol")
    this.f = t
  }
  constructor(t, e) {
    ;(this.c = t), (this.e = e)
  }
  toJSON() {
    return { range: this.range, newText: this.newText, newEol: this.f }
  }
})
fs = pa = __decorate([st], fs)
var n6 = (hs = class {
  static isNotebookCellEdit(t) {
    return t instanceof hs
      ? !0
      : t
        ? $n.isNotebookRange(t) && Array.isArray(t.newCells)
        : !1
  }
  static replaceCells(t, e) {
    return new hs(t, e)
  }
  static insertCells(t, e) {
    return new hs(new $n(t, t), e)
  }
  static deleteCells(t) {
    return new hs(t, [])
  }
  static updateCellMetadata(t, e) {
    const r = new hs(new $n(t, t), [])
    return (r.newCellMetadata = e), r
  }
  static updateNotebookMetadata(t) {
    const e = new hs(new $n(0, 0), [])
    return (e.newNotebookMetadata = t), e
  }
  constructor(t, e) {
    ;(this.range = t), (this.newCells = e)
  }
})
n6 = hs = __decorate([st], n6)
var z3 = class H8 {
    static isSnippetTextEdit(t) {
      return t instanceof H8
        ? !0
        : t
          ? Nt.isRange(t.range) && wa.isSnippetString(t.snippet)
          : !1
    }
    static replace(t, e) {
      return new H8(t, e)
    }
    static insert(t, e) {
      return H8.replace(new Nt(t, t), e)
    }
    constructor(t, e) {
      ;(this.range = t), (this.snippet = e)
    }
  },
  zz
;(function (i) {
  ;(i[(i.File = 1)] = "File"),
    (i[(i.Text = 2)] = "Text"),
    (i[(i.Cell = 3)] = "Cell"),
    (i[(i.CellReplace = 5)] = "CellReplace"),
    (i[(i.Snippet = 6)] = "Snippet")
})(zz || (zz = {}))
var va = class {
  constructor() {
    this.c = []
  }
  _allEntries() {
    return this.c
  }
  renameFile(t, e, r, s) {
    this.c.push({ _type: 1, from: t, to: e, options: r, metadata: s })
  }
  createFile(t, e, r) {
    this.c.push({ _type: 1, from: void 0, to: t, options: e, metadata: r })
  }
  deleteFile(t, e, r) {
    this.c.push({ _type: 1, from: t, to: void 0, options: e, metadata: r })
  }
  e(t, e, r) {
    this.c.push({
      _type: 3,
      metadata: r,
      uri: t,
      edit: { editType: 5, metadata: e },
    })
  }
  f(t, e, r, s) {
    const a = e.start,
      o = e.end
    ;(a !== o || r.length > 0) &&
      this.c.push({
        _type: 5,
        uri: t,
        index: a,
        count: o - a,
        cells: r,
        metadata: s,
      })
  }
  g(t, e, r, s) {
    this.c.push({
      _type: 3,
      metadata: s,
      uri: t,
      edit: { editType: 3, index: e, metadata: r },
    })
  }
  replace(t, e, r, s) {
    this.c.push({ _type: 2, uri: t, edit: new fs(e, r), metadata: s })
  }
  insert(t, e, r, s) {
    this.replace(t, new Nt(e, e), r, s)
  }
  delete(t, e, r) {
    this.replace(t, e, "", r)
  }
  has(t) {
    return this.c.some(
      (e) => e._type === 2 && e.uri.toString() === t.toString(),
    )
  }
  set(t, e) {
    if (e)
      for (const r of e) {
        if (!r) continue
        let s, a
        Array.isArray(r) ? ((s = r[0]), (a = r[1])) : (s = r),
          n6.isNotebookCellEdit(s)
            ? s.newCellMetadata
              ? this.g(t, s.range.start, s.newCellMetadata, a)
              : s.newNotebookMetadata
                ? this.e(t, s.newNotebookMetadata, a)
                : this.f(t, s.range, s.newCells, a)
            : z3.isSnippetTextEdit(s)
              ? this.c.push({
                  _type: 6,
                  uri: t,
                  range: s.range,
                  edit: s.snippet,
                  metadata: a,
                })
              : this.c.push({ _type: 2, uri: t, edit: s, metadata: a })
      }
    else {
      for (let r = 0; r < this.c.length; r++) {
        const s = this.c[r]
        switch (s._type) {
          case 2:
          case 6:
          case 3:
          case 5:
            s.uri.toString() === t.toString() && (this.c[r] = void 0)
            break
        }
      }
      Zst(this.c)
    }
  }
  get(t) {
    const e = []
    for (const r of this.c)
      r._type === 2 && r.uri.toString() === t.toString() && e.push(r.edit)
    return e
  }
  entries() {
    const t = new ei()
    for (const e of this.c)
      if (e._type === 2) {
        let r = t.get(e.uri)
        r || ((r = [e.uri, []]), t.set(e.uri, r)), r[1].push(e.edit)
      }
    return [...t.values()]
  }
  get size() {
    return this.entries().length
  }
  toJSON() {
    return this.entries()
  }
}
va = __decorate([st], va)
var wa = (ga = class {
  static isSnippetString(t) {
    return t instanceof ga ? !0 : t ? typeof t.value == "string" : !1
  }
  static c(t) {
    return t.replace(/\$|}|\\/g, "\\$&")
  }
  constructor(t) {
    ;(this.e = 1), (this.value = t || "")
  }
  appendText(t) {
    return (this.value += ga.c(t)), this
  }
  appendTabstop(t = this.e++) {
    return (this.value += "$"), (this.value += t), this
  }
  appendPlaceholder(t, e = this.e++) {
    if (typeof t == "function") {
      const r = new ga()
      ;(r.e = this.e), t(r), (this.e = r.e), (t = r.value)
    } else t = ga.c(t)
    return (
      (this.value += "${"),
      (this.value += e),
      (this.value += ":"),
      (this.value += t),
      (this.value += "}"),
      this
    )
  }
  appendChoice(t, e = this.e++) {
    const r = t.map((s) => s.replaceAll(/[|\\,]/g, "\\$&")).join(",")
    return (
      (this.value += "${"),
      (this.value += e),
      (this.value += "|"),
      (this.value += r),
      (this.value += "|}"),
      this
    )
  }
  appendVariable(t, e) {
    if (typeof e == "function") {
      const r = new ga()
      ;(r.e = this.e), e(r), (this.e = r.e), (e = r.value)
    } else typeof e == "string" && (e = e.replace(/\$|}/g, "\\$&"))
    return (
      (this.value += "${"),
      (this.value += t),
      e && ((this.value += ":"), (this.value += e)),
      (this.value += "}"),
      this
    )
  }
})
wa = ga = __decorate([st], wa)
var ya
;(function (i) {
  ;(i[(i.Unnecessary = 1)] = "Unnecessary"),
    (i[(i.Deprecated = 2)] = "Deprecated")
})(ya || (ya = {}))
var di
;(function (i) {
  ;(i[(i.Hint = 3)] = "Hint"),
    (i[(i.Information = 2)] = "Information"),
    (i[(i.Warning = 1)] = "Warning"),
    (i[(i.Error = 0)] = "Error")
})(di || (di = {}))
var er = (M3 = class {
  static isLocation(t) {
    return t instanceof M3 ? !0 : t ? Nt.isRange(t.range) && S.isUri(t.uri) : !1
  }
  constructor(t, e) {
    if (((this.uri = t), e))
      if (Nt.isRange(e)) this.range = Nt.of(e)
      else if (Lt.isPosition(e)) this.range = new Nt(e, e)
      else throw new Error("Illegal argument")
  }
  toJSON() {
    return { uri: this.uri, range: this.range }
  }
})
er = M3 = __decorate([st], er)
var ml = class {
  static is(t) {
    return t
      ? typeof t.message == "string" &&
          t.location &&
          Nt.isRange(t.location.range) &&
          S.isUri(t.location.uri)
      : !1
  }
  constructor(t, e) {
    ;(this.location = t), (this.message = e)
  }
  static isEqual(t, e) {
    return t === e
      ? !0
      : !t || !e
        ? !1
        : t.message === e.message &&
          t.location.range.isEqual(e.location.range) &&
          t.location.uri.toString() === e.location.uri.toString()
  }
}
ml = __decorate([st], ml)
var s6 = class {
  constructor(t, e, r = di.Error) {
    if (!Nt.isRange(t)) throw new TypeError("range must be set")
    if (!e) throw new TypeError("message must be set")
    ;(this.range = t), (this.message = e), (this.severity = r)
  }
  toJSON() {
    return {
      severity: di[this.severity],
      message: this.message,
      range: this.range,
      source: this.source,
      code: this.code,
    }
  }
  static isEqual(t, e) {
    return t === e
      ? !0
      : !t || !e
        ? !1
        : t.message === e.message &&
          t.severity === e.severity &&
          t.code === e.code &&
          t.severity === e.severity &&
          t.source === e.source &&
          t.range.isEqual(e.range) &&
          fn(t.tags, e.tags) &&
          fn(t.relatedInformation, e.relatedInformation, ml.isEqual)
  }
}
s6 = __decorate([st], s6)
var a6 = class {
  constructor(t, e) {
    if (!t) throw new Error("Illegal argument, contents must be defined")
    Array.isArray(t) ? (this.contents = t) : (this.contents = [t]),
      (this.range = e)
  }
}
a6 = __decorate([st], a6)
var o6 = class extends a6 {
  constructor(t, e, r, s) {
    super(t, e),
      (this.canIncreaseVerbosity = r),
      (this.canDecreaseVerbosity = s)
  }
}
o6 = __decorate([st], o6)
var Y3
;(function (i) {
  ;(i[(i.Increase = 0)] = "Increase"), (i[(i.Decrease = 1)] = "Decrease")
})(Y3 || (Y3 = {}))
var hl
;(function (i) {
  ;(i[(i.Text = 0)] = "Text"),
    (i[(i.Read = 1)] = "Read"),
    (i[(i.Write = 2)] = "Write")
})(hl || (hl = {}))
var c6 = class {
  constructor(t, e = hl.Text) {
    ;(this.range = t), (this.kind = e)
  }
  toJSON() {
    return { range: this.range, kind: hl[this.kind] }
  }
}
c6 = __decorate([st], c6)
var u6 = class {
  constructor(t, e) {
    ;(this.uri = t), (this.highlights = e)
  }
  toJSON() {
    return { uri: this.uri, highlights: this.highlights.map((t) => t.toJSON()) }
  }
}
u6 = __decorate([st], u6)
var ae
;(function (i) {
  ;(i[(i.File = 0)] = "File"),
    (i[(i.Module = 1)] = "Module"),
    (i[(i.Namespace = 2)] = "Namespace"),
    (i[(i.Package = 3)] = "Package"),
    (i[(i.Class = 4)] = "Class"),
    (i[(i.Method = 5)] = "Method"),
    (i[(i.Property = 6)] = "Property"),
    (i[(i.Field = 7)] = "Field"),
    (i[(i.Constructor = 8)] = "Constructor"),
    (i[(i.Enum = 9)] = "Enum"),
    (i[(i.Interface = 10)] = "Interface"),
    (i[(i.Function = 11)] = "Function"),
    (i[(i.Variable = 12)] = "Variable"),
    (i[(i.Constant = 13)] = "Constant"),
    (i[(i.String = 14)] = "String"),
    (i[(i.Number = 15)] = "Number"),
    (i[(i.Boolean = 16)] = "Boolean"),
    (i[(i.Array = 17)] = "Array"),
    (i[(i.Object = 18)] = "Object"),
    (i[(i.Key = 19)] = "Key"),
    (i[(i.Null = 20)] = "Null"),
    (i[(i.EnumMember = 21)] = "EnumMember"),
    (i[(i.Struct = 22)] = "Struct"),
    (i[(i.Event = 23)] = "Event"),
    (i[(i.Operator = 24)] = "Operator"),
    (i[(i.TypeParameter = 25)] = "TypeParameter")
})(ae || (ae = {}))
var fl
;(function (i) {
  i[(i.Deprecated = 1)] = "Deprecated"
})(fl || (fl = {}))
var pl = (H3 = class {
  static validate(t) {
    if (!t.name) throw new Error("name must not be falsy")
  }
  constructor(t, e, r, s, a) {
    ;(this.name = t),
      (this.kind = e),
      (this.containerName = a),
      typeof r == "string" && (this.containerName = r),
      s instanceof er
        ? (this.location = s)
        : r instanceof Nt && (this.location = new er(s, r)),
      H3.validate(this)
  }
  toJSON() {
    return {
      name: this.name,
      kind: ae[this.kind],
      location: this.location,
      containerName: this.containerName,
    }
  }
})
pl = H3 = __decorate([st], pl)
var gl = (i6 = class {
  static validate(t) {
    if (!t.name) throw new Error("name must not be falsy")
    if (!t.range.contains(t.selectionRange))
      throw new Error("selectionRange must be contained in fullRange")
    t.children?.forEach(i6.validate)
  }
  constructor(t, e, r, s, a) {
    ;(this.name = t),
      (this.detail = e),
      (this.kind = r),
      (this.range = s),
      (this.selectionRange = a),
      (this.children = []),
      i6.validate(this)
  }
})
gl = i6 = __decorate([st], gl)
var vl
;(function (i) {
  ;(i[(i.Invoke = 1)] = "Invoke"), (i[(i.Automatic = 2)] = "Automatic")
})(vl || (vl = {}))
var l6 = class {
  constructor(t, e) {
    ;(this.title = t), (this.kind = e)
  }
}
l6 = __decorate([st], l6)
var ge = class {
  static {
    dl = this
  }
  static {
    this.c = "."
  }
  constructor(t) {
    this.value = t
  }
  append(t) {
    return new dl(this.value ? this.value + dl.c + t : t)
  }
  intersects(t) {
    return this.contains(t) || t.contains(this)
  }
  contains(t) {
    return this.value === t.value || t.value.startsWith(this.value + dl.c)
  }
}
;(ge = dl = __decorate([st], ge)),
  (ge.Empty = new ge("")),
  (ge.QuickFix = ge.Empty.append("quickfix")),
  (ge.Refactor = ge.Empty.append("refactor")),
  (ge.RefactorExtract = ge.Refactor.append("extract")),
  (ge.RefactorInline = ge.Refactor.append("inline")),
  (ge.RefactorMove = ge.Refactor.append("move")),
  (ge.RefactorRewrite = ge.Refactor.append("rewrite")),
  (ge.Source = ge.Empty.append("source")),
  (ge.SourceOrganizeImports = ge.Source.append("organizeImports")),
  (ge.SourceFixAll = ge.Source.append("fixAll")),
  (ge.Notebook = ge.Empty.append("notebook"))
var wl = class {
  constructor(t, e) {
    if (
      ((this.range = t), (this.parent = e), e && !e.range.contains(this.range))
    )
      throw new Error("Invalid argument: parent must contain this range")
  }
}
wl = __decorate([st], wl)
var Q3 = class {
    constructor(i, t, e, r, s, a) {
      ;(this.kind = i),
        (this.name = t),
        (this.detail = e),
        (this.uri = r),
        (this.range = s),
        (this.selectionRange = a)
    }
  },
  Yz = class {
    constructor(i, t) {
      ;(this.fromRanges = t), (this.from = i)
    }
  },
  Qz = class {
    constructor(i, t) {
      ;(this.fromRanges = t), (this.to = i)
    }
  },
  Fo
;(function (i) {
  ;(i[(i.Information = 0)] = "Information"),
    (i[(i.Warning = 1)] = "Warning"),
    (i[(i.Error = 2)] = "Error")
})(Fo || (Fo = {}))
var d6 = class {
  constructor(t, e) {
    ;(this.range = t), (this.command = e)
  }
  get isResolved() {
    return !!this.command
  }
}
d6 = __decorate([st], d6)
var Gi = (W3 = class {
  #t
  static isMarkdownString(t) {
    return t instanceof W3
      ? !0
      : t &&
          t.appendCodeblock &&
          t.appendMarkdown &&
          t.appendText &&
          t.value !== void 0
  }
  constructor(t, e = !1) {
    this.#t = new mV(t, { supportThemeIcons: e })
  }
  get value() {
    return this.#t.value
  }
  set value(t) {
    this.#t.value = t
  }
  get isTrusted() {
    return this.#t.isTrusted
  }
  set isTrusted(t) {
    this.#t.isTrusted = t
  }
  get supportThemeIcons() {
    return this.#t.supportThemeIcons
  }
  set supportThemeIcons(t) {
    this.#t.supportThemeIcons = t
  }
  get supportHtml() {
    return this.#t.supportHtml
  }
  set supportHtml(t) {
    this.#t.supportHtml = t
  }
  get baseUri() {
    return this.#t.baseUri
  }
  set baseUri(t) {
    this.#t.baseUri = t
  }
  appendText(t) {
    return this.#t.appendText(t), this
  }
  appendMarkdown(t) {
    return this.#t.appendMarkdown(t), this
  }
  appendCodeblock(t, e) {
    return this.#t.appendCodeblock(e ?? "", t), this
  }
})
Gi = W3 = __decorate([st], Gi)
var X3 = class {
  constructor(t, e) {
    ;(this.label = t), (this.documentation = e)
  }
}
X3 = __decorate([st], X3)
var K3 = class {
  constructor(t, e) {
    ;(this.label = t), (this.documentation = e), (this.parameters = [])
  }
}
K3 = __decorate([st], K3)
var Z3 = class {
  constructor() {
    ;(this.activeSignature = 0),
      (this.activeParameter = 0),
      (this.signatures = [])
  }
}
Z3 = __decorate([st], Z3)
var tO
;(function (i) {
  ;(i[(i.Invoke = 1)] = "Invoke"),
    (i[(i.TriggerCharacter = 2)] = "TriggerCharacter"),
    (i[(i.ContentChange = 3)] = "ContentChange")
})(tO || (tO = {}))
var eO
;(function (i) {
  ;(i[(i.Type = 1)] = "Type"), (i[(i.Parameter = 2)] = "Parameter")
})(eO || (eO = {}))
var m6 = class {
  constructor(t) {
    this.value = t
  }
}
m6 = __decorate([st], m6)
var h6 = class {
  constructor(t, e, r) {
    ;(this.position = t), (this.label = e), (this.kind = r)
  }
}
h6 = __decorate([st], h6)
var _o
;(function (i) {
  ;(i[(i.Invoke = 0)] = "Invoke"),
    (i[(i.TriggerCharacter = 1)] = "TriggerCharacter"),
    (i[(i.TriggerForIncompleteCompletions = 2)] =
      "TriggerForIncompleteCompletions")
})(_o || (_o = {}))
var mt
;(function (i) {
  ;(i[(i.Text = 0)] = "Text"),
    (i[(i.Method = 1)] = "Method"),
    (i[(i.Function = 2)] = "Function"),
    (i[(i.Constructor = 3)] = "Constructor"),
    (i[(i.Field = 4)] = "Field"),
    (i[(i.Variable = 5)] = "Variable"),
    (i[(i.Class = 6)] = "Class"),
    (i[(i.Interface = 7)] = "Interface"),
    (i[(i.Module = 8)] = "Module"),
    (i[(i.Property = 9)] = "Property"),
    (i[(i.Unit = 10)] = "Unit"),
    (i[(i.Value = 11)] = "Value"),
    (i[(i.Enum = 12)] = "Enum"),
    (i[(i.Keyword = 13)] = "Keyword"),
    (i[(i.Snippet = 14)] = "Snippet"),
    (i[(i.Color = 15)] = "Color"),
    (i[(i.File = 16)] = "File"),
    (i[(i.Reference = 17)] = "Reference"),
    (i[(i.Folder = 18)] = "Folder"),
    (i[(i.EnumMember = 19)] = "EnumMember"),
    (i[(i.Constant = 20)] = "Constant"),
    (i[(i.Struct = 21)] = "Struct"),
    (i[(i.Event = 22)] = "Event"),
    (i[(i.Operator = 23)] = "Operator"),
    (i[(i.TypeParameter = 24)] = "TypeParameter"),
    (i[(i.User = 25)] = "User"),
    (i[(i.Issue = 26)] = "Issue")
})(mt || (mt = {}))
var yl
;(function (i) {
  i[(i.Deprecated = 1)] = "Deprecated"
})(yl || (yl = {}))
var f6 = class {
  constructor(t, e) {
    ;(this.label = t), (this.kind = e)
  }
  toJSON() {
    return {
      label: this.label,
      kind: this.kind && mt[this.kind],
      detail: this.detail,
      documentation: this.documentation,
      sortText: this.sortText,
      filterText: this.filterText,
      preselect: this.preselect,
      insertText: this.insertText,
      textEdit: this.textEdit,
    }
  }
}
f6 = __decorate([st], f6)
var Ao = class {
  constructor(t = [], e = !1) {
    ;(this.items = t), (this.isIncomplete = e)
  }
}
Ao = __decorate([st], Ao)
var iO = class {
  constructor(t, e, r) {
    ;(this.insertText = t), (this.range = e), (this.command = r)
  }
}
iO = __decorate([st], iO)
var rO = class {
  constructor(t) {
    ;(this.commands = void 0),
      (this.suppressSuggestions = void 0),
      (this.items = t)
  }
}
rO = __decorate([st], rO)
var Ta
;(function (i) {
  ;(i[(i.Unknown = 0)] = "Unknown"),
    (i[(i.Word = 1)] = "Word"),
    (i[(i.Line = 2)] = "Line"),
    (i[(i.Suggest = 3)] = "Suggest")
})(Ta || (Ta = {}))
var Tl
;(function (i) {
  ;(i[(i.Active = -1)] = "Active"),
    (i[(i.Beside = -2)] = "Beside"),
    (i[(i.One = 1)] = "One"),
    (i[(i.Two = 2)] = "Two"),
    (i[(i.Three = 3)] = "Three"),
    (i[(i.Four = 4)] = "Four"),
    (i[(i.Five = 5)] = "Five"),
    (i[(i.Six = 6)] = "Six"),
    (i[(i.Seven = 7)] = "Seven"),
    (i[(i.Eight = 8)] = "Eight"),
    (i[(i.Nine = 9)] = "Nine")
})(Tl || (Tl = {}))
var ps
;(function (i) {
  ;(i[(i.Left = 1)] = "Left"), (i[(i.Right = 2)] = "Right")
})(ps || (ps = {}))
function kmt(i, t) {
  return `${te.toKey(i)}.${t}`
}
var Jr
;(function (i) {
  ;(i[(i.Off = 0)] = "Off"),
    (i[(i.On = 1)] = "On"),
    (i[(i.Relative = 2)] = "Relative"),
    (i[(i.Interval = 3)] = "Interval")
})(Jr || (Jr = {}))
var Bo
;(function (i) {
  ;(i[(i.Manual = 1)] = "Manual"),
    (i[(i.AfterDelay = 2)] = "AfterDelay"),
    (i[(i.FocusOut = 3)] = "FocusOut")
})(Bo || (Bo = {}))
var p6
;(function (i) {
  ;(i[(i.Default = 0)] = "Default"),
    (i[(i.InCenter = 1)] = "InCenter"),
    (i[(i.InCenterIfOutsideViewport = 2)] = "InCenterIfOutsideViewport"),
    (i[(i.AtTop = 3)] = "AtTop")
})(p6 || (p6 = {}))
var Oo
;(function (i) {
  ;(i[(i.Keyboard = 1)] = "Keyboard"),
    (i[(i.Mouse = 2)] = "Mouse"),
    (i[(i.Command = 3)] = "Command")
})(Oo || (Oo = {}))
var qo
;(function (i) {
  ;(i[(i.Addition = 1)] = "Addition"),
    (i[(i.Deletion = 2)] = "Deletion"),
    (i[(i.Modification = 3)] = "Modification")
})(qo || (qo = {}))
var kl
;(function (i) {
  ;(i[(i.Undo = 1)] = "Undo"), (i[(i.Redo = 2)] = "Redo")
})(kl || (kl = {}))
var ka
;(function (i) {
  ;(i[(i.OpenOpen = 0)] = "OpenOpen"),
    (i[(i.ClosedClosed = 1)] = "ClosedClosed"),
    (i[(i.OpenClosed = 2)] = "OpenClosed"),
    (i[(i.ClosedOpen = 3)] = "ClosedOpen")
})(ka || (ka = {})),
  (function (i) {
    function t(e) {
      switch (e) {
        case "keyboard":
          return i.Keyboard
        case "mouse":
          return i.Mouse
        case "api":
          return i.Command
      }
    }
    i.fromValue = t
  })(Oo || (Oo = {}))
var Uo
;(function (i) {
  ;(i[(i.Other = 0)] = "Other"),
    (i[(i.Comment = 1)] = "Comment"),
    (i[(i.String = 2)] = "String"),
    (i[(i.RegEx = 3)] = "RegEx")
})(Uo || (Uo = {})),
  (function (i) {
    function t(e) {
      switch (e) {
        case i.Other:
          return "other"
        case i.Comment:
          return "comment"
        case i.String:
          return "string"
        case i.RegEx:
          return "regex"
      }
      return "other"
    }
    i.toString = t
  })(Uo || (Uo = {}))
var g6 = class {
  constructor(t, e) {
    if (e && !S.isUri(e)) throw xt("target")
    if (!Nt.isRange(t) || t.isEmpty) throw xt("range")
    ;(this.range = t), (this.target = e)
  }
}
g6 = __decorate([st], g6)
var Mo = class {
  constructor(t, e, r, s) {
    ;(this.red = t), (this.green = e), (this.blue = r), (this.alpha = s)
  }
}
Mo = __decorate([st], Mo)
var v6 = class {
  constructor(t, e) {
    if (e && !(e instanceof Mo)) throw xt("color")
    if (!Nt.isRange(t) || t.isEmpty) throw xt("range")
    ;(this.range = t), (this.color = e)
  }
}
v6 = __decorate([st], v6)
var w6 = class {
  constructor(t) {
    if (!t || typeof t != "string") throw xt("label")
    this.label = t
  }
}
w6 = __decorate([st], w6)
var Xz
;(function (i) {
  ;(i[(i.RGB = 0)] = "RGB"), (i[(i.HEX = 1)] = "HEX"), (i[(i.HSL = 2)] = "HSL")
})(Xz || (Xz = {}))
var nO
;(function (i) {
  ;(i[(i.Error = 0)] = "Error"),
    (i[(i.Warning = 1)] = "Warning"),
    (i[(i.Information = 2)] = "Information")
})(nO || (nO = {}))
var sO
;(function (i) {
  ;(i[(i.Unknown = 0)] = "Unknown"),
    (i[(i.Shutdown = 1)] = "Shutdown"),
    (i[(i.Process = 2)] = "Process"),
    (i[(i.User = 3)] = "User"),
    (i[(i.Extension = 4)] = "Extension")
})(sO || (sO = {}))
var y6
;(function (i) {
  ;(i[(i.Low = 0)] = "Low"),
    (i[(i.Medium = 1)] = "Medium"),
    (i[(i.High = 2)] = "High")
})(y6 || (y6 = {}))
var Smt = class {
    constructor(i, t, e) {
      if (
        ((this.startIndex = i),
        (this.length = t),
        (this.tooltip = e),
        typeof i != "number" || i < 0)
      )
        throw xt("startIndex")
      if (typeof t != "number" || t < 1) throw xt("length")
      if (e !== void 0 && typeof e != "string") throw xt("tooltip")
    }
  },
  bmt = class {
    constructor(i) {
      this.uri = i
    }
  },
  Emt = class {
    constructor(i) {
      this.terminalCommand = i
    }
  },
  aO
;(function (i) {
  ;(i[(i.Panel = 1)] = "Panel"), (i[(i.Editor = 2)] = "Editor")
})(aO || (aO = {}))
var Imt = class {
    constructor(i) {
      if (((this.options = i), typeof i != "object")) throw xt("options")
    }
  },
  oO
;(function (i) {
  ;(i[(i.File = 0)] = "File"),
    (i[(i.Folder = 1)] = "Folder"),
    (i[(i.Flag = 2)] = "Flag"),
    (i[(i.Method = 3)] = "Method"),
    (i[(i.Argument = 4)] = "Argument")
})(oO || (oO = {}))
var Pmt = class {
    constructor(i, t, e, r, s, a, o, c) {
      ;(this.label = i),
        (this.icon = t),
        (this.detail = e),
        (this.isFile = r),
        (this.isDirectory = s),
        (this.isKeyword = a),
        (this.replacementIndex = o ?? 0),
        (this.replacementLength = c ?? 0)
    }
  },
  Nmt = class {
    constructor(i, t) {
      ;(this.items = i ?? []), (this.resourceRequestConfig = t)
    }
  },
  cO
;(function (i) {
  ;(i[(i.Always = 1)] = "Always"),
    (i[(i.Silent = 2)] = "Silent"),
    (i[(i.Never = 3)] = "Never")
})(cO || (cO = {}))
var uO
;(function (i) {
  ;(i[(i.Shared = 1)] = "Shared"),
    (i[(i.Dedicated = 2)] = "Dedicated"),
    (i[(i.New = 3)] = "New")
})(uO || (uO = {}))
var Sl = class {
  static {
    rn = this
  }
  static {
    this.Clean = new rn("clean", "Clean")
  }
  static {
    this.Build = new rn("build", "Build")
  }
  static {
    this.Rebuild = new rn("rebuild", "Rebuild")
  }
  static {
    this.Test = new rn("test", "Test")
  }
  static from(t) {
    switch (t) {
      case "clean":
        return rn.Clean
      case "build":
        return rn.Build
      case "rebuild":
        return rn.Rebuild
      case "test":
        return rn.Test
      default:
        return
    }
  }
  constructor(t, e) {
    if (((this.label = e), typeof t != "string" || typeof e != "string"))
      throw xt("name")
    this.c = t
  }
  get id() {
    return this.c
  }
}
Sl = rn = __decorate([st], Sl)
function Kz(i) {
  let t = ""
  for (let e = 0; e < i.length; e++) t += i[e].replace(/,/g, ",,") + ","
  return t
}
var Ho = class {
  constructor(t, e, r) {
    if (typeof t != "string") throw xt("process")
    ;(this.e = []),
      (this.c = t),
      e !== void 0 &&
        (Array.isArray(e) ? ((this.e = e), (this.f = r)) : (this.f = e))
  }
  get process() {
    return this.c
  }
  set process(t) {
    if (typeof t != "string") throw xt("process")
    this.c = t
  }
  get args() {
    return this.e
  }
  set args(t) {
    Array.isArray(t) || (t = []), (this.e = t)
  }
  get options() {
    return this.f
  }
  set options(t) {
    this.f = t
  }
  computeId() {
    const t = []
    if (
      (t.push("process"),
      this.c !== void 0 && t.push(this.c),
      this.e && this.e.length > 0)
    )
      for (const e of this.e) t.push(e)
    return Kz(t)
  }
}
Ho = __decorate([st], Ho)
var Sa = class {
  constructor(t, e, r) {
    if (((this.f = []), Array.isArray(e))) {
      if (!t) throw xt("command can't be undefined or null")
      if (typeof t != "string" && typeof t.value != "string")
        throw xt("command")
      ;(this.e = t), (this.f = e), (this.g = r)
    } else {
      if (typeof t != "string") throw xt("commandLine")
      ;(this.c = t), (this.g = e)
    }
  }
  get commandLine() {
    return this.c
  }
  set commandLine(t) {
    if (typeof t != "string") throw xt("commandLine")
    this.c = t
  }
  get command() {
    return this.e ? this.e : ""
  }
  set command(t) {
    if (typeof t != "string" && typeof t.value != "string") throw xt("command")
    this.e = t
  }
  get args() {
    return this.f
  }
  set args(t) {
    this.f = t || []
  }
  get options() {
    return this.g
  }
  set options(t) {
    this.g = t
  }
  computeId() {
    const t = []
    if (
      (t.push("shell"),
      this.c !== void 0 && t.push(this.c),
      this.e !== void 0 &&
        t.push(typeof this.e == "string" ? this.e : this.e.value),
      this.f && this.f.length > 0)
    )
      for (const e of this.f) t.push(typeof e == "string" ? e : e.value)
    return Kz(t)
  }
}
Sa = __decorate([st], Sa)
var lO
;(function (i) {
  ;(i[(i.Escape = 1)] = "Escape"),
    (i[(i.Strong = 2)] = "Strong"),
    (i[(i.Weak = 3)] = "Weak")
})(lO || (lO = {}))
var gs
;(function (i) {
  ;(i[(i.Global = 1)] = "Global"), (i[(i.Workspace = 2)] = "Workspace")
})(gs || (gs = {}))
var dO = class {
    constructor(i) {
      this.c = i
    }
    computeId() {
      return "customExecution" + Ki()
    }
    set callback(i) {
      this.c = i
    }
    get callback() {
      return this.c
    }
  },
  T6 = class {
    static {
      nn = this
    }
    static {
      this.c = "customExecution"
    }
    static {
      this.e = "process"
    }
    static {
      this.f = "shell"
    }
    static {
      this.g = "$empty"
    }
    constructor(t, e, r, s, a, o) {
      ;(this.k = !1), (this.l = this.definition = t)
      let c
      typeof e == "string"
        ? ((this.o = this.name = e),
          (this.w = this.source = r),
          (this.execution = s),
          (c = a),
          (this.k = !0))
        : e === gs.Global || e === gs.Workspace
          ? ((this.target = e),
            (this.o = this.name = r),
            (this.w = this.source = s),
            (this.execution = a),
            (c = o))
          : ((this.target = e),
            (this.o = this.name = r),
            (this.w = this.source = s),
            (this.execution = a),
            (c = o)),
        typeof c == "string"
          ? ((this.r = [c]), (this.t = !0))
          : Array.isArray(c)
            ? ((this.r = c), (this.t = !0))
            : ((this.r = []), (this.t = !1)),
        (this.u = !1),
        (this.y = Object.create(null)),
        (this.z = Object.create(null))
    }
    get _id() {
      return this.j
    }
    set _id(t) {
      this.j = t
    }
    get _deprecated() {
      return this.k
    }
    B() {
      this.j !== void 0 && ((this.j = void 0), (this.m = void 0), this.C())
    }
    C() {
      this.q instanceof Ho
        ? (this.l = { type: nn.e, id: this.q.computeId() })
        : this.q instanceof Sa
          ? (this.l = { type: nn.f, id: this.q.computeId() })
          : this.q instanceof dO
            ? (this.l = { type: nn.c, id: this.q.computeId() })
            : (this.l = { type: nn.g, id: Ki() })
    }
    get definition() {
      return this.l
    }
    set definition(t) {
      if (t == null) throw xt("Kind can't be undefined or null")
      this.B(), (this.l = t)
    }
    get scope() {
      return this.m
    }
    set target(t) {
      this.B(), (this.m = t)
    }
    get name() {
      return this.o
    }
    set name(t) {
      if (typeof t != "string") throw xt("name")
      this.B(), (this.o = t)
    }
    get execution() {
      return this.q
    }
    set execution(t) {
      t === null && (t = void 0), this.B(), (this.q = t)
      const e = this.l.type
      ;(nn.g === e || nn.e === e || nn.f === e || nn.c === e) && this.C()
    }
    get problemMatchers() {
      return this.r
    }
    set problemMatchers(t) {
      if (Array.isArray(t)) this.B(), (this.r = t), (this.t = !0)
      else {
        this.B(), (this.r = []), (this.t = !1)
        return
      }
    }
    get hasDefinedMatchers() {
      return this.t
    }
    get isBackground() {
      return this.u
    }
    set isBackground(t) {
      t !== !0 && t !== !1 && (t = !1), this.B(), (this.u = t)
    }
    get source() {
      return this.w
    }
    set source(t) {
      if (typeof t != "string" || t.length === 0)
        throw xt("source must be a string of length > 0")
      this.B(), (this.w = t)
    }
    get group() {
      return this.x
    }
    set group(t) {
      t === null && (t = void 0), this.B(), (this.x = t)
    }
    get detail() {
      return this.A
    }
    set detail(t) {
      t === null && (t = void 0), (this.A = t)
    }
    get presentationOptions() {
      return this.y
    }
    set presentationOptions(t) {
      t == null && (t = Object.create(null)), this.B(), (this.y = t)
    }
    get runOptions() {
      return this.z
    }
    set runOptions(t) {
      t == null && (t = Object.create(null)), this.B(), (this.z = t)
    }
  }
T6 = nn = __decorate([st], T6)
var ba
;(function (i) {
  ;(i[(i.SourceControl = 1)] = "SourceControl"),
    (i[(i.Window = 10)] = "Window"),
    (i[(i.Notification = 15)] = "Notification")
})(ba || (ba = {}))
var mO
;(function (i) {
  function t(e) {
    const r = e
    return os(r.value)
      ? r.tooltip && !Bt(r.tooltip)
        ? (console.log("INVALID view badge, invalid tooltip", r.tooltip), !1)
        : !0
      : (console.log("INVALID view badge, invalid value", r.value), !1)
  }
  i.isViewBadge = t
})(mO || (mO = {}))
var k6 = (j3 = class {
  static isTreeItem(t, e) {
    const r = t
    if (r.checkboxState !== void 0) {
      const s = os(r.checkboxState)
          ? r.checkboxState
          : Ce(r.checkboxState) && os(r.checkboxState.state)
            ? r.checkboxState.state
            : void 0,
        a =
          !os(r.checkboxState) && Ce(r.checkboxState)
            ? r.checkboxState.tooltip
            : void 0
      if (
        s === void 0 ||
        (s !== sn.Checked && s !== sn.Unchecked) ||
        (a !== void 0 && !Bt(a))
      )
        return (
          console.log(
            "INVALID tree item, invalid checkboxState",
            r.checkboxState,
          ),
          !1
        )
    }
    if (t instanceof j3) return !0
    if (r.label !== void 0 && !Bt(r.label) && !r.label?.label)
      return console.log("INVALID tree item, invalid label", r.label), !1
    if (r.id !== void 0 && !Bt(r.id))
      return console.log("INVALID tree item, invalid id", r.id), !1
    if (
      r.iconPath !== void 0 &&
      !Bt(r.iconPath) &&
      !S.isUri(r.iconPath) &&
      (!r.iconPath || !Bt(r.iconPath.id))
    ) {
      const s = r.iconPath
      if (
        !s ||
        (!Bt(s.light) && !S.isUri(s.light) && !Bt(s.dark) && !S.isUri(s.dark))
      )
        return (
          console.log("INVALID tree item, invalid iconPath", r.iconPath), !1
        )
    }
    return r.description !== void 0 &&
      !Bt(r.description) &&
      typeof r.description != "boolean"
      ? (console.log("INVALID tree item, invalid description", r.description),
        !1)
      : r.resourceUri !== void 0 && !S.isUri(r.resourceUri)
        ? (console.log("INVALID tree item, invalid resourceUri", r.resourceUri),
          !1)
        : r.tooltip !== void 0 && !Bt(r.tooltip) && !(r.tooltip instanceof Gi)
          ? (console.log("INVALID tree item, invalid tooltip", r.tooltip), !1)
          : r.command !== void 0 && !r.command.command
            ? (console.log("INVALID tree item, invalid command", r.command), !1)
            : r.collapsibleState !== void 0 &&
                r.collapsibleState < Ea.None &&
                r.collapsibleState > Ea.Expanded
              ? (console.log(
                  "INVALID tree item, invalid collapsibleState",
                  r.collapsibleState,
                ),
                !1)
              : r.contextValue !== void 0 && !Bt(r.contextValue)
                ? (console.log(
                    "INVALID tree item, invalid contextValue",
                    r.contextValue,
                  ),
                  !1)
                : r.accessibilityInformation !== void 0 &&
                    !r.accessibilityInformation?.label
                  ? (console.log(
                      "INVALID tree item, invalid accessibilityInformation",
                      r.accessibilityInformation,
                    ),
                    !1)
                  : !0
  }
  constructor(t, e = Ea.None) {
    ;(this.collapsibleState = e),
      S.isUri(t) ? (this.resourceUri = t) : (this.label = t)
  }
})
k6 = j3 = __decorate([st], k6)
var Ea
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Collapsed = 1)] = "Collapsed"),
    (i[(i.Expanded = 2)] = "Expanded")
})(Ea || (Ea = {}))
var sn
;(function (i) {
  ;(i[(i.Unchecked = 0)] = "Unchecked"), (i[(i.Checked = 1)] = "Checked")
})(sn || (sn = {}))
var S6 = class {
  async asString() {
    return typeof this.value == "string"
      ? this.value
      : JSON.stringify(this.value)
  }
  asFile() {}
  constructor(t) {
    this.value = t
  }
}
S6 = __decorate([st], S6)
var b6 = class extends S6 {},
  $mt = class extends b6 {
    #t
    constructor(i) {
      super(""), (this.#t = i)
    }
    asFile() {
      return this.#t
    }
  },
  xmt = class {
    constructor(i, t, e, r) {
      ;(this.name = i), (this.uri = t), (this._itemId = e), (this.c = r)
    }
    data() {
      return this.c()
    }
  },
  bl = class {
    #t = new Map()
    constructor(t) {
      for (const [e, r] of t ?? []) {
        const s = this.#t.get(this.#e(e))
        s ? s.push(r) : this.#t.set(this.#e(e), [r])
      }
    }
    get(t) {
      return this.#t.get(this.#e(t))?.[0]
    }
    set(t, e) {
      this.#t.set(this.#e(t), [e])
    }
    forEach(t, e) {
      for (const [r, s] of this.#t) for (const a of s) t.call(e, a, r, this)
    }
    *[Symbol.iterator]() {
      for (const [t, e] of this.#t) for (const r of e) yield [t, r]
    }
    #e(t) {
      return t.toLowerCase()
    }
  }
bl = __decorate([st], bl)
var hO = class {
  constructor(t, e, r) {
    ;(this.insertText = t), (this.title = e), (this.kind = r)
  }
}
hO = __decorate([st], hO)
var fO
;(function (i) {
  ;(i[(i.Automatic = 0)] = "Automatic"), (i[(i.PasteAs = 1)] = "PasteAs")
})(fO || (fO = {}))
var Wo = class W8 {
  static {
    this.c = "."
  }
  constructor(t) {
    this.value = t
  }
  append(...t) {
    return new W8((this.value ? [this.value, ...t] : t).join(W8.c))
  }
  intersects(t) {
    return this.contains(t) || t.contains(this)
  }
  contains(t) {
    return this.value === t.value || t.value.startsWith(this.value + W8.c)
  }
}
;(Wo.Empty = new Wo("")), (Wo.Text = new Wo("text"))
var Jmt = class {
    constructor(i, t, e) {
      ;(this.title = t), (this.insertText = i), (this.kind = e)
    }
  },
  Si = class {
    constructor(t, e) {
      ;(this.id = t), (this.color = e)
    }
    static isThemeIcon(t) {
      return typeof t.id != "string"
        ? (console.log("INVALID ThemeIcon, invalid id", t.id), !1)
        : !0
    }
  }
;(Si = __decorate([st], Si)),
  (Si.File = new Si("file")),
  (Si.Folder = new Si("folder"))
var El = class {
  constructor(t) {
    this.id = t
  }
}
El = __decorate([st], El)
var jo
;(function (i) {
  ;(i[(i.Global = 1)] = "Global"),
    (i[(i.Workspace = 2)] = "Workspace"),
    (i[(i.WorkspaceFolder = 3)] = "WorkspaceFolder")
})(jo || (jo = {}))
var Vo = class {
  get base() {
    return this.c
  }
  set base(t) {
    ;(this.c = t), (this.e = S.file(t))
  }
  get baseUri() {
    return this.e
  }
  set baseUri(t) {
    ;(this.e = t), (this.c = t.fsPath)
  }
  constructor(t, e) {
    if (typeof t != "string" && (!t || (!S.isUri(t) && !S.isUri(t.uri))))
      throw xt("base")
    if (typeof e != "string") throw xt("pattern")
    typeof t == "string"
      ? (this.baseUri = S.file(t))
      : S.isUri(t)
        ? (this.baseUri = t)
        : (this.baseUri = t.uri),
      (this.pattern = e)
  }
  toJSON() {
    return {
      pattern: this.pattern,
      base: this.base,
      baseUri: this.baseUri.toJSON(),
    }
  }
}
Vo = __decorate([st], Vo)
var Zz = new WeakMap()
function Cmt(i, t) {
  Zz.set(i, t)
}
var Go = class {
  constructor(t, e, r, s, a) {
    ;(this.enabled = typeof t == "boolean" ? t : !0),
      typeof e == "string" && (this.condition = e),
      typeof r == "string" && (this.hitCondition = r),
      typeof s == "string" && (this.logMessage = s),
      typeof a == "string" && (this.mode = a)
  }
  get id() {
    return this.c || (this.c = Zz.get(this) ?? Ki()), this.c
  }
}
Go = __decorate([st], Go)
var Ia = class extends Go {
  constructor(t, e, r, s, a, o) {
    if ((super(e, r, s, a, o), t === null)) throw xt("location")
    this.location = t
  }
}
Ia = __decorate([st], Ia)
var Pa = class extends Go {
  constructor(t, e, r, s, a, o) {
    super(e, r, s, a, o), (this.functionName = t)
  }
}
Pa = __decorate([st], Pa)
var E6 = class extends Go {
  constructor(t, e, r, s, a, o, c, u) {
    if ((super(s, a, o, c, u), !e)) throw xt("dataId")
    ;(this.label = t), (this.dataId = e), (this.canPersist = r)
  }
}
E6 = __decorate([st], E6)
var I6 = class {
  constructor(t, e, r) {
    ;(this.command = t), (this.args = e || []), (this.options = r)
  }
}
I6 = __decorate([st], I6)
var Il = class {
  constructor(t, e) {
    ;(this.port = t), (this.host = e)
  }
}
Il = __decorate([st], Il)
var P6 = class {
  constructor(t) {
    this.path = t
  }
}
P6 = __decorate([st], P6)
var Pl = class {
  constructor(t) {
    this.implementation = t
  }
}
Pl = __decorate([st], Pl)
var tY = class {
    constructor(i, t, e) {
      ;(this.session = i), (this.threadId = t), (this.frameId = e)
    }
  },
  eY = class {
    constructor(i, t) {
      ;(this.session = i), (this.threadId = t)
    }
  },
  N6 = class {
    constructor(t, e) {
      ;(this.range = t), (this.expression = e)
    }
  }
N6 = __decorate([st], N6)
var Nl
;(function (i) {
  ;(i[(i.Invoke = 0)] = "Invoke"), (i[(i.Automatic = 1)] = "Automatic")
})(Nl || (Nl = {}))
var $6 = class {
  constructor(t, e) {
    ;(this.range = t), (this.text = e)
  }
}
$6 = __decorate([st], $6)
var x6 = class {
  constructor(t, e, r = !0) {
    ;(this.range = t), (this.variableName = e), (this.caseSensitiveLookup = r)
  }
}
x6 = __decorate([st], x6)
var J6 = class {
  constructor(t, e) {
    ;(this.range = t), (this.expression = e)
  }
}
J6 = __decorate([st], J6)
var pO = class {
  constructor(t, e) {
    ;(this.frameId = t), (this.stoppedLocation = e)
  }
}
pO = __decorate([st], pO)
var gO
;(function (i) {
  i[(i.AIGenerated = 1)] = "AIGenerated"
})(gO || (gO = {}))
var $l
;(function (i) {
  ;(i[(i.Invoke = 0)] = "Invoke"), (i[(i.Automatic = 1)] = "Automatic")
})($l || ($l = {}))
var Lmt = class {
    constructor(i, t) {
      ;(this.newSymbolName = i), (this.tags = t)
    }
  },
  zo
;(function (i) {
  ;(i[(i.Changed = 1)] = "Changed"),
    (i[(i.Created = 2)] = "Created"),
    (i[(i.Deleted = 3)] = "Deleted")
})(zo || (zo = {}))
var Ue = (Ci = class extends Error {
  static FileExists(t) {
    return new Ci(t, It.FileExists, Ci.FileExists)
  }
  static FileNotFound(t) {
    return new Ci(t, It.FileNotFound, Ci.FileNotFound)
  }
  static FileNotADirectory(t) {
    return new Ci(t, It.FileNotADirectory, Ci.FileNotADirectory)
  }
  static FileIsADirectory(t) {
    return new Ci(t, It.FileIsADirectory, Ci.FileIsADirectory)
  }
  static NoPermissions(t) {
    return new Ci(t, It.NoPermissions, Ci.NoPermissions)
  }
  static Unavailable(t) {
    return new Ci(t, It.Unavailable, Ci.Unavailable)
  }
  constructor(t, e = It.Unknown, r) {
    super(S.isUri(t) ? t.toString(!0) : t),
      (this.code = r?.name ?? "Unknown"),
      rG(this, e),
      Object.setPrototypeOf(this, Ci.prototype),
      typeof Error.captureStackTrace == "function" &&
        typeof r == "function" &&
        Error.captureStackTrace(this, r)
  }
})
Ue = Ci = __decorate([st], Ue)
var vO = class {
  constructor(t, e, r) {
    ;(this.start = t), (this.end = e), (this.kind = r)
  }
}
vO = __decorate([st], vO)
var Nn
;(function (i) {
  ;(i[(i.Comment = 1)] = "Comment"),
    (i[(i.Imports = 2)] = "Imports"),
    (i[(i.Region = 3)] = "Region")
})(Nn || (Nn = {}))
var xl
;(function (i) {
  ;(i[(i.Collapsed = 0)] = "Collapsed"), (i[(i.Expanded = 1)] = "Expanded")
})(xl || (xl = {}))
var wO
;(function (i) {
  ;(i[(i.Editing = 0)] = "Editing"), (i[(i.Preview = 1)] = "Preview")
})(wO || (wO = {}))
var yO
;(function (i) {
  ;(i[(i.Published = 0)] = "Published"), (i[(i.Draft = 1)] = "Draft")
})(yO || (yO = {}))
var Jl
;(function (i) {
  ;(i[(i.Unresolved = 0)] = "Unresolved"), (i[(i.Resolved = 1)] = "Resolved")
})(Jl || (Jl = {}))
var Cl
;(function (i) {
  ;(i[(i.Current = 0)] = "Current"), (i[(i.Outdated = 1)] = "Outdated")
})(Cl || (Cl = {}))
var Ll
;(function (i) {
  ;(i[(i.Reply = 1)] = "Reply"), (i[(i.Comment = 2)] = "Comment")
})(Ll || (Ll = {}))
var TO = class {
  constructor(i, t = []) {
    ;(this.tokenTypes = i), (this.tokenModifiers = t)
  }
}
function Rmt(i) {
  return typeof i > "u" || Bot(i)
}
var Dmt = class Mnt {
    constructor(t) {
      if (
        ((this.c = 0),
        (this.e = 0),
        (this.f = !0),
        (this.g = []),
        (this.j = 0),
        (this.k = new Map()),
        (this.l = new Map()),
        (this.m = !1),
        t)
      ) {
        this.m = !0
        for (let e = 0, r = t.tokenTypes.length; e < r; e++)
          this.k.set(t.tokenTypes[e], e)
        for (let e = 0, r = t.tokenModifiers.length; e < r; e++)
          this.l.set(t.tokenModifiers[e], e)
      }
    }
    push(t, e, r, s, a) {
      if (
        typeof t == "number" &&
        typeof e == "number" &&
        typeof r == "number" &&
        typeof s == "number" &&
        (typeof a == "number" || typeof a > "u")
      )
        return typeof a > "u" && (a = 0), this.q(t, e, r, s, a)
      if (Nt.isRange(t) && typeof e == "string" && Rmt(r))
        return this.o(t, e, r)
      throw xt()
    }
    o(t, e, r) {
      if (!this.m) throw new Error("Legend must be provided in constructor")
      if (t.start.line !== t.end.line)
        throw new Error("`range` cannot span multiple lines")
      if (!this.k.has(e))
        throw new Error("`tokenType` is not in the provided legend")
      const s = t.start.line,
        a = t.start.character,
        o = t.end.character - t.start.character,
        c = this.k.get(e)
      let u = 0
      if (r)
        for (const l of r) {
          if (!this.l.has(l))
            throw new Error("`tokenModifier` is not in the provided legend")
          const m = this.l.get(l)
          u |= (1 << m) >>> 0
        }
      this.q(s, a, o, c, u)
    }
    q(t, e, r, s, a) {
      if (this.f && (t < this.c || (t === this.c && e < this.e))) {
        this.f = !1
        const u = (this.g.length / 5) | 0
        let l = 0,
          m = 0
        for (let h = 0; h < u; h++) {
          let p = this.g[5 * h],
            g = this.g[5 * h + 1]
          p === 0 ? ((p = l), (g += m)) : (p += l),
            (this.g[5 * h] = p),
            (this.g[5 * h + 1] = g),
            (l = p),
            (m = g)
        }
      }
      let o = t,
        c = e
      this.f && this.j > 0 && ((o -= this.c), o === 0 && (c -= this.e)),
        (this.g[this.j++] = o),
        (this.g[this.j++] = c),
        (this.g[this.j++] = r),
        (this.g[this.j++] = s),
        (this.g[this.j++] = a),
        (this.c = t),
        (this.e = e)
    }
    static r(t) {
      const e = [],
        r = (t.length / 5) | 0
      for (let c = 0; c < r; c++) e[c] = c
      e.sort((c, u) => {
        const l = t[5 * c],
          m = t[5 * u]
        if (l === m) {
          const h = t[5 * c + 1],
            p = t[5 * u + 1]
          return h - p
        }
        return l - m
      })
      const s = new Uint32Array(t.length)
      let a = 0,
        o = 0
      for (let c = 0; c < r; c++) {
        const u = 5 * e[c],
          l = t[u + 0],
          m = t[u + 1],
          h = t[u + 2],
          p = t[u + 3],
          g = t[u + 4],
          w = l - a,
          T = w === 0 ? m - o : m,
          b = 5 * c
        ;(s[b + 0] = w),
          (s[b + 1] = T),
          (s[b + 2] = h),
          (s[b + 3] = p),
          (s[b + 4] = g),
          (a = l),
          (o = m)
      }
      return s
    }
    build(t) {
      return this.f
        ? new Yo(new Uint32Array(this.g), t)
        : new Yo(Mnt.r(this.g), t)
    }
  },
  Yo = class {
    constructor(i, t) {
      ;(this.resultId = t), (this.data = i)
    }
  },
  iY = class {
    constructor(i, t, e) {
      ;(this.start = i), (this.deleteCount = t), (this.data = e)
    }
  },
  C6 = class {
    constructor(i, t) {
      ;(this.resultId = t), (this.edits = i)
    }
  },
  L6
;(function (i) {
  ;(i[(i.Separate = 0)] = "Separate"),
    (i[(i.MergeWithParent = 1)] = "MergeWithParent")
})(L6 || (L6 = {}))
var Fmt = class {
    constructor(i) {
      this.name = i
    }
  },
  kO
;(function (i) {
  ;(i[(i.Title = 1)] = "Title"), (i[(i.Inline = 2)] = "Inline")
})(kO || (kO = {}))
var Rl = class {
  static {
    this.Back = { iconPath: new Si("arrow-left") }
  }
  constructor() {}
}
Rl = __decorate([st], Rl)
var Dl
;(function (i) {
  ;(i[(i.Separator = -1)] = "Separator"), (i[(i.Default = 0)] = "Default")
})(Dl || (Dl = {}))
var Qo
;(function (i) {
  ;(i[(i.Info = 1)] = "Info"),
    (i[(i.Warning = 2)] = "Warning"),
    (i[(i.Error = 3)] = "Error")
})(Qo || (Qo = {}))
var Na
;(function (i) {
  ;(i[(i.UI = 1)] = "UI"), (i[(i.Workspace = 2)] = "Workspace")
})(Na || (Na = {}))
var SO = class {
    static validate(i) {
      if (typeof i.badge == "string") {
        let t = BW(i.badge, 0)
        if ((t < i.badge.length && (t += BW(i.badge, t)), i.badge.length > t))
          throw new Error(
            "The 'badge'-property must be undefined or a short character",
          )
      } else if (i.badge && !Si.isThemeIcon(i.badge))
        throw new Error("The 'badge'-property is not a valid ThemeIcon")
      if (!i.color && !i.badge && !i.tooltip)
        throw new Error("The decoration is empty")
      return !0
    }
    constructor(i, t, e) {
      ;(this.badge = i), (this.tooltip = t), (this.color = e)
    }
  },
  R6 = class {
    constructor(t) {
      this.kind = t
    }
  }
R6 = __decorate([st], R6)
var vs
;(function (i) {
  ;(i[(i.Light = 1)] = "Light"),
    (i[(i.Dark = 2)] = "Dark"),
    (i[(i.HighContrast = 3)] = "HighContrast"),
    (i[(i.HighContrastLight = 4)] = "HighContrastLight")
})(vs || (vs = {}))
var $n = class pH {
    static isNotebookRange(t) {
      return t instanceof pH
        ? !0
        : t
          ? typeof t.start == "number" && typeof t.end == "number"
          : !1
    }
    get start() {
      return this.c
    }
    get end() {
      return this.e
    }
    get isEmpty() {
      return this.c === this.e
    }
    constructor(t, e) {
      if (t < 0) throw xt("start must be positive")
      if (e < 0) throw xt("end must be positive")
      t <= e ? ((this.c = t), (this.e = e)) : ((this.c = e), (this.e = t))
    }
    with(t) {
      let e = this.c,
        r = this.e
      return (
        t.start !== void 0 && (e = t.start),
        t.end !== void 0 && (r = t.end),
        e === this.c && r === this.e ? this : new pH(e, r)
      )
    }
  },
  D6 = class gH {
    static validate(t) {
      if (typeof t.kind != "number")
        throw new Error("NotebookCellData MUST have 'kind' property")
      if (typeof t.value != "string")
        throw new Error("NotebookCellData MUST have 'value' property")
      if (typeof t.languageId != "string")
        throw new Error("NotebookCellData MUST have 'languageId' property")
    }
    static isNotebookCellDataArray(t) {
      return Array.isArray(t) && t.every((e) => gH.isNotebookCellData(e))
    }
    static isNotebookCellData(t) {
      return !0
    }
    constructor(t, e, r, s, a, o, c) {
      ;(this.kind = t),
        (this.value = e),
        (this.languageId = r),
        (this.mime = s),
        (this.outputs = a ?? []),
        (this.metadata = o),
        (this.executionSummary = c),
        gH.validate(this)
    }
  },
  rY = class {
    constructor(i) {
      this.cells = i
    }
  },
  nY = class Qn {
    static isNotebookCellOutputItem(t) {
      return t instanceof Qn
        ? !0
        : t
          ? typeof t.mime == "string" && t.data instanceof Uint8Array
          : !1
    }
    static error(t) {
      const e = { name: t.name, message: t.message, stack: t.stack }
      return Qn.json(e, "application/vnd.code.notebook.error")
    }
    static stdout(t) {
      return Qn.text(t, "application/vnd.code.notebook.stdout")
    }
    static stderr(t) {
      return Qn.text(t, "application/vnd.code.notebook.stderr")
    }
    static bytes(t, e = "application/octet-stream") {
      return new Qn(t, e)
    }
    static #t = new TextEncoder()
    static text(t, e = kn.text) {
      const r = Qn.#t.encode(String(t))
      return new Qn(r, e)
    }
    static json(t, e = "text/x-json") {
      const r = JSON.stringify(t, void 0, "	")
      return Qn.text(r, e)
    }
    constructor(t, e) {
      ;(this.data = t), (this.mime = e)
      const r = xV(e, !0)
      if (!r)
        throw new Error(
          `INVALID mime type: ${e}. Must be in the format "type/subtype[;optionalparameter]"`,
        )
      this.mime = r
    }
  },
  F6 = class vH {
    static isNotebookCellOutput(t) {
      return t instanceof vH
        ? !0
        : !t || typeof t != "object"
          ? !1
          : typeof t.id == "string" && Array.isArray(t.items)
    }
    static ensureUniqueMimeTypes(t, e = !1) {
      const r = new Set(),
        s = new Set()
      for (let a = 0; a < t.length; a++) {
        const o = t[a],
          c = xV(o.mime)
        if (!r.has(c) || wz(c)) {
          r.add(c)
          continue
        }
        s.add(a),
          e && console.warn(`DUPLICATED mime type '${o.mime}' will be dropped`)
      }
      return s.size === 0 ? t : t.filter((a, o) => !s.has(o))
    }
    constructor(t, e, r) {
      ;(this.items = vH.ensureUniqueMimeTypes(t, !0)),
        typeof e == "string"
          ? ((this.id = e), (this.metadata = r))
          : ((this.id = Ki()), (this.metadata = e ?? r))
    }
  },
  _mt = class {
    constructor(i, t, e) {
      ;(this.label = i), (this.uri = t), (this.position = e)
    }
  },
  $a
;(function (i) {
  ;(i[(i.Markup = 1)] = "Markup"), (i[(i.Code = 2)] = "Code")
})($a || ($a = {}))
var Xo
;(function (i) {
  ;(i[(i.Idle = 1)] = "Idle"),
    (i[(i.Pending = 2)] = "Pending"),
    (i[(i.Executing = 3)] = "Executing")
})(Xo || (Xo = {}))
var _6
;(function (i) {
  ;(i[(i.Left = 1)] = "Left"), (i[(i.Right = 2)] = "Right")
})(_6 || (_6 = {}))
var A6
;(function (i) {
  ;(i[(i.Default = 0)] = "Default"),
    (i[(i.InCenter = 1)] = "InCenter"),
    (i[(i.InCenterIfOutsideViewport = 2)] = "InCenterIfOutsideViewport"),
    (i[(i.AtTop = 3)] = "AtTop")
})(A6 || (A6 = {}))
var Amt = class {
    constructor(i, t) {
      ;(this.text = i), (this.alignment = t)
    }
  },
  bO
;(function (i) {
  ;(i[(i.Default = 1)] = "Default"), (i[(i.Preferred = 2)] = "Preferred")
})(bO || (bO = {}))
var B6
;(function (i) {
  ;(i[(i.Default = 1)] = "Default"),
    (i[(i.Preferred = 2)] = "Preferred"),
    (i[(i.Hidden = -1)] = "Hidden")
})(B6 || (B6 = {}))
var sY = class {
    constructor(i, t = []) {
      ;(this.uri = i), (this.provides = Yr(t))
    }
  },
  Bmt = class {
    constructor(i) {
      this.label = i
    }
  },
  Fl
;(function (i) {
  ;(i[(i.Named = 1)] = "Named"), (i[(i.Indexed = 2)] = "Indexed")
})(Fl || (Fl = {}))
var EO = class {
  constructor(t, e) {
    ;(this.label = t), (this.timestamp = e)
  }
}
EO = __decorate([st], EO)
var Ko
;(function (i) {
  ;(i[(i.Production = 1)] = "Production"),
    (i[(i.Development = 2)] = "Development"),
    (i[(i.Test = 3)] = "Test")
})(Ko || (Ko = {}))
var O6
;(function (i) {
  ;(i[(i.Node = 1)] = "Node"), (i[(i.Webworker = 2)] = "Webworker")
})(O6 || (O6 = {}))
var ws
;(function (i) {
  ;(i[(i.Other = 0)] = "Other"),
    (i[(i.Comment = 1)] = "Comment"),
    (i[(i.String = 2)] = "String"),
    (i[(i.RegEx = 3)] = "RegEx")
})(ws || (ws = {}))
var Omt = class {
    constructor(i, t) {
      ;(this.ranges = i), (this.wordPattern = t)
    }
  },
  qmt = class {
    constructor(i) {
      this.c = i
    }
    get autoForwardAction() {
      return this.c
    }
  },
  IO
;(function (i) {
  ;(i[(i.Queued = 1)] = "Queued"),
    (i[(i.Running = 2)] = "Running"),
    (i[(i.Passed = 3)] = "Passed"),
    (i[(i.Failed = 4)] = "Failed"),
    (i[(i.Skipped = 5)] = "Skipped"),
    (i[(i.Errored = 6)] = "Errored")
})(IO || (IO = {}))
var Zo
;(function (i) {
  ;(i[(i.Run = 1)] = "Run"),
    (i[(i.Debug = 2)] = "Debug"),
    (i[(i.Coverage = 3)] = "Coverage")
})(Zo || (Zo = {}))
var aY = class {
    constructor(i, t, e) {
      ;(this.controllerId = i), (this.profileId = t), (this.kind = e)
    }
  },
  q6 = class {
    constructor(t = void 0, e = void 0, r = void 0, s = !1, a = !0) {
      ;(this.include = t),
        (this.exclude = e),
        (this.profile = r),
        (this.continuous = s),
        (this.preserveFocus = a)
    }
  }
q6 = __decorate([st], q6)
var U6 = (V3 = class {
  static diff(t, e, r) {
    const s = new V3(t)
    return (s.expectedOutput = e), (s.actualOutput = r), s
  }
  constructor(t) {
    this.message = t
  }
})
U6 = V3 = __decorate([st], U6)
var _l = class {
  constructor(t) {
    this.id = t
  }
}
_l = __decorate([st], _l)
var Umt = class {
    constructor(i, t, e) {
      ;(this.label = i), (this.uri = t), (this.position = e)
    }
  },
  M6 = class {
    constructor(i, t) {
      ;(this.covered = i), (this.total = t), H6(this)
    }
  }
function H6(i) {
  if (i) {
    if (i.covered > i.total)
      throw new Error(
        `The total number of covered items (${i.covered}) cannot be greater than the total (${i.total})`,
      )
    if (i.total < 0)
      throw new Error(
        `The number of covered items (${i.total}) cannot be negative`,
      )
  }
}
var W6 = class Hnt {
    static fromDetails(t, e) {
      const r = new M6(0, 0),
        s = new M6(0, 0),
        a = new M6(0, 0)
      for (const c of e)
        if ("branches" in c) {
          ;(r.total += 1), (r.covered += c.executed ? 1 : 0)
          for (const u of c.branches)
            (s.total += 1), (s.covered += u.executed ? 1 : 0)
        } else (a.total += 1), (a.covered += c.executed ? 1 : 0)
      const o = new Hnt(
        t,
        r,
        s.total > 0 ? s : void 0,
        a.total > 0 ? a : void 0,
      )
      return (o.detailedCoverage = e), o
    }
    constructor(t, e, r, s, a = []) {
      ;(this.uri = t),
        (this.statementCoverage = e),
        (this.branchCoverage = r),
        (this.declarationCoverage = s),
        (this.includesTests = a)
    }
  },
  oY = class {
    get executionCount() {
      return +this.executed
    }
    set executionCount(i) {
      this.executed = i
    }
    constructor(i, t, e = []) {
      ;(this.executed = i), (this.location = t), (this.branches = e)
    }
  },
  cY = class {
    get executionCount() {
      return +this.executed
    }
    set executionCount(i) {
      this.executed = i
    }
    constructor(i, t, e) {
      ;(this.executed = i), (this.location = t), (this.label = e)
    }
  },
  uY = class {
    get executionCount() {
      return +this.executed
    }
    set executionCount(i) {
      this.executed = i
    }
    constructor(i, t, e) {
      ;(this.name = i), (this.executed = t), (this.location = e)
    }
  },
  PO
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Option = 1)] = "Option"),
    (i[(i.Default = 2)] = "Default"),
    (i[(i.Preferred = 3)] = "Preferred")
})(PO || (PO = {}))
var NO
;(function (i) {
  ;(i[(i.Untrusted = 0)] = "Untrusted"),
    (i[(i.Trusted = 1)] = "Trusted"),
    (i[(i.Unspecified = 2)] = "Unspecified")
})(NO || (NO = {}))
var $O
;(function (i) {
  ;(i[(i.Notify = 1)] = "Notify"),
    (i[(i.OpenBrowser = 2)] = "OpenBrowser"),
    (i[(i.OpenPreview = 3)] = "OpenPreview"),
    (i[(i.Silent = 4)] = "Silent"),
    (i[(i.Ignore = 5)] = "Ignore"),
    (i[(i.OpenBrowserOnce = 6)] = "OpenBrowserOnce")
})($O || ($O = {}))
var xO = class {
    constructor(i, t, e, r, s, a) {
      ;(this.kind = i),
        (this.name = t),
        (this.detail = e),
        (this.uri = r),
        (this.range = s),
        (this.selectionRange = a)
    }
  },
  JO = class {
    constructor(i) {
      this.uri = i
    }
  },
  j6 = class {
    constructor(i, t) {
      ;(this.original = i), (this.modified = t)
    }
  },
  lY = class {
    constructor(i, t, e, r) {
      ;(this.base = i), (this.input1 = t), (this.input2 = e), (this.result = r)
    }
  },
  CO = class {
    constructor(i, t) {
      ;(this.uri = i), (this.viewType = t)
    }
  },
  dY = class {
    constructor(i) {
      this.viewType = i
    }
  },
  LO = class {
    constructor(i, t) {
      ;(this.uri = i), (this.notebookType = t)
    }
  },
  RO = class {
    constructor(i, t, e) {
      ;(this.original = i), (this.modified = t), (this.notebookType = e)
    }
  },
  mY = class {
    constructor() {}
  },
  hY = class {
    constructor(i, t) {
      ;(this.uri = i), (this.inputBoxUri = t)
    }
  },
  fY = class {
    constructor() {}
  },
  pY = class {
    constructor(i) {
      this.textDiffs = i
    }
  },
  DO
;(function (i) {
  ;(i[(i.Down = 0)] = "Down"), (i[(i.Up = 1)] = "Up")
})(DO || (DO = {}))
var FO
;(function (i) {
  ;(i[(i.Action = 1)] = "Action"), (i[(i.Toolbar = 2)] = "Toolbar")
})(FO || (FO = {}))
var _O
;(function (i) {
  ;(i[(i.Short = 1)] = "Short"),
    (i[(i.Medium = 2)] = "Medium"),
    (i[(i.Full = 3)] = "Full")
})(_O || (_O = {}))
var Mmt = class {
    constructor(i, t, e) {
      ;(this.id = i), (this.label = t), (this.values = e)
    }
  },
  xa
;(function (i) {
  ;(i[(i.Accepted = 1)] = "Accepted"),
    (i[(i.Rejected = 2)] = "Rejected"),
    (i[(i.Saved = 3)] = "Saved")
})(xa || (xa = {}))
var AO
;(function (i) {
  ;(i[(i.Unhelpful = 0)] = "Unhelpful"),
    (i[(i.Helpful = 1)] = "Helpful"),
    (i[(i.Undone = 2)] = "Undone"),
    (i[(i.Accepted = 3)] = "Accepted"),
    (i[(i.Bug = 4)] = "Bug")
})(AO || (AO = {}))
var Al
;(function (i) {
  ;(i[(i.Unhelpful = 0)] = "Unhelpful"), (i[(i.Helpful = 1)] = "Helpful")
})(Al || (Al = {}))
var V6 = class {
    constructor(i) {
      if (typeof i != "string" && i.isTrusted === !0)
        throw new Error(
          "The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.",
        )
      this.value = typeof i == "string" ? new Gi(i) : i
    }
  },
  Bl = class {
    constructor(i, t) {
      if (typeof i != "string" && i.isTrusted === !0)
        throw new Error(
          "The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.",
        )
      ;(this.value = typeof i == "string" ? new Gi(i) : i),
        (this.vulnerabilities = t)
    }
  },
  Ol = class {
    constructor(i, t) {
      ;(this.participant = i), (this.command = t)
    }
  },
  G6 = class {
    constructor(i, t, e, r) {
      ;(this.title = i), (this.message = t), (this.data = e), (this.buttons = r)
    }
  },
  z6 = class {
    constructor(i, t) {
      ;(this.value = i), (this.baseUri = t)
    }
  },
  ql = class {
    constructor(i, t) {
      ;(this.value = i), (this.value2 = i), (this.title = t)
    }
  },
  Ul = class {
    constructor(i) {
      this.value = i
    }
  },
  Y6 = class {
    constructor(i, t) {
      ;(this.value = i), (this.task = t)
    }
  },
  Ml = class {
    constructor(i) {
      if (typeof i != "string" && i.isTrusted === !0)
        throw new Error(
          "The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.",
        )
      this.value = typeof i == "string" ? new Gi(i) : i
    }
  },
  Q6 = class {
    constructor(i) {
      this.value = i
    }
  },
  xn = class {
    constructor(i, t, e) {
      ;(this.value = i), (this.iconPath = t), (this.options = e)
    }
  },
  X6 = class {
    constructor(i) {
      this.value = i
    }
  },
  K6 = class {
    constructor(i, t, e) {
      ;(this.value = i), (this.license = t), (this.snippet = e)
    }
  },
  Z6 = class {
    constructor(i, t) {
      ;(this.uri = i), (this.range = t)
    }
  },
  Hl = class {
    constructor(i, t) {
      ;(this.uri = i),
        t === !0
          ? ((this.isDone = !0), (this.edits = []))
          : (this.edits = Array.isArray(t) ? t : [t])
    }
  },
  gY = class {
    constructor(i, t, e, r, s) {
      ;(this.prompt = i),
        (this.command = t),
        (this.references = e),
        (this.participant = r),
        (this.toolReferences = s)
    }
  },
  vY = class {
    constructor(i, t, e, r) {
      ;(this.response = i),
        (this.result = t),
        (this.participant = e),
        (this.command = r)
    }
  },
  ir
;(function (i) {
  ;(i[(i.Panel = 1)] = "Panel"),
    (i[(i.Terminal = 2)] = "Terminal"),
    (i[(i.Notebook = 3)] = "Notebook"),
    (i[(i.Editor = 4)] = "Editor"),
    (i[(i.EditingSession = 5)] = "EditingSession")
})(ir || (ir = {}))
var BO
;(function (i) {
  ;(i[(i.Complete = 1)] = "Complete"),
    (i[(i.Partial = 2)] = "Partial"),
    (i[(i.Omitted = 3)] = "Omitted")
})(BO || (BO = {}))
var wY = class {
    constructor(i, t, e) {
      ;(this.document = i), (this.selection = t), (this.wholeRange = e)
    }
  },
  yY = class {
    constructor(i) {
      this.cell = i
    }
  },
  TY = class {
    constructor(i, t) {
      ;(this.mimeType = i), (this.data = t)
    }
  },
  dr
;(function (i) {
  ;(i[(i.User = 1)] = "User"),
    (i[(i.Assistant = 2)] = "Assistant"),
    (i[(i.System = 3)] = "System")
})(dr || (dr = {}))
var OO = class {
    constructor(i, t, e) {
      ;(this.callId = i), (this.content = t), (this.isError = e ?? !1)
    }
  },
  kY = class wH {
    static User(t, e) {
      return new wH(dr.User, t, e)
    }
    static Assistant(t, e) {
      return new wH(dr.Assistant, t, e)
    }
    set content(t) {
      typeof t == "string" ? (this.c = [new Li(t)]) : (this.c = t)
    }
    get content() {
      return this.c
    }
    set content2(t) {
      t && (this.content = t.map((e) => (typeof e == "string" ? new Li(e) : e)))
    }
    get content2() {
      return this.content.map((t) => (t instanceof Li ? t.value : t))
    }
    constructor(t, e, r) {
      ;(this.c = []), (this.role = t), (this.content = e), (this.name = r)
    }
  },
  Wl = class {
    constructor(i, t, e) {
      ;(this.callId = i), (this.name = t), (this.input = e)
    }
  },
  Li = class {
    constructor(i) {
      this.value = i
    }
    toJSON() {
      return { $mid: 21, value: this.value }
    }
  },
  tc = class {
    constructor(i) {
      this.value = i
    }
    toJSON() {
      return { $mid: 22, value: this.value }
    }
  },
  Jn = class Ka extends Error {
    static NotFound(t) {
      return new Ka(t, Ka.NotFound.name)
    }
    static NoPermissions(t) {
      return new Ka(t, Ka.NoPermissions.name)
    }
    static Blocked(t) {
      return new Ka(t, Ka.Blocked.name)
    }
    constructor(t, e, r) {
      super(t, { cause: r }),
        (this.name = "LanguageModelError"),
        (this.code = e ?? "")
    }
  },
  qO = class {
    constructor(i) {
      this.content = i
    }
    toJSON() {
      return { $mid: 20, content: this.content }
    }
  },
  UO
;(function (i) {
  ;(i[(i.Auto = 1)] = "Auto"), (i[(i.Required = 2)] = "Required")
})(UO || (UO = {}))
var MO
;(function (i) {
  ;(i[(i.SymbolInformation = 1)] = "SymbolInformation"),
    (i[(i.CommandInformation = 2)] = "CommandInformation"),
    (i[(i.SearchInformation = 3)] = "SearchInformation"),
    (i[(i.SettingInformation = 4)] = "SettingInformation")
})(MO || (MO = {}))
var HO
;(function (i) {
  ;(i[(i.Started = 1)] = "Started"),
    (i[(i.Recognizing = 2)] = "Recognizing"),
    (i[(i.Recognized = 3)] = "Recognized"),
    (i[(i.Stopped = 4)] = "Stopped"),
    (i[(i.Error = 5)] = "Error")
})(HO || (HO = {}))
var WO
;(function (i) {
  ;(i[(i.Started = 1)] = "Started"),
    (i[(i.Stopped = 2)] = "Stopped"),
    (i[(i.Error = 3)] = "Error")
})(WO || (WO = {}))
var jO
;(function (i) {
  ;(i[(i.Recognized = 1)] = "Recognized"), (i[(i.Stopped = 2)] = "Stopped")
})(jO || (jO = {}))
var Hmt = class {
    constructor(i, t) {
      ;(this.text = i), (this.range = t)
    }
  },
  jl
;(function (i) {
  ;(i[(i.Invoke = 0)] = "Invoke"), (i[(i.Automatic = 1)] = "Automatic")
})(jl || (jl = {}))
var Cr
;(function (i) {
  function t(r) {
    const {
        selectionStartLineNumber: s,
        selectionStartColumn: a,
        positionLineNumber: o,
        positionColumn: c,
      } = r,
      u = new Lt(s - 1, a - 1),
      l = new Lt(o - 1, c - 1)
    return new Pn(u, l)
  }
  i.to = t
  function e(r) {
    const { anchor: s, active: a } = r
    return {
      selectionStartLineNumber: s.line + 1,
      selectionStartColumn: s.character + 1,
      positionLineNumber: a.line + 1,
      positionColumn: a.character + 1,
    }
  }
  i.from = e
})(Cr || (Cr = {}))
var O
;(function (i) {
  function t(r) {
    if (!r) return
    const { start: s, end: a } = r
    return {
      startLineNumber: s.line + 1,
      startColumn: s.character + 1,
      endLineNumber: a.line + 1,
      endColumn: a.character + 1,
    }
  }
  i.from = t
  function e(r) {
    if (!r) return
    const {
      startLineNumber: s,
      startColumn: a,
      endLineNumber: o,
      endColumn: c,
    } = r
    return new Nt(s - 1, a - 1, o - 1, c - 1)
  }
  i.to = e
})(O || (O = {}))
var ys
;(function (i) {
  function t(r) {
    return { uri: r.uri, range: O.from(r.range) }
  }
  i.from = t
  function e(r) {
    return new er(S.revive(r.uri), O.to(r.range))
  }
  i.to = e
})(ys || (ys = {}))
var VO
;(function (i) {
  function t(e) {
    switch (e) {
      case 1:
        return ws.Comment
      case 0:
        return ws.Other
      case 3:
        return ws.RegEx
      case 2:
        return ws.String
    }
  }
  i.to = t
})(VO || (VO = {}))
var Gt
;(function (i) {
  function t(r) {
    return new Lt(r.lineNumber - 1, r.column - 1)
  }
  i.to = t
  function e(r) {
    return { lineNumber: r.line + 1, column: r.character + 1 }
  }
  i.from = e
})(Gt || (Gt = {}))
var ec
;(function (i) {
  function t(s, a, o) {
    return Ge(Yr(s).map((c) => e(c, a, o)))
  }
  i.from = t
  function e(s, a, o) {
    if (typeof s == "string")
      return { $serialized: !0, language: s, isBuiltin: o?.isBuiltin }
    if (s)
      return {
        $serialized: !0,
        language: s.language,
        scheme: r(s.scheme, a),
        pattern: zi.from(s.pattern) ?? void 0,
        exclusive: s.exclusive,
        notebookType: s.notebookType,
        isBuiltin: o?.isBuiltin,
      }
  }
  function r(s, a) {
    return a && typeof s == "string" ? a.transformOutgoingScheme(s) : s
  }
})(ec || (ec = {}))
var tA
;(function (i) {
  function t(r) {
    switch (r) {
      case ya.Unnecessary:
        return 1
      case ya.Deprecated:
        return 2
    }
  }
  i.from = t
  function e(r) {
    switch (r) {
      case 1:
        return ya.Unnecessary
      case 2:
        return ya.Deprecated
      default:
        return
    }
  }
  i.to = e
})(tA || (tA = {}))
var ic
;(function (i) {
  function t(r) {
    let s
    return (
      r.code &&
        (Bt(r.code) || os(r.code)
          ? (s = String(r.code))
          : (s = { value: String(r.code.value), target: r.code.target })),
      {
        ...O.from(r.range),
        message: r.message,
        source: r.source,
        code: s,
        severity: iA.from(r.severity),
        relatedInformation:
          r.relatedInformation && r.relatedInformation.map(eA.from),
        tags: Array.isArray(r.tags) ? Ge(r.tags.map(tA.from)) : void 0,
      }
    )
  }
  i.from = t
  function e(r) {
    const s = new s6(O.to(r), r.message, iA.to(r.severity))
    return (
      (s.source = r.source),
      (s.code = Bt(r.code) ? r.code : r.code?.value),
      (s.relatedInformation =
        r.relatedInformation && r.relatedInformation.map(eA.to)),
      (s.tags = r.tags && Ge(r.tags.map(tA.to))),
      s
    )
  }
  i.to = e
})(ic || (ic = {}))
var eA
;(function (i) {
  function t(r) {
    return {
      ...O.from(r.location.range),
      message: r.message,
      resource: r.location.uri,
    }
  }
  i.from = t
  function e(r) {
    return new ml(new er(r.resource, O.to(r)), r.message)
  }
  i.to = e
})(eA || (eA = {}))
var iA
;(function (i) {
  function t(r) {
    switch (r) {
      case di.Error:
        return xi.Error
      case di.Warning:
        return xi.Warning
      case di.Information:
        return xi.Info
      case di.Hint:
        return xi.Hint
    }
    return xi.Error
  }
  i.from = t
  function e(r) {
    switch (r) {
      case xi.Info:
        return di.Information
      case xi.Warning:
        return di.Warning
      case xi.Error:
        return di.Error
      case xi.Hint:
        return di.Hint
      default:
        return di.Error
    }
  }
  i.to = e
})(iA || (iA = {}))
var Me
;(function (i) {
  function t(r) {
    return typeof r == "number" && r >= Tl.One
      ? r - 1
      : r === Tl.Beside
        ? cmt
        : omt
  }
  i.from = t
  function e(r) {
    if (typeof r == "number" && r >= 0) return r + 1
    throw new Error("invalid 'EditorGroupColumn'")
  }
  i.to = e
})(Me || (Me = {}))
function Wmt(i) {
  return typeof i.range < "u"
}
function SY(i) {
  return i.length === 0 ? !0 : !!Wmt(i[0])
}
var Jt
;(function (i) {
  function t(c) {
    return c.map(i.from)
  }
  i.fromMany = t
  function e(c) {
    return (
      c &&
      typeof c == "object" &&
      typeof c.language == "string" &&
      typeof c.value == "string"
    )
  }
  function r(c) {
    let u
    if (e(c)) {
      const { language: h, value: p } = c
      u = {
        value:
          "```" +
          h +
          `
` +
          p +
          "\n```\n",
      }
    } else
      Gi.isMarkdownString(c)
        ? (u = {
            value: c.value,
            isTrusted: c.isTrusted,
            supportThemeIcons: c.supportThemeIcons,
            supportHtml: c.supportHtml,
            baseUri: c.baseUri,
          })
        : typeof c == "string"
          ? (u = { value: c })
          : (u = { value: "" })
    const l = Object.create(null)
    u.uris = l
    const m = ({ href: h }) => {
      try {
        let p = S.parse(h, !0)
        ;(p = p.with({ query: s(p.query, l) })), (l[h] = p)
      } catch {}
      return ""
    }
    return (
      oe.walkTokens(oe.lexer(u.value), (h) => {
        h.type === "link"
          ? m({ href: h.href })
          : h.type === "image" && typeof h.href == "string" && m(Lut(h.href))
      }),
      u
    )
  }
  i.from = r
  function s(c, u) {
    if (!c) return c
    let l
    try {
      l = $V(c)
    } catch {}
    if (!l) return c
    let m = !1
    return (
      (l = yo(l, (h) => {
        if (S.isUri(h)) {
          const p = `__uri_${Math.random().toString(16).slice(2, 8)}`
          return (u[p] = h), (m = !0), p
        } else return
      })),
      m ? JSON.stringify(l) : c
    )
  }
  function a(c) {
    const u = new Gi(c.value, c.supportThemeIcons)
    return (
      (u.isTrusted = c.isTrusted),
      (u.supportHtml = c.supportHtml),
      (u.baseUri = c.baseUri ? S.from(c.baseUri) : void 0),
      u
    )
  }
  i.to = a
  function o(c) {
    if (c) return typeof c == "string" ? c : i.from(c)
  }
  i.fromStrict = o
})(Jt || (Jt = {}))
function jmt(i) {
  return SY(i)
    ? i.map((t) => ({
        range: O.from(t.range),
        hoverMessage: Array.isArray(t.hoverMessage)
          ? Jt.fromMany(t.hoverMessage)
          : t.hoverMessage
            ? Jt.from(t.hoverMessage)
            : void 0,
        renderOptions: t.renderOptions,
      }))
    : i.map((t) => ({ range: O.from(t) }))
}
function rA(i) {
  return typeof i > "u" ? i : typeof i == "string" ? S.file(i) : i
}
var rc
;(function (i) {
  function t(e) {
    return typeof e > "u"
      ? e
      : {
          contentText: e.contentText,
          contentIconPath: e.contentIconPath ? rA(e.contentIconPath) : void 0,
          border: e.border,
          borderColor: e.borderColor,
          fontStyle: e.fontStyle,
          fontWeight: e.fontWeight,
          textDecoration: e.textDecoration,
          color: e.color,
          backgroundColor: e.backgroundColor,
          margin: e.margin,
          width: e.width,
          height: e.height,
        }
  }
  i.from = t
})(rc || (rc = {}))
var nA
;(function (i) {
  function t(e) {
    return typeof e > "u"
      ? e
      : {
          backgroundColor: e.backgroundColor,
          outline: e.outline,
          outlineColor: e.outlineColor,
          outlineStyle: e.outlineStyle,
          outlineWidth: e.outlineWidth,
          border: e.border,
          borderColor: e.borderColor,
          borderRadius: e.borderRadius,
          borderSpacing: e.borderSpacing,
          borderStyle: e.borderStyle,
          borderWidth: e.borderWidth,
          fontStyle: e.fontStyle,
          fontWeight: e.fontWeight,
          textDecoration: e.textDecoration,
          cursor: e.cursor,
          color: e.color,
          opacity: e.opacity,
          letterSpacing: e.letterSpacing,
          gutterIconPath: e.gutterIconPath ? rA(e.gutterIconPath) : void 0,
          gutterIconSize: e.gutterIconSize,
          overviewRulerColor: e.overviewRulerColor,
          before: e.before ? rc.from(e.before) : void 0,
          after: e.after ? rc.from(e.after) : void 0,
        }
  }
  i.from = t
})(nA || (nA = {}))
var GO
;(function (i) {
  function t(e) {
    if (typeof e > "u") return e
    switch (e) {
      case ka.OpenOpen:
        return 0
      case ka.ClosedClosed:
        return 1
      case ka.OpenClosed:
        return 2
      case ka.ClosedOpen:
        return 3
    }
  }
  i.from = t
})(GO || (GO = {}))
var zO
;(function (i) {
  function t(e) {
    return {
      isWholeLine: e.isWholeLine,
      rangeBehavior: e.rangeBehavior ? GO.from(e.rangeBehavior) : void 0,
      overviewRulerLane: e.overviewRulerLane,
      light: e.light ? nA.from(e.light) : void 0,
      dark: e.dark ? nA.from(e.dark) : void 0,
      backgroundColor: e.backgroundColor,
      outline: e.outline,
      outlineColor: e.outlineColor,
      outlineStyle: e.outlineStyle,
      outlineWidth: e.outlineWidth,
      border: e.border,
      borderColor: e.borderColor,
      borderRadius: e.borderRadius,
      borderSpacing: e.borderSpacing,
      borderStyle: e.borderStyle,
      borderWidth: e.borderWidth,
      fontStyle: e.fontStyle,
      fontWeight: e.fontWeight,
      textDecoration: e.textDecoration,
      cursor: e.cursor,
      color: e.color,
      opacity: e.opacity,
      letterSpacing: e.letterSpacing,
      gutterIconPath: e.gutterIconPath ? rA(e.gutterIconPath) : void 0,
      gutterIconSize: e.gutterIconSize,
      overviewRulerColor: e.overviewRulerColor,
      before: e.before ? rc.from(e.before) : void 0,
      after: e.after ? rc.from(e.after) : void 0,
    }
  }
  i.from = t
})(zO || (zO = {}))
var He
;(function (i) {
  function t(r) {
    return {
      text: r.newText,
      eol: r.newEol && oc.from(r.newEol),
      range: O.from(r.range),
    }
  }
  i.from = t
  function e(r) {
    const s = new fs(O.to(r.range), r.text)
    return (s.newEol = typeof r.eol > "u" ? void 0 : oc.to(r.eol)), s
  }
  i.to = e
})(He || (He = {}))
var bi
;(function (i) {
  function t(r, s) {
    const a = { edits: [] }
    if (r instanceof va) {
      const o = new AH()
      for (const c of r._allEntries())
        c._type === 1 && S.isUri(c.to) && c.from === void 0 && o.add(c.to)
      for (const c of r._allEntries())
        if (c._type === 1) {
          let u
          c.options?.contents &&
            (ArrayBuffer.isView(c.options.contents)
              ? (u = { type: "base64", value: VF(Et.wrap(c.options.contents)) })
              : (u = {
                  type: "dataTransferItem",
                  id: c.options.contents._itemId,
                })),
            a.edits.push({
              oldResource: c.from,
              newResource: c.to,
              options: { ...c.options, contents: u },
              metadata: c.metadata,
            })
        } else
          c._type === 2
            ? a.edits.push({
                resource: c.uri,
                textEdit: He.from(c.edit),
                versionId: o.has(c.uri)
                  ? void 0
                  : s?.getTextDocumentVersion(c.uri),
                metadata: c.metadata,
              })
            : c._type === 6
              ? a.edits.push({
                  resource: c.uri,
                  textEdit: {
                    range: O.from(c.range),
                    text: c.edit.value,
                    insertAsSnippet: !0,
                  },
                  versionId: o.has(c.uri)
                    ? void 0
                    : s?.getTextDocumentVersion(c.uri),
                  metadata: c.metadata,
                })
              : c._type === 3
                ? a.edits.push({
                    metadata: c.metadata,
                    resource: c.uri,
                    cellEdit: c.edit,
                    notebookVersionId: s?.getNotebookDocumentVersion(c.uri),
                  })
                : c._type === 5 &&
                  a.edits.push({
                    metadata: c.metadata,
                    resource: c.uri,
                    notebookVersionId: s?.getNotebookDocumentVersion(c.uri),
                    cellEdit: {
                      editType: 1,
                      index: c.index,
                      count: c.count,
                      cells: c.cells.map(Xl.from),
                    },
                  })
    }
    return a
  }
  i.from = t
  function e(r) {
    const s = new va(),
      a = new ei()
    for (const o of r.edits)
      if (o.textEdit) {
        const c = o,
          u = S.revive(c.resource),
          l = O.to(c.textEdit.range),
          m = c.textEdit.text,
          h = c.textEdit.insertAsSnippet
        let p
        h ? (p = z3.replace(l, new wa(m))) : (p = fs.replace(l, m))
        const g = a.get(u)
        g ? g.push(p) : a.set(u, [p])
      } else
        s.renameFile(
          S.revive(o.oldResource),
          S.revive(o.newResource),
          o.options,
        )
    for (const [o, c] of a) s.set(o, c)
    return s
  }
  i.to = e
})(bi || (bi = {}))
var mr
;(function (i) {
  const t = Object.create(null)
  ;(t[ae.File] = 0),
    (t[ae.Module] = 1),
    (t[ae.Namespace] = 2),
    (t[ae.Package] = 3),
    (t[ae.Class] = 4),
    (t[ae.Method] = 5),
    (t[ae.Property] = 6),
    (t[ae.Field] = 7),
    (t[ae.Constructor] = 8),
    (t[ae.Enum] = 9),
    (t[ae.Interface] = 10),
    (t[ae.Function] = 11),
    (t[ae.Variable] = 12),
    (t[ae.Constant] = 13),
    (t[ae.String] = 14),
    (t[ae.Number] = 15),
    (t[ae.Boolean] = 16),
    (t[ae.Array] = 17),
    (t[ae.Object] = 18),
    (t[ae.Key] = 19),
    (t[ae.Null] = 20),
    (t[ae.EnumMember] = 21),
    (t[ae.Struct] = 22),
    (t[ae.Event] = 23),
    (t[ae.Operator] = 24),
    (t[ae.TypeParameter] = 25)
  function e(s) {
    return typeof t[s] == "number" ? t[s] : 6
  }
  i.from = e
  function r(s) {
    for (const a in t) if (t[a] === s) return Number(a)
    return ae.Property
  }
  i.to = r
})(mr || (mr = {}))
var Cn
;(function (i) {
  function t(r) {
    switch (r) {
      case fl.Deprecated:
        return 1
    }
  }
  i.from = t
  function e(r) {
    switch (r) {
      case 1:
        return fl.Deprecated
    }
  }
  i.to = e
})(Cn || (Cn = {}))
var Ja
;(function (i) {
  function t(r) {
    return {
      name: r.name,
      kind: mr.from(r.kind),
      tags: r.tags && r.tags.map(Cn.from),
      containerName: r.containerName,
      location: Ri.from(r.location),
    }
  }
  i.from = t
  function e(r) {
    const s = new pl(r.name, mr.to(r.kind), r.containerName, Ri.to(r.location))
    return (s.tags = r.tags && r.tags.map(Cn.to)), s
  }
  i.to = e
})(Ja || (Ja = {}))
var YO
;(function (i) {
  function t(r) {
    const s = {
      name: r.name || "!!MISSING: name!!",
      detail: r.detail,
      range: O.from(r.range),
      selectionRange: O.from(r.selectionRange),
      kind: mr.from(r.kind),
      tags: r.tags?.map(Cn.from) ?? [],
    }
    return r.children && (s.children = r.children.map(t)), s
  }
  i.from = t
  function e(r) {
    const s = new gl(
      r.name,
      r.detail,
      mr.to(r.kind),
      O.to(r.range),
      O.to(r.selectionRange),
    )
    return (
      Su(r.tags) && (s.tags = r.tags.map(Cn.to)),
      r.children && (s.children = r.children.map(e)),
      s
    )
  }
  i.to = e
})(YO || (YO = {}))
var Ca
;(function (i) {
  function t(r) {
    const s = new Q3(
      mr.to(r.kind),
      r.name,
      r.detail || "",
      S.revive(r.uri),
      O.to(r.range),
      O.to(r.selectionRange),
    )
    return (s._sessionId = r._sessionId), (s._itemId = r._itemId), s
  }
  i.to = t
  function e(r, s, a) {
    if (
      ((s = s ?? r._sessionId),
      (a = a ?? r._itemId),
      s === void 0 || a === void 0)
    )
      throw new Error("invalid item")
    return {
      _sessionId: s,
      _itemId: a,
      name: r.name,
      detail: r.detail,
      kind: mr.from(r.kind),
      uri: r.uri,
      range: O.from(r.range),
      selectionRange: O.from(r.selectionRange),
      tags: r.tags?.map(Cn.from),
    }
  }
  i.from = e
})(Ca || (Ca = {}))
var QO
;(function (i) {
  function t(e) {
    return new Yz(
      Ca.to(e.from),
      e.fromRanges.map((r) => O.to(r)),
    )
  }
  i.to = t
})(QO || (QO = {}))
var XO
;(function (i) {
  function t(e) {
    return new Qz(
      Ca.to(e.to),
      e.fromRanges.map((r) => O.to(r)),
    )
  }
  i.to = t
})(XO || (XO = {}))
var Ri
;(function (i) {
  function t(r) {
    return { range: r.range && O.from(r.range), uri: r.uri }
  }
  i.from = t
  function e(r) {
    return new er(S.revive(r.uri), O.to(r.range))
  }
  i.to = e
})(Ri || (Ri = {}))
var Vl
;(function (i) {
  function t(r) {
    const s = r,
      a = r
    return {
      originSelectionRange: s.originSelectionRange
        ? O.from(s.originSelectionRange)
        : void 0,
      uri: s.targetUri ? s.targetUri : a.uri,
      range: O.from(s.targetRange ? s.targetRange : a.range),
      targetSelectionRange: s.targetSelectionRange
        ? O.from(s.targetSelectionRange)
        : void 0,
    }
  }
  i.from = t
  function e(r) {
    return {
      targetUri: S.revive(r.uri),
      targetRange: O.to(r.range),
      targetSelectionRange: r.targetSelectionRange
        ? O.to(r.targetSelectionRange)
        : void 0,
      originSelectionRange: r.originSelectionRange
        ? O.to(r.originSelectionRange)
        : void 0,
    }
  }
  i.to = e
})(Vl || (Vl = {}))
var Gl
;(function (i) {
  function t(r) {
    return {
      range: O.from(r.range),
      contents: Jt.fromMany(r.contents),
      canIncreaseVerbosity: r.canIncreaseVerbosity,
      canDecreaseVerbosity: r.canDecreaseVerbosity,
    }
  }
  i.from = t
  function e(r) {
    const s = r.contents.map(Jt.to),
      a = O.to(r.range),
      o = r.canIncreaseVerbosity,
      c = r.canDecreaseVerbosity
    return new o6(s, a, o, c)
  }
  i.to = e
})(Gl || (Gl = {}))
var KO
;(function (i) {
  function t(r) {
    return { range: O.from(r.range), expression: r.expression }
  }
  i.from = t
  function e(r) {
    return new N6(O.to(r.range), r.expression)
  }
  i.to = e
})(KO || (KO = {}))
var sA
;(function (i) {
  function t(r) {
    if (r instanceof $6)
      return { type: "text", range: O.from(r.range), text: r.text }
    if (r instanceof x6)
      return {
        type: "variable",
        range: O.from(r.range),
        variableName: r.variableName,
        caseSensitiveLookup: r.caseSensitiveLookup,
      }
    if (r instanceof J6)
      return {
        type: "expression",
        range: O.from(r.range),
        expression: r.expression,
      }
    throw new Error("Unknown 'InlineValue' type")
  }
  i.from = t
  function e(r) {
    switch (r.type) {
      case "text":
        return { range: O.to(r.range), text: r.text }
      case "variable":
        return {
          range: O.to(r.range),
          variableName: r.variableName,
          caseSensitiveLookup: r.caseSensitiveLookup,
        }
      case "expression":
        return { range: O.to(r.range), expression: r.expression }
    }
  }
  i.to = e
})(sA || (sA = {}))
var aA
;(function (i) {
  function t(r) {
    return { frameId: r.frameId, stoppedLocation: O.from(r.stoppedLocation) }
  }
  i.from = t
  function e(r) {
    return new pO(r.frameId, O.to(r.stoppedLocation))
  }
  i.to = e
})(aA || (aA = {}))
var nc
;(function (i) {
  function t(r) {
    return { range: O.from(r.range), kind: r.kind }
  }
  i.from = t
  function e(r) {
    return new c6(O.to(r.range), r.kind)
  }
  i.to = e
})(nc || (nc = {}))
var ZO
;(function (i) {
  function t(r) {
    return { uri: r.uri, highlights: r.highlights.map(nc.from) }
  }
  i.from = t
  function e(r) {
    return new u6(S.revive(r.uri), r.highlights.map(nc.to))
  }
  i.to = e
})(ZO || (ZO = {}))
var tq
;(function (i) {
  function t(e) {
    switch (e) {
      case 1:
        return _o.TriggerCharacter
      case 2:
        return _o.TriggerForIncompleteCompletions
      case 0:
      default:
        return _o.Invoke
    }
  }
  i.to = t
})(tq || (tq = {}))
var eq
;(function (i) {
  function t(e) {
    return {
      triggerKind: tq.to(e.triggerKind),
      triggerCharacter: e.triggerCharacter,
    }
  }
  i.to = t
})(eq || (eq = {}))
var oA
;(function (i) {
  function t(r) {
    switch (r) {
      case yl.Deprecated:
        return 1
    }
  }
  i.from = t
  function e(r) {
    switch (r) {
      case 1:
        return yl.Deprecated
    }
  }
  i.to = e
})(oA || (oA = {}))
var cA
;(function (i) {
  const t = new Map([
    [mt.Method, 0],
    [mt.Function, 1],
    [mt.Constructor, 2],
    [mt.Field, 3],
    [mt.Variable, 4],
    [mt.Class, 5],
    [mt.Interface, 7],
    [mt.Struct, 6],
    [mt.Module, 8],
    [mt.Property, 9],
    [mt.Unit, 12],
    [mt.Value, 13],
    [mt.Constant, 14],
    [mt.Enum, 15],
    [mt.EnumMember, 16],
    [mt.Keyword, 17],
    [mt.Snippet, 27],
    [mt.Text, 18],
    [mt.Color, 19],
    [mt.File, 20],
    [mt.Reference, 21],
    [mt.Folder, 23],
    [mt.Event, 10],
    [mt.Operator, 11],
    [mt.TypeParameter, 24],
    [mt.Issue, 26],
    [mt.User, 25],
  ])
  function e(a) {
    return t.get(a) ?? 9
  }
  i.from = e
  const r = new Map([
    [0, mt.Method],
    [1, mt.Function],
    [2, mt.Constructor],
    [3, mt.Field],
    [4, mt.Variable],
    [5, mt.Class],
    [7, mt.Interface],
    [6, mt.Struct],
    [8, mt.Module],
    [9, mt.Property],
    [12, mt.Unit],
    [13, mt.Value],
    [14, mt.Constant],
    [15, mt.Enum],
    [16, mt.EnumMember],
    [17, mt.Keyword],
    [27, mt.Snippet],
    [18, mt.Text],
    [19, mt.Color],
    [20, mt.File],
    [21, mt.Reference],
    [23, mt.Folder],
    [10, mt.Event],
    [11, mt.Operator],
    [24, mt.TypeParameter],
    [25, mt.User],
    [26, mt.Issue],
  ])
  function s(a) {
    return r.get(a) ?? mt.Property
  }
  i.to = s
})(cA || (cA = {}))
var iq
;(function (i) {
  function t(e, r) {
    const s = new f6(e.label)
    return (
      (s.insertText = e.insertText),
      (s.kind = cA.to(e.kind)),
      (s.tags = e.tags?.map(oA.to)),
      (s.detail = e.detail),
      (s.documentation = na(e.documentation)
        ? Jt.to(e.documentation)
        : e.documentation),
      (s.sortText = e.sortText),
      (s.filterText = e.filterText),
      (s.preselect = e.preselect),
      (s.commitCharacters = e.commitCharacters),
      re.isIRange(e.range)
        ? (s.range = O.to(e.range))
        : typeof e.range == "object" &&
          (s.range = {
            inserting: O.to(e.range.insert),
            replacing: O.to(e.range.replace),
          }),
      (s.keepWhitespace =
        typeof e.insertTextRules > "u" ? !1 : !!(e.insertTextRules & 1)),
      typeof e.insertTextRules < "u" && e.insertTextRules & 4
        ? (s.insertText = new wa(e.insertText))
        : ((s.insertText = e.insertText),
          (s.textEdit =
            s.range instanceof Nt ? new fs(s.range, s.insertText) : void 0)),
      e.additionalTextEdits &&
        e.additionalTextEdits.length > 0 &&
        (s.additionalTextEdits = e.additionalTextEdits.map((a) => He.to(a))),
      (s.command = r && e.command ? r.fromInternal(e.command) : void 0),
      s
    )
  }
  i.to = t
})(iq || (iq = {}))
var uA
;(function (i) {
  function t(r) {
    if (typeof r.label != "string" && !Array.isArray(r.label))
      throw new TypeError("Invalid label")
    return { label: r.label, documentation: Jt.fromStrict(r.documentation) }
  }
  i.from = t
  function e(r) {
    return {
      label: r.label,
      documentation: na(r.documentation)
        ? Jt.to(r.documentation)
        : r.documentation,
    }
  }
  i.to = e
})(uA || (uA = {}))
var lA
;(function (i) {
  function t(r) {
    return {
      label: r.label,
      documentation: Jt.fromStrict(r.documentation),
      parameters: Array.isArray(r.parameters) ? r.parameters.map(uA.from) : [],
      activeParameter: r.activeParameter,
    }
  }
  i.from = t
  function e(r) {
    return {
      label: r.label,
      documentation: na(r.documentation)
        ? Jt.to(r.documentation)
        : r.documentation,
      parameters: Array.isArray(r.parameters) ? r.parameters.map(uA.to) : [],
      activeParameter: r.activeParameter,
    }
  }
  i.to = e
})(lA || (lA = {}))
var zl
;(function (i) {
  function t(r) {
    return {
      activeSignature: r.activeSignature,
      activeParameter: r.activeParameter,
      signatures: Array.isArray(r.signatures) ? r.signatures.map(lA.from) : [],
    }
  }
  i.from = t
  function e(r) {
    return {
      activeSignature: r.activeSignature,
      activeParameter: r.activeParameter,
      signatures: Array.isArray(r.signatures) ? r.signatures.map(lA.to) : [],
    }
  }
  i.to = e
})(zl || (zl = {}))
var rq
;(function (i) {
  function t(e, r) {
    const s = new h6(
      Gt.to(r.position),
      typeof r.label == "string" ? r.label : r.label.map(nq.to.bind(void 0, e)),
      r.kind && dA.to(r.kind),
    )
    return (
      (s.textEdits = r.textEdits && r.textEdits.map(He.to)),
      (s.tooltip = na(r.tooltip) ? Jt.to(r.tooltip) : r.tooltip),
      (s.paddingLeft = r.paddingLeft),
      (s.paddingRight = r.paddingRight),
      s
    )
  }
  i.to = t
})(rq || (rq = {}))
var nq
;(function (i) {
  function t(e, r) {
    const s = new m6(r.label)
    return (
      (s.tooltip = na(r.tooltip) ? Jt.to(r.tooltip) : r.tooltip),
      v3.is(r.command) && (s.command = e.fromInternal(r.command)),
      r.location && (s.location = Ri.to(r.location)),
      s
    )
  }
  i.to = t
})(nq || (nq = {}))
var dA
;(function (i) {
  function t(r) {
    return r
  }
  i.from = t
  function e(r) {
    return r
  }
  i.to = e
})(dA || (dA = {}))
var La
;(function (i) {
  function t(r) {
    return { range: O.from(r.range), url: r.target, tooltip: r.tooltip }
  }
  i.from = t
  function e(r) {
    let s
    if (r.url)
      try {
        s = typeof r.url == "string" ? S.parse(r.url, !0) : S.revive(r.url)
      } catch {}
    const a = new g6(O.to(r.range), s)
    return (a.tooltip = r.tooltip), a
  }
  i.to = e
})(La || (La = {}))
var mA
;(function (i) {
  function t(r) {
    const s = new w6(r.label)
    return (
      r.textEdit && (s.textEdit = He.to(r.textEdit)),
      r.additionalTextEdits &&
        (s.additionalTextEdits = r.additionalTextEdits.map((a) => He.to(a))),
      s
    )
  }
  i.to = t
  function e(r) {
    return {
      label: r.label,
      textEdit: r.textEdit ? He.from(r.textEdit) : void 0,
      additionalTextEdits: r.additionalTextEdits
        ? r.additionalTextEdits.map((s) => He.from(s))
        : void 0,
    }
  }
  i.from = e
})(mA || (mA = {}))
var sc
;(function (i) {
  function t(r) {
    return new Mo(r[0], r[1], r[2], r[3])
  }
  i.to = t
  function e(r) {
    return [r.red, r.green, r.blue, r.alpha]
  }
  i.from = e
})(sc || (sc = {}))
var sq
;(function (i) {
  function t(r) {
    return { range: O.from(r.range) }
  }
  i.from = t
  function e(r) {
    return new wl(O.to(r.range))
  }
  i.to = e
})(sq || (sq = {}))
var hA
;(function (i) {
  function t(e) {
    switch (e) {
      case 2:
        return Bo.AfterDelay
      case 1:
        return Bo.Manual
      case 3:
      case 4:
        return Bo.FocusOut
    }
  }
  i.to = t
})(hA || (hA = {}))
var ac
;(function (i) {
  function t(r) {
    switch (r) {
      case Jr.Off:
        return 0
      case Jr.Relative:
        return 2
      case Jr.Interval:
        return 3
      case Jr.On:
      default:
        return 1
    }
  }
  i.from = t
  function e(r) {
    switch (r) {
      case 0:
        return Jr.Off
      case 2:
        return Jr.Relative
      case 3:
        return Jr.Interval
      case 1:
      default:
        return Jr.On
    }
  }
  i.to = e
})(ac || (ac = {}))
var oc
;(function (i) {
  function t(r) {
    if (r === xr.CRLF) return 1
    if (r === xr.LF) return 0
  }
  i.from = t
  function e(r) {
    if (r === 1) return xr.CRLF
    if (r === 0) return xr.LF
  }
  i.to = e
})(oc || (oc = {}))
var aq
;(function (i) {
  function t(e) {
    if (typeof e == "object") return e.viewId
    switch (e) {
      case ba.SourceControl:
        return 3
      case ba.Window:
        return 10
      case ba.Notification:
        return 15
    }
    throw new Error("Unknown 'ProgressLocation'")
  }
  i.from = t
})(aq || (aq = {}))
var fA
;(function (i) {
  function t(r) {
    const s = { start: r.start + 1, end: r.end + 1 }
    return r.kind && (s.kind = pA.from(r.kind)), s
  }
  i.from = t
  function e(r) {
    const s = { start: r.start - 1, end: r.end - 1 }
    return r.kind && (s.kind = pA.to(r.kind)), s
  }
  i.to = e
})(fA || (fA = {}))
var pA
;(function (i) {
  function t(r) {
    if (r)
      switch (r) {
        case Nn.Comment:
          return So.Comment
        case Nn.Imports:
          return So.Imports
        case Nn.Region:
          return So.Region
      }
  }
  i.from = t
  function e(r) {
    if (r)
      switch (r.value) {
        case So.Comment.value:
          return Nn.Comment
        case So.Imports.value:
          return Nn.Imports
        case So.Region.value:
          return Nn.Region
      }
  }
  i.to = e
})(pA || (pA = {}))
var Yl
;(function (i) {
  function t(e) {
    if (e)
      return {
        pinned: typeof e.preview == "boolean" ? !e.preview : void 0,
        inactive: e.background,
        preserveFocus: e.preserveFocus,
        selection:
          typeof e.selection == "object" ? O.from(e.selection) : void 0,
        override: typeof e.override == "boolean" ? Ilt.id : void 0,
      }
  }
  i.from = t
})(Yl || (Yl = {}))
var zi
;(function (i) {
  function t(a) {
    return a instanceof Vo
      ? a.toJSON()
      : typeof a == "string"
        ? a
        : e(a) || r(a)
          ? new Vo(a.baseUri ?? a.base, a.pattern).toJSON()
          : a
  }
  i.from = t
  function e(a) {
    const o = a
    return o ? S.isUri(o.baseUri) && typeof o.pattern == "string" : !1
  }
  function r(a) {
    const o = a
    return o ? typeof o.base == "string" && typeof o.pattern == "string" : !1
  }
  function s(a) {
    return typeof a == "string" ? a : new Vo(S.revive(a.baseUri), a.pattern)
  }
  i.to = s
})(zi || (zi = {}))
var oq
;(function (i) {
  function t(e) {
    if (e) {
      if (Array.isArray(e)) return e.map(t)
      if (typeof e == "string") return e
      {
        const r = e
        return {
          language: r.language,
          scheme: r.scheme,
          pattern: zi.from(r.pattern) ?? void 0,
          exclusive: r.exclusive,
          notebookType: r.notebookType,
        }
      }
    } else return
  }
  i.from = t
})(oq || (oq = {}))
var gA
;(function (i) {
  function t(r) {
    return (
      !!r &&
      typeof r == "object" &&
      "documents" in r &&
      Array.isArray(r.documents) &&
      r.documents.every((s) => Array.isArray(s) && s.every(cc.is))
    )
  }
  i.is = t
  function e(r) {
    return {
      documents: r.documents.map((s) => s.map(cc.from)),
      conversation: r.conversation?.map((s) =>
        s.type === "request"
          ? { type: "request", message: s.message }
          : {
              type: "response",
              message: s.message,
              result: s.result ? Es.from(s.result) : void 0,
              references: s.references?.map(cc.from),
            },
      ),
    }
  }
  i.from = e
})(gA || (gA = {}))
var cc
;(function (i) {
  function t(s) {
    return (
      typeof s == "object" &&
      s !== null &&
      "uri" in s &&
      S.isUri(s.uri) &&
      "version" in s &&
      typeof s.version == "number" &&
      "ranges" in s &&
      Array.isArray(s.ranges) &&
      s.ranges.every((a) => a instanceof Nt)
    )
  }
  i.is = t
  function e(s) {
    return {
      uri: s.uri,
      version: s.version,
      ranges: s.ranges.map((a) => O.from(a)),
    }
  }
  i.from = e
  function r(s) {
    return {
      uri: S.revive(s.uri),
      version: s.version,
      ranges: s.ranges.map((a) => O.to(a)),
    }
  }
  i.to = r
})(cc || (cc = {}))
var an
;(function (i) {
  function t(r) {
    return { start: r.start, end: r.end }
  }
  i.from = t
  function e(r) {
    return new $n(r.start, r.end)
  }
  i.to = e
})(an || (an = {}))
var uc
;(function (i) {
  function t(r) {
    return {
      timing:
        typeof r.runStartTime == "number" && typeof r.runEndTime == "number"
          ? { startTime: r.runStartTime, endTime: r.runEndTime }
          : void 0,
      executionOrder: r.executionOrder,
      success: r.lastRunSuccess,
    }
  }
  i.to = t
  function e(r) {
    return {
      lastRunSuccess: r.success,
      runStartTime: r.timing?.startTime,
      runEndTime: r.timing?.endTime,
      executionOrder: r.executionOrder,
    }
  }
  i.from = e
})(uc || (uc = {}))
var cq
;(function (i) {
  function t(e) {
    if (e === ol.Unconfirmed) return Xo.Pending
    if (e === ol.Pending) return
    if (e === ol.Executing) return Xo.Executing
    throw new Error(`Unknown state: ${e}`)
  }
  i.to = t
})(cq || (cq = {}))
var Ql
;(function (i) {
  function t(r) {
    switch (r) {
      case $a.Markup:
        return Co.Markup
      case $a.Code:
      default:
        return Co.Code
    }
  }
  i.from = t
  function e(r) {
    switch (r) {
      case Co.Markup:
        return $a.Markup
      case Co.Code:
      default:
        return $a.Code
    }
  }
  i.to = e
})(Ql || (Ql = {}))
var Ts
;(function (i) {
  function t(r) {
    const s = { metadata: r.metadata ?? Object.create(null), cells: [] }
    for (const a of r.cells) D6.validate(a), s.cells.push(Xl.from(a))
    return s
  }
  i.from = t
  function e(r) {
    const s = new rY(r.cells.map(Xl.to))
    return GW(r.metadata) || (s.metadata = r.metadata), s
  }
  i.to = e
})(Ts || (Ts = {}))
var Xl
;(function (i) {
  function t(r) {
    return {
      cellKind: Ql.from(r.kind),
      language: r.languageId,
      mime: r.mime,
      source: r.value,
      metadata: r.metadata,
      internalMetadata: uc.from(r.executionSummary ?? {}),
      outputs: r.outputs ? r.outputs.map(ks.from) : [],
    }
  }
  i.from = t
  function e(r) {
    return new D6(
      Ql.to(r.cellKind),
      r.source,
      r.language,
      r.mime,
      r.outputs ? r.outputs.map(ks.to) : void 0,
      r.metadata,
      r.internalMetadata ? uc.to(r.internalMetadata) : void 0,
    )
  }
  i.to = e
})(Xl || (Xl = {}))
var lc
;(function (i) {
  function t(r) {
    return { mime: r.mime, valueBytes: Et.wrap(r.data) }
  }
  i.from = t
  function e(r) {
    return new nY(r.valueBytes.buffer, r.mime)
  }
  i.to = e
})(lc || (lc = {}))
var ks
;(function (i) {
  function t(r) {
    return { outputId: r.id, items: r.items.map(lc.from), metadata: r.metadata }
  }
  i.from = t
  function e(r) {
    const s = r.items.map(lc.to)
    return new F6(s, r.outputId, r.metadata)
  }
  i.to = e
})(ks || (ks = {}))
var vA
;(function (i) {
  function t(s) {
    return r(s)
      ? {
          include: zi.from(s.include) ?? void 0,
          exclude: zi.from(s.exclude) ?? void 0,
        }
      : (zi.from(s) ?? void 0)
  }
  i.from = t
  function e(s) {
    return r(s)
      ? { include: zi.to(s.include), exclude: zi.to(s.exclude) }
      : zi.to(s)
  }
  i.to = e
  function r(s) {
    const a = s
    return a ? !Le(a.include) && !Le(a.exclude) : !1
  }
})(vA || (vA = {}))
var uq
;(function (i) {
  function t(e, r, s) {
    const a =
      typeof e.command == "string"
        ? { title: "", command: e.command }
        : e.command
    return {
      alignment: e.alignment === _6.Left ? 1 : 2,
      command: r.toInternal(a, s),
      text: e.text,
      tooltip: e.tooltip,
      accessibilityInformation: e.accessibilityInformation,
      priority: e.priority,
    }
  }
  i.from = t
})(uq || (uq = {}))
var lq
;(function (i) {
  function t(e, r, s) {
    const a =
      typeof e.command == "string"
        ? { title: "", command: e.command }
        : e.command
    return {
      command: r.toInternal(a, s),
      label: e.label,
      description: e.description,
      detail: e.detail,
      documentation: e.documentation,
    }
  }
  i.from = t
})(lq || (lq = {}))
var dq
;(function (i) {
  function t(e) {
    return {
      transientOutputs: e?.transientOutputs ?? !1,
      transientCellMetadata: e?.transientCellMetadata ?? {},
      transientDocumentMetadata: e?.transientDocumentMetadata ?? {},
      cellContentMetadata: e?.cellContentMetadata ?? {},
    }
  }
  i.from = t
})(dq || (dq = {}))
var wA
;(function (i) {
  function t(r) {
    return { uri: r.uri, provides: r.provides }
  }
  i.from = t
  function e(r) {
    return new sY(S.revive(r.uri), r.provides)
  }
  i.to = e
})(wA || (wA = {}))
var dc
;(function (i) {
  function t(r) {
    return {
      message: Jt.fromStrict(r.message) || "",
      type: 0,
      expected: r.expectedOutput,
      actual: r.actualOutput,
      contextValue: r.contextValue,
      location: r.location && {
        range: O.from(r.location.range),
        uri: r.location.uri,
      },
      stackTrace: r.stackTrace?.map((s) => ({
        label: s.label,
        position: s.position && Gt.from(s.position),
        uri: s.uri && S.revive(s.uri).toJSON(),
      })),
    }
  }
  i.from = t
  function e(r) {
    const s = new U6(
      typeof r.message == "string" ? r.message : Jt.to(r.message),
    )
    return (
      (s.actualOutput = r.actual),
      (s.expectedOutput = r.expected),
      (s.contextValue = r.contextValue),
      (s.location = r.location ? Ri.to(r.location) : void 0),
      s
    )
  }
  i.to = e
})(dc || (dc = {}))
var Lr
;(function (i) {
  ;(i.namespace = z_), (i.denamespace = Nz)
})(Lr || (Lr = {}))
var mq
;(function (i) {
  function t(e) {
    return {
      controllerId: e.controllerId,
      profileId: e.profileId,
      group: mc.from(e.kind),
    }
  }
  i.from = t
})(mq || (mq = {}))
var mc
;(function (i) {
  const t = { [Zo.Coverage]: 8, [Zo.Debug]: 4, [Zo.Run]: 2 }
  function e(r) {
    return t.hasOwnProperty(r) ? t[r] : 2
  }
  i.from = e
})(mc || (mc = {}))
var Ss
;(function (i) {
  function t(r) {
    const s = e6(r).controllerId
    return {
      extId: Ot.fromExtHostTestItem(r, s).toString(),
      label: r.label,
      uri: S.revive(r.uri),
      busy: r.busy,
      tags: r.tags.map((a) => Lr.namespace(s, a.id)),
      range: re.lift(O.from(r.range)),
      description: r.description || null,
      sortText: r.sortText || null,
      error: (r.error && Jt.fromStrict(r.error)) || null,
    }
  }
  i.from = t
  function e(r) {
    return {
      parent: void 0,
      error: void 0,
      id: Ot.fromString(r.extId).localId,
      label: r.label,
      uri: S.revive(r.uri),
      tags: (r.tags || []).map((s) => {
        const { tagId: a } = Lr.denamespace(s)
        return new _l(a)
      }),
      children: {
        add: () => {},
        delete: () => {},
        forEach: () => {},
        *[Symbol.iterator]() {},
        get: () => {},
        replace: () => {},
        size: 0,
      },
      range: O.to(r.range || void 0),
      canResolveChildren: !1,
      busy: r.busy,
      description: r.description || void 0,
      sortText: r.sortText || void 0,
    }
  }
  i.toPlain = e
})(Ss || (Ss = {})),
  (function (i) {
    function t(r) {
      return { id: r.id }
    }
    i.from = t
    function e(r) {
      return new _l(r.id)
    }
    i.to = e
  })(Lr || (Lr = {}))
var hq
;(function (i) {
  const t = (r, s) => {
    const a = r.value
    if (!a) return
    const o = {
      ...Ss.toPlain(a.item),
      parent: s,
      taskStates: a.tasks.map((c) => ({
        state: c.state,
        duration: c.duration,
        messages: c.messages.filter((u) => u.type === 0).map(dc.to),
      })),
      children: [],
    }
    if (r.children)
      for (const c of r.children.values()) {
        const u = t(c, o)
        u && o.children.push(u)
      }
    return o
  }
  function e(r) {
    const s = new plt()
    for (const c of r.items) s.insert(Ot.fromString(c.item.extId).path, c)
    const a = [s.nodes],
      o = []
    for (; a.length; )
      for (const c of a.pop())
        c.value ? o.push(c) : c.children && a.push(c.children.values())
    return {
      completedAt: r.completedAt,
      results: o.map((c) => t(c)).filter(ta),
    }
  }
  i.to = e
})(hq || (hq = {}))
var Kl
;(function (i) {
  function t(c) {
    return { covered: c.covered, total: c.total }
  }
  function e(c) {
    return "line" in c ? Gt.from(c) : O.from(c)
  }
  function r(c) {
    if (c) return "endLineNumber" in c ? O.to(c) : Gt.to(c)
  }
  function s(c) {
    if (c.type === 1) {
      const u = []
      if (c.branches)
        for (const l of c.branches)
          u.push({ executed: l.count, location: r(l.location), label: l.label })
      return new oY(
        c.count,
        r(c.location),
        c.branches?.map((l) => new cY(l.count, r(l.location), l.label)),
      )
    } else return new uY(c.name, c.count, r(c.location))
  }
  i.to = s
  function a(c) {
    if (typeof c.executed == "number" && c.executed < 0)
      throw new Error(`Invalid coverage count ${c.executed}`)
    return "branches" in c
      ? {
          count: c.executed,
          location: e(c.location),
          type: 1,
          branches: c.branches.length
            ? c.branches.map((u) => ({
                count: u.executed,
                location: u.location && e(u.location),
                label: u.label,
              }))
            : void 0,
        }
      : { type: 0, name: c.name, count: c.executed, location: e(c.location) }
  }
  i.fromDetails = a
  function o(c, u, l) {
    return (
      H6(l.statementCoverage),
      H6(l.branchCoverage),
      H6(l.declarationCoverage),
      {
        id: u,
        uri: l.uri,
        statement: t(l.statementCoverage),
        branch: l.branchCoverage && t(l.branchCoverage),
        declaration: l.declarationCoverage && t(l.declarationCoverage),
        testIds:
          l instanceof W6 && l.includesTests.length
            ? l.includesTests.map((m) =>
                Ot.fromExtHostTestItem(m, c).toString(),
              )
            : void 0,
      }
    )
  }
  i.fromFile = o
})(Kl || (Kl = {}))
var fq
;(function (i) {
  function t(e) {
    switch (e) {
      case 1:
        return vl.Invoke
      case 2:
        return vl.Automatic
    }
  }
  i.to = t
})(fq || (fq = {}))
var Ra
;(function (i) {
  function t(r) {
    const s = new xO(
      mr.to(r.kind),
      r.name,
      r.detail || "",
      S.revive(r.uri),
      O.to(r.range),
      O.to(r.selectionRange),
    )
    return (s._sessionId = r._sessionId), (s._itemId = r._itemId), s
  }
  i.to = t
  function e(r, s, a) {
    if (
      ((s = s ?? r._sessionId),
      (a = a ?? r._itemId),
      s === void 0 || a === void 0)
    )
      throw new Error("invalid item")
    return {
      _sessionId: s,
      _itemId: a,
      kind: mr.from(r.kind),
      name: r.name,
      detail: r.detail ?? "",
      uri: r.uri,
      range: O.from(r.range),
      selectionRange: O.from(r.selectionRange),
      tags: r.tags?.map(Cn.from),
    }
  }
  i.from = e
})(Ra || (Ra = {}))
var yA
;(function (i) {
  function t(e) {
    if (e) return { value: e.value, tooltip: e.tooltip }
  }
  i.from = t
})(yA || (yA = {}))
var TA
;(function (i) {
  function t(a, o, c) {
    const u = o.fileData
    return u
      ? new $mt(
          new xmt(
            u.name,
            S.revive(u.uri),
            u.id,
            cB(() => c(u.id)),
          ),
        )
      : a === kn.uriList && o.uriListData
        ? new b6(s(o.uriListData))
        : new b6(o.asString)
  }
  i.to = t
  async function e(a, o) {
    const c = await o.asString()
    if (a === kn.uriList)
      return { asString: c, fileData: void 0, uriListData: r(c) }
    const u = o.asFile()
    return {
      asString: c,
      fileData: u
        ? { name: u.name, uri: u.uri, id: u._itemId ?? u.id }
        : void 0,
    }
  }
  i.from = e
  function r(a) {
    return t3.split(a).map((o) => {
      if (o.startsWith("#")) return o
      try {
        return S.parse(o)
      } catch {}
      return o
    })
  }
  function s(a) {
    return t3.create(a.map((o) => (typeof o == "string" ? o : S.revive(o))))
  }
})(TA || (TA = {}))
var bs
;(function (i) {
  function t(r, s) {
    const a = r.items.map(([o, c]) => [o, TA.to(o, c, s)])
    return new bl(a)
  }
  i.toDataTransfer = t
  async function e(r) {
    const s = { items: [] },
      a = []
    for (const [o, c] of r)
      a.push(
        (async () => {
          s.items.push([o, await TA.from(o, c)])
        })(),
      )
    return await Promise.all(a), s
  }
  i.from = e
})(bs || (bs = {}))
var Zl
;(function (i) {
  function t(r, s) {
    return {
      kind: "reply",
      agentId: r.participant ?? s?.agentId ?? "",
      subCommand: r.command ?? s?.command,
      message: r.prompt,
      title: r.label,
    }
  }
  i.from = t
  function e(r) {
    return {
      prompt: r.message,
      label: r.title,
      participant: r.agentId,
      command: r.subCommand,
    }
  }
  i.to = e
})(Zl || (Zl = {}))
var kA
;(function (i) {
  function t(r) {
    switch (r) {
      case 0:
        return dr.System
      case 1:
        return dr.User
      case 2:
        return dr.Assistant
    }
  }
  i.to = t
  function e(r) {
    switch (r) {
      case dr.System:
        return 0
      case dr.User:
        return 1
      case dr.Assistant:
        return 2
    }
    return 1
  }
  i.from = e
})(kA || (kA = {}))
var hc
;(function (i) {
  function t(r) {
    const s = r.content.map((c) => {
        if (c.type === "text") return new Li(c.value)
        if (c.type === "tool_result") {
          const u = c.value.map((l) =>
            l.type === "text" ? new Li(l.value) : new tc(l.value),
          )
          return new OO(c.toolCallId, u, c.isError)
        } else return new Wl(c.toolCallId, c.name, c.parameters)
      }),
      a = kA.to(r.role)
    return new kY(a, s, r.name)
  }
  i.to = t
  function e(r) {
    const s = kA.from(r.role),
      a = r.name
    let o = r.content
    typeof o == "string" && (o = [new Li(o)])
    const c = o.map((u) => {
      if (u instanceof OO)
        return {
          type: "tool_result",
          toolCallId: u.callId,
          value: Ge(
            u.content.map((l) =>
              l instanceof Li
                ? { type: "text", value: l.value }
                : l instanceof tc
                  ? { type: "prompt_tsx", value: l.value }
                  : void 0,
            ),
          ),
          isError: u.isError,
        }
      if (u instanceof Wl)
        return {
          type: "tool_use",
          toolCallId: u.callId,
          name: u.name,
          parameters: u.input,
        }
      if (u instanceof Li) return { type: "text", value: u.value }
      if (typeof u != "string")
        throw new Error("Unexpected chat message content type")
      return { type: "text", value: u }
    })
    return { role: s, name: a, content: c }
  }
  i.from = e
})(hc || (hc = {}))
var td
;(function (i) {
  function t(r) {
    return { kind: "markdownContent", content: Jt.from(r.value) }
  }
  i.from = t
  function e(r) {
    return new V6(Jt.to(r.content))
  }
  i.to = e
})(td || (td = {}))
var SA
;(function (i) {
  function t(r) {
    return { kind: "codeblockUri", uri: r.value }
  }
  i.from = t
  function e(r) {
    return new X6(S.revive(r.uri))
  }
  i.to = e
})(SA || (SA = {}))
var bA
;(function (i) {
  function t(r) {
    return {
      kind: "markdownVuln",
      content: Jt.from(r.value),
      vulnerabilities: r.vulnerabilities,
    }
  }
  i.from = t
  function e(r) {
    return new Bl(Jt.to(r.content), r.vulnerabilities)
  }
  i.to = e
})(bA || (bA = {}))
var EA
;(function (i) {
  function t(r) {
    return {
      kind: "agentDetection",
      agentId: r.participant,
      command: r.command,
    }
  }
  i.from = t
  function e(r) {
    return new Ol(r.agentId, r.command)
  }
  i.to = e
})(EA || (EA = {}))
var IA
;(function (i) {
  function t(e) {
    return {
      kind: "confirmation",
      title: e.title,
      message: e.message,
      data: e.data,
      buttons: e.buttons,
    }
  }
  i.from = t
})(IA || (IA = {}))
var ed
;(function (i) {
  function t(r) {
    const { value: s, baseUri: a } = r
    function o(c, u) {
      return c.map((l) => {
        const m = S.joinPath(u, l.name)
        return {
          label: l.name,
          uri: m,
          children: l.children && o(l.children, m),
        }
      })
    }
    return {
      kind: "treeData",
      treeData: { label: us(a), uri: a, children: o(s, a) },
    }
  }
  i.from = t
  function e(r) {
    const s = $i(r.treeData)
    function a(u) {
      return u.map((l) => ({
        name: l.label,
        children: l.children && a(l.children),
      }))
    }
    const o = s.uri,
      c = s.children ? a(s.children) : []
    return new z6(c, o)
  }
  i.to = e
})(ed || (ed = {}))
var fc
;(function (i) {
  function t(r) {
    const s = (o) => S.isUri(o),
      a = (o) => "name" in o
    return {
      kind: "inlineReference",
      name: r.title,
      inlineReference: s(r.value)
        ? r.value
        : a(r.value)
          ? Ja.from(r.value)
          : ys.from(r.value),
    }
  }
  i.from = t
  function e(r) {
    const s = $i(r)
    return new ql(
      S.isUri(s.inlineReference)
        ? s.inlineReference
        : "location" in s.inlineReference
          ? Ja.to(s.inlineReference)
          : ys.to(s.inlineReference),
      r.name,
    )
  }
  i.to = e
})(fc || (fc = {}))
var Da
;(function (i) {
  function t(r) {
    return { kind: "progressMessage", content: Jt.from(r.value) }
  }
  i.from = t
  function e(r) {
    return new Ul(r.content.value)
  }
  i.to = e
})(Da || (Da = {}))
var id
;(function (i) {
  function t(r) {
    return { kind: "warning", content: Jt.from(r.value) }
  }
  i.from = t
  function e(r) {
    return new Ml(r.content.value)
  }
  i.to = e
})(id || (id = {}))
var pq
;(function (i) {
  function t(r) {
    return { kind: "move", uri: r.uri, range: O.from(r.range) }
  }
  i.from = t
  function e(r) {
    return new Z6(S.revive(r.uri), O.to(r.range))
  }
  i.to = e
})(pq || (pq = {}))
var PA
;(function (i) {
  function t(e) {
    return { kind: "progressTask", content: Jt.from(e.value) }
  }
  i.from = t
})(PA || (PA = {}))
var gq
;(function (i) {
  function t(e) {
    return {
      kind: "progressTaskResult",
      content: typeof e == "string" ? Jt.from(e) : void 0,
    }
  }
  i.from = t
})(gq || (gq = {}))
var rd
;(function (i) {
  function t(r, s, a) {
    return {
      kind: "command",
      command: s.toInternal(r.value, a) ?? {
        command: r.value.command,
        title: r.value.title,
      },
    }
  }
  i.from = t
  function e(r, s) {
    return new Q6(
      s.fromInternal(r.command) ?? {
        command: r.command.id,
        title: r.command.title,
      },
    )
  }
  i.to = e
})(rd || (rd = {}))
var NA
;(function (i) {
  function t(r) {
    return {
      kind: "textEdit",
      uri: r.uri,
      edits: r.edits.map((s) => He.from(s)),
      done: r.isDone,
    }
  }
  i.from = t
  function e(r) {
    const s = new Hl(
      S.revive(r.uri),
      r.edits.map((a) => He.to(a)),
    )
    return (s.isDone = r.done), s
  }
  i.to = e
})(NA || (NA = {}))
var Ln
;(function (i) {
  function t(r) {
    const s = ri.isThemeIcon(r.iconPath)
      ? r.iconPath
      : S.isUri(r.iconPath)
        ? { light: S.revive(r.iconPath) }
        : r.iconPath &&
            "light" in r.iconPath &&
            "dark" in r.iconPath &&
            S.isUri(r.iconPath.light) &&
            S.isUri(r.iconPath.dark)
          ? {
              light: S.revive(r.iconPath.light),
              dark: S.revive(r.iconPath.dark),
            }
          : void 0
    return typeof r.value == "object" && "variableName" in r.value
      ? {
          kind: "reference",
          reference: {
            variableName: r.value.variableName,
            value:
              S.isUri(r.value.value) || !r.value.value
                ? r.value.value
                : ys.from(r.value.value),
          },
          iconPath: s,
          options: r.options,
        }
      : {
          kind: "reference",
          reference:
            S.isUri(r.value) || typeof r.value == "string"
              ? r.value
              : ys.from(r.value),
          iconPath: s,
          options: r.options,
        }
  }
  i.from = t
  function e(r) {
    const s = $i(r),
      a = (o) => (S.isUri(o) ? o : ys.to(o))
    return new xn(
      typeof s.reference == "string"
        ? s.reference
        : "variableName" in s.reference
          ? {
              variableName: s.reference.variableName,
              value: s.reference.value && a(s.reference.value),
            }
          : a(s.reference),
    )
  }
  i.to = e
})(Ln || (Ln = {}))
var $A
;(function (i) {
  function t(e) {
    return {
      kind: "codeCitation",
      value: e.value,
      license: e.license,
      snippet: e.snippet,
    }
  }
  i.from = t
})($A || ($A = {}))
var xA
;(function (i) {
  function t(s, a, o) {
    return s instanceof V6
      ? td.from(s)
      : s instanceof ql
        ? fc.from(s)
        : s instanceof xn
          ? Ln.from(s)
          : s instanceof Ul
            ? Da.from(s)
            : s instanceof z6
              ? ed.from(s)
              : s instanceof Q6
                ? rd.from(s, a, o)
                : s instanceof Hl
                  ? NA.from(s)
                  : s instanceof Bl
                    ? bA.from(s)
                    : s instanceof X6
                      ? SA.from(s)
                      : s instanceof Ol
                        ? EA.from(s)
                        : s instanceof Ml
                          ? id.from(s)
                          : s instanceof G6
                            ? IA.from(s)
                            : s instanceof K6
                              ? $A.from(s)
                              : s instanceof Z6
                                ? pq.from(s)
                                : {
                                    kind: "markdownContent",
                                    content: Jt.from(""),
                                  }
  }
  i.from = t
  function e(s, a) {
    switch (s.kind) {
      case "reference":
        return Ln.to(s)
      case "markdownContent":
      case "inlineReference":
      case "progressMessage":
      case "treeData":
      case "command":
        return r(s, a)
    }
  }
  i.to = e
  function r(s, a) {
    switch (s.kind) {
      case "markdownContent":
        return td.to(s)
      case "inlineReference":
        return fc.to(s)
      case "progressMessage":
        return
      case "treeData":
        return ed.to(s)
      case "command":
        return rd.to(s, a)
    }
  }
  i.toContent = r
})(xA || (xA = {}))
var JA
;(function (i) {
  function t(e, r, s) {
    const a = e.variables.variables.filter((c) => c.isTool),
      o = e.variables.variables.filter((c) => !c.isTool)
    return {
      prompt: e.message,
      command: e.command,
      attempt: e.attempt ?? 0,
      enableCommandDetection: e.enableCommandDetection ?? !0,
      isParticipantDetected: e.isParticipantDetected ?? !1,
      references: o.map(CA.to),
      toolReferences: a.map(LA.to),
      location: nd.to(e.location),
      acceptedConfirmationData: e.acceptedConfirmationData,
      rejectedConfirmationData: e.rejectedConfirmationData,
      location2: r,
      toolInvocationToken: Object.freeze({ sessionId: e.sessionId }),
      model: s,
    }
  }
  i.to = t
})(JA || (JA = {}))
var vq
;(function (i) {
  function t(e) {
    return { prompt: e.prompt, files: e.files.map((r) => S.revive(r)) }
  }
  i.to = t
})(vq || (vq = {}))
var nd
;(function (i) {
  function t(r) {
    switch (r) {
      case li.Notebook:
        return ir.Notebook
      case li.Terminal:
        return ir.Terminal
      case li.Panel:
        return ir.Panel
      case li.Editor:
        return ir.Editor
      case li.EditingSession:
        return ir.EditingSession
    }
  }
  i.to = t
  function e(r) {
    switch (r) {
      case ir.Notebook:
        return li.Notebook
      case ir.Terminal:
        return li.Terminal
      case ir.Panel:
        return li.Panel
      case ir.Editor:
        return li.Editor
      case ir.EditingSession:
        return li.EditingSession
    }
  }
  i.from = e
})(nd || (nd = {}))
var CA
;(function (i) {
  function t(e) {
    const r = e.value
    if (!r) throw new Error("Invalid value reference")
    return {
      id: e.id,
      name: e.name,
      range: e.range && [e.range.start, e.range.endExclusive],
      value: hW(r)
        ? S.revive(r)
        : r && typeof r == "object" && "uri" in r && "range" in r && hW(r.uri)
          ? ys.to($i(r))
          : e.isImage
            ? new TY(e.mimeType ?? "image/png", () =>
                Promise.resolve(new Uint8Array(Object.values(r))),
              )
            : r,
      modelDescription: e.modelDescription,
    }
  }
  i.to = t
})(CA || (CA = {}))
var LA
;(function (i) {
  function t(e) {
    if (e.value) throw new Error("Invalid tool reference")
    return {
      name: e.id,
      range: e.range && [e.range.start, e.range.endExclusive],
    }
  }
  i.to = t
})(LA || (LA = {}))
var wq
;(function (i) {
  function t(e, r, s) {
    return {
      id: e.id,
      label: e.label,
      fullName: e.fullName,
      icon: e.icon?.id,
      value: e.values[0].value,
      insertText: e.insertText,
      detail: e.detail,
      documentation: e.documentation,
      command: r.toInternal(e.command, s),
    }
  }
  i.from = t
})(wq || (wq = {}))
var Es
;(function (i) {
  function t(s) {
    return {
      errorDetails: s.errorDetails,
      metadata: r(s.metadata),
      nextQuestion: s.nextQuestion,
    }
  }
  i.to = t
  function e(s) {
    return {
      errorDetails: s.errorDetails,
      metadata: s.metadata,
      nextQuestion: s.nextQuestion,
    }
  }
  i.from = e
  function r(s) {
    return yo(s, (a) => {
      if (a.$mid === 20) return new qO(yo(a.content, r))
      if (a.$mid === 21) return new Li(a.value)
      if (a.$mid === 22) return new tc(a.value)
    })
  }
})(Es || (Es = {}))
var yq
;(function (i) {
  function t(e, r, s) {
    if (r.action.kind === "vote") return
    const a = Es.to(e)
    if (r.action.kind === "command") {
      const o = r.action.commandButton.command
      return {
        action: {
          kind: "command",
          commandButton: {
            command: s.fromInternal(o) ?? { command: o.id, title: o.title },
          },
        },
        result: a,
      }
    } else
      return r.action.kind === "followUp"
        ? {
            action: { kind: "followUp", followup: Zl.to(r.action.followup) },
            result: a,
          }
        : r.action.kind === "inlineChat"
          ? {
              action: {
                kind: "editor",
                accepted: r.action.action === "accepted",
              },
              result: a,
            }
          : r.action.kind === "chatEditingSessionAction"
            ? {
                action: {
                  kind: "chatEditingSessionAction",
                  outcome:
                    new Map([
                      ["accepted", xa.Accepted],
                      ["rejected", xa.Rejected],
                      ["saved", xa.Saved],
                    ]).get(r.action.outcome) ?? xa.Rejected,
                  uri: S.revive(r.action.uri),
                  hasRemainingEdits: r.action.hasRemainingEdits,
                },
                result: a,
              }
            : { action: r.action, result: a }
  }
  i.to = t
})(yq || (yq = {}))
var RA
;(function (i) {
  function t(e, r, s) {
    return "terminalCommand" in e
      ? { terminalCommand: e.terminalCommand, shouldExecute: e.shouldExecute }
      : "uri" in e
        ? { uri: e.uri }
        : r.toInternal(e, s)
  }
  i.from = t
})(RA || (RA = {}))
var Tq
;(function (i) {
  function t(e) {
    return { kind: kq.to(e.kind) }
  }
  i.to = t
})(Tq || (Tq = {}))
var kq
;(function (i) {
  function t(e) {
    switch (e) {
      case 0:
        return Ta.Word
      case 1:
        return Ta.Line
      case 2:
        return Ta.Suggest
      default:
        return Ta.Unknown
    }
  }
  i.to = t
})(kq || (kq = {}))
var Sq
;(function (i) {
  function t(e, r) {
    return {
      id: r,
      label: e.label,
      description: e.description,
      canEdit: e.canEdit,
      collapsibleState: e.collapsibleState || 0,
      contextValue: e.contextValue,
    }
  }
  i.from = t
})(Sq || (Sq = {}))
var bq
;(function (i) {
  function t(e) {
    return {
      name: e.id,
      description: e.modelDescription,
      inputSchema: e.inputSchema,
      tags: e.tags ?? [],
    }
  }
  i.to = t
})(bq || (bq = {}))
var Eq
;(function (i) {
  function t(r) {
    return new qO(
      r.content.map((s) =>
        s.kind === "text" ? new Li(s.value) : new tc(s.value),
      ),
    )
  }
  i.to = t
  function e(r) {
    return {
      content: r.content.map((s) => {
        if (s instanceof Li) return { kind: "text", value: s.value }
        if (s instanceof tc) return { kind: "promptTsx", value: s.value }
        throw new Error("Unknown LanguageModelToolResult part type")
      }),
    }
  }
  i.from = e
})(Eq || (Eq = {}))
var Is = class {
    constructor(i, t, e) {
      ;(this.uri = i), (this.ranges = t), (this.previewText = e)
    }
  },
  Iq = class {
    constructor(i, t, e) {
      ;(this.uri = i), (this.text = t), (this.lineNumber = e)
    }
  },
  Rn
;(function (i) {
  ;(i[(i.None = 1)] = "None"),
    (i[(i.FilesExclude = 2)] = "FilesExclude"),
    (i[(i.SearchAndFilesExclude = 3)] = "SearchAndFilesExclude")
})(Rn || (Rn = {}))
var DA
;(function (i) {
  ;(i[(i.Information = 1)] = "Information"), (i[(i.Warning = 2)] = "Warning")
})(DA || (DA = {}))
var bY = 2e4,
  EY = "\u27EA ",
  IY = " characters skipped \u27EB",
  Vmt = (EY.length + IY.length + 5) * 2,
  V3t = Y("searchService"),
  PY
;(function (i) {
  ;(i[(i.file = 0)] = "file"),
    (i[(i.text = 1)] = "text"),
    (i[(i.aiText = 2)] = "aiText")
})(PY || (PY = {}))
var NY
;(function (i) {
  ;(i[(i.File = 1)] = "File"),
    (i[(i.Text = 2)] = "Text"),
    (i[(i.aiText = 3)] = "aiText")
})(NY || (NY = {}))
function $Y(i) {
  return !!i.rangeLocations && !!i.previewText
}
var xY
;(function (i) {
  ;(i[(i.Normal = 0)] = "Normal"),
    (i[(i.NewSearchStarted = 1)] = "NewSearchStarted")
})(xY || (xY = {}))
var Gmt = class {
  constructor(i, t, e, r) {
    ;(this.rangeLocations = []), (this.webviewIndex = r)
    const s = Array.isArray(t) ? t : [t]
    if (e && e.matchLines === 1 && zmt(s)) {
      i = _ot(i, e.matchLines)
      let a = "",
        o = 0,
        c = 0
      const u = Math.floor(e.charsPerLine / 5)
      for (const l of s) {
        const m = Math.max(l.startColumn - u, 0),
          h = l.startColumn + e.charsPerLine
        if (m > c + u + Vmt) {
          const p = EY + (m - c) + IY
          ;(a += p + i.slice(m, h)), (o += m - (c + p.length))
        } else a += i.slice(c, h)
        ;(c = h),
          this.rangeLocations.push({
            source: l,
            preview: new Ymt(0, l.startColumn - o, l.endColumn - o),
          })
      }
      this.previewText = a
    } else {
      const a = Array.isArray(t) ? t[0].startLineNumber : t.startLineNumber,
        o = sB(t, (c) => ({
          preview: new JY(
            c.startLineNumber - a,
            c.startColumn,
            c.endLineNumber - a,
            c.endColumn,
          ),
          source: c,
        }))
      ;(this.rangeLocations = Array.isArray(o) ? o : [o]),
        (this.previewText = i)
    }
  }
}
function zmt(i) {
  const t = i[0].startLineNumber
  for (const e of i)
    if (e.startLineNumber !== t || e.endLineNumber !== t) return !1
  return !0
}
var JY = class {
    constructor(i, t, e, r) {
      ;(this.startLineNumber = i),
        (this.startColumn = t),
        (this.endLineNumber = e),
        (this.endColumn = r)
    }
  },
  Ymt = class extends JY {
    constructor(i, t, e) {
      super(i, t, i, e)
    }
  },
  CY
;(function (i) {
  ;(i.List = "list"), (i.Tree = "tree")
})(CY || (CY = {}))
var LY
;(function (i) {
  ;(i.Default = "default"),
    (i.FileNames = "fileNames"),
    (i.Type = "type"),
    (i.Modified = "modified"),
    (i.CountDescending = "countDescending"),
    (i.CountAscending = "countAscending")
})(LY || (LY = {}))
function Qmt(i, t = !0) {
  const e = i && i.files && i.files.exclude,
    r = t && i && i.search && i.search.exclude
  if (!e && !r) return
  if (!e || !r) return e || r || void 0
  let s = Object.create(null)
  return (s = ra(s, pe(e))), (s = ra(s, pe(r), !0)), s
}
function RY(i, t) {
  return i.excludePattern && al(i.excludePattern, t)
    ? !1
    : i.includePattern || i.usingSearchPaths
      ? i.includePattern && al(i.includePattern, t)
        ? !0
        : i.usingSearchPaths
          ? !!i.folderQueries &&
            i.folderQueries.some((e) => {
              const r = e.folder.fsPath
              if (c_(t, r)) {
                const s = Cu(r, t)
                return !e.includePattern || !!al(e.includePattern, s)
              } else return !1
            })
          : !1
      : !0
}
var DY
;(function (i) {
  ;(i[(i.unknownEncoding = 1)] = "unknownEncoding"),
    (i[(i.regexParseError = 2)] = "regexParseError"),
    (i[(i.globParseError = 3)] = "globParseError"),
    (i[(i.invalidLiteral = 4)] = "invalidLiteral"),
    (i[(i.rgProcessError = 5)] = "rgProcessError"),
    (i[(i.other = 6)] = "other"),
    (i[(i.canceled = 7)] = "canceled")
})(DY || (DY = {}))
function pc(i, t) {
  const e = { ...(i || {}), ...(t || {}) }
  return Object.keys(e).filter((r) => {
    const s = e[r]
    return typeof s == "boolean" && s
  })
}
var FY = class {
  constructor(i, t) {
    ;(this.c = null),
      (this.a =
        t.excludePattern?.map((r) => ({
          ...(i.excludePattern || {}),
          ...(r.pattern || {}),
        })) ?? []),
      this.a.length === 0 && (this.a = [i.excludePattern || {}]),
      (this.b = this.a.map((r) => Jo(r)))
    let e = i.includePattern
    t.includePattern &&
      (e ? (e = { ...e, ...t.includePattern }) : (e = t.includePattern)),
      e && (this.c = Jo(e))
  }
  d(i, t, e) {
    let r = null
    for (const s of this.b) {
      const a = s(i, t, e)
      if (typeof a == "string") {
        r = a
        break
      }
    }
    return r
  }
  matchesExcludesSync(i, t, e) {
    return !!(this.b && this.d(i, t, e))
  }
  includedInQuerySync(i, t, e) {
    return !((this.b && this.d(i, t, e)) || (this.c && !this.c(i, t, e)))
  }
  includedInQuery(i, t, e) {
    const r = () => (this.c ? !!this.c(i, t, e) : !0)
    return Promise.all(
      this.b.map((s) => {
        const a = s(i, t, e)
        return wn(a) ? a.then((o) => (o ? !1 : r())) : r()
      }),
    ).then((s) => s.some((a) => !!a))
  }
  hasSiblingExcludeClauses() {
    return this.a.reduce((i, t) => Xmt(t) || i, !1)
  }
}
function Xmt(i) {
  for (const t in i) if (typeof i[t] != "boolean") return !0
  return !1
}
function Kmt(i) {
  if (!i) return
  let t
  return (e) => (
    t || (t = (i() || Promise.resolve([])).then((r) => (r ? _Y(r) : {}))),
    t.then((r) => !!r[e])
  )
}
function Zmt(i) {
  if (!i) return
  let t
  return (e) => {
    if (!t) {
      const r = i()
      t = r ? _Y(r) : {}
    }
    return !!t[e]
  }
}
function _Y(i) {
  const t = {}
  for (const e of i) t[e] = !0
  return t
}
function AY(i) {
  return i.flatMap((t) =>
    t.patterns.map((e) => (t.baseUri ? { baseUri: t.baseUri, pattern: e } : e)),
  )
}
var Pq = { matchLines: 100, charsPerLine: 1e4 }
function _e(i, t) {
  if (!i) throw new Error(t)
}
var tht = 34028234663852886e22,
  eht = -34028234663852886e22,
  iht = 4294967295,
  rht = 2147483647,
  nht = -2147483648
function FA(i) {
  if (typeof i != "number") throw new Error("invalid int 32: " + typeof i)
  if (!Number.isInteger(i) || i > rht || i < nht)
    throw new Error("invalid int 32: " + i)
}
function Nq(i) {
  if (typeof i != "number") throw new Error("invalid uint 32: " + typeof i)
  if (!Number.isInteger(i) || i > iht || i < 0)
    throw new Error("invalid uint 32: " + i)
}
function BY(i) {
  if (typeof i != "number") throw new Error("invalid float 32: " + typeof i)
  if (Number.isFinite(i) && (i > tht || i < eht))
    throw new Error("invalid float 32: " + i)
}
var OY = Symbol("@bufbuild/protobuf/enum-type")
function qY(i) {
  const t = i[OY]
  return _e(t, "missing enum type on enum object"), t
}
function UY(i, t, e, r) {
  i[OY] = MY(
    t,
    e.map((s) => ({ no: s.no, name: s.name, localName: i[s.no] })),
    r,
  )
}
function MY(i, t, e) {
  const r = Object.create(null),
    s = Object.create(null),
    a = []
  for (const o of t) {
    const c = HY(o)
    a.push(c), (r[o.name] = c), (s[o.no] = c)
  }
  return {
    typeName: i,
    values: a,
    findName(o) {
      return r[o]
    },
    findNumber(o) {
      return s[o]
    },
  }
}
function sht(i, t, e) {
  const r = {}
  for (const s of t) {
    const a = HY(s)
    ;(r[a.localName] = a.no), (r[a.no] = a.localName)
  }
  return UY(r, i, t, e), r
}
function HY(i) {
  return "localName" in i ? i : { ...i, localName: i.name }
}
var d = class {
  equals(i) {
    return this.getType().runtime.util.equals(this.getType(), this, i)
  }
  clone() {
    return this.getType().runtime.util.clone(this)
  }
  fromBinary(i, t) {
    const e = this.getType(),
      r = e.runtime.bin,
      s = r.makeReadOptions(t)
    return r.readMessage(this, s.readerFactory(i), i.byteLength, s), this
  }
  fromJson(i, t) {
    const e = this.getType(),
      r = e.runtime.json,
      s = r.makeReadOptions(t)
    return r.readMessage(e, i, s, this), this
  }
  fromJsonString(i, t) {
    let e
    try {
      e = JSON.parse(i)
    } catch (r) {
      throw new Error(
        `cannot decode ${this.getType().typeName} from JSON: ${r instanceof Error ? r.message : String(r)}`,
      )
    }
    return this.fromJson(e, t)
  }
  toBinary(i) {
    const t = this.getType(),
      e = t.runtime.bin,
      r = e.makeWriteOptions(i),
      s = r.writerFactory()
    return e.writeMessage(this, s, r), s.finish()
  }
  toJson(i) {
    const t = this.getType(),
      e = t.runtime.json,
      r = e.makeWriteOptions(i)
    return e.writeMessage(this, r)
  }
  toJsonString(i) {
    const t = this.toJson(i)
    return JSON.stringify(t, null, i?.prettySpaces ?? 0)
  }
  toJSON() {
    return this.toJson({ emitDefaultValues: !0 })
  }
  getType() {
    return Object.getPrototypeOf(this).constructor
  }
}
function aht(i, t, e, r) {
  const s = r?.localName ?? t.substring(t.lastIndexOf(".") + 1),
    a = {
      [s]: function (o) {
        i.util.initFields(this), i.util.initPartial(o, this)
      },
    }[s]
  return (
    Object.setPrototypeOf(a.prototype, new d()),
    Object.assign(a, {
      runtime: i,
      typeName: t,
      fields: i.util.newFieldList(e),
      fromBinary(o, c) {
        return new a().fromBinary(o, c)
      },
      fromJson(o, c) {
        return new a().fromJson(o, c)
      },
      fromJsonString(o, c) {
        return new a().fromJsonString(o, c)
      },
      equals(o, c) {
        return i.util.equals(a, o, c)
      },
    }),
    a
  )
}
function oht() {
  let i = 0,
    t = 0
  for (let r = 0; r < 28; r += 7) {
    let s = this.buf[this.pos++]
    if (((i |= (s & 127) << r), !(s & 128))) return this.assertBounds(), [i, t]
  }
  let e = this.buf[this.pos++]
  if (((i |= (e & 15) << 28), (t = (e & 112) >> 4), !(e & 128)))
    return this.assertBounds(), [i, t]
  for (let r = 3; r <= 31; r += 7) {
    let s = this.buf[this.pos++]
    if (((t |= (s & 127) << r), !(s & 128))) return this.assertBounds(), [i, t]
  }
  throw new Error("invalid varint")
}
function $q(i, t, e) {
  for (let a = 0; a < 28; a = a + 7) {
    const o = i >>> a,
      c = !(!(o >>> 7) && t == 0),
      u = (c ? o | 128 : o) & 255
    if ((e.push(u), !c)) return
  }
  const r = ((i >>> 28) & 15) | ((t & 7) << 4),
    s = !!(t >> 3)
  if ((e.push((s ? r | 128 : r) & 255), !!s)) {
    for (let a = 3; a < 31; a = a + 7) {
      const o = t >>> a,
        c = !!(o >>> 7),
        u = (c ? o | 128 : o) & 255
      if ((e.push(u), !c)) return
    }
    e.push((t >>> 31) & 1)
  }
}
var _A = 4294967296
function WY(i) {
  const t = i[0] === "-"
  t && (i = i.slice(1))
  const e = 1e6
  let r = 0,
    s = 0
  function a(o, c) {
    const u = Number(i.slice(o, c))
    ;(s *= e),
      (r = r * e + u),
      r >= _A && ((s = s + ((r / _A) | 0)), (r = r % _A))
  }
  return a(-24, -18), a(-18, -12), a(-12, -6), a(-6), t ? VY(r, s) : xq(r, s)
}
function cht(i, t) {
  let e = xq(i, t)
  const r = e.hi & 2147483648
  r && (e = VY(e.lo, e.hi))
  const s = jY(e.lo, e.hi)
  return r ? "-" + s : s
}
function jY(i, t) {
  if ((({ lo: i, hi: t } = uht(i, t)), t <= 2097151)) return String(_A * t + i)
  const e = i & 16777215,
    r = ((i >>> 24) | (t << 8)) & 16777215,
    s = (t >> 16) & 65535
  let a = e + r * 6777216 + s * 6710656,
    o = r + s * 8147497,
    c = s * 2
  const u = 1e7
  return (
    a >= u && ((o += Math.floor(a / u)), (a %= u)),
    o >= u && ((c += Math.floor(o / u)), (o %= u)),
    c.toString() + GY(o) + GY(a)
  )
}
function uht(i, t) {
  return { lo: i >>> 0, hi: t >>> 0 }
}
function xq(i, t) {
  return { lo: i | 0, hi: t | 0 }
}
function VY(i, t) {
  return (t = ~t), i ? (i = ~i + 1) : (t += 1), xq(i, t)
}
var GY = (i) => {
  const t = String(i)
  return "0000000".slice(t.length) + t
}
function zY(i, t) {
  if (i >= 0) {
    for (; i > 127; ) t.push((i & 127) | 128), (i = i >>> 7)
    t.push(i)
  } else {
    for (let e = 0; e < 9; e++) t.push((i & 127) | 128), (i = i >> 7)
    t.push(1)
  }
}
function lht() {
  let i = this.buf[this.pos++],
    t = i & 127
  if (!(i & 128)) return this.assertBounds(), t
  if (((i = this.buf[this.pos++]), (t |= (i & 127) << 7), !(i & 128)))
    return this.assertBounds(), t
  if (((i = this.buf[this.pos++]), (t |= (i & 127) << 14), !(i & 128)))
    return this.assertBounds(), t
  if (((i = this.buf[this.pos++]), (t |= (i & 127) << 21), !(i & 128)))
    return this.assertBounds(), t
  ;(i = this.buf[this.pos++]), (t |= (i & 15) << 28)
  for (let e = 5; i & 128 && e < 10; e++) i = this.buf[this.pos++]
  if (i & 128) throw new Error("invalid varint")
  return this.assertBounds(), t >>> 0
}
function dht() {
  const i = new DataView(new ArrayBuffer(8))
  if (
    typeof BigInt == "function" &&
    typeof i.getBigInt64 == "function" &&
    typeof i.getBigUint64 == "function" &&
    typeof i.setBigInt64 == "function" &&
    typeof i.setBigUint64 == "function" &&
    (typeof process != "object" ||
      typeof process.env != "object" ||
      process.env.BUF_BIGINT_DISABLE !== "1")
  ) {
    const s = BigInt("-9223372036854775808"),
      a = BigInt("9223372036854775807"),
      o = BigInt("0"),
      c = BigInt("18446744073709551615")
    return {
      zero: BigInt(0),
      supported: !0,
      parse(u) {
        const l = typeof u == "bigint" ? u : BigInt(u)
        if (l > a || l < s) throw new Error(`int64 invalid: ${u}`)
        return l
      },
      uParse(u) {
        const l = typeof u == "bigint" ? u : BigInt(u)
        if (l > c || l < o) throw new Error(`uint64 invalid: ${u}`)
        return l
      },
      enc(u) {
        return (
          i.setBigInt64(0, this.parse(u), !0),
          { lo: i.getInt32(0, !0), hi: i.getInt32(4, !0) }
        )
      },
      uEnc(u) {
        return (
          i.setBigInt64(0, this.uParse(u), !0),
          { lo: i.getInt32(0, !0), hi: i.getInt32(4, !0) }
        )
      },
      dec(u, l) {
        return i.setInt32(0, u, !0), i.setInt32(4, l, !0), i.getBigInt64(0, !0)
      },
      uDec(u, l) {
        return i.setInt32(0, u, !0), i.setInt32(4, l, !0), i.getBigUint64(0, !0)
      },
    }
  }
  const e = (s) => _e(/^-?[0-9]+$/.test(s), `int64 invalid: ${s}`),
    r = (s) => _e(/^[0-9]+$/.test(s), `uint64 invalid: ${s}`)
  return {
    zero: "0",
    supported: !1,
    parse(s) {
      return typeof s != "string" && (s = s.toString()), e(s), s
    },
    uParse(s) {
      return typeof s != "string" && (s = s.toString()), r(s), s
    },
    enc(s) {
      return typeof s != "string" && (s = s.toString()), e(s), WY(s)
    },
    uEnc(s) {
      return typeof s != "string" && (s = s.toString()), r(s), WY(s)
    },
    dec(s, a) {
      return cht(s, a)
    },
    uDec(s, a) {
      return jY(s, a)
    },
  }
}
var Pe = dht(),
  A
;(function (i) {
  ;(i[(i.DOUBLE = 1)] = "DOUBLE"),
    (i[(i.FLOAT = 2)] = "FLOAT"),
    (i[(i.INT64 = 3)] = "INT64"),
    (i[(i.UINT64 = 4)] = "UINT64"),
    (i[(i.INT32 = 5)] = "INT32"),
    (i[(i.FIXED64 = 6)] = "FIXED64"),
    (i[(i.FIXED32 = 7)] = "FIXED32"),
    (i[(i.BOOL = 8)] = "BOOL"),
    (i[(i.STRING = 9)] = "STRING"),
    (i[(i.BYTES = 12)] = "BYTES"),
    (i[(i.UINT32 = 13)] = "UINT32"),
    (i[(i.SFIXED32 = 15)] = "SFIXED32"),
    (i[(i.SFIXED64 = 16)] = "SFIXED64"),
    (i[(i.SINT32 = 17)] = "SINT32"),
    (i[(i.SINT64 = 18)] = "SINT64")
})(A || (A = {}))
var Ps
;(function (i) {
  ;(i[(i.BIGINT = 0)] = "BIGINT"), (i[(i.STRING = 1)] = "STRING")
})(Ps || (Ps = {}))
function Ns(i, t, e) {
  if (t === e) return !0
  if (i == A.BYTES) {
    if (
      !(t instanceof Uint8Array) ||
      !(e instanceof Uint8Array) ||
      t.length !== e.length
    )
      return !1
    for (let r = 0; r < t.length; r++) if (t[r] !== e[r]) return !1
    return !0
  }
  switch (i) {
    case A.UINT64:
    case A.FIXED64:
    case A.INT64:
    case A.SFIXED64:
    case A.SINT64:
      return t == e
  }
  return !1
}
function gc(i, t) {
  switch (i) {
    case A.BOOL:
      return !1
    case A.UINT64:
    case A.FIXED64:
    case A.INT64:
    case A.SFIXED64:
    case A.SINT64:
      return t == 0 ? Pe.zero : "0"
    case A.DOUBLE:
    case A.FLOAT:
      return 0
    case A.BYTES:
      return new Uint8Array(0)
    case A.STRING:
      return ""
    default:
      return 0
  }
}
function YY(i, t) {
  switch (i) {
    case A.BOOL:
      return t === !1
    case A.STRING:
      return t === ""
    case A.BYTES:
      return t instanceof Uint8Array && !t.byteLength
    default:
      return t == 0
  }
}
function mht(i, t, e, r) {
  let s
  return {
    typeName: t,
    extendee: e,
    get field() {
      if (!s) {
        const a = typeof r == "function" ? r() : r
        ;(a.name = t.split(".").pop()),
          (a.jsonName = `[${t}]`),
          (s = i.util.newFieldList([a]).list()[0])
      }
      return s
    },
    runtime: i,
  }
}
function QY(i) {
  const t = i.field.localName,
    e = Object.create(null)
  return (e[t] = hht(i)), [e, () => e[t]]
}
function hht(i) {
  const t = i.field
  if (t.repeated) return []
  if (t.default !== void 0) return t.default
  switch (t.kind) {
    case "enum":
      return t.T.values[0].no
    case "scalar":
      return gc(t.T, t.L)
    case "message":
      const e = t.T,
        r = new e()
      return e.fieldWrapper ? e.fieldWrapper.unwrapField(r) : r
    case "map":
      throw "map fields are not allowed to be extensions"
  }
}
function fht(i, t) {
  if (!t.repeated && (t.kind == "enum" || t.kind == "scalar")) {
    for (let e = i.length - 1; e >= 0; --e) if (i[e].no == t.no) return [i[e]]
    return []
  }
  return i.filter((e) => e.no === t.no)
}
var Dn =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
      "",
    ),
  AA = []
for (let i = 0; i < Dn.length; i++) AA[Dn[i].charCodeAt(0)] = i
;(AA[45] = Dn.indexOf("+")), (AA[95] = Dn.indexOf("/"))
var XY = {
  dec(i) {
    let t = (i.length * 3) / 4
    i[i.length - 2] == "=" ? (t -= 2) : i[i.length - 1] == "=" && (t -= 1)
    let e = new Uint8Array(t),
      r = 0,
      s = 0,
      a,
      o = 0
    for (let c = 0; c < i.length; c++) {
      if (((a = AA[i.charCodeAt(c)]), a === void 0))
        switch (i[c]) {
          case "=":
            s = 0
          case `
`:
          case "\r":
          case "	":
          case " ":
            continue
          default:
            throw Error("invalid base64 string.")
        }
      switch (s) {
        case 0:
          ;(o = a), (s = 1)
          break
        case 1:
          ;(e[r++] = (o << 2) | ((a & 48) >> 4)), (o = a), (s = 2)
          break
        case 2:
          ;(e[r++] = ((o & 15) << 4) | ((a & 60) >> 2)), (o = a), (s = 3)
          break
        case 3:
          ;(e[r++] = ((o & 3) << 6) | a), (s = 0)
          break
      }
    }
    if (s == 1) throw Error("invalid base64 string.")
    return e.subarray(0, r)
  },
  enc(i) {
    let t = "",
      e = 0,
      r,
      s = 0
    for (let a = 0; a < i.length; a++)
      switch (((r = i[a]), e)) {
        case 0:
          ;(t += Dn[r >> 2]), (s = (r & 3) << 4), (e = 1)
          break
        case 1:
          ;(t += Dn[s | (r >> 4)]), (s = (r & 15) << 2), (e = 2)
          break
        case 2:
          ;(t += Dn[s | (r >> 6)]), (t += Dn[r & 63]), (e = 0)
          break
      }
    return e && ((t += Dn[s]), (t += "="), e == 1 && (t += "=")), t
  },
}
function pht(i, t, e) {
  ZY(t, i)
  const r = t.runtime.bin.makeReadOptions(e),
    s = fht(i.getType().runtime.bin.listUnknownFields(i), t.field),
    [a, o] = QY(t)
  for (const c of s)
    t.runtime.bin.readField(a, r.readerFactory(c.data), t.field, c.wireType, r)
  return o()
}
function ght(i, t, e, r) {
  ZY(t, i)
  const s = t.runtime.bin.makeReadOptions(r),
    a = t.runtime.bin.makeWriteOptions(r)
  if (KY(i, t)) {
    const l = i
      .getType()
      .runtime.bin.listUnknownFields(i)
      .filter((m) => m.no != t.field.no)
    i.getType().runtime.bin.discardUnknownFields(i)
    for (const m of l)
      i.getType().runtime.bin.onUnknownField(i, m.no, m.wireType, m.data)
  }
  const o = a.writerFactory()
  let c = t.field
  !c.opt &&
    !c.repeated &&
    (c.kind == "enum" || c.kind == "scalar") &&
    (c = { ...t.field, opt: !0 }),
    t.runtime.bin.writeField(c, e, o, a)
  const u = s.readerFactory(o.finish())
  for (; u.pos < u.len; ) {
    const [l, m] = u.tag(),
      h = u.skip(m, l)
    i.getType().runtime.bin.onUnknownField(i, l, m, h)
  }
}
function KY(i, t) {
  const e = i.getType()
  return (
    t.extendee.typeName === e.typeName &&
    !!e.runtime.bin.listUnknownFields(i).find((r) => r.no == t.field.no)
  )
}
function ZY(i, t) {
  _e(
    i.extendee.typeName == t.getType().typeName,
    `extension ${i.typeName} can only be applied to message ${i.extendee.typeName}`,
  )
}
function tQ(i, t) {
  const e = i.localName
  if (i.repeated) return t[e].length > 0
  if (i.oneof) return t[i.oneof.localName].case === e
  switch (i.kind) {
    case "enum":
    case "scalar":
      return i.opt || i.req
        ? t[e] !== void 0
        : i.kind == "enum"
          ? t[e] !== i.T.values[0].no
          : !YY(i.T, t[e])
    case "message":
      return t[e] !== void 0
    case "map":
      return Object.keys(t[e]).length > 0
  }
}
function eQ(i, t) {
  const e = i.localName,
    r = !i.opt && !i.req
  if (i.repeated) t[e] = []
  else if (i.oneof) t[i.oneof.localName] = { case: void 0 }
  else
    switch (i.kind) {
      case "map":
        t[e] = {}
        break
      case "enum":
        t[e] = r ? i.T.values[0].no : void 0
        break
      case "scalar":
        t[e] = r ? gc(i.T, i.L) : void 0
        break
      case "message":
        t[e] = void 0
        break
    }
}
function Fa(i, t) {
  if (
    i === null ||
    typeof i != "object" ||
    !Object.getOwnPropertyNames(d.prototype).every(
      (r) => r in i && typeof i[r] == "function",
    )
  )
    return !1
  const e = i.getType()
  return e === null ||
    typeof e != "function" ||
    !("typeName" in e) ||
    typeof e.typeName != "string"
    ? !1
    : t === void 0
      ? !0
      : e.typeName == t.typeName
}
function iQ(i, t) {
  return Fa(t) || !i.fieldWrapper ? t : i.fieldWrapper.wrapField(t)
}
var G3t = {
    "google.protobuf.DoubleValue": A.DOUBLE,
    "google.protobuf.FloatValue": A.FLOAT,
    "google.protobuf.Int64Value": A.INT64,
    "google.protobuf.UInt64Value": A.UINT64,
    "google.protobuf.Int32Value": A.INT32,
    "google.protobuf.UInt32Value": A.UINT32,
    "google.protobuf.BoolValue": A.BOOL,
    "google.protobuf.StringValue": A.STRING,
    "google.protobuf.BytesValue": A.BYTES,
  },
  rQ = { ignoreUnknownFields: !1 },
  nQ = {
    emitDefaultValues: !1,
    enumAsInteger: !1,
    useProtoFieldName: !1,
    prettySpaces: 0,
  }
function vht(i) {
  return i ? { ...rQ, ...i } : rQ
}
function wht(i) {
  return i ? { ...nQ, ...i } : nQ
}
var BA = Symbol(),
  OA = Symbol()
function yht() {
  return {
    makeReadOptions: vht,
    makeWriteOptions: wht,
    readMessage(i, t, e, r) {
      if (t == null || Array.isArray(t) || typeof t != "object")
        throw new Error(
          `cannot decode message ${i.typeName} from JSON: ${on(t)}`,
        )
      r = r ?? new i()
      const s = new Map(),
        a = e.typeRegistry
      for (const [o, c] of Object.entries(t)) {
        const u = i.fields.findJsonName(o)
        if (u) {
          if (u.oneof) {
            if (c === null && u.kind == "scalar") continue
            const l = s.get(u.oneof)
            if (l !== void 0)
              throw new Error(
                `cannot decode message ${i.typeName} from JSON: multiple keys for oneof "${u.oneof.name}" present: "${l}", "${o}"`,
              )
            s.set(u.oneof, o)
          }
          sQ(r, c, u, e, i)
        } else {
          let l = !1
          if (a?.findExtension && o.startsWith("[") && o.endsWith("]")) {
            const m = a.findExtension(o.substring(1, o.length - 1))
            if (m && m.extendee.typeName == i.typeName) {
              l = !0
              const [h, p] = QY(m)
              sQ(h, c, m.field, e, m), ght(r, m, p(), e)
            }
          }
          if (!l && !e.ignoreUnknownFields)
            throw new Error(
              `cannot decode message ${i.typeName} from JSON: key "${o}" is unknown`,
            )
        }
      }
      return r
    },
    writeMessage(i, t) {
      const e = i.getType(),
        r = {}
      let s
      try {
        for (s of e.fields.byNumber()) {
          if (!tQ(s, i)) {
            if (s.req) throw "required field not set"
            if (!t.emitDefaultValues || !kht(s)) continue
          }
          const o = s.oneof ? i[s.oneof.localName].value : i[s.localName],
            c = aQ(s, o, t)
          c !== void 0 && (r[t.useProtoFieldName ? s.name : s.jsonName] = c)
        }
        const a = t.typeRegistry
        if (a?.findExtensionFor)
          for (const o of e.runtime.bin.listUnknownFields(i)) {
            const c = a.findExtensionFor(e.typeName, o.no)
            if (c && KY(i, c)) {
              const u = pht(i, c, t),
                l = aQ(c.field, u, t)
              l !== void 0 && (r[c.field.jsonName] = l)
            }
          }
      } catch (a) {
        const o = s
            ? `cannot encode field ${e.typeName}.${s.name} to JSON`
            : `cannot encode message ${e.typeName} to JSON`,
          c = a instanceof Error ? a.message : String(a)
        throw new Error(o + (c.length > 0 ? `: ${c}` : ""))
      }
      return r
    },
    readScalar(i, t, e) {
      return sd(i, t, e ?? Ps.BIGINT, !0)
    },
    writeScalar(i, t, e) {
      if (t !== void 0 && (e || YY(i, t))) return qA(i, t)
    },
    debug: on,
  }
}
function on(i) {
  if (i === null) return "null"
  switch (typeof i) {
    case "object":
      return Array.isArray(i) ? "array" : "object"
    case "string":
      return i.length > 100 ? "string" : `"${i.split('"').join('\\"')}"`
    default:
      return String(i)
  }
}
function sQ(i, t, e, r, s) {
  let a = e.localName
  if (e.repeated) {
    if ((_e(e.kind != "map"), t === null)) return
    if (!Array.isArray(t))
      throw new Error(
        `cannot decode field ${s.typeName}.${e.name} from JSON: ${on(t)}`,
      )
    const o = i[a]
    for (const c of t) {
      if (c === null)
        throw new Error(
          `cannot decode field ${s.typeName}.${e.name} from JSON: ${on(c)}`,
        )
      switch (e.kind) {
        case "message":
          o.push(e.T.fromJson(c, r))
          break
        case "enum":
          const u = Jq(e.T, c, r.ignoreUnknownFields, !0)
          u !== OA && o.push(u)
          break
        case "scalar":
          try {
            o.push(sd(e.T, c, e.L, !0))
          } catch (l) {
            let m = `cannot decode field ${s.typeName}.${e.name} from JSON: ${on(c)}`
            throw (
              (l instanceof Error &&
                l.message.length > 0 &&
                (m += `: ${l.message}`),
              new Error(m))
            )
          }
          break
      }
    }
  } else if (e.kind == "map") {
    if (t === null) return
    if (typeof t != "object" || Array.isArray(t))
      throw new Error(
        `cannot decode field ${s.typeName}.${e.name} from JSON: ${on(t)}`,
      )
    const o = i[a]
    for (const [c, u] of Object.entries(t)) {
      if (u === null)
        throw new Error(
          `cannot decode field ${s.typeName}.${e.name} from JSON: map value null`,
        )
      let l
      try {
        l = Tht(e.K, c)
      } catch (m) {
        let h = `cannot decode map key for field ${s.typeName}.${e.name} from JSON: ${on(t)}`
        throw (
          (m instanceof Error &&
            m.message.length > 0 &&
            (h += `: ${m.message}`),
          new Error(h))
        )
      }
      switch (e.V.kind) {
        case "message":
          o[l] = e.V.T.fromJson(u, r)
          break
        case "enum":
          const m = Jq(e.V.T, u, r.ignoreUnknownFields, !0)
          m !== OA && (o[l] = m)
          break
        case "scalar":
          try {
            o[l] = sd(e.V.T, u, Ps.BIGINT, !0)
          } catch (h) {
            let p = `cannot decode map value for field ${s.typeName}.${e.name} from JSON: ${on(t)}`
            throw (
              (h instanceof Error &&
                h.message.length > 0 &&
                (p += `: ${h.message}`),
              new Error(p))
            )
          }
          break
      }
    }
  } else
    switch (
      (e.oneof && ((i = i[e.oneof.localName] = { case: a }), (a = "value")),
      e.kind)
    ) {
      case "message":
        const o = e.T
        if (t === null && o.typeName != "google.protobuf.Value") return
        let c = i[a]
        Fa(c)
          ? c.fromJson(t, r)
          : ((i[a] = c = o.fromJson(t, r)),
            o.fieldWrapper &&
              !e.oneof &&
              (i[a] = o.fieldWrapper.unwrapField(c)))
        break
      case "enum":
        const u = Jq(e.T, t, r.ignoreUnknownFields, !1)
        switch (u) {
          case BA:
            eQ(e, i)
            break
          case OA:
            break
          default:
            i[a] = u
            break
        }
        break
      case "scalar":
        try {
          const l = sd(e.T, t, e.L, !1)
          switch (l) {
            case BA:
              eQ(e, i)
              break
            default:
              i[a] = l
              break
          }
        } catch (l) {
          let m = `cannot decode field ${s.typeName}.${e.name} from JSON: ${on(t)}`
          throw (
            (l instanceof Error &&
              l.message.length > 0 &&
              (m += `: ${l.message}`),
            new Error(m))
          )
        }
        break
    }
}
function Tht(i, t) {
  if (i === A.BOOL)
    switch (t) {
      case "true":
        t = !0
        break
      case "false":
        t = !1
        break
    }
  return sd(i, t, Ps.BIGINT, !0).toString()
}
function sd(i, t, e, r) {
  if (t === null) return r ? gc(i, e) : BA
  switch (i) {
    case A.DOUBLE:
    case A.FLOAT:
      if (t === "NaN") return Number.NaN
      if (t === "Infinity") return Number.POSITIVE_INFINITY
      if (t === "-Infinity") return Number.NEGATIVE_INFINITY
      if (
        t === "" ||
        (typeof t == "string" && t.trim().length !== t.length) ||
        (typeof t != "string" && typeof t != "number")
      )
        break
      const s = Number(t)
      if (Number.isNaN(s) || !Number.isFinite(s)) break
      return i == A.FLOAT && BY(s), s
    case A.INT32:
    case A.FIXED32:
    case A.SFIXED32:
    case A.SINT32:
    case A.UINT32:
      let a
      if (
        (typeof t == "number"
          ? (a = t)
          : typeof t == "string" &&
            t.length > 0 &&
            t.trim().length === t.length &&
            (a = Number(t)),
        a === void 0)
      )
        break
      return i == A.UINT32 || i == A.FIXED32 ? Nq(a) : FA(a), a
    case A.INT64:
    case A.SFIXED64:
    case A.SINT64:
      if (typeof t != "number" && typeof t != "string") break
      const o = Pe.parse(t)
      return e ? o.toString() : o
    case A.FIXED64:
    case A.UINT64:
      if (typeof t != "number" && typeof t != "string") break
      const c = Pe.uParse(t)
      return e ? c.toString() : c
    case A.BOOL:
      if (typeof t != "boolean") break
      return t
    case A.STRING:
      if (typeof t != "string") break
      try {
        encodeURIComponent(t)
      } catch {
        throw new Error("invalid UTF8")
      }
      return t
    case A.BYTES:
      if (t === "") return new Uint8Array(0)
      if (typeof t != "string") break
      return XY.dec(t)
  }
  throw new Error()
}
function Jq(i, t, e, r) {
  if (t === null)
    return i.typeName == "google.protobuf.NullValue"
      ? 0
      : r
        ? i.values[0].no
        : BA
  switch (typeof t) {
    case "number":
      if (Number.isInteger(t)) return t
      break
    case "string":
      const s = i.findName(t)
      if (s !== void 0) return s.no
      if (e) return OA
      break
  }
  throw new Error(`cannot decode enum ${i.typeName} from JSON: ${on(t)}`)
}
function kht(i) {
  return i.repeated || i.kind == "map"
    ? !0
    : !(i.oneof || i.kind == "message" || i.opt || i.req)
}
function aQ(i, t, e) {
  if (i.kind == "map") {
    _e(typeof t == "object" && t != null)
    const r = {},
      s = Object.entries(t)
    switch (i.V.kind) {
      case "scalar":
        for (const [o, c] of s) r[o.toString()] = qA(i.V.T, c)
        break
      case "message":
        for (const [o, c] of s) r[o.toString()] = c.toJson(e)
        break
      case "enum":
        const a = i.V.T
        for (const [o, c] of s) r[o.toString()] = Cq(a, c, e.enumAsInteger)
        break
    }
    return e.emitDefaultValues || s.length > 0 ? r : void 0
  }
  if (i.repeated) {
    _e(Array.isArray(t))
    const r = []
    switch (i.kind) {
      case "scalar":
        for (let s = 0; s < t.length; s++) r.push(qA(i.T, t[s]))
        break
      case "enum":
        for (let s = 0; s < t.length; s++)
          r.push(Cq(i.T, t[s], e.enumAsInteger))
        break
      case "message":
        for (let s = 0; s < t.length; s++) r.push(t[s].toJson(e))
        break
    }
    return e.emitDefaultValues || r.length > 0 ? r : void 0
  }
  switch (i.kind) {
    case "scalar":
      return qA(i.T, t)
    case "enum":
      return Cq(i.T, t, e.enumAsInteger)
    case "message":
      return iQ(i.T, t).toJson(e)
  }
}
function Cq(i, t, e) {
  return (
    _e(typeof t == "number"),
    i.typeName == "google.protobuf.NullValue"
      ? null
      : e
        ? t
        : (i.findNumber(t)?.name ?? t)
  )
}
function qA(i, t) {
  switch (i) {
    case A.INT32:
    case A.SFIXED32:
    case A.SINT32:
    case A.FIXED32:
    case A.UINT32:
      return _e(typeof t == "number"), t
    case A.FLOAT:
    case A.DOUBLE:
      return (
        _e(typeof t == "number"),
        Number.isNaN(t)
          ? "NaN"
          : t === Number.POSITIVE_INFINITY
            ? "Infinity"
            : t === Number.NEGATIVE_INFINITY
              ? "-Infinity"
              : t
      )
    case A.STRING:
      return _e(typeof t == "string"), t
    case A.BOOL:
      return _e(typeof t == "boolean"), t
    case A.UINT64:
    case A.FIXED64:
    case A.INT64:
    case A.SFIXED64:
    case A.SINT64:
      return (
        _e(
          typeof t == "bigint" || typeof t == "string" || typeof t == "number",
        ),
        t.toString()
      )
    case A.BYTES:
      return _e(t instanceof Uint8Array), XY.enc(t)
  }
}
var We
;(function (i) {
  ;(i[(i.Varint = 0)] = "Varint"),
    (i[(i.Bit64 = 1)] = "Bit64"),
    (i[(i.LengthDelimited = 2)] = "LengthDelimited"),
    (i[(i.StartGroup = 3)] = "StartGroup"),
    (i[(i.EndGroup = 4)] = "EndGroup"),
    (i[(i.Bit32 = 5)] = "Bit32")
})(We || (We = {}))
var Sht = class {
    constructor(i) {
      ;(this.stack = []),
        (this.textEncoder = i ?? new TextEncoder()),
        (this.chunks = []),
        (this.buf = [])
    }
    finish() {
      this.chunks.push(new Uint8Array(this.buf))
      let i = 0
      for (let r = 0; r < this.chunks.length; r++) i += this.chunks[r].length
      let t = new Uint8Array(i),
        e = 0
      for (let r = 0; r < this.chunks.length; r++)
        t.set(this.chunks[r], e), (e += this.chunks[r].length)
      return (this.chunks = []), t
    }
    fork() {
      return (
        this.stack.push({ chunks: this.chunks, buf: this.buf }),
        (this.chunks = []),
        (this.buf = []),
        this
      )
    }
    join() {
      let i = this.finish(),
        t = this.stack.pop()
      if (!t) throw new Error("invalid state, fork stack empty")
      return (
        (this.chunks = t.chunks),
        (this.buf = t.buf),
        this.uint32(i.byteLength),
        this.raw(i)
      )
    }
    tag(i, t) {
      return this.uint32(((i << 3) | t) >>> 0)
    }
    raw(i) {
      return (
        this.buf.length &&
          (this.chunks.push(new Uint8Array(this.buf)), (this.buf = [])),
        this.chunks.push(i),
        this
      )
    }
    uint32(i) {
      for (Nq(i); i > 127; ) this.buf.push((i & 127) | 128), (i = i >>> 7)
      return this.buf.push(i), this
    }
    int32(i) {
      return FA(i), zY(i, this.buf), this
    }
    bool(i) {
      return this.buf.push(i ? 1 : 0), this
    }
    bytes(i) {
      return this.uint32(i.byteLength), this.raw(i)
    }
    string(i) {
      let t = this.textEncoder.encode(i)
      return this.uint32(t.byteLength), this.raw(t)
    }
    float(i) {
      BY(i)
      let t = new Uint8Array(4)
      return new DataView(t.buffer).setFloat32(0, i, !0), this.raw(t)
    }
    double(i) {
      let t = new Uint8Array(8)
      return new DataView(t.buffer).setFloat64(0, i, !0), this.raw(t)
    }
    fixed32(i) {
      Nq(i)
      let t = new Uint8Array(4)
      return new DataView(t.buffer).setUint32(0, i, !0), this.raw(t)
    }
    sfixed32(i) {
      FA(i)
      let t = new Uint8Array(4)
      return new DataView(t.buffer).setInt32(0, i, !0), this.raw(t)
    }
    sint32(i) {
      return FA(i), (i = ((i << 1) ^ (i >> 31)) >>> 0), zY(i, this.buf), this
    }
    sfixed64(i) {
      let t = new Uint8Array(8),
        e = new DataView(t.buffer),
        r = Pe.enc(i)
      return e.setInt32(0, r.lo, !0), e.setInt32(4, r.hi, !0), this.raw(t)
    }
    fixed64(i) {
      let t = new Uint8Array(8),
        e = new DataView(t.buffer),
        r = Pe.uEnc(i)
      return e.setInt32(0, r.lo, !0), e.setInt32(4, r.hi, !0), this.raw(t)
    }
    int64(i) {
      let t = Pe.enc(i)
      return $q(t.lo, t.hi, this.buf), this
    }
    sint64(i) {
      let t = Pe.enc(i),
        e = t.hi >> 31,
        r = (t.lo << 1) ^ e,
        s = ((t.hi << 1) | (t.lo >>> 31)) ^ e
      return $q(r, s, this.buf), this
    }
    uint64(i) {
      let t = Pe.uEnc(i)
      return $q(t.lo, t.hi, this.buf), this
    }
  },
  bht = class {
    constructor(i, t) {
      ;(this.varint64 = oht),
        (this.uint32 = lht),
        (this.buf = i),
        (this.len = i.length),
        (this.pos = 0),
        (this.view = new DataView(i.buffer, i.byteOffset, i.byteLength)),
        (this.textDecoder = t ?? new TextDecoder())
    }
    tag() {
      let i = this.uint32(),
        t = i >>> 3,
        e = i & 7
      if (t <= 0 || e < 0 || e > 5)
        throw new Error("illegal tag: field no " + t + " wire type " + e)
      return [t, e]
    }
    skip(i, t) {
      let e = this.pos
      switch (i) {
        case We.Varint:
          for (; this.buf[this.pos++] & 128; );
          break
        case We.Bit64:
          this.pos += 4
        case We.Bit32:
          this.pos += 4
          break
        case We.LengthDelimited:
          let r = this.uint32()
          this.pos += r
          break
        case We.StartGroup:
          for (;;) {
            const [s, a] = this.tag()
            if (a === We.EndGroup) {
              if (t !== void 0 && s !== t)
                throw new Error("invalid end group tag")
              break
            }
            this.skip(a, s)
          }
          break
        default:
          throw new Error("cant skip wire type " + i)
      }
      return this.assertBounds(), this.buf.subarray(e, this.pos)
    }
    assertBounds() {
      if (this.pos > this.len) throw new RangeError("premature EOF")
    }
    int32() {
      return this.uint32() | 0
    }
    sint32() {
      let i = this.uint32()
      return (i >>> 1) ^ -(i & 1)
    }
    int64() {
      return Pe.dec(...this.varint64())
    }
    uint64() {
      return Pe.uDec(...this.varint64())
    }
    sint64() {
      let [i, t] = this.varint64(),
        e = -(i & 1)
      return (
        (i = ((i >>> 1) | ((t & 1) << 31)) ^ e),
        (t = (t >>> 1) ^ e),
        Pe.dec(i, t)
      )
    }
    bool() {
      let [i, t] = this.varint64()
      return i !== 0 || t !== 0
    }
    fixed32() {
      return this.view.getUint32((this.pos += 4) - 4, !0)
    }
    sfixed32() {
      return this.view.getInt32((this.pos += 4) - 4, !0)
    }
    fixed64() {
      return Pe.uDec(this.sfixed32(), this.sfixed32())
    }
    sfixed64() {
      return Pe.dec(this.sfixed32(), this.sfixed32())
    }
    float() {
      return this.view.getFloat32((this.pos += 4) - 4, !0)
    }
    double() {
      return this.view.getFloat64((this.pos += 8) - 8, !0)
    }
    bytes() {
      let i = this.uint32(),
        t = this.pos
      return (this.pos += i), this.assertBounds(), this.buf.subarray(t, t + i)
    }
    string() {
      return this.textDecoder.decode(this.bytes())
    }
  },
  vc = Symbol("@bufbuild/protobuf/unknown-fields"),
  oQ = { readUnknownFields: !0, readerFactory: (i) => new bht(i) },
  cQ = { writeUnknownFields: !0, writerFactory: () => new Sht() }
function Eht(i) {
  return i ? { ...oQ, ...i } : oQ
}
function Iht(i) {
  return i ? { ...cQ, ...i } : cQ
}
function Pht() {
  return {
    makeReadOptions: Eht,
    makeWriteOptions: Iht,
    listUnknownFields(i) {
      return i[vc] ?? []
    },
    discardUnknownFields(i) {
      delete i[vc]
    },
    writeUnknownFields(i, t) {
      const r = i[vc]
      if (r) for (const s of r) t.tag(s.no, s.wireType).raw(s.data)
    },
    onUnknownField(i, t, e, r) {
      const s = i
      Array.isArray(s[vc]) || (s[vc] = []),
        s[vc].push({ no: t, wireType: e, data: r })
    },
    readMessage(i, t, e, r, s) {
      const a = i.getType(),
        o = s ? t.len : t.pos + e
      let c, u
      for (
        ;
        t.pos < o && (([c, u] = t.tag()), !(s === !0 && u == We.EndGroup));

      ) {
        const l = a.fields.find(c)
        if (!l) {
          const m = t.skip(u, c)
          r.readUnknownFields && this.onUnknownField(i, c, u, m)
          continue
        }
        uQ(i, t, l, u, r)
      }
      if (s && (u != We.EndGroup || c !== e))
        throw new Error("invalid end group tag")
    },
    readField: uQ,
    writeMessage(i, t, e) {
      const r = i.getType()
      for (const s of r.fields.byNumber()) {
        if (!tQ(s, i)) {
          if (s.req)
            throw new Error(
              `cannot encode field ${r.typeName}.${s.name} to binary: required field not set`,
            )
          continue
        }
        const a = s.oneof ? i[s.oneof.localName].value : i[s.localName]
        lQ(s, a, t, e)
      }
      return e.writeUnknownFields && this.writeUnknownFields(i, t), t
    },
    writeField(i, t, e, r) {
      t !== void 0 && lQ(i, t, e, r)
    },
  }
}
function uQ(i, t, e, r, s) {
  let { repeated: a, localName: o } = e
  switch (
    (e.oneof &&
      ((i = i[e.oneof.localName]),
      i.case != o && delete i.value,
      (i.case = o),
      (o = "value")),
    e.kind)
  ) {
    case "scalar":
    case "enum":
      const c = e.kind == "enum" ? A.INT32 : e.T
      let u = MA
      if ((e.kind == "scalar" && e.L > 0 && (u = $ht), a)) {
        let p = i[o]
        if (r == We.LengthDelimited && c != A.STRING && c != A.BYTES) {
          let w = t.uint32() + t.pos
          for (; t.pos < w; ) p.push(u(t, c))
        } else p.push(u(t, c))
      } else i[o] = u(t, c)
      break
    case "message":
      const l = e.T
      a
        ? i[o].push(UA(t, new l(), s, e))
        : Fa(i[o])
          ? UA(t, i[o], s, e)
          : ((i[o] = UA(t, new l(), s, e)),
            l.fieldWrapper &&
              !e.oneof &&
              !e.repeated &&
              (i[o] = l.fieldWrapper.unwrapField(i[o])))
      break
    case "map":
      let [m, h] = Nht(e, t, s)
      i[o][m] = h
      break
  }
}
function UA(i, t, e, r) {
  const s = t.getType().runtime.bin,
    a = r?.delimited
  return s.readMessage(t, i, a ? r.no : i.uint32(), e, a), t
}
function Nht(i, t, e) {
  const r = t.uint32(),
    s = t.pos + r
  let a, o
  for (; t.pos < s; ) {
    const [c] = t.tag()
    switch (c) {
      case 1:
        a = MA(t, i.K)
        break
      case 2:
        switch (i.V.kind) {
          case "scalar":
            o = MA(t, i.V.T)
            break
          case "enum":
            o = t.int32()
            break
          case "message":
            o = UA(t, new i.V.T(), e, void 0)
            break
        }
        break
    }
  }
  if (
    (a === void 0 && (a = gc(i.K, Ps.BIGINT)),
    typeof a != "string" && typeof a != "number" && (a = a.toString()),
    o === void 0)
  )
    switch (i.V.kind) {
      case "scalar":
        o = gc(i.V.T, Ps.BIGINT)
        break
      case "enum":
        o = i.V.T.values[0].no
        break
      case "message":
        o = new i.V.T()
        break
    }
  return [a, o]
}
function $ht(i, t) {
  const e = MA(i, t)
  return typeof e == "bigint" ? e.toString() : e
}
function MA(i, t) {
  switch (t) {
    case A.STRING:
      return i.string()
    case A.BOOL:
      return i.bool()
    case A.DOUBLE:
      return i.double()
    case A.FLOAT:
      return i.float()
    case A.INT32:
      return i.int32()
    case A.INT64:
      return i.int64()
    case A.UINT64:
      return i.uint64()
    case A.FIXED64:
      return i.fixed64()
    case A.BYTES:
      return i.bytes()
    case A.FIXED32:
      return i.fixed32()
    case A.SFIXED32:
      return i.sfixed32()
    case A.SFIXED64:
      return i.sfixed64()
    case A.SINT64:
      return i.sint64()
    case A.UINT32:
      return i.uint32()
    case A.SINT32:
      return i.sint32()
  }
}
function lQ(i, t, e, r) {
  _e(t !== void 0)
  const s = i.repeated
  switch (i.kind) {
    case "scalar":
    case "enum":
      let a = i.kind == "enum" ? A.INT32 : i.T
      if (s)
        if ((_e(Array.isArray(t)), i.packed)) Jht(e, a, i.no, t)
        else for (const o of t) ad(e, a, i.no, o)
      else ad(e, a, i.no, t)
      break
    case "message":
      if (s) {
        _e(Array.isArray(t))
        for (const o of t) dQ(e, r, i, o)
      } else dQ(e, r, i, t)
      break
    case "map":
      _e(typeof t == "object" && t != null)
      for (const [o, c] of Object.entries(t)) xht(e, r, i, o, c)
      break
  }
}
function xht(i, t, e, r, s) {
  i.tag(e.no, We.LengthDelimited), i.fork()
  let a = r
  switch (e.K) {
    case A.INT32:
    case A.FIXED32:
    case A.UINT32:
    case A.SFIXED32:
    case A.SINT32:
      a = Number.parseInt(r)
      break
    case A.BOOL:
      _e(r == "true" || r == "false"), (a = r == "true")
      break
  }
  switch ((ad(i, e.K, 1, a), e.V.kind)) {
    case "scalar":
      ad(i, e.V.T, 2, s)
      break
    case "enum":
      ad(i, A.INT32, 2, s)
      break
    case "message":
      _e(s !== void 0), i.tag(2, We.LengthDelimited).bytes(s.toBinary(t))
      break
  }
  i.join()
}
function dQ(i, t, e, r) {
  const s = iQ(e.T, r)
  e.delimited
    ? i.tag(e.no, We.StartGroup).raw(s.toBinary(t)).tag(e.no, We.EndGroup)
    : i.tag(e.no, We.LengthDelimited).bytes(s.toBinary(t))
}
function ad(i, t, e, r) {
  _e(r !== void 0)
  let [s, a] = mQ(t)
  i.tag(e, s)[a](r)
}
function Jht(i, t, e, r) {
  if (!r.length) return
  i.tag(e, We.LengthDelimited).fork()
  let [, s] = mQ(t)
  for (let a = 0; a < r.length; a++) i[s](r[a])
  i.join()
}
function mQ(i) {
  let t = We.Varint
  switch (i) {
    case A.BYTES:
    case A.STRING:
      t = We.LengthDelimited
      break
    case A.DOUBLE:
    case A.FIXED64:
    case A.SFIXED64:
      t = We.Bit64
      break
    case A.FIXED32:
    case A.SFIXED32:
    case A.FLOAT:
      t = We.Bit32
      break
  }
  const e = A[i].toLowerCase()
  return [t, e]
}
function Cht() {
  return {
    setEnumType: UY,
    initPartial(i, t) {
      if (i === void 0) return
      const e = t.getType()
      for (const r of e.fields.byMember()) {
        const s = r.localName,
          a = t,
          o = i
        if (o[s] != null)
          switch (r.kind) {
            case "oneof":
              const c = o[s].case
              if (c === void 0) continue
              const u = r.findField(c)
              let l = o[s].value
              u && u.kind == "message" && !Fa(l, u.T)
                ? (l = new u.T(l))
                : u && u.kind === "scalar" && u.T === A.BYTES && (l = od(l)),
                (a[s] = { case: c, value: l })
              break
            case "scalar":
            case "enum":
              let m = o[s]
              r.T === A.BYTES && (m = r.repeated ? m.map(od) : od(m)),
                (a[s] = m)
              break
            case "map":
              switch (r.V.kind) {
                case "scalar":
                case "enum":
                  if (r.V.T === A.BYTES)
                    for (const [g, w] of Object.entries(o[s])) a[s][g] = od(w)
                  else Object.assign(a[s], o[s])
                  break
                case "message":
                  const p = r.V.T
                  for (const g of Object.keys(o[s])) {
                    let w = o[s][g]
                    p.fieldWrapper || (w = new p(w)), (a[s][g] = w)
                  }
                  break
              }
              break
            case "message":
              const h = r.T
              if (r.repeated) a[s] = o[s].map((p) => (Fa(p, h) ? p : new h(p)))
              else {
                const p = o[s]
                h.fieldWrapper
                  ? h.typeName === "google.protobuf.BytesValue"
                    ? (a[s] = od(p))
                    : (a[s] = p)
                  : (a[s] = Fa(p, h) ? p : new h(p))
              }
              break
          }
      }
    },
    equals(i, t, e) {
      return t === e
        ? !0
        : !t || !e
          ? !1
          : i.fields.byMember().every((r) => {
              const s = t[r.localName],
                a = e[r.localName]
              if (r.repeated) {
                if (s.length !== a.length) return !1
                switch (r.kind) {
                  case "message":
                    return s.every((o, c) => r.T.equals(o, a[c]))
                  case "scalar":
                    return s.every((o, c) => Ns(r.T, o, a[c]))
                  case "enum":
                    return s.every((o, c) => Ns(A.INT32, o, a[c]))
                }
                throw new Error(`repeated cannot contain ${r.kind}`)
              }
              switch (r.kind) {
                case "message":
                  return r.T.equals(s, a)
                case "enum":
                  return Ns(A.INT32, s, a)
                case "scalar":
                  return Ns(r.T, s, a)
                case "oneof":
                  if (s.case !== a.case) return !1
                  const o = r.findField(s.case)
                  if (o === void 0) return !0
                  switch (o.kind) {
                    case "message":
                      return o.T.equals(s.value, a.value)
                    case "enum":
                      return Ns(A.INT32, s.value, a.value)
                    case "scalar":
                      return Ns(o.T, s.value, a.value)
                  }
                  throw new Error(`oneof cannot contain ${o.kind}`)
                case "map":
                  const c = Object.keys(s).concat(Object.keys(a))
                  switch (r.V.kind) {
                    case "message":
                      const u = r.V.T
                      return c.every((m) => u.equals(s[m], a[m]))
                    case "enum":
                      return c.every((m) => Ns(A.INT32, s[m], a[m]))
                    case "scalar":
                      const l = r.V.T
                      return c.every((m) => Ns(l, s[m], a[m]))
                  }
                  break
              }
            })
    },
    clone(i) {
      const t = i.getType(),
        e = new t(),
        r = e
      for (const s of t.fields.byMember()) {
        const a = i[s.localName]
        let o
        if (s.repeated) o = a.map(HA)
        else if (s.kind == "map") {
          o = r[s.localName]
          for (const [c, u] of Object.entries(a)) o[c] = HA(u)
        } else
          s.kind == "oneof"
            ? (o = s.findField(a.case)
                ? { case: a.case, value: HA(a.value) }
                : { case: void 0 })
            : (o = HA(a))
        r[s.localName] = o
      }
      for (const s of t.runtime.bin.listUnknownFields(i))
        t.runtime.bin.onUnknownField(r, s.no, s.wireType, s.data)
      return e
    },
  }
}
function HA(i) {
  if (i === void 0) return i
  if (Fa(i)) return i.clone()
  if (i instanceof Uint8Array) {
    const t = new Uint8Array(i.byteLength)
    return t.set(i), t
  }
  return i
}
function od(i) {
  return i instanceof Uint8Array ? i : new Uint8Array(i)
}
function hQ(i, t, e) {
  return {
    syntax: i,
    json: yht(),
    bin: Pht(),
    util: { ...Cht(), newFieldList: t, initFields: e },
    makeMessageType(r, s, a) {
      return aht(this, r, s, a)
    },
    makeEnum: sht,
    makeEnumType: MY,
    getEnumType: qY,
    makeExtension(r, s, a) {
      return mht(this, r, s, a)
    },
  }
}
var fQ = class {
  constructor(i, t) {
    ;(this._fields = i), (this._normalizer = t)
  }
  findJsonName(i) {
    if (!this.jsonNames) {
      const t = {}
      for (const e of this.list()) t[e.jsonName] = t[e.name] = e
      this.jsonNames = t
    }
    return this.jsonNames[i]
  }
  find(i) {
    if (!this.numbers) {
      const t = {}
      for (const e of this.list()) t[e.no] = e
      this.numbers = t
    }
    return this.numbers[i]
  }
  list() {
    return this.all || (this.all = this._normalizer(this._fields)), this.all
  }
  byNumber() {
    return (
      this.numbersAsc ||
        (this.numbersAsc = this.list()
          .concat()
          .sort((i, t) => i.no - t.no)),
      this.numbersAsc
    )
  }
  byMember() {
    if (!this.members) {
      this.members = []
      const i = this.members
      let t
      for (const e of this.list())
        e.oneof ? e.oneof !== t && ((t = e.oneof), i.push(t)) : i.push(e)
    }
    return this.members
  }
}
function pQ(i, t) {
  const e = gQ(i)
  return t ? e : Aht(_ht(e))
}
function Lht(i) {
  return pQ(i, !1)
}
var Rht = gQ
function gQ(i) {
  let t = !1
  const e = []
  for (let r = 0; r < i.length; r++) {
    let s = i.charAt(r)
    switch (s) {
      case "_":
        t = !0
        break
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        e.push(s), (t = !1)
        break
      default:
        t && ((t = !1), (s = s.toUpperCase())), e.push(s)
        break
    }
  }
  return e.join("")
}
var Dht = new Set(["constructor", "toString", "toJSON", "valueOf"]),
  Fht = new Set([
    "getType",
    "clone",
    "equals",
    "fromBinary",
    "fromJson",
    "fromJsonString",
    "toBinary",
    "toJson",
    "toJsonString",
    "toObject",
  ]),
  vQ = (i) => `${i}$`,
  _ht = (i) => (Fht.has(i) ? vQ(i) : i),
  Aht = (i) => (Dht.has(i) ? vQ(i) : i),
  Bht = class {
    constructor(i) {
      ;(this.kind = "oneof"),
        (this.repeated = !1),
        (this.packed = !1),
        (this.opt = !1),
        (this.req = !1),
        (this.default = void 0),
        (this.fields = []),
        (this.name = i),
        (this.localName = Lht(i))
    }
    addField(i) {
      _e(i.oneof === this, `field ${i.name} not one of ${this.name}`),
        this.fields.push(i)
    }
    findField(i) {
      if (!this._lookup) {
        this._lookup = Object.create(null)
        for (let t = 0; t < this.fields.length; t++)
          this._lookup[this.fields[t].localName] = this.fields[t]
      }
      return this._lookup[i]
    }
  }
function wQ(i, t) {
  const e = []
  let r
  for (const s of typeof i == "function" ? i() : i) {
    const a = s
    if (
      ((a.localName = pQ(s.name, s.oneof !== void 0)),
      (a.jsonName = s.jsonName ?? Rht(s.name)),
      (a.repeated = s.repeated ?? !1),
      s.kind == "scalar" && (a.L = s.L ?? Ps.BIGINT),
      (a.delimited = s.delimited ?? !1),
      (a.req = s.req ?? !1),
      (a.opt = s.opt ?? !1),
      s.packed === void 0 &&
        (t
          ? (a.packed =
              s.kind == "enum" ||
              (s.kind == "scalar" && s.T != A.BYTES && s.T != A.STRING))
          : (a.packed = !1)),
      s.oneof !== void 0)
    ) {
      const o = typeof s.oneof == "string" ? s.oneof : s.oneof.name
      ;(!r || r.name != o) && (r = new Bht(o)), (a.oneof = r), r.addField(a)
    }
    e.push(a)
  }
  return e
}
var n = hQ(
    "proto3",
    (i) => new fQ(i, (t) => wQ(t, !0)),
    (i) => {
      for (const t of i.getType().fields.byMember()) {
        if (t.opt) continue
        const e = t.localName,
          r = i
        if (t.repeated) {
          r[e] = []
          continue
        }
        switch (t.kind) {
          case "oneof":
            r[e] = { case: void 0 }
            break
          case "enum":
            r[e] = 0
            break
          case "map":
            r[e] = {}
            break
          case "scalar":
            r[e] = gc(t.T, t.L)
            break
          case "message":
            break
        }
      }
    },
  ),
  J = hQ(
    "proto2",
    (i) => new fQ(i, (t) => wQ(t, !1)),
    (i) => {
      for (const t of i.getType().fields.byMember()) {
        const e = t.localName,
          r = i
        if (t.repeated) {
          r[e] = []
          continue
        }
        switch (t.kind) {
          case "oneof":
            r[e] = { case: void 0 }
            break
          case "map":
            r[e] = {}
            break
          case "scalar":
          case "enum":
          case "message":
            break
        }
      }
    },
  ),
  z3t = {
    NaN: Number.NaN,
    POSITIVE_INFINITY: Number.POSITIVE_INFINITY,
    NEGATIVE_INFINITY: Number.NEGATIVE_INFINITY,
  },
  E
;(function (i) {
  ;(i[(i.Unary = 0)] = "Unary"),
    (i[(i.ServerStreaming = 1)] = "ServerStreaming"),
    (i[(i.ClientStreaming = 2)] = "ClientStreaming"),
    (i[(i.BiDiStreaming = 3)] = "BiDiStreaming")
})(E || (E = {}))
var yQ
;(function (i) {
  ;(i[(i.NoSideEffects = 1)] = "NoSideEffects"),
    (i[(i.Idempotent = 2)] = "Idempotent")
})(yQ || (yQ = {}))
var Rr
;(function (i) {
  ;(i[(i.EDITION_UNKNOWN = 0)] = "EDITION_UNKNOWN"),
    (i[(i.EDITION_LEGACY = 900)] = "EDITION_LEGACY"),
    (i[(i.EDITION_PROTO2 = 998)] = "EDITION_PROTO2"),
    (i[(i.EDITION_PROTO3 = 999)] = "EDITION_PROTO3"),
    (i[(i.EDITION_2023 = 1e3)] = "EDITION_2023"),
    (i[(i.EDITION_2024 = 1001)] = "EDITION_2024"),
    (i[(i.EDITION_1_TEST_ONLY = 1)] = "EDITION_1_TEST_ONLY"),
    (i[(i.EDITION_2_TEST_ONLY = 2)] = "EDITION_2_TEST_ONLY"),
    (i[(i.EDITION_99997_TEST_ONLY = 99997)] = "EDITION_99997_TEST_ONLY"),
    (i[(i.EDITION_99998_TEST_ONLY = 99998)] = "EDITION_99998_TEST_ONLY"),
    (i[(i.EDITION_99999_TEST_ONLY = 99999)] = "EDITION_99999_TEST_ONLY"),
    (i[(i.EDITION_MAX = 2147483647)] = "EDITION_MAX")
})(Rr || (Rr = {})),
  J.util.setEnumType(Rr, "google.protobuf.Edition", [
    { no: 0, name: "EDITION_UNKNOWN" },
    { no: 900, name: "EDITION_LEGACY" },
    { no: 998, name: "EDITION_PROTO2" },
    { no: 999, name: "EDITION_PROTO3" },
    { no: 1e3, name: "EDITION_2023" },
    { no: 1001, name: "EDITION_2024" },
    { no: 1, name: "EDITION_1_TEST_ONLY" },
    { no: 2, name: "EDITION_2_TEST_ONLY" },
    { no: 99997, name: "EDITION_99997_TEST_ONLY" },
    { no: 99998, name: "EDITION_99998_TEST_ONLY" },
    { no: 99999, name: "EDITION_99999_TEST_ONLY" },
    { no: 2147483647, name: "EDITION_MAX" },
  ])
var Y3t = class Lh extends d {
    constructor(t) {
      super(), (this.file = []), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.FileDescriptorSet"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "file", kind: "message", T: Lq, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Lh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Lh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Lh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Lh, t, e)
    }
  },
  Lq = class Rh extends d {
    constructor(t) {
      super(),
        (this.dependency = []),
        (this.publicDependency = []),
        (this.weakDependency = []),
        (this.messageType = []),
        (this.enumType = []),
        (this.service = []),
        (this.extension = []),
        J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.FileDescriptorProto"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "package", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "dependency", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 10,
          name: "public_dependency",
          kind: "scalar",
          T: 5,
          repeated: !0,
        },
        { no: 11, name: "weak_dependency", kind: "scalar", T: 5, repeated: !0 },
        { no: 4, name: "message_type", kind: "message", T: Oht, repeated: !0 },
        { no: 5, name: "enum_type", kind: "message", T: TQ, repeated: !0 },
        { no: 6, name: "service", kind: "message", T: Ght, repeated: !0 },
        { no: 7, name: "extension", kind: "message", T: Rq, repeated: !0 },
        { no: 8, name: "options", kind: "message", T: Yht, opt: !0 },
        { no: 9, name: "source_code_info", kind: "message", T: aft, opt: !0 },
        { no: 12, name: "syntax", kind: "scalar", T: 9, opt: !0 },
        {
          no: 14,
          name: "edition",
          kind: "enum",
          T: J.getEnumType(Rr),
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Rh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Rh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Rh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Rh, t, e)
    }
  },
  Oht = class Qc extends d {
    constructor(t) {
      super(),
        (this.field = []),
        (this.extension = []),
        (this.nestedType = []),
        (this.enumType = []),
        (this.extensionRange = []),
        (this.oneofDecl = []),
        (this.reservedRange = []),
        (this.reservedName = []),
        J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.DescriptorProto"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "field", kind: "message", T: Rq, repeated: !0 },
        { no: 6, name: "extension", kind: "message", T: Rq, repeated: !0 },
        { no: 3, name: "nested_type", kind: "message", T: Qc, repeated: !0 },
        { no: 4, name: "enum_type", kind: "message", T: TQ, repeated: !0 },
        {
          no: 5,
          name: "extension_range",
          kind: "message",
          T: qht,
          repeated: !0,
        },
        { no: 8, name: "oneof_decl", kind: "message", T: Wht, repeated: !0 },
        { no: 7, name: "options", kind: "message", T: Qht, opt: !0 },
        {
          no: 9,
          name: "reserved_range",
          kind: "message",
          T: Uht,
          repeated: !0,
        },
        { no: 10, name: "reserved_name", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Qc().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Qc().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Qc().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Qc, t, e)
    }
  },
  qht = class Dh extends d {
    constructor(t) {
      super(), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.DescriptorProto.ExtensionRange"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "start", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "end", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "options", kind: "message", T: Mht, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Dh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Dh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Dh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Dh, t, e)
    }
  },
  Uht = class Fh extends d {
    constructor(t) {
      super(), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.DescriptorProto.ReservedRange"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "start", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "end", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Fh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Fh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Fh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Fh, t, e)
    }
  },
  Mht = class _h extends d {
    constructor(t) {
      super(),
        (this.uninterpretedOption = []),
        (this.declaration = []),
        J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.ExtensionRangeOptions"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        {
          no: 999,
          name: "uninterpreted_option",
          kind: "message",
          T: Fn,
          repeated: !0,
        },
        { no: 2, name: "declaration", kind: "message", T: Hht, repeated: !0 },
        { no: 50, name: "features", kind: "message", T: Dr, opt: !0 },
        {
          no: 3,
          name: "verification",
          kind: "enum",
          T: J.getEnumType(cd),
          opt: !0,
          default: cd.UNVERIFIED,
        },
      ])
    }
    static fromBinary(t, e) {
      return new _h().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _h().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _h().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(_h, t, e)
    }
  },
  cd
;(function (i) {
  ;(i[(i.DECLARATION = 0)] = "DECLARATION"),
    (i[(i.UNVERIFIED = 1)] = "UNVERIFIED")
})(cd || (cd = {})),
  J.util.setEnumType(
    cd,
    "google.protobuf.ExtensionRangeOptions.VerificationState",
    [
      { no: 0, name: "DECLARATION" },
      { no: 1, name: "UNVERIFIED" },
    ],
  )
var Hht = class Ah extends d {
    constructor(t) {
      super(), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.ExtensionRangeOptions.Declaration"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "number", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "full_name", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "type", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "reserved", kind: "scalar", T: 8, opt: !0 },
        { no: 6, name: "repeated", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Ah().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ah().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ah().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Ah, t, e)
    }
  },
  Rq = class Bh extends d {
    constructor(t) {
      super(), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.FieldDescriptorProto"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "number", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "label", kind: "enum", T: J.getEnumType(WA), opt: !0 },
        { no: 5, name: "type", kind: "enum", T: J.getEnumType(Ae), opt: !0 },
        { no: 6, name: "type_name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "extendee", kind: "scalar", T: 9, opt: !0 },
        { no: 7, name: "default_value", kind: "scalar", T: 9, opt: !0 },
        { no: 9, name: "oneof_index", kind: "scalar", T: 5, opt: !0 },
        { no: 10, name: "json_name", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "options", kind: "message", T: Xht, opt: !0 },
        { no: 17, name: "proto3_optional", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Bh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Bh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Bh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Bh, t, e)
    }
  },
  Ae
;(function (i) {
  ;(i[(i.DOUBLE = 1)] = "DOUBLE"),
    (i[(i.FLOAT = 2)] = "FLOAT"),
    (i[(i.INT64 = 3)] = "INT64"),
    (i[(i.UINT64 = 4)] = "UINT64"),
    (i[(i.INT32 = 5)] = "INT32"),
    (i[(i.FIXED64 = 6)] = "FIXED64"),
    (i[(i.FIXED32 = 7)] = "FIXED32"),
    (i[(i.BOOL = 8)] = "BOOL"),
    (i[(i.STRING = 9)] = "STRING"),
    (i[(i.GROUP = 10)] = "GROUP"),
    (i[(i.MESSAGE = 11)] = "MESSAGE"),
    (i[(i.BYTES = 12)] = "BYTES"),
    (i[(i.UINT32 = 13)] = "UINT32"),
    (i[(i.ENUM = 14)] = "ENUM"),
    (i[(i.SFIXED32 = 15)] = "SFIXED32"),
    (i[(i.SFIXED64 = 16)] = "SFIXED64"),
    (i[(i.SINT32 = 17)] = "SINT32"),
    (i[(i.SINT64 = 18)] = "SINT64")
})(Ae || (Ae = {})),
  J.util.setEnumType(Ae, "google.protobuf.FieldDescriptorProto.Type", [
    { no: 1, name: "TYPE_DOUBLE" },
    { no: 2, name: "TYPE_FLOAT" },
    { no: 3, name: "TYPE_INT64" },
    { no: 4, name: "TYPE_UINT64" },
    { no: 5, name: "TYPE_INT32" },
    { no: 6, name: "TYPE_FIXED64" },
    { no: 7, name: "TYPE_FIXED32" },
    { no: 8, name: "TYPE_BOOL" },
    { no: 9, name: "TYPE_STRING" },
    { no: 10, name: "TYPE_GROUP" },
    { no: 11, name: "TYPE_MESSAGE" },
    { no: 12, name: "TYPE_BYTES" },
    { no: 13, name: "TYPE_UINT32" },
    { no: 14, name: "TYPE_ENUM" },
    { no: 15, name: "TYPE_SFIXED32" },
    { no: 16, name: "TYPE_SFIXED64" },
    { no: 17, name: "TYPE_SINT32" },
    { no: 18, name: "TYPE_SINT64" },
  ])
var WA
;(function (i) {
  ;(i[(i.OPTIONAL = 1)] = "OPTIONAL"),
    (i[(i.REPEATED = 3)] = "REPEATED"),
    (i[(i.REQUIRED = 2)] = "REQUIRED")
})(WA || (WA = {})),
  J.util.setEnumType(WA, "google.protobuf.FieldDescriptorProto.Label", [
    { no: 1, name: "LABEL_OPTIONAL" },
    { no: 3, name: "LABEL_REPEATED" },
    { no: 2, name: "LABEL_REQUIRED" },
  ])
var Wht = class Oh extends d {
    constructor(t) {
      super(), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.OneofDescriptorProto"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "options", kind: "message", T: Zht, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Oh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Oh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Oh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Oh, t, e)
    }
  },
  TQ = class qh extends d {
    constructor(t) {
      super(),
        (this.value = []),
        (this.reservedRange = []),
        (this.reservedName = []),
        J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.EnumDescriptorProto"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "value", kind: "message", T: Vht, repeated: !0 },
        { no: 3, name: "options", kind: "message", T: tft, opt: !0 },
        {
          no: 4,
          name: "reserved_range",
          kind: "message",
          T: jht,
          repeated: !0,
        },
        { no: 5, name: "reserved_name", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new qh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(qh, t, e)
    }
  },
  jht = class Uh extends d {
    constructor(t) {
      super(), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.EnumDescriptorProto.EnumReservedRange"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "start", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "end", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Uh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Uh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Uh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Uh, t, e)
    }
  },
  Vht = class Mh extends d {
    constructor(t) {
      super(), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.EnumValueDescriptorProto"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "number", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "options", kind: "message", T: eft, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Mh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Mh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Mh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Mh, t, e)
    }
  },
  Ght = class Hh extends d {
    constructor(t) {
      super(), (this.method = []), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.ServiceDescriptorProto"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "method", kind: "message", T: zht, repeated: !0 },
        { no: 3, name: "options", kind: "message", T: ift, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Hh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Hh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Hh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Hh, t, e)
    }
  },
  zht = class Wh extends d {
    constructor(t) {
      super(), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.MethodDescriptorProto"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "input_type", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "output_type", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "options", kind: "message", T: rft, opt: !0 },
        {
          no: 5,
          name: "client_streaming",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 6,
          name: "server_streaming",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Wh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Wh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Wh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Wh, t, e)
    }
  },
  Yht = class jh extends d {
    constructor(t) {
      super(), (this.uninterpretedOption = []), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.FileOptions"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "java_package", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "java_outer_classname", kind: "scalar", T: 9, opt: !0 },
        {
          no: 10,
          name: "java_multiple_files",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 20,
          name: "java_generate_equals_and_hash",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 27,
          name: "java_string_check_utf8",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 9,
          name: "optimize_for",
          kind: "enum",
          T: J.getEnumType(ud),
          opt: !0,
          default: ud.SPEED,
        },
        { no: 11, name: "go_package", kind: "scalar", T: 9, opt: !0 },
        {
          no: 16,
          name: "cc_generic_services",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 17,
          name: "java_generic_services",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 18,
          name: "py_generic_services",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 23,
          name: "deprecated",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 31,
          name: "cc_enable_arenas",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !0,
        },
        { no: 36, name: "objc_class_prefix", kind: "scalar", T: 9, opt: !0 },
        { no: 37, name: "csharp_namespace", kind: "scalar", T: 9, opt: !0 },
        { no: 39, name: "swift_prefix", kind: "scalar", T: 9, opt: !0 },
        { no: 40, name: "php_class_prefix", kind: "scalar", T: 9, opt: !0 },
        { no: 41, name: "php_namespace", kind: "scalar", T: 9, opt: !0 },
        {
          no: 44,
          name: "php_metadata_namespace",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        { no: 45, name: "ruby_package", kind: "scalar", T: 9, opt: !0 },
        { no: 50, name: "features", kind: "message", T: Dr, opt: !0 },
        {
          no: 999,
          name: "uninterpreted_option",
          kind: "message",
          T: Fn,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new jh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(jh, t, e)
    }
  },
  ud
;(function (i) {
  ;(i[(i.SPEED = 1)] = "SPEED"),
    (i[(i.CODE_SIZE = 2)] = "CODE_SIZE"),
    (i[(i.LITE_RUNTIME = 3)] = "LITE_RUNTIME")
})(ud || (ud = {})),
  J.util.setEnumType(ud, "google.protobuf.FileOptions.OptimizeMode", [
    { no: 1, name: "SPEED" },
    { no: 2, name: "CODE_SIZE" },
    { no: 3, name: "LITE_RUNTIME" },
  ])
var Qht = class Vh extends d {
    constructor(t) {
      super(), (this.uninterpretedOption = []), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.MessageOptions"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        {
          no: 1,
          name: "message_set_wire_format",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 2,
          name: "no_standard_descriptor_accessor",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 3,
          name: "deprecated",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        { no: 7, name: "map_entry", kind: "scalar", T: 8, opt: !0 },
        {
          no: 11,
          name: "deprecated_legacy_json_field_conflicts",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 12, name: "features", kind: "message", T: Dr, opt: !0 },
        {
          no: 999,
          name: "uninterpreted_option",
          kind: "message",
          T: Fn,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Vh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Vh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Vh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Vh, t, e)
    }
  },
  Xht = class Gh extends d {
    constructor(t) {
      super(),
        (this.targets = []),
        (this.editionDefaults = []),
        (this.uninterpretedOption = []),
        J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.FieldOptions"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        {
          no: 1,
          name: "ctype",
          kind: "enum",
          T: J.getEnumType(ld),
          opt: !0,
          default: ld.STRING,
        },
        { no: 2, name: "packed", kind: "scalar", T: 8, opt: !0 },
        {
          no: 6,
          name: "jstype",
          kind: "enum",
          T: J.getEnumType(dd),
          opt: !0,
          default: dd.JS_NORMAL,
        },
        { no: 5, name: "lazy", kind: "scalar", T: 8, opt: !0, default: !1 },
        {
          no: 15,
          name: "unverified_lazy",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 3,
          name: "deprecated",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        { no: 10, name: "weak", kind: "scalar", T: 8, opt: !0, default: !1 },
        {
          no: 16,
          name: "debug_redact",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 17,
          name: "retention",
          kind: "enum",
          T: J.getEnumType(jA),
          opt: !0,
        },
        {
          no: 19,
          name: "targets",
          kind: "enum",
          T: J.getEnumType(VA),
          repeated: !0,
        },
        {
          no: 20,
          name: "edition_defaults",
          kind: "message",
          T: Kht,
          repeated: !0,
        },
        { no: 21, name: "features", kind: "message", T: Dr, opt: !0 },
        { no: 22, name: "feature_support", kind: "message", T: kQ, opt: !0 },
        {
          no: 999,
          name: "uninterpreted_option",
          kind: "message",
          T: Fn,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Gh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Gh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Gh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Gh, t, e)
    }
  },
  ld
;(function (i) {
  ;(i[(i.STRING = 0)] = "STRING"),
    (i[(i.CORD = 1)] = "CORD"),
    (i[(i.STRING_PIECE = 2)] = "STRING_PIECE")
})(ld || (ld = {})),
  J.util.setEnumType(ld, "google.protobuf.FieldOptions.CType", [
    { no: 0, name: "STRING" },
    { no: 1, name: "CORD" },
    { no: 2, name: "STRING_PIECE" },
  ])
var dd
;(function (i) {
  ;(i[(i.JS_NORMAL = 0)] = "JS_NORMAL"),
    (i[(i.JS_STRING = 1)] = "JS_STRING"),
    (i[(i.JS_NUMBER = 2)] = "JS_NUMBER")
})(dd || (dd = {})),
  J.util.setEnumType(dd, "google.protobuf.FieldOptions.JSType", [
    { no: 0, name: "JS_NORMAL" },
    { no: 1, name: "JS_STRING" },
    { no: 2, name: "JS_NUMBER" },
  ])
var jA
;(function (i) {
  ;(i[(i.RETENTION_UNKNOWN = 0)] = "RETENTION_UNKNOWN"),
    (i[(i.RETENTION_RUNTIME = 1)] = "RETENTION_RUNTIME"),
    (i[(i.RETENTION_SOURCE = 2)] = "RETENTION_SOURCE")
})(jA || (jA = {})),
  J.util.setEnumType(jA, "google.protobuf.FieldOptions.OptionRetention", [
    { no: 0, name: "RETENTION_UNKNOWN" },
    { no: 1, name: "RETENTION_RUNTIME" },
    { no: 2, name: "RETENTION_SOURCE" },
  ])
var VA
;(function (i) {
  ;(i[(i.TARGET_TYPE_UNKNOWN = 0)] = "TARGET_TYPE_UNKNOWN"),
    (i[(i.TARGET_TYPE_FILE = 1)] = "TARGET_TYPE_FILE"),
    (i[(i.TARGET_TYPE_EXTENSION_RANGE = 2)] = "TARGET_TYPE_EXTENSION_RANGE"),
    (i[(i.TARGET_TYPE_MESSAGE = 3)] = "TARGET_TYPE_MESSAGE"),
    (i[(i.TARGET_TYPE_FIELD = 4)] = "TARGET_TYPE_FIELD"),
    (i[(i.TARGET_TYPE_ONEOF = 5)] = "TARGET_TYPE_ONEOF"),
    (i[(i.TARGET_TYPE_ENUM = 6)] = "TARGET_TYPE_ENUM"),
    (i[(i.TARGET_TYPE_ENUM_ENTRY = 7)] = "TARGET_TYPE_ENUM_ENTRY"),
    (i[(i.TARGET_TYPE_SERVICE = 8)] = "TARGET_TYPE_SERVICE"),
    (i[(i.TARGET_TYPE_METHOD = 9)] = "TARGET_TYPE_METHOD")
})(VA || (VA = {})),
  J.util.setEnumType(VA, "google.protobuf.FieldOptions.OptionTargetType", [
    { no: 0, name: "TARGET_TYPE_UNKNOWN" },
    { no: 1, name: "TARGET_TYPE_FILE" },
    { no: 2, name: "TARGET_TYPE_EXTENSION_RANGE" },
    { no: 3, name: "TARGET_TYPE_MESSAGE" },
    { no: 4, name: "TARGET_TYPE_FIELD" },
    { no: 5, name: "TARGET_TYPE_ONEOF" },
    { no: 6, name: "TARGET_TYPE_ENUM" },
    { no: 7, name: "TARGET_TYPE_ENUM_ENTRY" },
    { no: 8, name: "TARGET_TYPE_SERVICE" },
    { no: 9, name: "TARGET_TYPE_METHOD" },
  ])
var Kht = class zh extends d {
    constructor(t) {
      super(), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.FieldOptions.EditionDefault"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 3, name: "edition", kind: "enum", T: J.getEnumType(Rr), opt: !0 },
        { no: 2, name: "value", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new zh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(zh, t, e)
    }
  },
  kQ = class Yh extends d {
    constructor(t) {
      super(), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.FieldOptions.FeatureSupport"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        {
          no: 1,
          name: "edition_introduced",
          kind: "enum",
          T: J.getEnumType(Rr),
          opt: !0,
        },
        {
          no: 2,
          name: "edition_deprecated",
          kind: "enum",
          T: J.getEnumType(Rr),
          opt: !0,
        },
        { no: 3, name: "deprecation_warning", kind: "scalar", T: 9, opt: !0 },
        {
          no: 4,
          name: "edition_removed",
          kind: "enum",
          T: J.getEnumType(Rr),
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Yh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Yh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Yh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Yh, t, e)
    }
  },
  Zht = class Qh extends d {
    constructor(t) {
      super(), (this.uninterpretedOption = []), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.OneofOptions"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "features", kind: "message", T: Dr, opt: !0 },
        {
          no: 999,
          name: "uninterpreted_option",
          kind: "message",
          T: Fn,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Qh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Qh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Qh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Qh, t, e)
    }
  },
  tft = class Xh extends d {
    constructor(t) {
      super(), (this.uninterpretedOption = []), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.EnumOptions"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 2, name: "allow_alias", kind: "scalar", T: 8, opt: !0 },
        {
          no: 3,
          name: "deprecated",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 6,
          name: "deprecated_legacy_json_field_conflicts",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 7, name: "features", kind: "message", T: Dr, opt: !0 },
        {
          no: 999,
          name: "uninterpreted_option",
          kind: "message",
          T: Fn,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Xh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Xh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Xh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Xh, t, e)
    }
  },
  eft = class Kh extends d {
    constructor(t) {
      super(), (this.uninterpretedOption = []), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.EnumValueOptions"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        {
          no: 1,
          name: "deprecated",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        { no: 2, name: "features", kind: "message", T: Dr, opt: !0 },
        {
          no: 3,
          name: "debug_redact",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        { no: 4, name: "feature_support", kind: "message", T: kQ, opt: !0 },
        {
          no: 999,
          name: "uninterpreted_option",
          kind: "message",
          T: Fn,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Kh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Kh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Kh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Kh, t, e)
    }
  },
  ift = class Zh extends d {
    constructor(t) {
      super(), (this.uninterpretedOption = []), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.ServiceOptions"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 34, name: "features", kind: "message", T: Dr, opt: !0 },
        {
          no: 33,
          name: "deprecated",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 999,
          name: "uninterpreted_option",
          kind: "message",
          T: Fn,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Zh().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Zh().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Zh().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Zh, t, e)
    }
  },
  rft = class tf extends d {
    constructor(t) {
      super(), (this.uninterpretedOption = []), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.MethodOptions"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        {
          no: 33,
          name: "deprecated",
          kind: "scalar",
          T: 8,
          opt: !0,
          default: !1,
        },
        {
          no: 34,
          name: "idempotency_level",
          kind: "enum",
          T: J.getEnumType(md),
          opt: !0,
          default: md.IDEMPOTENCY_UNKNOWN,
        },
        { no: 35, name: "features", kind: "message", T: Dr, opt: !0 },
        {
          no: 999,
          name: "uninterpreted_option",
          kind: "message",
          T: Fn,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new tf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(tf, t, e)
    }
  },
  md
;(function (i) {
  ;(i[(i.IDEMPOTENCY_UNKNOWN = 0)] = "IDEMPOTENCY_UNKNOWN"),
    (i[(i.NO_SIDE_EFFECTS = 1)] = "NO_SIDE_EFFECTS"),
    (i[(i.IDEMPOTENT = 2)] = "IDEMPOTENT")
})(md || (md = {})),
  J.util.setEnumType(md, "google.protobuf.MethodOptions.IdempotencyLevel", [
    { no: 0, name: "IDEMPOTENCY_UNKNOWN" },
    { no: 1, name: "NO_SIDE_EFFECTS" },
    { no: 2, name: "IDEMPOTENT" },
  ])
var Fn = class ef extends d {
    constructor(t) {
      super(), (this.name = []), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.UninterpretedOption"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 2, name: "name", kind: "message", T: nft, repeated: !0 },
        { no: 3, name: "identifier_value", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "positive_int_value", kind: "scalar", T: 4, opt: !0 },
        { no: 5, name: "negative_int_value", kind: "scalar", T: 3, opt: !0 },
        { no: 6, name: "double_value", kind: "scalar", T: 1, opt: !0 },
        { no: 7, name: "string_value", kind: "scalar", T: 12, opt: !0 },
        { no: 8, name: "aggregate_value", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ef().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ef().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ef().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(ef, t, e)
    }
  },
  nft = class rf extends d {
    constructor(t) {
      super(), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.UninterpretedOption.NamePart"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "name_part", kind: "scalar", T: 9, req: !0 },
        { no: 2, name: "is_extension", kind: "scalar", T: 8, req: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new rf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(rf, t, e)
    }
  },
  Dr = class nf extends d {
    constructor(t) {
      super(), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.FeatureSet"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        {
          no: 1,
          name: "field_presence",
          kind: "enum",
          T: J.getEnumType(GA),
          opt: !0,
        },
        {
          no: 2,
          name: "enum_type",
          kind: "enum",
          T: J.getEnumType(zA),
          opt: !0,
        },
        {
          no: 3,
          name: "repeated_field_encoding",
          kind: "enum",
          T: J.getEnumType(YA),
          opt: !0,
        },
        {
          no: 4,
          name: "utf8_validation",
          kind: "enum",
          T: J.getEnumType(QA),
          opt: !0,
        },
        {
          no: 5,
          name: "message_encoding",
          kind: "enum",
          T: J.getEnumType(XA),
          opt: !0,
        },
        {
          no: 6,
          name: "json_format",
          kind: "enum",
          T: J.getEnumType(KA),
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new nf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(nf, t, e)
    }
  },
  GA
;(function (i) {
  ;(i[(i.FIELD_PRESENCE_UNKNOWN = 0)] = "FIELD_PRESENCE_UNKNOWN"),
    (i[(i.EXPLICIT = 1)] = "EXPLICIT"),
    (i[(i.IMPLICIT = 2)] = "IMPLICIT"),
    (i[(i.LEGACY_REQUIRED = 3)] = "LEGACY_REQUIRED")
})(GA || (GA = {})),
  J.util.setEnumType(GA, "google.protobuf.FeatureSet.FieldPresence", [
    { no: 0, name: "FIELD_PRESENCE_UNKNOWN" },
    { no: 1, name: "EXPLICIT" },
    { no: 2, name: "IMPLICIT" },
    { no: 3, name: "LEGACY_REQUIRED" },
  ])
var zA
;(function (i) {
  ;(i[(i.ENUM_TYPE_UNKNOWN = 0)] = "ENUM_TYPE_UNKNOWN"),
    (i[(i.OPEN = 1)] = "OPEN"),
    (i[(i.CLOSED = 2)] = "CLOSED")
})(zA || (zA = {})),
  J.util.setEnumType(zA, "google.protobuf.FeatureSet.EnumType", [
    { no: 0, name: "ENUM_TYPE_UNKNOWN" },
    { no: 1, name: "OPEN" },
    { no: 2, name: "CLOSED" },
  ])
var YA
;(function (i) {
  ;(i[(i.REPEATED_FIELD_ENCODING_UNKNOWN = 0)] =
    "REPEATED_FIELD_ENCODING_UNKNOWN"),
    (i[(i.PACKED = 1)] = "PACKED"),
    (i[(i.EXPANDED = 2)] = "EXPANDED")
})(YA || (YA = {})),
  J.util.setEnumType(YA, "google.protobuf.FeatureSet.RepeatedFieldEncoding", [
    { no: 0, name: "REPEATED_FIELD_ENCODING_UNKNOWN" },
    { no: 1, name: "PACKED" },
    { no: 2, name: "EXPANDED" },
  ])
var QA
;(function (i) {
  ;(i[(i.UTF8_VALIDATION_UNKNOWN = 0)] = "UTF8_VALIDATION_UNKNOWN"),
    (i[(i.VERIFY = 2)] = "VERIFY"),
    (i[(i.NONE = 3)] = "NONE")
})(QA || (QA = {})),
  J.util.setEnumType(QA, "google.protobuf.FeatureSet.Utf8Validation", [
    { no: 0, name: "UTF8_VALIDATION_UNKNOWN" },
    { no: 2, name: "VERIFY" },
    { no: 3, name: "NONE" },
  ])
var XA
;(function (i) {
  ;(i[(i.MESSAGE_ENCODING_UNKNOWN = 0)] = "MESSAGE_ENCODING_UNKNOWN"),
    (i[(i.LENGTH_PREFIXED = 1)] = "LENGTH_PREFIXED"),
    (i[(i.DELIMITED = 2)] = "DELIMITED")
})(XA || (XA = {})),
  J.util.setEnumType(XA, "google.protobuf.FeatureSet.MessageEncoding", [
    { no: 0, name: "MESSAGE_ENCODING_UNKNOWN" },
    { no: 1, name: "LENGTH_PREFIXED" },
    { no: 2, name: "DELIMITED" },
  ])
var KA
;(function (i) {
  ;(i[(i.JSON_FORMAT_UNKNOWN = 0)] = "JSON_FORMAT_UNKNOWN"),
    (i[(i.ALLOW = 1)] = "ALLOW"),
    (i[(i.LEGACY_BEST_EFFORT = 2)] = "LEGACY_BEST_EFFORT")
})(KA || (KA = {})),
  J.util.setEnumType(KA, "google.protobuf.FeatureSet.JsonFormat", [
    { no: 0, name: "JSON_FORMAT_UNKNOWN" },
    { no: 1, name: "ALLOW" },
    { no: 2, name: "LEGACY_BEST_EFFORT" },
  ])
var Q3t = class sf extends d {
    constructor(t) {
      super(), (this.defaults = []), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.FeatureSetDefaults"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "defaults", kind: "message", T: sft, repeated: !0 },
        {
          no: 4,
          name: "minimum_edition",
          kind: "enum",
          T: J.getEnumType(Rr),
          opt: !0,
        },
        {
          no: 5,
          name: "maximum_edition",
          kind: "enum",
          T: J.getEnumType(Rr),
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new sf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(sf, t, e)
    }
  },
  sft = class af extends d {
    constructor(t) {
      super(), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName =
        "google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 3, name: "edition", kind: "enum", T: J.getEnumType(Rr), opt: !0 },
        {
          no: 4,
          name: "overridable_features",
          kind: "message",
          T: Dr,
          opt: !0,
        },
        { no: 5, name: "fixed_features", kind: "message", T: Dr, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new af().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new af().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new af().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(af, t, e)
    }
  },
  aft = class of extends d {
    constructor(t) {
      super(), (this.location = []), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.SourceCodeInfo"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "location", kind: "message", T: oft, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new of().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new of().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new of().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(of, t, e)
    }
  },
  oft = class cf extends d {
    constructor(t) {
      super(),
        (this.path = []),
        (this.span = []),
        (this.leadingDetachedComments = []),
        J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.SourceCodeInfo.Location"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "path", kind: "scalar", T: 5, repeated: !0, packed: !0 },
        { no: 2, name: "span", kind: "scalar", T: 5, repeated: !0, packed: !0 },
        { no: 3, name: "leading_comments", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "trailing_comments", kind: "scalar", T: 9, opt: !0 },
        {
          no: 6,
          name: "leading_detached_comments",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new cf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(cf, t, e)
    }
  },
  cft = class uf extends d {
    constructor(t) {
      super(), (this.annotation = []), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.GeneratedCodeInfo"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "annotation", kind: "message", T: uft, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new uf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(uf, t, e)
    }
  },
  uft = class lf extends d {
    constructor(t) {
      super(), (this.path = []), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.GeneratedCodeInfo.Annotation"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "path", kind: "scalar", T: 5, repeated: !0, packed: !0 },
        { no: 2, name: "source_file", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "begin", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "end", kind: "scalar", T: 5, opt: !0 },
        {
          no: 5,
          name: "semantic",
          kind: "enum",
          T: J.getEnumType(ZA),
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new lf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(lf, t, e)
    }
  },
  ZA
;(function (i) {
  ;(i[(i.NONE = 0)] = "NONE"),
    (i[(i.SET = 1)] = "SET"),
    (i[(i.ALIAS = 2)] = "ALIAS")
})(ZA || (ZA = {})),
  J.util.setEnumType(
    ZA,
    "google.protobuf.GeneratedCodeInfo.Annotation.Semantic",
    [
      { no: 0, name: "NONE" },
      { no: 1, name: "SET" },
      { no: 2, name: "ALIAS" },
    ],
  )
var X3t = {
    [Ae.DOUBLE]: A.DOUBLE,
    [Ae.FLOAT]: A.FLOAT,
    [Ae.INT64]: A.INT64,
    [Ae.UINT64]: A.UINT64,
    [Ae.INT32]: A.INT32,
    [Ae.FIXED64]: A.FIXED64,
    [Ae.FIXED32]: A.FIXED32,
    [Ae.BOOL]: A.BOOL,
    [Ae.STRING]: A.STRING,
    [Ae.GROUP]: void 0,
    [Ae.MESSAGE]: void 0,
    [Ae.BYTES]: A.BYTES,
    [Ae.UINT32]: A.UINT32,
    [Ae.ENUM]: void 0,
    [Ae.SFIXED32]: A.SFIXED32,
    [Ae.SFIXED64]: A.SFIXED64,
    [Ae.SINT32]: A.SINT32,
    [Ae.SINT64]: A.SINT64,
  },
  SQ
;(function (i) {
  ;(i[(i.FileDescriptorProto_Package = 2)] = "FileDescriptorProto_Package"),
    (i[(i.FileDescriptorProto_MessageType = 4)] =
      "FileDescriptorProto_MessageType"),
    (i[(i.FileDescriptorProto_EnumType = 5)] = "FileDescriptorProto_EnumType"),
    (i[(i.FileDescriptorProto_Service = 6)] = "FileDescriptorProto_Service"),
    (i[(i.FileDescriptorProto_Extension = 7)] =
      "FileDescriptorProto_Extension"),
    (i[(i.FileDescriptorProto_Syntax = 12)] = "FileDescriptorProto_Syntax"),
    (i[(i.DescriptorProto_Field = 2)] = "DescriptorProto_Field"),
    (i[(i.DescriptorProto_NestedType = 3)] = "DescriptorProto_NestedType"),
    (i[(i.DescriptorProto_EnumType = 4)] = "DescriptorProto_EnumType"),
    (i[(i.DescriptorProto_Extension = 6)] = "DescriptorProto_Extension"),
    (i[(i.DescriptorProto_OneofDecl = 8)] = "DescriptorProto_OneofDecl"),
    (i[(i.EnumDescriptorProto_Value = 2)] = "EnumDescriptorProto_Value"),
    (i[(i.ServiceDescriptorProto_Method = 2)] = "ServiceDescriptorProto_Method")
})(SQ || (SQ = {}))
var bQ = class Za extends d {
    constructor(t) {
      super(),
        (this.seconds = Pe.zero),
        (this.nanos = 0),
        n.util.initPartial(t, this)
    }
    fromJson(t, e) {
      if (typeof t != "string")
        throw new Error(
          `cannot decode google.protobuf.Timestamp from JSON: ${n.json.debug(t)}`,
        )
      const r = t.match(
        /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/,
      )
      if (!r)
        throw new Error(
          "cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string",
        )
      const s = Date.parse(
        r[1] +
          "-" +
          r[2] +
          "-" +
          r[3] +
          "T" +
          r[4] +
          ":" +
          r[5] +
          ":" +
          r[6] +
          (r[8] ? r[8] : "Z"),
      )
      if (Number.isNaN(s))
        throw new Error(
          "cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string",
        )
      if (
        s < Date.parse("0001-01-01T00:00:00Z") ||
        s > Date.parse("9999-12-31T23:59:59Z")
      )
        throw new Error(
          "cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive",
        )
      return (
        (this.seconds = Pe.parse(s / 1e3)),
        (this.nanos = 0),
        r[7] &&
          (this.nanos =
            parseInt("1" + r[7] + "0".repeat(9 - r[7].length)) - 1e9),
        this
      )
    }
    toJson(t) {
      const e = Number(this.seconds) * 1e3
      if (
        e < Date.parse("0001-01-01T00:00:00Z") ||
        e > Date.parse("9999-12-31T23:59:59Z")
      )
        throw new Error(
          "cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive",
        )
      if (this.nanos < 0)
        throw new Error(
          "cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative",
        )
      let r = "Z"
      if (this.nanos > 0) {
        const s = (this.nanos + 1e9).toString().substring(1)
        s.substring(3) === "000000"
          ? (r = "." + s.substring(0, 3) + "Z")
          : s.substring(6) === "000"
            ? (r = "." + s.substring(0, 6) + "Z")
            : (r = "." + s + "Z")
      }
      return new Date(e).toISOString().replace(".000Z", r)
    }
    toDate() {
      return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6))
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Timestamp"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "seconds", kind: "scalar", T: 3 },
        { no: 2, name: "nanos", kind: "scalar", T: 5 },
      ])
    }
    static now() {
      return Za.fromDate(new Date())
    }
    static fromDate(t) {
      const e = t.getTime()
      return new Za({
        seconds: Pe.parse(Math.floor(e / 1e3)),
        nanos: (e % 1e3) * 1e6,
      })
    }
    static fromBinary(t, e) {
      return new Za().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Za().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Za().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Za, t, e)
    }
  },
  K3t = class df extends d {
    constructor(t) {
      super(),
        (this.seconds = Pe.zero),
        (this.nanos = 0),
        n.util.initPartial(t, this)
    }
    fromJson(t, e) {
      if (typeof t != "string")
        throw new Error(
          `cannot decode google.protobuf.Duration from JSON: ${n.json.debug(t)}`,
        )
      const r = t.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/)
      if (r === null)
        throw new Error(
          `cannot decode google.protobuf.Duration from JSON: ${n.json.debug(t)}`,
        )
      const s = Number(r[1])
      if (s > 315576e6 || s < -315576e6)
        throw new Error(
          `cannot decode google.protobuf.Duration from JSON: ${n.json.debug(t)}`,
        )
      if (((this.seconds = Pe.parse(s)), typeof r[2] == "string")) {
        const a = r[2] + "0".repeat(9 - r[2].length)
        ;(this.nanos = parseInt(a)),
          (s < 0 || Object.is(s, -0)) && (this.nanos = -this.nanos)
      }
      return this
    }
    toJson(t) {
      if (Number(this.seconds) > 315576e6 || Number(this.seconds) < -315576e6)
        throw new Error(
          "cannot encode google.protobuf.Duration to JSON: value out of range",
        )
      let e = this.seconds.toString()
      if (this.nanos !== 0) {
        let r = Math.abs(this.nanos).toString()
        ;(r = "0".repeat(9 - r.length) + r),
          r.substring(3) === "000000"
            ? (r = r.substring(0, 3))
            : r.substring(6) === "000" && (r = r.substring(0, 6)),
          (e += "." + r),
          this.nanos < 0 && Number(this.seconds) == 0 && (e = "-" + e)
      }
      return e + "s"
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Duration"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "seconds", kind: "scalar", T: 3 },
        { no: 2, name: "nanos", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new df().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new df().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new df().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(df, t, e)
    }
  },
  lft = class Xc extends d {
    constructor(t) {
      super(),
        (this.typeUrl = ""),
        (this.value = new Uint8Array(0)),
        n.util.initPartial(t, this)
    }
    toJson(t) {
      if (this.typeUrl === "") return {}
      const e = this.typeUrlToName(this.typeUrl),
        r = t?.typeRegistry?.findMessage(e)
      if (!r)
        throw new Error(
          `cannot encode message google.protobuf.Any to JSON: "${this.typeUrl}" is not in the type registry`,
        )
      let a = r.fromBinary(this.value).toJson(t)
      return (
        (e.startsWith("google.protobuf.") ||
          a === null ||
          Array.isArray(a) ||
          typeof a != "object") &&
          (a = { value: a }),
        (a["@type"] = this.typeUrl),
        a
      )
    }
    fromJson(t, e) {
      if (t === null || Array.isArray(t) || typeof t != "object")
        throw new Error(
          `cannot decode message google.protobuf.Any from JSON: expected object but got ${t === null ? "null" : Array.isArray(t) ? "array" : typeof t}`,
        )
      if (Object.keys(t).length == 0) return this
      const r = t["@type"]
      if (typeof r != "string" || r == "")
        throw new Error(
          'cannot decode message google.protobuf.Any from JSON: "@type" is empty',
        )
      const s = this.typeUrlToName(r),
        a = e?.typeRegistry?.findMessage(s)
      if (!a)
        throw new Error(
          `cannot decode message google.protobuf.Any from JSON: ${r} is not in the type registry`,
        )
      let o
      if (
        s.startsWith("google.protobuf.") &&
        Object.prototype.hasOwnProperty.call(t, "value")
      )
        o = a.fromJson(t.value, e)
      else {
        const c = Object.assign({}, t)
        delete c["@type"], (o = a.fromJson(c, e))
      }
      return this.packFrom(o), this
    }
    packFrom(t) {
      ;(this.value = t.toBinary()),
        (this.typeUrl = this.typeNameToUrl(t.getType().typeName))
    }
    unpackTo(t) {
      return this.is(t.getType()) ? (t.fromBinary(this.value), !0) : !1
    }
    unpack(t) {
      if (this.typeUrl === "") return
      const e = t.findMessage(this.typeUrlToName(this.typeUrl))
      if (e) return e.fromBinary(this.value)
    }
    is(t) {
      if (this.typeUrl === "") return !1
      const e = this.typeUrlToName(this.typeUrl)
      let r = ""
      return typeof t == "string" ? (r = t) : (r = t.typeName), e === r
    }
    typeNameToUrl(t) {
      return `type.googleapis.com/${t}`
    }
    typeUrlToName(t) {
      if (!t.length) throw new Error(`invalid type url: ${t}`)
      const e = t.lastIndexOf("/"),
        r = e >= 0 ? t.substring(e + 1) : t
      if (!r.length) throw new Error(`invalid type url: ${t}`)
      return r
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Any"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type_url", kind: "scalar", T: 9 },
        { no: 2, name: "value", kind: "scalar", T: 12 },
      ])
    }
    static pack(t) {
      const e = new Xc()
      return e.packFrom(t), e
    }
    static fromBinary(t, e) {
      return new Xc().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Xc().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Xc().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Xc, t, e)
    }
  },
  Z3t = class mf extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Empty"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new mf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mf, t, e)
    }
  },
  tOt = class hf extends d {
    constructor(t) {
      super(), (this.paths = []), n.util.initPartial(t, this)
    }
    toJson(t) {
      function e(r) {
        let s = !1
        const a = []
        for (let o = 0; o < r.length; o++) {
          let c = r.charAt(o)
          switch (c) {
            case "_":
              s = !0
              break
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              a.push(c), (s = !1)
              break
            default:
              s && ((s = !1), (c = c.toUpperCase())), a.push(c)
              break
          }
        }
        return a.join("")
      }
      return this.paths
        .map((r) => {
          if (r.match(/_[0-9]?_/g) || r.match(/[A-Z]/g))
            throw new Error(
              'cannot encode google.protobuf.FieldMask to JSON: lowerCamelCase of path name "' +
                r +
                '" is irreversible',
            )
          return e(r)
        })
        .join(",")
    }
    fromJson(t, e) {
      if (typeof t != "string")
        throw new Error(
          "cannot decode google.protobuf.FieldMask from JSON: " +
            n.json.debug(t),
        )
      if (t === "") return this
      function r(s) {
        if (s.includes("_"))
          throw new Error(
            "cannot decode google.protobuf.FieldMask from JSON: path names must be lowerCamelCase",
          )
        const a = s.replace(/[A-Z]/g, (o) => "_" + o.toLowerCase())
        return a[0] === "_" ? a.substring(1) : a
      }
      return (this.paths = t.split(",").map(r)), this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.FieldMask"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "paths", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new hf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hf, t, e)
    }
  },
  wc
;(function (i) {
  i[(i.NULL_VALUE = 0)] = "NULL_VALUE"
})(wc || (wc = {})),
  n.util.setEnumType(wc, "google.protobuf.NullValue", [
    { no: 0, name: "NULL_VALUE" },
  ])
var EQ = class ff extends d {
    constructor(t) {
      super(), (this.fields = {}), n.util.initPartial(t, this)
    }
    toJson(t) {
      const e = {}
      for (const [r, s] of Object.entries(this.fields)) e[r] = s.toJson(t)
      return e
    }
    fromJson(t, e) {
      if (typeof t != "object" || t == null || Array.isArray(t))
        throw new Error(
          "cannot decode google.protobuf.Struct from JSON " + n.json.debug(t),
        )
      for (const [r, s] of Object.entries(t)) this.fields[r] = t7.fromJson(s)
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Struct"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "fields",
          kind: "map",
          K: 9,
          V: { kind: "message", T: t7 },
        },
      ])
    }
    static fromBinary(t, e) {
      return new ff().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ff().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ff().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ff, t, e)
    }
  },
  t7 = class pf extends d {
    constructor(t) {
      super(), (this.kind = { case: void 0 }), n.util.initPartial(t, this)
    }
    toJson(t) {
      switch (this.kind.case) {
        case "nullValue":
          return null
        case "numberValue":
          if (!Number.isFinite(this.kind.value))
            throw new Error("google.protobuf.Value cannot be NaN or Infinity")
          return this.kind.value
        case "boolValue":
          return this.kind.value
        case "stringValue":
          return this.kind.value
        case "structValue":
        case "listValue":
          return this.kind.value.toJson({ ...t, emitDefaultValues: !0 })
      }
      throw new Error("google.protobuf.Value must have a value")
    }
    fromJson(t, e) {
      switch (typeof t) {
        case "number":
          this.kind = { case: "numberValue", value: t }
          break
        case "string":
          this.kind = { case: "stringValue", value: t }
          break
        case "boolean":
          this.kind = { case: "boolValue", value: t }
          break
        case "object":
          t === null
            ? (this.kind = { case: "nullValue", value: wc.NULL_VALUE })
            : Array.isArray(t)
              ? (this.kind = { case: "listValue", value: IQ.fromJson(t) })
              : (this.kind = { case: "structValue", value: EQ.fromJson(t) })
          break
        default:
          throw new Error(
            "cannot decode google.protobuf.Value from JSON " + n.json.debug(t),
          )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Value"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "null_value",
          kind: "enum",
          T: n.getEnumType(wc),
          oneof: "kind",
        },
        { no: 2, name: "number_value", kind: "scalar", T: 1, oneof: "kind" },
        { no: 3, name: "string_value", kind: "scalar", T: 9, oneof: "kind" },
        { no: 4, name: "bool_value", kind: "scalar", T: 8, oneof: "kind" },
        { no: 5, name: "struct_value", kind: "message", T: EQ, oneof: "kind" },
        { no: 6, name: "list_value", kind: "message", T: IQ, oneof: "kind" },
      ])
    }
    static fromBinary(t, e) {
      return new pf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pf, t, e)
    }
  },
  IQ = class gf extends d {
    constructor(t) {
      super(), (this.values = []), n.util.initPartial(t, this)
    }
    toJson(t) {
      return this.values.map((e) => e.toJson())
    }
    fromJson(t, e) {
      if (!Array.isArray(t))
        throw new Error(
          "cannot decode google.protobuf.ListValue from JSON " +
            n.json.debug(t),
        )
      for (let r of t) this.values.push(t7.fromJson(r))
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.ListValue"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "values", kind: "message", T: t7, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new gf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gf, t, e)
    }
  },
  eOt = class Kc extends d {
    constructor(t) {
      super(), (this.value = 0), n.util.initPartial(t, this)
    }
    toJson(t) {
      return n.json.writeScalar(A.DOUBLE, this.value, !0)
    }
    fromJson(t, e) {
      try {
        this.value = n.json.readScalar(A.DOUBLE, t)
      } catch (r) {
        let s = 'cannot decode message google.protobuf.DoubleValue from JSON"'
        throw (
          (r instanceof Error &&
            r.message.length > 0 &&
            (s += `: ${r.message}`),
          new Error(s))
        )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.DoubleValue"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 1 },
      ])
    }
    static {
      this.fieldWrapper = {
        wrapField(t) {
          return new Kc({ value: t })
        },
        unwrapField(t) {
          return t.value
        },
      }
    }
    static fromBinary(t, e) {
      return new Kc().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Kc().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Kc().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Kc, t, e)
    }
  },
  iOt = class Zc extends d {
    constructor(t) {
      super(), (this.value = 0), n.util.initPartial(t, this)
    }
    toJson(t) {
      return n.json.writeScalar(A.FLOAT, this.value, !0)
    }
    fromJson(t, e) {
      try {
        this.value = n.json.readScalar(A.FLOAT, t)
      } catch (r) {
        let s = 'cannot decode message google.protobuf.FloatValue from JSON"'
        throw (
          (r instanceof Error &&
            r.message.length > 0 &&
            (s += `: ${r.message}`),
          new Error(s))
        )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.FloatValue"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 2 },
      ])
    }
    static {
      this.fieldWrapper = {
        wrapField(t) {
          return new Zc({ value: t })
        },
        unwrapField(t) {
          return t.value
        },
      }
    }
    static fromBinary(t, e) {
      return new Zc().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Zc().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Zc().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Zc, t, e)
    }
  },
  rOt = class tu extends d {
    constructor(t) {
      super(), (this.value = Pe.zero), n.util.initPartial(t, this)
    }
    toJson(t) {
      return n.json.writeScalar(A.INT64, this.value, !0)
    }
    fromJson(t, e) {
      try {
        this.value = n.json.readScalar(A.INT64, t)
      } catch (r) {
        let s = 'cannot decode message google.protobuf.Int64Value from JSON"'
        throw (
          (r instanceof Error &&
            r.message.length > 0 &&
            (s += `: ${r.message}`),
          new Error(s))
        )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Int64Value"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 3 },
      ])
    }
    static {
      this.fieldWrapper = {
        wrapField(t) {
          return new tu({ value: t })
        },
        unwrapField(t) {
          return t.value
        },
      }
    }
    static fromBinary(t, e) {
      return new tu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tu, t, e)
    }
  },
  nOt = class eu extends d {
    constructor(t) {
      super(), (this.value = Pe.zero), n.util.initPartial(t, this)
    }
    toJson(t) {
      return n.json.writeScalar(A.UINT64, this.value, !0)
    }
    fromJson(t, e) {
      try {
        this.value = n.json.readScalar(A.UINT64, t)
      } catch (r) {
        let s = 'cannot decode message google.protobuf.UInt64Value from JSON"'
        throw (
          (r instanceof Error &&
            r.message.length > 0 &&
            (s += `: ${r.message}`),
          new Error(s))
        )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.UInt64Value"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 4 },
      ])
    }
    static {
      this.fieldWrapper = {
        wrapField(t) {
          return new eu({ value: t })
        },
        unwrapField(t) {
          return t.value
        },
      }
    }
    static fromBinary(t, e) {
      return new eu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eu, t, e)
    }
  },
  sOt = class iu extends d {
    constructor(t) {
      super(), (this.value = 0), n.util.initPartial(t, this)
    }
    toJson(t) {
      return n.json.writeScalar(A.INT32, this.value, !0)
    }
    fromJson(t, e) {
      try {
        this.value = n.json.readScalar(A.INT32, t)
      } catch (r) {
        let s = 'cannot decode message google.protobuf.Int32Value from JSON"'
        throw (
          (r instanceof Error &&
            r.message.length > 0 &&
            (s += `: ${r.message}`),
          new Error(s))
        )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Int32Value"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 5 },
      ])
    }
    static {
      this.fieldWrapper = {
        wrapField(t) {
          return new iu({ value: t })
        },
        unwrapField(t) {
          return t.value
        },
      }
    }
    static fromBinary(t, e) {
      return new iu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iu, t, e)
    }
  },
  aOt = class ru extends d {
    constructor(t) {
      super(), (this.value = 0), n.util.initPartial(t, this)
    }
    toJson(t) {
      return n.json.writeScalar(A.UINT32, this.value, !0)
    }
    fromJson(t, e) {
      try {
        this.value = n.json.readScalar(A.UINT32, t)
      } catch (r) {
        let s = 'cannot decode message google.protobuf.UInt32Value from JSON"'
        throw (
          (r instanceof Error &&
            r.message.length > 0 &&
            (s += `: ${r.message}`),
          new Error(s))
        )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.UInt32Value"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 13 },
      ])
    }
    static {
      this.fieldWrapper = {
        wrapField(t) {
          return new ru({ value: t })
        },
        unwrapField(t) {
          return t.value
        },
      }
    }
    static fromBinary(t, e) {
      return new ru().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ru().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ru().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ru, t, e)
    }
  },
  oOt = class nu extends d {
    constructor(t) {
      super(), (this.value = !1), n.util.initPartial(t, this)
    }
    toJson(t) {
      return n.json.writeScalar(A.BOOL, this.value, !0)
    }
    fromJson(t, e) {
      try {
        this.value = n.json.readScalar(A.BOOL, t)
      } catch (r) {
        let s = 'cannot decode message google.protobuf.BoolValue from JSON"'
        throw (
          (r instanceof Error &&
            r.message.length > 0 &&
            (s += `: ${r.message}`),
          new Error(s))
        )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.BoolValue"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 8 },
      ])
    }
    static {
      this.fieldWrapper = {
        wrapField(t) {
          return new nu({ value: t })
        },
        unwrapField(t) {
          return t.value
        },
      }
    }
    static fromBinary(t, e) {
      return new nu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nu, t, e)
    }
  },
  cOt = class su extends d {
    constructor(t) {
      super(), (this.value = ""), n.util.initPartial(t, this)
    }
    toJson(t) {
      return n.json.writeScalar(A.STRING, this.value, !0)
    }
    fromJson(t, e) {
      try {
        this.value = n.json.readScalar(A.STRING, t)
      } catch (r) {
        let s = 'cannot decode message google.protobuf.StringValue from JSON"'
        throw (
          (r instanceof Error &&
            r.message.length > 0 &&
            (s += `: ${r.message}`),
          new Error(s))
        )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.StringValue"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 9 },
      ])
    }
    static {
      this.fieldWrapper = {
        wrapField(t) {
          return new su({ value: t })
        },
        unwrapField(t) {
          return t.value
        },
      }
    }
    static fromBinary(t, e) {
      return new su().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new su().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new su().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(su, t, e)
    }
  },
  uOt = class au extends d {
    constructor(t) {
      super(), (this.value = new Uint8Array(0)), n.util.initPartial(t, this)
    }
    toJson(t) {
      return n.json.writeScalar(A.BYTES, this.value, !0)
    }
    fromJson(t, e) {
      try {
        this.value = n.json.readScalar(A.BYTES, t)
      } catch (r) {
        let s = 'cannot decode message google.protobuf.BytesValue from JSON"'
        throw (
          (r instanceof Error &&
            r.message.length > 0 &&
            (s += `: ${r.message}`),
          new Error(s))
        )
      }
      return this
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.BytesValue"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 12 },
      ])
    }
    static {
      this.fieldWrapper = {
        wrapField(t) {
          return new au({ value: t })
        },
        unwrapField(t) {
          return t.value
        },
      }
    }
    static fromBinary(t, e) {
      return new au().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new au().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new au().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(au, t, e)
    }
  },
  lOt = [qY(wc)],
  dft = class vf extends d {
    constructor(t) {
      super(), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.compiler.Version"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "major", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "minor", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "patch", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "suffix", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new vf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(vf, t, e)
    }
  },
  dOt = class wf extends d {
    constructor(t) {
      super(),
        (this.fileToGenerate = []),
        (this.protoFile = []),
        (this.sourceFileDescriptors = []),
        J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.compiler.CodeGeneratorRequest"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "file_to_generate", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "parameter", kind: "scalar", T: 9, opt: !0 },
        { no: 15, name: "proto_file", kind: "message", T: Lq, repeated: !0 },
        {
          no: 17,
          name: "source_file_descriptors",
          kind: "message",
          T: Lq,
          repeated: !0,
        },
        { no: 3, name: "compiler_version", kind: "message", T: dft, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new wf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(wf, t, e)
    }
  },
  mOt = class yf extends d {
    constructor(t) {
      super(), (this.file = []), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.compiler.CodeGeneratorResponse"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "error", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "supported_features", kind: "scalar", T: 4, opt: !0 },
        { no: 3, name: "minimum_edition", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "maximum_edition", kind: "scalar", T: 5, opt: !0 },
        { no: 15, name: "file", kind: "message", T: mft, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new yf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(yf, t, e)
    }
  },
  Dq
;(function (i) {
  ;(i[(i.NONE = 0)] = "NONE"),
    (i[(i.PROTO3_OPTIONAL = 1)] = "PROTO3_OPTIONAL"),
    (i[(i.SUPPORTS_EDITIONS = 2)] = "SUPPORTS_EDITIONS")
})(Dq || (Dq = {})),
  J.util.setEnumType(
    Dq,
    "google.protobuf.compiler.CodeGeneratorResponse.Feature",
    [
      { no: 0, name: "FEATURE_NONE" },
      { no: 1, name: "FEATURE_PROTO3_OPTIONAL" },
      { no: 2, name: "FEATURE_SUPPORTS_EDITIONS" },
    ],
  )
var mft = class Tf extends d {
    constructor(t) {
      super(), J.util.initPartial(t, this)
    }
    static {
      this.runtime = J
    }
    static {
      this.typeName = "google.protobuf.compiler.CodeGeneratorResponse.File"
    }
    static {
      this.fields = J.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "insertion_point", kind: "scalar", T: 9, opt: !0 },
        { no: 15, name: "content", kind: "scalar", T: 9, opt: !0 },
        {
          no: 16,
          name: "generated_code_info",
          kind: "message",
          T: cft,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Tf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Tf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Tf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return J.util.equals(Tf, t, e)
    }
  },
  Fq = class kf extends d {
    constructor(t) {
      super(), (this.fileName = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.SourceContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new kf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kf, t, e)
    }
  },
  Fr
;(function (i) {
  ;(i[(i.PROTO2 = 0)] = "PROTO2"),
    (i[(i.PROTO3 = 1)] = "PROTO3"),
    (i[(i.EDITIONS = 2)] = "EDITIONS")
})(Fr || (Fr = {})),
  n.util.setEnumType(Fr, "google.protobuf.Syntax", [
    { no: 0, name: "SYNTAX_PROTO2" },
    { no: 1, name: "SYNTAX_PROTO3" },
    { no: 2, name: "SYNTAX_EDITIONS" },
  ])
var hOt = class Sf extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.fields = []),
        (this.oneofs = []),
        (this.options = []),
        (this.syntax = Fr.PROTO2),
        (this.edition = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Type"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "fields", kind: "message", T: hft, repeated: !0 },
        { no: 3, name: "oneofs", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "options", kind: "message", T: yc, repeated: !0 },
        { no: 5, name: "source_context", kind: "message", T: Fq },
        { no: 6, name: "syntax", kind: "enum", T: n.getEnumType(Fr) },
        { no: 7, name: "edition", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Sf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Sf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Sf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Sf, t, e)
    }
  },
  hft = class bf extends d {
    constructor(t) {
      super(),
        (this.kind = hd.TYPE_UNKNOWN),
        (this.cardinality = fd.UNKNOWN),
        (this.number = 0),
        (this.name = ""),
        (this.typeUrl = ""),
        (this.oneofIndex = 0),
        (this.packed = !1),
        (this.options = []),
        (this.jsonName = ""),
        (this.defaultValue = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Field"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "kind", kind: "enum", T: n.getEnumType(hd) },
        { no: 2, name: "cardinality", kind: "enum", T: n.getEnumType(fd) },
        { no: 3, name: "number", kind: "scalar", T: 5 },
        { no: 4, name: "name", kind: "scalar", T: 9 },
        { no: 6, name: "type_url", kind: "scalar", T: 9 },
        { no: 7, name: "oneof_index", kind: "scalar", T: 5 },
        { no: 8, name: "packed", kind: "scalar", T: 8 },
        { no: 9, name: "options", kind: "message", T: yc, repeated: !0 },
        { no: 10, name: "json_name", kind: "scalar", T: 9 },
        { no: 11, name: "default_value", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new bf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bf, t, e)
    }
  },
  hd
;(function (i) {
  ;(i[(i.TYPE_UNKNOWN = 0)] = "TYPE_UNKNOWN"),
    (i[(i.TYPE_DOUBLE = 1)] = "TYPE_DOUBLE"),
    (i[(i.TYPE_FLOAT = 2)] = "TYPE_FLOAT"),
    (i[(i.TYPE_INT64 = 3)] = "TYPE_INT64"),
    (i[(i.TYPE_UINT64 = 4)] = "TYPE_UINT64"),
    (i[(i.TYPE_INT32 = 5)] = "TYPE_INT32"),
    (i[(i.TYPE_FIXED64 = 6)] = "TYPE_FIXED64"),
    (i[(i.TYPE_FIXED32 = 7)] = "TYPE_FIXED32"),
    (i[(i.TYPE_BOOL = 8)] = "TYPE_BOOL"),
    (i[(i.TYPE_STRING = 9)] = "TYPE_STRING"),
    (i[(i.TYPE_GROUP = 10)] = "TYPE_GROUP"),
    (i[(i.TYPE_MESSAGE = 11)] = "TYPE_MESSAGE"),
    (i[(i.TYPE_BYTES = 12)] = "TYPE_BYTES"),
    (i[(i.TYPE_UINT32 = 13)] = "TYPE_UINT32"),
    (i[(i.TYPE_ENUM = 14)] = "TYPE_ENUM"),
    (i[(i.TYPE_SFIXED32 = 15)] = "TYPE_SFIXED32"),
    (i[(i.TYPE_SFIXED64 = 16)] = "TYPE_SFIXED64"),
    (i[(i.TYPE_SINT32 = 17)] = "TYPE_SINT32"),
    (i[(i.TYPE_SINT64 = 18)] = "TYPE_SINT64")
})(hd || (hd = {})),
  n.util.setEnumType(hd, "google.protobuf.Field.Kind", [
    { no: 0, name: "TYPE_UNKNOWN" },
    { no: 1, name: "TYPE_DOUBLE" },
    { no: 2, name: "TYPE_FLOAT" },
    { no: 3, name: "TYPE_INT64" },
    { no: 4, name: "TYPE_UINT64" },
    { no: 5, name: "TYPE_INT32" },
    { no: 6, name: "TYPE_FIXED64" },
    { no: 7, name: "TYPE_FIXED32" },
    { no: 8, name: "TYPE_BOOL" },
    { no: 9, name: "TYPE_STRING" },
    { no: 10, name: "TYPE_GROUP" },
    { no: 11, name: "TYPE_MESSAGE" },
    { no: 12, name: "TYPE_BYTES" },
    { no: 13, name: "TYPE_UINT32" },
    { no: 14, name: "TYPE_ENUM" },
    { no: 15, name: "TYPE_SFIXED32" },
    { no: 16, name: "TYPE_SFIXED64" },
    { no: 17, name: "TYPE_SINT32" },
    { no: 18, name: "TYPE_SINT64" },
  ])
var fd
;(function (i) {
  ;(i[(i.UNKNOWN = 0)] = "UNKNOWN"),
    (i[(i.OPTIONAL = 1)] = "OPTIONAL"),
    (i[(i.REQUIRED = 2)] = "REQUIRED"),
    (i[(i.REPEATED = 3)] = "REPEATED")
})(fd || (fd = {})),
  n.util.setEnumType(fd, "google.protobuf.Field.Cardinality", [
    { no: 0, name: "CARDINALITY_UNKNOWN" },
    { no: 1, name: "CARDINALITY_OPTIONAL" },
    { no: 2, name: "CARDINALITY_REQUIRED" },
    { no: 3, name: "CARDINALITY_REPEATED" },
  ])
var fOt = class Ef extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.enumvalue = []),
        (this.options = []),
        (this.syntax = Fr.PROTO2),
        (this.edition = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Enum"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "enumvalue", kind: "message", T: fft, repeated: !0 },
        { no: 3, name: "options", kind: "message", T: yc, repeated: !0 },
        { no: 4, name: "source_context", kind: "message", T: Fq },
        { no: 5, name: "syntax", kind: "enum", T: n.getEnumType(Fr) },
        { no: 6, name: "edition", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ef().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ef().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ef().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ef, t, e)
    }
  },
  fft = class If extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.number = 0),
        (this.options = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.EnumValue"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "number", kind: "scalar", T: 5 },
        { no: 3, name: "options", kind: "message", T: yc, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new If().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new If().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new If().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(If, t, e)
    }
  },
  yc = class Pf extends d {
    constructor(t) {
      super(), (this.name = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Option"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "value", kind: "message", T: lft },
      ])
    }
    static fromBinary(t, e) {
      return new Pf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Pf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Pf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Pf, t, e)
    }
  },
  pOt = class Nf extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.methods = []),
        (this.options = []),
        (this.version = ""),
        (this.mixins = []),
        (this.syntax = Fr.PROTO2),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Api"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "methods", kind: "message", T: pft, repeated: !0 },
        { no: 3, name: "options", kind: "message", T: yc, repeated: !0 },
        { no: 4, name: "version", kind: "scalar", T: 9 },
        { no: 5, name: "source_context", kind: "message", T: Fq },
        { no: 6, name: "mixins", kind: "message", T: gft, repeated: !0 },
        { no: 7, name: "syntax", kind: "enum", T: n.getEnumType(Fr) },
      ])
    }
    static fromBinary(t, e) {
      return new Nf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Nf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Nf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Nf, t, e)
    }
  },
  pft = class $f extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.requestTypeUrl = ""),
        (this.requestStreaming = !1),
        (this.responseTypeUrl = ""),
        (this.responseStreaming = !1),
        (this.options = []),
        (this.syntax = Fr.PROTO2),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Method"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "request_type_url", kind: "scalar", T: 9 },
        { no: 3, name: "request_streaming", kind: "scalar", T: 8 },
        { no: 4, name: "response_type_url", kind: "scalar", T: 9 },
        { no: 5, name: "response_streaming", kind: "scalar", T: 8 },
        { no: 6, name: "options", kind: "message", T: yc, repeated: !0 },
        { no: 7, name: "syntax", kind: "enum", T: n.getEnumType(Fr) },
      ])
    }
    static fromBinary(t, e) {
      return new $f().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $f().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $f().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($f, t, e)
    }
  },
  gft = class xf extends d {
    constructor(t) {
      super(), (this.name = ""), (this.root = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "google.protobuf.Mixin"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "root", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new xf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xf, t, e)
    }
  },
  Tc
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.ERROR = 1)] = "ERROR"),
    (i[(i.WARNING = 2)] = "WARNING"),
    (i[(i.INFO = 3)] = "INFO"),
    (i[(i.HINT = 4)] = "HINT"),
    (i[(i.AI = 5)] = "AI")
})(Tc || (Tc = {})),
  n.util.setEnumType(Tc, "aiserver.v1.LintSeverity", [
    { no: 0, name: "LINT_SEVERITY_UNSPECIFIED" },
    { no: 1, name: "LINT_SEVERITY_ERROR" },
    { no: 2, name: "LINT_SEVERITY_WARNING" },
    { no: 3, name: "LINT_SEVERITY_INFO" },
    { no: 4, name: "LINT_SEVERITY_HINT" },
    { no: 5, name: "LINT_SEVERITY_AI" },
  ])
var pd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.EDIT = 1)] = "EDIT"),
    (i[(i.GENERATE = 2)] = "GENERATE"),
    (i[(i.INLINE_LONG_COMPLETION = 3)] = "INLINE_LONG_COMPLETION")
})(pd || (pd = {})),
  n.util.setEnumType(pd, "aiserver.v1.FeatureType", [
    { no: 0, name: "FEATURE_TYPE_UNSPECIFIED" },
    { no: 1, name: "FEATURE_TYPE_EDIT" },
    { no: 2, name: "FEATURE_TYPE_GENERATE" },
    { no: 3, name: "FEATURE_TYPE_INLINE_LONG_COMPLETION" },
  ])
var e7
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.VOYAGE_CODE_2 = 1)] = "VOYAGE_CODE_2"),
    (i[(i.TEXT_EMBEDDINGS_LARGE_3 = 2)] = "TEXT_EMBEDDINGS_LARGE_3"),
    (i[(i.QWEN_1_5B_CUSTOM = 3)] = "QWEN_1_5B_CUSTOM")
})(e7 || (e7 = {})),
  n.util.setEnumType(e7, "aiserver.v1.EmbeddingModel", [
    { no: 0, name: "EMBEDDING_MODEL_UNSPECIFIED" },
    { no: 1, name: "EMBEDDING_MODEL_VOYAGE_CODE_2" },
    { no: 2, name: "EMBEDDING_MODEL_TEXT_EMBEDDINGS_LARGE_3" },
    { no: 3, name: "EMBEDDING_MODEL_QWEN_1_5B_CUSTOM" },
  ])
var $s = class Jf extends d {
    constructor(t) {
      super(), (this.line = 0), (this.column = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CursorPosition"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line", kind: "scalar", T: 5 },
        { no: 2, name: "column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Jf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Jf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Jf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Jf, t, e)
    }
  },
  vft = class Cf extends d {
    constructor(t) {
      super(),
        (this.selectionStartLineNumber = 0),
        (this.selectionStartColumn = 0),
        (this.positionLineNumber = 0),
        (this.positionColumn = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SelectionWithOrientation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "selection_start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "selection_start_column", kind: "scalar", T: 5 },
        { no: 3, name: "position_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "position_column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Cf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Cf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Cf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Cf, t, e)
    }
  },
  rr = class Lf extends d {
    constructor(t) {
      super(),
        (this.startLine = 0),
        (this.endLineInclusive = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SimplestRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_inclusive", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Lf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Lf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Lf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Lf, t, e)
    }
  },
  gOt = class Rf extends d {
    constructor(t) {
      super(),
        (this.original = []),
        (this.modified = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComputeLinesDiffOriginalAndModified"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "original", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "modified", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Rf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Rf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Rf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Rf, t, e)
    }
  },
  i7 = class Df extends d {
    constructor(t) {
      super(),
        (this.diffs = []),
        (this.diffType = gd.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GitDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diffs", kind: "message", T: r7, repeated: !0 },
        { no: 2, name: "diff_type", kind: "enum", T: n.getEnumType(gd) },
      ])
    }
    static fromBinary(t, e) {
      return new Df().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Df().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Df().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Df, t, e)
    }
  },
  gd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.DIFF_TO_HEAD = 1)] = "DIFF_TO_HEAD"),
    (i[(i.DIFF_FROM_BRANCH_TO_MAIN = 2)] = "DIFF_FROM_BRANCH_TO_MAIN")
})(gd || (gd = {})),
  n.util.setEnumType(gd, "aiserver.v1.GitDiff.DiffType", [
    { no: 0, name: "DIFF_TYPE_UNSPECIFIED" },
    { no: 1, name: "DIFF_TYPE_DIFF_TO_HEAD" },
    { no: 2, name: "DIFF_TYPE_DIFF_FROM_BRANCH_TO_MAIN" },
  ])
var r7 = class Ff extends d {
    constructor(t) {
      super(),
        (this.from = ""),
        (this.to = ""),
        (this.chunks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "from", kind: "scalar", T: 9 },
        { no: 2, name: "to", kind: "scalar", T: 9 },
        { no: 3, name: "chunks", kind: "message", T: wft, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Ff().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ff().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ff().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ff, t, e)
    }
  },
  wft = class _f extends d {
    constructor(t) {
      super(),
        (this.content = ""),
        (this.lines = []),
        (this.oldStart = 0),
        (this.oldLines = 0),
        (this.newStart = 0),
        (this.newLines = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileDiff.Chunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "content", kind: "scalar", T: 9 },
        { no: 2, name: "lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "old_start", kind: "scalar", T: 5 },
        { no: 4, name: "old_lines", kind: "scalar", T: 5 },
        { no: 5, name: "new_start", kind: "scalar", T: 5 },
        { no: 6, name: "new_lines", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new _f().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _f().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _f().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_f, t, e)
    }
  },
  mi = class Af extends d {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.startColumn = 0),
        (this.endLineNumberInclusive = 0),
        (this.endColumn = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SimpleRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "start_column", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number_inclusive", kind: "scalar", T: 5 },
        { no: 4, name: "end_column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Af().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Af().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Af().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Af, t, e)
    }
  },
  yft = class Bf extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.chunkHash = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SimpleFileChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: rr },
        { no: 3, name: "chunk_hash", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Bf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Bf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Bf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Bf, t, e)
    }
  },
  hr = class Of extends d {
    constructor(t) {
      super(),
        (this.remoteUrl = ""),
        (this.commitId = ""),
        (this.gitPatch = ""),
        (this.unsavedFiles = []),
        (this.unixTimestampMs = 0),
        (this.openEditors = []),
        (this.fileDiffHistories = []),
        (this.branchName = ""),
        (this.branchNotes = ""),
        (this.branchNotesRich = ""),
        (this.globalNotes = ""),
        (this.pastThoughts = []),
        (this.baseBranchName = ""),
        (this.baseBranchCommitId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKDebugInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "remote_url", kind: "scalar", T: 9 },
        { no: 2, name: "commit_id", kind: "scalar", T: 9 },
        { no: 3, name: "git_patch", kind: "scalar", T: 9 },
        { no: 4, name: "unsaved_files", kind: "message", T: Tft, repeated: !0 },
        { no: 5, name: "unix_timestamp_ms", kind: "scalar", T: 1 },
        { no: 6, name: "open_editors", kind: "message", T: kft, repeated: !0 },
        {
          no: 7,
          name: "file_diff_histories",
          kind: "message",
          T: Sft,
          repeated: !0,
        },
        { no: 8, name: "branch_name", kind: "scalar", T: 9 },
        { no: 9, name: "branch_notes", kind: "scalar", T: 9 },
        { no: 12, name: "branch_notes_rich", kind: "scalar", T: 9 },
        { no: 10, name: "global_notes", kind: "scalar", T: 9 },
        {
          no: 11,
          name: "past_thoughts",
          kind: "message",
          T: bft,
          repeated: !0,
        },
        { no: 13, name: "base_branch_name", kind: "scalar", T: 9 },
        { no: 14, name: "base_branch_commit_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Of().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Of().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Of().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Of, t, e)
    }
  },
  Tft = class qf extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKDebugInfo.UnsavedFiles"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new qf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qf, t, e)
    }
  },
  kft = class Uf extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.editorGroupIndex = 0),
        (this.editorGroupId = 0),
        (this.isActive = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKDebugInfo.OpenEditor"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "editor_group_index", kind: "scalar", T: 5 },
        { no: 3, name: "editor_group_id", kind: "scalar", T: 5 },
        { no: 4, name: "is_active", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Uf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Uf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Uf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Uf, t, e)
    }
  },
  Sft = class Mf extends d {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.diffHistory = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKDebugInfo.CppFileDiffHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "diff_history", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Mf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Mf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Mf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Mf, t, e)
    }
  },
  bft = class Hf extends d {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.timeInUnixSeconds = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKDebugInfo.PastThought"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "time_in_unix_seconds", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new Hf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Hf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Hf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Hf, t, e)
    }
  },
  vi = class Wf extends d {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.endLineNumberInclusive = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LineRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_number_inclusive", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Wf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Wf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Wf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Wf, t, e)
    }
  },
  xs = class jf extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CursorRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_position", kind: "message", T: $s },
        { no: 2, name: "end_position", kind: "message", T: $s },
      ])
    }
    static fromBinary(t, e) {
      return new jf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jf, t, e)
    }
  },
  _q = class Vf extends d {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.lineNumber = 0),
        (this.isSignature = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DetailedLine"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 2 },
        { no: 3, name: "is_signature", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Vf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Vf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Vf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Vf, t, e)
    }
  },
  ye = class Gf extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.detailedLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodeBlock"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_contents", kind: "scalar", T: 9, opt: !0 },
        { no: 9, name: "file_contents_length", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "range", kind: "message", T: xs },
        { no: 4, name: "contents", kind: "scalar", T: 9 },
        { no: 5, name: "signatures", kind: "message", T: Eft },
        { no: 6, name: "override_contents", kind: "scalar", T: 9, opt: !0 },
        { no: 7, name: "original_contents", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "detailed_lines", kind: "message", T: _q, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Gf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Gf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Gf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Gf, t, e)
    }
  },
  Eft = class zf extends d {
    constructor(t) {
      super(), (this.ranges = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodeBlock.Signatures"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ranges", kind: "message", T: xs, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new zf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zf, t, e)
    }
  },
  nr = class Yf extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Yf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Yf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Yf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Yf, t, e)
    }
  },
  PQ = class Qf extends d {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.severity = kc.UNSPECIFIED),
        (this.relatedInformation = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Diagnostic"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: xs },
        { no: 3, name: "severity", kind: "enum", T: n.getEnumType(kc) },
        {
          no: 4,
          name: "related_information",
          kind: "message",
          T: NQ,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Qf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Qf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Qf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Qf, t, e)
    }
  },
  kc
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.ERROR = 1)] = "ERROR"),
    (i[(i.WARNING = 2)] = "WARNING"),
    (i[(i.INFORMATION = 3)] = "INFORMATION"),
    (i[(i.HINT = 4)] = "HINT")
})(kc || (kc = {})),
  n.util.setEnumType(kc, "aiserver.v1.Diagnostic.DiagnosticSeverity", [
    { no: 0, name: "DIAGNOSTIC_SEVERITY_UNSPECIFIED" },
    { no: 1, name: "DIAGNOSTIC_SEVERITY_ERROR" },
    { no: 2, name: "DIAGNOSTIC_SEVERITY_WARNING" },
    { no: 3, name: "DIAGNOSTIC_SEVERITY_INFORMATION" },
    { no: 4, name: "DIAGNOSTIC_SEVERITY_HINT" },
  ])
var NQ = class Xf extends d {
    constructor(t) {
      super(), (this.message = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Diagnostic.RelatedInformation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: xs },
      ])
    }
    static fromBinary(t, e) {
      return new Xf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Xf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Xf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Xf, t, e)
    }
  },
  Ift = class Kf extends d {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.severity = Tc.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Lint"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: mi },
        { no: 3, name: "severity", kind: "enum", T: n.getEnumType(Tc) },
      ])
    }
    static fromBinary(t, e) {
      return new Kf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Kf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Kf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Kf, t, e)
    }
  },
  Pft = class Zf extends d {
    constructor(t) {
      super(),
        (this.content = ""),
        (this.score = 0),
        (this.relativePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BM25Chunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "content", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: rr },
        { no: 3, name: "score", kind: "scalar", T: 5 },
        { no: 4, name: "relative_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Zf().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Zf().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Zf().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Zf, t, e)
    }
  },
  Ht = class tp extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.relyOnFilesync = !1),
        (this.cells = []),
        (this.topChunks = []),
        (this.contentsStartAtLine = 0),
        (this.dataframes = []),
        (this.totalNumberOfLines = 0),
        (this.languageId = ""),
        (this.diagnostics = []),
        (this.cellStartLines = []),
        (this.workspaceRootPath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CurrentFileInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        { no: 18, name: "rely_on_filesync", kind: "scalar", T: 8 },
        { no: 17, name: "sha_256_hash", kind: "scalar", T: 9, opt: !0 },
        { no: 16, name: "cells", kind: "message", T: Nft, repeated: !0 },
        { no: 10, name: "top_chunks", kind: "message", T: Pft, repeated: !0 },
        { no: 9, name: "contents_start_at_line", kind: "scalar", T: 5 },
        { no: 3, name: "cursor_position", kind: "message", T: $s },
        { no: 4, name: "dataframes", kind: "message", T: $Q, repeated: !0 },
        { no: 8, name: "total_number_of_lines", kind: "scalar", T: 5 },
        { no: 5, name: "language_id", kind: "scalar", T: 9 },
        { no: 6, name: "selection", kind: "message", T: xs },
        {
          no: 11,
          name: "alternative_version_id",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 7, name: "diagnostics", kind: "message", T: PQ, repeated: !0 },
        { no: 14, name: "file_version", kind: "scalar", T: 5, opt: !0 },
        {
          no: 15,
          name: "cell_start_lines",
          kind: "scalar",
          T: 5,
          repeated: !0,
        },
        { no: 19, name: "workspace_root_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new tp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tp, t, e)
    }
  },
  Nft = class ep extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CurrentFileInfo.NotebookCell"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new ep().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ep().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ep().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ep, t, e)
    }
  },
  $ft = class ip extends d {
    constructor(t) {
      super(),
        (this.apiKey = ""),
        (this.baseUrl = ""),
        (this.deployment = ""),
        (this.useAzure = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AzureState"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "api_key", kind: "scalar", T: 9 },
        { no: 2, name: "base_url", kind: "scalar", T: 9 },
        { no: 3, name: "deployment", kind: "scalar", T: 9 },
        { no: 4, name: "use_azure", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new ip().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ip().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ip().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ip, t, e)
    }
  },
  vt = class rp extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelDetails"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_name", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "api_key", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "enable_ghost_mode", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "azure_state", kind: "message", T: $ft, opt: !0 },
        { no: 5, name: "enable_slow_pool", kind: "scalar", T: 8, opt: !0 },
        { no: 6, name: "openai_api_base_url", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new rp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rp, t, e)
    }
  },
  $Q = class np extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.shape = ""),
        (this.dataDimensionality = 0),
        (this.columns = []),
        (this.rowCount = 0),
        (this.indexColumn = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DataframeInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "shape", kind: "scalar", T: 9 },
        { no: 3, name: "data_dimensionality", kind: "scalar", T: 5 },
        { no: 6, name: "columns", kind: "message", T: xft, repeated: !0 },
        { no: 7, name: "row_count", kind: "scalar", T: 5 },
        { no: 8, name: "index_column", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new np().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new np().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new np().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(np, t, e)
    }
  },
  xft = class sp extends d {
    constructor(t) {
      super(), (this.key = ""), (this.type = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DataframeInfo.Column"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "key", kind: "scalar", T: 9 },
        { no: 2, name: "type", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new sp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sp, t, e)
    }
  },
  Js = class ap extends d {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.relatedInformation = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LinterError"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: xs },
        { no: 3, name: "source", kind: "scalar", T: 9, opt: !0 },
        {
          no: 4,
          name: "related_information",
          kind: "message",
          T: NQ,
          repeated: !0,
        },
        {
          no: 5,
          name: "severity",
          kind: "enum",
          T: n.getEnumType(kc),
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new ap().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ap().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ap().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ap, t, e)
    }
  },
  hi = class op extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.errors = []),
        (this.fileContents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LinterErrors"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "errors", kind: "message", T: Js, repeated: !0 },
        { no: 3, name: "file_contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new op().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new op().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new op().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(op, t, e)
    }
  },
  Jft = class cp extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.errors = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LinterErrorsWithoutFileContents"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "errors", kind: "message", T: Js, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new cp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cp, t, e)
    }
  },
  Aq = class up extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.description = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CursorRule"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "description", kind: "scalar", T: 9 },
        { no: 3, name: "body", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "is_from_glob", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new up().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new up().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new up().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(up, t, e)
    }
  },
  Ne = class lp extends d {
    constructor(t) {
      super(),
        (this.context = ""),
        (this.rules = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ExplicitContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context", kind: "scalar", T: 9 },
        { no: 2, name: "repo_context", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "rules", kind: "message", T: Aq, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new lp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lp, t, e)
    }
  },
  vd = class dp extends d {
    constructor(t) {
      super(),
        (this.messageType = wd.UNSPECIFIED),
        (this.content = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PureMessage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message_type", kind: "enum", T: n.getEnumType(wd) },
        { no: 2, name: "content", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new dp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dp, t, e)
    }
  },
  wd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SYSTEM = 1)] = "SYSTEM"),
    (i[(i.USER = 2)] = "USER"),
    (i[(i.ASSISTANT = 3)] = "ASSISTANT")
})(wd || (wd = {})),
  n.util.setEnumType(wd, "aiserver.v1.PureMessage.MessageType", [
    { no: 0, name: "MESSAGE_TYPE_UNSPECIFIED" },
    { no: 1, name: "MESSAGE_TYPE_SYSTEM" },
    { no: 2, name: "MESSAGE_TYPE_USER" },
    { no: 3, name: "MESSAGE_TYPE_ASSISTANT" },
  ])
var Bq = class ou extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.detail = ""),
        (this.kind = yd.UNSPECIFIED),
        (this.containerName = ""),
        (this.children = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentSymbol"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "detail", kind: "scalar", T: 9 },
        { no: 3, name: "kind", kind: "enum", T: n.getEnumType(yd) },
        { no: 5, name: "container_name", kind: "scalar", T: 9 },
        { no: 6, name: "range", kind: "message", T: xQ },
        { no: 7, name: "selection_range", kind: "message", T: xQ },
        { no: 8, name: "children", kind: "message", T: ou, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ou().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ou().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ou().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ou, t, e)
    }
  },
  yd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.FILE = 1)] = "FILE"),
    (i[(i.MODULE = 2)] = "MODULE"),
    (i[(i.NAMESPACE = 3)] = "NAMESPACE"),
    (i[(i.PACKAGE = 4)] = "PACKAGE"),
    (i[(i.CLASS = 5)] = "CLASS"),
    (i[(i.METHOD = 6)] = "METHOD"),
    (i[(i.PROPERTY = 7)] = "PROPERTY"),
    (i[(i.FIELD = 8)] = "FIELD"),
    (i[(i.CONSTRUCTOR = 9)] = "CONSTRUCTOR"),
    (i[(i.ENUM = 10)] = "ENUM"),
    (i[(i.INTERFACE = 11)] = "INTERFACE"),
    (i[(i.FUNCTION = 12)] = "FUNCTION"),
    (i[(i.VARIABLE = 13)] = "VARIABLE"),
    (i[(i.CONSTANT = 14)] = "CONSTANT"),
    (i[(i.STRING = 15)] = "STRING"),
    (i[(i.NUMBER = 16)] = "NUMBER"),
    (i[(i.BOOLEAN = 17)] = "BOOLEAN"),
    (i[(i.ARRAY = 18)] = "ARRAY"),
    (i[(i.OBJECT = 19)] = "OBJECT"),
    (i[(i.KEY = 20)] = "KEY"),
    (i[(i.NULL = 21)] = "NULL"),
    (i[(i.ENUM_MEMBER = 22)] = "ENUM_MEMBER"),
    (i[(i.STRUCT = 23)] = "STRUCT"),
    (i[(i.EVENT = 24)] = "EVENT"),
    (i[(i.OPERATOR = 25)] = "OPERATOR"),
    (i[(i.TYPE_PARAMETER = 26)] = "TYPE_PARAMETER")
})(yd || (yd = {})),
  n.util.setEnumType(yd, "aiserver.v1.DocumentSymbol.SymbolKind", [
    { no: 0, name: "SYMBOL_KIND_UNSPECIFIED" },
    { no: 1, name: "SYMBOL_KIND_FILE" },
    { no: 2, name: "SYMBOL_KIND_MODULE" },
    { no: 3, name: "SYMBOL_KIND_NAMESPACE" },
    { no: 4, name: "SYMBOL_KIND_PACKAGE" },
    { no: 5, name: "SYMBOL_KIND_CLASS" },
    { no: 6, name: "SYMBOL_KIND_METHOD" },
    { no: 7, name: "SYMBOL_KIND_PROPERTY" },
    { no: 8, name: "SYMBOL_KIND_FIELD" },
    { no: 9, name: "SYMBOL_KIND_CONSTRUCTOR" },
    { no: 10, name: "SYMBOL_KIND_ENUM" },
    { no: 11, name: "SYMBOL_KIND_INTERFACE" },
    { no: 12, name: "SYMBOL_KIND_FUNCTION" },
    { no: 13, name: "SYMBOL_KIND_VARIABLE" },
    { no: 14, name: "SYMBOL_KIND_CONSTANT" },
    { no: 15, name: "SYMBOL_KIND_STRING" },
    { no: 16, name: "SYMBOL_KIND_NUMBER" },
    { no: 17, name: "SYMBOL_KIND_BOOLEAN" },
    { no: 18, name: "SYMBOL_KIND_ARRAY" },
    { no: 19, name: "SYMBOL_KIND_OBJECT" },
    { no: 20, name: "SYMBOL_KIND_KEY" },
    { no: 21, name: "SYMBOL_KIND_NULL" },
    { no: 22, name: "SYMBOL_KIND_ENUM_MEMBER" },
    { no: 23, name: "SYMBOL_KIND_STRUCT" },
    { no: 24, name: "SYMBOL_KIND_EVENT" },
    { no: 25, name: "SYMBOL_KIND_OPERATOR" },
    { no: 26, name: "SYMBOL_KIND_TYPE_PARAMETER" },
  ])
var xQ = class mp extends d {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.startColumn = 0),
        (this.endLineNumber = 0),
        (this.endColumn = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentSymbol.Range"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "start_column", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "end_column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new mp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mp, t, e)
    }
  },
  Cft = class hp extends d {
    constructor(t) {
      super(),
        (this.codeDetails = ""),
        (this.markdownBlocks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HoverDetails"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_details", kind: "scalar", T: 9 },
        { no: 2, name: "markdown_blocks", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new hp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hp, t, e)
    }
  },
  Lft = class fp extends d {
    constructor(t) {
      super(), (this.scheme = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UriComponents"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "scheme", kind: "scalar", T: 9 },
        { no: 2, name: "authority", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "path", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "query", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "fragment", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new fp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fp, t, e)
    }
  },
  Oq = class pp extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.textInSymbolRange = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentSymbolWithText"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "symbol", kind: "message", T: Bq },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 3, name: "text_in_symbol_range", kind: "scalar", T: 9 },
        { no: 4, name: "uri_components", kind: "message", T: Lft },
      ])
    }
    static fromBinary(t, e) {
      return new pp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pp, t, e)
    }
  },
  vOt = class gp extends d {
    constructor(t) {
      super(), (this.error = Cs.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ErrorDetails"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "error", kind: "enum", T: n.getEnumType(Cs) },
        { no: 2, name: "details", kind: "message", T: Rft },
        { no: 3, name: "is_expected", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new gp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gp, t, e)
    }
  },
  Cs
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.BAD_API_KEY = 1)] = "BAD_API_KEY"),
    (i[(i.BAD_USER_API_KEY = 42)] = "BAD_USER_API_KEY"),
    (i[(i.NOT_LOGGED_IN = 2)] = "NOT_LOGGED_IN"),
    (i[(i.INVALID_AUTH_ID = 3)] = "INVALID_AUTH_ID"),
    (i[(i.NOT_HIGH_ENOUGH_PERMISSIONS = 4)] = "NOT_HIGH_ENOUGH_PERMISSIONS"),
    (i[(i.AGENT_REQUIRES_LOGIN = 18)] = "AGENT_REQUIRES_LOGIN"),
    (i[(i.BAD_MODEL_NAME = 5)] = "BAD_MODEL_NAME"),
    (i[(i.NOT_FOUND = 39)] = "NOT_FOUND"),
    (i[(i.DEPRECATED = 40)] = "DEPRECATED"),
    (i[(i.USER_NOT_FOUND = 6)] = "USER_NOT_FOUND"),
    (i[(i.FREE_USER_RATE_LIMIT_EXCEEDED = 7)] =
      "FREE_USER_RATE_LIMIT_EXCEEDED"),
    (i[(i.PRO_USER_RATE_LIMIT_EXCEEDED = 8)] = "PRO_USER_RATE_LIMIT_EXCEEDED"),
    (i[(i.FREE_USER_USAGE_LIMIT = 9)] = "FREE_USER_USAGE_LIMIT"),
    (i[(i.PRO_USER_USAGE_LIMIT = 10)] = "PRO_USER_USAGE_LIMIT"),
    (i[(i.RESOURCE_EXHAUSTED = 41)] = "RESOURCE_EXHAUSTED"),
    (i[(i.AUTH_TOKEN_NOT_FOUND = 11)] = "AUTH_TOKEN_NOT_FOUND"),
    (i[(i.AUTH_TOKEN_EXPIRED = 12)] = "AUTH_TOKEN_EXPIRED"),
    (i[(i.OPENAI = 13)] = "OPENAI"),
    (i[(i.OPENAI_RATE_LIMIT_EXCEEDED = 14)] = "OPENAI_RATE_LIMIT_EXCEEDED"),
    (i[(i.OPENAI_ACCOUNT_LIMIT_EXCEEDED = 15)] =
      "OPENAI_ACCOUNT_LIMIT_EXCEEDED"),
    (i[(i.TASK_UUID_NOT_FOUND = 16)] = "TASK_UUID_NOT_FOUND"),
    (i[(i.TASK_NO_PERMISSIONS = 17)] = "TASK_NO_PERMISSIONS"),
    (i[(i.AGENT_ENGINE_NOT_FOUND = 19)] = "AGENT_ENGINE_NOT_FOUND"),
    (i[(i.MAX_TOKENS = 20)] = "MAX_TOKENS"),
    (i[(i.PRO_USER_ONLY = 23)] = "PRO_USER_ONLY"),
    (i[(i.API_KEY_NOT_SUPPORTED = 24)] = "API_KEY_NOT_SUPPORTED"),
    (i[(i.USER_ABORTED_REQUEST = 21)] = "USER_ABORTED_REQUEST"),
    (i[(i.TIMEOUT = 25)] = "TIMEOUT"),
    (i[(i.GENERIC_RATE_LIMIT_EXCEEDED = 22)] = "GENERIC_RATE_LIMIT_EXCEEDED"),
    (i[(i.SLASH_EDIT_FILE_TOO_LONG = 26)] = "SLASH_EDIT_FILE_TOO_LONG"),
    (i[(i.FILE_UNSUPPORTED = 27)] = "FILE_UNSUPPORTED"),
    (i[(i.GPT_4_VISION_PREVIEW_RATE_LIMIT = 28)] =
      "GPT_4_VISION_PREVIEW_RATE_LIMIT"),
    (i[(i.CUSTOM_MESSAGE = 29)] = "CUSTOM_MESSAGE"),
    (i[(i.OUTDATED_CLIENT = 30)] = "OUTDATED_CLIENT"),
    (i[(i.CLAUDE_IMAGE_TOO_LARGE = 31)] = "CLAUDE_IMAGE_TOO_LARGE"),
    (i[(i.GITGRAPH_NOT_FOUND = 32)] = "GITGRAPH_NOT_FOUND"),
    (i[(i.FILE_NOT_FOUND = 33)] = "FILE_NOT_FOUND"),
    (i[(i.API_KEY_RATE_LIMIT = 34)] = "API_KEY_RATE_LIMIT"),
    (i[(i.DEBOUNCED = 35)] = "DEBOUNCED"),
    (i[(i.BAD_REQUEST = 36)] = "BAD_REQUEST"),
    (i[(i.REPOSITORY_SERVICE_REPOSITORY_IS_NOT_INITIALIZED = 37)] =
      "REPOSITORY_SERVICE_REPOSITORY_IS_NOT_INITIALIZED"),
    (i[(i.UNAUTHORIZED = 38)] = "UNAUTHORIZED"),
    (i[(i.CONVERSATION_TOO_LONG = 43)] = "CONVERSATION_TOO_LONG")
})(Cs || (Cs = {})),
  n.util.setEnumType(Cs, "aiserver.v1.ErrorDetails.Error", [
    { no: 0, name: "ERROR_UNSPECIFIED" },
    { no: 1, name: "ERROR_BAD_API_KEY" },
    { no: 42, name: "ERROR_BAD_USER_API_KEY" },
    { no: 2, name: "ERROR_NOT_LOGGED_IN" },
    { no: 3, name: "ERROR_INVALID_AUTH_ID" },
    { no: 4, name: "ERROR_NOT_HIGH_ENOUGH_PERMISSIONS" },
    { no: 18, name: "ERROR_AGENT_REQUIRES_LOGIN" },
    { no: 5, name: "ERROR_BAD_MODEL_NAME" },
    { no: 39, name: "ERROR_NOT_FOUND" },
    { no: 40, name: "ERROR_DEPRECATED" },
    { no: 6, name: "ERROR_USER_NOT_FOUND" },
    { no: 7, name: "ERROR_FREE_USER_RATE_LIMIT_EXCEEDED" },
    { no: 8, name: "ERROR_PRO_USER_RATE_LIMIT_EXCEEDED" },
    { no: 9, name: "ERROR_FREE_USER_USAGE_LIMIT" },
    { no: 10, name: "ERROR_PRO_USER_USAGE_LIMIT" },
    { no: 41, name: "ERROR_RESOURCE_EXHAUSTED" },
    { no: 11, name: "ERROR_AUTH_TOKEN_NOT_FOUND" },
    { no: 12, name: "ERROR_AUTH_TOKEN_EXPIRED" },
    { no: 13, name: "ERROR_OPENAI" },
    { no: 14, name: "ERROR_OPENAI_RATE_LIMIT_EXCEEDED" },
    { no: 15, name: "ERROR_OPENAI_ACCOUNT_LIMIT_EXCEEDED" },
    { no: 16, name: "ERROR_TASK_UUID_NOT_FOUND" },
    { no: 17, name: "ERROR_TASK_NO_PERMISSIONS" },
    { no: 19, name: "ERROR_AGENT_ENGINE_NOT_FOUND" },
    { no: 20, name: "ERROR_MAX_TOKENS" },
    { no: 23, name: "ERROR_PRO_USER_ONLY" },
    { no: 24, name: "ERROR_API_KEY_NOT_SUPPORTED" },
    { no: 21, name: "ERROR_USER_ABORTED_REQUEST" },
    { no: 25, name: "ERROR_TIMEOUT" },
    { no: 22, name: "ERROR_GENERIC_RATE_LIMIT_EXCEEDED" },
    { no: 26, name: "ERROR_SLASH_EDIT_FILE_TOO_LONG" },
    { no: 27, name: "ERROR_FILE_UNSUPPORTED" },
    { no: 28, name: "ERROR_GPT_4_VISION_PREVIEW_RATE_LIMIT" },
    { no: 29, name: "ERROR_CUSTOM_MESSAGE" },
    { no: 30, name: "ERROR_OUTDATED_CLIENT" },
    { no: 31, name: "ERROR_CLAUDE_IMAGE_TOO_LARGE" },
    { no: 32, name: "ERROR_GITGRAPH_NOT_FOUND" },
    { no: 33, name: "ERROR_FILE_NOT_FOUND" },
    { no: 34, name: "ERROR_API_KEY_RATE_LIMIT" },
    { no: 35, name: "ERROR_DEBOUNCED" },
    { no: 36, name: "ERROR_BAD_REQUEST" },
    { no: 37, name: "ERROR_REPOSITORY_SERVICE_REPOSITORY_IS_NOT_INITIALIZED" },
    { no: 38, name: "ERROR_UNAUTHORIZED" },
    { no: 43, name: "ERROR_CONVERSATION_TOO_LONG" },
  ])
var Rft = class vp extends d {
    constructor(t) {
      super(),
        (this.title = ""),
        (this.detail = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CustomErrorDetails"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "detail", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "allow_command_links_potentially_unsafe_please_only_use_for_handwritten_trusted_markdown",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 4, name: "is_retryable", kind: "scalar", T: 8, opt: !0 },
        { no: 5, name: "show_request_id", kind: "scalar", T: 8, opt: !0 },
        {
          no: 6,
          name: "should_show_immediate_error",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new vp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vp, t, e)
    }
  },
  Ls = class wp extends d {
    constructor(t) {
      super(), (this.data = new Uint8Array(0)), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ImageProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "data", kind: "scalar", T: 12 },
        { no: 2, name: "dimension", kind: "message", T: Dft },
      ])
    }
    static fromBinary(t, e) {
      return new wp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wp, t, e)
    }
  },
  Dft = class yp extends d {
    constructor(t) {
      super(), (this.width = 0), (this.height = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ImageProto.Dimension"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "width", kind: "scalar", T: 5 },
        { no: 2, name: "height", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new yp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yp, t, e)
    }
  },
  n7 = class Tp extends d {
    constructor(t) {
      super(),
        (this.markdown = ""),
        (this.bubbleId = ""),
        (this.sectionIndex = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChatQuote"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "markdown", kind: "scalar", T: 9 },
        { no: 2, name: "bubble_id", kind: "scalar", T: 9 },
        { no: 3, name: "section_index", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Tp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Tp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Tp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Tp, t, e)
    }
  },
  Fft = class kp extends d {
    constructor(t) {
      super(), (this.url = ""), (this.uuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChatExternalLink"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "url", kind: "scalar", T: 9 },
        { no: 2, name: "uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new kp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kp, t, e)
    }
  },
  qq = class Sp extends d {
    constructor(t) {
      super(), (this.url = ""), (this.uuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComposerExternalLink"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "url", kind: "scalar", T: 9 },
        { no: 2, name: "uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Sp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Sp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Sp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Sp, t, e)
    }
  },
  Uq = class bp extends d {
    constructor(t) {
      super(), (this.url = ""), (this.uuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKExternalLink"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "url", kind: "scalar", T: 9 },
        { no: 2, name: "uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new bp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bp, t, e)
    }
  },
  Mq = class Ep extends d {
    constructor(t) {
      super(),
        (this.note = ""),
        (this.commitHash = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CommitNote"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "note", kind: "scalar", T: 9 },
        { no: 2, name: "commit_hash", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ep().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ep().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ep().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ep, t, e)
    }
  },
  _ft = class Ip extends d {
    constructor(t) {
      super(),
        (this.note = ""),
        (this.commitHash = ""),
        (this.embeddings = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CommitNoteWithEmbeddings"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "note", kind: "scalar", T: 9 },
        { no: 2, name: "commit_hash", kind: "scalar", T: 9 },
        { no: 3, name: "embeddings", kind: "scalar", T: 1, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Ip().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ip().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ip().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ip, t, e)
    }
  },
  Aft = class Pp extends d {
    constructor(t) {
      super(), (this.diff = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CommitDiffString"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diff", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Pp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Pp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Pp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Pp, t, e)
    }
  },
  wOt = class Np extends d {
    constructor(t) {
      super(),
        (this.notes = []),
        (this.commitHash = ""),
        (this.repoUrl = ""),
        (this.filesChangedRelativePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FullCommitNotes"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "notes", kind: "message", T: Mq, repeated: !0 },
        { no: 2, name: "commit_hash", kind: "scalar", T: 9 },
        { no: 3, name: "repo_url", kind: "scalar", T: 9 },
        { no: 4, name: "files_changed_relative_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Np().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Np().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Np().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Np, t, e)
    }
  },
  JQ = class $p extends d {
    constructor(t) {
      super(), (this.key = ""), (this.value = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CrossExtHostHeader"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "key", kind: "scalar", T: 9 },
        { no: 2, name: "value", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $p().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $p().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $p().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($p, t, e)
    }
  },
  Hq = class xp extends d {
    constructor(t) {
      super(), (this.headers = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CrossExtHostHeaders"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "headers", kind: "message", T: JQ, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new xp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xp, t, e)
    }
  },
  s7 = class Jp extends d {
    constructor(t) {
      super(),
        (this.message = new Uint8Array(0)),
        (this.isError = !1),
        (this.connectError = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SimpleUnaryCrossExtensionHostMessage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 12 },
        { no: 2, name: "header", kind: "message", T: Hq },
        { no: 3, name: "trailer", kind: "message", T: Hq },
        { no: 4, name: "is_error", kind: "scalar", T: 8 },
        { no: 5, name: "connect_error", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Jp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Jp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Jp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Jp, t, e)
    }
  },
  CQ = class Cp extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumber = 0),
        (this.lines = []),
        (this.languageIdentifier = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodeChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "lines", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 4,
          name: "summarization_strategy",
          kind: "enum",
          T: n.getEnumType(o7),
          opt: !0,
        },
        { no: 5, name: "language_identifier", kind: "scalar", T: 9 },
        { no: 6, name: "intent", kind: "enum", T: n.getEnumType(a7), opt: !0 },
        { no: 7, name: "is_final_version", kind: "scalar", T: 8, opt: !0 },
        { no: 8, name: "is_first_version", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Cp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Cp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Cp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Cp, t, e)
    }
  },
  a7
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.COMPOSER_FILE = 1)] = "COMPOSER_FILE"),
    (i[(i.COMPRESSED_COMPOSER_FILE = 2)] = "COMPRESSED_COMPOSER_FILE")
})(a7 || (a7 = {})),
  n.util.setEnumType(a7, "aiserver.v1.CodeChunk.Intent", [
    { no: 0, name: "INTENT_UNSPECIFIED" },
    { no: 1, name: "INTENT_COMPOSER_FILE" },
    { no: 2, name: "INTENT_COMPRESSED_COMPOSER_FILE" },
  ])
var o7
;(function (i) {
  ;(i[(i.NONE_UNSPECIFIED = 0)] = "NONE_UNSPECIFIED"),
    (i[(i.SUMMARIZED = 1)] = "SUMMARIZED"),
    (i[(i.EMBEDDED = 2)] = "EMBEDDED")
})(o7 || (o7 = {})),
  n.util.setEnumType(o7, "aiserver.v1.CodeChunk.SummarizationStrategy", [
    { no: 0, name: "SUMMARIZATION_STRATEGY_NONE_UNSPECIFIED" },
    { no: 1, name: "SUMMARIZATION_STRATEGY_SUMMARIZED" },
    { no: 2, name: "SUMMARIZATION_STRATEGY_EMBEDDED" },
  ])
var Bft = class Lp extends d {
    constructor(t) {
      super(),
        (this.line = 0),
        (this.character = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LspSubgraphPosition"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line", kind: "scalar", T: 5 },
        { no: 2, name: "character", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Lp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Lp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Lp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Lp, t, e)
    }
  },
  Oft = class Rp extends d {
    constructor(t) {
      super(),
        (this.startLine = 0),
        (this.startCharacter = 0),
        (this.endLine = 0),
        (this.endCharacter = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LspSubgraphRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line", kind: "scalar", T: 5 },
        { no: 2, name: "start_character", kind: "scalar", T: 5 },
        { no: 3, name: "end_line", kind: "scalar", T: 5 },
        { no: 4, name: "end_character", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Rp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Rp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Rp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Rp, t, e)
    }
  },
  qft = class Dp extends d {
    constructor(t) {
      super(),
        (this.type = ""),
        (this.content = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LspSubgraphContextItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uri", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "type", kind: "scalar", T: 9 },
        { no: 3, name: "content", kind: "scalar", T: 9 },
        { no: 4, name: "range", kind: "message", T: Oft, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Dp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Dp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Dp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Dp, t, e)
    }
  },
  Wq = class Fp extends d {
    constructor(t) {
      super(),
        (this.uri = ""),
        (this.symbolName = ""),
        (this.positions = []),
        (this.contextItems = []),
        (this.score = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LspSubgraphFullContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uri", kind: "scalar", T: 9 },
        { no: 2, name: "symbol_name", kind: "scalar", T: 9 },
        { no: 3, name: "positions", kind: "message", T: Bft, repeated: !0 },
        { no: 4, name: "context_items", kind: "message", T: qft, repeated: !0 },
        { no: 5, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new Fp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Fp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Fp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Fp, t, e)
    }
  },
  Td
;(function (i) {
  ;(i[(i.FS_UPLOAD_ERROR_TYPE_UNSPECIFIED = 0)] =
    "FS_UPLOAD_ERROR_TYPE_UNSPECIFIED"),
    (i[(i.FS_UPLOAD_ERROR_TYPE_NON_EXISTANT = 1)] =
      "FS_UPLOAD_ERROR_TYPE_NON_EXISTANT"),
    (i[(i.FS_UPLOAD_ERROR_TYPE_HASH_MISMATCH = 2)] =
      "FS_UPLOAD_ERROR_TYPE_HASH_MISMATCH")
})(Td || (Td = {})),
  n.util.setEnumType(Td, "aiserver.v1.FSUploadErrorType", [
    { no: 0, name: "FS_UPLOAD_ERROR_TYPE_UNSPECIFIED" },
    { no: 1, name: "FS_UPLOAD_ERROR_TYPE_NON_EXISTANT" },
    { no: 2, name: "FS_UPLOAD_ERROR_TYPE_HASH_MISMATCH" },
  ])
var kd
;(function (i) {
  ;(i[(i.FS_SYNC_ERROR_TYPE_UNSPECIFIED = 0)] =
    "FS_SYNC_ERROR_TYPE_UNSPECIFIED"),
    (i[(i.FS_SYNC_ERROR_TYPE_NON_EXISTANT = 1)] =
      "FS_SYNC_ERROR_TYPE_NON_EXISTANT"),
    (i[(i.FS_SYNC_ERROR_TYPE_HASH_MISMATCH = 2)] =
      "FS_SYNC_ERROR_TYPE_HASH_MISMATCH")
})(kd || (kd = {})),
  n.util.setEnumType(kd, "aiserver.v1.FSSyncErrorType", [
    { no: 0, name: "FS_SYNC_ERROR_TYPE_UNSPECIFIED" },
    { no: 1, name: "FS_SYNC_ERROR_TYPE_NON_EXISTANT" },
    { no: 2, name: "FS_SYNC_ERROR_TYPE_HASH_MISMATCH" },
  ])
var yOt = class _p extends d {
    constructor(t) {
      super(),
        (this.uuid = ""),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.modelVersion = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSUploadFileRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 3, name: "contents", kind: "scalar", T: 9 },
        { no: 4, name: "model_version", kind: "scalar", T: 5 },
        { no: 5, name: "sha256_hash", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new _p().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _p().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _p().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_p, t, e)
    }
  },
  TOt = class Ap extends d {
    constructor(t) {
      super(),
        (this.error = Td.FS_UPLOAD_ERROR_TYPE_UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSUploadFileResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "error", kind: "enum", T: n.getEnumType(Td) },
      ])
    }
    static fromBinary(t, e) {
      return new Ap().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ap().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ap().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ap, t, e)
    }
  },
  Sd = class Bp extends d {
    constructor(t) {
      super(),
        (this.modelVersion = 0),
        (this.relativeWorkspacePath = ""),
        (this.updates = []),
        (this.expectedFileLength = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FilesyncUpdateWithModelVersion"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_version", kind: "scalar", T: 5 },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 3, name: "updates", kind: "message", T: Uft, repeated: !0 },
        { no: 4, name: "expected_file_length", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Bp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Bp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Bp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Bp, t, e)
    }
  },
  Uft = class Op extends d {
    constructor(t) {
      super(),
        (this.startPosition = 0),
        (this.endPosition = 0),
        (this.changeLength = 0),
        (this.replacedString = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SingleUpdateRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_position", kind: "scalar", T: 5 },
        { no: 2, name: "end_position", kind: "scalar", T: 5 },
        { no: 3, name: "change_length", kind: "scalar", T: 5 },
        { no: 4, name: "replaced_string", kind: "scalar", T: 9 },
        { no: 5, name: "range", kind: "message", T: mi },
      ])
    }
    static fromBinary(t, e) {
      return new Op().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Op().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Op().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Op, t, e)
    }
  },
  kOt = class qp extends d {
    constructor(t) {
      super(),
        (this.uuid = ""),
        (this.relativeWorkspacePath = ""),
        (this.modelVersion = 0),
        (this.filesyncUpdates = []),
        (this.sha256Hash = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSSyncFileRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 3, name: "model_version", kind: "scalar", T: 5 },
        {
          no: 4,
          name: "filesync_updates",
          kind: "message",
          T: Sd,
          repeated: !0,
        },
        { no: 5, name: "sha256_hash", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new qp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qp, t, e)
    }
  },
  SOt = class Up extends d {
    constructor(t) {
      super(),
        (this.error = kd.FS_SYNC_ERROR_TYPE_UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSSyncFileResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "error", kind: "enum", T: n.getEnumType(kd) },
      ])
    }
    static fromBinary(t, e) {
      return new Up().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Up().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Up().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Up, t, e)
    }
  },
  bOt = class Mp extends d {
    constructor(t) {
      super(), (this.uuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSIsEnabledForUserRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Mp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Mp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Mp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Mp, t, e)
    }
  },
  EOt = class Hp extends d {
    constructor(t) {
      super(), (this.enabled = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSIsEnabledForUserResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "enabled", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Hp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Hp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Hp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Hp, t, e)
    }
  },
  IOt = class Wp extends d {
    constructor(t) {
      super(),
        (this.uuid = ""),
        (this.authId = ""),
        (this.relativeWorkspacePath = ""),
        (this.modelVersion = 0),
        (this.filesyncUpdates = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSGetFileContentsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "auth_id", kind: "scalar", T: 9 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "model_version", kind: "scalar", T: 5 },
        {
          no: 5,
          name: "filesync_updates",
          kind: "message",
          T: Sd,
          repeated: !0,
        },
        { no: 6, name: "sha256_hash", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Wp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Wp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Wp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Wp, t, e)
    }
  },
  POt = class jp extends d {
    constructor(t) {
      super(), (this.contents = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSGetFileContentsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "contents", kind: "scalar", T: 9 },
        { no: 2, name: "sha256_hash", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new jp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jp, t, e)
    }
  },
  Mft = class Vp extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.required = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "requested_version", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "sha256_hash", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "required", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Vp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Vp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Vp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Vp, t, e)
    }
  },
  NOt = class Gp extends d {
    constructor(t) {
      super(),
        (this.authId = ""),
        (this.filesyncUpdates = []),
        (this.fileRequests = []),
        (this.getAllRecentFiles = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSGetMultiFileContentsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "auth_id", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "filesync_updates",
          kind: "message",
          T: Sd,
          repeated: !0,
        },
        { no: 3, name: "file_requests", kind: "message", T: Mft, repeated: !0 },
        { no: 4, name: "get_all_recent_files", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Gp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Gp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Gp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Gp, t, e)
    }
  },
  Hft = class zp extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.modelVersion = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileRetrieved"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        { no: 3, name: "model_version", kind: "scalar", T: 5 },
        { no: 4, name: "last_modified", kind: "message", T: bQ },
      ])
    }
    static fromBinary(t, e) {
      return new zp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zp, t, e)
    }
  },
  $Ot = class Yp extends d {
    constructor(t) {
      super(), (this.files = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSGetMultiFileContentsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: Hft, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Yp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Yp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Yp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Yp, t, e)
    }
  },
  xOt = class Qp extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSInternalHealthCheckRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "from_server", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Qp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Qp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Qp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Qp, t, e)
    }
  },
  JOt = class Xp extends d {
    constructor(t) {
      super(), (this.success = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSInternalHealthCheckResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "success", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Xp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Xp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Xp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Xp, t, e)
    }
  },
  COt = class Kp extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSConfigRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Kp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Kp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Kp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Kp, t, e)
    }
  },
  LOt = class Zp extends d {
    constructor(t) {
      super(), (this.checkFilesyncHashPercent = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FSConfigResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "check_filesync_hash_percent", kind: "scalar", T: 2 },
        {
          no: 2,
          name: "rate_limiter_breaker_reset_time_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 3, name: "rate_limiter_rps", kind: "scalar", T: 5, opt: !0 },
        {
          no: 4,
          name: "rate_limiter_burst_capacity",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 5,
          name: "max_recent_updates_stored",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 6,
          name: "max_model_version_cache_size",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 7,
          name: "max_file_size_to_sync_bytes",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 8,
          name: "sync_retry_max_attempts",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 9,
          name: "sync_retry_initial_delay_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 10,
          name: "sync_retry_time_multiplier",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 11,
          name: "file_sync_status_max_cache_size",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 12,
          name: "successive_syncs_required_for_reliance",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 13,
          name: "extra_successful_syncs_needed_after_errors",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 14,
          name: "big_change_stripping_threshold_bytes",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 15,
          name: "last_n_updates_to_send",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 16,
          name: "file_sync_status_ttl_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 17, name: "sync_debounce_ms", kind: "scalar", T: 5, opt: !0 },
        {
          no: 18,
          name: "sync_update_threshold",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Zp().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Zp().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Zp().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Zp, t, e)
    }
  },
  LQ = class tg extends d {
    constructor(t) {
      super(),
        (this.file = ""),
        (this.startLine = 0),
        (this.endLine = 0),
        (this.codeLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugLocation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "end_line", kind: "scalar", T: 5 },
        { no: 4, name: "code_lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new tg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tg, t, e)
    }
  },
  c7 = class eg extends d {
    constructor(t) {
      super(),
        (this.locations = []),
        (this.id = ""),
        (this.description = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugReport"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "locations", kind: "message", T: LQ, repeated: !0 },
        { no: 2, name: "id", kind: "scalar", T: 9 },
        { no: 3, name: "description", kind: "scalar", T: 9 },
        { no: 4, name: "confidence", kind: "scalar", T: 2, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new eg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eg, t, e)
    }
  },
  RQ = class ig extends d {
    constructor(t) {
      super(), (this.bugReports = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugReports"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_reports", kind: "message", T: c7, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ig().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ig().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ig().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ig, t, e)
    }
  },
  jq = class rg extends d {
    constructor(t) {
      super(),
        (this.inBackgroundSubsidized = !1),
        (this.hasTelemetry = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugBotRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "git_diff", kind: "message", T: i7 },
        { no: 2, name: "model_details", kind: "message", T: vt },
        { no: 3, name: "user_instructions", kind: "scalar", T: 9, opt: !0 },
        {
          no: 4,
          name: "bug_detection_guidelines",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        { no: 5, name: "iterations", kind: "scalar", T: 5, opt: !0 },
        {
          no: 12,
          name: "unified_context_lines",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 6, name: "in_background_subsidized", kind: "scalar", T: 8 },
        { no: 7, name: "session_id", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "price_id", kind: "scalar", T: 9, opt: !0 },
        { no: 9, name: "has_telemetry", kind: "scalar", T: 8 },
        { no: 10, name: "constrain_to_file", kind: "scalar", T: 9, opt: !0 },
        {
          no: 11,
          name: "constrain_to_range",
          kind: "message",
          T: Wft,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new rg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rg, t, e)
    }
  },
  Wft = class ng extends d {
    constructor(t) {
      super(),
        (this.startLine = 0),
        (this.endLineInclusive = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugBotRequest.Range"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_inclusive", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new ng().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ng().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ng().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ng, t, e)
    }
  },
  ROt = class sg extends d {
    constructor(t) {
      super(), (this.seed = ""), (this.date = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunBugBotPromptProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "req", kind: "message", T: jq },
        { no: 2, name: "seed", kind: "scalar", T: 9 },
        { no: 3, name: "date", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new sg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sg, t, e)
    }
  },
  jft = class ag extends d {
    constructor(t) {
      super(), (this.date = ""), (this.seed = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotDiscriminatorPromptProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "req", kind: "message", T: jq },
        { no: 2, name: "bug", kind: "message", T: c7 },
        { no: 3, name: "date", kind: "scalar", T: 9 },
        { no: 4, name: "seed", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ag().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ag().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ag().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ag, t, e)
    }
  },
  DOt = class og extends d {
    constructor(t) {
      super(), (this.isRealBug = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotDiscriminatorTrainingPromptProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "props", kind: "message", T: jft },
        { no: 2, name: "is_real_bug", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new og().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new og().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new og().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(og, t, e)
    }
  },
  bd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.ACCEPT = 1)] = "ACCEPT"),
    (i[(i.REJECT = 2)] = "REJECT"),
    (i[(i.PARTIAL_ACCEPT = 3)] = "PARTIAL_ACCEPT")
})(bd || (bd = {})),
  n.util.setEnumType(bd, "aiserver.v1.CppFate", [
    { no: 0, name: "CPP_FATE_UNSPECIFIED" },
    { no: 1, name: "CPP_FATE_ACCEPT" },
    { no: 2, name: "CPP_FATE_REJECT" },
    { no: 3, name: "CPP_FATE_PARTIAL_ACCEPT" },
  ])
var Ed
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.LINE_CHANGE = 1)] = "LINE_CHANGE"),
    (i[(i.TYPING = 2)] = "TYPING"),
    (i[(i.OPTION_HOLD = 3)] = "OPTION_HOLD"),
    (i[(i.LINTER_ERRORS = 4)] = "LINTER_ERRORS"),
    (i[(i.PARAMETER_HINTS = 5)] = "PARAMETER_HINTS"),
    (i[(i.CURSOR_PREDICTION = 6)] = "CURSOR_PREDICTION"),
    (i[(i.MANUAL_TRIGGER = 7)] = "MANUAL_TRIGGER"),
    (i[(i.EDITOR_CHANGE = 8)] = "EDITOR_CHANGE"),
    (i[(i.LSP_SUGGESTIONS = 9)] = "LSP_SUGGESTIONS")
})(Ed || (Ed = {})),
  n.util.setEnumType(Ed, "aiserver.v1.CppSource", [
    { no: 0, name: "CPP_SOURCE_UNSPECIFIED" },
    { no: 1, name: "CPP_SOURCE_LINE_CHANGE" },
    { no: 2, name: "CPP_SOURCE_TYPING" },
    { no: 3, name: "CPP_SOURCE_OPTION_HOLD" },
    { no: 4, name: "CPP_SOURCE_LINTER_ERRORS" },
    { no: 5, name: "CPP_SOURCE_PARAMETER_HINTS" },
    { no: 6, name: "CPP_SOURCE_CURSOR_PREDICTION" },
    { no: 7, name: "CPP_SOURCE_MANUAL_TRIGGER" },
    { no: 8, name: "CPP_SOURCE_EDITOR_CHANGE" },
    { no: 9, name: "CPP_SOURCE_LSP_SUGGESTIONS" },
  ])
var DQ = class cg extends d {
    constructor(t) {
      super(), (this.source = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppIntentInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "source", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new cg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cg, t, e)
    }
  },
  Vft = class ug extends d {
    constructor(t) {
      super(), (this.label = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LspSuggestion"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "label", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ug().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ug().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ug().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ug, t, e)
    }
  },
  Gft = class lg extends d {
    constructor(t) {
      super(), (this.suggestions = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LspSuggestedItems"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "suggestions", kind: "message", T: Vft, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new lg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lg, t, e)
    }
  },
  zft = class dg extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ShouldTurnOnCppOnboardingRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new dg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dg, t, e)
    }
  },
  Yft = class mg extends d {
    constructor(t) {
      super(),
        (this.shouldTurnOnCppOnboarding = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ShouldTurnOnCppOnboardingResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "should_turn_on_cpp_onboarding", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new mg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mg, t, e)
    }
  },
  Vq = class hg extends d {
    constructor(t) {
      super(),
        (this.diffHistory = []),
        (this.contextItems = []),
        (this.diffHistoryKeys = []),
        (this.fileDiffHistories = []),
        (this.mergedDiffHistories = []),
        (this.blockDiffPatches = []),
        (this.parameterHints = []),
        (this.lspContexts = []),
        (this.additionalFiles = []),
        (this.filesyncUpdates = []),
        (this.timeSinceRequestStart = 0),
        (this.timeAtRequestSend = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCppRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
        { no: 2, name: "diff_history", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "model_name", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "linter_errors", kind: "message", T: hi, opt: !0 },
        { no: 13, name: "context_items", kind: "message", T: zq, repeated: !0 },
        {
          no: 5,
          name: "diff_history_keys",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 6, name: "give_debug_output", kind: "scalar", T: 8, opt: !0 },
        {
          no: 7,
          name: "file_diff_histories",
          kind: "message",
          T: Di,
          repeated: !0,
        },
        {
          no: 8,
          name: "merged_diff_histories",
          kind: "message",
          T: Di,
          repeated: !0,
        },
        {
          no: 9,
          name: "block_diff_patches",
          kind: "message",
          T: Xq,
          repeated: !0,
        },
        { no: 10, name: "is_nightly", kind: "scalar", T: 8, opt: !0 },
        { no: 11, name: "is_debug", kind: "scalar", T: 8, opt: !0 },
        { no: 12, name: "immediately_ack", kind: "scalar", T: 8, opt: !0 },
        { no: 17, name: "enable_more_context", kind: "scalar", T: 8, opt: !0 },
        {
          no: 14,
          name: "parameter_hints",
          kind: "message",
          T: _Q,
          repeated: !0,
        },
        { no: 15, name: "lsp_contexts", kind: "message", T: Wq, repeated: !0 },
        { no: 16, name: "cpp_intent_info", kind: "message", T: DQ, opt: !0 },
        { no: 18, name: "workspace_id", kind: "scalar", T: 9, opt: !0 },
        {
          no: 19,
          name: "additional_files",
          kind: "message",
          T: cpt,
          repeated: !0,
        },
        {
          no: 20,
          name: "control_token",
          kind: "enum",
          T: n.getEnumType(u7),
          opt: !0,
        },
        { no: 21, name: "client_time", kind: "scalar", T: 1, opt: !0 },
        {
          no: 22,
          name: "filesync_updates",
          kind: "message",
          T: Sd,
          repeated: !0,
        },
        { no: 23, name: "time_since_request_start", kind: "scalar", T: 1 },
        { no: 24, name: "time_at_request_send", kind: "scalar", T: 1 },
        {
          no: 25,
          name: "client_timezone_offset",
          kind: "scalar",
          T: 1,
          opt: !0,
        },
        {
          no: 26,
          name: "lsp_suggested_items",
          kind: "message",
          T: Gft,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new hg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hg, t, e)
    }
  },
  u7
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.QUIET = 1)] = "QUIET"),
    (i[(i.LOUD = 2)] = "LOUD"),
    (i[(i.OP = 3)] = "OP")
})(u7 || (u7 = {})),
  n.util.setEnumType(u7, "aiserver.v1.StreamCppRequest.ControlToken", [
    { no: 0, name: "CONTROL_TOKEN_UNSPECIFIED" },
    { no: 1, name: "CONTROL_TOKEN_QUIET" },
    { no: 2, name: "CONTROL_TOKEN_LOUD" },
    { no: 3, name: "CONTROL_TOKEN_OP" },
  ])
var Qft = class fg extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCppResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "suggestion_start_line", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "suggestion_confidence", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "done_stream", kind: "scalar", T: 8, opt: !0 },
        { no: 5, name: "debug_model_output", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "debug_model_input", kind: "scalar", T: 9, opt: !0 },
        { no: 7, name: "debug_stream_time", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "debug_total_time", kind: "scalar", T: 9, opt: !0 },
        { no: 9, name: "debug_ttft_time", kind: "scalar", T: 9, opt: !0 },
        { no: 10, name: "debug_server_timing", kind: "scalar", T: 9, opt: !0 },
        { no: 11, name: "range_to_replace", kind: "message", T: vi, opt: !0 },
        {
          no: 12,
          name: "cursor_prediction_target",
          kind: "message",
          T: Xft,
          opt: !0,
        },
        { no: 13, name: "done_edit", kind: "scalar", T: 8, opt: !0 },
        { no: 14, name: "model_info", kind: "message", T: Kft, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new fg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fg, t, e)
    }
  },
  Xft = class pg extends d {
    constructor(t) {
      super(),
        (this.relativePath = ""),
        (this.lineNumberOneIndexed = 0),
        (this.expectedContent = ""),
        (this.shouldRetriggerCpp = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCppResponse.CursorPredictionTarget"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_path", kind: "scalar", T: 9 },
        { no: 2, name: "line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 3, name: "expected_content", kind: "scalar", T: 9 },
        { no: 4, name: "should_retrigger_cpp", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new pg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pg, t, e)
    }
  },
  Kft = class gg extends d {
    constructor(t) {
      super(),
        (this.isFusedCursorPredictionModel = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCppResponse.ModelInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "is_fused_cursor_prediction_model",
          kind: "scalar",
          T: 8,
        },
      ])
    }
    static fromBinary(t, e) {
      return new gg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gg, t, e)
    }
  },
  Zft = class vg extends d {
    constructor(t) {
      super(), (this.model = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppConfigRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "is_nightly", kind: "scalar", T: 8, opt: !0 },
        { no: 2, name: "model", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new vg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vg, t, e)
    }
  },
  tpt = class wg extends d {
    constructor(t) {
      super(),
        (this.heuristics = []),
        (this.excludeRecentlyViewedFilesPatterns = []),
        (this.enableRvfTracking = !1),
        (this.globalDebounceDurationMillis = 0),
        (this.clientDebounceDurationMillis = 0),
        (this.cppUrl = ""),
        (this.useWhitespaceDiffHistory = !1),
        (this.enableFilesyncDebounceSkipping = !1),
        (this.checkFilesyncHashPercent = 0),
        (this.geoCppBackendUrl = ""),
        (this.isFusedCursorPredictionModel = !1),
        (this.includeUnchangedLines = !1),
        (this.shouldFetchRvfText = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppConfigResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "above_radius", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "below_radius", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "merge_behavior", kind: "message", T: ipt, opt: !0 },
        { no: 5, name: "is_on", kind: "scalar", T: 8, opt: !0 },
        { no: 6, name: "is_ghost_text", kind: "scalar", T: 8, opt: !0 },
        {
          no: 7,
          name: "should_let_user_enable_cpp_even_if_not_pro",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 8,
          name: "heuristics",
          kind: "enum",
          T: n.getEnumType(l7),
          repeated: !0,
        },
        {
          no: 9,
          name: "exclude_recently_viewed_files_patterns",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 10, name: "enable_rvf_tracking", kind: "scalar", T: 8 },
        {
          no: 11,
          name: "global_debounce_duration_millis",
          kind: "scalar",
          T: 5,
        },
        {
          no: 12,
          name: "client_debounce_duration_millis",
          kind: "scalar",
          T: 5,
        },
        { no: 13, name: "cpp_url", kind: "scalar", T: 9 },
        { no: 14, name: "use_whitespace_diff_history", kind: "scalar", T: 8 },
        { no: 15, name: "import_prediction_config", kind: "message", T: ept },
        {
          no: 16,
          name: "enable_filesync_debounce_skipping",
          kind: "scalar",
          T: 8,
        },
        { no: 17, name: "check_filesync_hash_percent", kind: "scalar", T: 2 },
        { no: 18, name: "geo_cpp_backend_url", kind: "scalar", T: 9 },
        {
          no: 19,
          name: "recently_rejected_edit_thresholds",
          kind: "message",
          T: rpt,
          opt: !0,
        },
        {
          no: 20,
          name: "is_fused_cursor_prediction_model",
          kind: "scalar",
          T: 8,
        },
        { no: 21, name: "include_unchanged_lines", kind: "scalar", T: 8 },
        { no: 22, name: "should_fetch_rvf_text", kind: "scalar", T: 8 },
        {
          no: 23,
          name: "max_number_of_cleared_suggestions_since_last_accept",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 24,
          name: "suggestion_hint_config",
          kind: "message",
          T: npt,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new wg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wg, t, e)
    }
  },
  l7
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.LOTS_OF_ADDED_TEXT = 1)] = "LOTS_OF_ADDED_TEXT"),
    (i[(i.DUPLICATING_LINE_AFTER_SUGGESTION = 2)] =
      "DUPLICATING_LINE_AFTER_SUGGESTION"),
    (i[(i.DUPLICATING_MULTIPLE_LINES_AFTER_SUGGESTION = 3)] =
      "DUPLICATING_MULTIPLE_LINES_AFTER_SUGGESTION"),
    (i[(i.REVERTING_USER_CHANGE = 4)] = "REVERTING_USER_CHANGE"),
    (i[(i.OUTPUT_EXTENDS_BEYOND_RANGE_AND_IS_REPEATED = 5)] =
      "OUTPUT_EXTENDS_BEYOND_RANGE_AND_IS_REPEATED"),
    (i[(i.SUGGESTING_RECENTLY_REJECTED_EDIT = 6)] =
      "SUGGESTING_RECENTLY_REJECTED_EDIT")
})(l7 || (l7 = {})),
  n.util.setEnumType(l7, "aiserver.v1.CppConfigResponse.Heuristic", [
    { no: 0, name: "HEURISTIC_UNSPECIFIED" },
    { no: 1, name: "HEURISTIC_LOTS_OF_ADDED_TEXT" },
    { no: 2, name: "HEURISTIC_DUPLICATING_LINE_AFTER_SUGGESTION" },
    { no: 3, name: "HEURISTIC_DUPLICATING_MULTIPLE_LINES_AFTER_SUGGESTION" },
    { no: 4, name: "HEURISTIC_REVERTING_USER_CHANGE" },
    { no: 5, name: "HEURISTIC_OUTPUT_EXTENDS_BEYOND_RANGE_AND_IS_REPEATED" },
    { no: 6, name: "HEURISTIC_SUGGESTING_RECENTLY_REJECTED_EDIT" },
  ])
var ept = class yg extends d {
    constructor(t) {
      super(),
        (this.isDisabledByBackend = !1),
        (this.shouldTurnOnAutomatically = !1),
        (this.pythonEnabled = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppConfigResponse.ImportPredictionConfig"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "is_disabled_by_backend", kind: "scalar", T: 8 },
        { no: 2, name: "should_turn_on_automatically", kind: "scalar", T: 8 },
        { no: 3, name: "python_enabled", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new yg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yg, t, e)
    }
  },
  ipt = class Tg extends d {
    constructor(t) {
      super(), (this.type = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppConfigResponse.MergeBehavior"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type", kind: "scalar", T: 9 },
        { no: 2, name: "limit", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "radius", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Tg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Tg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Tg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Tg, t, e)
    }
  },
  rpt = class kg extends d {
    constructor(t) {
      super(),
        (this.hardRejectThreshold = 0),
        (this.softRejectThreshold = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.CppConfigResponse.RecentlyRejectedEditThresholds"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "hard_reject_threshold", kind: "scalar", T: 5 },
        { no: 2, name: "soft_reject_threshold", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new kg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kg, t, e)
    }
  },
  npt = class Sg extends d {
    constructor(t) {
      super(),
        (this.importantLspExtensions = []),
        (this.enabledForPathExtensions = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppConfigResponse.SuggestionHintConfig"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "important_lsp_extensions",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 2,
          name: "enabled_for_path_extensions",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Sg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Sg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Sg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Sg, t, e)
    }
  },
  FQ = class bg extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SuggestedEdit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "edit_range", kind: "message", T: mi },
        { no: 2, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new bg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bg, t, e)
    }
  },
  spt = class Eg extends d {
    constructor(t) {
      super(),
        (this.suggestedEdits = []),
        (this.markerTouchesGreen = !1),
        (this.currentFileContentsForLinterErrors = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetCppEditClassificationRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cpp_request", kind: "message", T: Vq },
        {
          no: 25,
          name: "suggested_edits",
          kind: "message",
          T: FQ,
          repeated: !0,
        },
        { no: 26, name: "marker_touches_green", kind: "scalar", T: 8 },
        {
          no: 27,
          name: "current_file_contents_for_linter_errors",
          kind: "scalar",
          T: 9,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Eg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Eg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Eg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Eg, t, e)
    }
  },
  apt = class Ig extends d {
    constructor(t) {
      super(), (this.scoredEdits = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetCppEditClassificationResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "scored_edits", kind: "message", T: Gq, repeated: !0 },
        { no: 2, name: "noop_edit", kind: "message", T: Gq },
        { no: 3, name: "should_noop", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "generation_edit", kind: "message", T: Gq },
      ])
    }
    static fromBinary(t, e) {
      return new Ig().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ig().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ig().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ig, t, e)
    }
  },
  opt = class Pg extends d {
    constructor(t) {
      super(),
        (this.tokens = []),
        (this.tokenLogprobs = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetCppEditClassificationResponse.LogProbs"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tokens", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "token_logprobs", kind: "scalar", T: 1, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Pg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Pg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Pg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Pg, t, e)
    }
  },
  Gq = class Ng extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetCppEditClassificationResponse.ScoredEdit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "edit", kind: "message", T: FQ },
        { no: 2, name: "log_probs", kind: "message", T: opt },
      ])
    }
    static fromBinary(t, e) {
      return new Ng().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ng().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ng().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ng, t, e)
    }
  },
  cpt = class $g extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.isOpen = !1),
        (this.visibleRangeContent = []),
        (this.startLineNumberOneIndexed = []),
        (this.visibleRanges = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AdditionalFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "is_open", kind: "scalar", T: 8 },
        {
          no: 3,
          name: "visible_range_content",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 4, name: "last_viewed_at", kind: "scalar", T: 1, opt: !0 },
        {
          no: 5,
          name: "start_line_number_one_indexed",
          kind: "scalar",
          T: 5,
          repeated: !0,
        },
        { no: 6, name: "visible_ranges", kind: "message", T: vi, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new $g().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $g().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $g().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($g, t, e)
    }
  },
  upt = class xg extends d {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.performanceNowTime = 0),
        (this.fate = bd.UNSPECIFIED),
        (this.extension = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RecordCppFateRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "performance_now_time", kind: "scalar", T: 2 },
        { no: 3, name: "fate", kind: "enum", T: n.getEnumType(bd) },
        { no: 4, name: "extension", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new xg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xg, t, e)
    }
  },
  lpt = class Jg extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RecordCppFateResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Jg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Jg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Jg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Jg, t, e)
    }
  },
  dpt = class Cg extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AvailableCppModelsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Cg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Cg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Cg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Cg, t, e)
    }
  },
  mpt = class Lg extends d {
    constructor(t) {
      super(), (this.models = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AvailableCppModelsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "models", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "default_model", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Lg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Lg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Lg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Lg, t, e)
    }
  },
  hpt = class Rg extends d {
    constructor(t) {
      super(),
        (this.contextItems = []),
        (this.fileDiffHistories = []),
        (this.mergedDiffHistories = []),
        (this.blockDiffPatches = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamHoldCppRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
        { no: 4, name: "linter_errors", kind: "message", T: hi, opt: !0 },
        { no: 13, name: "context_items", kind: "message", T: zq, repeated: !0 },
        {
          no: 7,
          name: "file_diff_histories",
          kind: "message",
          T: Di,
          repeated: !0,
        },
        {
          no: 8,
          name: "merged_diff_histories",
          kind: "message",
          T: Di,
          repeated: !0,
        },
        {
          no: 9,
          name: "block_diff_patches",
          kind: "message",
          T: Xq,
          repeated: !0,
        },
        { no: 10, name: "model_details", kind: "message", T: vt },
      ])
    }
    static fromBinary(t, e) {
      return new Rg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Rg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Rg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Rg, t, e)
    }
  },
  fpt = class Dg extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamHoldCppResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Dg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Dg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Dg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Dg, t, e)
    }
  },
  Di = class Fg extends d {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.diffHistory = []),
        (this.diffHistoryTimestamps = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppFileDiffHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "diff_history", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 3,
          name: "diff_history_timestamps",
          kind: "scalar",
          T: 1,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Fg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Fg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Fg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Fg, t, e)
    }
  },
  zq = class _g extends d {
    constructor(t) {
      super(),
        (this.contents = ""),
        (this.relativeWorkspacePath = ""),
        (this.score = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppContextItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "contents", kind: "scalar", T: 9 },
        { no: 2, name: "symbol", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new _g().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _g().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _g().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_g, t, e)
    }
  },
  ppt = class Ag extends d {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.sessionId = ""),
        (this.responseType = Id.UNSPECIFIED),
        (this.modelCodeName = ""),
        (this.modelOpenaiName = ""),
        (this.currentPerformanceNowTime = 0),
        (this.sessionPerformanceOriginTime = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MarkCppRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "session_id", kind: "scalar", T: 9 },
        { no: 3, name: "response_type", kind: "enum", T: n.getEnumType(Id) },
        { no: 4, name: "desired_completion", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "range_transformation", kind: "message", T: gpt },
        { no: 10, name: "model_code_name", kind: "scalar", T: 9 },
        { no: 11, name: "model_openai_name", kind: "scalar", T: 9 },
        { no: 12, name: "current_performance_now_time", kind: "scalar", T: 1 },
        {
          no: 13,
          name: "session_performance_origin_time",
          kind: "scalar",
          T: 1,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Ag().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ag().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ag().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ag, t, e)
    }
  },
  Id
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.GOOD = 1)] = "GOOD"),
    (i[(i.BAD = 2)] = "BAD"),
    (i[(i.BAD_CONTEXT = 3)] = "BAD_CONTEXT"),
    (i[(i.BAD_REASONING = 4)] = "BAD_REASONING"),
    (i[(i.BAD_STUPID_MISTAKE = 5)] = "BAD_STUPID_MISTAKE"),
    (i[(i.BAD_FORMATTING = 6)] = "BAD_FORMATTING"),
    (i[(i.BAD_RANGE = 7)] = "BAD_RANGE"),
    (i[(i.GOOD_PREDICTION = 8)] = "GOOD_PREDICTION"),
    (i[(i.BAD_FALSE_POSITIVE_TRIGGER = 9)] = "BAD_FALSE_POSITIVE_TRIGGER"),
    (i[(i.BAD_FALSE_NEGATIVE_TRIGGER = 10)] = "BAD_FALSE_NEGATIVE_TRIGGER")
})(Id || (Id = {})),
  n.util.setEnumType(Id, "aiserver.v1.MarkCppRequest.CppResponseTypes", [
    { no: 0, name: "CPP_RESPONSE_TYPES_UNSPECIFIED" },
    { no: 1, name: "CPP_RESPONSE_TYPES_GOOD" },
    { no: 2, name: "CPP_RESPONSE_TYPES_BAD" },
    { no: 3, name: "CPP_RESPONSE_TYPES_BAD_CONTEXT" },
    { no: 4, name: "CPP_RESPONSE_TYPES_BAD_REASONING" },
    { no: 5, name: "CPP_RESPONSE_TYPES_BAD_STUPID_MISTAKE" },
    { no: 6, name: "CPP_RESPONSE_TYPES_BAD_FORMATTING" },
    { no: 7, name: "CPP_RESPONSE_TYPES_BAD_RANGE" },
    { no: 8, name: "CPP_RESPONSE_TYPES_GOOD_PREDICTION" },
    { no: 9, name: "CPP_RESPONSE_TYPES_BAD_FALSE_POSITIVE_TRIGGER" },
    { no: 10, name: "CPP_RESPONSE_TYPES_BAD_FALSE_NEGATIVE_TRIGGER" },
  ])
var gpt = class Bg extends d {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.endLineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MarkCppRequest.RangeTransformation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Bg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Bg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Bg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Bg, t, e)
    }
  },
  _Q = class Og extends d {
    constructor(t) {
      super(), (this.label = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppParameterHint"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "label", kind: "scalar", T: 9 },
        { no: 2, name: "documentation", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Og().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Og().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Og().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Og, t, e)
    }
  },
  vpt = class qg extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MarkCppResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new qg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qg, t, e)
    }
  },
  sr = class Ug extends d {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.startColumn = 0),
        (this.endLineNumber = 0),
        (this.endColumn = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "start_column", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "end_column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Ug().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ug().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ug().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ug, t, e)
    }
  },
  d7 = class Mg extends d {
    constructor(t) {
      super(),
        (this.lineNumberOneIndexed = 0),
        (this.columnOneIndexed = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OneIndexedPosition"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 2, name: "column_one_indexed", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Mg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Mg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Mg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Mg, t, e)
    }
  },
  wpt = class Hg extends d {
    constructor(t) {
      super(),
        (this.selectionStartLineNumber = 0),
        (this.selectionStartColumn = 0),
        (this.positionLineNumber = 0),
        (this.positionColumn = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CursorSelection"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "selection_start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "selection_start_column", kind: "scalar", T: 5 },
        { no: 3, name: "position_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "position_column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Hg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Hg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Hg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Hg, t, e)
    }
  },
  Pd = class Wg extends d {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.modelIsAttachedToEditor = !1),
        (this.modelIsAttachedToTheActiveEditor = !1),
        (this.cursorSelections = []),
        (this.modelVersionAtMetadataRetrievalTime = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelChange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: sr },
        { no: 3, name: "final_model_hash", kind: "scalar", T: 9, opt: !0 },
        {
          no: 4,
          name: "model_version_immediately_after_this_change",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 5,
          name: "performance_now_timestamp",
          kind: "scalar",
          T: 1,
          opt: !0,
        },
        { no: 7, name: "is_undoing", kind: "scalar", T: 8, opt: !0 },
        { no: 8, name: "is_redoing", kind: "scalar", T: 8, opt: !0 },
        { no: 9, name: "model_is_attached_to_editor", kind: "scalar", T: 8 },
        {
          no: 10,
          name: "model_is_attached_to_the_active_editor",
          kind: "scalar",
          T: 8,
        },
        {
          no: 11,
          name: "cursor_selections",
          kind: "message",
          T: wpt,
          repeated: !0,
        },
        {
          no: 12,
          name: "model_version_at_metadata_retrieval_time",
          kind: "scalar",
          T: 5,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Wg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Wg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Wg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Wg, t, e)
    }
  },
  m7 = class jg extends d {
    constructor(t) {
      super(),
        (this.suggestionId = 0),
        (this.suggestionText = ""),
        (this.modelVersionWhenTheChangeIsFirstIndicatedToTheUserButNotShownInTheModel = 0),
        (this.originalText = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CurrentlyShownCppSuggestion"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "suggestion_id", kind: "scalar", T: 5 },
        { no: 2, name: "suggestion_text", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "model_version_when_the_change_is_first_indicated_to_the_user_but_not_shown_in_the_model",
          kind: "scalar",
          T: 5,
        },
        {
          no: 4,
          name: "range_of_suggestion_in_current_model",
          kind: "message",
          T: sr,
          opt: !0,
        },
        { no: 5, name: "original_text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new jg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jg, t, e)
    }
  },
  ypt = class Vg extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppAcceptEventNew"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cpp_suggestion", kind: "message", T: m7 },
        { no: 7, name: "point_in_time_model", kind: "message", T: je },
      ])
    }
    static fromBinary(t, e) {
      return new Vg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Vg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Vg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Vg, t, e)
    }
  },
  AQ = class Gg extends d {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.suggestionText = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RecoverableCppData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "suggestion_text", kind: "scalar", T: 9 },
        { no: 3, name: "suggestion_range", kind: "message", T: sr },
        { no: 4, name: "position", kind: "message", T: d7 },
      ])
    }
    static fromBinary(t, e) {
      return new Gg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Gg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Gg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Gg, t, e)
    }
  },
  Tpt = class zg extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppSuggestEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cpp_suggestion", kind: "message", T: m7 },
        { no: 2, name: "point_in_time_model", kind: "message", T: je },
        { no: 3, name: "recoverable_cpp_data", kind: "message", T: AQ },
      ])
    }
    static fromBinary(t, e) {
      return new zg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zg, t, e)
    }
  },
  kpt = class Yg extends d {
    constructor(t) {
      super(),
        (this.generationUuid = ""),
        (this.modelVersion = 0),
        (this.source = Ed.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppTriggerEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "generation_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "model_version", kind: "scalar", T: 5 },
        { no: 3, name: "cursor_position", kind: "message", T: d7 },
        { no: 4, name: "point_in_time_model", kind: "message", T: je },
        { no: 5, name: "source", kind: "enum", T: n.getEnumType(Ed) },
      ])
    }
    static fromBinary(t, e) {
      return new Yg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Yg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Yg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Yg, t, e)
    }
  },
  Spt = class Qg extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FinishedCppGenerationEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: je },
        { no: 2, name: "recoverable_cpp_data", kind: "message", T: AQ },
      ])
    }
    static fromBinary(t, e) {
      return new Qg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Qg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Qg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Qg, t, e)
    }
  },
  bpt = class Xg extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppRejectEventNew"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cpp_suggestion", kind: "message", T: m7 },
        { no: 7, name: "point_in_time_model", kind: "message", T: je },
      ])
    }
    static fromBinary(t, e) {
      return new Xg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Xg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Xg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Xg, t, e)
    }
  },
  Ept = class Kg extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Edit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: sr },
      ])
    }
    static fromBinary(t, e) {
      return new Kg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Kg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Kg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Kg, t, e)
    }
  },
  Ipt = class Zg extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppPartialAcceptEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cpp_suggestion", kind: "message", T: m7 },
        { no: 2, name: "edit", kind: "message", T: Ept },
        { no: 3, name: "point_in_time_model", kind: "message", T: je },
      ])
    }
    static fromBinary(t, e) {
      return new Zg().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Zg().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Zg().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Zg, t, e)
    }
  },
  Yq = class tv extends d {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.predictionId = 0),
        (this.lineNumber = 0),
        (this.source = Nd.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CursorPrediction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "prediction_id", kind: "scalar", T: 5 },
        { no: 3, name: "line_number", kind: "scalar", T: 5 },
        { no: 4, name: "source", kind: "enum", T: n.getEnumType(Nd) },
      ])
    }
    static fromBinary(t, e) {
      return new tv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tv, t, e)
    }
  },
  Nd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.ALWAYS_ON = 1)] = "ALWAYS_ON"),
    (i[(i.ACCEPT = 2)] = "ACCEPT"),
    (i[(i.UNDO = 3)] = "UNDO"),
    (i[(i.EDITOR_CHANGE = 4)] = "EDITOR_CHANGE")
})(Nd || (Nd = {})),
  n.util.setEnumType(
    Nd,
    "aiserver.v1.CursorPrediction.CursorPredictionSource",
    [
      { no: 0, name: "CURSOR_PREDICTION_SOURCE_UNSPECIFIED" },
      { no: 1, name: "CURSOR_PREDICTION_SOURCE_ALWAYS_ON" },
      { no: 2, name: "CURSOR_PREDICTION_SOURCE_ACCEPT" },
      { no: 3, name: "CURSOR_PREDICTION_SOURCE_UNDO" },
      { no: 4, name: "CURSOR_PREDICTION_SOURCE_EDITOR_CHANGE" },
    ],
  )
var Ppt = class ev extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SuggestCursorPredictionEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cursor_prediction", kind: "message", T: Yq },
        { no: 2, name: "point_in_time_model", kind: "message", T: je },
      ])
    }
    static fromBinary(t, e) {
      return new ev().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ev().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ev().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ev, t, e)
    }
  },
  Npt = class iv extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AcceptCursorPredictionEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cursor_prediction", kind: "message", T: Yq },
        { no: 2, name: "point_in_time_model", kind: "message", T: je },
      ])
    }
    static fromBinary(t, e) {
      return new iv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iv, t, e)
    }
  },
  $pt = class rv extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RejectCursorPredictionEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cursor_prediction", kind: "message", T: Yq },
        { no: 2, name: "point_in_time_model", kind: "message", T: je },
      ])
    }
    static fromBinary(t, e) {
      return new rv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rv, t, e)
    }
  },
  BQ = class nv extends d {
    constructor(t) {
      super(),
        (this.modelVersion = 0),
        (this.relativePath = ""),
        (this.modelId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MaybeDefinedPointInTimeModel"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_uuid", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "model_version", kind: "scalar", T: 5 },
        { no: 3, name: "relative_path", kind: "scalar", T: 9 },
        { no: 4, name: "model_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new nv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nv, t, e)
    }
  },
  je = class sv extends d {
    constructor(t) {
      super(),
        (this.modelUuid = ""),
        (this.modelVersion = 0),
        (this.relativePath = ""),
        (this.modelId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PointInTimeModel"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "model_version", kind: "scalar", T: 5 },
        { no: 3, name: "relative_path", kind: "scalar", T: 9 },
        { no: 4, name: "model_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new sv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sv, t, e)
    }
  },
  xpt = class av extends d {
    constructor(t) {
      super(),
        (this.lineNumberOneIndexed = 0),
        (this.columnNumberOneIndexed = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppManualTriggerEventNew"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 2, name: "column_number_one_indexed", kind: "scalar", T: 5 },
        { no: 7, name: "point_in_time_model", kind: "message", T: je },
      ])
    }
    static fromBinary(t, e) {
      return new av().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new av().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new av().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(av, t, e)
    }
  },
  Jpt = class ov extends d {
    constructor(t) {
      super(),
        (this.modelUuid = ""),
        (this.relativePath = ""),
        (this.reason = $d.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppStoppedTrackingModelEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "relative_path", kind: "scalar", T: 9 },
        { no: 3, name: "reason", kind: "enum", T: n.getEnumType($d) },
      ])
    }
    static fromBinary(t, e) {
      return new ov().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ov().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ov().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ov, t, e)
    }
  },
  $d
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.FILE_TOO_BIG = 1)] = "FILE_TOO_BIG"),
    (i[(i.FILE_DISPOSED = 2)] = "FILE_DISPOSED"),
    (i[(i.CHANGE_TOO_BIG = 3)] = "CHANGE_TOO_BIG")
})($d || ($d = {})),
  n.util.setEnumType(
    $d,
    "aiserver.v1.CppStoppedTrackingModelEvent.StoppedTrackingModelReason",
    [
      { no: 0, name: "STOPPED_TRACKING_MODEL_REASON_UNSPECIFIED" },
      { no: 1, name: "STOPPED_TRACKING_MODEL_REASON_FILE_TOO_BIG" },
      { no: 2, name: "STOPPED_TRACKING_MODEL_REASON_FILE_DISPOSED" },
      { no: 3, name: "STOPPED_TRACKING_MODEL_REASON_CHANGE_TOO_BIG" },
    ],
  )
var Cpt = class cv extends d {
    constructor(t) {
      super(),
        (this.addedErrors = []),
        (this.removedErrors = []),
        (this.errors = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppLinterErrorEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: je },
        { no: 2, name: "added_errors", kind: "message", T: Js, repeated: !0 },
        { no: 3, name: "removed_errors", kind: "message", T: Js, repeated: !0 },
        { no: 4, name: "errors", kind: "message", T: Js, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new cv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cv, t, e)
    }
  },
  Lpt = class uv extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppDebouncedCursorMovementEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: je },
        { no: 2, name: "cursor_position", kind: "message", T: d7 },
      ])
    }
    static fromBinary(t, e) {
      return new uv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uv, t, e)
    }
  },
  Rpt = class lv extends d {
    constructor(t) {
      super(),
        (this.visibleRanges = []),
        (this.editorId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppEditorChangedEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: je },
        { no: 2, name: "cursor_position", kind: "message", T: d7 },
        { no: 3, name: "visible_ranges", kind: "message", T: sr, repeated: !0 },
        { no: 4, name: "editor_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new lv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lv, t, e)
    }
  },
  Dpt = class dv extends d {
    constructor(t) {
      super(), (this.clipboardContents = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppCopyEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "clipboard_contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new dv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dv, t, e)
    }
  },
  OQ = class mv extends d {
    constructor(t) {
      super(),
        (this.title = ""),
        (this.id = ""),
        (this.arguments = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppQuickActionCommand"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "id", kind: "scalar", T: 9 },
        { no: 3, name: "arguments", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new mv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mv, t, e)
    }
  },
  h7 = class hv extends d {
    constructor(t) {
      super(), (this.title = ""), (this.edits = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppQuickAction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "edits", kind: "message", T: Fpt, repeated: !0 },
        { no: 3, name: "is_preferred", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "command", kind: "message", T: OQ },
      ])
    }
    static fromBinary(t, e) {
      return new hv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hv, t, e)
    }
  },
  Fpt = class fv extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppQuickAction.Edit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: sr },
      ])
    }
    static fromBinary(t, e) {
      return new fv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fv, t, e)
    }
  },
  _pt = class pv extends d {
    constructor(t) {
      super(),
        (this.added = []),
        (this.removed = []),
        (this.actions = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppChangeQuickActionEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: je },
        { no: 2, name: "added", kind: "message", T: h7, repeated: !0 },
        { no: 3, name: "removed", kind: "message", T: h7, repeated: !0 },
        { no: 4, name: "actions", kind: "message", T: h7, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new pv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pv, t, e)
    }
  },
  Apt = class gv extends d {
    constructor(t) {
      super(),
        (this.actionIdentifier = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppQuickActionFireEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: je },
        {
          no: 2,
          name: "quick_action_command",
          kind: "message",
          T: OQ,
          oneof: "action_identifier",
        },
        {
          no: 3,
          name: "quick_action_event",
          kind: "message",
          T: h7,
          oneof: "action_identifier",
        },
      ])
    }
    static fromBinary(t, e) {
      return new gv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gv, t, e)
    }
  },
  Bpt = class vv extends d {
    constructor(t) {
      super(),
        (this.terminalId = 0),
        (this.terminalPath = ""),
        (this.event = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppTerminalEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "terminal_id", kind: "scalar", T: 5 },
        { no: 2, name: "terminal_path", kind: "scalar", T: 9 },
        { no: 6, name: "terminal_cwd", kind: "scalar", T: 9, opt: !0 },
        {
          no: 3,
          name: "terminal_input",
          kind: "message",
          T: Opt,
          oneof: "event",
        },
        {
          no: 4,
          name: "command_started",
          kind: "message",
          T: qpt,
          oneof: "event",
        },
        {
          no: 5,
          name: "command_finished",
          kind: "message",
          T: Upt,
          oneof: "event",
        },
      ])
    }
    static fromBinary(t, e) {
      return new vv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vv, t, e)
    }
  },
  Opt = class wv extends d {
    constructor(t) {
      super(), (this.bufferedKeypresses = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppTerminalEvent.TerminalInput"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "buffered_keypresses",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new wv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wv, t, e)
    }
  },
  qpt = class yv extends d {
    constructor(t) {
      super(),
        (this.command = ""),
        (this.startedTimestampUnixMs = 0),
        (this.commandWasTrimmed = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppTerminalEvent.CommandStarted"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
        { no: 2, name: "started_timestamp_unix_ms", kind: "scalar", T: 1 },
        { no: 3, name: "command_was_trimmed", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new yv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yv, t, e)
    }
  },
  Upt = class Tv extends d {
    constructor(t) {
      super(),
        (this.command = ""),
        (this.output = ""),
        (this.finishedTimestampUnixMs = 0),
        (this.commandWasTrimmed = !1),
        (this.outputWasTrimmed = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppTerminalEvent.CommandFinished"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
        { no: 2, name: "exit_code", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "output", kind: "scalar", T: 9 },
        { no: 4, name: "finished_timestamp_unix_ms", kind: "scalar", T: 1 },
        { no: 5, name: "command_was_trimmed", kind: "scalar", T: 8 },
        { no: 6, name: "output_was_trimmed", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Tv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Tv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Tv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Tv, t, e)
    }
  },
  Mpt = class kv extends d {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.eventType = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: je },
        { no: 2, name: "request_id", kind: "scalar", T: 9 },
        { no: 20, name: "prompt_bar_id", kind: "scalar", T: 9, opt: !0 },
        {
          no: 3,
          name: "submit_prompt",
          kind: "message",
          T: Hpt,
          oneof: "event_type",
        },
        {
          no: 4,
          name: "end_of_generation",
          kind: "message",
          T: Wpt,
          oneof: "event_type",
        },
        {
          no: 5,
          name: "interrupt_generation",
          kind: "message",
          T: jpt,
          oneof: "event_type",
        },
        {
          no: 6,
          name: "accept_all",
          kind: "message",
          T: Vpt,
          oneof: "event_type",
        },
        {
          no: 7,
          name: "reject_all",
          kind: "message",
          T: Gpt,
          oneof: "event_type",
        },
        {
          no: 8,
          name: "reject_partial_diff",
          kind: "message",
          T: Ypt,
          oneof: "event_type",
        },
        {
          no: 9,
          name: "accept_partial_diff",
          kind: "message",
          T: zpt,
          oneof: "event_type",
        },
      ])
    }
    static fromBinary(t, e) {
      return new kv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kv, t, e)
    }
  },
  Hpt = class Sv extends d {
    constructor(t) {
      super(),
        (this.originalText = ""),
        (this.prompt = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKEvent.SubmitPrompt"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "original_range", kind: "message", T: sr },
        { no: 2, name: "original_text", kind: "scalar", T: 9 },
        { no: 3, name: "prompt", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Sv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Sv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Sv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Sv, t, e)
    }
  },
  Wpt = class bv extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKEvent.EndOfGeneration"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new bv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bv, t, e)
    }
  },
  jpt = class Ev extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKEvent.InterruptGeneration"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Ev().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ev().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ev().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ev, t, e)
    }
  },
  Vpt = class Iv extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKEvent.AcceptDiffs"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Iv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Iv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Iv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Iv, t, e)
    }
  },
  Gpt = class Pv extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKEvent.RejectDiffs"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Pv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Pv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Pv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Pv, t, e)
    }
  },
  zpt = class Nv extends d {
    constructor(t) {
      super(),
        (this.greenLines = []),
        (this.redLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKEvent.AcceptPartialDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "green_range", kind: "message", T: sr },
        { no: 2, name: "green_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "red_lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Nv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Nv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Nv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Nv, t, e)
    }
  },
  Ypt = class $v extends d {
    constructor(t) {
      super(),
        (this.greenLines = []),
        (this.redLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKEvent.RejectPartialDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "green_range", kind: "message", T: sr },
        { no: 2, name: "green_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "red_lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new $v().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $v().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $v().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($v, t, e)
    }
  },
  Qpt = class xv extends d {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.eventType = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChatEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "submit_prompt",
          kind: "message",
          T: Xpt,
          oneof: "event_type",
        },
        {
          no: 3,
          name: "end_of_any_generation",
          kind: "message",
          T: Kpt,
          oneof: "event_type",
        },
        {
          no: 4,
          name: "end_of_uninterrupted_generation",
          kind: "message",
          T: Zpt,
          oneof: "event_type",
        },
      ])
    }
    static fromBinary(t, e) {
      return new xv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xv, t, e)
    }
  },
  Xpt = class Jv extends d {
    constructor(t) {
      super(), (this.prompt = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChatEvent.SubmitPrompt"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "prompt", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Jv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Jv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Jv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Jv, t, e)
    }
  },
  Kpt = class Cv extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChatEvent.EndOfAnyGeneration"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Cv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Cv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Cv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Cv, t, e)
    }
  },
  Zpt = class Lv extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChatEvent.EndOfUninterruptedGeneration"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Lv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Lv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Lv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Lv, t, e)
    }
  },
  tgt = class Rv extends d {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.eventType = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotLinterEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "point_in_time_model", kind: "message", T: je },
        {
          no: 3,
          name: "lint_generated",
          kind: "message",
          T: igt,
          oneof: "event_type",
        },
        {
          no: 4,
          name: "lint_dismissed",
          kind: "message",
          T: rgt,
          oneof: "event_type",
        },
        {
          no: 5,
          name: "user_feedback",
          kind: "message",
          T: ngt,
          oneof: "event_type",
        },
        {
          no: 6,
          name: "viewed_report",
          kind: "message",
          T: sgt,
          oneof: "event_type",
        },
        {
          no: 7,
          name: "unviewed_report",
          kind: "message",
          T: agt,
          oneof: "event_type",
        },
        {
          no: 8,
          name: "started",
          kind: "message",
          T: egt,
          oneof: "event_type",
        },
        {
          no: 9,
          name: "not_shown_because_heuristic",
          kind: "message",
          T: ogt,
          oneof: "event_type",
        },
      ])
    }
    static fromBinary(t, e) {
      return new Rv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Rv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Rv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Rv, t, e)
    }
  },
  egt = class Dv extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotLinterEvent.Started"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Dv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Dv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Dv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Dv, t, e)
    }
  },
  igt = class Fv extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotLinterEvent.LintGenerated"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_report", kind: "message", T: c7 },
      ])
    }
    static fromBinary(t, e) {
      return new Fv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Fv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Fv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Fv, t, e)
    }
  },
  rgt = class _v extends d {
    constructor(t) {
      super(), (this.bugReportId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotLinterEvent.LintDismissed"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_report_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new _v().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _v().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _v().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_v, t, e)
    }
  },
  ngt = class Av extends d {
    constructor(t) {
      super(),
        (this.bugReportId = ""),
        (this.feedback = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotLinterEvent.UserFeedback"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_report_id", kind: "scalar", T: 9 },
        { no: 2, name: "feedback", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Av().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Av().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Av().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Av, t, e)
    }
  },
  sgt = class Bv extends d {
    constructor(t) {
      super(), (this.bugReportId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotLinterEvent.ViewedReport"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_report_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Bv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Bv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Bv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Bv, t, e)
    }
  },
  agt = class Ov extends d {
    constructor(t) {
      super(), (this.bugReportId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotLinterEvent.UnviewedReport"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_report_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ov().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ov().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ov().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ov, t, e)
    }
  },
  ogt = class qv extends d {
    constructor(t) {
      super(), (this.heuristic = xd.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotLinterEvent.NotShownBecauseHeuristic"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "heuristic", kind: "enum", T: n.getEnumType(xd) },
      ])
    }
    static fromBinary(t, e) {
      return new qv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qv, t, e)
    }
  },
  xd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.LINT_OVERLAP = 1)] = "LINT_OVERLAP"),
    (i[(i.LINES_MISMATCH = 2)] = "LINES_MISMATCH")
})(xd || (xd = {})),
  n.util.setEnumType(
    xd,
    "aiserver.v1.BugBotLinterEvent.NotShownBecauseHeuristic.Heuristic",
    [
      { no: 0, name: "HEURISTIC_UNSPECIFIED" },
      { no: 1, name: "HEURISTIC_LINT_OVERLAP" },
      { no: 2, name: "HEURISTIC_LINES_MISMATCH" },
    ],
  )
var cgt = class Uv extends d {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.eventType = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "started",
          kind: "message",
          T: ugt,
          oneof: "event_type",
        },
        {
          no: 3,
          name: "reports_generated",
          kind: "message",
          T: lgt,
          oneof: "event_type",
        },
        {
          no: 4,
          name: "pressed_fix_in_composer",
          kind: "message",
          T: dgt,
          oneof: "event_type",
        },
        {
          no: 5,
          name: "pressed_open_in_editor",
          kind: "message",
          T: hgt,
          oneof: "event_type",
        },
        {
          no: 6,
          name: "viewed_report",
          kind: "message",
          T: fgt,
          oneof: "event_type",
        },
        {
          no: 7,
          name: "user_feedback",
          kind: "message",
          T: ggt,
          oneof: "event_type",
        },
        {
          no: 8,
          name: "pressed_add_to_chat",
          kind: "message",
          T: mgt,
          oneof: "event_type",
        },
        {
          no: 9,
          name: "background_interval_started",
          kind: "message",
          T: vgt,
          oneof: "event_type",
        },
        {
          no: 10,
          name: "background_interval_ended",
          kind: "message",
          T: wgt,
          oneof: "event_type",
        },
        {
          no: 11,
          name: "background_interval_interrupted",
          kind: "message",
          T: ygt,
          oneof: "event_type",
        },
        {
          no: 12,
          name: "background_interval_errored",
          kind: "message",
          T: Tgt,
          oneof: "event_type",
        },
      ])
    }
    static fromBinary(t, e) {
      return new Uv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Uv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Uv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Uv, t, e)
    }
  },
  Jd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.DISABLED = 1)] = "DISABLED"),
    (i[(i.TOO_RECENT = 2)] = "TOO_RECENT"),
    (i[(i.UNVIEWED_BUG_REPORTS = 3)] = "UNVIEWED_BUG_REPORTS"),
    (i[(i.NOT_IN_GIT_REPO = 4)] = "NOT_IN_GIT_REPO"),
    (i[(i.DEFAULT_BRANCH_IS_NOT_CURRENT_BRANCH = 5)] =
      "DEFAULT_BRANCH_IS_NOT_CURRENT_BRANCH"),
    (i[(i.NO_GIT_USER = 6)] = "NO_GIT_USER"),
    (i[(i.NO_LAST_COMMIT = 7)] = "NO_LAST_COMMIT"),
    (i[(i.LAST_COMMIT_NOT_MADE_BY_USER = 8)] = "LAST_COMMIT_NOT_MADE_BY_USER"),
    (i[(i.LAST_COMMIT_TOO_OLD = 9)] = "LAST_COMMIT_TOO_OLD"),
    (i[(i.DIFF_TOO_LONG = 10)] = "DIFF_TOO_LONG"),
    (i[(i.DIFF_TOO_SHORT = 11)] = "DIFF_TOO_SHORT"),
    (i[(i.TELEMETRY_UNHEALTHY = 12)] = "TELEMETRY_UNHEALTHY")
})(Jd || (Jd = {})),
  n.util.setEnumType(
    Jd,
    "aiserver.v1.BugBotEvent.BackgroundIntervalInterruptedReason",
    [
      { no: 0, name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_UNSPECIFIED" },
      { no: 1, name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_DISABLED" },
      { no: 2, name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_TOO_RECENT" },
      {
        no: 3,
        name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_UNVIEWED_BUG_REPORTS",
      },
      { no: 4, name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_NOT_IN_GIT_REPO" },
      {
        no: 5,
        name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_DEFAULT_BRANCH_IS_NOT_CURRENT_BRANCH",
      },
      { no: 6, name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_NO_GIT_USER" },
      { no: 7, name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_NO_LAST_COMMIT" },
      {
        no: 8,
        name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_LAST_COMMIT_NOT_MADE_BY_USER",
      },
      {
        no: 9,
        name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_LAST_COMMIT_TOO_OLD",
      },
      { no: 10, name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_DIFF_TOO_LONG" },
      { no: 11, name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_DIFF_TOO_SHORT" },
      {
        no: 12,
        name: "BACKGROUND_INTERVAL_INTERRUPTED_REASON_TELEMETRY_UNHEALTHY",
      },
    ],
  )
var ugt = class Mv extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.Started"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Mv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Mv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Mv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Mv, t, e)
    }
  },
  lgt = class Hv extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.ReportsGenerated"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_reports", kind: "message", T: RQ },
      ])
    }
    static fromBinary(t, e) {
      return new Hv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Hv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Hv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Hv, t, e)
    }
  },
  dgt = class Wv extends d {
    constructor(t) {
      super(), (this.bugReportId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.PressedFixInComposer"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_report_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Wv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Wv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Wv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Wv, t, e)
    }
  },
  mgt = class jv extends d {
    constructor(t) {
      super(), (this.bugReportId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.PressedAddToChat"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_report_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new jv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jv, t, e)
    }
  },
  hgt = class Vv extends d {
    constructor(t) {
      super(), (this.bugReportId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.PressedOpenInEditor"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_location", kind: "message", T: LQ },
        { no: 2, name: "bug_report_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Vv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Vv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Vv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Vv, t, e)
    }
  },
  fgt = class Gv extends d {
    constructor(t) {
      super(),
        (this.secondsViewed = 0),
        (this.reportViews = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.ViewedReport"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "seconds_viewed", kind: "scalar", T: 5 },
        { no: 2, name: "report_views", kind: "message", T: pgt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Gv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Gv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Gv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Gv, t, e)
    }
  },
  pgt = class zv extends d {
    constructor(t) {
      super(),
        (this.bugReportId = ""),
        (this.viewPercentage = 0),
        (this.textPercentage = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.ViewedReport.ReportView"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_report_id", kind: "scalar", T: 9 },
        { no: 2, name: "view_percentage", kind: "scalar", T: 1 },
        { no: 3, name: "text_percentage", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new zv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zv, t, e)
    }
  },
  ggt = class Yv extends d {
    constructor(t) {
      super(),
        (this.bugReportId = ""),
        (this.feedback = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.UserFeedback"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_report_id", kind: "scalar", T: 9 },
        { no: 2, name: "feedback", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Yv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Yv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Yv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Yv, t, e)
    }
  },
  vgt = class Qv extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.BackgroundIntervalStarted"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Qv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Qv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Qv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Qv, t, e)
    }
  },
  wgt = class Xv extends d {
    constructor(t) {
      super(), (this.success = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.BackgroundIntervalEnded"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "success", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Xv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Xv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Xv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Xv, t, e)
    }
  },
  ygt = class Kv extends d {
    constructor(t) {
      super(), (this.reason = Jd.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.BackgroundIntervalInterrupted"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "reason", kind: "enum", T: n.getEnumType(Jd) },
      ])
    }
    static fromBinary(t, e) {
      return new Kv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Kv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Kv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Kv, t, e)
    }
  },
  Tgt = class Zv extends d {
    constructor(t) {
      super(), (this.errorMessage = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotEvent.BackgroundIntervalErrored"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "error_message", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Zv().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Zv().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Zv().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Zv, t, e)
    }
  },
  kgt = class t1 extends d {
    constructor(t) {
      super(),
        (this.requestType = Cd.UNSPECIFIED),
        (this.requestId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiRequestEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_type", kind: "enum", T: n.getEnumType(Cd) },
        { no: 2, name: "request_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new t1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new t1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new t1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(t1, t, e)
    }
  },
  Cd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.START = 1)] = "START"),
    (i[(i.END = 2)] = "END")
})(Cd || (Cd = {})),
  n.util.setEnumType(Cd, "aiserver.v1.AiRequestEvent.RequestType", [
    { no: 0, name: "REQUEST_TYPE_UNSPECIFIED" },
    { no: 1, name: "REQUEST_TYPE_START" },
    { no: 2, name: "REQUEST_TYPE_END" },
  ])
var Sgt = class e1 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelOpenedEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: je },
      ])
    }
    static fromBinary(t, e) {
      return new e1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new e1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new e1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(e1, t, e)
    }
  },
  bgt = class i1 extends d {
    constructor(t) {
      super(), (this.files = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundFilesEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "files", kind: "message", T: Egt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new i1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new i1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new i1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(i1, t, e)
    }
  },
  Egt = class r1 extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.hash = ""),
        (this.fullPath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundFilesEvent.BackgroundFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        { no: 3, name: "hash", kind: "scalar", T: 9 },
        { no: 4, name: "full_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new r1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new r1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new r1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(r1, t, e)
    }
  },
  Igt = class n1 extends d {
    constructor(t) {
      super(),
        (this.visibleRanges = []),
        (this.editorId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ScrollEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: je },
        { no: 2, name: "visible_ranges", kind: "message", T: sr, repeated: !0 },
        { no: 3, name: "editor_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new n1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new n1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new n1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(n1, t, e)
    }
  },
  Pgt = class s1 extends d {
    constructor(t) {
      super(), (this.editorId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditorCloseEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "editor_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new s1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new s1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new s1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(s1, t, e)
    }
  },
  Ngt = class a1 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TabCloseEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: BQ },
      ])
    }
    static fromBinary(t, e) {
      return new a1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new a1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new a1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(a1, t, e)
    }
  },
  $gt = class o1 extends d {
    constructor(t) {
      super(),
        (this.fullUri = ""),
        (this.modelId = ""),
        (this.uriScheme = ""),
        (this.isTooLargeForSyncing = !1),
        (this.isTooLargeForTokenization = !1),
        (this.isTooLargeForHeapOperation = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelAddedEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "point_in_time_model", kind: "message", T: BQ },
        { no: 2, name: "full_uri", kind: "scalar", T: 9 },
        { no: 3, name: "model_id", kind: "scalar", T: 9 },
        { no: 4, name: "uri_scheme", kind: "scalar", T: 9 },
        { no: 5, name: "is_too_large_for_syncing", kind: "scalar", T: 8 },
        { no: 6, name: "is_too_large_for_tokenization", kind: "scalar", T: 8 },
        {
          no: 7,
          name: "is_too_large_for_heap_operation",
          kind: "scalar",
          T: 8,
        },
      ])
    }
    static fromBinary(t, e) {
      return new o1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new o1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new o1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(o1, t, e)
    }
  },
  xgt = class c1 extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.rootFsPath = ""),
        (this.refs = []),
        (this.remotes = []),
        (this.submodules = []),
        (this.mergeChanges = []),
        (this.indexChanges = []),
        (this.workingTreeChanges = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppGitContextEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "root_fs_path", kind: "scalar", T: 9 },
        { no: 3, name: "head", kind: "message", T: Jgt, opt: !0 },
        { no: 4, name: "refs", kind: "message", T: Lgt, repeated: !0 },
        { no: 5, name: "remotes", kind: "message", T: Rgt, repeated: !0 },
        { no: 6, name: "submodules", kind: "message", T: Dgt, repeated: !0 },
        { no: 7, name: "rebase_commit", kind: "message", T: Fgt, opt: !0 },
        { no: 8, name: "merge_changes", kind: "message", T: Qq, repeated: !0 },
        { no: 9, name: "index_changes", kind: "message", T: Qq, repeated: !0 },
        {
          no: 10,
          name: "working_tree_changes",
          kind: "message",
          T: Qq,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new c1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new c1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new c1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(c1, t, e)
    }
  },
  Jgt = class u1 extends d {
    constructor(t) {
      super(), (this.type = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppGitContextEvent.Head"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type", kind: "scalar", T: 9 },
        { no: 2, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "commit", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "remote", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "upstream_ref", kind: "message", T: Cgt, opt: !0 },
        { no: 6, name: "ahead", kind: "scalar", T: 5, opt: !0 },
        { no: 7, name: "behind", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new u1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new u1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new u1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(u1, t, e)
    }
  },
  Cgt = class l1 extends d {
    constructor(t) {
      super(), (this.remote = ""), (this.name = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppGitContextEvent.Head.UpstreamRef"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "remote", kind: "scalar", T: 9 },
        { no: 2, name: "name", kind: "scalar", T: 9 },
        { no: 3, name: "commit", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new l1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new l1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new l1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(l1, t, e)
    }
  },
  Lgt = class d1 extends d {
    constructor(t) {
      super(), (this.type = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppGitContextEvent.Ref"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type", kind: "scalar", T: 9 },
        { no: 2, name: "name", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "commit", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "remote", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new d1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new d1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new d1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(d1, t, e)
    }
  },
  Rgt = class m1 extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.isReadOnly = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppGitContextEvent.Remote"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "fetch_url", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "push_url", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "is_read_only", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new m1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new m1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new m1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(m1, t, e)
    }
  },
  Dgt = class h1 extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.path = ""),
        (this.url = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppGitContextEvent.Submodule"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "path", kind: "scalar", T: 9 },
        { no: 3, name: "url", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new h1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new h1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new h1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(h1, t, e)
    }
  },
  Fgt = class f1 extends d {
    constructor(t) {
      super(),
        (this.hash = ""),
        (this.message = ""),
        (this.parents = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppGitContextEvent.Commit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "hash", kind: "scalar", T: 9 },
        { no: 2, name: "message", kind: "scalar", T: 9 },
        { no: 3, name: "parents", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "author_date", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "author_name", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "author_email", kind: "scalar", T: 9, opt: !0 },
        { no: 7, name: "commit_date", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "short_stat", kind: "message", T: _gt, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new f1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new f1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new f1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(f1, t, e)
    }
  },
  _gt = class p1 extends d {
    constructor(t) {
      super(),
        (this.files = 0),
        (this.insertions = 0),
        (this.deletions = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppGitContextEvent.Commit.CommitShortStat"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "scalar", T: 5 },
        { no: 2, name: "insertions", kind: "scalar", T: 5 },
        { no: 3, name: "deletions", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new p1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new p1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new p1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(p1, t, e)
    }
  },
  Qq = class g1 extends d {
    constructor(t) {
      super(),
        (this.uri = ""),
        (this.originalUri = ""),
        (this.status = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppGitContextEvent.Change"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uri", kind: "scalar", T: 9 },
        { no: 2, name: "original_uri", kind: "scalar", T: 9 },
        { no: 3, name: "rename_uri", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "status", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new g1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new g1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new g1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(g1, t, e)
    }
  },
  Agt = class v1 extends d {
    constructor(t) {
      super(), (this.item = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AnythingQuickAccessItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "resource", kind: "message", T: Bgt, oneof: "item" },
        { no: 2, name: "separator", kind: "scalar", T: 9, oneof: "item" },
      ])
    }
    static fromBinary(t, e) {
      return new v1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new v1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new v1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(v1, t, e)
    }
  },
  Bgt = class w1 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AnythingQuickAccessItem.Resource"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model", kind: "message", T: je, opt: !0 },
        { no: 2, name: "range", kind: "message", T: sr, opt: !0 },
        { no: 3, name: "uri", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new w1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new w1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new w1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(w1, t, e)
    }
  },
  Ogt = class y1 extends d {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.items = []),
        (this.selectedIndices = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AnythingQuickAccessSelectionEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "items", kind: "message", T: Agt, repeated: !0 },
        { no: 3, name: "selected_indices", kind: "scalar", T: 5, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new y1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new y1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new y1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(y1, t, e)
    }
  },
  qgt = class T1 extends d {
    constructor(t) {
      super(), (this.suggestions = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LspSuggestionEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "suggestions", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "request_id", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "editor_id", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "point_in_time_model", kind: "message", T: je },
      ])
    }
    static fromBinary(t, e) {
      return new T1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new T1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new T1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(T1, t, e)
    }
  },
  qQ = class k1 extends d {
    constructor(t) {
      super(),
        (this.event = { case: void 0 }),
        (this.performanceNowTimestamp = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppSessionEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 2,
          name: "accept_event",
          kind: "message",
          T: ypt,
          oneof: "event",
        },
        {
          no: 3,
          name: "reject_event",
          kind: "message",
          T: bpt,
          oneof: "event",
        },
        {
          no: 4,
          name: "manual_trigger_event",
          kind: "message",
          T: xpt,
          oneof: "event",
        },
        {
          no: 6,
          name: "stopped_tracking_model_event",
          kind: "message",
          T: Jpt,
          oneof: "event",
        },
        {
          no: 7,
          name: "suggest_event",
          kind: "message",
          T: Tpt,
          oneof: "event",
        },
        {
          no: 8,
          name: "linter_error_event",
          kind: "message",
          T: Cpt,
          oneof: "event",
        },
        {
          no: 9,
          name: "debounced_cursor_movement_event",
          kind: "message",
          T: Lpt,
          oneof: "event",
        },
        {
          no: 10,
          name: "editor_changed_event",
          kind: "message",
          T: Rpt,
          oneof: "event",
        },
        { no: 11, name: "copy_event", kind: "message", T: Dpt, oneof: "event" },
        {
          no: 13,
          name: "quick_action_event",
          kind: "message",
          T: _pt,
          oneof: "event",
        },
        {
          no: 14,
          name: "quick_action_fire_event",
          kind: "message",
          T: Apt,
          oneof: "event",
        },
        {
          no: 15,
          name: "model_opened_event",
          kind: "message",
          T: Sgt,
          oneof: "event",
        },
        {
          no: 17,
          name: "cmd_k_event",
          kind: "message",
          T: Mpt,
          oneof: "event",
        },
        { no: 18, name: "chat_event", kind: "message", T: Qpt, oneof: "event" },
        { no: 19, name: "ai_event", kind: "message", T: kgt, oneof: "event" },
        {
          no: 21,
          name: "scroll_event",
          kind: "message",
          T: Igt,
          oneof: "event",
        },
        {
          no: 22,
          name: "editor_close_event",
          kind: "message",
          T: Pgt,
          oneof: "event",
        },
        {
          no: 23,
          name: "tab_close_event",
          kind: "message",
          T: Ngt,
          oneof: "event",
        },
        {
          no: 33,
          name: "model_added_event",
          kind: "message",
          T: $gt,
          oneof: "event",
        },
        {
          no: 26,
          name: "partial_accept_event",
          kind: "message",
          T: Ipt,
          oneof: "event",
        },
        {
          no: 27,
          name: "accept_cursor_prediction_event",
          kind: "message",
          T: Npt,
          oneof: "event",
        },
        {
          no: 28,
          name: "reject_cursor_prediction_event",
          kind: "message",
          T: $pt,
          oneof: "event",
        },
        {
          no: 29,
          name: "suggest_cursor_prediction_event",
          kind: "message",
          T: Ppt,
          oneof: "event",
        },
        {
          no: 30,
          name: "cpp_trigger_event",
          kind: "message",
          T: kpt,
          oneof: "event",
        },
        {
          no: 31,
          name: "finished_cpp_generation_event",
          kind: "message",
          T: Spt,
          oneof: "event",
        },
        {
          no: 32,
          name: "bug_bot_event",
          kind: "message",
          T: cgt,
          oneof: "event",
        },
        {
          no: 34,
          name: "bug_bot_linter_event",
          kind: "message",
          T: tgt,
          oneof: "event",
        },
        {
          no: 35,
          name: "anything_quick_access_selection_event",
          kind: "message",
          T: Ogt,
          oneof: "event",
        },
        {
          no: 36,
          name: "lsp_suggestion_event",
          kind: "message",
          T: qgt,
          oneof: "event",
        },
        {
          no: 16,
          name: "background_files_event",
          kind: "message",
          T: bgt,
          oneof: "event",
        },
        {
          no: 20,
          name: "terminal_event",
          kind: "message",
          T: Bpt,
          oneof: "event",
        },
        {
          no: 24,
          name: "git_context_event",
          kind: "message",
          T: xgt,
          oneof: "event",
        },
        { no: 5, name: "performance_now_timestamp", kind: "scalar", T: 1 },
        {
          no: 25,
          name: "performance_time_origin",
          kind: "scalar",
          T: 1,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new k1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new k1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new k1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(k1, t, e)
    }
  },
  Ugt = class S1 extends d {
    constructor(t) {
      super(), (this.changes = new Uint8Array(0)), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppAppendRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "changes", kind: "scalar", T: 12 },
      ])
    }
    static fromBinary(t, e) {
      return new S1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new S1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new S1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(S1, t, e)
    }
  },
  Mgt = class b1 extends d {
    constructor(t) {
      super(), (this.success = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppAppendResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "success", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new b1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new b1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new b1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(b1, t, e)
    }
  },
  Hgt = class E1 extends d {
    constructor(t) {
      super(),
        (this.sessionId = ""),
        (this.modelUuid = ""),
        (this.relativePath = ""),
        (this.uri = ""),
        (this.clientVersion = ""),
        (this.changes = []),
        (this.sessionEvents = []),
        (this.modelChangesMayBeOutOfOrder = !1),
        (this.privacyModeStatus = Ld.UNSPECIFIED),
        (this.events = []),
        (this.timeOrigin = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditHistoryAppendChangesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "session_id", kind: "scalar", T: 9 },
        { no: 2, name: "model_uuid", kind: "scalar", T: 9 },
        { no: 3, name: "starting_model_value", kind: "scalar", T: 9, opt: !0 },
        {
          no: 10,
          name: "starting_model_version",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 5, name: "relative_path", kind: "scalar", T: 9 },
        { no: 14, name: "uri", kind: "scalar", T: 9 },
        { no: 6, name: "client_version", kind: "scalar", T: 9 },
        { no: 8, name: "client_commit", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "changes", kind: "message", T: Pd, repeated: !0 },
        { no: 9, name: "session_events", kind: "message", T: qQ, repeated: !0 },
        {
          no: 11,
          name: "model_changes_may_be_out_of_order",
          kind: "scalar",
          T: 8,
        },
        {
          no: 12,
          name: "privacy_mode_status",
          kind: "enum",
          T: n.getEnumType(Ld),
        },
        { no: 7, name: "events", kind: "message", T: Qgt, repeated: !0 },
        { no: 13, name: "time_origin", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new E1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new E1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new E1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(E1, t, e)
    }
  },
  Ld
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.PRIVACY_ENABLED = 1)] = "PRIVACY_ENABLED"),
    (i[(i.IMPLICIT_NO_PRIVACY = 2)] = "IMPLICIT_NO_PRIVACY"),
    (i[(i.EXPLICIT_NO_PRIVACY = 3)] = "EXPLICIT_NO_PRIVACY")
})(Ld || (Ld = {})),
  n.util.setEnumType(
    Ld,
    "aiserver.v1.EditHistoryAppendChangesRequest.PrivacyModeStatus",
    [
      { no: 0, name: "PRIVACY_MODE_STATUS_UNSPECIFIED" },
      { no: 1, name: "PRIVACY_MODE_STATUS_PRIVACY_ENABLED" },
      { no: 2, name: "PRIVACY_MODE_STATUS_IMPLICIT_NO_PRIVACY" },
      { no: 3, name: "PRIVACY_MODE_STATUS_EXPLICIT_NO_PRIVACY" },
    ],
  )
var Wgt = class I1 extends d {
    constructor(t) {
      super(), (this.success = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditHistoryAppendChangesResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "success", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new I1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new I1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new I1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(I1, t, e)
    }
  },
  jgt = class P1 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppEditHistoryStatusRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new P1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new P1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new P1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(P1, t, e)
    }
  },
  Vgt = class N1 extends d {
    constructor(t) {
      super(),
        (this.on = !1),
        (this.onlyIfExplicit = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppEditHistoryStatusResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "on", kind: "scalar", T: 8 },
        { no: 2, name: "only_if_explicit", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new N1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new N1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new N1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(N1, t, e)
    }
  },
  Ggt = class $1 extends d {
    constructor(t) {
      super(),
        (this.relativePath = ""),
        (this.startingContents = ""),
        (this.beforeStartModelChanges = []),
        (this.clientVersion = ""),
        (this.modelUuid = ""),
        (this.sessionId = ""),
        (this.uri = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StartingModel"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_path", kind: "scalar", T: 9 },
        { no: 2, name: "starting_contents", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "starting_model_version",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 4,
          name: "before_start_model_changes",
          kind: "message",
          T: Pd,
          repeated: !0,
        },
        { no: 5, name: "client_version", kind: "scalar", T: 9 },
        { no: 6, name: "client_commit", kind: "scalar", T: 9, opt: !0 },
        { no: 7, name: "model_uuid", kind: "scalar", T: 9 },
        { no: 8, name: "session_id", kind: "scalar", T: 9 },
        { no: 9, name: "uri", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($1, t, e)
    }
  },
  Xq = class x1 extends d {
    constructor(t) {
      super(),
        (this.changes = []),
        (this.relativePath = ""),
        (this.modelUuid = ""),
        (this.startFromChangeIndex = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BlockDiffPatch"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_model_window", kind: "message", T: Ygt },
        { no: 3, name: "changes", kind: "message", T: zgt, repeated: !0 },
        { no: 4, name: "relative_path", kind: "scalar", T: 9 },
        { no: 7, name: "model_uuid", kind: "scalar", T: 9 },
        { no: 5, name: "start_from_change_index", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new x1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new x1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new x1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(x1, t, e)
    }
  },
  zgt = class J1 extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BlockDiffPatch.Change"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: sr },
      ])
    }
    static fromBinary(t, e) {
      return new J1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new J1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new J1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(J1, t, e)
    }
  },
  Ygt = class C1 extends d {
    constructor(t) {
      super(),
        (this.lines = []),
        (this.startLineNumber = 0),
        (this.endLineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BlockDiffPatch.ModelWindow"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new C1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new C1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new C1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(C1, t, e)
    }
  },
  Qgt = class L1 extends d {
    constructor(t) {
      super(), (this.event = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppHistoryAppendEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_change", kind: "message", T: Pd, oneof: "event" },
        {
          no: 2,
          name: "accept_event",
          kind: "message",
          T: Kgt,
          oneof: "event",
        },
        {
          no: 3,
          name: "reject_event",
          kind: "message",
          T: Zgt,
          oneof: "event",
        },
        {
          no: 4,
          name: "manual_trigger_event",
          kind: "message",
          T: Xgt,
          oneof: "event",
        },
        { no: 10, name: "final_model_hash", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new L1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new L1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new L1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(L1, t, e)
    }
  },
  Xgt = class R1 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppManualTriggerEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "position", kind: "message", T: $s },
      ])
    }
    static fromBinary(t, e) {
      return new R1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new R1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new R1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(R1, t, e)
    }
  },
  Kgt = class D1 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppAcceptEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cpp_suggestion", kind: "message", T: UQ },
      ])
    }
    static fromBinary(t, e) {
      return new D1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new D1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new D1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(D1, t, e)
    }
  },
  Zgt = class F1 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppRejectEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cpp_suggestion", kind: "message", T: UQ },
      ])
    }
    static fromBinary(t, e) {
      return new F1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new F1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new F1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(F1, t, e)
    }
  },
  UQ = class _1 extends d {
    constructor(t) {
      super(),
        (this.suggestionText = ""),
        (this.seen = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppSuggestion"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "suggestion_text", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: sr },
        { no: 5, name: "seen", kind: "scalar", T: 8 },
        {
          no: 6,
          name: "editor_selection_before_peek",
          kind: "message",
          T: vft,
        },
      ])
    }
    static fromBinary(t, e) {
      return new _1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_1, t, e)
    }
  },
  FOt = class A1 extends d {
    constructor(t) {
      super(),
        (this.changes = []),
        (this.modelUuid = ""),
        (this.numCorrectChanges = 0),
        (this.numUnvalidatedChanges = 0),
        (this.numIncorrectChanges = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelWithHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "changes", kind: "message", T: Pd, repeated: !0 },
        { no: 2, name: "model_uuid", kind: "scalar", T: 9 },
        { no: 3, name: "starting_model", kind: "message", T: Ggt },
        { no: 4, name: "num_correct_changes", kind: "scalar", T: 5 },
        { no: 5, name: "num_unvalidated_changes", kind: "scalar", T: 5 },
        { no: 6, name: "num_incorrect_changes", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new A1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new A1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new A1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(A1, t, e)
    }
  },
  _Ot = class B1 extends d {
    constructor(t) {
      super(),
        (this.timestamp = 0),
        (this.v = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppTimelineEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "timestamp", kind: "scalar", T: 1 },
        { no: 2, name: "event", kind: "message", T: qQ, oneof: "v" },
        { no: 3, name: "change", kind: "message", T: tvt, oneof: "v" },
      ])
    }
    static fromBinary(t, e) {
      return new B1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new B1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new B1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(B1, t, e)
    }
  },
  tvt = class O1 extends d {
    constructor(t) {
      super(),
        (this.modelUuid = ""),
        (this.changeIndex = 0),
        (this.status = Rd.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CppTimelineEvent.Change"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "change_index", kind: "scalar", T: 5 },
        { no: 3, name: "change", kind: "message", T: Pd },
        { no: 4, name: "status", kind: "enum", T: n.getEnumType(Rd) },
      ])
    }
    static fromBinary(t, e) {
      return new O1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new O1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new O1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(O1, t, e)
    }
  },
  Rd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.CORRECT = 1)] = "CORRECT"),
    (i[(i.UNVALIDATED = 2)] = "UNVALIDATED"),
    (i[(i.INCORRECT = 3)] = "INCORRECT")
})(Rd || (Rd = {})),
  n.util.setEnumType(Rd, "aiserver.v1.CppTimelineEvent.Change.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_CORRECT" },
    { no: 2, name: "STATUS_UNVALIDATED" },
    { no: 3, name: "STATUS_INCORRECT" },
  ])
function Dd(i, t, e) {
  return new Du((r) => Kq(r, e)).isEqual(i, t)
}
function evt(i, t, e) {
  return Dd(i.uri, t.uri, e) ? 0 : Zs(i.uri.toString(), t.uri.toString())
}
function ivt(i, t, e) {
  return i.index !== t.index
    ? i.index < t.index
      ? -1
      : 1
    : Dd(i.uri, t.uri, e)
      ? Zs(i.name, t.name)
      : Zs(i.uri.toString(), t.uri.toString())
}
function MQ(i, t, e, r) {
  const s = i.slice(0).sort((o, c) => e(o, c, r)),
    a = t.slice(0).sort((o, c) => e(o, c, r))
  return Kst(s, a, (o, c) => e(o, c, r))
}
function Kq(i, t) {
  const e = t.getCapabilities(i.scheme)
  return !(e && e & 1024)
}
var Zq = class yH extends put {
    static toExtHostWorkspace(t, e, r, s) {
      if (!t) return { workspace: null, added: [], removed: [] }
      const {
          id: a,
          name: o,
          folders: c,
          configuration: u,
          transient: l,
          isUntitled: m,
        } = t,
        h = [],
        p = e
      e
        ? c.forEach((b, N) => {
            const $ = S.revive(b.uri),
              L = yH.o(r || e, $, s)
            L
              ? ((L.name = b.name), (L.index = b.index), h.push(L))
              : h.push({ uri: $, name: b.name, index: N })
          })
        : h.push(
            ...c.map(({ uri: b, name: N, index: $ }) => ({
              uri: S.revive(b),
              name: N,
              index: $,
            })),
          ),
        h.sort((b, N) => (b.index < N.index ? -1 : 1))
      const g = new yH(a, o, h, !!l, u ? S.revive(u) : null, !!m, (b) =>
          Kq(b, s),
        ),
        { added: w, removed: T } = MQ(
          p ? p.workspaceFolders : [],
          g.workspaceFolders,
          evt,
          s,
        )
      return { workspace: g, added: w, removed: T }
    }
    static o(t, e, r) {
      for (let s = 0; s < t.folders.length; s++) {
        const a = t.workspaceFolders[s]
        if (Dd(a.uri, e, r)) return a
      }
    }
    constructor(t, e, r, s, a, o, c) {
      super(
        t,
        r.map((u) => new Qj(u)),
        s,
        a,
        c,
      ),
        (this.t = e),
        (this.u = o),
        (this.q = []),
        (this.s = ls.forUris(c, () => !0)),
        r.forEach((u) => {
          this.q.push(u), this.s.set(u.uri, u)
        })
    }
    get name() {
      return this.t
    }
    get isUntitled() {
      return this.u
    }
    get workspaceFolders() {
      return this.q.slice(0)
    }
    getWorkspaceFolder(t, e) {
      return e && this.s.get(t) && (t = RB(t)), this.s.findSubstr(t)
    }
    resolveWorkspaceFolder(t) {
      return this.s.get(t)
    }
  },
  t2 = class {
    constructor(t, e, r, s, a) {
      ;(this.c = new C()),
        (this.onDidChangeWorkspace = this.c.event),
        (this.g = new C()),
        (this.onDidGrantWorkspaceTrust = this.g.event),
        (this.u = []),
        (this.v = !1),
        (this.w = new Map()),
        (this.x = new Map()),
        (this.A = 0),
        (this.D = 0),
        (this.F = new Iu()),
        (this.G = new Map()),
        (this.h = s),
        (this.s = r),
        (this.t = a),
        (this.j = new dut()),
        (this.k = new Xr()),
        (this.o = t.getProxy(z.MainThreadWorkspace)),
        (this.q = t.getProxy(z.MainThreadMessageService))
      const o = e.workspace
      this.l = o
        ? new Zq(
            o.id,
            o.name,
            [],
            !!o.transient,
            o.configuration ? S.revive(o.configuration) : null,
            !!o.isUntitled,
            (c) => Kq(c, r),
          )
        : void 0
    }
    $initializeWorkspace(t, e) {
      ;(this.v = e), this.$acceptWorkspaceData(t), this.k.open()
    }
    waitForInitializeCall() {
      return this.k.wait()
    }
    get workspace() {
      return this.y
    }
    get name() {
      return this.y ? this.y.name : void 0
    }
    get workspaceFile() {
      if (this.y && this.y.configuration)
        return this.y.isUntitled
          ? S.from({ scheme: Q.untitled, path: us(RB(this.y.configuration)) })
          : this.y.configuration
    }
    get y() {
      return this.n || this.l
    }
    getWorkspaceFolders() {
      if (this.y) return this.y.workspaceFolders.slice(0)
    }
    async getWorkspaceFolders2() {
      if ((await this.k.wait(), !!this.y))
        return this.y.workspaceFolders.slice(0)
    }
    updateWorkspaceFolders(t, e, r, ...s) {
      const a = []
      if (
        (Array.isArray(s) &&
          s.forEach((m) => {
            S.isUri(m.uri) &&
              !a.some((h) => Dd(h.uri, m.uri, this.s)) &&
              a.push({ uri: m.uri, name: m.name || LB(m.uri) })
          }),
        this.n ||
          [e, r].some((m) => typeof m != "number" || m < 0) ||
          (r === 0 && a.length === 0))
      )
        return !1
      const o = this.y ? this.y.workspaceFolders : []
      if (e + r > o.length) return !1
      const c = o.slice(0)
      c.splice(
        e,
        r,
        ...a.map((m) => ({
          uri: m.uri,
          name: m.name || LB(m.uri),
          index: void 0,
        })),
      )
      for (let m = 0; m < c.length; m++) {
        const h = c[m]
        if (c.some((p, g) => g !== m && Dd(h.uri, p.uri, this.s))) return !1
      }
      c.forEach((m, h) => (m.index = h))
      const { added: u, removed: l } = MQ(o, c, ivt, this.s)
      if (u.length === 0 && l.length === 0) return !1
      if (this.o) {
        const m = t.displayName || t.name
        this.o.$updateWorkspaceFolders(m, e, r, a).then(void 0, (h) => {
          this.n = void 0
          const p = {
            source: {
              identifier: t.identifier,
              label: t.displayName || t.name,
            },
          }
          this.q.$showMessage(mut.Error, f(2775, null, m, h.toString()), p, [])
        })
      }
      return this.z(c), !0
    }
    getWorkspaceFolder(t, e) {
      if (this.y) return this.y.getWorkspaceFolder(t, e)
    }
    async getWorkspaceFolder2(t, e) {
      if ((await this.k.wait(), !!this.y))
        return this.y.getWorkspaceFolder(t, e)
    }
    async resolveWorkspaceFolder(t) {
      if ((await this.k.wait(), !!this.y))
        return this.y.resolveWorkspaceFolder(t)
    }
    getPath() {
      if (!this.y) return
      const { folders: t } = this.y
      if (t.length !== 0) return t[0].uri.fsPath
    }
    getRelativePath(t, e) {
      let r,
        s = ""
      if (
        (typeof t == "string"
          ? ((r = S.file(t)), (s = t))
          : typeof t < "u" && ((r = t), (s = t.fsPath)),
        !r)
      )
        return s
      const a = this.getWorkspaceFolder(r, !0)
      if (!a) return s
      typeof e > "u" && this.y && (e = this.y.folders.length > 1)
      let o = ZW(a.uri, r)
      return e && a.name && (o = `${a.name}/${o}`), o
    }
    z(t) {
      this.y &&
        (this.n =
          Zq.toExtHostWorkspace(
            {
              id: this.y.id,
              name: this.y.name,
              configuration: this.y.configuration,
              folders: t,
              isUntitled: this.y.isUntitled,
            },
            this.y,
            void 0,
            this.s,
          ).workspace || void 0)
    }
    $acceptWorkspaceData(t) {
      const {
        workspace: e,
        added: r,
        removed: s,
      } = Zq.toExtHostWorkspace(t, this.l, this.n, this.s)
      ;(this.l = e || void 0),
        (this.n = void 0),
        this.c.fire(Object.freeze({ added: r, removed: s }))
    }
    registerControlProvider(t, e) {
      if (this.x.has(t))
        throw new Error(
          `A control provider for the scheme '${t}' is already registered.`,
        )
      this.x.set(t, e)
      const r = this.t.transformOutgoingScheme(t),
        s = this.A++
      return (
        this.o.$registerControlProvider(s, r),
        it(() => {
          this.o.$unregisterControlProvider(s), this.x.delete(t)
        })
      )
    }
    async $controlGetDataframeSummary(t) {
      const e = "vscode-jupyter",
        r = this.x.get(e)
      if (!r) throw new Error(`No control provider for scheme '${e}' found.`)
      const s = S.revive(t)
      if (!s) {
        this.h.warn("Unable to resolve workspace folder")
        return
      }
      return await r.getDataframeSummary(s)
    }
    async $controlGetFullDiff(t, e) {
      const r = "git",
        s = this.x.get(r)
      if (!s) throw new Error(`No control provider for scheme '${r}' found.`)
      return await s.getFullDiff(t, e)
    }
    async $controlAppendCppTelem(t, e) {
      const r = "cursor-retrieval",
        s = this.x.get(r)
      if (!s) throw new Error(`No control provider for scheme '${r}' found.`)
      await s.appendCppTelem(t.buffer, e)
    }
    async $controlStreamCpp(t, e) {
      const r = "cursor-retrieval",
        s = this.x.get(r)
      if (!s) throw new Error(`No control provider for scheme '${r}' found.`)
      await s.streamCpp(Vq.fromBinary(t.buffer), e)
    }
    async $controlFlushCpp(t) {
      const e = "cursor-retrieval",
        r = this.x.get(e)
      if (!r) throw new Error(`No control provider for scheme '${e}' found.`)
      const s = await r.flushCpp(t)
      return s === null
        ? { type: "failure", reason: "flushCppResponse is null" }
        : s === void 0
          ? { type: "failure", reason: "flushCppResponse is undefined" }
          : s
    }
    async $controlGetCppReport() {
      const t = "cursor-retrieval",
        e = this.x.get(t)
      if (!e) throw new Error(`No control provider for scheme '${t}' found.`)
      const r = await e.getCppReport()
      if (r !== null) return r
    }
    async $controlCancelCpp(t) {
      const e = "cursor-retrieval",
        r = this.x.get(e)
      if (!r) throw new Error(`No control provider for scheme '${e}' found.`)
      await r.cancelCpp(t)
    }
    async $controlTokenizeBPE(t, e) {
      const r = "cursor-tokenize",
        s = this.x.get(r)
      if (!s) throw new Error(`No control provider for scheme '${r}' found.`)
      return await s.tokenizeBPE(t, e)
    }
    findFiles(t, e, r, s, a = fe.None) {
      this.h.trace(
        `extHostWorkspace#findFiles: fileSearch, extension: ${s.value}, entryPoint: findFiles`,
      )
      let o = "",
        c = !0
      return (
        e === null
          ? (c = !1)
          : e !== void 0 && (typeof e == "string" ? (o = e) : (o = e.pattern)),
        this.B(
          { type: "include", value: t },
          {
            exclude: [o],
            maxResults: r,
            useExcludeSettings: c ? Rn.FilesExclude : Rn.None,
            useIgnoreFiles: { local: !1 },
          },
          a,
        )
      )
    }
    findFiles2(t, e = {}, r, s = fe.None) {
      return (
        this.h.trace(
          `extHostWorkspace#findFiles2New: fileSearch, extension: ${r.value}, entryPoint: findFiles2New`,
        ),
        this.B({ type: "filePatterns", value: t }, e, s)
      )
    }
    async B(t, e, r) {
      if (r.isCancellationRequested) return Promise.resolve([])
      const s = t.type === "include" ? [t.value] : (t.value ?? [])
      if (!Array.isArray(s))
        throw new Error(`Invalid file pattern provided ${s}`)
      const a = s.map((o) => {
        const c = HQ(e.exclude),
          u = {
            ignoreSymlinks:
              typeof e.followSymlinks == "boolean" ? !e.followSymlinks : void 0,
            disregardIgnoreFiles:
              typeof e.useIgnoreFiles?.local == "boolean"
                ? !e.useIgnoreFiles.local
                : void 0,
            disregardGlobalIgnoreFiles:
              typeof e.useIgnoreFiles?.global == "boolean"
                ? !e.useIgnoreFiles.global
                : void 0,
            disregardParentIgnoreFiles:
              typeof e.useIgnoreFiles?.parent == "boolean"
                ? !e.useIgnoreFiles.parent
                : void 0,
            disregardExcludeSettings:
              e.useExcludeSettings !== void 0 &&
              e.useExcludeSettings === Rn.None,
            disregardSearchExcludeSettings:
              e.useExcludeSettings !== void 0 &&
              e.useExcludeSettings !== Rn.SearchAndFilesExclude,
            maxResults: e.maxResults,
            excludePattern: c.length > 0 ? c : void 0,
            _reason: "startFileSearch",
            shouldGlobSearch: t.type === "include" ? void 0 : !0,
          },
          l = f7(zi.from(o)),
          m = l?.folder
        return (
          t.type === "include"
            ? (u.includePattern = l?.pattern)
            : (u.filePattern = l?.pattern),
          { folder: m, options: u }
        )
      })
      return this.C(a, r)
    }
    async C(t, e) {
      return (
        await Promise.all(
          t?.map((s) =>
            this.o
              .$startFileSearch(s.folder ?? null, s.options, e)
              .then((a) => (Array.isArray(a) ? a.map((o) => S.revive(o)) : [])),
          ) ?? [],
        )
      ).flat()
    }
    findTextInFiles2(t, e, r, s = fe.None) {
      this.h.trace(
        `extHostWorkspace#findTextInFiles2: textSearch, extension: ${r.value}, entryPoint: findTextInFiles2`,
      )
      const a = (p) => {
          if (!e) return { folder: void 0, options: {} }
          const g = p ? f7(zi.from(p)) : void 0,
            w = e.exclude ? HQ(e.exclude) : void 0
          return {
            options: {
              ignoreSymlinks:
                typeof e.followSymlinks == "boolean"
                  ? !e.followSymlinks
                  : void 0,
              disregardIgnoreFiles:
                typeof e.useIgnoreFiles == "boolean"
                  ? !e.useIgnoreFiles
                  : void 0,
              disregardGlobalIgnoreFiles:
                typeof e.useIgnoreFiles?.global == "boolean"
                  ? !e.useIgnoreFiles?.global
                  : void 0,
              disregardParentIgnoreFiles:
                typeof e.useIgnoreFiles?.parent == "boolean"
                  ? !e.useIgnoreFiles?.parent
                  : void 0,
              disregardExcludeSettings:
                e.useExcludeSettings !== void 0 &&
                e.useExcludeSettings === Rn.None,
              disregardSearchExcludeSettings:
                e.useExcludeSettings !== void 0 &&
                e.useExcludeSettings !== Rn.SearchAndFilesExclude,
              fileEncoding: e.encoding,
              maxResults: e.maxResults,
              previewOptions: e.previewOptions
                ? {
                    matchLines: e.previewOptions?.numMatchLines ?? 100,
                    charsPerLine: e.previewOptions?.charsPerLine ?? 1e4,
                  }
                : void 0,
              surroundingContext: e.surroundingContext,
              includePattern: g?.pattern,
              excludePattern: w,
            },
            folder: g?.folder,
          }
        },
        c = (e?.include?.map((p) => a(p)) ?? [a(void 0)]).filter((p) => !!p),
        u = new bt(),
        l = u.add(new C()),
        m = this.findTextInFilesBase(
          t,
          c,
          (p, g) => l.fire({ result: p, uri: g }),
          s,
        )
      return {
        results: new Fu(async (p) => {
          u.add(
            l.event((g) => {
              const w = g.result,
                T = g.uri
              $Y(w)
                ? p.emitOne(
                    new Is(
                      T,
                      w.rangeLocations.map((b) => ({
                        previewRange: new Nt(
                          b.preview.startLineNumber,
                          b.preview.startColumn,
                          b.preview.endLineNumber,
                          b.preview.endColumn,
                        ),
                        sourceRange: new Nt(
                          b.source.startLineNumber,
                          b.source.startColumn,
                          b.source.endLineNumber,
                          b.source.endColumn,
                        ),
                      })),
                      w.previewText,
                    ),
                  )
                : p.emitOne(new Iq(T, w.text, w.lineNumber))
            }),
          ),
            await m
        }),
        complete: m.then((p) => (u.dispose(), { limitHit: p?.limitHit ?? !1 })),
      }
    }
    async findTextInFilesBase(t, e, r, s = fe.None) {
      const a = this.j.getNext()
      let o = !1
      if (
        (s.onCancellationRequested((c) => {
          o = !0
        }),
        (this.u[a] = (c) => {
          if (o) return
          const u = S.revive(c.resource)
          c.results.forEach((l) => {
            const m = $i(l)
            r(m, u)
          })
        }),
        s.isCancellationRequested)
      )
        return {}
      try {
        const c = await Promise.all(
          e?.map(
            (u) =>
              this.o.$startTextSearch(t, u.folder ?? null, u.options, a, s) ||
              {},
          ) ?? [],
        )
        return (
          delete this.u[a],
          c.reduce(
            (u, l) => ({
              limitHit: u?.limitHit || (l?.limitHit ?? !1),
              message: [u?.message ?? [], l?.message ?? []].flat(),
            }),
            {},
          ) ?? { limitHit: !1 }
        )
      } catch (c) {
        throw (delete this.u[a], c)
      }
    }
    async findTextInFiles(t, e, r, s, a = fe.None) {
      this.h.trace(
        `extHostWorkspace#findTextInFiles: textSearch, extension: ${s.value}, entryPoint: findTextInFiles`,
      )
      const o =
          typeof e.previewOptions > "u"
            ? { matchLines: 100, charsPerLine: 1e4 }
            : e.previewOptions,
        c = f7(zi.from(e.include)),
        u =
          typeof e.exclude == "string"
            ? e.exclude
            : e.exclude
              ? e.exclude.pattern
              : void 0,
        l = {
          ignoreSymlinks:
            typeof e.followSymlinks == "boolean" ? !e.followSymlinks : void 0,
          disregardIgnoreFiles:
            typeof e.useIgnoreFiles == "boolean" ? !e.useIgnoreFiles : void 0,
          disregardGlobalIgnoreFiles:
            typeof e.useGlobalIgnoreFiles == "boolean"
              ? !e.useGlobalIgnoreFiles
              : void 0,
          disregardParentIgnoreFiles:
            typeof e.useParentIgnoreFiles == "boolean"
              ? !e.useParentIgnoreFiles
              : void 0,
          disregardExcludeSettings:
            typeof e.useDefaultExcludes == "boolean"
              ? !e.useDefaultExcludes
              : !0,
          disregardSearchExcludeSettings:
            typeof e.useSearchExclude == "boolean" ? !e.useSearchExclude : !0,
          fileEncoding: e.encoding,
          maxResults: e.maxResults,
          previewOptions: o,
          surroundingContext: e.afterContext,
          includePattern: c?.pattern,
          excludePattern: u ? [{ pattern: u }] : void 0,
        },
        m = (h, p) => {
          $Y(h)
            ? r({
                uri: p,
                preview: {
                  text: h.previewText,
                  matches: sB(
                    h.rangeLocations,
                    (g) =>
                      new Nt(
                        g.preview.startLineNumber,
                        g.preview.startColumn,
                        g.preview.endLineNumber,
                        g.preview.endColumn,
                      ),
                  ),
                },
                ranges: sB(
                  h.rangeLocations,
                  (g) =>
                    new Nt(
                      g.source.startLineNumber,
                      g.source.startColumn,
                      g.source.endLineNumber,
                      g.source.endColumn,
                    ),
                ),
              })
            : r({ uri: p, text: h.text, lineNumber: h.lineNumber })
        }
      return this.findTextInFilesBase(
        t,
        [{ options: l, folder: c?.folder }],
        m,
        a,
      )
    }
    $handleTextSearchResult(t, e) {
      this.u[e]?.(t)
    }
    async save(t) {
      const e = await this.o.$save(t, { saveAs: !1 })
      return S.revive(e)
    }
    async saveAs(t) {
      const e = await this.o.$save(t, { saveAs: !0 })
      return S.revive(e)
    }
    saveAll(t) {
      return this.o.$saveAll(t)
    }
    resolveProxy(t) {
      return this.o.$resolveProxy(t)
    }
    lookupAuthorization(t) {
      return this.o.$lookupAuthorization(t)
    }
    lookupKerberosAuthorization(t) {
      return this.o.$lookupKerberosAuthorization(t)
    }
    loadCertificates() {
      return this.o.$loadCertificates()
    }
    get trusted() {
      return this.v
    }
    requestWorkspaceTrust(t) {
      return this.o.$requestWorkspaceTrust(t)
    }
    $onDidGrantWorkspaceTrust() {
      this.v || ((this.v = !0), this.g.fire())
    }
    registerEditSessionIdentityProvider(t, e) {
      if (this.w.has(t))
        throw new Error(
          `A provider has already been registered for scheme ${t}`,
        )
      this.w.set(t, e)
      const r = this.t.transformOutgoingScheme(t),
        s = this.D++
      return (
        this.o.$registerEditSessionIdentityProvider(s, r),
        it(() => {
          this.w.delete(t), this.o.$unregisterEditSessionIdentityProvider(s)
        })
      )
    }
    async $getEditSessionIdentifier(t, e) {
      this.h.info("Getting edit session identifier for workspaceFolder", t)
      const r = await this.resolveWorkspaceFolder(S.revive(t))
      if (!r) {
        this.h.warn("Unable to resolve workspace folder")
        return
      }
      this.h.info("Invoking #provideEditSessionIdentity for workspaceFolder", r)
      const s = this.w.get(r.uri.scheme)
      if (
        (this.h.info(`Provider for scheme ${r.uri.scheme} is defined: `, !!s),
        !s)
      )
        return
      const a = await s.provideEditSessionIdentity(r, e)
      if ((this.h.info("Provider returned edit session identifier: ", a), !!a))
        return a
    }
    async $provideEditSessionIdentityMatch(t, e, r, s) {
      this.h.info("Getting edit session identifier for workspaceFolder", t)
      const a = await this.resolveWorkspaceFolder(S.revive(t))
      if (!a) {
        this.h.warn("Unable to resolve workspace folder")
        return
      }
      this.h.info("Invoking #provideEditSessionIdentity for workspaceFolder", a)
      const o = this.w.get(a.uri.scheme)
      if (
        (this.h.info(`Provider for scheme ${a.uri.scheme} is defined: `, !!o),
        !o)
      )
        return
      const c = await o.provideEditSessionIdentityMatch?.(e, r, s)
      if (
        (this.h.info(
          "Provider returned edit session identifier match result: ",
          c,
        ),
        !!c)
      )
        return c
    }
    getOnWillCreateEditSessionIdentityEvent(t) {
      return (e, r, s) => {
        const a = function (c) {
          e.call(r, c)
        }
        return (a.extension = t), this.F.event(a, void 0, s)
      }
    }
    async $onWillCreateEditSessionIdentity(t, e, r) {
      const s = await this.resolveWorkspaceFolder(S.revive(t))
      if (s === void 0) throw new Error("Unable to resolve workspace folder")
      await this.F.fireAsync({ workspaceFolder: s }, e, async (a, o) => {
        const c = Date.now()
        await Promise.resolve(a),
          Date.now() - c > r &&
            this.h.warn(
              "SLOW edit session create-participant",
              o.extension.identifier,
            )
      }),
        e.isCancellationRequested
    }
    registerCanonicalUriProvider(t, e) {
      if (this.G.has(t))
        throw new Error(
          `A provider has already been registered for scheme ${t}`,
        )
      this.G.set(t, e)
      const r = this.t.transformOutgoingScheme(t),
        s = this.D++
      return (
        this.o.$registerCanonicalUriProvider(s, r),
        it(() => {
          this.G.delete(t), this.o.$unregisterCanonicalUriProvider(s)
        })
      )
    }
    async provideCanonicalUri(t, e, r) {
      const s = this.G.get(t.scheme)
      if (!s) return
      const a = await s.provideCanonicalUri?.(S.revive(t), e, r)
      if (a) return a
    }
    async $provideCanonicalUri(t, e, r) {
      return this.provideCanonicalUri(S.revive(t), { targetScheme: e }, r)
    }
  }
t2 = __decorate(
  [
    __param(0, Vt),
    __param(1, ci),
    __param(2, To),
    __param(3, Kt),
    __param(4, m_),
  ],
  t2,
)
var _n = Y("IExtHostWorkspace")
function f7(i) {
  let t, e
  if (i)
    return (
      typeof i == "string"
        ? (t = i)
        : ((t = i.pattern), (e = S.revive(i.baseUri))),
      { pattern: t, folder: e }
    )
}
function HQ(i) {
  return (
    i?.map((t) => {
      if (typeof t == "string")
        return t === "" ? void 0 : { pattern: t, uri: void 0 }
      {
        const e = f7(t)
        return e ? { pattern: e.pattern, uri: e.folder } : void 0
      }
    }) ?? []
  ).filter((t) => !!t)
}
var WQ
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.UnexpectedEndOfComment = 1)] = "UnexpectedEndOfComment"),
    (i[(i.UnexpectedEndOfString = 2)] = "UnexpectedEndOfString"),
    (i[(i.UnexpectedEndOfNumber = 3)] = "UnexpectedEndOfNumber"),
    (i[(i.InvalidUnicode = 4)] = "InvalidUnicode"),
    (i[(i.InvalidEscapeCharacter = 5)] = "InvalidEscapeCharacter"),
    (i[(i.InvalidCharacter = 6)] = "InvalidCharacter")
})(WQ || (WQ = {}))
var jQ
;(function (i) {
  ;(i[(i.OpenBraceToken = 1)] = "OpenBraceToken"),
    (i[(i.CloseBraceToken = 2)] = "CloseBraceToken"),
    (i[(i.OpenBracketToken = 3)] = "OpenBracketToken"),
    (i[(i.CloseBracketToken = 4)] = "CloseBracketToken"),
    (i[(i.CommaToken = 5)] = "CommaToken"),
    (i[(i.ColonToken = 6)] = "ColonToken"),
    (i[(i.NullKeyword = 7)] = "NullKeyword"),
    (i[(i.TrueKeyword = 8)] = "TrueKeyword"),
    (i[(i.FalseKeyword = 9)] = "FalseKeyword"),
    (i[(i.StringLiteral = 10)] = "StringLiteral"),
    (i[(i.NumericLiteral = 11)] = "NumericLiteral"),
    (i[(i.LineCommentTrivia = 12)] = "LineCommentTrivia"),
    (i[(i.BlockCommentTrivia = 13)] = "BlockCommentTrivia"),
    (i[(i.LineBreakTrivia = 14)] = "LineBreakTrivia"),
    (i[(i.Trivia = 15)] = "Trivia"),
    (i[(i.Unknown = 16)] = "Unknown"),
    (i[(i.EOF = 17)] = "EOF")
})(jQ || (jQ = {}))
var VQ
;(function (i) {
  ;(i[(i.InvalidSymbol = 1)] = "InvalidSymbol"),
    (i[(i.InvalidNumberFormat = 2)] = "InvalidNumberFormat"),
    (i[(i.PropertyNameExpected = 3)] = "PropertyNameExpected"),
    (i[(i.ValueExpected = 4)] = "ValueExpected"),
    (i[(i.ColonExpected = 5)] = "ColonExpected"),
    (i[(i.CommaExpected = 6)] = "CommaExpected"),
    (i[(i.CloseBraceExpected = 7)] = "CloseBraceExpected"),
    (i[(i.CloseBracketExpected = 8)] = "CloseBracketExpected"),
    (i[(i.EndOfFileExpected = 9)] = "EndOfFileExpected"),
    (i[(i.InvalidCommentToken = 10)] = "InvalidCommentToken"),
    (i[(i.UnexpectedEndOfComment = 11)] = "UnexpectedEndOfComment"),
    (i[(i.UnexpectedEndOfString = 12)] = "UnexpectedEndOfString"),
    (i[(i.UnexpectedEndOfNumber = 13)] = "UnexpectedEndOfNumber"),
    (i[(i.InvalidUnicode = 14)] = "InvalidUnicode"),
    (i[(i.InvalidEscapeCharacter = 15)] = "InvalidEscapeCharacter"),
    (i[(i.InvalidCharacter = 16)] = "InvalidCharacter")
})(VQ || (VQ = {}))
var e2
;(function (i) {
  i.DEFAULT = { allowTrailingComma: !0 }
})(e2 || (e2 = {}))
function rvt(i, t = !1) {
  let e = 0
  const r = i.length
  let s = "",
    a = 0,
    o = 16,
    c = 0
  function u(T) {
    let b = 0,
      N = 0
    for (; b < T; ) {
      const $ = i.charCodeAt(e)
      if ($ >= 48 && $ <= 57) N = N * 16 + $ - 48
      else if ($ >= 65 && $ <= 70) N = N * 16 + $ - 65 + 10
      else if ($ >= 97 && $ <= 102) N = N * 16 + $ - 97 + 10
      else break
      e++, b++
    }
    return b < T && (N = -1), N
  }
  function l(T) {
    ;(e = T), (s = ""), (a = 0), (o = 16), (c = 0)
  }
  function m() {
    const T = e
    if (i.charCodeAt(e) === 48) e++
    else for (e++; e < i.length && Sc(i.charCodeAt(e)); ) e++
    if (e < i.length && i.charCodeAt(e) === 46)
      if ((e++, e < i.length && Sc(i.charCodeAt(e))))
        for (e++; e < i.length && Sc(i.charCodeAt(e)); ) e++
      else return (c = 3), i.substring(T, e)
    let b = e
    if (e < i.length && (i.charCodeAt(e) === 69 || i.charCodeAt(e) === 101))
      if (
        (e++,
        ((e < i.length && i.charCodeAt(e) === 43) || i.charCodeAt(e) === 45) &&
          e++,
        e < i.length && Sc(i.charCodeAt(e)))
      ) {
        for (e++; e < i.length && Sc(i.charCodeAt(e)); ) e++
        b = e
      } else c = 3
    return i.substring(T, b)
  }
  function h() {
    let T = "",
      b = e
    for (;;) {
      if (e >= r) {
        ;(T += i.substring(b, e)), (c = 2)
        break
      }
      const N = i.charCodeAt(e)
      if (N === 34) {
        ;(T += i.substring(b, e)), e++
        break
      }
      if (N === 92) {
        if (((T += i.substring(b, e)), e++, e >= r)) {
          c = 2
          break
        }
        switch (i.charCodeAt(e++)) {
          case 34:
            T += '"'
            break
          case 92:
            T += "\\"
            break
          case 47:
            T += "/"
            break
          case 98:
            T += "\b"
            break
          case 102:
            T += "\f"
            break
          case 110:
            T += `
`
            break
          case 114:
            T += "\r"
            break
          case 116:
            T += "	"
            break
          case 117: {
            const L = u(4)
            L >= 0 ? (T += String.fromCharCode(L)) : (c = 4)
            break
          }
          default:
            c = 5
        }
        b = e
        continue
      }
      if (N >= 0 && N <= 31)
        if (p7(N)) {
          ;(T += i.substring(b, e)), (c = 2)
          break
        } else c = 6
      e++
    }
    return T
  }
  function p() {
    if (((s = ""), (c = 0), (a = e), e >= r)) return (a = r), (o = 17)
    let T = i.charCodeAt(e)
    if (i2(T)) {
      do e++, (s += String.fromCharCode(T)), (T = i.charCodeAt(e))
      while (i2(T))
      return (o = 15)
    }
    if (p7(T))
      return (
        e++,
        (s += String.fromCharCode(T)),
        T === 13 &&
          i.charCodeAt(e) === 10 &&
          (e++,
          (s += `
`)),
        (o = 14)
      )
    switch (T) {
      case 123:
        return e++, (o = 1)
      case 125:
        return e++, (o = 2)
      case 91:
        return e++, (o = 3)
      case 93:
        return e++, (o = 4)
      case 58:
        return e++, (o = 6)
      case 44:
        return e++, (o = 5)
      case 34:
        return e++, (s = h()), (o = 10)
      case 47: {
        const b = e - 1
        if (i.charCodeAt(e + 1) === 47) {
          for (e += 2; e < r && !p7(i.charCodeAt(e)); ) e++
          return (s = i.substring(b, e)), (o = 12)
        }
        if (i.charCodeAt(e + 1) === 42) {
          e += 2
          const N = r - 1
          let $ = !1
          for (; e < N; ) {
            if (i.charCodeAt(e) === 42 && i.charCodeAt(e + 1) === 47) {
              ;(e += 2), ($ = !0)
              break
            }
            e++
          }
          return $ || (e++, (c = 1)), (s = i.substring(b, e)), (o = 13)
        }
        return (s += String.fromCharCode(T)), e++, (o = 16)
      }
      case 45:
        if (
          ((s += String.fromCharCode(T)), e++, e === r || !Sc(i.charCodeAt(e)))
        )
          return (o = 16)
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return (s += m()), (o = 11)
      default:
        for (; e < r && g(T); ) e++, (T = i.charCodeAt(e))
        if (a !== e) {
          switch (((s = i.substring(a, e)), s)) {
            case "true":
              return (o = 8)
            case "false":
              return (o = 9)
            case "null":
              return (o = 7)
          }
          return (o = 16)
        }
        return (s += String.fromCharCode(T)), e++, (o = 16)
    }
  }
  function g(T) {
    if (i2(T) || p7(T)) return !1
    switch (T) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return !1
    }
    return !0
  }
  function w() {
    let T
    do T = p()
    while (T >= 12 && T <= 15)
    return T
  }
  return {
    setPosition: l,
    getPosition: () => e,
    scan: t ? w : p,
    getToken: () => o,
    getTokenValue: () => s,
    getTokenOffset: () => a,
    getTokenLength: () => e - a,
    getTokenError: () => c,
  }
}
function i2(i) {
  return (
    i === 32 ||
    i === 9 ||
    i === 11 ||
    i === 12 ||
    i === 160 ||
    i === 5760 ||
    (i >= 8192 && i <= 8203) ||
    i === 8239 ||
    i === 8287 ||
    i === 12288 ||
    i === 65279
  )
}
function p7(i) {
  return i === 10 || i === 13 || i === 8232 || i === 8233
}
function Sc(i) {
  return i >= 48 && i <= 57
}
var GQ
;(function (i) {
  ;(i[(i.nullCharacter = 0)] = "nullCharacter"),
    (i[(i.maxAsciiCharacter = 127)] = "maxAsciiCharacter"),
    (i[(i.lineFeed = 10)] = "lineFeed"),
    (i[(i.carriageReturn = 13)] = "carriageReturn"),
    (i[(i.lineSeparator = 8232)] = "lineSeparator"),
    (i[(i.paragraphSeparator = 8233)] = "paragraphSeparator"),
    (i[(i.nextLine = 133)] = "nextLine"),
    (i[(i.space = 32)] = "space"),
    (i[(i.nonBreakingSpace = 160)] = "nonBreakingSpace"),
    (i[(i.enQuad = 8192)] = "enQuad"),
    (i[(i.emQuad = 8193)] = "emQuad"),
    (i[(i.enSpace = 8194)] = "enSpace"),
    (i[(i.emSpace = 8195)] = "emSpace"),
    (i[(i.threePerEmSpace = 8196)] = "threePerEmSpace"),
    (i[(i.fourPerEmSpace = 8197)] = "fourPerEmSpace"),
    (i[(i.sixPerEmSpace = 8198)] = "sixPerEmSpace"),
    (i[(i.figureSpace = 8199)] = "figureSpace"),
    (i[(i.punctuationSpace = 8200)] = "punctuationSpace"),
    (i[(i.thinSpace = 8201)] = "thinSpace"),
    (i[(i.hairSpace = 8202)] = "hairSpace"),
    (i[(i.zeroWidthSpace = 8203)] = "zeroWidthSpace"),
    (i[(i.narrowNoBreakSpace = 8239)] = "narrowNoBreakSpace"),
    (i[(i.ideographicSpace = 12288)] = "ideographicSpace"),
    (i[(i.mathematicalSpace = 8287)] = "mathematicalSpace"),
    (i[(i.ogham = 5760)] = "ogham"),
    (i[(i._ = 95)] = "_"),
    (i[(i.$ = 36)] = "$"),
    (i[(i._0 = 48)] = "_0"),
    (i[(i._1 = 49)] = "_1"),
    (i[(i._2 = 50)] = "_2"),
    (i[(i._3 = 51)] = "_3"),
    (i[(i._4 = 52)] = "_4"),
    (i[(i._5 = 53)] = "_5"),
    (i[(i._6 = 54)] = "_6"),
    (i[(i._7 = 55)] = "_7"),
    (i[(i._8 = 56)] = "_8"),
    (i[(i._9 = 57)] = "_9"),
    (i[(i.a = 97)] = "a"),
    (i[(i.b = 98)] = "b"),
    (i[(i.c = 99)] = "c"),
    (i[(i.d = 100)] = "d"),
    (i[(i.e = 101)] = "e"),
    (i[(i.f = 102)] = "f"),
    (i[(i.g = 103)] = "g"),
    (i[(i.h = 104)] = "h"),
    (i[(i.i = 105)] = "i"),
    (i[(i.j = 106)] = "j"),
    (i[(i.k = 107)] = "k"),
    (i[(i.l = 108)] = "l"),
    (i[(i.m = 109)] = "m"),
    (i[(i.n = 110)] = "n"),
    (i[(i.o = 111)] = "o"),
    (i[(i.p = 112)] = "p"),
    (i[(i.q = 113)] = "q"),
    (i[(i.r = 114)] = "r"),
    (i[(i.s = 115)] = "s"),
    (i[(i.t = 116)] = "t"),
    (i[(i.u = 117)] = "u"),
    (i[(i.v = 118)] = "v"),
    (i[(i.w = 119)] = "w"),
    (i[(i.x = 120)] = "x"),
    (i[(i.y = 121)] = "y"),
    (i[(i.z = 122)] = "z"),
    (i[(i.A = 65)] = "A"),
    (i[(i.B = 66)] = "B"),
    (i[(i.C = 67)] = "C"),
    (i[(i.D = 68)] = "D"),
    (i[(i.E = 69)] = "E"),
    (i[(i.F = 70)] = "F"),
    (i[(i.G = 71)] = "G"),
    (i[(i.H = 72)] = "H"),
    (i[(i.I = 73)] = "I"),
    (i[(i.J = 74)] = "J"),
    (i[(i.K = 75)] = "K"),
    (i[(i.L = 76)] = "L"),
    (i[(i.M = 77)] = "M"),
    (i[(i.N = 78)] = "N"),
    (i[(i.O = 79)] = "O"),
    (i[(i.P = 80)] = "P"),
    (i[(i.Q = 81)] = "Q"),
    (i[(i.R = 82)] = "R"),
    (i[(i.S = 83)] = "S"),
    (i[(i.T = 84)] = "T"),
    (i[(i.U = 85)] = "U"),
    (i[(i.V = 86)] = "V"),
    (i[(i.W = 87)] = "W"),
    (i[(i.X = 88)] = "X"),
    (i[(i.Y = 89)] = "Y"),
    (i[(i.Z = 90)] = "Z"),
    (i[(i.ampersand = 38)] = "ampersand"),
    (i[(i.asterisk = 42)] = "asterisk"),
    (i[(i.at = 64)] = "at"),
    (i[(i.backslash = 92)] = "backslash"),
    (i[(i.bar = 124)] = "bar"),
    (i[(i.caret = 94)] = "caret"),
    (i[(i.closeBrace = 125)] = "closeBrace"),
    (i[(i.closeBracket = 93)] = "closeBracket"),
    (i[(i.closeParen = 41)] = "closeParen"),
    (i[(i.colon = 58)] = "colon"),
    (i[(i.comma = 44)] = "comma"),
    (i[(i.dot = 46)] = "dot"),
    (i[(i.doubleQuote = 34)] = "doubleQuote"),
    (i[(i.equals = 61)] = "equals"),
    (i[(i.exclamation = 33)] = "exclamation"),
    (i[(i.greaterThan = 62)] = "greaterThan"),
    (i[(i.lessThan = 60)] = "lessThan"),
    (i[(i.minus = 45)] = "minus"),
    (i[(i.openBrace = 123)] = "openBrace"),
    (i[(i.openBracket = 91)] = "openBracket"),
    (i[(i.openParen = 40)] = "openParen"),
    (i[(i.percent = 37)] = "percent"),
    (i[(i.plus = 43)] = "plus"),
    (i[(i.question = 63)] = "question"),
    (i[(i.semicolon = 59)] = "semicolon"),
    (i[(i.singleQuote = 39)] = "singleQuote"),
    (i[(i.slash = 47)] = "slash"),
    (i[(i.tilde = 126)] = "tilde"),
    (i[(i.backspace = 8)] = "backspace"),
    (i[(i.formFeed = 12)] = "formFeed"),
    (i[(i.byteOrderMark = 65279)] = "byteOrderMark"),
    (i[(i.tab = 9)] = "tab"),
    (i[(i.verticalTab = 11)] = "verticalTab")
})(GQ || (GQ = {}))
function nvt(i, t, e = e2.DEFAULT) {
  const r = rvt(i, !1)
  function s(et) {
    return et ? () => et(r.getTokenOffset(), r.getTokenLength()) : () => !0
  }
  function a(et) {
    return et
      ? (wt) => et(wt, r.getTokenOffset(), r.getTokenLength())
      : () => !0
  }
  const o = s(t.onObjectBegin),
    c = a(t.onObjectProperty),
    u = s(t.onObjectEnd),
    l = s(t.onArrayBegin),
    m = s(t.onArrayEnd),
    h = a(t.onLiteralValue),
    p = a(t.onSeparator),
    g = s(t.onComment),
    w = a(t.onError),
    T = e && e.disallowComments,
    b = e && e.allowTrailingComma
  function N() {
    for (;;) {
      const et = r.scan()
      switch (r.getTokenError()) {
        case 4:
          $(14)
          break
        case 5:
          $(15)
          break
        case 3:
          $(13)
          break
        case 1:
          T || $(11)
          break
        case 2:
          $(12)
          break
        case 6:
          $(16)
          break
      }
      switch (et) {
        case 12:
        case 13:
          T ? $(10) : g()
          break
        case 16:
          $(1)
          break
        case 15:
        case 14:
          break
        default:
          return et
      }
    }
  }
  function $(et, wt = [], zt = []) {
    if ((w(et), wt.length + zt.length > 0)) {
      let Ct = r.getToken()
      for (; Ct !== 17; ) {
        if (wt.indexOf(Ct) !== -1) {
          N()
          break
        } else if (zt.indexOf(Ct) !== -1) break
        Ct = N()
      }
    }
  }
  function L(et) {
    const wt = r.getTokenValue()
    return et ? h(wt) : c(wt), N(), !0
  }
  function U() {
    switch (r.getToken()) {
      case 11: {
        let et = 0
        try {
          ;(et = JSON.parse(r.getTokenValue())),
            typeof et != "number" && ($(2), (et = 0))
        } catch {
          $(2)
        }
        h(et)
        break
      }
      case 7:
        h(null)
        break
      case 8:
        h(!0)
        break
      case 9:
        h(!1)
        break
      default:
        return !1
    }
    return N(), !0
  }
  function q() {
    return r.getToken() !== 10
      ? ($(3, [], [2, 5]), !1)
      : (L(!1),
        r.getToken() === 6
          ? (p(":"), N(), at() || $(4, [], [2, 5]))
          : $(5, [], [2, 5]),
        !0)
  }
  function V() {
    o(), N()
    let et = !1
    for (; r.getToken() !== 2 && r.getToken() !== 17; ) {
      if (r.getToken() === 5) {
        if ((et || $(4, [], []), p(","), N(), r.getToken() === 2 && b)) break
      } else et && $(6, [], [])
      q() || $(4, [], [2, 5]), (et = !0)
    }
    return u(), r.getToken() !== 2 ? $(7, [2], []) : N(), !0
  }
  function lt() {
    l(), N()
    let et = !1
    for (; r.getToken() !== 4 && r.getToken() !== 17; ) {
      if (r.getToken() === 5) {
        if ((et || $(4, [], []), p(","), N(), r.getToken() === 4 && b)) break
      } else et && $(6, [], [])
      at() || $(4, [], [4, 5]), (et = !0)
    }
    return m(), r.getToken() !== 4 ? $(8, [4], []) : N(), !0
  }
  function at() {
    switch (r.getToken()) {
      case 3:
        return lt()
      case 1:
        return V()
      case 10:
        return L(!0)
      default:
        return U()
    }
  }
  return (
    N(),
    r.getToken() === 17
      ? e.allowEmptyContent
        ? !0
        : ($(4, [], []), !1)
      : at()
        ? (r.getToken() !== 17 && $(9, [], []), !0)
        : ($(4, [], []), !1)
  )
}
function Fd(i) {
  return Object.isFrozen(i) ? i : Hj(i)
}
var bc = class to {
    static createEmptyModel(t) {
      return new to({}, [], [], void 0, t)
    }
    constructor(t, e, r, s, a) {
      ;(this.b = t),
        (this.c = e),
        (this.d = r),
        (this.raw = s),
        (this.f = a),
        (this.a = new Map())
    }
    get rawConfiguration() {
      if (!this.g)
        if (this.raw?.length) {
          const t = this.raw.map((e) => {
            if (e instanceof to) return e
            const r = new svt("", this.f)
            return r.parseRaw(e), r.configurationModel
          })
          this.g = t.reduce((e, r) => (r === e ? r : e.merge(r)), t[0])
        } else this.g = this
      return this.g
    }
    get contents() {
      return this.b
    }
    get overrides() {
      return this.d
    }
    get keys() {
      return this.c
    }
    isEmpty() {
      return (
        this.c.length === 0 &&
        Object.keys(this.b).length === 0 &&
        this.d.length === 0
      )
    }
    getValue(t) {
      return t ? x_(this.contents, t) : this.contents
    }
    inspect(t, e) {
      const r = this
      return {
        get value() {
          return Fd(r.rawConfiguration.getValue(t))
        },
        get override() {
          return e ? Fd(r.rawConfiguration.getOverrideValue(t, e)) : void 0
        },
        get merged() {
          return Fd(
            e
              ? r.rawConfiguration.override(e).getValue(t)
              : r.rawConfiguration.getValue(t),
          )
        },
        get overrides() {
          const s = []
          for (const { contents: a, identifiers: o, keys: c } of r
            .rawConfiguration.overrides) {
            const u = new to(a, c, [], void 0, r.f).getValue(t)
            u !== void 0 && s.push({ identifiers: o, value: u })
          }
          return s.length ? Fd(s) : void 0
        },
      }
    }
    getOverrideValue(t, e) {
      const r = this.j(e)
      return r ? (t ? x_(r, t) : r) : void 0
    }
    getKeysForOverrideIdentifier(t) {
      const e = []
      for (const r of this.overrides)
        r.identifiers.includes(t) && e.push(...r.keys)
      return so(e)
    }
    getAllOverrideIdentifiers() {
      const t = []
      for (const e of this.overrides) t.push(...e.identifiers)
      return so(t)
    }
    override(t) {
      let e = this.a.get(t)
      return e || ((e = this.h(t)), this.a.set(t, e)), e
    }
    merge(...t) {
      const e = pe(this.contents),
        r = pe(this.overrides),
        s = [...this.keys],
        a = this.raw?.length ? [...this.raw] : [this]
      for (const o of t)
        if ((a.push(...(o.raw?.length ? o.raw : [o])), !o.isEmpty())) {
          this.i(e, o.contents)
          for (const c of o.overrides) {
            const [u] = r.filter((l) => fn(l.identifiers, c.identifiers))
            u
              ? (this.i(u.contents, c.contents),
                u.keys.push(...c.keys),
                (u.keys = so(u.keys)))
              : r.push(pe(c))
          }
          for (const c of o.keys) s.indexOf(c) === -1 && s.push(c)
        }
      return new to(
        e,
        s,
        r,
        a.every((o) => o instanceof to) ? void 0 : a,
        this.f,
      )
    }
    h(t) {
      const e = this.j(t)
      if (!e || typeof e != "object" || !Object.keys(e).length) return this
      const r = {}
      for (const s of so([...Object.keys(this.contents), ...Object.keys(e)])) {
        let a = this.contents[s]
        const o = e[s]
        o &&
          (typeof a == "object" && typeof o == "object"
            ? ((a = pe(a)), this.i(a, o))
            : (a = o)),
          (r[s] = a)
      }
      return new to(r, this.keys, this.overrides, void 0, this.f)
    }
    i(t, e) {
      for (const r of Object.keys(e)) {
        if (r in t && Ce(t[r]) && Ce(e[r])) {
          this.i(t[r], e[r])
          continue
        }
        t[r] = pe(e[r])
      }
    }
    j(t) {
      let e = null,
        r = null
      const s = (a) => {
        a && (r ? this.i(r, a) : (r = pe(a)))
      }
      for (const a of this.overrides)
        a.identifiers.length === 1 && a.identifiers[0] === t
          ? (e = a.contents)
          : a.identifiers.includes(t) && s(a.contents)
      return s(e), r
    }
    toJSON() {
      return {
        contents: this.contents,
        overrides: this.overrides,
        keys: this.keys,
      }
    }
    addValue(t, e) {
      this.k(t, e, !0)
    }
    setValue(t, e) {
      this.k(t, e, !1)
    }
    removeValue(t) {
      const e = this.keys.indexOf(t)
      e !== -1 &&
        (this.keys.splice(e, 1),
        odt(this.contents, t),
        tn.test(t) &&
          this.overrides.splice(
            this.overrides.findIndex((r) => fn(r.identifiers, il(t))),
            1,
          ))
    }
    k(t, e, r) {
      if (
        (BG(this.contents, t, e, (s) => this.f.error(s)),
        (r = r || this.keys.indexOf(t) === -1),
        r && this.keys.push(t),
        tn.test(t))
      ) {
        const s = il(t),
          a = {
            identifiers: s,
            keys: Object.keys(this.contents[t]),
            contents: N3(this.contents[t], (c) => this.f.error(c)),
          },
          o = this.overrides.findIndex((c) => fn(c.identifiers, s))
        o !== -1 ? (this.overrides[o] = a) : this.overrides.push(a)
      }
    }
  },
  svt = class {
    constructor(i, t) {
      ;(this.f = i),
        (this.g = t),
        (this.a = null),
        (this.b = null),
        (this.c = []),
        (this.d = [])
    }
    get configurationModel() {
      return this.b || bc.createEmptyModel(this.g)
    }
    get restrictedConfigurations() {
      return this.c
    }
    get errors() {
      return this.d
    }
    parse(i, t) {
      if (!Le(i)) {
        const e = this.h(i)
        this.parseRaw(e, t)
      }
    }
    reparse(i) {
      this.a && this.parseRaw(this.a, i)
    }
    parseRaw(i, t) {
      this.a = i
      const {
        contents: e,
        keys: r,
        overrides: s,
        restricted: a,
        hasExcludedProperties: o,
      } = this.i(i, t)
      ;(this.b = new bc(e, r, s, o ? [i] : void 0, this.g)), (this.c = a || [])
    }
    h(i) {
      let t = {},
        e = null,
        r = []
      const s = [],
        a = []
      function o(u) {
        Array.isArray(r) ? r.push(u) : e !== null && (r[e] = u)
      }
      const c = {
        onObjectBegin: () => {
          const u = {}
          o(u), s.push(r), (r = u), (e = null)
        },
        onObjectProperty: (u) => {
          e = u
        },
        onObjectEnd: () => {
          r = s.pop()
        },
        onArrayBegin: () => {
          const u = []
          o(u), s.push(r), (r = u), (e = null)
        },
        onArrayEnd: () => {
          r = s.pop()
        },
        onLiteralValue: o,
        onError: (u, l, m) => {
          a.push({ error: u, offset: l, length: m })
        },
      }
      if (i)
        try {
          nvt(i, c), (t = r[0] || {})
        } catch (u) {
          this.g.error(`Error while parsing settings file ${this.f}: ${u}`),
            (this.d = [u])
        }
      return t
    }
    i(i, t) {
      const e = ui.as($o.Configuration).getConfigurationProperties(),
        r = this.j(i, e, !0, t)
      i = r.raw
      const s = N3(i, (c) =>
          this.g.error(`Conflict in settings file ${this.f}: ${c}`),
        ),
        a = Object.keys(i),
        o = this.m(i, (c) =>
          this.g.error(`Conflict in settings file ${this.f}: ${c}`),
        )
      return {
        contents: s,
        keys: a,
        overrides: o,
        restricted: r.restricted,
        hasExcludedProperties: r.hasExcludedProperties,
      }
    }
    j(i, t, e, r) {
      let s = !1
      if (!r?.scopes && !r?.skipRestricted && !r?.exclude?.length)
        return { raw: i, restricted: [], hasExcludedProperties: s }
      const a = {},
        o = []
      for (const c in i)
        if (tn.test(c) && e) {
          const u = this.j(i[c], t, !1, r)
          ;(a[c] = u.raw),
            (s = s || u.hasExcludedProperties),
            o.push(...u.restricted)
        } else {
          const u = t[c]
          u?.restricted && o.push(c), this.l(c, u, r) ? (a[c] = i[c]) : (s = !0)
        }
      return { raw: a, restricted: o, hasExcludedProperties: s }
    }
    l(i, t, e) {
      if (e.exclude?.includes(i)) return !1
      if (e.include?.includes(i)) return !0
      if ((e.skipRestricted && t?.restricted) || (e.skipUnregistered && !t))
        return !1
      const r = t ? (typeof t.scope < "u" ? t.scope : 3) : void 0
      return r === void 0 || e.scopes === void 0 ? !0 : e.scopes.includes(r)
    }
    m(i, t) {
      const e = []
      for (const r of Object.keys(i))
        if (tn.test(r)) {
          const s = {}
          for (const a in i[r]) s[a] = i[r][a]
          e.push({
            identifiers: il(r),
            keys: Object.keys(s),
            contents: N3(s, t),
          })
        }
      return e
    }
  },
  avt = class {
    constructor(i, t, e, r, s, a, o, c, u, l, m, h, p) {
      ;(this.a = i),
        (this.b = t),
        (this.c = e),
        (this.overrideIdentifiers = r),
        (this.d = s),
        (this.f = a),
        (this.g = o),
        (this.h = c),
        (this.i = u),
        (this.j = l),
        (this.k = m),
        (this.l = h),
        (this.m = p)
    }
    get value() {
      return Fd(this.c)
    }
    n(i) {
      return i?.value !== void 0 ||
        i?.override !== void 0 ||
        i?.overrides !== void 0
        ? i
        : void 0
    }
    get q() {
      return (
        this.p || (this.p = this.d.inspect(this.a, this.b.overrideIdentifier)),
        this.p
      )
    }
    get defaultValue() {
      return this.q.merged
    }
    get default() {
      return this.n(this.q)
    }
    get s() {
      return (
        this.r === void 0 && (this.r = this.f ? this.f.inspect(this.a) : null),
        this.r
      )
    }
    get policyValue() {
      return this.s?.merged
    }
    get policy() {
      return this.s?.value !== void 0 ? { value: this.s.value } : void 0
    }
    get u() {
      return (
        this.t === void 0 && (this.t = this.g ? this.g.inspect(this.a) : null),
        this.t
      )
    }
    get applicationValue() {
      return this.u?.merged
    }
    get application() {
      return this.n(this.u)
    }
    get w() {
      return (
        this.v || (this.v = this.h.inspect(this.a, this.b.overrideIdentifier)),
        this.v
      )
    }
    get userValue() {
      return this.w.merged
    }
    get user() {
      return this.n(this.w)
    }
    get y() {
      return (
        this.x || (this.x = this.i.inspect(this.a, this.b.overrideIdentifier)),
        this.x
      )
    }
    get userLocalValue() {
      return this.y.merged
    }
    get userLocal() {
      return this.n(this.y)
    }
    get A() {
      return (
        this.z || (this.z = this.j.inspect(this.a, this.b.overrideIdentifier)),
        this.z
      )
    }
    get userRemoteValue() {
      return this.A.merged
    }
    get userRemote() {
      return this.n(this.A)
    }
    get D() {
      return (
        this.B === void 0 &&
          (this.B = this.k
            ? this.k.inspect(this.a, this.b.overrideIdentifier)
            : null),
        this.B
      )
    }
    get workspaceValue() {
      return this.D?.merged
    }
    get workspace() {
      return this.n(this.D)
    }
    get F() {
      return (
        this.E === void 0 &&
          (this.E = this.l
            ? this.l.inspect(this.a, this.b.overrideIdentifier)
            : null),
        this.E
      )
    }
    get workspaceFolderValue() {
      return this.F?.merged
    }
    get workspaceFolder() {
      return this.n(this.F)
    }
    get H() {
      return (
        this.G === void 0 &&
          (this.G = this.m.inspect(this.a, this.b.overrideIdentifier)),
        this.G
      )
    }
    get memoryValue() {
      return this.H.merged
    }
    get memory() {
      return this.n(this.H)
    }
  },
  r2 = class Wnt {
    constructor(t, e, r, s, a, o, c, u, l, m) {
      ;(this.j = t),
        (this.l = e),
        (this.m = r),
        (this.n = s),
        (this.p = a),
        (this.q = o),
        (this.r = c),
        (this.s = u),
        (this.t = l),
        (this.u = m),
        (this.h = null),
        (this.i = new ei()),
        (this.v = null)
    }
    getValue(t, e, r) {
      return this.w(t, e, r).getValue(t)
    }
    updateValue(t, e, r = {}) {
      let s
      r.resource
        ? ((s = this.t.get(r.resource)),
          s || ((s = bc.createEmptyModel(this.u)), this.t.set(r.resource, s)))
        : (s = this.s),
        e === void 0 ? s.removeValue(t) : s.setValue(t, e),
        r.resource || (this.h = null)
    }
    inspect(t, e, r) {
      const s = this.w(t, e, r),
        a = this.A(e.resource, r),
        o = e.resource ? this.t.get(e.resource) || this.s : this.s,
        c = new Set()
      for (const u of s.overrides)
        for (const l of u.identifiers)
          s.getOverrideValue(t, l) !== void 0 && c.add(l)
      return new avt(
        t,
        e,
        s.getValue(t),
        c.size ? [...c] : void 0,
        this.j,
        this.l.isEmpty() ? void 0 : this.l,
        this.applicationConfiguration.isEmpty()
          ? void 0
          : this.applicationConfiguration,
        this.userConfiguration,
        this.localUserConfiguration,
        this.remoteUserConfiguration,
        r ? this.q : void 0,
        a || void 0,
        o,
      )
    }
    keys(t) {
      const e = this.A(void 0, t)
      return {
        default: this.j.keys.slice(0),
        user: this.userConfiguration.keys.slice(0),
        workspace: this.q.keys.slice(0),
        workspaceFolder: e ? e.keys.slice(0) : [],
      }
    }
    updateDefaultConfiguration(t) {
      ;(this.j = t), (this.h = null), this.i.clear()
    }
    updatePolicyConfiguration(t) {
      this.l = t
    }
    updateApplicationConfiguration(t) {
      ;(this.m = t), (this.h = null), this.i.clear()
    }
    updateLocalUserConfiguration(t) {
      ;(this.n = t), (this.v = null), (this.h = null), this.i.clear()
    }
    updateRemoteUserConfiguration(t) {
      ;(this.p = t), (this.v = null), (this.h = null), this.i.clear()
    }
    updateWorkspaceConfiguration(t) {
      ;(this.q = t), (this.h = null), this.i.clear()
    }
    updateFolderConfiguration(t, e) {
      this.r.set(t, e), this.i.delete(t)
    }
    deleteFolderConfiguration(t) {
      this.folderConfigurations.delete(t), this.i.delete(t)
    }
    compareAndUpdateDefaultConfiguration(t, e) {
      const r = []
      if (!e) {
        const { added: s, updated: a, removed: o } = Rs(this.j, t)
        e = [...s, ...a, ...o]
      }
      for (const s of e)
        for (const a of il(s)) {
          const o = this.j.getKeysForOverrideIdentifier(a),
            c = t.getKeysForOverrideIdentifier(a),
            u = [
              ...c.filter((l) => o.indexOf(l) === -1),
              ...o.filter((l) => c.indexOf(l) === -1),
              ...o.filter(
                (l) =>
                  !Ir(
                    this.j.override(a).getValue(l),
                    t.override(a).getValue(l),
                  ),
              ),
            ]
          r.push([a, u])
        }
      return this.updateDefaultConfiguration(t), { keys: e, overrides: r }
    }
    compareAndUpdatePolicyConfiguration(t) {
      const { added: e, updated: r, removed: s } = Rs(this.l, t),
        a = [...e, ...r, ...s]
      return (
        a.length && this.updatePolicyConfiguration(t),
        { keys: a, overrides: [] }
      )
    }
    compareAndUpdateApplicationConfiguration(t) {
      const {
          added: e,
          updated: r,
          removed: s,
          overrides: a,
        } = Rs(this.applicationConfiguration, t),
        o = [...e, ...r, ...s]
      return (
        o.length && this.updateApplicationConfiguration(t),
        { keys: o, overrides: a }
      )
    }
    compareAndUpdateLocalUserConfiguration(t) {
      const {
          added: e,
          updated: r,
          removed: s,
          overrides: a,
        } = Rs(this.localUserConfiguration, t),
        o = [...e, ...r, ...s]
      return (
        o.length && this.updateLocalUserConfiguration(t),
        { keys: o, overrides: a }
      )
    }
    compareAndUpdateRemoteUserConfiguration(t) {
      const {
          added: e,
          updated: r,
          removed: s,
          overrides: a,
        } = Rs(this.remoteUserConfiguration, t),
        o = [...e, ...r, ...s]
      return (
        o.length && this.updateRemoteUserConfiguration(t),
        { keys: o, overrides: a }
      )
    }
    compareAndUpdateWorkspaceConfiguration(t) {
      const {
          added: e,
          updated: r,
          removed: s,
          overrides: a,
        } = Rs(this.workspaceConfiguration, t),
        o = [...e, ...r, ...s]
      return (
        o.length && this.updateWorkspaceConfiguration(t),
        { keys: o, overrides: a }
      )
    }
    compareAndUpdateFolderConfiguration(t, e) {
      const r = this.folderConfigurations.get(t),
        { added: s, updated: a, removed: o, overrides: c } = Rs(r, e),
        u = [...s, ...a, ...o]
      return (
        (u.length || !r) && this.updateFolderConfiguration(t, e),
        { keys: u, overrides: c }
      )
    }
    compareAndDeleteFolderConfiguration(t) {
      const e = this.folderConfigurations.get(t)
      if (!e) throw new Error("Unknown folder")
      this.deleteFolderConfiguration(t)
      const { added: r, updated: s, removed: a, overrides: o } = Rs(e, void 0)
      return { keys: [...r, ...s, ...a], overrides: o }
    }
    get defaults() {
      return this.j
    }
    get applicationConfiguration() {
      return this.m
    }
    get userConfiguration() {
      return (
        this.v || (this.v = this.p.isEmpty() ? this.n : this.n.merge(this.p)),
        this.v
      )
    }
    get localUserConfiguration() {
      return this.n
    }
    get remoteUserConfiguration() {
      return this.p
    }
    get workspaceConfiguration() {
      return this.q
    }
    get folderConfigurations() {
      return this.r
    }
    w(t, e, r) {
      let s = this.x(e, r)
      return (
        e.overrideIdentifier && (s = s.override(e.overrideIdentifier)),
        !this.l.isEmpty() &&
          this.l.getValue(t) !== void 0 &&
          (s = s.merge(this.l)),
        s
      )
    }
    x({ resource: t }, e) {
      let r = this.y()
      if (e && t) {
        const s = e.getFolder(t)
        s && (r = this.z(s.uri) || r)
        const a = this.t.get(t)
        a && (r = r.merge(a))
      }
      return r
    }
    y() {
      return (
        this.h ||
          (this.h = this.j.merge(
            this.applicationConfiguration,
            this.userConfiguration,
            this.q,
            this.s,
          )),
        this.h
      )
    }
    z(t) {
      let e = this.i.get(t)
      if (!e) {
        const r = this.y(),
          s = this.r.get(t)
        s ? ((e = r.merge(s)), this.i.set(t, e)) : (e = r)
      }
      return e
    }
    A(t, e) {
      if (e && t) {
        const r = e.getFolder(t)
        if (r) return this.r.get(r.uri)
      }
    }
    toData() {
      return {
        defaults: {
          contents: this.j.contents,
          overrides: this.j.overrides,
          keys: this.j.keys,
        },
        policy: {
          contents: this.l.contents,
          overrides: this.l.overrides,
          keys: this.l.keys,
        },
        application: {
          contents: this.applicationConfiguration.contents,
          overrides: this.applicationConfiguration.overrides,
          keys: this.applicationConfiguration.keys,
        },
        user: {
          contents: this.userConfiguration.contents,
          overrides: this.userConfiguration.overrides,
          keys: this.userConfiguration.keys,
        },
        workspace: {
          contents: this.q.contents,
          overrides: this.q.overrides,
          keys: this.q.keys,
        },
        folders: [...this.r.keys()].reduce((t, e) => {
          const { contents: r, overrides: s, keys: a } = this.r.get(e)
          return t.push([e, { contents: r, overrides: s, keys: a }]), t
        }, []),
      }
    }
    allKeys() {
      const t = new Set()
      return (
        this.j.keys.forEach((e) => t.add(e)),
        this.userConfiguration.keys.forEach((e) => t.add(e)),
        this.q.keys.forEach((e) => t.add(e)),
        this.r.forEach((e) => e.keys.forEach((r) => t.add(r))),
        [...t.values()]
      )
    }
    B() {
      const t = new Set()
      return (
        this.j.getAllOverrideIdentifiers().forEach((e) => t.add(e)),
        this.userConfiguration
          .getAllOverrideIdentifiers()
          .forEach((e) => t.add(e)),
        this.q.getAllOverrideIdentifiers().forEach((e) => t.add(e)),
        this.r.forEach((e) =>
          e.getAllOverrideIdentifiers().forEach((r) => t.add(r)),
        ),
        [...t.values()]
      )
    }
    D(t) {
      const e = new Set()
      return (
        this.j.getKeysForOverrideIdentifier(t).forEach((r) => e.add(r)),
        this.userConfiguration
          .getKeysForOverrideIdentifier(t)
          .forEach((r) => e.add(r)),
        this.q.getKeysForOverrideIdentifier(t).forEach((r) => e.add(r)),
        this.r.forEach((r) =>
          r.getKeysForOverrideIdentifier(t).forEach((s) => e.add(s)),
        ),
        [...e.values()]
      )
    }
    static parse(t, e) {
      const r = this.E(t.defaults, e),
        s = this.E(t.policy, e),
        a = this.E(t.application, e),
        o = this.E(t.user, e),
        c = this.E(t.workspace, e),
        u = t.folders.reduce(
          (l, m) => (l.set(S.revive(m[0]), this.E(m[1], e)), l),
          new ei(),
        )
      return new Wnt(
        r,
        s,
        a,
        o,
        bc.createEmptyModel(e),
        c,
        u,
        bc.createEmptyModel(e),
        new ei(),
        e,
      )
    }
    static E(t, e) {
      return new bc(t.contents, t.keys, t.overrides, void 0, e)
    }
  },
  ovt = class {
    constructor(i, t, e, r, s) {
      ;(this.change = i),
        (this.f = t),
        (this.g = e),
        (this.h = r),
        (this.i = s),
        (this.a = `
`),
        (this.b = this.a.charCodeAt(0)),
        (this.c = 46),
        (this.affectedKeys = new Set()),
        (this.j = void 0)
      for (const a of i.keys) this.affectedKeys.add(a)
      for (const [, a] of i.overrides)
        for (const o of a) this.affectedKeys.add(o)
      this.d = this.a
      for (const a of this.affectedKeys) this.d += a + this.a
    }
    get previousConfiguration() {
      return (
        !this.j && this.f && (this.j = r2.parse(this.f.data, this.i)), this.j
      )
    }
    affectsConfiguration(i, t) {
      const e = this.a + i,
        r = this.d.indexOf(e)
      if (r < 0) return !1
      const s = r + e.length
      if (s >= this.d.length) return !1
      const a = this.d.charCodeAt(s)
      if (a !== this.b && a !== this.c) return !1
      if (t) {
        const o = this.previousConfiguration
            ? this.previousConfiguration.getValue(i, t, this.f?.workspace)
            : void 0,
          c = this.g.getValue(i, t, this.h)
        return !Ir(o, c)
      }
      return !0
    }
  }
function Rs(i, t) {
  const {
      added: e,
      removed: r,
      updated: s,
    } = zQ(t?.rawConfiguration, i?.rawConfiguration),
    a = [],
    o = i?.getAllOverrideIdentifiers() || [],
    c = t?.getAllOverrideIdentifiers() || []
  if (t) {
    const u = c.filter((l) => !o.includes(l))
    for (const l of u) a.push([l, t.getKeysForOverrideIdentifier(l)])
  }
  if (i) {
    const u = o.filter((l) => !c.includes(l))
    for (const l of u) a.push([l, i.getKeysForOverrideIdentifier(l)])
  }
  if (t && i) {
    for (const u of o)
      if (c.includes(u)) {
        const l = zQ(
          {
            contents: i.getOverrideValue(void 0, u) || {},
            keys: i.getKeysForOverrideIdentifier(u),
          },
          {
            contents: t.getOverrideValue(void 0, u) || {},
            keys: t.getKeysForOverrideIdentifier(u),
          },
        )
        a.push([u, [...l.added, ...l.removed, ...l.updated]])
      }
  }
  return { added: e, removed: r, updated: s, overrides: a }
}
function zQ(i, t) {
  const e = i
      ? t
        ? i.keys.filter((a) => t.keys.indexOf(a) === -1)
        : [...i.keys]
      : [],
    r = t
      ? i
        ? t.keys.filter((a) => i.keys.indexOf(a) === -1)
        : [...t.keys]
      : [],
    s = []
  if (i && t) {
    for (const a of t.keys)
      if (i.keys.indexOf(a) !== -1) {
        const o = x_(t.contents, a),
          c = x_(i.contents, a)
        Ir(o, c) || s.push(a)
      }
  }
  return { added: e, removed: r, updated: s }
}
function _d(i, t) {
  if (t) {
    const e = t.split(".")
    let r = i
    for (let s = 0; r && s < e.length; s++) r = r[e[s]]
    return r
  }
}
function cvt(i) {
  return i instanceof S
}
function uvt(i) {
  return (
    i && i.uri instanceof S && i.languageId && typeof i.languageId == "string"
  )
}
function lvt(i) {
  return i && !i.uri && i.languageId && typeof i.languageId == "string"
}
function dvt(i) {
  return (
    i &&
    i.uri instanceof S &&
    (!i.name || typeof i.name == "string") &&
    (!i.index || typeof i.index == "number")
  )
}
function YQ(i) {
  if (cvt(i)) return { resource: i }
  if (uvt(i)) return { resource: i.uri, overrideIdentifier: i.languageId }
  if (lvt(i)) return { overrideIdentifier: i.languageId }
  if (dvt(i)) return { resource: i.uri }
  if (i === null) return { resource: null }
}
var n2 = class {
  constructor(t, e, r) {
    ;(this.a = t.getProxy(z.MainThreadConfiguration)),
      (this.c = e),
      (this.b = r),
      (this.d = new Xr()),
      (this.e = null)
  }
  getConfigProvider() {
    return this.d.wait().then((t) => this.e)
  }
  $initializeConfiguration(t) {
    ;(this.e = new mvt(this.a, this.c, t, this.b)), this.d.open()
  }
  $acceptConfigurationChanged(t, e) {
    this.getConfigProvider().then((r) => r.$acceptConfigurationChanged(t, e))
  }
}
n2 = __decorate([__param(0, Vt), __param(1, _n), __param(2, Kt)], n2)
var mvt = class {
    constructor(i, t, e, r) {
      ;(this.a = new C()),
        (this.b = i),
        (this.f = r),
        (this.c = t),
        (this.e = r2.parse(e, r)),
        (this.d = this.k(e.configurationScopes))
    }
    get onDidChangeConfiguration() {
      return this.a && this.a.event
    }
    $acceptConfigurationChanged(i, t) {
      const e = { data: this.e.toData(), workspace: this.c.workspace }
      ;(this.e = r2.parse(i, this.f)),
        (this.d = this.k(i.configurationScopes)),
        this.a.fire(this.j(t, e))
    }
    getConfiguration(i, t, e) {
      const r = YQ(t) || {},
        s = this.g(
          i
            ? _d(this.e.getValue(void 0, r, this.c.workspace), i)
            : this.e.getValue(void 0, r, this.c.workspace),
        )
      i && this.h(i, r, e?.identifier)
      function a(c) {
        if (c == null) return null
        if (typeof c == "boolean") return c ? 2 : 5
        switch (c) {
          case jo.Global:
            return 2
          case jo.Workspace:
            return 5
          case jo.WorkspaceFolder:
            return 6
        }
      }
      const o = {
        has(c) {
          return typeof _d(s, c) < "u"
        },
        get: (c, u) => {
          this.h(i ? `${i}.${c}` : c, r, e?.identifier)
          let l = _d(s, c)
          if (typeof l > "u") l = u
          else {
            let m
            const h = (p, g) => {
              if (Ce(p)) {
                let w
                const T = () => {
                  ;(m = m || pe(s)), (w = w || _d(m, g))
                }
                return new Proxy(p, {
                  get: (b, N) => {
                    if (typeof N == "string" && N.toLowerCase() === "tojson")
                      return T(), () => w
                    if (m) return (w = w || _d(m, g)), w[N]
                    const $ = b[N]
                    return typeof N == "string" ? h($, `${g}.${N}`) : $
                  },
                  set: (b, N, $) => (T(), w && (w[N] = $), !0),
                  deleteProperty: (b, N) => (T(), w && delete w[N], !0),
                  defineProperty: (b, N, $) => (
                    T(), w && Object.defineProperty(w, N, $), !0
                  ),
                })
              }
              return Array.isArray(p) ? pe(p) : p
            }
            l = h(l, c)
          }
          return l
        },
        update: (c, u, l, m) => {
          c = i ? `${i}.${c}` : c
          const h = a(l)
          return u !== void 0
            ? this.b.$updateConfigurationOption(h, c, u, r, m)
            : this.b.$removeConfigurationOption(h, c, r, m)
        },
        inspect: (c) => {
          c = i ? `${i}.${c}` : c
          const u = this.e.inspect(c, r, this.c.workspace)
          if (u)
            return {
              key: c,
              defaultValue: pe(u.policy?.value ?? u.default?.value),
              globalValue: pe(u.user?.value ?? u.application?.value),
              workspaceValue: pe(u.workspace?.value),
              workspaceFolderValue: pe(u.workspaceFolder?.value),
              defaultLanguageValue: pe(u.default?.override),
              globalLanguageValue: pe(
                u.user?.override ?? u.application?.override,
              ),
              workspaceLanguageValue: pe(u.workspace?.override),
              workspaceFolderLanguageValue: pe(u.workspaceFolder?.override),
              languageIds: pe(u.overrideIdentifiers),
            }
        },
      }
      return typeof s == "object" && ra(o, s, !1), Object.freeze(o)
    }
    g(i) {
      const t = (e) =>
        Ce(e)
          ? new Proxy(e, {
              get: (r, s) => t(r[s]),
              set: (r, s, a) => {
                throw new Error(
                  `TypeError: Cannot assign to read only property '${String(s)}' of object`,
                )
              },
              deleteProperty: (r, s) => {
                throw new Error(
                  `TypeError: Cannot delete read only property '${String(s)}' of object`,
                )
              },
              defineProperty: (r, s) => {
                throw new Error(
                  `TypeError: Cannot define property '${String(s)}' for a readonly object`,
                )
              },
              setPrototypeOf: (r) => {
                throw new Error(
                  "TypeError: Cannot set prototype for a readonly object",
                )
              },
              isExtensible: () => !1,
              preventExtensions: () => !0,
            })
          : e
      return t(i)
    }
    h(i, t, e) {
      const r = tn.test(i) ? 4 : this.d.get(i),
        s = e ? `[${e.value}] ` : ""
      if (r === 4) {
        typeof t?.resource > "u" &&
          this.f.warn(
            `${s}Accessing a resource scoped configuration without providing a resource is not expected. To get the effective value for '${i}', provide the URI of a resource or 'null' for any resource.`,
          )
        return
      }
      if (r === 3) {
        t?.resource &&
          this.f.warn(
            `${s}Accessing a window scoped configuration for a resource is not expected. To associate '${i}' to a resource, define its scope to 'resource' in configuration contributions in 'package.json'.`,
          )
        return
      }
    }
    j(i, t) {
      const e = new ovt(i, t, this.e, this.c.workspace, this.f)
      return Object.freeze({
        affectsConfiguration: (r, s) => e.affectsConfiguration(r, YQ(s)),
      })
    }
    k(i) {
      return i.reduce((t, e) => (t.set(e[0], e[1]), t), new Map())
    }
  },
  An = Y("IExtHostConfiguration"),
  Ye,
  s2 = globalThis.vscode
if (typeof s2 < "u" && typeof s2.context < "u") {
  const i = s2.context.configuration()
  if (i) Ye = i.product
  else
    throw new Error(
      "Sandbox: unable to resolve product configuration from preload script.",
    )
} else if (globalThis._VSCODE_PRODUCT_JSON && globalThis._VSCODE_PACKAGE_JSON) {
  if (
    ((Ye = globalThis._VSCODE_PRODUCT_JSON),
    Ju.VSCODE_DEV &&
      Object.assign(Ye, {
        nameShort: `${Ye.nameShort} Dev`,
        nameLong: `${Ye.nameLong} Dev`,
        dataFolderName: `${Ye.dataFolderName}-dev`,
        serverDataFolderName: Ye.serverDataFolderName
          ? `${Ye.serverDataFolderName}-dev`
          : void 0,
      }),
    Ju.VSCODE_DEV_ONBOARDING &&
      Object.assign(Ye, {
        nameShort: `${Ye.nameShort} Onboarding`,
        nameLong: `${Ye.nameLong} Onboarding`,
        dataFolderName: `${Ye.dataFolderName}-onboarding`,
        serverDataFolderName: Ye.serverDataFolderName
          ? `${Ye.serverDataFolderName}-onboarding`
          : void 0,
      }),
    !Ye.version)
  ) {
    const i = globalThis._VSCODE_PACKAGE_JSON
    Object.assign(Ye, { version: i.version })
  }
} else
  (Ye = {}),
    Object.keys(Ye).length === 0 &&
      Object.assign(Ye, {
        version: "1.94.0-dev",
        nameShort: "Cursor Dev",
        nameLong: "Cursor Dev",
        applicationName: "cursor",
        dataFolderName: ".cursor",
        urlProtocol: "cursor",
        reportIssueUrl: "https://github.com/getcursor/cursor/issues/new",
        licenseName: "MIT",
        licenseUrl: "https://github.com/getcursor/cursor/",
        serverLicenseUrl: "https://github.com/getcursor/cursor/",
      })
var a2 = Ye,
  hvt = class {
    constructor(i, t) {
      ;(this.versionId = i), (this.removedDueToLooping = t)
    }
  },
  Ad = class jnt {
    static isHostExtension(t, e, r) {
      if (e.getExtensionDescription(t)) return !1
      const s = r.getExtensionDescription(t)
      return s ? !!((s.main || s.browser) && s.api === "none") : !1
    }
    constructor(t, e) {
      ;(this.j = t),
        (this.c = new C()),
        (this.onDidChange = this.c.event),
        (this.d = 0),
        (this.e = e.map(o2)),
        this.k()
    }
    k() {
      this.e.sort(pvt), (this.f = new bn()), (this.g = []), (this.h = new Map())
      for (const t of this.e) {
        if (this.f.has(t.identifier)) {
          console.error(
            "Extension `" + t.identifier.value + "` is already registered",
          )
          continue
        }
        this.f.set(t.identifier, t), this.g.push(t)
        const e = this.j.readActivationEvents(t)
        for (const r of e)
          this.h.has(r) || this.h.set(r, []), this.h.get(r).push(t)
      }
    }
    set(t) {
      return (
        (this.e = t.map(o2)),
        this.k(),
        this.d++,
        this.c.fire(void 0),
        { versionId: this.d }
      )
    }
    deltaExtensions(t, e) {
      ;(t = t.map(o2)), (this.e = XQ(this.e, e)), (this.e = this.e.concat(t))
      const r = jnt.l(this.e)
      return (
        (this.e = XQ(
          this.e,
          r.map((s) => s.identifier),
        )),
        this.k(),
        this.d++,
        this.c.fire(void 0),
        new hvt(this.d, r)
      )
    }
    static l(t) {
      const e = new (class {
          constructor() {
            ;(this.c = new Map()), (this.d = new Set()), (this.e = [])
          }
          addNode(c) {
            this.d.has(c) || (this.d.add(c), this.e.push(c))
          }
          addArc(c, u) {
            this.addNode(c),
              this.addNode(u),
              this.c.has(c) ? this.c.get(c).push(u) : this.c.set(c, [u])
          }
          getArcs(c) {
            return this.c.has(c) ? this.c.get(c) : []
          }
          hasOnlyGoodArcs(c, u) {
            const l = e.getArcs(c)
            for (let m = 0; m < l.length; m++) if (!u.has(l[m])) return !1
            return !0
          }
          getNodes() {
            return this.e
          }
        })(),
        r = new bn()
      for (const c of t)
        if ((r.set(c.identifier, c), c.extensionDependencies))
          for (const u of c.extensionDependencies)
            e.addArc(te.toKey(c.identifier), te.toKey(u))
      const s = new Set()
      e.getNodes()
        .filter((c) => e.getArcs(c).length === 0)
        .forEach((c) => s.add(c))
      const a = e.getNodes().filter((c) => !s.has(c))
      let o
      do {
        o = !1
        for (let c = 0; c < a.length; c++) {
          const u = a[c]
          e.hasOnlyGoodArcs(u, s) && (a.splice(c, 1), c--, s.add(u), (o = !0))
        }
      } while (o)
      return a.map((c) => r.get(c))
    }
    containsActivationEvent(t) {
      return this.h.has(t)
    }
    containsExtension(t) {
      return this.f.has(t)
    }
    getExtensionDescriptionsForActivationEvent(t) {
      const e = this.h.get(t)
      return e ? e.slice(0) : []
    }
    getAllExtensionDescriptions() {
      return this.g.slice(0)
    }
    getSnapshot() {
      return new fvt(this.d, this.getAllExtensionDescriptions())
    }
    getExtensionDescription(t) {
      const e = this.f.get(t)
      return e || void 0
    }
    getExtensionDescriptionByUUID(t) {
      for (const e of this.g) if (e.uuid === t) return e
    }
    getExtensionDescriptionByIdOrUUID(t, e) {
      return (
        this.getExtensionDescription(t) ??
        (e ? this.getExtensionDescriptionByUUID(e) : void 0)
      )
    }
  },
  fvt = class {
    constructor(i, t) {
      ;(this.versionId = i), (this.extensions = t)
    }
  },
  QQ
;(function (i) {
  ;(i[(i.Builtin = 0)] = "Builtin"),
    (i[(i.User = 1)] = "User"),
    (i[(i.Dev = 2)] = "Dev")
})(QQ || (QQ = {}))
function pvt(i, t) {
  const e = i.isBuiltin ? 0 : i.isUnderDevelopment ? 2 : 1,
    r = t.isBuiltin ? 0 : t.isUnderDevelopment ? 2 : 1
  if (e !== r) return e - r
  const s = Ut.basename(i.extensionLocation.path),
    a = Ut.basename(t.extensionLocation.path)
  return s < a ? -1 : s > a ? 1 : 0
}
function XQ(i, t) {
  const e = new la(t)
  return i.filter((r) => !e.has(r.identifier))
}
function o2(i) {
  return {
    ...i,
    extensionDependencies: i.extensionDependencies?.map(
      (t) => a2.modifiedExtensionDependencies?.[t] ?? t,
    ),
  }
}
var c2 = "^([a-z0-9A-Z][a-z0-9-A-Z]*)\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$",
  OOt = new RegExp(c2),
  KQ
;(function (i) {
  ;(i.COMMAND = "command"), (i.SETTINGS_SYNC = "settingsSync")
})(KQ || (KQ = {}))
var ZQ
;(function (i) {
  ;(i[(i.NoneOrRelevance = 0)] = "NoneOrRelevance"),
    (i[(i.LastUpdatedDate = 1)] = "LastUpdatedDate"),
    (i[(i.Title = 2)] = "Title"),
    (i[(i.PublisherName = 3)] = "PublisherName"),
    (i[(i.InstallCount = 4)] = "InstallCount"),
    (i[(i.PublishedDate = 10)] = "PublishedDate"),
    (i[(i.AverageRating = 6)] = "AverageRating"),
    (i[(i.WeightedRating = 12)] = "WeightedRating")
})(ZQ || (ZQ = {}))
var tX
;(function (i) {
  ;(i[(i.Default = 0)] = "Default"),
    (i[(i.Ascending = 1)] = "Ascending"),
    (i[(i.Descending = 2)] = "Descending")
})(tX || (tX = {}))
var eX
;(function (i) {
  ;(i.Install = "install"), (i.Uninstall = "uninstall")
})(eX || (eX = {}))
var iX
;(function (i) {
  ;(i[(i.None = 1)] = "None"),
    (i[(i.Install = 2)] = "Install"),
    (i[(i.Update = 3)] = "Update"),
    (i[(i.Migrate = 4)] = "Migrate")
})(iX || (iX = {}))
var qOt = Y("extensionGalleryService"),
  rX
;(function (i) {
  ;(i.Timeout = "Timeout"),
    (i.Cancelled = "Cancelled"),
    (i.Failed = "Failed"),
    (i.DownloadFailedWriting = "DownloadFailedWriting"),
    (i.Offline = "Offline")
})(rX || (rX = {}))
var nX
;(function (i) {
  ;(i.Unsupported = "Unsupported"),
    (i.Deprecated = "Deprecated"),
    (i.Malicious = "Malicious"),
    (i.Incompatible = "Incompatible"),
    (i.IncompatibleApi = "IncompatibleApi"),
    (i.IncompatibleTargetPlatform = "IncompatibleTargetPlatform"),
    (i.ReleaseVersionNotFound = "ReleaseVersionNotFound"),
    (i.Invalid = "Invalid"),
    (i.Download = "Download"),
    (i.DownloadSignature = "DownloadSignature"),
    (i.DownloadFailedWriting = "DownloadFailedWriting"),
    (i.UpdateMetadata = "UpdateMetadata"),
    (i.Extract = "Extract"),
    (i.Scanning = "Scanning"),
    (i.ScanningExtension = "ScanningExtension"),
    (i.ReadUninstalled = "ReadUninstalled"),
    (i.UnsetUninstalled = "UnsetUninstalled"),
    (i.Delete = "Delete"),
    (i.Rename = "Rename"),
    (i.IntializeDefaultProfile = "IntializeDefaultProfile"),
    (i.AddToProfile = "AddToProfile"),
    (i.InstalledExtensionNotFound = "InstalledExtensionNotFound"),
    (i.PostInstall = "PostInstall"),
    (i.CorruptZip = "CorruptZip"),
    (i.IncompleteZip = "IncompleteZip"),
    (i.PackageNotSigned = "PackageNotSigned"),
    (i.SignatureVerificationInternal = "SignatureVerificationInternal"),
    (i.SignatureVerificationFailed = "SignatureVerificationFailed"),
    (i.NotAllowed = "NotAllowed"),
    (i.Gallery = "Gallery"),
    (i.Cancelled = "Cancelled"),
    (i.Unknown = "Unknown"),
    (i.Internal = "Internal")
})(nX || (nX = {}))
var sX
;(function (i) {
  ;(i.NotSigned = "NotSigned"),
    (i.Success = "Success"),
    (i.RequiredArgumentMissing = "RequiredArgumentMissing"),
    (i.InvalidArgument = "InvalidArgument"),
    (i.PackageIsUnreadable = "PackageIsUnreadable"),
    (i.UnhandledException = "UnhandledException"),
    (i.SignatureManifestIsMissing = "SignatureManifestIsMissing"),
    (i.SignatureManifestIsUnreadable = "SignatureManifestIsUnreadable"),
    (i.SignatureIsMissing = "SignatureIsMissing"),
    (i.SignatureIsUnreadable = "SignatureIsUnreadable"),
    (i.CertificateIsUnreadable = "CertificateIsUnreadable"),
    (i.SignatureArchiveIsUnreadable = "SignatureArchiveIsUnreadable"),
    (i.FileAlreadyExists = "FileAlreadyExists"),
    (i.SignatureArchiveIsInvalidZip = "SignatureArchiveIsInvalidZip"),
    (i.SignatureArchiveHasSameSignatureFile =
      "SignatureArchiveHasSameSignatureFile"),
    (i.PackageIntegrityCheckFailed = "PackageIntegrityCheckFailed"),
    (i.SignatureIsInvalid = "SignatureIsInvalid"),
    (i.SignatureManifestIsInvalid = "SignatureManifestIsInvalid"),
    (i.SignatureIntegrityCheckFailed = "SignatureIntegrityCheckFailed"),
    (i.EntryIsMissing = "EntryIsMissing"),
    (i.EntryIsTampered = "EntryIsTampered"),
    (i.Untrusted = "Untrusted"),
    (i.CertificateRevoked = "CertificateRevoked"),
    (i.SignatureIsNotValid = "SignatureIsNotValid"),
    (i.UnknownError = "UnknownError"),
    (i.PackageIsInvalidZip = "PackageIsInvalidZip"),
    (i.SignatureArchiveHasTooManyEntries = "SignatureArchiveHasTooManyEntries")
})(sX || (sX = {}))
var UOt = Y("extensionManagementService"),
  MOt = Y("IGlobalExtensionEnablementService"),
  HOt = Y("IExtensionTipsService"),
  WOt = Y("IAllowedExtensionsService"),
  jOt = fB(1832, "Extensions"),
  VOt = fB(1833, "Preferences"),
  GOt = Y("telemetryService"),
  zOt = Y("customEndpointTelemetryService"),
  aX
;(function (i) {
  ;(i[(i.NONE = 0)] = "NONE"),
    (i[(i.CRASH = 1)] = "CRASH"),
    (i[(i.ERROR = 2)] = "ERROR"),
    (i[(i.USAGE = 3)] = "USAGE")
})(aX || (aX = {}))
var oX
;(function (i) {
  ;(i.OFF = "off"), (i.ON = "all")
})(oX || (oX = {}))
var u2 = class {
    constructor(i) {
      ;(this.value = i), (this.isTrustedTelemetryValue = !0)
    }
  },
  gvt = class {
    constructor() {
      ;(this.telemetryLevel = 0),
        (this.sessionId = "someValue.sessionId"),
        (this.machineId = "someValue.machineId"),
        (this.macMachineId = "someValue.macMachineId"),
        (this.sqmId = "someValue.sqmId"),
        (this.devDeviceId = "someValue.devDeviceId"),
        (this.firstSessionDate = "someValue.firstSessionDate"),
        (this.sendErrorTelemetry = !1)
    }
    registerAuthId() {}
    publicLog() {}
    publicLog2() {}
    publicLogError() {}
    publicLogError2() {}
    publicLogCapture() {}
    setExperimentProperty() {}
  },
  YOt = new gvt(),
  vvt = "extensionTelemetryLog",
  wvt = new Set([
    "ssh-remote",
    "dev-container",
    "attached-container",
    "wsl",
    "tunnel",
    "codespaces",
    "amlext",
  ])
function yvt(i) {
  if (!i) return "none"
  const t = P3(i)
  return wvt.has(t) ? t : "other"
}
function Tvt(i, t) {
  if (!i || (!i.includes("/") && !i.includes("\\"))) return i
  let e = i
  const r = []
  for (const c of t)
    for (;;) {
      const u = c.exec(i)
      if (!u) break
      r.push([u.index, c.lastIndex])
    }
  const s = /^[\\\/]?(node_modules|node_modules\.asar)[\\\/]/,
    a =
      /(file:\/\/)?([a-zA-Z]:(\\\\|\\|\/)|(\\\\|\\|\/))?([\w-\._]+(\\\\|\\|\/))+[\w-\._]*/g
  let o = 0
  for (e = ""; ; ) {
    const c = a.exec(i)
    if (!c) break
    const u = r.some(([l, m]) => c.index < m && l < a.lastIndex)
    !s.test(c[0]) &&
      !u &&
      ((e += i.substring(o, c.index) + "<REDACTED: user-file-path>"),
      (o = a.lastIndex))
  }
  return o < i.length && (e += i.substr(o)), e
}
function kvt(i) {
  if (!i) return i
  const t = [
    { label: "Google API Key", regex: /AIza[A-Za-z0-9_\\\-]{35}/ },
    { label: "Slack Token", regex: /xox[pbar]\-[A-Za-z0-9]/ },
    {
      label: "GitHub Token",
      regex:
        /(gh[psuro]_[a-zA-Z0-9]{36}|github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59})/,
    },
    {
      label: "Generic Secret",
      regex:
        /(key|token|sig|secret|signature|password|passwd|pwd|android:value)[^a-zA-Z0-9]/i,
    },
    {
      label: "CLI Credentials",
      regex:
        /((login|psexec|(certutil|psexec)\.exe).{1,50}(\s-u(ser(name)?)?\s+.{3,100})?\s-(admin|user|vm|root)?p(ass(word)?)?\s+["']?[^$\-\/\s]|(^|[\s\r\n\\])net(\.exe)?.{1,5}(user\s+|share\s+\/user:| user -? secrets ? set) \s + [^ $\s \/])/,
    },
    {
      label: "Microsoft Entra ID",
      regex: /eyJ(?:0eXAiOiJKV1Qi|hbGci|[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.)/,
    },
    { label: "Email", regex: /@[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+/ },
  ]
  for (const e of t) if (e.regex.test(i)) return `<REDACTED: ${e.label}>`
  return i
}
function cX(i, t) {
  return yo(i, (e) => {
    if (
      e instanceof u2 ||
      Object.hasOwnProperty.call(e, "isTrustedTelemetryValue")
    )
      return e.value
    if (typeof e == "string") {
      let r = e.replaceAll("%20", " ")
      r = Tvt(r, t)
      for (const s of t) r = r.replace(s, "")
      return (r = kvt(r)), r
    }
  })
}
var QOt = new te("pprice.better-merge"),
  Svt = class {
    constructor() {
      ;(this.a = new Map()), (this.b = new WeakMap())
    }
    register(i, t) {
      this.a.set(i, t)
    }
    readActivationEvents(i) {
      return this.b.has(i) || this.b.set(i, this.c(i)), this.b.get(i)
    }
    createActivationEventsMap(i) {
      const t = Object.create(null)
      for (const e of i) {
        const r = this.readActivationEvents(e)
        r.length > 0 && (t[te.toKey(e.identifier)] = r)
      }
      return t
    }
    c(i) {
      if (typeof i.main > "u" && typeof i.browser > "u") return []
      const t = Array.isArray(i.activationEvents)
        ? i.activationEvents.slice(0)
        : []
      for (let e = 0; e < t.length; e++)
        t[e] === "onUri" && (t[e] = `onUri:${te.toKey(i.identifier)}`)
      if (!i.contributes) return t
      for (const e in i.contributes) {
        const r = this.a.get(e)
        if (!r) continue
        const s = i.contributes[e],
          a = Array.isArray(s) ? s : [s]
        try {
          r(a, t)
        } catch (o) {
          Ui(o)
        }
      }
      return t
    }
  },
  bvt = new Svt(),
  Evt = Object.freeze({
    identifier: new te("nullExtensionDescription"),
    name: "Null Extension Description",
    version: "0.0.0",
    publisher: "vscode",
    engines: { vscode: "" },
    extensionLocation: S.parse("void:location"),
    isBuiltin: !1,
    targetPlatform: "undefined",
    isUserBuiltin: !1,
    isUnderDevelopment: !1,
    preRelease: !1,
  }),
  XOt = Y("extensionService"),
  uX = class {
    constructor(i) {
      this.dependency = i
    }
  },
  lX
;(function (i) {
  ;(i[(i.EagerAutoStart = 1)] = "EagerAutoStart"),
    (i[(i.EagerManualStart = 2)] = "EagerManualStart"),
    (i[(i.Lazy = 3)] = "Lazy")
})(lX || (lX = {}))
function Qe(i, t) {
  return ((t === "control" || t === "cursor" || t === "cursorNoDeps") &&
    !i.isBuiltin) ||
    !i.enabledApiProposals
    ? !1
    : i.enabledApiProposals.includes(t)
}
function F(i, t) {
  if (!Qe(i, t))
    throw new Error(`Extension '${i.identifier.value}' CANNOT use API proposal: ${t}.
Its package.json#enabledApiProposals-property declares: ${i.enabledApiProposals?.join(", ") ?? "[]"} but NOT ${t}.
 The missing proposal MUST be added and you must start in extension development mode or use the following command line switch: --enable-proposed-api ${i.identifier.value}. Note that the cursor and control proposals are only available for built-in extensions`)
}
var dX
;(function (i) {
  ;(i[(i.Normal = 0)] = "Normal"), (i[(i.Immediate = 1)] = "Immediate")
})(dX || (dX = {}))
var g7 = class Vnt {
    static {
      this.NONE = new Vnt(!1, -1, -1, -1)
    }
    constructor(t, e, r, s) {
      ;(this.startup = t),
        (this.codeLoadingTime = e),
        (this.activateCallTime = r),
        (this.activateResolvedTime = s)
    }
  },
  mX = class {
    constructor(i) {
      ;(this.a = i),
        (this.b = -1),
        (this.c = -1),
        (this.d = -1),
        (this.f = -1),
        (this.g = -1),
        (this.h = -1)
    }
    j(i, t) {
      return i === -1 || t === -1 ? -1 : t - i
    }
    build() {
      return new g7(
        this.a,
        this.j(this.b, this.c),
        this.j(this.d, this.f),
        this.j(this.g, this.h),
      )
    }
    codeLoadingStart() {
      this.b = Date.now()
    }
    codeLoadingStop() {
      this.c = Date.now()
    }
    activateCallStart() {
      this.d = Date.now()
    }
    activateCallStop() {
      this.f = Date.now()
    }
    activateResolveStart() {
      this.g = Date.now()
    }
    activateResolveStop() {
      this.h = Date.now()
    }
  },
  v7 = class {
    constructor(i, t, e, r, s, a) {
      ;(this.activationFailed = i),
        (this.activationFailedError = t),
        (this.activationTimes = e),
        (this.module = r),
        (this.exports = s),
        (this.disposable = a)
    }
  },
  Ivt = class extends v7 {
    constructor(i) {
      super(
        !1,
        null,
        i,
        { activate: void 0, deactivate: void 0 },
        void 0,
        dt.None,
      )
    }
  },
  Pvt = class extends v7 {
    constructor() {
      super(
        !1,
        null,
        g7.NONE,
        { activate: void 0, deactivate: void 0 },
        void 0,
        dt.None,
      )
    }
  },
  w7 = class extends v7 {
    constructor(i) {
      super(
        !0,
        i,
        g7.NONE,
        { activate: void 0, deactivate: void 0 },
        void 0,
        dt.None,
      )
    }
  },
  l2 = class {
    constructor(t, e, r, s) {
      ;(this.g = s),
        (this.a = t),
        (this.b = e),
        (this.c = r),
        (this.d = new bn()),
        (this.f = Object.create(null))
    }
    dispose() {
      for (const [t, e] of this.d) e.dispose()
    }
    async waitForActivatingExtensions() {
      const t = []
      for (const [e, r] of this.d) t.push(r.wait())
      await Promise.all(t)
    }
    isActivated(t) {
      const e = this.d.get(t)
      return !!(e && e.value)
    }
    getActivatedExtension(t) {
      const e = this.d.get(t)
      if (!e || !e.value)
        throw new Error(`Extension '${t.value}' is not known or not activated`)
      return e.value
    }
    async activateByEvent(t, e) {
      if (this.f[t]) return
      const r = this.a.getExtensionDescriptionsForActivationEvent(t)
      await this.h(
        r.map((s) => ({
          id: s.identifier,
          reason: { startup: e, extensionId: s.identifier, activationEvent: t },
        })),
      ),
        (this.f[t] = !0)
    }
    activateById(t, e) {
      const r = this.a.getExtensionDescription(t)
      if (!r) throw new Error(`Extension '${t.value}' is not known`)
      return this.h([{ id: r.identifier, reason: e }])
    }
    async h(t) {
      const e = t.filter((r) => !this.isActivated(r.id)).map((r) => this.j(r))
      await Promise.all(e.map((r) => r.wait()))
    }
    j(t) {
      if (this.d.has(t.id)) return this.d.get(t.id)
      if (this.l(t.id)) return this.k(t, null, [], null)
      const e = this.a.getExtensionDescription(t.id)
      if (!e) {
        const a = new Error(
            `Cannot activate unknown extension '${t.id.value}'`,
          ),
          o = this.k(t, null, [], new w7(a))
        return this.c.onExtensionActivationError(t.id, a, new uX(t.id.value)), o
      }
      const r = [],
        s = typeof e.extensionDependencies > "u" ? [] : e.extensionDependencies
      for (const a of s) {
        if (this.m(a)) continue
        const o = this.d.get(a)
        if (o) {
          r.push(o)
          continue
        }
        if (this.l(a)) {
          r.push(
            this.j({
              id: this.b.getExtensionDescription(a).identifier,
              reason: t.reason,
            }),
          )
          continue
        }
        const c = this.a.getExtensionDescription(a)
        if (c) {
          if (!c.main && !c.browser) continue
          r.push(this.j({ id: c.identifier, reason: t.reason }))
          continue
        }
        const u = e.displayName || e.identifier.value,
          l = new Error(
            `Cannot activate the '${u}' extension because it depends on unknown extension '${a}'`,
          ),
          m = this.k(t, e.displayName, [], new w7(l))
        return this.c.onExtensionActivationError(e.identifier, l, new uX(a)), m
      }
      return this.k(t, e.displayName, r, null)
    }
    k(t, e, r, s) {
      const a = new d2(t.id, e, t.reason, r, s, this.c, this.g)
      return this.d.set(t.id, a), a
    }
    l(t) {
      return Ad.isHostExtension(t, this.a, this.b)
    }
    m(t) {
      const e = this.b.getExtensionDescription(t)
      return e ? !e.main && !e.browser : !1
    }
  }
l2 = __decorate([__param(3, Kt)], l2)
var d2 = class {
  get value() {
    return this.h
  }
  get friendlyName() {
    return this.d || this.c.value
  }
  constructor(t, e, r, s, a, o, c) {
    ;(this.c = t),
      (this.d = e),
      (this.f = r),
      (this.g = s),
      (this.h = a),
      (this.j = o),
      (this.k = c),
      (this.a = new Xr()),
      (this.b = !1),
      this.l()
  }
  dispose() {
    this.b = !0
  }
  wait() {
    return this.a.wait()
  }
  async l() {
    await this.m(), this.a.open()
  }
  async m() {
    if (!this.h) {
      for (; this.g.length > 0; ) {
        for (let t = 0; t < this.g.length; t++) {
          const e = this.g[t]
          if (e.value && !e.value.activationFailed) {
            this.g.splice(t, 1), t--
            continue
          }
          if (e.value && e.value.activationFailed) {
            const r = new Error(
              `Cannot activate the '${this.friendlyName}' extension because its dependency '${e.friendlyName}' failed to activate`,
            )
            ;(r.detail = e.value.activationFailedError),
              (this.h = new w7(r)),
              this.j.onExtensionActivationError(this.c, r, null)
            return
          }
        }
        this.g.length > 0 && (await Promise.race(this.g.map((t) => t.wait())))
      }
      await this.n()
    }
  }
  async n() {
    try {
      this.h = await this.j.actualActivateExtension(this.c, this.f)
    } catch (t) {
      const e = new Error()
      if (
        (t && t.name && (e.name = t.name),
        t && t.message
          ? (e.message = `Activating extension '${this.c.value}' failed: ${t.message}.`)
          : (e.message = `Activating extension '${this.c.value}' failed: ${t}.`),
        t && t.stack && (e.stack = t.stack),
        (this.h = new w7(e)),
        this.b && Xn(t))
      )
        return
      this.j.onExtensionActivationError(this.c, e, null),
        this.k.error(
          `Activating extension ${this.c.value} failed due to an error:`,
        ),
        this.k.error(t)
    }
  }
}
d2 = __decorate([__param(6, Kt)], d2)
var hX = class {
    constructor(i, t) {
      ;(this.c = t),
        (this.b = new C()),
        (this.onDidChangeStorage = this.b.event),
        (this.a = i.getProxy(z.MainThreadStorage))
    }
    registerExtensionStorageKeysToSync(i, t) {
      this.a.$registerExtensionStorageKeysToSync(i, t)
    }
    async initializeExtensionStorage(i, t, e) {
      const r = await this.a.$initializeExtensionStorage(i, t)
      let s
      return r && (s = this.d(i, t, r)), s || e
    }
    setValue(i, t, e) {
      return this.a.$setValue(i, t, e)
    }
    $acceptValue(i, t, e) {
      const r = this.d(i, t, e)
      r && this.b.fire({ shared: i, key: t, value: r })
    }
    d(i, t, e) {
      try {
        return JSON.parse(e)
      } catch (r) {
        this.c.error(
          `[extHostStorage] unexpected error parsing storage contents (extensionId: ${t}, global: ${i}): ${r}`,
        )
      }
    }
  },
  m2 = Y("IExtHostStorage"),
  fX = class {
    constructor(i, t, e) {
      ;(this.h = new Map()),
        (this.a = i),
        (this.b = t),
        (this.c = e),
        (this.d = this.c
          .initializeExtensionStorage(this.b, this.a, Object.create(null))
          .then((r) => ((this.f = r), this))),
        (this.g = this.c.onDidChangeStorage((r) => {
          r.shared === this.b && r.key === this.a && (this.f = r.value)
        })),
        (this.i = new po(() => {
          const r = this.h
          ;(this.h = new Map()),
            (async () => {
              try {
                await this.c.setValue(this.b, this.a, this.f)
                for (const s of r.values()) s.complete()
              } catch (s) {
                for (const a of r.values()) a.error(s)
              }
            })()
        }, 0))
    }
    keys() {
      return Object.entries(this.f ?? {})
        .filter(([, i]) => i !== void 0)
        .map(([i]) => i)
    }
    get whenReady() {
      return this.d
    }
    get(i, t) {
      let e = this.f[i]
      return typeof e > "u" && (e = t), e
    }
    update(i, t) {
      this.f[i] = t
      const e = this.h.get(i)
      if (e !== void 0) return e.p
      const r = new go()
      return this.h.set(i, r), this.i.isScheduled() || this.i.schedule(), r.p
    }
    dispose() {
      this.g.dispose()
    }
  },
  Nvt = class extends fX {
    setKeysForSync(i) {
      this.c.registerExtensionStorageKeysToSync(
        { id: this.a, version: this.j.version },
        i,
      )
    }
    constructor(i, t) {
      super(i.identifier.value, !0, t), (this.j = i)
    }
  },
  cn,
  h2 = (cn = class {
    constructor(t, e) {
      ;(this.b = new Map()),
        (this.c = new wct()),
        (this.a = t.getProxy(z.MainThreadFileSystem))
      const r = this
      this.value = Object.freeze({
        async stat(s) {
          try {
            let a
            const o = r.b.get(s.scheme)
            return (
              o
                ? (await r.a.$ensureActivation(s.scheme),
                  (a = await o.impl.stat(s)))
                : (a = await r.a.$stat(s)),
              {
                type: a.type,
                ctime: a.ctime,
                mtime: a.mtime,
                size: a.size,
                permissions: a.permissions === Eo.Readonly ? 1 : void 0,
              }
            )
          } catch (a) {
            cn.e(a)
          }
        },
        async readDirectory(s) {
          try {
            const a = r.b.get(s.scheme)
            return a
              ? (await r.a.$ensureActivation(s.scheme),
                (await a.impl.readDirectory(s)).slice())
              : await r.a.$readdir(s)
          } catch (a) {
            return cn.e(a)
          }
        },
        async createDirectory(s) {
          try {
            const a = r.b.get(s.scheme)
            return a && !a.isReadonly
              ? (await r.a.$ensureActivation(s.scheme),
                await r.d(a.impl, a.extUri, s))
              : await r.a.$mkdir(s)
          } catch (a) {
            return cn.e(a)
          }
        },
        async readFile(s) {
          try {
            const a = r.b.get(s.scheme)
            return a
              ? (await r.a.$ensureActivation(s.scheme),
                (await a.impl.readFile(s)).slice())
              : (await r.a.$readFile(s)).buffer
          } catch (a) {
            return cn.e(a)
          }
        },
        async writeFile(s, a) {
          try {
            const o = r.b.get(s.scheme)
            return o && !o.isReadonly
              ? (await r.a.$ensureActivation(s.scheme),
                await r.d(o.impl, o.extUri, o.extUri.dirname(s)),
                await r.c.queueFor(s, () =>
                  Promise.resolve(
                    o.impl.writeFile(s, a, { create: !0, overwrite: !0 }),
                  ),
                ))
              : await r.a.$writeFile(s, Et.wrap(a))
          } catch (o) {
            return cn.e(o)
          }
        },
        async delete(s, a) {
          try {
            const o = r.b.get(s.scheme)
            return o && !o.isReadonly && !a?.useTrash
              ? (await r.a.$ensureActivation(s.scheme),
                await o.impl.delete(s, { recursive: !1, ...a }))
              : await r.a.$delete(s, {
                  recursive: !1,
                  useTrash: !1,
                  atomic: !1,
                  ...a,
                })
          } catch (o) {
            return cn.e(o)
          }
        },
        async rename(s, a, o) {
          try {
            return await r.a.$rename(s, a, { overwrite: !1, ...o })
          } catch (c) {
            return cn.e(c)
          }
        },
        async copy(s, a, o) {
          try {
            return await r.a.$copy(s, a, { overwrite: !1, ...o })
          } catch (c) {
            return cn.e(c)
          }
        },
        isWritableFileSystem(s) {
          const a = e.getCapabilities(s)
          if (typeof a == "number") return !(a & 2048)
        },
      })
    }
    async d(t, e, r) {
      const s = []
      for (; !e.isEqual(r, e.dirname(r)); )
        try {
          if (!((await t.stat(r)).type & ua.Directory))
            throw Ue.FileExists(
              `Unable to create folder '${r.scheme === Q.file ? r.fsPath : r.toString(!0)}' that already exists but is not a directory`,
            )
          break
        } catch (a) {
          if (I_(a) !== It.FileNotFound) throw a
          s.push(e.basename(r)), (r = e.dirname(r))
        }
      for (let a = s.length - 1; a >= 0; a--) {
        r = e.joinPath(r, s[a])
        try {
          await t.createDirectory(r)
        } catch (o) {
          if (I_(o) !== It.FileExists) throw o
        }
      }
    }
    static e(t) {
      if (t instanceof Ue) throw t
      if (t instanceof iG)
        switch (t.code) {
          case It.FileExists:
            throw Ue.FileExists(t.message)
          case It.FileNotFound:
            throw Ue.FileNotFound(t.message)
          case It.FileNotADirectory:
            throw Ue.FileNotADirectory(t.message)
          case It.FileIsADirectory:
            throw Ue.FileIsADirectory(t.message)
          case It.NoPermissions:
            throw Ue.NoPermissions(t.message)
          case It.Unavailable:
            throw Ue.Unavailable(t.message)
          default:
            throw new Ue(t.message, t.name)
        }
      if (!(t instanceof Error)) throw new Ue(String(t))
      if (t.name === "ENOPRO" || t.message.includes("ENOPRO"))
        throw Ue.Unavailable(t.message)
      switch (t.name) {
        case It.FileExists:
          throw Ue.FileExists(t.message)
        case It.FileNotFound:
          throw Ue.FileNotFound(t.message)
        case It.FileNotADirectory:
          throw Ue.FileNotADirectory(t.message)
        case It.FileIsADirectory:
          throw Ue.FileIsADirectory(t.message)
        case It.NoPermissions:
          throw Ue.NoPermissions(t.message)
        case It.Unavailable:
          throw Ue.Unavailable(t.message)
        default:
          throw new Ue(t.message, t.name)
      }
    }
    addFileSystemProvider(t, e, r) {
      return (
        this.b.set(t, {
          impl: e,
          extUri: r?.isCaseSensitive ? jt : nct,
          isReadonly: !!r?.isReadonly,
        }),
        it(() => this.b.delete(t))
      )
    }
    getFileSystemProviderExtUri(t) {
      return this.b.get(t)?.extUri ?? jt
    }
  })
h2 = cn = __decorate([__param(0, Vt), __param(1, To)], h2)
var y7 = Y("IExtHostConsumerFileSystem"),
  f2 = Y("IExtensionStoragePaths"),
  p2 = class {
    constructor(t, e, r) {
      ;(this.d = e),
        (this.f = r),
        (this.a = t.workspace ?? void 0),
        (this.b = t.environment),
        (this.whenReady = this.h().then((s) => (this.c = s)))
    }
    async g(t) {
      return S.joinPath(this.b.workspaceStorageHome, t)
    }
    async h() {
      if (!this.a) return Promise.resolve(void 0)
      const t = this.a.id,
        e = await this.g(t)
      try {
        return (
          await this.f.value.stat(e),
          this.d.trace("[ExtHostStorage] storage dir already exists", e),
          e
        )
      } catch {}
      try {
        return (
          this.d.trace("[ExtHostStorage] creating dir and metadata-file", e),
          await this.f.value.createDirectory(e),
          await this.f.value.writeFile(
            S.joinPath(e, "meta.json"),
            new TextEncoder().encode(
              JSON.stringify(
                {
                  id: this.a.id,
                  configuration: S.revive(this.a.configuration)?.toString(),
                  name: this.a.name,
                },
                void 0,
                2,
              ),
            ),
          ),
          e
        )
      } catch (r) {
        this.d.error("[ExtHostStorage]", r)
        return
      }
    }
    workspaceValue(t) {
      if (this.c) return S.joinPath(this.c, t.identifier.value)
    }
    globalValue(t) {
      return S.joinPath(
        this.b.globalStorageHome,
        t.identifier.value.toLowerCase(),
      )
    }
    onWillDeactivateAll() {}
  }
p2 = __decorate([__param(0, ci), __param(1, Kt), __param(2, y7)], p2)
var iqt = Y("tunnelService"),
  rqt = Y("sharedTunnelsService"),
  pX
;(function (i) {
  ;(i.Http = "http"), (i.Https = "https")
})(pX || (pX = {}))
var _a
;(function (i) {
  ;(i.ConstantPrivate = "constantPrivate"),
    (i.Private = "private"),
    (i.Public = "public")
})(_a || (_a = {}))
var gX
;(function (i) {
  ;(i[(i.Notify = 1)] = "Notify"),
    (i[(i.OpenBrowser = 2)] = "OpenBrowser"),
    (i[(i.OpenPreview = 3)] = "OpenPreview"),
    (i[(i.Silent = 4)] = "Silent"),
    (i[(i.Ignore = 5)] = "Ignore"),
    (i[(i.OpenBrowserOnce = 6)] = "OpenBrowserOnce")
})(gX || (gX = {}))
function $vt(i) {
  if (i.scheme !== "http" && i.scheme !== "https") return
  const t = /^(localhost|127\.0\.0\.1|0\.0\.0\.0):(\d+)$/.exec(i.authority)
  if (t) return { address: t[1], port: +t[2] }
}
var g2 = ["localhost", "127.0.0.1", "0:0:0:0:0:0:0:1", "::1"]
function vX(i) {
  return g2.indexOf(i) >= 0
}
var v2 = ["0.0.0.0", "0:0:0:0:0:0:0:0", "::"]
function wX(i) {
  return v2.indexOf(i) >= 0
}
var xvt = class {
    constructor(i, t, e) {
      ;(this.remoteAddress = i),
        (this.localAddress = t),
        (this.b = e),
        (this.a = new C()),
        (this.onDidDispose = this.a.event)
    }
    dispose() {
      return this.a.fire(), this.b()
    }
  },
  yX = class extends dt {
    constructor(t, e) {
      super(),
        (this.q = t),
        (this.r = e),
        (this.a = new C()),
        (this.onTunnelOpened = this.a.event),
        (this.b = new C()),
        (this.onTunnelClosed = this.b.event),
        (this.c = new C()),
        (this.onAddedTunnelProvider = this.c.event),
        (this.f = new Map()),
        (this.h = !1),
        (this.j = !0),
        (this.m = []),
        (this.n = new Set())
    }
    get hasTunnelProvider() {
      return !!this.g
    }
    get s() {
      const t = this.r.getValue("remote.localPortHost")
      return !t || t === "localhost" ? "127.0.0.1" : "0.0.0.0"
    }
    setTunnelProvider(t) {
      return (
        (this.g = t),
        t
          ? (this.c.fire(),
            {
              dispose: () => {
                ;(this.g = void 0), (this.h = !1), (this.m = [])
              },
            })
          : ((this.h = !1), (this.m = []), this.c.fire(), { dispose: () => {} })
      )
    }
    setTunnelFeatures(t) {
      ;(this.h = t.elevation),
        (this.m = t.privacyOptions),
        (this.j = t.protocol)
    }
    get canChangeProtocol() {
      return this.j
    }
    get canElevate() {
      return this.h
    }
    get canChangePrivacy() {
      return this.m.length > 0
    }
    get privacyOptions() {
      return this.m
    }
    get tunnels() {
      return this.t()
    }
    async t() {
      const t = [],
        e = Array.from(this.f.values())
      for (const r of e) {
        const s = Array.from(r.values())
        for (const a of s) {
          const o = await a.value
          o && typeof o != "string" && t.push(o)
        }
      }
      return t
    }
    async dispose() {
      super.dispose()
      for (const t of this.f.values()) {
        for (const { value: e } of t.values())
          await e.then((r) => (typeof r != "string" ? r?.dispose() : void 0))
        t.clear()
      }
      this.f.clear()
    }
    setEnvironmentTunnel(t, e, r, s, a) {
      this.y(
        t,
        e,
        Promise.resolve({
          tunnelRemoteHost: t,
          tunnelRemotePort: e,
          localAddress: r,
          privacy: s,
          protocol: a,
          dispose: () => Promise.resolve(),
        }),
      )
    }
    async getExistingTunnel(t, e) {
      ;(wX(t) || vX(t)) && (t = g2[0])
      const r = this.C(t, e)
      if (r) return ++r.refcount, r.value
    }
    openTunnel(t, e, r, s, a, o = !1, c, u) {
      this.q.trace(
        `ForwardedPorts: (TunnelService) openTunnel request for ${e}:${r} on local port ${a}.`,
      )
      const l = this.g ?? t
      if (!l) return
      if (
        (e || (e = "localhost"), s || (s = this.s), this.g && this.n.has(r))
      ) {
        this.q.debug(
          "ForwardedPorts: (TunnelService) Another call to create a tunnel with the same address has occurred before the last one completed. This call will be ignored.",
        )
        return
      }
      const m = this.F(l, e, r, s, a, o, c, u)
      return m
        ? m.then((h) => {
            if (h) {
              if (typeof h == "string")
                return (
                  this.q.trace(
                    "ForwardedPorts: (TunnelService) The tunnel provider returned an error when creating the tunnel.",
                  ),
                  this.z(e, r),
                  h
                )
            } else {
              this.q.trace(
                "ForwardedPorts: (TunnelService) New tunnel is undefined.",
              ),
                this.z(e, r)
              return
            }
            this.q.trace(
              "ForwardedPorts: (TunnelService) New tunnel established.",
            )
            const p = this.u(h)
            return (
              (h.tunnelRemoteHost !== e || h.tunnelRemotePort !== r) &&
                this.q.warn(
                  "ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Host or port mismatch.",
                ),
              c &&
                h.privacy !== c &&
                this.q.warn(
                  "ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Privacy mismatch.",
                ),
              this.a.fire(p),
              p
            )
          })
        : (this.q.trace(
            "ForwardedPorts: (TunnelService) Tunnel was not created.",
          ),
          m)
    }
    u(t) {
      return {
        tunnelRemotePort: t.tunnelRemotePort,
        tunnelRemoteHost: t.tunnelRemoteHost,
        tunnelLocalPort: t.tunnelLocalPort,
        localAddress: t.localAddress,
        privacy: t.privacy,
        protocol: t.protocol,
        dispose: async () => {
          this.q.trace(
            `ForwardedPorts: (TunnelService) dispose request for ${t.tunnelRemoteHost}:${t.tunnelRemotePort} `,
          )
          const e = this.f.get(t.tunnelRemoteHost)
          if (e) {
            const r = e.get(t.tunnelRemotePort)
            r &&
              (r.refcount--,
              await this.w(t.tunnelRemoteHost, t.tunnelRemotePort, r))
          }
        },
      }
    }
    async w(t, e, r) {
      if (r.refcount <= 0) {
        this.q.trace(
          `ForwardedPorts: (TunnelService) Tunnel is being disposed ${t}:${e}.`,
        )
        const s = r.value.then(async (a) => {
          a &&
            typeof a != "string" &&
            (await a.dispose(!0),
            this.b.fire({ host: a.tunnelRemoteHost, port: a.tunnelRemotePort }))
        })
        return this.f.has(t) && this.f.get(t).delete(e), s
      }
    }
    async closeTunnel(t, e) {
      this.q.trace(
        `ForwardedPorts: (TunnelService) close request for ${t}:${e} `,
      )
      const r = this.f.get(t)
      if (r && r.has(e)) {
        const s = r.get(e)
        ;(s.refcount = 0), await this.w(t, e, s)
      }
    }
    y(t, e, r) {
      this.f.has(t) || this.f.set(t, new Map()),
        this.f.get(t).set(e, { refcount: 1, value: r })
    }
    async z(t, e) {
      const r = this.f.get(t)
      if (r) {
        const s = r.get(e),
          a = s ? await s.value : void 0
        ;(!a || typeof a == "string") && r.delete(e),
          r.size === 0 && this.f.delete(t)
      }
    }
    C(t, e) {
      const r = [t]
      vX(t) ? (r.push(...g2), r.push(...v2)) : wX(t) && r.push(...v2)
      const s = r.map((a) => this.f.get(a))
      for (const a of s) {
        const o = a?.get(e)
        if (o) return o
      }
    }
    canTunnel(t) {
      return !!$vt(t)
    }
    G(t, e, r, s, a, o, c) {
      this.q.trace(
        `ForwardedPorts: (TunnelService) Creating tunnel with provider ${e}:${r} on local port ${s}.`,
      )
      const u = r
      this.n.add(u)
      const l = s === void 0 ? r : s,
        m = { elevationRequired: a ? this.isPortPrivileged(l) : !1 },
        h = {
          remoteAddress: { host: e, port: r },
          localAddressPort: s,
          privacy: o,
          public: o ? o !== _a.Private : void 0,
          protocol: c,
        },
        p = t.forwardPort(h, m)
      return (
        p
          ? (this.y(e, r, p),
            p.finally(() => {
              this.q.trace(
                "ForwardedPorts: (TunnelService) Tunnel created by provider.",
              ),
                this.n.delete(u)
            }))
          : this.n.delete(u),
        p
      )
    }
  }
yX = __decorate([__param(0, Kt), __param(1, $_)], yX)
var Jvt = class extends xvt {},
  w2
;(function (i) {
  function t(r) {
    return {
      remoteAddress: r.remoteAddress,
      localAddress: r.localAddress,
      public: !!r.public,
      privacy: r.privacy ?? (r.public ? _a.Public : _a.Private),
      protocol: r.protocol,
    }
  }
  i.fromApiTunnel = t
  function e(r) {
    return {
      remoteAddress: { host: r.tunnelRemoteHost, port: r.tunnelRemotePort },
      localAddress: r.localAddress,
      public:
        r.privacy !== _a.ConstantPrivate && r.privacy !== _a.ConstantPrivate,
      privacy: r.privacy,
      protocol: r.protocol,
    }
  }
  i.fromServiceTunnel = e
})(w2 || (w2 = {}))
var y2 = Y("IExtHostTunnelService"),
  T2 = class extends dt {
    constructor(t, e, r) {
      super(),
        (this.r = r),
        (this.f = () => Promise.resolve(!0)),
        (this.g = new Map()),
        (this.h = new C()),
        (this.onDidChangeTunnels = this.h.event),
        (this.n = 0),
        (this.q = new Map()),
        (this.a = t.getProxy(z.MainThreadTunnelService))
    }
    async openTunnel(t, e) {
      this.r.trace(
        `ForwardedPorts: (ExtHostTunnelService) ${t.identifier.value} called openTunnel API for ${e.remoteAddress.host}:${e.remoteAddress.port}.`,
      )
      const r = await this.a.$openTunnel(e, t.displayName)
      if (r) {
        const s = new Jvt(r.remoteAddress, r.localAddress, () =>
          this.a.$closeTunnel(r.remoteAddress),
        )
        return this.D(s), s
      }
    }
    async getTunnels() {
      return this.a.$getTunnels()
    }
    s() {
      return this.n++
    }
    registerPortsAttributesProvider(t, e) {
      t.portRange === void 0 &&
        t.commandPattern === void 0 &&
        this.r.error(
          "PortAttributesProvider must specify either a portRange or a commandPattern",
        )
      const r = this.s()
      return (
        this.q.set(r, { selector: t, provider: e }),
        this.a.$registerPortsAttributesProvider(t, r),
        new At(() => {
          this.q.delete(r), this.a.$unregisterPortsAttributesProvider(r)
        })
      )
    }
    async $providePortAttributes(t, e, r, s, a) {
      const o = []
      for (const u of t) {
        const l = this.q.get(u)
        if (!l) return []
        o.push(
          ...(await Promise.all(
            e.map(async (m) => {
              let h
              try {
                h = await l.provider.providePortAttributes(
                  { port: m, pid: r, commandLine: s },
                  a,
                )
              } catch {
                h = await l.provider.providePortAttributes(m, r, s, a)
              }
              return { providedAttributes: h, port: m }
            }),
          )),
        )
      }
      const c = o.filter((u) => !!u.providedAttributes)
      return c.length > 0
        ? c.map((u) => ({
            autoForwardAction: u.providedAttributes.autoForwardAction,
            port: u.port,
          }))
        : []
    }
    async $registerCandidateFinder(t) {}
    registerTunnelProvider(t, e) {
      if (this.b)
        throw new Error(
          "A tunnel provider has already been registered. Only the first tunnel provider to be registered will be used.",
        )
      this.b = async (s, a) => (await t.provideTunnel(s, a, fe.None)) ?? void 0
      const r = e.tunnelFeatures
        ? {
            elevation: !!e.tunnelFeatures?.elevation,
            privacyOptions: e.tunnelFeatures?.privacyOptions,
            protocol:
              e.tunnelFeatures.protocol === void 0
                ? !0
                : e.tunnelFeatures.protocol,
          }
        : void 0
      return (
        this.a.$setTunnelProvider(r, !0),
        Promise.resolve(
          it(() => {
            ;(this.b = void 0), this.a.$setTunnelProvider(void 0, !1)
          }),
        )
      )
    }
    async setTunnelFactory(t, e) {
      if (t) {
        t.candidatePortSource !== void 0 &&
          this.a.$setCandidatePortSource(t.candidatePortSource),
          t.showCandidatePort &&
            ((this.f = t.showCandidatePort), this.a.$setCandidateFilter())
        const r = t.tunnelFactory ?? (e ? this.u(e) : void 0)
        if (r) {
          this.b = r
          let s = t.tunnelFeatures?.privacyOptions ?? []
          t.tunnelFeatures?.public &&
            s.length === 0 &&
            (s = [
              { id: "private", label: f(2773, null), themeIcon: "lock" },
              { id: "public", label: f(2774, null), themeIcon: "eye" },
            ])
          const a = t.tunnelFeatures
            ? {
                elevation: !!t.tunnelFeatures?.elevation,
                public: !!t.tunnelFeatures?.public,
                privacyOptions: s,
                protocol: !0,
              }
            : void 0
          this.a.$setTunnelProvider(a, !!t.tunnelFactory)
        }
      } else this.b = void 0
      return it(() => {
        this.b = void 0
      })
    }
    u(t) {}
    async $closeTunnel(t, e) {
      if (this.g.has(t.host)) {
        const r = this.g.get(t.host)
        r.has(t.port) &&
          (e && r.get(t.port).disposeListener.dispose(),
          await r.get(t.port).tunnel.dispose(),
          r.delete(t.port))
      }
    }
    async $onDidTunnelsChange() {
      this.h.fire()
    }
    async $forwardPort(t, e) {
      if (this.b)
        try {
          this.r.trace(
            "ForwardedPorts: (ExtHostTunnelService) Getting tunnel from provider.",
          )
          const r = this.b(t, e)
          if (
            (this.r.trace(
              "ForwardedPorts: (ExtHostTunnelService) Got tunnel promise from provider.",
            ),
            r !== void 0)
          ) {
            const s = await r
            if (
              (this.r.trace(
                "ForwardedPorts: (ExtHostTunnelService) Successfully awaited tunnel from provider.",
              ),
              s === void 0)
            ) {
              this.r.error(
                "ForwardedPorts: (ExtHostTunnelService) Resolved tunnel is undefined",
              )
              return
            }
            this.g.has(t.remoteAddress.host) ||
              this.g.set(t.remoteAddress.host, new Map())
            const a = this.D(
              s.onDidDispose(
                () => (
                  this.r.trace(
                    "ForwardedPorts: (ExtHostTunnelService) Extension fired tunnel's onDidDispose.",
                  ),
                  this.a.$closeTunnel(s.remoteAddress)
                ),
              ),
            )
            return (
              this.g
                .get(t.remoteAddress.host)
                .set(t.remoteAddress.port, { tunnel: s, disposeListener: a }),
              w2.fromApiTunnel(s)
            )
          } else
            this.r.trace(
              "ForwardedPorts: (ExtHostTunnelService) Tunnel is undefined",
            )
        } catch (r) {
          if (
            (this.r.trace(
              "ForwardedPorts: (ExtHostTunnelService) tunnel provider error",
            ),
            r instanceof Error)
          )
            return r.message
        }
    }
    async $applyCandidateFilter(t) {
      const e = await Promise.all(
          t.map((s) => this.f(s.host, s.port, s.detail ?? "")),
        ),
        r = t.filter((s, a) => e[a])
      return (
        this.r.trace(
          `ForwardedPorts: (ExtHostTunnelService) filtered from ${t.map((s) => s.port).join(", ")} to ${r.map((s) => s.port).join(", ")}`,
        ),
        r
      )
    }
  }
T2 = __decorate([__param(0, Vt), __param(1, ci), __param(2, Kt)], T2)
function Cvt(i) {
  return [...i.entries()]
}
function Lvt(i) {
  return i ? [...i.entries()] : []
}
var Rvt = class {
    constructor(i) {
      ;(this.b = i), (this.a = new Map())
    }
    dispose() {
      for (const i of this.a.values()) i.dispose()
    }
    startBuffering(i, t, e = 5) {
      const r = t((s) => {
        const a = typeof s == "string" ? s : s.data
        let o = this.a.get(i)
        if (o) {
          o.data.push(a)
          return
        }
        const c = setTimeout(() => this.flushBuffer(i), e)
        ;(o = {
          data: [a],
          timeoutId: c,
          dispose: () => {
            clearTimeout(c), this.flushBuffer(i), r.dispose()
          },
        }),
          this.a.set(i, o)
      })
      return r
    }
    stopBuffering(i) {
      this.a.get(i)?.dispose()
    }
    flushBuffer(i) {
      const t = this.a.get(i)
      t && (this.a.delete(i), this.b(i, t.data.join("")))
    }
  },
  Aa = (i, t, e, r) => {
    let s = t
    return {
      enumerable: !0,
      configurable: !1,
      get() {
        return s
      },
      set(a) {
        if (!e(s, a)) {
          const o = s
          ;(s = a), i.listener?.(r(a, o))
        }
      },
    }
  },
  Ec = (i, t) => i === t,
  Ds = {
    range: (i, t) => (i === t ? !0 : !i || !t ? !1 : i.isEqual(t)),
    label: Ec,
    description: Ec,
    sortText: Ec,
    busy: Ec,
    error: Ec,
    canResolveChildren: Ec,
    tags: (i, t) =>
      !(i.length !== t.length || i.some((e) => !t.find((r) => e.id === r.id))),
  },
  Ic = (i) => (t) => ({ op: 4, update: i(t) }),
  Dvt = (i, t) => ({
    range: (() => {
      let e
      const r = Ic((s) => ({ range: re.lift(O.from(s)) }))
      return {
        enumerable: !0,
        configurable: !1,
        get() {
          return e
        },
        set(s) {
          i.listener?.({ op: 6 }),
            Ds.range(e, s) || ((e = s), i.listener?.(r(s)))
        },
      }
    })(),
    label: Aa(
      i,
      t,
      Ds.label,
      Ic((e) => ({ label: e })),
    ),
    description: Aa(
      i,
      void 0,
      Ds.description,
      Ic((e) => ({ description: e })),
    ),
    sortText: Aa(
      i,
      void 0,
      Ds.sortText,
      Ic((e) => ({ sortText: e })),
    ),
    canResolveChildren: Aa(i, !1, Ds.canResolveChildren, (e) => ({
      op: 2,
      state: e,
    })),
    busy: Aa(
      i,
      !1,
      Ds.busy,
      Ic((e) => ({ busy: e })),
    ),
    error: Aa(
      i,
      void 0,
      Ds.error,
      Ic((e) => ({ error: Jt.fromStrict(e) || null })),
    ),
    tags: Aa(i, [], Ds.tags, (e, r) => ({
      op: 1,
      new: e.map(Lr.from),
      old: r.map(Lr.from),
    })),
  }),
  Fvt = (i) => {
    const t = Ot.fromString(i.extId),
      e = new Bd(t.controllerId, t.localId, i.label, S.revive(i.uri) || void 0)
    return (
      (e.range = O.to(i.range || void 0)),
      (e.description = i.description || void 0),
      (e.sortText = i.sortText || void 0),
      (e.tags = i.tags.map((r) => Lr.to({ id: Nz(r).tagId }))),
      e
    )
  },
  TX = (i) => {
    let t
    for (const e of i.tests) {
      const r = Fvt(e.item)
      ;(e6(r).parent = t), (t = r)
    }
    return t
  },
  Bd = class Gnt {
    constructor(t, e, r, s) {
      if (e.includes("\0"))
        throw new Error(
          `Test IDs may not include the ${JSON.stringify(e)} symbol`,
        )
      const a = gmt(this, t)
      Object.defineProperties(this, {
        id: { value: e, enumerable: !0, writable: !1 },
        uri: { value: s, enumerable: !0, writable: !1 },
        parent: {
          enumerable: !1,
          get() {
            return a.parent instanceof k2 ? void 0 : a.parent
          },
        },
        children: { value: pmt(a, e6, Gnt), enumerable: !0, writable: !1 },
        ...Dvt(a, r),
      })
    }
  },
  k2 = class extends Bd {
    constructor(i, t) {
      super(i, i, t, void 0), (this._isRoot = !0)
    }
  },
  _vt = class extends mmt {
    constructor(i, t, e) {
      super({
        controllerId: i,
        getDocumentVersion: (r) => r && e.getDocument(r)?.version,
        getApiFor: e6,
        getChildren: (r) => r.children,
        root: new k2(i, t),
        toITestItem: Ss.from,
      })
    }
  },
  S2 = class extends dt {
    constructor(t, e) {
      super(),
        (this.r = t),
        (this.s = e),
        (this.a = this.D(new C())),
        (this.onDidChangeTelemetryEnabled = this.a.event),
        (this.b = this.D(new C())),
        (this.onDidChangeTelemetryConfiguration = this.b.event),
        (this.c = { usage: !0, error: !0 }),
        (this.f = 0),
        (this.g = !1),
        (this.j = !1),
        (this.q = new Map()),
        (this.m = S.revive(this.r.environment.extensionTelemetryLogResource)),
        (this.j = this.r.environment.isExtensionTelemetryLoggingOnly),
        (this.n = e.createLogger(this.m, {
          id: vvt,
          name: f(2770, null, this.j ? " (Not Sent)" : ""),
          hidden: !0,
        })),
        this.D(this.n),
        this.D(
          e.onDidChangeLogLevel((r) => {
            Yct(r) && this.t()
          }),
        ),
        this.n.info(
          "Below are logs for extension telemetry events sent to the telemetry output channel API once the log level is set to trace.",
        ),
        this.n.info(
          "===========================================================",
        )
    }
    t() {
      this.s.setVisibility(this.m, this.g && this.s.getLogLevel() === Mt.Trace)
    }
    getTelemetryConfiguration() {
      return this.f === 3
    }
    getTelemetryDetails() {
      return {
        isCrashEnabled: this.f >= 1,
        isErrorsEnabled: this.c.error ? this.f >= 2 : !1,
        isUsageEnabled: this.c.usage ? this.f >= 3 : !1,
      }
    }
    instantiateLogger(t, e, r) {
      const s = this.getTelemetryDetails(),
        a = new kX(
          e,
          r,
          t,
          this.n,
          this.j,
          this.getBuiltInCommonProperties(t),
          {
            isUsageEnabled: s.isUsageEnabled,
            isErrorsEnabled: s.isErrorsEnabled,
          },
        ),
        o = this.q.get(t.identifier.value) ?? []
      return this.q.set(t.identifier.value, [...o, a]), a.apiTelemetryLogger
    }
    $initializeTelemetryLevel(t, e, r) {
      ;(this.f = t),
        (this.g = e),
        (this.c = r ?? { usage: !0, error: !0 }),
        this.t()
    }
    getBuiltInCommonProperties(t) {
      const e = Object.create(null)
      switch (
        ((e["common.extname"] = `${t.publisher}.${t.name}`),
        (e["common.extversion"] = t.version),
        (e["common.vscodemachineid"] = this.r.telemetryInfo.machineId),
        (e["common.vscodesessionid"] = this.r.telemetryInfo.sessionId),
        (e["common.macMachineId"] = this.r.telemetryInfo.macMachineId),
        (e["common.sqmid"] = this.r.telemetryInfo.sqmId),
        (e["common.devDeviceId"] = this.r.telemetryInfo.devDeviceId),
        (e["common.vscodeversion"] = this.r.version),
        (e["common.isnewappinstall"] = SX(
          this.r.telemetryInfo.firstSessionDate,
        )),
        (e["common.product"] = this.r.environment.appHost),
        this.r.uiKind)
      ) {
        case Pu.Web:
          e["common.uikind"] = "web"
          break
        case Pu.Desktop:
          e["common.uikind"] = "desktop"
          break
        default:
          e["common.uikind"] = "unknown"
      }
      return (e["common.remotename"] = P3(yvt(this.r.remote.authority))), e
    }
    $onDidChangeTelemetryLevel(t) {
      ;(this.h = this.getTelemetryConfiguration()), (this.f = t)
      const e = this.getTelemetryDetails()
      this.q.forEach((r, s) => {
        const a = r.filter((o) => !o.isDisposed)
        a.length === 0 ? this.q.delete(s) : this.q.set(s, a)
      }),
        this.q.forEach((r) => {
          for (const s of r)
            s.updateTelemetryEnablements(e.isUsageEnabled, e.isErrorsEnabled)
        }),
        this.h !== this.getTelemetryConfiguration() &&
          this.a.fire(this.getTelemetryConfiguration()),
        this.b.fire(this.getTelemetryDetails()),
        this.t()
    }
    onExtensionError(t, e) {
      const s = this.q.get(t.value)?.filter((o) => !o.isDisposed)
      if (!s) return this.q.delete(t.value), !1
      let a = !1
      for (const o of s)
        o.ignoreUnhandledExtHostErrors || (o.logError(e), (a = !0))
      return a
    }
  }
S2 = __decorate([__param(0, ci), __param(1, Hu)], S2)
var kX = class {
  static validateSender(i) {
    if (typeof i != "object")
      throw new TypeError("TelemetrySender argument is invalid")
    if (typeof i.sendEventData != "function")
      throw new TypeError("TelemetrySender.sendEventData must be a function")
    if (typeof i.sendErrorData != "function")
      throw new TypeError("TelemetrySender.sendErrorData must be a function")
    if (typeof i.flush < "u" && typeof i.flush != "function")
      throw new TypeError(
        "TelemetrySender.flush must be a function or undefined",
      )
  }
  constructor(i, t, e, r, s, a, o) {
    ;(this.g = e),
      (this.h = r),
      (this.i = s),
      (this.j = a),
      (this.a = new C()),
      (this.ignoreUnhandledExtHostErrors = t?.ignoreUnhandledErrors ?? !1),
      (this.b = t?.ignoreBuiltInCommonProperties ?? !1),
      (this.c = t?.additionalCommonProperties),
      (this.f = i),
      (this.d = {
        isUsageEnabled: o.isUsageEnabled,
        isErrorsEnabled: o.isErrorsEnabled,
      })
  }
  updateTelemetryEnablements(i, t) {
    this.e &&
      ((this.d = { isUsageEnabled: i, isErrorsEnabled: t }),
      this.a.fire(this.e))
  }
  mixInCommonPropsAndCleanData(i) {
    let t = "properties" in i ? (i.properties ?? {}) : i
    return (
      (t = cX(t, [])),
      this.c && (t = ra(t, this.c)),
      this.b || (t = ra(t, this.j)),
      "properties" in i ? (i.properties = t) : (i = t),
      i
    )
  }
  k(i, t) {
    this.f &&
      (this.g.publisher === "vscode"
        ? (i = this.g.name + "/" + i)
        : (i = this.g.identifier.value + "/" + i),
      (t = this.mixInCommonPropsAndCleanData(t || {})),
      this.i || this.f?.sendEventData(i, t),
      this.h.trace(i, t))
  }
  logUsage(i, t) {
    this.d.isUsageEnabled && this.k(i, t)
  }
  logError(i, t) {
    if (!(!this.d.isErrorsEnabled || !this.f))
      if (typeof i == "string") this.k(i, t)
      else {
        const e = {
            name: i.name,
            message: i.message,
            stack: i.stack,
            cause: i.cause,
          },
          r = cX(e, []),
          s = new Error(r.message, { cause: r.cause })
        ;(s.stack = r.stack),
          (s.name = r.name),
          (t = this.mixInCommonPropsAndCleanData(t || {})),
          this.i || this.f.sendErrorData(s, t),
          this.h.trace("exception", t)
      }
  }
  get apiTelemetryLogger() {
    if (!this.e) {
      const i = this,
        t = {
          logUsage: i.logUsage.bind(i),
          get isUsageEnabled() {
            return i.d.isUsageEnabled
          },
          get isErrorsEnabled() {
            return i.d.isErrorsEnabled
          },
          logError: i.logError.bind(i),
          dispose: i.dispose.bind(i),
          onDidChangeEnableStates: i.a.event.bind(i),
        }
      this.e = Object.freeze(t)
    }
    return this.e
  }
  get isDisposed() {
    return !this.f
  }
  dispose() {
    if (this.f?.flush) {
      let i = this.f
      ;(this.f = void 0),
        Promise.resolve(i.flush()).then((i = void 0)),
        (this.e = void 0)
    } else this.f = void 0
  }
}
function SX(i) {
  const t = Date.now() - new Date(i).getTime()
  return isNaN(t) ? !1 : t < 1e3 * 60 * 60 * 24
}
var T7 = Y("IExtHostTelemetry"),
  b2 = class {
    #t
    #e
    #i
    constructor(t, e, r) {
      ;(this.b = new Map()),
        (this.c = new Map()),
        (this.#t = t.getProxy(z.MainThreadCommands)),
        (this.d = e),
        (this.#i = r),
        (this.#e = t.getProxy(z.MainThreadTelemetry)),
        (this.converter = new Avt(
          this,
          (s) => {
            const a = this.c.get(s)
            return a?.result === ht.Void ? a : void 0
          },
          e,
        )),
        (this.f = [
          {
            processArgument(s) {
              return $i(s)
            },
          },
          {
            processArgument(s) {
              return yo(s, function (a) {
                if (re.isIRange(a)) return O.to(a)
                if (tr.isIPosition(a)) return Gt.to(a)
                if (re.isIRange(a.range) && S.isUri(a.uri)) return Ri.to(a)
                if (a instanceof Et) return a.buffer.buffer
                if (!Array.isArray(a)) return a
              })
            },
          },
        ])
    }
    registerArgumentProcessor(t) {
      this.f.push(t)
    }
    registerApiCommand(t) {
      const e = this.registerCommand(
        !1,
        t.id,
        async (...r) => {
          const s = t.args.map((o, c) => {
              if (!o.validate(r[c]))
                throw new Error(
                  `Invalid argument '${o.name}' when running '${t.id}', received: ${typeof r[c] == "object" ? JSON.stringify(r[c], null, "	") : r[c]} `,
                )
              return o.convert(r[c])
            }),
            a = await this.executeCommand(t.internalId, ...s)
          return t.result.convert(a, r, this.converter)
        },
        void 0,
        {
          description: t.description,
          args: t.args,
          returns: t.result.description,
        },
      )
      return (
        this.c.set(t.id, t),
        new At(() => {
          e.dispose(), this.c.delete(t.id)
        })
      )
    }
    registerCommand(t, e, r, s, a, o) {
      if (
        (this.d.trace("ExtHostCommands#registerCommand", e), !e.trim().length)
      )
        throw new Error("invalid id")
      if (this.b.has(e)) throw new Error(`command '${e}' already exists`)
      return (
        this.b.set(e, { callback: r, thisArg: s, metadata: a, extension: o }),
        t && this.#t.$registerCommand(e),
        new At(() => {
          this.b.delete(e) && t && this.#t.$unregisterCommand(e)
        })
      )
    }
    executeCommand(t, ...e) {
      return this.d.trace("ExtHostCommands#executeCommand", t), this.g(t, e, !0)
    }
    async g(t, e, r) {
      if (this.b.has(t))
        return this.#t.$fireCommandActivationEvent(t), this.h(t, e, !1)
      {
        let s = !1
        const a = yo(e, function (o) {
          if (o instanceof Lt) return Gt.from(o)
          if (o instanceof Nt) return O.from(o)
          if (o instanceof er) return Ri.from(o)
          if ($n.isNotebookRange(o)) return an.from(o)
          if (o instanceof ArrayBuffer)
            return (s = !0), Et.wrap(new Uint8Array(o))
          if (o instanceof Uint8Array) return (s = !0), Et.wrap(o)
          if (o instanceof Et) return (s = !0), o
          if (!Array.isArray(o)) return o
        })
        try {
          const o = await this.#t.$executeCommand(t, s ? new Xi(a) : a, r)
          return $i(o)
        } catch (o) {
          if (o instanceof Error && o.message === "$executeCommand:retry")
            return this.g(t, e, !1)
          throw o
        }
      }
    }
    async h(t, e, r) {
      const s = this.b.get(t)
      if (!s) throw new Error("Unknown command")
      const { callback: a, thisArg: o, metadata: c } = s
      if (c?.args)
        for (let l = 0; l < c.args.length; l++)
          try {
            Mot(e[l], c.args[l].constraint)
          } catch {
            throw new Error(
              `Running the contributed command: '${t}' failed. Illegal argument '${c.args[l].name}' - ${c.args[l].description}`,
            )
          }
      const u = Ys.create()
      try {
        return await a.apply(o, e)
      } catch (l) {
        if (t === this.converter.delegatingCommandId) {
          const m = this.converter.getActualCommand(...e)
          m && (t = m.command)
        }
        if ((this.d.error(l, t, s.extension?.identifier), !r)) throw l
        if (s.extension?.identifier) {
          const m = this.#i.onExtensionError(s.extension.identifier, l)
          this.d.trace(
            "forwarded error to extension?",
            m,
            s.extension?.identifier,
          )
        }
        throw new (class extends Error {
          constructor() {
            super(ea(l)),
              (this.id = t),
              (this.source = s.extension?.displayName ?? s.extension?.name)
          }
        })()
      } finally {
        this.j(s, t, u.elapsed())
      }
    }
    j(t, e, r) {
      t.extension &&
        this.#e.$publicLog2("Extension:ActionExecuted", {
          extensionId: t.extension.identifier.value,
          id: new u2(e),
          duration: r,
        })
    }
    $executeContributedCommand(t, ...e) {
      this.d.trace("ExtHostCommands#$executeContributedCommand", t)
      const r = this.b.get(t)
      return r
        ? ((e = e.map((s) =>
            this.f.reduce(
              (a, o) => o.processArgument(a, r.extension?.identifier),
              s,
            ),
          )),
          this.h(t, e, !0))
        : Promise.reject(
            new Error(`Contributed command '${t}' does not exist.`),
          )
    }
    getCommands(t = !1) {
      return (
        this.d.trace("ExtHostCommands#getCommands", t),
        this.#t
          .$getCommands()
          .then((e) => (t && (e = e.filter((r) => r[0] !== "_")), e))
      )
    }
    $getContributedCommandMetadata() {
      const t = Object.create(null)
      for (const [e, r] of this.b) {
        const { metadata: s } = r
        s && (t[e] = s)
      }
      return Promise.resolve(t)
    }
  }
b2 = __decorate([__param(0, Vt), __param(1, Kt), __param(2, T7)], b2)
var Ba = Y("IExtHostCommands"),
  Avt = class {
    constructor(i, t, e) {
      ;(this.d = i),
        (this.f = t),
        (this.g = e),
        (this.delegatingCommandId = `__vsc${Ki()}`),
        (this.b = new Map()),
        (this.c = 0),
        this.d.registerCommand(!0, this.delegatingCommandId, this.h, this)
    }
    toInternal(i, t) {
      if (!i) return
      const e = {
        $ident: void 0,
        id: i.command,
        title: i.title,
        tooltip: i.tooltip,
      }
      if (!i.command) return e
      const r = this.f(i.command)
      if (r)
        (e.id = r.internalId),
          (e.arguments = r.args.map((s, a) =>
            s.convert(i.arguments && i.arguments[a]),
          ))
      else if (Su(i.arguments)) {
        const s = `${i.command} /${++this.c}`
        this.b.set(s, i),
          t.add(
            it(() => {
              this.b.delete(s), this.g.trace("CommandsConverter#DISPOSE", s)
            }),
          ),
          (e.$ident = s),
          (e.id = this.delegatingCommandId),
          (e.arguments = [s]),
          this.g.trace("CommandsConverter#CREATE", i.command, s)
      }
      return e
    }
    fromInternal(i) {
      return typeof i.$ident == "string"
        ? this.b.get(i.$ident)
        : { command: i.id, title: i.title, arguments: i.arguments }
    }
    getActualCommand(...i) {
      return this.b.get(i[0])
    }
    h(...i) {
      const t = this.getActualCommand(...i)
      return (
        this.g.trace(
          "CommandsConverter#EXECUTE",
          i[0],
          t ? t.command : "MISSING",
        ),
        t
          ? this.d.executeCommand(t.command, ...(t.arguments || []))
          : Promise.reject(
              `Actual command not found, wanted to execute ${i[0]}`,
            )
      )
    }
  },
  M = class Ei {
    static {
      this.Uri = new Ei(
        "uri",
        "Uri of a text document",
        (t) => S.isUri(t),
        (t) => t,
      )
    }
    static {
      this.Position = new Ei(
        "position",
        "A position in a text document",
        (t) => Lt.isPosition(t),
        Gt.from,
      )
    }
    static {
      this.Range = new Ei(
        "range",
        "A range in a text document",
        (t) => Nt.isRange(t),
        O.from,
      )
    }
    static {
      this.Selection = new Ei(
        "selection",
        "A selection in a text document",
        (t) => Pn.isSelection(t),
        Cr.from,
      )
    }
    static {
      this.Number = new Ei(
        "number",
        "",
        (t) => typeof t == "number",
        (t) => t,
      )
    }
    static {
      this.String = new Ei(
        "string",
        "",
        (t) => typeof t == "string",
        (t) => t,
      )
    }
    static {
      this.StringArray = Ei.Arr(Ei.String)
    }
    static Arr(t) {
      return new Ei(
        `${t.name}_array`,
        `Array of ${t.name}, ${t.description}`,
        (e) => Array.isArray(e) && e.every((r) => t.validate(r)),
        (e) => e.map((r) => t.convert(r)),
      )
    }
    static {
      this.CallHierarchyItem = new Ei(
        "item",
        "A call hierarchy item",
        (t) => t instanceof Q3,
        Ca.from,
      )
    }
    static {
      this.TypeHierarchyItem = new Ei(
        "item",
        "A type hierarchy item",
        (t) => t instanceof xO,
        Ra.from,
      )
    }
    static {
      this.TestItem = new Ei(
        "testItem",
        "A VS Code TestItem",
        (t) => t instanceof Bd,
        Ss.from,
      )
    }
    static {
      this.TestProfile = new Ei(
        "testProfile",
        "A VS Code test profile",
        (t) => t instanceof aY,
        mq.from,
      )
    }
    constructor(t, e, r, s) {
      ;(this.name = t),
        (this.description = e),
        (this.validate = r),
        (this.convert = s)
    }
    optional() {
      return new Ei(
        this.name,
        `(optional) ${this.description}`,
        (t) => t == null || this.validate(t),
        (t) => (t === void 0 ? void 0 : t === null ? null : this.convert(t)),
      )
    }
    with(t, e) {
      return new Ei(
        t ?? this.name,
        e ?? this.description,
        this.validate,
        this.convert,
      )
    }
  },
  ht = class znt {
    static {
      this.Void = new znt("no result", (t) => t)
    }
    constructor(t, e) {
      ;(this.description = t), (this.convert = e)
    }
  },
  pt = class {
    constructor(i, t, e, r, s) {
      ;(this.id = i),
        (this.internalId = t),
        (this.description = e),
        (this.args = r),
        (this.result = s)
    }
  },
  Pc = Y("IExtHostTerminalService"),
  bX = class extends dt {
    constructor(i, t, e, r) {
      super(),
        (this.s = i),
        (this._id = t),
        (this.u = e),
        (this.w = r),
        (this.a = !1),
        (this.m = { isInteractedWith: !1 }),
        (this.isOpen = !1),
        (this.q = this.D(new C())),
        (this.onWillDispose = this.q.event),
        (this.u = Object.freeze(this.u)),
        (this.b = new Promise((a) => (this.g = a)))
      const s = this
      this.value = {
        get name() {
          return s.w || ""
        },
        get processId() {
          return s.b
        },
        get creationOptions() {
          return s.u
        },
        get exitStatus() {
          return s.j
        },
        get state() {
          return s.m
        },
        get selection() {
          return s.n
        },
        get shellIntegration() {
          return s.shellIntegration
        },
        sendText(a, o = !0) {
          s.z(), s.s.$sendText(s._id, a, o)
        },
        show(a) {
          s.z(), s.s.$show(s._id, a)
        },
        hide() {
          s.z(), s.s.$hide(s._id)
        },
        dispose() {
          s.a || ((s.a = !0), s.s.$dispose(s._id))
        },
        get dimensions() {
          if (!(s.f === void 0 || s.h === void 0))
            return { columns: s.f, rows: s.h }
        },
      }
    }
    dispose() {
      this.q.fire(), super.dispose()
    }
    async create(i, t) {
      if (typeof this._id != "string")
        throw new Error("Terminal has already been created")
      await this.s.$createTerminal(this._id, {
        name: i.name,
        shellPath: i.shellPath ?? void 0,
        shellArgs: i.shellArgs ?? void 0,
        cwd: i.cwd ?? t?.cwd ?? void 0,
        env: i.env ?? void 0,
        icon: IX(i.iconPath) ?? void 0,
        color: ko.isThemeColor(i.color) ? i.color.id : void 0,
        initialText: i.message ?? void 0,
        strictEnv: i.strictEnv ?? void 0,
        hideFromUser: i.hideFromUser ?? void 0,
        forceShellIntegration: t?.forceShellIntegration ?? void 0,
        isFeatureTerminal: t?.isFeatureTerminal ?? void 0,
        isExtensionOwnedTerminal: !0,
        useShellEnvironment: t?.useShellEnvironment ?? void 0,
        location:
          t?.location || this.y(i.location, t?.resolvedExtHostIdentifier),
        isTransient: i.isTransient ?? void 0,
      })
    }
    async createExtensionTerminal(i, t, e, r, s) {
      if (typeof this._id != "string")
        throw new Error("Terminal has already been created")
      if (
        (await this.s.$createTerminal(this._id, {
          name: this.w,
          isExtensionCustomPtyTerminal: !0,
          icon: r,
          color: ko.isThemeColor(s) ? s.id : void 0,
          location: t?.location || this.y(i, e),
          isTransient: !0,
        }),
        typeof this._id == "string")
      )
        throw new Error("Terminal creation failed")
      return this._id
    }
    y(i, t) {
      return typeof i == "object"
        ? "parentTerminal" in i && i.parentTerminal && t
          ? { parentTerminal: t }
          : "viewColumn" in i
            ? {
                viewColumn: Me.from(i.viewColumn),
                preserveFocus: i.preserveFocus,
              }
            : void 0
        : i
    }
    z() {
      if (this.a) throw new Error("Terminal has already been disposed")
    }
    set name(i) {
      this.w = i
    }
    setExitStatus(i, t) {
      this.j = Object.freeze({ code: i, reason: t })
    }
    setDimensions(i, t) {
      return (i === this.f && t === this.h) || i === 0 || t === 0
        ? !1
        : ((this.f = i), (this.h = t), !0)
    }
    setInteractedWith() {
      return this.m.isInteractedWith
        ? !1
        : ((this.m = { isInteractedWith: !0 }), !0)
    }
    setSelection(i) {
      this.n = i
    }
    _setProcessId(i) {
      this.g
        ? (this.g(i), (this.g = void 0))
        : this.b.then((t) => {
            t !== i && (this.b = Promise.resolve(i))
          })
    }
  },
  E2 = class {
    get onProcessReady() {
      return this.b.event
    }
    constructor(i) {
      ;(this.g = i),
        (this.id = 0),
        (this.shouldPersist = !1),
        (this.a = new C()),
        (this.onProcessData = this.a.event),
        (this.b = new C()),
        (this.d = new C()),
        (this.onDidChangeProperty = this.d.event),
        (this.f = new C()),
        (this.onProcessExit = this.f.event)
    }
    refreshProperty(i) {
      throw new Error(
        `refreshProperty is not suppported in extension owned terminals. property: ${i}`,
      )
    }
    updateProperty(i, t) {
      throw new Error(
        `updateProperty is not suppported in extension owned terminals. property: ${i}, value: ${t}`,
      )
    }
    async start() {}
    shutdown() {
      this.g.close()
    }
    input(i) {
      this.g.handleInput?.(i)
    }
    resize(i, t) {
      this.g.setDimensions?.({ columns: i, rows: t })
    }
    clearBuffer() {}
    async processBinary(i) {}
    acknowledgeDataEvent(i) {}
    async setUnicodeVersion(i) {}
    getInitialCwd() {
      return Promise.resolve("")
    }
    getCwd() {
      return Promise.resolve("")
    }
    startSendingEvents(i) {
      this.g.onDidWrite((t) => this.a.fire(t)),
        this.g.onDidClose?.((t = void 0) => {
          this.f.fire(t === void 0 ? void 0 : t)
        }),
        this.g.onDidOverrideDimensions?.((t) => {
          t &&
            this.d.fire({
              type: "overrideDimensions",
              value: { cols: t.columns, rows: t.rows },
            })
        }),
        this.g.onDidChangeName?.((t) => {
          this.d.fire({ type: "title", value: t })
        }),
        this.g.open(i || void 0),
        i && this.g.setDimensions?.(i),
        this.b.fire({ pid: -1, cwd: "", windowsPty: void 0 })
    }
  },
  Bvt = 1,
  I2 = class extends dt {
    get activeTerminal() {
      return this.b?.value
    }
    get terminals() {
      return this.f.map((t) => t.value)
    }
    constructor(t, e, r) {
      super(),
        (this.R = e),
        (this.f = []),
        (this.g = new Map()),
        (this.h = {}),
        (this.j = {}),
        (this.m = {}),
        (this.n = new Map()),
        (this.u = this.D(new Zn())),
        (this.y = new Set()),
        (this.z = new Map()),
        (this.C = new Map()),
        (this.F = new Map()),
        (this.G = new Map()),
        (this.H = new Map()),
        (this.I = new C()),
        (this.onDidCloseTerminal = this.I.event),
        (this.J = new C()),
        (this.onDidOpenTerminal = this.J.event),
        (this.L = new C()),
        (this.onDidChangeActiveTerminal = this.L.event),
        (this.M = new C()),
        (this.onDidChangeTerminalDimensions = this.M.event),
        (this.N = new C()),
        (this.onDidChangeTerminalState = this.N.event),
        (this.O = new C()),
        (this.onDidChangeShell = this.O.event),
        (this.P = new C({
          onWillAddFirstListener: () => this.a.$startSendingDataEvents(),
          onDidRemoveLastListener: () => this.a.$stopSendingDataEvents(),
        })),
        (this.onDidWriteTerminalData = this.P.event),
        (this.Q = new C({
          onWillAddFirstListener: () => this.a.$startSendingCommandEvents(),
          onDidRemoveLastListener: () => this.a.$stopSendingCommandEvents(),
        })),
        (this.onDidExecuteTerminalCommand = this.Q.event),
        (this.a = r.getProxy(z.MainThreadTerminalService)),
        (this.w = new Rvt(this.a.$sendProcessData)),
        this.a.$registerProcessSupport(t),
        this.R.registerArgumentProcessor({
          processArgument: (s) => {
            const a = (o) => {
              const c = o
              return this.getTerminalById(c.instanceId)?.value
            }
            switch (s?.$mid) {
              case 15:
                return a(s)
              default: {
                if (Array.isArray(s))
                  for (let o = 0; o < s.length && s[o].$mid === 15; o++)
                    s[o] = a(s[o])
                return s
              }
            }
          },
        }),
        this.D({
          dispose: () => {
            for (const [s, a] of this.g) a.shutdown(!0)
          },
        })
    }
    getDefaultShell(t) {
      return (t ? this.s : this.q)?.path || ""
    }
    getDefaultShellArgs(t) {
      return (t ? this.s : this.q)?.args || []
    }
    createExtensionTerminal(t, e) {
      const r = new bX(this.a, Ki(), t, t.name),
        s = new E2(t.pty)
      return (
        r
          .createExtensionTerminal(
            t.location,
            e,
            this.S(t, e).resolvedExtHostIdentifier,
            IX(t.iconPath),
            qvt(t.color),
          )
          .then((a) => {
            const o = this.U(a, s)
            this.h[a] = o
          }),
        this.f.push(r),
        r.value
      )
    }
    S(t, e) {
      if (
        ((e = e || {}),
        t.location &&
          typeof t.location == "object" &&
          "parentTerminal" in t.location)
      ) {
        const r = t.location.parentTerminal
        if (r) {
          const s = this.f.find((a) => a.value === r)
          s && (e.resolvedExtHostIdentifier = s._id)
        }
      } else
        t.location && typeof t.location != "object"
          ? (e.location = t.location)
          : e.location &&
            typeof e.location == "object" &&
            "splitActiveTerminal" in e.location &&
            (e.location = { splitActiveTerminal: !0 })
      return e
    }
    attachPtyToTerminal(t, e) {
      if (!this.getTerminalById(t))
        throw new Error(
          `Cannot resolve terminal with id ${t} for virtual process`,
        )
      const s = new E2(e),
        a = this.U(t, s)
      this.h[t] = a
    }
    async $acceptActiveTerminalChanged(t) {
      const e = this.b
      if (t === null) {
        ;(this.b = void 0), e !== this.b && this.L.fire(this.b)
        return
      }
      const r = this.getTerminalById(t)
      r && ((this.b = r), e !== this.b && this.L.fire(this.b.value))
    }
    async $acceptTerminalProcessData(t, e) {
      const r = this.getTerminalById(t)
      r && this.P.fire({ terminal: r.value, data: e })
    }
    async $acceptTerminalDimensions(t, e, r) {
      const s = this.getTerminalById(t)
      s &&
        s.setDimensions(e, r) &&
        this.M.fire({ terminal: s.value, dimensions: s.value.dimensions })
    }
    async $acceptDidExecuteCommand(t, e) {
      const r = this.getTerminalById(t)
      r && this.Q.fire({ terminal: r.value, ...e })
    }
    async $acceptTerminalMaximumDimensions(t, e, r) {
      this.g.get(t)?.resize(e, r)
    }
    async $acceptTerminalTitleChange(t, e) {
      const r = this.getTerminalById(t)
      r && (r.name = e)
    }
    async $acceptTerminalClosed(t, e, r) {
      const s = this.Y(this.f, t)
      if (s !== null) {
        const a = this.f.splice(s, 1)[0]
        a.setExitStatus(e, r), this.I.fire(a.value)
      }
    }
    $acceptTerminalOpened(t, e, r, s) {
      if (e) {
        const c = this.Y(this.f, e)
        if (c !== null) {
          ;(this.f[c]._id = t),
            this.J.fire(this.terminals[c]),
            (this.f[c].isOpen = !0)
          return
        }
      }
      const a = {
          name: s.name,
          shellPath: s.executable,
          shellArgs: s.args,
          cwd: typeof s.cwd == "string" ? s.cwd : S.revive(s.cwd),
          env: s.env,
          hideFromUser: s.hideFromUser,
        },
        o = new bX(this.a, t, a, r)
      this.f.push(o), this.J.fire(o.value), (o.isOpen = !0)
    }
    async $acceptTerminalProcessId(t, e) {
      this.getTerminalById(t)?._setProcessId(e)
    }
    async $startExtensionTerminal(t, e) {
      const r = this.getTerminalById(t)
      if (!r) return { message: f(2771, null, t) }
      r.isOpen ||
        (await new Promise((a) => {
          const o = this.onDidOpenTerminal(async (c) => {
            c === r.value && (o.dispose(), a())
          })
        }))
      const s = this.g.get(t)
      s ? s.startSendingEvents(e) : (this.j[t] = { initialDimensions: e })
    }
    U(t, e) {
      const r = new bt()
      r.add(
        e.onProcessReady((a) =>
          this.a.$sendProcessReady(t, a.pid, a.cwd, a.windowsPty),
        ),
      ),
        r.add(e.onDidChangeProperty((a) => this.a.$sendProcessProperty(t, a))),
        this.w.startBuffering(t, e.onProcessData),
        r.add(e.onProcessExit((a) => this.W(t, a))),
        this.g.set(t, e)
      const s = this.j[t]
      return (
        s &&
          e instanceof E2 &&
          (e.startSendingEvents(s.initialDimensions), delete this.j[t]),
        r
      )
    }
    $acceptProcessAckDataEvent(t, e) {
      this.g.get(t)?.acknowledgeDataEvent(e)
    }
    $acceptProcessInput(t, e) {
      this.g.get(t)?.input(e)
    }
    $acceptTerminalInteraction(t) {
      const e = this.getTerminalById(t)
      e?.setInteractedWith() && this.N.fire(e.value)
    }
    $acceptTerminalSelection(t, e) {
      this.getTerminalById(t)?.setSelection(e)
    }
    $acceptProcessResize(t, e, r) {
      try {
        this.g.get(t)?.resize(e, r)
      } catch (s) {
        if (s.code !== "EPIPE" && s.code !== "ERR_IPC_CHANNEL_CLOSED") throw s
      }
    }
    $acceptProcessShutdown(t, e) {
      this.g.get(t)?.shutdown(e)
    }
    $acceptProcessRequestInitialCwd(t) {
      this.g
        .get(t)
        ?.getInitialCwd()
        .then((e) =>
          this.a.$sendProcessProperty(t, { type: "initialCwd", value: e }),
        )
    }
    $acceptProcessRequestCwd(t) {
      this.g
        .get(t)
        ?.getCwd()
        .then((e) => this.a.$sendProcessProperty(t, { type: "cwd", value: e }))
    }
    $acceptProcessRequestLatency(t) {
      return Promise.resolve(t)
    }
    registerProfileProvider(t, e, r) {
      if (this.C.has(e))
        throw new Error(`Terminal profile provider "${e}" already registered`)
      return (
        this.C.set(e, r),
        this.a.$registerProfileProvider(e, t.identifier.value),
        new At(() => {
          this.C.delete(e), this.a.$unregisterProfileProvider(e)
        })
      )
    }
    registerTerminalCompletionProvider(t, e, ...r) {
      if (this.z.has(e.id))
        throw new Error(
          `Terminal completion provider "${e.id}" already registered`,
        )
      return (
        this.z.set(e.id, e),
        this.a.$registerCompletionProvider(e.id, t.identifier.value, ...r),
        new At(() => {
          this.z.delete(e.id), this.a.$unregisterCompletionProvider(e.id)
        })
      )
    }
    async $provideTerminalCompletions(t, e) {
      const r = new Ie().token
      if (r.isCancellationRequested || !this.activeTerminal) return
      const s = this.z.get(t)
      if (!s) return
      const a = await s.provideTerminalCompletions(this.activeTerminal, e, r)
      if (a != null) return a
    }
    registerTerminalQuickFixProvider(t, e, r) {
      if (this.F.has(t))
        throw new Error(
          `Terminal quick fix provider "${t}" is already registered`,
        )
      return (
        this.F.set(t, r),
        this.a.$registerQuickFixProvider(t, e),
        new At(() => {
          this.F.delete(t), this.a.$unregisterQuickFixProvider(t)
        })
      )
    }
    async $provideTerminalQuickFixes(t, e) {
      const r = new Ie().token
      if (r.isCancellationRequested) return
      const s = this.F.get(t)
      if (!s) return
      const a = await s.provideTerminalQuickFixes(e, r)
      if (a === null || (Array.isArray(a) && a.length === 0)) return
      const o = new bt()
      if (((this.u.value = o), !Array.isArray(a)))
        return a ? RA.from(a, this.R.converter, o) : void 0
      const c = []
      for (const u of a) {
        const l = RA.from(u, this.R.converter, o)
        l && c.push(l)
      }
      return c
    }
    async $createContributedProfileTerminal(t, e) {
      const r = new Ie().token
      let s = await this.C.get(t)?.provideTerminalProfile(r)
      if (!r.isCancellationRequested) {
        if (
          (s && !("options" in s) && (s = { options: s }),
          !s || !("options" in s))
        )
          throw new Error(`No terminal profile options provided for id "${t}"`)
        if ("pty" in s.options) {
          this.createExtensionTerminal(s.options, e)
          return
        }
        this.createTerminalFromOptions(s.options, e)
      }
    }
    registerLinkProvider(t) {
      return (
        this.y.add(t),
        this.y.size === 1 && this.a.$startLinkProvider(),
        new At(() => {
          this.y.delete(t), this.y.size === 0 && this.a.$stopLinkProvider()
        })
      )
    }
    async $provideLinks(t, e) {
      const r = this.getTerminalById(t)
      if (!r) return []
      this.G.delete(t), this.H.get(t)?.dispose(!0)
      const a = new Ie()
      this.H.set(t, a)
      const o = [],
        c = { terminal: r.value, line: e },
        u = []
      for (const h of this.y)
        u.push(
          vo.withAsyncBody(async (p) => {
            a.token.onCancellationRequested(() => p({ provider: h, links: [] }))
            const g = (await h.provideTerminalLinks(c, a.token)) || []
            a.token.isCancellationRequested || p({ provider: h, links: g })
          }),
        )
      const l = await Promise.all(u)
      if (a.token.isCancellationRequested) return []
      const m = new Map()
      for (const h of l)
        h &&
          h.links.length > 0 &&
          o.push(
            ...h.links.map((p) => {
              const g = {
                id: Bvt++,
                startIndex: p.startIndex,
                length: p.length,
                label: p.tooltip,
              }
              return m.set(g.id, { provider: h.provider, link: p }), g
            }),
          )
      return this.G.set(t, m), o
    }
    $activateLink(t, e) {
      const r = this.G.get(t)?.get(e)
      r && r.provider.handleTerminalLink(r.link)
    }
    W(t, e) {
      this.w.stopBuffering(t), this.g.delete(t), delete this.j[t]
      const r = this.h[t]
      r && (r.dispose(), delete this.h[t]), this.a.$sendProcessExit(t, e)
    }
    getTerminalById(t) {
      return this.X(this.f, t)
    }
    getTerminalIdByApiObject(t) {
      const e = this.f.findIndex((r) => r.value === t)
      return e >= 0 ? e : null
    }
    X(t, e) {
      const r = this.Y(t, e)
      return r !== null ? t[r] : null
    }
    Y(t, e) {
      const r = t.findIndex((s) => s._id === e)
      return r >= 0 ? r : null
    }
    getEnvironmentVariableCollection(t) {
      let e = this.n.get(t.identifier.value)
      return (
        e || ((e = this.D(new EX())), this.$(t.identifier.value, e)),
        e.getScopedEnvironmentVariableCollection(void 0)
      )
    }
    Z(t, e) {
      const r = Cvt(e.map),
        s = Lvt(e.descriptionMap)
      this.a.$setEnvironmentVariableCollection(
        t,
        e.persistent,
        r.length === 0 ? void 0 : r,
        s,
      )
    }
    $initEnvironmentVariableCollections(t) {
      t.forEach((e) => {
        const r = e[0],
          s = this.D(new EX(e[1]))
        this.$(r, s)
      })
    }
    $acceptDefaultProfile(t, e) {
      const r = this.q
      ;(this.q = t), (this.s = e), r?.path !== t.path && this.O.fire(t.path)
    }
    $(t, e) {
      this.n.set(t, e),
        this.D(
          e.onDidChangeCollection(() => {
            this.Z(t, e)
          }),
        )
    }
  }
I2 = __decorate([__param(1, Ba), __param(2, Vt)], I2)
var EX = class extends dt {
    get persistent() {
      return this.b
    }
    set persistent(i) {
      ;(this.b = i), this.f.fire()
    }
    get onDidChangeCollection() {
      return this.f && this.f.event
    }
    constructor(i) {
      super(),
        (this.map = new Map()),
        (this.a = new Map()),
        (this.descriptionMap = new Map()),
        (this.b = !0),
        (this.f = new C()),
        (this.map = new Map(i))
    }
    getScopedEnvironmentVariableCollection(i) {
      const t = this.j(i)
      let e = this.a.get(t)
      return (
        e ||
          ((e = new Ovt(this, i)),
          this.a.set(t, e),
          this.D(e.onDidChangeCollection(() => this.f.fire()))),
        e
      )
    }
    replace(i, t, e, r) {
      this.g(i, {
        value: t,
        type: Do.Replace,
        options: e ?? { applyAtProcessCreation: !0 },
        scope: r,
      })
    }
    append(i, t, e, r) {
      this.g(i, {
        value: t,
        type: Do.Append,
        options: e ?? { applyAtProcessCreation: !0 },
        scope: r,
      })
    }
    prepend(i, t, e, r) {
      this.g(i, {
        value: t,
        type: Do.Prepend,
        options: e ?? { applyAtProcessCreation: !0 },
        scope: r,
      })
    }
    g(i, t) {
      if (
        t.options &&
        t.options.applyAtProcessCreation === !1 &&
        !t.options.applyAtShellIntegration
      )
        throw new Error(
          "EnvironmentVariableMutatorOptions must apply at either process creation or shell integration",
        )
      const e = this.h(i, t.scope),
        r = this.map.get(e),
        s = t.options
          ? {
              applyAtProcessCreation: t.options.applyAtProcessCreation ?? !1,
              applyAtShellIntegration: t.options.applyAtShellIntegration ?? !1,
            }
          : { applyAtProcessCreation: !0 }
      if (
        !r ||
        r.value !== t.value ||
        r.type !== t.type ||
        r.options?.applyAtProcessCreation !== s.applyAtProcessCreation ||
        r.options?.applyAtShellIntegration !== s.applyAtShellIntegration ||
        r.scope?.workspaceFolder?.index !== t.scope?.workspaceFolder?.index
      ) {
        const a = this.h(i, t.scope),
          o = { variable: i, ...t, options: s }
        this.map.set(a, o), this.f.fire()
      }
    }
    get(i, t) {
      const e = this.h(i, t),
        r = this.map.get(e)
      return r ? PX(r) : void 0
    }
    h(i, t) {
      const e = this.j(t)
      return e.length ? `${i}:::${e}` : i
    }
    j(i) {
      return this.m(i?.workspaceFolder) ?? ""
    }
    m(i) {
      return i ? i.uri.toString() : void 0
    }
    getVariableMap(i) {
      const t = new Map()
      for (const [e, r] of this.map)
        this.j(r.scope) === this.j(i) && t.set(r.variable, PX(r))
      return t
    }
    delete(i, t) {
      const e = this.h(i, t)
      this.map.delete(e), this.f.fire()
    }
    clear(i) {
      if (i?.workspaceFolder) {
        for (const [t, e] of this.map)
          e.scope?.workspaceFolder?.index === i.workspaceFolder.index &&
            this.map.delete(t)
        this.n(i)
      } else this.map.clear(), this.descriptionMap.clear()
      this.f.fire()
    }
    setDescription(i, t) {
      const e = this.j(t),
        r = this.descriptionMap.get(e)
      if (!r || r.description !== i) {
        let s
        typeof i == "string"
          ? (s = i)
          : (s = i?.value.split(`

`)[0])
        const a = { description: s, scope: t }
        this.descriptionMap.set(e, a), this.f.fire()
      }
    }
    getDescription(i) {
      const t = this.j(i)
      return this.descriptionMap.get(t)?.description
    }
    n(i) {
      const t = this.j(i)
      this.descriptionMap.delete(t)
    }
  },
  Ovt = class {
    get persistent() {
      return this.b.persistent
    }
    set persistent(i) {
      this.b.persistent = i
    }
    get onDidChangeCollection() {
      return this.a && this.a.event
    }
    constructor(i, t) {
      ;(this.b = i), (this.d = t), (this.a = new C())
    }
    getScoped(i) {
      return this.b.getScopedEnvironmentVariableCollection(i)
    }
    replace(i, t, e) {
      this.b.replace(i, t, e, this.d)
    }
    append(i, t, e) {
      this.b.append(i, t, e, this.d)
    }
    prepend(i, t, e) {
      this.b.prepend(i, t, e, this.d)
    }
    get(i) {
      return this.b.get(i, this.d)
    }
    forEach(i, t) {
      this.b
        .getVariableMap(this.d)
        .forEach((e, r) => i.call(t, r, e, this), this.d)
    }
    [Symbol.iterator]() {
      return this.b.getVariableMap(this.d).entries()
    }
    delete(i) {
      this.b.delete(i, this.d), this.a.fire(void 0)
    }
    clear() {
      this.b.clear(this.d)
    }
    set description(i) {
      this.b.setDescription(i, this.d)
    }
    get description() {
      return this.b.getDescription(this.d)
    }
  },
  P2 = class extends I2 {
    constructor(t, e) {
      super(!1, t, e)
    }
    createTerminal(t, e, r) {
      throw new rB()
    }
    createTerminalFromOptions(t, e) {
      throw new rB()
    }
  }
P2 = __decorate([__param(0, Ba), __param(1, Vt)], P2)
function IX(i) {
  if (!(!i || typeof i == "string"))
    return "id" in i ? { id: i.id, color: i.color } : i
}
function qvt(i) {
  return ko.isThemeColor(i) ? i : void 0
}
function PX(i) {
  const t = { ...i }
  return delete t.scope, (t.options = t.options ?? void 0), delete t.variable, t
}
var Uvt = Y("progressService"),
  NX
;(function (i) {
  ;(i[(i.Explorer = 1)] = "Explorer"),
    (i[(i.Scm = 3)] = "Scm"),
    (i[(i.Extensions = 5)] = "Extensions"),
    (i[(i.Window = 10)] = "Window"),
    (i[(i.Notification = 15)] = "Notification"),
    (i[(i.Dialog = 20)] = "Dialog")
})(NX || (NX = {}))
var dqt = Object.freeze({ total() {}, worked() {}, done() {} }),
  $X = class {
    static {
      this.None = Object.freeze({ report() {} })
    }
    get value() {
      return this.a
    }
    constructor(i) {
      this.b = i
    }
    report(i) {
      ;(this.a = i), this.b(this.a)
    }
  },
  xX = class extends dt {
    constructor(t, e) {
      super(),
        (this.a = new go()),
        e.withProgress(
          t,
          (r) => ((this.b = r), this.c && r.report(this.c), this.a.p),
        ),
        this.D(it(() => this.a.complete()))
    }
    report(t) {
      this.b ? this.b.report(t) : (this.c = t)
    }
  }
xX = __decorate([__param(1, Uvt)], xX)
var Mvt = Y("editorProgressService"),
  Hvt = Object.freeze({ total() {}, worked() {}, done() {} }),
  Wvt = class extends dt {
    show(i, t) {
      return Hvt
    }
    showWhile(i, t) {
      return Promise.resolve()
    }
  }
Zt(Mvt, Wvt, 1)
var JX = "__",
  hqt = Y("IAuthenticationService"),
  fqt = Y("IAuthenticationExtensionsService"),
  N2 = Y("IExtHostAuthentication"),
  $2 = class {
    constructor(t) {
      ;(this.b = new Map()),
        (this.c = new C()),
        (this.d = new jvt()),
        (this.a = t.getProxy(z.MainThreadAuthentication))
    }
    getExtensionScopedSessionsEvent(t) {
      const e = t.toLowerCase()
      return Ee.chain(this.c.event, (r) =>
        r
          .filter(
            (s) => !s.extensionIdFilter || s.extensionIdFilter.includes(e),
          )
          .map((s) => ({ provider: s.provider })),
      )
    }
    async getSession(t, e, r, s = {}) {
      const a = te.toKey(t.identifier),
        o = [...r].sort().join(" ")
      return await this.d.getOrCreate(`${a} ${e} ${o}`, async () => {
        await this.a.$ensureProvider(e)
        const c = t.displayName || t.name
        return this.a.$getSession(e, r, a, c, s)
      })
    }
    async getAccounts(t) {
      return await this.a.$ensureProvider(t), await this.a.$getAccounts(t)
    }
    async removeSession(t, e) {
      const r = this.b.get(t)
      return r ? r.provider.removeSession(e) : this.a.$removeSession(t, e)
    }
    registerAuthenticationProvider(t, e, r, s) {
      if (this.b.get(t))
        throw new Error(
          `An authentication provider with id '${t}' is already registered.`,
        )
      this.b.set(t, {
        label: e,
        provider: r,
        options: s ?? { supportsMultipleAccounts: !1 },
      })
      const a = r.onDidChangeSessions((o) =>
        this.a.$sendDidChangeSessions(t, o),
      )
      return (
        this.a.$registerAuthenticationProvider(
          t,
          e,
          s?.supportsMultipleAccounts ?? !1,
        ),
        new At(() => {
          a.dispose(),
            this.b.delete(t),
            this.a.$unregisterAuthenticationProvider(t)
        })
      )
    }
    async $createSession(t, e, r) {
      const s = this.b.get(t)
      if (s) return await s.provider.createSession(e, r)
      throw new Error(
        `Unable to find authentication provider with handle: ${t}`,
      )
    }
    async $removeSession(t, e) {
      const r = this.b.get(t)
      if (r) return await r.provider.removeSession(e)
      throw new Error(
        `Unable to find authentication provider with handle: ${t}`,
      )
    }
    async $getSessions(t, e, r) {
      const s = this.b.get(t)
      if (s) return await s.provider.getSessions(e, r)
      throw new Error(
        `Unable to find authentication provider with handle: ${t}`,
      )
    }
    $onDidChangeAuthenticationSessions(t, e, r) {
      return (
        t.startsWith(JX) ||
          this.c.fire({ provider: { id: t, label: e }, extensionIdFilter: r }),
        Promise.resolve()
      )
    }
  }
$2 = __decorate([__param(0, Vt)], $2)
var jvt = class {
    constructor() {
      this.a = new Map()
    }
    getOrCreate(i, t) {
      const e = this.a.get(i)
      if (e) return e
      const r = t().finally(() => this.a.delete(i))
      return this.a.set(i, r), r
    }
  },
  k7,
  x2 = Y("IExtHostLanguageModels"),
  CX = class {
    constructor(i, t) {
      ;(this.option = i),
        (this.stream = new DB()),
        (this.stream = t ?? new DB())
    }
  },
  Vvt = class {
    constructor() {
      ;(this.a = new Map()), (this.b = new DB()), (this.c = !1)
      const i = this
      this.apiObject = {
        get stream() {
          return i.b.asyncIterable
        },
        get text() {
          return Fu.map(i.b.asyncIterable, (t) => {
            if (t instanceof Li) return t.value
          }).coalesce()
        },
      }
    }
    *d() {
      if (this.a.size > 0) for (const [, i] of this.a) yield i.stream
      else yield this.b
    }
    handleFragment(i) {
      if (this.c) return
      let t = this.a.get(i.index)
      t ||
        (this.a.size === 0
          ? (t = new CX(i.index, this.b))
          : (t = new CX(i.index)),
        this.a.set(i.index, t))
      let e
      i.part.type === "text"
        ? (e = new Li(i.part.value))
        : (e = new Wl(i.part.toolCallId, i.part.name, i.part.parameters)),
        t.stream.emitOne(e)
    }
    reject(i) {
      this.c = !0
      for (const t of this.d()) t.reject(i)
    }
    resolve() {
      this.c = !0
      for (const i of this.d()) i.resolve()
    }
  },
  J2 = class {
    static {
      k7 = this
    }
    static {
      this.a = 1
    }
    constructor(t, e, r) {
      ;(this.k = e),
        (this.l = r),
        (this.c = new C()),
        (this.d = new C()),
        (this.onDidChangeProviders = this.d.event),
        (this.f = new Map()),
        (this.g = new Map()),
        (this.h = new bn()),
        (this.i = new Map()),
        (this.j = new Map()),
        (this.t = new Set()),
        (this.b = t.getProxy(z.MainThreadLanguageModels))
    }
    dispose() {
      this.c.dispose(), this.d.dispose()
    }
    registerLanguageModel(t, e, r, s) {
      const a = k7.a++
      this.f.set(a, {
        extension: t.identifier,
        provider: r,
        languageModelId: e,
      })
      let o
      s.auth &&
        (o = {
          providerLabel: t.displayName || t.name,
          accountLabel: typeof s.auth == "object" ? s.auth.label : void 0,
        }),
        this.b.$registerLanguageModelProvider(
          a,
          `${te.toKey(t.identifier)}/${e}`,
          {
            extension: t.identifier,
            id: e,
            vendor: s.vendor ?? te.toKey(t.identifier),
            name: s.name ?? "",
            family: s.family ?? "",
            version: s.version,
            maxInputTokens: s.maxInputTokens,
            maxOutputTokens: s.maxOutputTokens,
            auth: o,
            targetExtensions: s.extensions,
            isDefault: s.isDefault,
            isUserSelectable: s.isUserSelectable,
          },
        )
      const c = r.onDidReceiveLanguageModelResponse2?.(
        ({ extensionId: u, participant: l, tokenCount: m }) => {
          this.b.$whenLanguageModelChatRequestMade(e, new te(u), l, m)
        },
      )
      return it(() => {
        this.f.delete(a), this.b.$unregisterProvider(a), c?.dispose()
      })
    }
    async $startChatRequest(t, e, r, s, a, o) {
      const c = this.f.get(t)
      if (!c) throw new Error("Provider not found")
      const u = new $X(async (m) => {
        if (o.isCancellationRequested) {
          this.k.warn(
            `[CHAT](${c.extension.value}) CANNOT send progress because the REQUEST IS CANCELLED`,
          )
          return
        }
        let h
        if (
          (m.part instanceof Wl
            ? (h = {
                type: "tool_use",
                name: m.part.name,
                parameters: m.part.input,
                toolCallId: m.part.callId,
              })
            : m.part instanceof Li &&
              (h = { type: "text", value: m.part.value }),
          !h)
        ) {
          this.k.warn(
            `[CHAT](${c.extension.value}) UNKNOWN part ${JSON.stringify(m)}`,
          )
          return
        }
        this.b.$reportResponsePart(e, { index: m.index, part: h })
      })
      let l
      c.provider.provideLanguageModelResponse2
        ? (l = Promise.resolve(
            c.provider.provideLanguageModelResponse2(
              s.map(hc.to),
              a,
              te.toKey(r),
              u,
              o,
            ),
          ))
        : (l = Promise.resolve(
            c.provider.provideLanguageModelResponse(
              s.map(hc.to),
              a,
              te.toKey(r),
              u,
              o,
            ),
          )),
        l.then(
          () => {
            this.b.$reportResponseDone(e, void 0)
          },
          (m) => {
            this.b.$reportResponseDone(e, ku(m))
          },
        )
    }
    $provideTokenLength(t, e, r) {
      const s = this.f.get(t)
      return s
        ? Promise.resolve(s.provider.provideTokenCount(e, r))
        : Promise.resolve(0)
    }
    $acceptChatModelMetadata(t) {
      if (t.added)
        for (const { identifier: e, metadata: r } of t.added)
          this.g.set(e, { metadata: r, apiObjects: new bn() })
      if (t.removed)
        for (const e of t.removed) {
          this.g.delete(e)
          for (const [r, s] of this.i)
            s.languageModelId === e &&
              (s.res.reject(new zr()), this.i.delete(r))
        }
      t.added?.forEach((e) => this.r(e.metadata)), this.d.fire(void 0)
    }
    async getDefaultLanguageModel(t) {
      const e = Yi.find(
        this.g.entries(),
        ([, r]) => !!r.metadata.isDefault,
      )?.[0]
      if (e) return this.getLanguageModelByIdentifier(t, e)
    }
    async getLanguageModelByIdentifier(t, e) {
      const r = this.g.get(e)
      if (!r) return
      this.q(t.identifier, r.metadata) && (await this.r(r.metadata))
      let s = r.apiObjects.get(t.identifier)
      if (!s) {
        const a = this
        ;(s = {
          id: r.metadata.id,
          vendor: r.metadata.vendor,
          family: r.metadata.family,
          version: r.metadata.version,
          name: r.metadata.name,
          maxInputTokens: r.metadata.maxInputTokens,
          countTokens(o, c) {
            if (!a.g.has(e)) throw Jn.NotFound(e)
            return a.s(e, o, c ?? fe.None)
          },
          sendRequest(o, c, u) {
            if (!a.g.has(e)) throw Jn.NotFound(e)
            return a.m(t, e, o, c ?? {}, u ?? fe.None)
          },
        }),
          Object.freeze(s),
          r.apiObjects.set(t.identifier, s)
      }
      return s
    }
    async selectLanguageModels(t, e) {
      const r = await this.b.$selectChatModels({
          ...e,
          extension: t.identifier,
        }),
        s = []
      for (const a of r) {
        const o = await this.getLanguageModelByIdentifier(t, a)
        o && s.push(o)
      }
      return s
    }
    async m(t, e, r, s, a) {
      const o = this.n(t, r),
        c = t.identifier,
        u = this.g.get(e)?.metadata
      if (!u || !this.g.has(e))
        throw Jn.NotFound(`Language model '${e}' is unknown.`)
      if (
        this.q(c, u) &&
        (!(await this.o(
          t,
          { identifier: u.extension, displayName: u.auth.providerLabel },
          s.justification,
          !1,
        )) ||
          !this.h.get(c)?.has(u.extension))
      )
        throw Jn.NoPermissions(
          `Language model '${e}' cannot be used by '${c.value}'.`,
        )
      try {
        const l = (Math.random() * 1e6) | 0,
          m = new Vvt()
        this.i.set(l, { languageModelId: e, res: m })
        try {
          await this.b.$tryStartChatRequest(c, e, l, o, s, a)
        } catch (h) {
          throw (this.i.delete(l), h)
        }
        return m.apiObject
      } catch (l) {
        throw l.name === Jn.name
          ? l
          : new Jn(`Language model '${e}' errored: ${ea(l)}`, "Unknown", l)
      }
    }
    n(t, e) {
      const r = []
      for (const s of e)
        s.role === dr.System && F(t, "languageModelSystem"), r.push(hc.from(s))
      return r
    }
    async $acceptResponsePart(t, e) {
      const r = this.i.get(t)
      r && r.res.handleFragment(e)
    }
    async $acceptResponseDone(t, e) {
      const r = this.i.get(t)
      r && (this.i.delete(t), e ? r.res.reject(Vst(e)) : r.res.resolve())
    }
    async o(t, e, r, s) {
      const a = JX + e.identifier.value
      if (await this.l.getSession(t, a, [], { silent: !0 }))
        return (
          this.$updateModelAccesslist([
            { from: t.identifier, to: e.identifier, enabled: !0 },
          ]),
          !0
        )
      if (s) return !1
      try {
        const c = r ? f(2762, null, e.displayName, r) : void 0
        return (
          await this.l.getSession(t, a, [], { forceNewSession: { detail: c } }),
          this.$updateModelAccesslist([
            { from: t.identifier, to: e.identifier, enabled: !0 },
          ]),
          !0
        )
      } catch {
        return !1
      }
    }
    q(t, e) {
      return !!e.auth && !te.equals(e.extension, t)
    }
    async r(t) {
      if (t.auth)
        for (const e of this.t)
          try {
            await this.o(
              e,
              { identifier: t.extension, displayName: "" },
              void 0,
              !0,
            )
          } catch (r) {
            this.k.error("Fake Auth request failed"), this.k.error(r)
          }
    }
    async s(t, e, r) {
      if (!this.g.get(t)) throw Jn.NotFound(`Language model '${t}' is unknown.`)
      const a = Yi.find(this.f.values(), (o) => o.languageModelId === t)
      return a
        ? a.provider.provideTokenCount(e, r)
        : this.b.$countTokens(t, typeof e == "string" ? e : hc.from(e), r)
    }
    $updateModelAccesslist(t) {
      const e = new Array()
      for (const { from: r, to: s, enabled: a } of t) {
        const o = this.h.get(r) ?? new la()
        if (o.has(s) !== a) {
          a ? o.add(s) : o.delete(s), this.h.set(r, o)
          const u = { from: r, to: s }
          e.push(u), this.c.fire(u)
        }
      }
    }
    createLanguageModelAccessInformation(t) {
      this.t.add(t)
      const e = this,
        r = Ee.signal(
          Ee.filter(this.c.event, (a) => te.equals(a.from, t.identifier)),
        ),
        s = Ee.signal(this.d.event)
      return {
        get onDidChange() {
          return Ee.any(r, s)
        },
        canSendRequest(a) {
          let o
          t: for (const [u, l] of e.g)
            for (const m of l.apiObjects.values())
              if (m === a) {
                o = l.metadata
                break t
              }
          if (!o) return
          if (!e.q(t.identifier, o)) return !0
          const c = e.h.get(t.identifier)
          if (c) return c.has(o.extension)
        },
      }
    }
    fileIsIgnored(t, e, r) {
      return F(t, "chatParticipantAdditions"), this.b.$fileIsIgnored(e, r)
    }
    async $isFileIgnored(t, e, r) {
      const s = this.j.get(t)
      if (!s) throw new Error("Unknown LanguageModelIgnoredFileProvider")
      return (await s.provideFileIgnored(S.revive(e), r)) ?? !1
    }
    registerIgnoredFileProvider(t, e) {
      F(t, "chatParticipantPrivate")
      const r = k7.a++
      return (
        this.b.$registerFileIgnoreProvider(r),
        this.j.set(r, e),
        it(() => {
          this.b.$unregisterFileIgnoreProvider(r), this.j.delete(r)
        })
      )
    }
  }
J2 = k7 = __decorate([__param(0, Vt), __param(1, Kt), __param(2, N2)], J2)
function Od(i, t = Mi) {
  return zot(i, t) ? i.charAt(0).toUpperCase() + i.slice(1) : i
}
function Gvt(i, t) {
  return i.replace(/^~($|\/|\\)/, `${t}$1`)
}
var LX
;(function (i) {
  ;(i[(i.TEXT = 0)] = "TEXT"),
    (i[(i.VARIABLE = 1)] = "VARIABLE"),
    (i[(i.SEPARATOR = 2)] = "SEPARATOR")
})(LX || (LX = {}))
var zvt = 60,
  Yvt = zvt * 60,
  C2 = Yvt * 24,
  vqt = C2 * 7,
  wqt = C2 * 30,
  yqt = C2 * 365
function Qvt(i) {
  return (
    i.getFullYear() +
    "-" +
    String(i.getMonth() + 1).padStart(2, "0") +
    "-" +
    String(i.getDate()).padStart(2, "0") +
    "T" +
    String(i.getHours()).padStart(2, "0") +
    ":" +
    String(i.getMinutes()).padStart(2, "0") +
    ":" +
    String(i.getSeconds()).padStart(2, "0") +
    "." +
    (i.getMilliseconds() / 1e3).toFixed(3).slice(2, 5) +
    "Z"
  )
}
var Xvt = {
    DateTimeFormat(i, t) {
      try {
        return new Intl.DateTimeFormat(i, t)
      } catch {
        return new Intl.DateTimeFormat(void 0, t)
      }
    },
    Collator(i, t) {
      try {
        return new Intl.Collator(i, t)
      } catch {
        return new Intl.Collator(void 0, t)
      }
    },
    Segmenter(i, t) {
      try {
        return new Intl.Segmenter(i, t)
      } catch {
        return new Intl.Segmenter(void 0, t)
      }
    },
    Locale(i, t) {
      try {
        return new Intl.Locale(i, t)
      } catch {
        return new Intl.Locale(ts, t)
      }
    },
  },
  RX
;(function (i) {
  ;(i[(i.MAX_SAFE_SMALL_INTEGER = 1073741824)] = "MAX_SAFE_SMALL_INTEGER"),
    (i[(i.MIN_SAFE_SMALL_INTEGER = -1073741824)] = "MIN_SAFE_SMALL_INTEGER"),
    (i[(i.MAX_UINT_8 = 255)] = "MAX_UINT_8"),
    (i[(i.MAX_UINT_16 = 65535)] = "MAX_UINT_16"),
    (i[(i.MAX_UINT_32 = 4294967295)] = "MAX_UINT_32"),
    (i[(i.UNICODE_SUPPLEMENTARY_PLANE_BEGIN = 65536)] =
      "UNICODE_SUPPLEMENTARY_PLANE_BEGIN")
})(RX || (RX = {}))
function DX(i) {
  return i < 0 ? 0 : i > 255 ? 255 : i | 0
}
function Nc(i) {
  return i < 0 ? 0 : i > 4294967295 ? 4294967295 : i | 0
}
var FX = class Ynt {
    constructor(t) {
      const e = DX(t)
      ;(this.c = e), (this.a = Ynt.d(e)), (this.b = new Map())
    }
    static d(t) {
      const e = new Uint8Array(256)
      return e.fill(t), e
    }
    set(t, e) {
      const r = DX(e)
      t >= 0 && t < 256 ? (this.a[t] = r) : this.b.set(t, r)
    }
    get(t) {
      return t >= 0 && t < 256 ? this.a[t] : this.b.get(t) || this.c
    }
    clear() {
      this.a.fill(this.c), this.b.clear()
    }
  },
  _X
;(function (i) {
  ;(i[(i.False = 0)] = "False"), (i[(i.True = 1)] = "True")
})(_X || (_X = {}))
var AX
;(function (i) {
  ;(i[(i.Regular = 0)] = "Regular"),
    (i[(i.Whitespace = 1)] = "Whitespace"),
    (i[(i.WordSeparator = 2)] = "WordSeparator")
})(AX || (AX = {}))
var Kvt = class extends FX {
    constructor(i, t) {
      super(0),
        (this.e = null),
        (this.f = null),
        (this.g = []),
        (this.intlSegmenterLocales = t),
        this.intlSegmenterLocales.length > 0
          ? (this.e = Xvt.Segmenter(this.intlSegmenterLocales, {
              granularity: "word",
            }))
          : (this.e = null)
      for (let e = 0, r = i.length; e < r; e++) this.set(i.charCodeAt(e), 2)
      this.set(32, 1), this.set(9, 1)
    }
    findPrevIntlWordBeforeOrAtOffset(i, t) {
      let e = null
      for (const r of this.h(i)) {
        if (r.index > t) break
        e = r
      }
      return e
    }
    findNextIntlWordAtOrAfterOffset(i, t) {
      for (const e of this.h(i)) if (!(e.index < t)) return e
      return null
    }
    h(i) {
      return this.e
        ? this.f === i
          ? this.g
          : ((this.f = i), (this.g = this.j(this.e.segment(i))), this.g)
        : []
    }
    j(i) {
      const t = []
      for (const e of i) this.k(e) && t.push(e)
      return t
    }
    k(i) {
      return !!i.isWordLike
    }
  },
  BX = new oB(10)
function Zvt(i, t) {
  const e = `${i}/${t.join(",")}`
  let r = BX.get(e)
  return r || ((r = new Kvt(i, t)), BX.set(e, r)), r
}
var L2
;(function (i) {
  ;(i[(i.Left = 1)] = "Left"),
    (i[(i.Center = 2)] = "Center"),
    (i[(i.Right = 4)] = "Right"),
    (i[(i.Full = 7)] = "Full")
})(L2 || (L2 = {}))
var OX
;(function (i) {
  ;(i[(i.Left = 1)] = "Left"),
    (i[(i.Center = 2)] = "Center"),
    (i[(i.Right = 3)] = "Right")
})(OX || (OX = {}))
var qX
;(function (i) {
  ;(i[(i.Inline = 1)] = "Inline"), (i[(i.Gutter = 2)] = "Gutter")
})(qX || (qX = {}))
var UX
;(function (i) {
  ;(i[(i.Normal = 1)] = "Normal"), (i[(i.Underlined = 2)] = "Underlined")
})(UX || (UX = {}))
var MX
;(function (i) {
  ;(i[(i.Both = 0)] = "Both"),
    (i[(i.Right = 1)] = "Right"),
    (i[(i.Left = 2)] = "Left"),
    (i[(i.None = 3)] = "None")
})(MX || (MX = {}))
var HX
;(function (i) {
  ;(i[(i.TextDefined = 0)] = "TextDefined"),
    (i[(i.LF = 1)] = "LF"),
    (i[(i.CRLF = 2)] = "CRLF")
})(HX || (HX = {}))
var WX
;(function (i) {
  ;(i[(i.LF = 1)] = "LF"), (i[(i.CRLF = 2)] = "CRLF")
})(WX || (WX = {}))
var jX
;(function (i) {
  ;(i[(i.LF = 0)] = "LF"), (i[(i.CRLF = 1)] = "CRLF")
})(jX || (jX = {}))
var R2 = class {
    constructor(i, t) {
      ;(this._findMatchBrand = void 0), (this.range = i), (this.matches = t)
    }
  },
  VX
;(function (i) {
  ;(i[(i.AlwaysGrowsWhenTypingAtEdges = 0)] = "AlwaysGrowsWhenTypingAtEdges"),
    (i[(i.NeverGrowsWhenTypingAtEdges = 1)] = "NeverGrowsWhenTypingAtEdges"),
    (i[(i.GrowsOnlyWhenTypingBefore = 2)] = "GrowsOnlyWhenTypingBefore"),
    (i[(i.GrowsOnlyWhenTypingAfter = 3)] = "GrowsOnlyWhenTypingAfter")
})(VX || (VX = {}))
var GX
;(function (i) {
  ;(i[(i.Left = 0)] = "Left"),
    (i[(i.Right = 1)] = "Right"),
    (i[(i.None = 2)] = "None"),
    (i[(i.LeftOfInjectedText = 3)] = "LeftOfInjectedText"),
    (i[(i.RightOfInjectedText = 4)] = "RightOfInjectedText")
})(GX || (GX = {}))
var zX
;(function (i) {
  i[(i.FIRST_LINE_DETECTION_LENGTH_LIMIT = 1e3)] =
    "FIRST_LINE_DETECTION_LENGTH_LIMIT"
})(zX || (zX = {}))
var t1t = class {
    constructor(i, t, e) {
      ;(this.regex = i), (this.wordSeparators = t), (this.simpleSearch = e)
    }
  },
  e1t = class {
    constructor(i, t, e) {
      ;(this.reverseEdits = i),
        (this.changes = t),
        (this.trimAutoWhitespaceLineNumbers = e)
    }
  },
  YX = class {
    constructor(i, t, e, r) {
      ;(this.searchString = i),
        (this.isRegex = t),
        (this.matchCase = e),
        (this.wordSeparators = r)
    }
    parseSearchRequest() {
      if (this.searchString === "") return null
      let i
      this.isRegex
        ? (i = QX(this.searchString))
        : (i =
            this.searchString.indexOf(`
`) >= 0)
      let t = null
      try {
        t = bot(this.searchString, this.isRegex, {
          matchCase: this.matchCase,
          wholeWord: !1,
          multiline: i,
          global: !0,
          unicode: !0,
        })
      } catch {
        return null
      }
      if (!t) return null
      let e = !this.isRegex && !i
      return (
        e &&
          this.searchString.toLowerCase() !== this.searchString.toUpperCase() &&
          (e = this.matchCase),
        new t1t(
          t,
          this.wordSeparators ? Zvt(this.wordSeparators, []) : null,
          e ? this.searchString : null,
        )
      )
    }
  }
function QX(i) {
  if (!i || i.length === 0) return !1
  for (let t = 0, e = i.length; t < e; t++) {
    const r = i.charCodeAt(t)
    if (r === 10) return !0
    if (r === 92) {
      if ((t++, t >= e)) break
      const s = i.charCodeAt(t)
      if (s === 110 || s === 114 || s === 87) return !0
    }
  }
  return !1
}
function XX(i, t, e) {
  if (!e) return new R2(i, null)
  const r = []
  for (let s = 0, a = t.length; s < a; s++) r[s] = t[s]
  return new R2(i, r)
}
function i1t(i, t, e, r, s) {
  if (r === 0) return !0
  const a = t.charCodeAt(r - 1)
  if (i.get(a) !== 0 || a === 13 || a === 10) return !0
  if (s > 0) {
    const o = t.charCodeAt(r)
    if (i.get(o) !== 0) return !0
  }
  return !1
}
function r1t(i, t, e, r, s) {
  if (r + s === e) return !0
  const a = t.charCodeAt(r + s)
  if (i.get(a) !== 0 || a === 13 || a === 10) return !0
  if (s > 0) {
    const o = t.charCodeAt(r + s - 1)
    if (i.get(o) !== 0) return !0
  }
  return !1
}
function KX(i, t, e, r, s) {
  return i1t(i, t, e, r, s) && r1t(i, t, e, r, s)
}
var n1t = class {
  constructor(i, t) {
    ;(this._wordSeparators = i), (this.a = t), (this.b = -1), (this.c = 0)
  }
  reset(i) {
    ;(this.a.lastIndex = i), (this.b = -1), (this.c = 0)
  }
  next(i) {
    const t = i.length
    let e
    do {
      if (this.b + this.c === t || ((e = this.a.exec(i)), !e)) return null
      const r = e.index,
        s = e[0].length
      if (r === this.b && s === this.c) {
        if (s === 0) {
          AW(i, t, this.a.lastIndex) > 65535
            ? (this.a.lastIndex += 2)
            : (this.a.lastIndex += 1)
          continue
        }
        return null
      }
      if (
        ((this.b = r),
        (this.c = s),
        !this._wordSeparators || KX(this._wordSeparators, i, t, r, s))
      )
        return e
    } while (e)
    return null
  }
}
function ZX(i) {
  return i.scheme !== Q.file && i.scheme !== Q.vscodeRemote
}
function s1t(i) {
  if (i.folders.length)
    return i.folders.every((t) => ZX(t.uri)) ? i.folders[0].uri : void 0
  if (i.configuration && ZX(i.configuration)) return i.configuration
}
function a1t(i) {
  return s1t(i)?.scheme
}
var o1t = x3,
  tK = Y("remoteAgentService"),
  Tqt = new (class {
    constructor() {
      ;(this.maxSampleCount = 5),
        (this.sampleDelay = 2e3),
        (this.initial = []),
        (this.maxInitialCount = 3),
        (this.average = []),
        (this.maxAverageCount = 100),
        (this.highLatencyMultiple = 2),
        (this.highLatencyMinThreshold = 500),
        (this.highLatencyMaxThreshold = 1500),
        (this.lastMeasurement = void 0)
    }
    get latency() {
      return this.lastMeasurement
    }
    async measure(i) {
      let t = 1 / 0
      for (let r = 0; r < this.maxSampleCount; r++) {
        const s = await i.getRoundTripTime()
        if (s === void 0) return
        ;(t = Math.min(t, s / 2)), await Kr(this.sampleDelay)
      }
      this.average.push(t),
        this.average.length > this.maxAverageCount && this.average.shift()
      let e
      return (
        this.initial.length < this.maxInitialCount
          ? this.initial.push(t)
          : (e = this.initial.reduce((r, s) => r + s, 0) / this.initial.length),
        (this.lastMeasurement = {
          initial: e,
          current: t,
          average:
            this.average.reduce((r, s) => r + s, 0) / this.average.length,
          high:
            typeof e > "u"
              ? !1
              : t > this.highLatencyMaxThreshold ||
                (t > this.highLatencyMinThreshold &&
                  t > e * this.highLatencyMultiple),
        }),
        this.lastMeasurement
      )
    }
  })(),
  D2,
  c1t = Y("pathService"),
  eK = (D2 = class {
    constructor(t, e, r, s) {
      ;(this.d = t),
        (this.e = e),
        (this.f = r),
        (this.g = s),
        (this.a = (async () => (await this.e.getEnvironment())?.os || Xat)()),
        (this.b = (async () => {
          const a = await this.e.getEnvironment()
          return (this.c = a?.userHome ?? t)
        })())
    }
    hasValidBasename(t, e, r) {
      return typeof e == "string" || typeof e > "u"
        ? this.a.then((s) => this.h(t, s, e))
        : this.h(t, e, r)
    }
    h(t, e, r) {
      return t.scheme === Q.file || t.scheme === Q.vscodeRemote
        ? Got(r ?? us(t), e === 1)
        : !0
    }
    get defaultUriScheme() {
      return D2.findDefaultUriScheme(this.f, this.g)
    }
    static findDefaultUriScheme(t, e) {
      if (t.remoteAuthority) return Q.vscodeRemote
      const r = a1t(e.getWorkspace())
      if (r) return r
      const s = e.getWorkspace().folders[0]
      if (s) return s.uri.scheme
      const a = e.getWorkspace().configuration
      return a ? a.scheme : Q.file
    }
    userHome(t) {
      return t?.preferLocal ? this.d : this.b
    }
    get resolvedUserHome() {
      return this.c
    }
    get path() {
      return this.a.then((t) => (t === 1 ? Fe : Ut))
    }
    async fileURI(t) {
      let e = ""
      if (
        ((await this.a) === 1 && (t = t.replace(/\\/g, "/")),
        t[0] === "/" && t[1] === "/")
      ) {
        const s = t.indexOf("/", 2)
        s === -1
          ? ((e = t.substring(2)), (t = "/"))
          : ((e = t.substring(2, s)), (t = t.substring(s) || "/"))
      }
      return S.from({
        scheme: Q.file,
        authority: e,
        path: t,
        query: "",
        fragment: "",
      })
    }
  })
eK = D2 = __decorate([__param(1, tK), __param(2, o1t), __param(3, KB)], eK)
function u1t(i) {
  return typeof i == "object" && "uri" in i && "pattern" in i
}
var iK = class {
  constructor(t, e, r, s, a, o) {
    ;(this.a = t),
      (this.b = e),
      (this.c = r),
      (this.d = s),
      (this.f = a),
      (this.g = o)
  }
  aiText(t, e, r = {}) {
    return { ...this.j(e?.map(ZB), r), type: 3, contentPattern: t }
  }
  text(t, e, r = {}) {
    t = this.h(t, r)
    const s = this.a.getValue(),
      a =
        e && e.some((c) => !this.a.getValue({ resource: c }).search.useRipgrep)
    return {
      ...this.j(e?.map(ZB), r),
      type: 2,
      contentPattern: t,
      previewOptions: r.previewOptions,
      maxFileSize: r.maxFileSize,
      usePCRE2: s.search.usePCRE2 || a || !1,
      surroundingContext: r.surroundingContext,
      userDisabledExcludesAndIgnoreFiles:
        r.disregardExcludeSettings && r.disregardIgnoreFiles,
    }
  }
  h(t, e) {
    const r = this.a.getValue()
    t.isRegExp && (t.pattern = t.pattern.replace(/\r?\n/g, "\\n"))
    const s = { ...t, wordSeparators: r.editor.wordSeparators }
    return (
      this.l(t, e) && (s.isCaseSensitive = !0),
      this.m(t) && (s.isMultiline = !0),
      e.notebookSearchConfig?.includeMarkupInput &&
        (s.notebookInfo || (s.notebookInfo = {}),
        (s.notebookInfo.isInNotebookMarkdownInput =
          e.notebookSearchConfig.includeMarkupInput)),
      e.notebookSearchConfig?.includeMarkupPreview &&
        (s.notebookInfo || (s.notebookInfo = {}),
        (s.notebookInfo.isInNotebookMarkdownPreview =
          e.notebookSearchConfig.includeMarkupPreview)),
      e.notebookSearchConfig?.includeCodeInput &&
        (s.notebookInfo || (s.notebookInfo = {}),
        (s.notebookInfo.isInNotebookCellInput =
          e.notebookSearchConfig.includeCodeInput)),
      e.notebookSearchConfig?.includeOutput &&
        (s.notebookInfo || (s.notebookInfo = {}),
        (s.notebookInfo.isInNotebookCellOutput =
          e.notebookSearchConfig.includeOutput)),
      s
    )
  }
  file(t, e = {}) {
    return {
      ...this.j(t, e),
      type: 1,
      filePattern: e.filePattern ? e.filePattern.trim() : e.filePattern,
      exists: e.exists,
      sortByScore: e.sortByScore,
      cacheKey: e.cacheKey,
      shouldGlobMatchFilePattern: e.shouldGlobSearch,
    }
  }
  i(t, e) {
    if (!t) return {}
    if (Array.isArray(t)) {
      if (((t = t.filter((r) => r.length > 0).map(S7)), !t.length)) return {}
    } else t = S7(t)
    return e
      ? this.parseSearchPaths(t)
      : { pattern: F2(...(Array.isArray(t) ? t : [t])) }
  }
  j(t = [], e = {}) {
    let r = Array.isArray(e.excludePattern)
      ? e.excludePattern.map((m) => m.pattern).flat()
      : e.excludePattern
    r = r?.length === 1 ? r[0] : r
    const s = this.i(e.includePattern, e.expandPatterns),
      a = this.i(r, e.expandPatterns),
      o = t.length > 1,
      c = (
        s.searchPaths && s.searchPaths.length
          ? s.searchPaths.map((m) => this.t(m, e, a))
          : t.map((m) => this.u(m, e, a, o))
      ).filter((m) => !!m),
      u = {
        _reason: e._reason,
        folderQueries: c,
        usingSearchPaths: !!(s.searchPaths && s.searchPaths.length),
        extraFileResources: e.extraFileResources,
        excludePattern: a.pattern,
        includePattern: s.pattern,
        onlyOpenEditors: e.onlyOpenEditors,
        maxResults: e.maxResults,
        onlyFileScheme: e.onlyFileScheme,
      }
    if (e.onlyOpenEditors) {
      const m = Ge(
        this.c.groups.flatMap((g) => g.editors.map((w) => w.resource)),
      )
      this.d.trace(
        "QueryBuilder#commonQuery - openEditor URIs",
        JSON.stringify(m),
      )
      const h = m.filter((g) => RY(u, g.fsPath)),
        p = this.k(h)
      return (
        this.d.trace(
          "QueryBuilder#commonQuery - openEditor Query",
          JSON.stringify(p),
        ),
        { ...u, ...p }
      )
    }
    const l =
      e.extraFileResources &&
      e.extraFileResources.filter((m) => RY(u, m.fsPath))
    return (u.extraFileResources = l && l.length ? l : void 0), u
  }
  k(t) {
    const e = [],
      r = new ei(),
      s = {}
    let a = !1
    return (
      t.forEach((o) => {
        if (o.scheme === Q.walkThrough) return
        if (sct(o)) {
          const u =
            this.b.getWorkspaceFolder(o)?.uri ?? this.g.extUri.dirname(o)
          let l = r.get(u)
          l ||
            ((a = !0),
            (l = { folder: u, includePattern: {} }),
            e.push(l),
            r.set(u, l))
          const m = Cu(u.fsPath, o.fsPath)
          fo(l.includePattern)[m.replace(/\\/g, "/")] = !0
        } else o.fsPath && ((a = !0), (s[o.fsPath] = !0))
      }),
      {
        folderQueries: e,
        includePattern: s,
        usingSearchPaths: !0,
        excludePattern: a ? void 0 : { "**/*": !0 },
      }
    )
  }
  l(t, e) {
    if (e.isSmartCase) {
      if (t.isRegExp) {
        if (UW(t.pattern, !0)) return !0
      } else if (UW(t.pattern)) return !0
    }
    return !!t.isCaseSensitive
  }
  m(t) {
    return t.isMultiline ||
      (t.isRegExp && QX(t.pattern)) ||
      t.pattern.indexOf(`
`) >= 0
      ? !0
      : !!t.isMultiline
  }
  parseSearchPaths(t) {
    const e = (h) => t_(h) || /^\.\.?([\/\\]|$)/.test(h),
      s = (Array.isArray(t) ? t : d1t(t)).map((h) => {
        const p = this.f.resolvedUserHome
        return p ? Gvt(h, p.scheme === Q.file ? p.fsPath : p.path) : h
      }),
      a = RH(s, (h) => (e(h) ? "searchPaths" : "exprSegments")),
      o = (a.exprSegments || [])
        .map((h) => IB(h, "/"))
        .map((h) => IB(h, "\\"))
        .map((h) => (h[0] === "." && (h = "*" + h), m1t(h))),
      c = {},
      u = this.o(a.searchPaths || [])
    u && u.length && (c.searchPaths = u)
    const l = o.flat(),
      m = F2(...l)
    return m && (c.pattern = m), c
  }
  n(t, e) {
    return e.disregardExcludeSettings
      ? void 0
      : Qmt(t, !e.disregardSearchExcludeSettings)
  }
  o(t) {
    if (!t || !t.length) return []
    const e = t.flatMap((s) => {
        let { pathPortion: a, globPortion: o } = l1t(s)
        return o && (o = _2(o)), this.q(a).flatMap((u) => this.r(u, o))
      }),
      r = new Map()
    return (
      e.forEach((s) => {
        const a = s.searchPath.toString(),
          o = r.get(a)
        o
          ? s.pattern &&
            ((o.pattern = o.pattern || {}), (o.pattern[s.pattern] = !0))
          : r.set(a, {
              searchPath: s.searchPath,
              pattern: s.pattern ? F2(s.pattern) : void 0,
            })
      }),
      Array.from(r.values())
    )
  }
  q(t) {
    if (t_(t)) {
      const e = this.b.getWorkspace().folders
      return e[0] && e[0].uri.scheme !== Q.file
        ? [{ searchPath: e[0].uri.with({ path: t }) }]
        : [{ searchPath: S.file(lo(t)) }]
    }
    if (this.b.getWorkbenchState() === 2) {
      const e = this.b.getWorkspace().folders[0].uri
      if (((t = S7(t)), t.startsWith("../") || t === "..")) {
        const s = Ut.resolve(e.path, t)
        return [{ searchPath: e.with({ path: s }) }]
      }
      const r = _2(t)
      return [{ searchPath: e, pattern: r }]
    } else {
      if (t === "./" || t === ".\\") return []
      {
        const e = t.replace(/^\.[\/\\]/, ""),
          s = this.b
            .getWorkspace()
            .folders.map((a) => {
              const o = e.match(new RegExp(`^${Ks(a.name)}(?:/(.*)|$)`))
              return o ? { match: o, folder: a } : null
            })
            .filter(ta)
        if (s.length)
          return s.map((a) => {
            const o = a.match[1]
            return { searchPath: a.folder.uri, pattern: o && _2(o) }
          })
        {
          const a = t.match(/\.[\/\\](.+)[\/\\]?/),
            o = a ? a[1] : t,
            c = f(13193, null, o)
          throw new Error(c)
        }
      }
    }
  }
  r(t, e) {
    const r = t.pattern && e ? `${t.pattern}/${e}` : t.pattern || e,
      s = [{ searchPath: t.searchPath, pattern: r }]
    return (
      r &&
        !r.endsWith("**") &&
        s.push({ searchPath: t.searchPath, pattern: r + "/**" }),
      s
    )
  }
  t(t, e, r) {
    const s = this.u(ZB(t.searchPath), e, r, !1)
    return s ? { ...s, includePattern: t.pattern } : null
  }
  u(t, e, r, s) {
    let a
    const o = S.isUri(t) ? t : t.uri
    let c = e.excludePattern?.map((g) => {
      const w = e.excludePattern && u1t(g) ? g.uri : void 0
      return !w || !(S.isUri(t) && this.g.extUri.isEqual(t, w)) ? w : void 0
    })
    if ((c?.length || (c = [void 0]), r.searchPaths)) {
      const g = r.searchPaths.filter((w) => KW(w.searchPath, o))[0]
      if (g && !g.pattern) return null
      g && (a = g.pattern)
    }
    const u = this.a.getValue({ resource: o }),
      m = { ...(this.n(u, e) || {}), ...(a || {}) },
      h = S.isUri(t) ? us(t) : t.name,
      p = c
        .map((g) =>
          Object.keys(m).length > 0 ? { folder: g, pattern: m } : void 0,
        )
        .filter((g) => g)
    return {
      folder: o,
      folderName: s ? h : void 0,
      excludePattern: p,
      fileEncoding: u.files && u.files.encoding,
      disregardIgnoreFiles:
        typeof e.disregardIgnoreFiles == "boolean"
          ? e.disregardIgnoreFiles
          : !u.search.useIgnoreFiles,
      disregardGlobalIgnoreFiles:
        typeof e.disregardGlobalIgnoreFiles == "boolean"
          ? e.disregardGlobalIgnoreFiles
          : !u.search.useGlobalIgnoreFiles,
      disregardParentIgnoreFiles:
        typeof e.disregardParentIgnoreFiles == "boolean"
          ? e.disregardParentIgnoreFiles
          : !u.search.useParentIgnoreFiles,
      ignoreSymlinks:
        typeof e.ignoreSymlinks == "boolean"
          ? e.ignoreSymlinks
          : !u.search.followSymlinks,
    }
  }
}
iK = __decorate(
  [
    __param(0, $_),
    __param(1, KB),
    __param(2, amt),
    __param(3, Kt),
    __param(4, c1t),
    __param(5, WG),
  ],
  iK,
)
function l1t(i) {
  const t = i.match(/[\*\{\}\(\)\[\]\?]/)
  if (t) {
    const e = t.index,
      r = i.substr(0, e).match(/[/|\\][^/\\]*$/)
    if (r) {
      let s = i.substr(0, r.index)
      return (
        s.match(/[/\\]/) || (s += "/"),
        { pathPortion: s, globPortion: i.substr((r.index || 0) + 1) }
      )
    }
  }
  return { pathPortion: i }
}
function F2(...i) {
  return i.length
    ? i.reduce((t, e) => ((t[e] = !0), t), Object.create(null))
    : void 0
}
function d1t(i) {
  return C3(i, ",")
    .map((t) => t.trim())
    .filter((t) => !!t.length)
}
function m1t(i) {
  return [`**/${i}/**`, `**/${i}`].map((e) => e.replace(/\*\*\/\*\*/g, "**"))
}
function S7(i) {
  return i.replace(/\\/g, "/")
}
function _2(i) {
  return S7(i).replace(/^\.\//, "").replace(/\/+$/g, "")
}
var h1t = 7e3
function f1t(i, t) {
  const e = t.activationEvents
  if (!e) return Promise.resolve(void 0)
  const r = [],
    s = []
  for (const m of e)
    if (/^workspaceContains:/.test(m)) {
      const h = m.substr(18)
      h.indexOf("*") >= 0 || h.indexOf("?") >= 0 || i.forceUsingSearch
        ? s.push(h)
        : r.push(h)
    }
  if (r.length === 0 && s.length === 0) return Promise.resolve(void 0)
  const { promise: a, resolve: o } = uct(),
    c = (m) => o({ activationEvent: m }),
    u = Promise.all(r.map((m) => p1t(i, m, c))).then(() => {}),
    l = g1t(i, t.identifier, s, c)
  return (
    Promise.all([u, l]).then(() => {
      o(void 0)
    }),
    a
  )
}
async function p1t(i, t, e) {
  for (const r of i.folders)
    if (await i.exists(Ti(S.revive(r), t))) {
      e(`workspaceContains:${t}`)
      return
    }
}
async function g1t(i, t, e, r) {
  if (e.length === 0) return Promise.resolve(void 0)
  const s = new Ie(),
    a = i.checkExists(i.folders, e, s.token),
    o = setTimeout(async () => {
      s.cancel(),
        i.logService.info(
          `Not activating extension '${t.value}': Timed out while searching for 'workspaceContains' pattern ${e.join(",")}`,
        )
    }, h1t)
  let c = !1
  try {
    c = await a
  } catch (u) {
    Xn(u) || Ui(u)
  }
  s.dispose(), clearTimeout(o), c && r(`workspaceContains:${e.join(",")}`)
}
var rK = class {
    constructor(i) {
      ;(this.b = new C()),
        (this.onDidChangePassword = this.b.event),
        (this.a = i.getProxy(z.MainThreadSecretState))
    }
    async $onDidChangePassword(i) {
      this.b.fire(i)
    }
    get(i, t) {
      return this.a.$getPassword(i, t)
    }
    store(i, t, e) {
      return this.a.$setPassword(i, t, e)
    }
    delete(i, t) {
      return this.a.$deletePassword(i, t)
    }
  },
  A2 = Y("IExtHostSecretState"),
  v1t = class {
    #t
    constructor(i, t) {
      ;(this.disposables = new bt()),
        (this.a = te.toKey(i.identifier)),
        (this.#t = t),
        (this.onDidChange = Ee.map(
          Ee.filter(
            this.#t.onDidChangePassword,
            (e) => e.extensionId === this.a,
          ),
          (e) => ({ key: e.key }),
          this.disposables,
        ))
    }
    dispose() {
      this.disposables.dispose()
    }
    get(i) {
      return this.#t.get(this.a, i)
    }
    store(i, t) {
      return this.#t.store(this.a, i, t)
    }
    delete(i) {
      return this.#t.delete(this.a, i)
    }
  },
  B2 = class {
    constructor(t, e, r) {
      ;(this.f = r),
        (this.d = new Map()),
        (this.a = e.getProxy(z.MainThreadLocalization)),
        (this.b = t.environment.appLanguage),
        (this.c = this.b === ts)
    }
    getMessage(t, e) {
      const { message: r, args: s, comment: a } = e
      if (this.c) return LW(r, s ?? {})
      let o = r
      a && a.length > 0 && (o += `/${Array.isArray(a) ? a.join("") : a}`)
      const c = this.d.get(t)?.contents[o]
      return (
        c ||
          this.f.warn(
            `Using default string since no string found in i18n bundle that has the key: ${o}`,
          ),
        LW(c ?? r, s ?? {})
      )
    }
    getBundle(t) {
      return this.d.get(t)?.contents
    }
    getBundleUri(t) {
      return this.d.get(t)?.uri
    }
    async initializeLocalizedMessages(t) {
      if (this.c || (!t.l10n && !t.isBuiltin) || this.d.has(t.identifier.value))
        return
      let e
      const r = await this.g(t)
      if (!r) {
        this.f.error(
          `No bundle location found for extension ${t.identifier.value}`,
        )
        return
      }
      try {
        const s = await this.a.$fetchBundleContents(r),
          a = JSON.parse(s)
        e = t.isBuiltin ? a.contents?.bundle : a
      } catch (s) {
        this.f.error(
          `Failed to load translations for ${t.identifier.value} from ${r}: ${s.message}`,
        )
        return
      }
      e && this.d.set(t.identifier.value, { contents: e, uri: r })
    }
    async g(t) {
      if (t.isBuiltin) {
        const e = await this.a.$fetchBuiltInBundleUri(
          t.identifier.value,
          this.b,
        )
        return S.revive(e)
      }
      return t.l10n
        ? S.joinPath(t.extensionLocation, t.l10n, `bundle.l10n.${this.b}.json`)
        : void 0
    }
  }
B2 = __decorate([__param(0, ci), __param(1, Vt), __param(2, Kt)], B2)
var O2 = Y("IExtHostLocalizationService"),
  q2 = Y("IExtHostManagedSockets"),
  U2 = class {
    constructor(t) {
      ;(this.b = 0),
        (this.c = null),
        (this.d = new Map()),
        (this.a = t.getProxy(z.MainThreadManagedSockets))
    }
    setFactory(t, e) {
      for (const r of this.d.values()) r.dispose()
      this.c && this.a.$unregisterSocketFactory(this.c.socketFactoryId),
        (this.c = new w1t(t, e)),
        this.a.$registerSocketFactory(this.c.socketFactoryId)
    }
    async $openRemoteSocket(t) {
      if (!this.c || this.c.socketFactoryId !== t)
        throw new Error(`No socket factory with id ${t}`)
      const e = ++this.b,
        r = await this.c.makeConnection(),
        s = new bt()
      return (
        this.d.set(e, new y1t(e, r, s)),
        s.add(it(() => this.d.delete(e))),
        s.add(
          r.onDidEnd(() => {
            this.a.$onDidManagedSocketEnd(e), s.dispose()
          }),
        ),
        s.add(
          r.onDidClose((a) => {
            this.a.$onDidManagedSocketClose(e, a?.stack ?? a?.message),
              s.dispose()
          }),
        ),
        s.add(
          r.onDidReceiveMessage((a) =>
            this.a.$onDidManagedSocketHaveData(e, Et.wrap(a)),
          ),
        ),
        e
      )
    }
    $remoteSocketWrite(t, e) {
      this.d.get(t)?.actual.send(e.buffer)
    }
    $remoteSocketEnd(t) {
      const e = this.d.get(t)
      e && (e.actual.end(), e.dispose())
    }
    async $remoteSocketDrain(t) {
      await this.d.get(t)?.actual.drain?.()
    }
  }
U2 = __decorate([__param(0, Vt)], U2)
var w1t = class {
    constructor(i, t) {
      ;(this.socketFactoryId = i), (this.makeConnection = t)
    }
  },
  y1t = class extends dt {
    constructor(i, t, e) {
      super(), (this.socketId = i), (this.actual = t), this.D(e)
    }
  },
  M2,
  nK = Y("IHostUtils"),
  H2 = (M2 = class extends dt {
    constructor(t, e, r, s, a, o, c, u, l, m, h, p, g) {
      super(),
        (this.Y = p),
        (this.Z = g),
        (this.a = this.D(new C())),
        (this.onDidChangeRemoteConnectionData = this.a.event),
        (this.R = new Map()),
        (this.W = !1),
        (this.ib = !1),
        (this.c = e),
        (this.g = r),
        (this.f = c),
        (this.j = s),
        (this.m = a),
        (this.q = o),
        (this.s = l),
        (this.t = m),
        (this.u = h),
        (this.w = this.g.getProxy(z.MainThreadWorkspace)),
        (this.y = this.g.getProxy(z.MainThreadTelemetry)),
        (this.z = this.g.getProxy(z.MainThreadExtensionService)),
        (this.C = new Xr()),
        (this.F = new Xr()),
        (this.G = new Xr()),
        (this.H = new Xr()),
        (this.I = new k1t(this.f.extensions.activationEvents)),
        (this.L = new Ad(this.I, this.f.extensions.allExtensions))
      const w = new la(this.f.extensions.myExtensions)
      ;(this.J = new Ad(this.I, oK(this.L, w))),
        Qs &&
          (this.q.info(
            `Creating extension host with the following global extensions: ${$c(this.L)}`,
          ),
          this.q.info(
            `Creating extension host with the following local extensions: ${$c(this.J)}`,
          )),
        (this.M = new hX(this.g, this.q)),
        (this.N = new rK(this.g)),
        (this.O = u),
        (this.h = this.B.add(
          t.createChild(new YB([m2, this.M], [A2, this.N])),
        )),
        (this.P = this.D(
          new l2(
            this.J,
            this.L,
            {
              onExtensionActivationError: (T, b, N) => {
                this.z.$onExtensionActivationError(T, ku(b), N)
              },
              actualActivateExtension: async (T, b) => {
                if (Ad.isHostExtension(T, this.J, this.L))
                  return await this.z.$activateExtension(T, b), new Pvt()
                const N = this.J.getExtensionDescription(T)
                return this.fb(N, b)
              },
            },
            this.q,
          ),
        )),
        (this.Q = null),
        (this.S = Object.create(null)),
        (this.U = !1),
        (this.X = this.f.remote.connectionData)
    }
    getRemoteConnectionData() {
      return this.X
    }
    async initialize() {
      try {
        await this.wb(),
          this.C.open(),
          await this.j.waitForInitializeCall(),
          Pi("code/extHost/ready"),
          this.F.open(),
          this.f.autoStart && this.ub()
      } catch (t) {
        Ui(t)
      }
    }
    async $() {
      this.O.onWillDeactivateAll()
      let t = []
      try {
        t = this.J.getAllExtensionDescriptions()
          .map((a) => a.identifier)
          .filter((a) => this.isActivated(a))
          .map((a) => this.eb(a))
      } catch {}
      await Promise.all(t)
    }
    terminate(t, e = 0) {
      if (this.W) return
      ;(this.W = !0),
        this.q.info(`Extension host terminating: ${t}`),
        this.q.flush(),
        this.t.dispose(),
        this.P.dispose(),
        tB((s) => {
          this.q.error(s)
        }),
        this.g.dispose()
      const r = this.$()
      Promise.race([Kr(5e3), r]).finally(() => {
        this.c.pid
          ? this.q.info(
              `Extension host with pid ${this.c.pid} exiting with code ${e}`,
            )
          : this.q.info(`Extension host exiting with code ${e}`),
          this.q.flush(),
          this.q.dispose(),
          this.c.exit(e)
      })
    }
    isActivated(t) {
      return this.G.isOpen() ? this.P.isActivated(t) : !1
    }
    async getExtension(t) {
      const e = await this.z.$getExtension(t)
      return (
        e && {
          ...e,
          identifier: new te(e.identifier.value),
          extensionLocation: S.revive(e.extensionLocation),
        }
      )
    }
    ab(t, e) {
      return this.P.activateByEvent(t, e)
    }
    bb(t, e) {
      return this.P.activateById(t, e)
    }
    activateByIdWithErrors(t, e) {
      return this.bb(t, e).then(() => {
        const r = this.P.getActivatedExtension(t)
        if (r.activationFailed) return Promise.reject(r.activationFailedError)
      })
    }
    getExtensionRegistry() {
      return this.G.wait().then((t) => this.J)
    }
    getExtensionExports(t) {
      if (this.G.isOpen()) return this.P.getActivatedExtension(t).exports
      try {
        return this.P.getActivatedExtension(t).exports
      } catch {
        return null
      }
    }
    async cb(t) {
      if (t.scheme === Q.file && this.c.fsRealpath) {
        const e = t.fsPath
        this.R.has(e) || this.R.set(e, this.c.fsRealpath(e))
        const r = await this.R.get(e)
        return S.file(r)
      }
      return t
    }
    async getExtensionPathIndex() {
      return (
        this.Q ||
          (this.Q = this.db(this.J.getAllExtensionDescriptions()).then(
            (t) => new T1t(t),
          )),
        this.Q
      )
    }
    async db(t) {
      const e = ls.forUris((r) => rct.ignorePathCasing(r))
      return (
        await Promise.all(
          t.map(async (r) => {
            if (this.xb(r)) {
              const s = await this.cb(r.extensionLocation)
              e.set(s, r)
            }
          }),
        ),
        e
      )
    }
    eb(t) {
      let e = Promise.resolve(void 0)
      if (!this.G.isOpen() || !this.P.isActivated(t)) return e
      const r = this.P.getActivatedExtension(t)
      if (!r) return e
      try {
        typeof r.module.deactivate == "function" &&
          (e = Promise.resolve(r.module.deactivate()).then(
            void 0,
            (s) => (this.q.error(s), Promise.resolve(void 0)),
          ))
      } catch (s) {
        this.q.error(
          `An error occurred when deactivating the extension '${t.value}':`,
        ),
          this.q.error(s)
      }
      try {
        r.disposable.dispose()
      } catch (s) {
        this.q.error(
          `An error occurred when disposing the subscriptions for extension '${t.value}':`,
        ),
          this.q.error(s)
      }
      return e
    }
    async fb(t, e) {
      return (
        this.f.remote.isRemote
          ? this.z.$onWillActivateExtension(t.identifier)
          : await this.z.$onWillActivateExtension(t.identifier),
        this.hb(t, e).then(
          (r) => {
            const s = r.activationTimes
            return (
              this.z.$onDidActivateExtension(
                t.identifier,
                s.codeLoadingTime,
                s.activateCallTime,
                s.activateResolvedTime,
                e,
              ),
              this.gb(t, e, "success", s),
              r
            )
          },
          (r) => {
            throw (this.gb(t, e, "failure"), r)
          },
        )
      )
    }
    gb(t, e, r, s) {
      const a = aK(t, e)
      this.y.$publicLog2("extensionActivationTimes", {
        ...a,
        ...(s || {}),
        outcome: r,
      })
    }
    hb(t, e) {
      const r = aK(t, e)
      this.y.$publicLog2("activatePlugin", r)
      const s = this.xb(t)
      if (!s) return Promise.resolve(new Ivt(g7.NONE))
      this.q.info(
        `ExtensionService#_doActivateExtension ${t.identifier.value}, startup: ${e.startup}, activationEvent: '${e.activationEvent}'${t.identifier.value !== e.extensionId.value ? `, root cause: ${e.extensionId.value}` : ""}`,
      ),
        this.q.flush()
      const a = new bt(),
        o = new mX(e.startup)
      return Promise.all([
        this.yb(t, Ti(t.extensionLocation, s), o),
        this.jb(t, a),
      ])
        .then(
          (c) => (
            Pi(`code/extHost/willActivateExtension/${t.identifier.value}`),
            M2.kb(this.q, t.identifier, c[0], c[1], a, o)
          ),
        )
        .then(
          (c) => (
            Pi(`code/extHost/didActivateExtension/${t.identifier.value}`), c
          ),
        )
    }
    jb(t, e) {
      const r = this.Z.createLanguageModelAccessInformation(t),
        s = e.add(new Nvt(t, this.M)),
        a = e.add(new fX(t.identifier.value, !1, this.M)),
        o = e.add(new v1t(t, this.N)),
        c = t.isUnderDevelopment
          ? this.f.environment.extensionTestsLocationURI
            ? Ko.Test
            : Ko.Development
          : Ko.Production,
        u = this.f.remote.isRemote ? Na.Workspace : Na.UI
      return (
        this.q.trace(
          `ExtensionService#loadExtensionContext ${t.identifier.value}`,
        ),
        Promise.all([s.whenReady, a.whenReady, this.O.whenReady]).then(() => {
          const l = this
          let m, h
          const p = Qe(t, "ipc")
            ? this.f.messagePorts?.get(te.toKey(t.identifier))
            : void 0
          return Object.freeze({
            globalState: s,
            workspaceState: a,
            secrets: o,
            subscriptions: [],
            get languageModelAccessInformation() {
              return r
            },
            get extensionUri() {
              return t.extensionLocation
            },
            get extensionPath() {
              return t.extensionLocation.fsPath
            },
            asAbsolutePath(g) {
              return kB(t.extensionLocation.fsPath, g)
            },
            get storagePath() {
              return l.O.workspaceValue(t)?.fsPath
            },
            get globalStoragePath() {
              return l.O.globalValue(t).fsPath
            },
            get logPath() {
              return kB(l.f.logsLocation.fsPath, t.identifier.value)
            },
            get logUri() {
              return S.joinPath(l.f.logsLocation, t.identifier.value)
            },
            get storageUri() {
              return l.O.workspaceValue(t)
            },
            get globalStorageUri() {
              return l.O.globalValue(t)
            },
            get extensionMode() {
              return c
            },
            get extension() {
              return m === void 0 && (m = new qd(l, t.identifier, t, u, !1)), m
            },
            get extensionRuntime() {
              return F(t, "extensionRuntime"), l.extensionRuntime
            },
            get environmentVariableCollection() {
              return l.t.getEnvironmentVariableCollection(t)
            },
            get messagePassingProtocol() {
              if (!h) {
                if (!p) return
                const g = Ee.buffer(
                  Ee.fromDOMEventEmitter(p, "message", (w) => w.data),
                )
                p.start(),
                  (h = {
                    onDidReceiveMessage: g,
                    postMessage: p.postMessage.bind(p),
                  })
              }
              return h
            },
            get isDevelopment() {
              return l.ib
            },
          })
        })
      )
    }
    static kb(t, e, r, s, a, o) {
      return (
        (r = r || { activate: void 0, deactivate: void 0 }),
        this.lb(t, e, r, s, o).then(
          (c) =>
            new v7(
              !1,
              null,
              o.build(),
              r,
              c,
              it(() => {
                a.dispose(), pn(s.subscriptions)
              }),
            ),
        )
      )
    }
    static lb(t, e, r, s, a) {
      if (typeof r.activate == "function")
        try {
          a.activateCallStart(),
            t.trace(`ExtensionService#_callActivateOptional ${e.value}`)
          const o = typeof global == "object" ? global : self,
            c = r.activate.apply(o, [s])
          return (
            a.activateCallStop(),
            a.activateResolveStart(),
            Promise.resolve(c).then((u) => (a.activateResolveStop(), u))
          )
        } catch (o) {
          return Promise.reject(o)
        }
      else return Promise.resolve(r)
    }
    mb(t, e) {
      this.bb(t.identifier, {
        startup: !1,
        extensionId: t.identifier,
        activationEvent: e,
      }).then(void 0, (r) => {
        this.q.error(r)
      })
    }
    nb(t, e = 0) {
      const s = Date.now()
      sW(() => {
        for (let a = e; a < t.length; a += 1) {
          const o = t[a]
          for (const c of o.activationEvents ?? [])
            if (c === "onStartupFinished")
              if (Date.now() - s > 50) {
                this.nb(t, a)
                break
              } else this.mb(o, c)
        }
      })
    }
    ob() {
      this.z.$setPerformanceMarks(Oat()),
        this.m.getConfigProvider().then((t) => {
          const e = t
              .getConfiguration("extensions.experimental")
              .get("deferredStartupFinishedActivation"),
            r = this.J.getAllExtensionDescriptions()
          if (e) this.nb(r)
          else
            for (const s of r)
              if (s.activationEvents)
                for (const a of s.activationEvents)
                  a === "onStartupFinished" && this.mb(s, a)
        })
    }
    pb() {
      const t = this.ab("*", !0).then(void 0, (o) => {
        this.q.error(o)
      })
      this.D(this.j.onDidChangeWorkspace((o) => this.qb(o.added)))
      const e = this.j.workspace ? this.j.workspace.folders : [],
        r = this.qb(e),
        s = this.sb(),
        a = Promise.all([s, t, r]).then(() => {})
      return (
        Promise.race([a, Kr(1e4)]).then(() => {
          this.ob()
        }),
        a
      )
    }
    qb(t) {
      return t.length === 0
        ? Promise.resolve(void 0)
        : Promise.all(
            this.J.getAllExtensionDescriptions().map((e) => this.rb(t, e)),
          ).then(() => {})
    }
    async rb(t, e) {
      if (this.isActivated(e.identifier)) return
      const r = !this.f.remote.isRemote && !!this.f.remote.authority,
        s = {
          logService: this.q,
          folders: t.map((o) => o.uri),
          forceUsingSearch: r || !this.c.fsExists,
          exists: (o) => this.c.fsExists(o.fsPath),
          checkExists: (o, c, u) => this.w.$checkExists(o, c, u),
        },
        a = await f1t(s, e)
      if (a)
        return this.bb(e.identifier, {
          startup: !0,
          extensionId: e.identifier,
          activationEvent: a.activationEvent,
        }).then(void 0, (o) => this.q.error(o))
    }
    async sb() {
      if (this.f.remote.authority)
        return this.ab(
          `onResolveRemoteAuthority:${this.f.remote.authority}`,
          !1,
        )
    }
    async $extensionTestsExecute() {
      await this.H.wait()
      try {
        return await this.tb()
      } catch (t) {
        throw (console.error(t), t)
      }
    }
    async tb() {
      const {
        extensionDevelopmentLocationURI: t,
        extensionTestsLocationURI: e,
      } = this.f.environment
      if (!t || !e) throw new Error(f(2758, null))
      const r = await this.yb(null, e, new mX(!1))
      if (!r || typeof r.run != "function")
        throw new Error(f(2759, null, e.toString()))
      return new Promise((s, a) => {
        const o = (l, m) => {
            l
              ? (Qs && this.q.error("Test runner called back with error", l),
                a(l))
              : (Qs &&
                  (m
                    ? this.q.info(`Test runner called back with ${m} failures.`)
                    : this.q.info(
                        "Test runner called back with successful outcome.",
                      )),
                s(typeof m == "number" && m > 0 ? 1 : 0))
          },
          c = br(e),
          u = r.run(c, o)
        u &&
          u.then &&
          u
            .then(() => {
              Qs && this.q.info("Test runner finished successfully."), s(0)
            })
            .catch((l) => {
              Qs && this.q.error("Test runner finished with error", l),
                a(l instanceof Error && l.stack ? l.stack : String(l))
            })
      })
    }
    ub() {
      if (this.U) throw new Error("Extension host is already started!")
      return (
        (this.U = !0),
        this.F.wait()
          .then(() => this.G.open())
          .then(() =>
            Promise.race([this.P.waitForActivatingExtensions(), Kr(1e3)]),
          )
          .then(() => this.pb())
          .then(() => {
            this.H.open(), this.q.info("Eager extensions activated")
          })
      )
    }
    registerRemoteAuthorityResolver(t, e) {
      return (
        (this.S[t] = e),
        it(() => {
          delete this.S[t]
        })
      )
    }
    async getRemoteExecServer(t) {
      const { resolver: e } = await this.vb(t)
      return e?.resolveExecServer?.(t, { resolveAttempt: 0 })
    }
    async vb(t) {
      const e = t.indexOf("+")
      if (e === -1)
        throw new Ro(
          "Not an authority that can be resolved!",
          En.InvalidAuthority,
        )
      const r = t.substr(0, e)
      return (
        await this.C.wait(),
        await this.ab(`onResolveRemoteAuthority:${r}`, !1),
        { authorityPrefix: r, resolver: this.S[r] }
      )
    }
    async $resolveAuthority(t, e) {
      const r = Ys.create(!1),
        s = () => `[resolveAuthority(${Wz(t)},${e})][${r.elapsed()}ms] `,
        a = ($) => this.q.info(`${s()}${$}`),
        o = ($) => this.q.warn(`${s()}${$}`),
        c = ($, L = void 0) => this.q.error(`${s()}${$}`, L),
        u = ($) => {
          if ($ instanceof Ro)
            return {
              type: "error",
              error: { code: $._code, message: $._message, detail: $._detail },
            }
          throw $
        },
        l = async ($) => {
          a(`activating resolver for ${$}...`)
          const { resolver: L, authorityPrefix: U } = await this.vb($)
          if (!L)
            throw (
              (c(`no resolver for ${U}`),
              new Ro(
                `No remote extension installed to resolve ${U}.`,
                En.NoResolverFound,
              ))
            )
          return { resolver: L, authorityPrefix: U, remoteAuthority: $ }
        },
        m = t.split(/@|%40/g).reverse()
      a(`activating remote resolvers ${m.join(" -> ")}`)
      let h
      try {
        h = await Promise.all(m.map(l)).catch(async ($) => {
          if (!($ instanceof Ro) || $._code !== En.InvalidAuthority) throw $
          return (
            o(`resolving nested authorities failed: ${$.message}`), [await l(t)]
          )
        })
      } catch ($) {
        return u($)
      }
      const p = new yct()
      p.cancelAndSet(() => a("waiting..."), 1e3)
      let g, w
      for (const [
        $,
        { authorityPrefix: L, resolver: U, remoteAuthority: q },
      ] of h.entries())
        try {
          if ($ === h.length - 1)
            a("invoking final resolve()..."),
              Pi(`code/extHost/willResolveAuthority/${L}`),
              (g = await U.resolve(q, { resolveAttempt: e, execServer: w })),
              Pi(`code/extHost/didResolveAuthorityOK/${L}`),
              a("setting tunnel factory..."),
              this.D(
                await this.s.setTunnelFactory(
                  U,
                  r6.isManagedResolvedAuthority(g) ? g : void 0,
                ),
              )
          else {
            if (
              (a(`invoking resolveExecServer() for ${q}`),
              Pi(`code/extHost/willResolveExecServer/${L}`),
              (w = await U.resolveExecServer?.(q, {
                resolveAttempt: e,
                execServer: w,
              })),
              !w)
            )
              throw new Ro(
                `Exec server was not available for ${q}`,
                En.NoResolverFound,
              )
            Pi(`code/extHost/didResolveExecServerOK/${L}`)
          }
        } catch (V) {
          return (
            Pi(`code/extHost/didResolveAuthorityError/${L}`),
            c("returned an error", V),
            p.dispose(),
            u(V)
          )
        }
      p.dispose()
      const T = {
          environmentTunnels: g.environmentTunnels,
          features: g.tunnelFeatures
            ? {
                elevation: g.tunnelFeatures.elevation,
                privacyOptions: g.tunnelFeatures.privacyOptions,
                protocol:
                  g.tunnelFeatures.protocol === void 0
                    ? !0
                    : g.tunnelFeatures.protocol,
              }
            : void 0,
        },
        b = {
          extensionHostEnv: g.extensionHostEnv,
          isTrusted: g.isTrusted,
          authenticationSession:
            g.authenticationSessionForInitializingExtensions
              ? {
                  id: g.authenticationSessionForInitializingExtensions.id,
                  providerId:
                    g.authenticationSessionForInitializingExtensions.providerId,
                }
              : void 0,
        }
      a(
        `returned ${r6.isManagedResolvedAuthority(g) ? "managed authority" : `${g.host}:${g.port}`}`,
      )
      let N
      if (r6.isManagedResolvedAuthority(g)) {
        const $ = e
        this.Y.setFactory($, g.makeConnection),
          (N = {
            authority: t,
            connectTo: new vmt($),
            connectionToken: g.connectionToken,
          })
      } else
        N = {
          authority: t,
          connectTo: new wmt(g.host, g.port),
          connectionToken: g.connectionToken,
        }
      return {
        type: "ok",
        value: { authority: N, options: b, tunnelInformation: T },
      }
    }
    async $getCanonicalURI(t, e) {
      this.q.info(`$getCanonicalURI invoked for authority (${Wz(t)})`)
      const { resolver: r } = await this.vb(t)
      if (!r) return null
      const s = S.revive(e)
      if (typeof r.getCanonicalURI > "u") return s
      const a = await gi(() => r.getCanonicalURI(s))
      return a || s
    }
    async $startExtensionHost(t) {
      t.toAdd.forEach(
        (o) => (o.extensionLocation = S.revive(o.extensionLocation)),
      )
      const { globalRegistry: e, myExtensions: r } = sK(
          this.I,
          this.L,
          this.J,
          t,
        ),
        s = await this.db(r)
      return (
        (await this.getExtensionPathIndex()).setSearchTree(s),
        this.L.set(e.getAllExtensionDescriptions()),
        this.J.set(r),
        Qs &&
          (this.q.info(`$startExtensionHost: global extensions: ${$c(this.L)}`),
          this.q.info(`$startExtensionHost: local extensions: ${$c(this.J)}`)),
        this.ub()
      )
    }
    $activateByEvent(t, e) {
      return e === 1
        ? this.C.wait().then((r) => this.ab(t, !1))
        : this.G.wait().then((r) => this.ab(t, !1))
    }
    async $activate(t, e) {
      return (
        await this.G.wait(),
        this.J.getExtensionDescription(t) ? (await this.bb(t, e), !0) : !1
      )
    }
    async $deltaExtensions(t) {
      t.toAdd.forEach(
        (o) => (o.extensionLocation = S.revive(o.extensionLocation)),
      )
      const { globalRegistry: e, myExtensions: r } = sK(
          this.I,
          this.L,
          this.J,
          t,
        ),
        s = await this.db(r)
      return (
        (await this.getExtensionPathIndex()).setSearchTree(s),
        this.L.set(e.getAllExtensionDescriptions()),
        this.J.set(r),
        Qs &&
          (this.q.info(`$deltaExtensions: global extensions: ${$c(this.L)}`),
          this.q.info(`$deltaExtensions: local extensions: ${$c(this.J)}`)),
        Promise.resolve(void 0)
      )
    }
    async $test_latency(t) {
      return t
    }
    async $test_up(t) {
      return t.byteLength
    }
    async $test_down(t) {
      const e = Et.alloc(t),
        r = Math.random() % 256
      for (let s = 0; s < t; s++) e.writeUInt8(r, s)
      return e
    }
    async $updateRemoteConnectionData(t) {
      ;(this.X = t), this.a.fire()
    }
  })
H2 = M2 = __decorate(
  [
    __param(0, l_),
    __param(1, nK),
    __param(2, Vt),
    __param(3, _n),
    __param(4, An),
    __param(5, Kt),
    __param(6, ci),
    __param(7, f2),
    __param(8, y2),
    __param(9, Pc),
    __param(10, O2),
    __param(11, q2),
    __param(12, x2),
  ],
  H2,
)
function sK(i, t, e, r) {
  i.addActivationEvents(r.addActivationEvents)
  const s = new Ad(i, t.getAllExtensionDescriptions())
  s.deltaExtensions(r.toAdd, r.toRemove)
  const a = new la(e.getAllExtensionDescriptions().map((c) => c.identifier))
  for (const c of r.myToRemove) a.delete(c)
  for (const c of r.myToAdd) a.add(c)
  const o = oK(s, a)
  return { globalRegistry: s, myExtensions: o }
}
function aK(i, t) {
  return {
    id: i.identifier.value,
    name: i.name,
    extensionVersion: i.version,
    publisherDisplayName: i.publisher,
    activationEvents: i.activationEvents ? i.activationEvents.join(",") : null,
    isBuiltin: i.isBuiltin,
    reason: t.activationEvent,
    reasonId: t.extensionId.value,
  }
}
function $c(i) {
  return i
    .getAllExtensionDescriptions()
    .map((t) => t.identifier.value)
    .join(",")
}
var Fs = Y("IExtHostExtensionService"),
  qd = class {
    #t
    #e
    #i
    constructor(i, t, e, r, s) {
      ;(this.#t = i),
        (this.#e = t),
        (this.#i = e.identifier),
        (this.id = e.identifier.value),
        (this.extensionUri = e.extensionLocation),
        (this.extensionPath = lo(br(e.extensionLocation))),
        (this.packageJSON = e),
        (this.extensionKind = r),
        (this.isFromDifferentExtensionHost = s)
    }
    get isActive() {
      return this.#t.isActivated(this.#i)
    }
    get exports() {
      if (
        !(this.packageJSON.api === "none" || this.isFromDifferentExtensionHost)
      )
        return this.#t.getExtensionExports(this.#i)
    }
    async activate() {
      if (this.isFromDifferentExtensionHost)
        throw new Error("Cannot activate foreign extension")
      return (
        await this.#t.activateByIdWithErrors(this.#i, {
          startup: !1,
          extensionId: this.#e,
          activationEvent: "api",
        }),
        this.exports
      )
    }
  }
function oK(i, t) {
  return i.getAllExtensionDescriptions().filter((e) => t.has(e.identifier))
}
var T1t = class {
    constructor(i) {
      this.a = i
    }
    setSearchTree(i) {
      this.a = i
    }
    findSubstr(i) {
      return this.a.findSubstr(i)
    }
    forEach(i) {
      return this.a.forEach(i)
    }
  },
  k1t = class {
    constructor(i) {
      ;(this.a = new bn()), this.addActivationEvents(i)
    }
    readActivationEvents(i) {
      return this.a.get(i.identifier) ?? []
    }
    addActivationEvents(i) {
      for (const t of Object.keys(i)) this.a.set(t, i[t])
    }
  },
  cK = class {
    static async installEarlyHandler(i) {
      Error.stackTraceLimit = 100
      const t = i.get(Kt),
        r = i.get(Vt).getProxy(z.MainThreadErrors)
      tB((s) => {
        t.error(s)
        const a = ku(s)
        r.$onUnexpectedError(a)
      })
    }
    static async installFullHandler(i) {
      const t = i.get(Kt),
        e = i.get(Vt),
        r = i.get(Fs),
        s = i.get(T7),
        a = e.getProxy(z.MainThreadExtensionService),
        o = e.getProxy(z.MainThreadErrors),
        c = await r.getExtensionPathIndex(),
        u = new WeakMap()
      function l(p, g) {
        if (u.has(p)) return u.get(p).stack
        let w = "",
          T,
          b
        for (const $ of g)
          (w += `
	at ${$.toString()}`),
            (b = $.getFileName()),
            !T && b && (T = c.findSubstr(S.file(b)))
        const N = `${p.name || "Error"}: ${p.message || ""}${w}`
        return u.set(p, { extensionIdentifier: T?.identifier, stack: N }), N
      }
      const m = Symbol("prepareStackTrace wrapped")
      let h = l
      Object.defineProperty(Error, "prepareStackTrace", {
        configurable: !1,
        get() {
          return h
        },
        set(p) {
          if (p === l || !p || p[m]) {
            h = p || l
            return
          }
          ;(h = function (g, w) {
            return l(g, w), p.call(Error, g, w)
          }),
            Object.assign(h, { [m]: !0 })
        },
      }),
        tB((p) => {
          t.error(p)
          const g = ku(p),
            w = u.get(p)
          if (!w?.extensionIdentifier) {
            o.$onUnexpectedError(g)
            return
          }
          a.$onExtensionRuntimeError(w.extensionIdentifier, g)
          const T = s.onExtensionError(w.extensionIdentifier, p)
          t.trace("forwarded error to extension?", T, w)
        })
    }
  },
  S1t = class Qnt {
    constructor(t, e, r, s, a) {
      ;(this.a = r), (this.b = new $ct(t, null, s)), (e = Qnt.e(e, this.b))
      const o = new YB(...iut())
      o.set(ci, { _serviceBrand: void 0, ...e, messagePorts: a }),
        o.set(Vt, new aut(this.b)),
        o.set(m_, new out(s)),
        o.set(nK, r)
      const c = new sut(o, !0)
      c.invokeFunction(cK.installEarlyHandler),
        (this.d = c.invokeFunction((u) => u.get(Kt))),
        Pi("code/extHost/didCreateServices"),
        this.a.pid
          ? this.d.info(`Extension host with pid ${this.a.pid} started`)
          : this.d.info("Extension host started"),
        this.d.trace("initData", e),
        (this.c = c.invokeFunction((u) => u.get(Fs))),
        this.c.initialize(),
        c.invokeFunction(cK.installFullHandler)
    }
    async asBrowserUri(t) {
      const e = this.b.getProxy(z.MainThreadExtensionService)
      return S.revive(await e.$asBrowserUri(t))
    }
    terminate(t) {
      this.c.terminate(t)
    }
    static e(t, e) {
      t.extensions.allExtensions.forEach((s) => {
        s.extensionLocation = S.revive(
          e.transformIncomingURIs(s.extensionLocation),
        )
      }),
        (t.environment.appRoot = S.revive(
          e.transformIncomingURIs(t.environment.appRoot),
        ))
      const r = t.environment.extensionDevelopmentLocationURI
      return (
        r &&
          (t.environment.extensionDevelopmentLocationURI = r.map((s) =>
            S.revive(e.transformIncomingURIs(s)),
          )),
        (t.environment.extensionTestsLocationURI = S.revive(
          e.transformIncomingURIs(t.environment.extensionTestsLocationURI),
        )),
        (t.environment.globalStorageHome = S.revive(
          e.transformIncomingURIs(t.environment.globalStorageHome),
        )),
        (t.environment.workspaceStorageHome = S.revive(
          e.transformIncomingURIs(t.environment.workspaceStorageHome),
        )),
        (t.environment.extensionTelemetryLogResource = S.revive(
          e.transformIncomingURIs(t.environment.extensionTelemetryLogResource),
        )),
        (t.nlsBaseUrl = S.revive(e.transformIncomingURIs(t.nlsBaseUrl))),
        (t.logsLocation = S.revive(e.transformIncomingURIs(t.logsLocation))),
        (t.workspace = e.transformIncomingURIs(t.workspace)),
        t
      )
    }
  },
  b1t = function (t) {
    const e = (r) => {
      globalThis.removeEventListener("message", e)
      const s = r.data
      Object.defineProperties(globalThis, {
        postMessage: {
          value(a, o) {
            s.postMessage(a, o)
          },
        },
        onmessage: {
          get() {
            return s.onmessage
          },
          set(a) {
            s.onmessage = a
          },
        },
      }),
        s.addEventListener("message", (a) => {
          globalThis.dispatchEvent(
            new MessageEvent("message", {
              data: a.data,
              ports: a.ports ? [...a.ports] : void 0,
            }),
          )
        }),
        s.start(),
        (globalThis.Worker = class {
          constructor() {
            throw new TypeError(
              "Nested workers from within nested worker are NOT supported.",
            )
          }
        }),
        importScripts(t)
    }
    globalThis.addEventListener("message", e)
  }.toString(),
  E1t = class extends EventTarget {
    constructor(i, t, e) {
      super(),
        (this.onmessage = null),
        (this.onmessageerror = null),
        (this.onerror = null)
      const r = `((${b1t})('${t}'))`,
        s = new Blob([r], { type: "application/javascript" }),
        a = URL.createObjectURL(s),
        o = new MessageChannel(),
        c = a,
        u = { type: "_newWorker", id: c, port: o.port2, url: a, options: e }
      i(u, [o.port2]),
        (this.postMessage = o.port1.postMessage.bind(o.port1)),
        (this.terminate = () => {
          i({ type: "_terminateWorker", id: c }),
            URL.revokeObjectURL(a),
            o.port1.close(),
            o.port2.close()
        }),
        Object.defineProperties(this, {
          onmessage: {
            get() {
              return o.port1.onmessage
            },
            set(l) {
              o.port1.onmessage = l
            },
          },
          onmessageerror: {
            get() {
              return o.port1.onmessageerror
            },
            set(l) {
              o.port1.onmessageerror = l
            },
          },
        }),
        o.port1.addEventListener("messageerror", (l) => {
          const m = new MessageEvent("messageerror", { data: l.data })
          this.dispatchEvent(m)
        }),
        o.port1.addEventListener("message", (l) => {
          const m = new MessageEvent("message", { data: l.data })
          this.dispatchEvent(m)
        }),
        o.port1.start()
    }
  },
  Pqt = new H("inOutput", !1),
  Nqt = new H("activeLogOutput", !1),
  $qt = new H("activeLogOutput.levelSettable", !1),
  xqt = new H("activeLogOutput.level", ""),
  Jqt = new H("activeLogOutput.levelIsDefault", !1),
  Cqt = new H("outputView.scrollLock", !1),
  Lqt = Y("outputService"),
  Ud
;(function (i) {
  ;(i[(i.Append = 1)] = "Append"),
    (i[(i.Replace = 2)] = "Replace"),
    (i[(i.Clear = 3)] = "Clear")
})(Ud || (Ud = {}))
var I1t = { OutputChannels: "workbench.contributions.outputChannels" },
  P1t = class {
    constructor() {
      ;(this.a = new Map()),
        (this.b = new C()),
        (this.onDidRegisterChannel = this.b.event),
        (this.c = new C()),
        (this.onDidRemoveChannel = this.c.event)
    }
    registerChannel(i) {
      this.a.has(i.id) || (this.a.set(i.id, i), this.b.fire(i.id))
    }
    getChannels() {
      const i = []
      return this.a.forEach((t) => i.push(t)), i
    }
    getChannel(i) {
      return this.a.get(i)
    }
    removeChannel(i) {
      this.a.delete(i), this.c.fire(i)
    }
  }
ui.add(I1t.OutputChannels, new P1t())
var Rqt = new H("activeOutputChannel", ""),
  uK = class extends Rj {
    constructor(i, t, e, r, s) {
      super(),
        (this.id = i),
        (this.name = t),
        (this.q = e),
        (this.r = r),
        (this.extension = s),
        (this.n = 0),
        (this.visible = !1),
        this.setLevel(e.getLevel()),
        this.D(e.onDidChangeLogLevel((a) => this.setLevel(a))),
        this.D(it(() => this.r.$dispose(this.id)))
    }
    get logLevel() {
      return this.getLevel()
    }
    appendLine(i) {
      this.append(
        i +
          `
`,
      )
    }
    append(i) {
      this.info(i)
    }
    clear() {
      const i = this.n
      this.q.flush(), this.r.$update(this.id, Ud.Clear, i)
    }
    replace(i) {
      const t = this.n
      this.info(i),
        this.r.$update(this.id, Ud.Replace, t),
        this.visible && this.q.flush()
    }
    show(i, t) {
      this.q.flush(), this.r.$reveal(this.id, !!(typeof i == "boolean" ? i : t))
    }
    hide() {
      this.r.$close(this.id)
    }
    m(i, t) {
      ;(this.n += Et.fromString(t).byteLength),
        Xct(this.q, i, t),
        this.visible && (this.q.flush(), this.r.$update(this.id, Ud.Append))
    }
  },
  N1t = class extends uK {
    appendLine(i) {
      this.append(i)
    }
  },
  W2 = class {
    constructor(t, e, r, s, a, o) {
      ;(this.i = e),
        (this.j = r),
        (this.k = s),
        (this.l = a),
        (this.m = o),
        (this.d = new Map()),
        (this.f = 1),
        (this.g = new Map()),
        (this.h = null),
        (this.a = t.getProxy(z.MainThreadOutputService)),
        (this.b = this.k.extUri.joinPath(
          e.logsLocation,
          `output_logging_${Qvt(new Date()).replace(/-|:|\.\d+Z$/g, "")}`,
        ))
    }
    $setVisibleChannel(t) {
      this.h = t
      for (const [e, r] of this.g) r.visible = e === this.h
    }
    createOutputChannel(t, e, r) {
      if (((t = t.trim()), !t))
        throw new Error("illegal argument `name`. must not be falsy")
      const s = typeof e == "object" && e.log,
        a = Bt(e) ? e : void 0
      if (Bt(a) && !a.trim())
        throw new Error("illegal argument `languageId`. must not be empty")
      let o
      const c = this.i.environment.extensionLogLevel?.find(([m]) =>
        te.equals(r.identifier, m),
      )?.[1]
      c && (o = eut(c))
      const u = new bt(),
        l = s ? this.o(t, o, r, u) : this.n(t, a, r, u)
      return (
        l.then((m) => {
          this.g.set(m.id, m),
            (m.visible = m.id === this.h),
            u.add(it(() => this.g.delete(m.id)))
        }),
        s ? this.r(t, o ?? this.m.getLevel(), l, u) : this.q(t, l, u)
      )
    }
    async n(t, e, r, s) {
      this.c ||
        (this.c = this.j.value.createDirectory(this.b).then(() => this.b))
      const a = await this.c,
        o = this.k.extUri.joinPath(
          a,
          `${this.f++}-${t.replace(/[\\/:\*\?"<>\|]/g, "")}.log`,
        ),
        c = s.add(
          this.l.createLogger(o, {
            logLevel: "always",
            donotRotate: !0,
            donotUseFormatters: !0,
            hidden: !0,
          }),
        ),
        u = await this.a.$register(t, o, e, r.identifier.value)
      return (
        s.add(it(() => this.l.deregisterLogger(o))), new uK(u, t, c, this.a, r)
      )
    }
    async o(t, e, r, s) {
      const a = await this.p(r),
        o = t.replace(/[\\/:\*\?"<>\|]/g, ""),
        c = this.k.extUri.joinPath(a, `${o}.log`),
        u = `${r.identifier.value}.${o}`,
        l = s.add(
          this.l.createLogger(c, {
            id: u,
            name: t,
            logLevel: e,
            extensionId: r.identifier.value,
          }),
        )
      return (
        s.add(it(() => this.l.deregisterLogger(c))), new N1t(u, t, l, this.a, r)
      )
    }
    p(t) {
      let e = this.d.get(t.identifier.value)
      if (!e) {
        const r = this.k.extUri.joinPath(
          this.i.logsLocation,
          t.identifier.value,
        )
        this.d.set(
          t.identifier.value,
          (e = (async () => {
            try {
              await this.j.value.createDirectory(r)
            } catch (s) {
              if (I_(s) !== It.FileExists) throw s
            }
            return r
          })()),
        )
      }
      return e
    }
    q(t, e, r) {
      const s = () => {
        if (r.isDisposed) throw new Error("Channel has been closed")
      }
      return (
        e.then((a) => r.add(a)),
        {
          get name() {
            return t
          },
          append(a) {
            s(), e.then((o) => o.append(a))
          },
          appendLine(a) {
            s(), e.then((o) => o.appendLine(a))
          },
          clear() {
            s(), e.then((a) => a.clear())
          },
          replace(a) {
            s(), e.then((o) => o.replace(a))
          },
          show(a, o) {
            s(), e.then((c) => c.show(a, o))
          },
          hide() {
            s(), e.then((a) => a.hide())
          },
          dispose() {
            r.dispose()
          },
        }
      )
    }
    r(t, e, r, s) {
      const a = () => {
          if (s.isDisposed) throw new Error("Channel has been closed")
        },
        o = s.add(new C())
      function c(u) {
        ;(e = u), o.fire(u)
      }
      return (
        r.then((u) => {
          u.logLevel !== e && c(u.logLevel),
            s.add(u.onDidChangeLogLevel((l) => c(l)))
        }),
        {
          ...this.q(t, r, s),
          get logLevel() {
            return e
          },
          onDidChangeLogLevel: o.event,
          trace(u, ...l) {
            a(), r.then((m) => m.trace(u, ...l))
          },
          debug(u, ...l) {
            a(), r.then((m) => m.debug(u, ...l))
          },
          info(u, ...l) {
            a(), r.then((m) => m.info(u, ...l))
          },
          warn(u, ...l) {
            a(), r.then((m) => m.warn(u, ...l))
          },
          error(u, ...l) {
            a(), r.then((m) => m.error(u, ...l))
          },
        }
      )
    }
  }
W2 = __decorate(
  [
    __param(0, Vt),
    __param(1, ci),
    __param(2, y7),
    __param(3, To),
    __param(4, Hu),
    __param(5, Kt),
  ],
  W2,
)
var lK = Y("IExtHostOutputService"),
  Md,
  j2 = class {
    static {
      Md = this
    }
    static {
      this.c = 0
    }
    static {
      this.d = 250
    }
    constructor(t, e) {
      ;(this.h = e),
        (this.f = new Map()),
        (this.g = t.getProxy(z.MainThreadDecorations))
    }
    registerFileDecorationProvider(t, e) {
      const r = Md.c++
      this.f.set(r, { provider: t, extensionDescription: e }),
        this.g.$registerDecorationProvider(r, e.identifier.value)
      const s =
        t.onDidChangeFileDecorations &&
        t.onDidChangeFileDecorations((a) => {
          if (!a) {
            this.g.$onDidChange(r, null)
            return
          }
          const o = Yr(a)
          if (o.length <= Md.d) {
            this.g.$onDidChange(r, o)
            return
          }
          this.h.warn(
            "[Decorations] CAPPING events from decorations provider",
            e.identifier.value,
            o.length,
          )
          const c = o.map((m) => ({ uri: m, rank: kot(m.path, "/") })),
            u = Xst(c, (m, h) => m.rank - h.rank || Zs(m.uri.path, h.uri.path)),
            l = []
          t: for (const m of u) {
            let h
            for (const p of m) {
              const g = mo(p.uri.path)
              if (h !== g && ((h = g), l.push(p.uri) >= Md.d)) break t
            }
          }
          this.g.$onDidChange(r, l)
        })
      return new At(() => {
        s?.dispose(), this.g.$unregisterDecorationProvider(r), this.f.delete(r)
      })
    }
    async $provideDecorations(t, e, r) {
      if (!this.f.has(t)) return Object.create(null)
      const s = Object.create(null),
        { provider: a, extensionDescription: o } = this.f.get(t)
      return (
        await Promise.all(
          e.map(async (c) => {
            try {
              const { uri: u, id: l } = c,
                m = await Promise.resolve(
                  a.provideFileDecoration(S.revive(u), r),
                )
              if (!m) return
              try {
                SO.validate(m),
                  m.badge &&
                    typeof m.badge != "string" &&
                    F(o, "codiconDecoration"),
                  (s[l] = [m.propagate, m.tooltip, m.badge, m.color])
              } catch (h) {
                this.h.warn(
                  `INVALID decoration from extension '${o.identifier.value}': ${h}`,
                )
              }
            } catch (u) {
              this.h.error(u)
            }
          }),
        ),
        s
      )
    }
  }
j2 = Md = __decorate([__param(0, Vt), __param(1, Kt)], j2)
var dK = Y("IExtHostDecorations"),
  $1t = class {
    constructor(i) {
      ;(this.a = i),
        (this.b = new Uint32Array(i.length)),
        (this.c = new Int32Array(1)),
        (this.c[0] = -1)
    }
    getCount() {
      return this.a.length
    }
    insertValues(i, t) {
      i = Nc(i)
      const e = this.a,
        r = this.b,
        s = t.length
      return s === 0
        ? !1
        : ((this.a = new Uint32Array(e.length + s)),
          this.a.set(e.subarray(0, i), 0),
          this.a.set(e.subarray(i), i + s),
          this.a.set(t, i),
          i - 1 < this.c[0] && (this.c[0] = i - 1),
          (this.b = new Uint32Array(this.a.length)),
          this.c[0] >= 0 && this.b.set(r.subarray(0, this.c[0] + 1)),
          !0)
    }
    setValue(i, t) {
      return (
        (i = Nc(i)),
        (t = Nc(t)),
        this.a[i] === t
          ? !1
          : ((this.a[i] = t), i - 1 < this.c[0] && (this.c[0] = i - 1), !0)
      )
    }
    removeValues(i, t) {
      ;(i = Nc(i)), (t = Nc(t))
      const e = this.a,
        r = this.b
      if (i >= e.length) return !1
      const s = e.length - i
      return (
        t >= s && (t = s),
        t === 0
          ? !1
          : ((this.a = new Uint32Array(e.length - t)),
            this.a.set(e.subarray(0, i), 0),
            this.a.set(e.subarray(i + t), i),
            (this.b = new Uint32Array(this.a.length)),
            i - 1 < this.c[0] && (this.c[0] = i - 1),
            this.c[0] >= 0 && this.b.set(r.subarray(0, this.c[0] + 1)),
            !0)
      )
    }
    getTotalSum() {
      return this.a.length === 0 ? 0 : this.d(this.a.length - 1)
    }
    getPrefixSum(i) {
      return i < 0 ? 0 : ((i = Nc(i)), this.d(i))
    }
    d(i) {
      if (i <= this.c[0]) return this.b[i]
      let t = this.c[0] + 1
      t === 0 && ((this.b[0] = this.a[0]), t++),
        i >= this.a.length && (i = this.a.length - 1)
      for (let e = t; e <= i; e++) this.b[e] = this.b[e - 1] + this.a[e]
      return (this.c[0] = Math.max(this.c[0], i)), this.b[i]
    }
    getIndexOf(i) {
      ;(i = Math.floor(i)), this.getTotalSum()
      let t = 0,
        e = this.a.length - 1,
        r = 0,
        s = 0,
        a = 0
      for (; t <= e; )
        if (
          ((r = (t + (e - t) / 2) | 0),
          (s = this.b[r]),
          (a = s - this.a[r]),
          i < a)
        )
          e = r - 1
        else if (i >= s) t = r + 1
        else break
      return new x1t(r, i - a)
    }
  },
  x1t = class {
    constructor(i, t) {
      ;(this.index = i),
        (this.remainder = t),
        (this._prefixSumIndexOfResultBrand = void 0),
        (this.index = i),
        (this.remainder = t)
    }
  },
  J1t = class {
    constructor(i, t, e, r) {
      ;(this.a = i),
        (this.b = t),
        (this.c = e),
        (this.d = r),
        (this.f = null),
        (this.g = null)
    }
    dispose() {
      this.b.length = 0
    }
    get version() {
      return this.d
    }
    getText() {
      return this.g === null && (this.g = this.b.join(this.c)), this.g
    }
    onEvents(i) {
      i.eol && i.eol !== this.c && ((this.c = i.eol), (this.f = null))
      const t = i.changes
      for (const e of t)
        this.k(e.range),
          this.l(new tr(e.range.startLineNumber, e.range.startColumn), e.text)
      ;(this.d = i.versionId), (this.g = null)
    }
    h() {
      if (!this.f) {
        const i = this.c.length,
          t = this.b.length,
          e = new Uint32Array(t)
        for (let r = 0; r < t; r++) e[r] = this.b[r].length + i
        this.f = new $1t(e)
      }
    }
    j(i, t) {
      ;(this.b[i] = t),
        this.f && this.f.setValue(i, this.b[i].length + this.c.length)
    }
    k(i) {
      if (i.startLineNumber === i.endLineNumber) {
        if (i.startColumn === i.endColumn) return
        this.j(
          i.startLineNumber - 1,
          this.b[i.startLineNumber - 1].substring(0, i.startColumn - 1) +
            this.b[i.startLineNumber - 1].substring(i.endColumn - 1),
        )
        return
      }
      this.j(
        i.startLineNumber - 1,
        this.b[i.startLineNumber - 1].substring(0, i.startColumn - 1) +
          this.b[i.endLineNumber - 1].substring(i.endColumn - 1),
      ),
        this.b.splice(i.startLineNumber, i.endLineNumber - i.startLineNumber),
        this.f &&
          this.f.removeValues(
            i.startLineNumber,
            i.endLineNumber - i.startLineNumber,
          )
    }
    l(i, t) {
      if (t.length === 0) return
      const e = DW(t)
      if (e.length === 1) {
        this.j(
          i.lineNumber - 1,
          this.b[i.lineNumber - 1].substring(0, i.column - 1) +
            e[0] +
            this.b[i.lineNumber - 1].substring(i.column - 1),
        )
        return
      }
      ;(e[e.length - 1] += this.b[i.lineNumber - 1].substring(i.column - 1)),
        this.j(
          i.lineNumber - 1,
          this.b[i.lineNumber - 1].substring(0, i.column - 1) + e[0],
        )
      const r = new Uint32Array(e.length - 1)
      for (let s = 1; s < e.length; s++)
        this.b.splice(i.lineNumber + s - 1, 0, e[s]),
          (r[s - 1] = e[s].length + this.c.length)
      this.f && this.f.insertValues(i.lineNumber, r)
    }
  },
  mK = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?"
function C1t(i = "") {
  let t = "(-?\\d*\\.\\d\\w*)|([^"
  for (const e of mK) i.indexOf(e) >= 0 || (t += "\\" + e)
  return (t += "\\s]+)"), new RegExp(t, "g")
}
var L1t = C1t()
function hK(i) {
  let t = L1t
  if (i && i instanceof RegExp)
    if (i.global) t = i
    else {
      let e = "g"
      i.ignoreCase && (e += "i"),
        i.multiline && (e += "m"),
        i.unicode && (e += "u"),
        (t = new RegExp(i.source, e))
    }
  return (t.lastIndex = 0), t
}
var fK = new Eu()
fK.unshift({ maxLen: 1e3, windowSize: 15, timeBudget: 150 })
function pK(i, t, e, r, s) {
  if (((t = hK(t)), s || (s = Yi.first(fK)), e.length > s.maxLen)) {
    let l = i - s.maxLen / 2
    return (
      l < 0 ? (l = 0) : (r += l),
      (e = e.substring(l, i + s.maxLen / 2)),
      pK(i, t, e, r, s)
    )
  }
  const a = Date.now(),
    o = i - 1 - r
  let c = -1,
    u = null
  for (let l = 1; !(Date.now() - a >= s.timeBudget); l++) {
    const m = o - s.windowSize * l
    t.lastIndex = Math.max(0, m)
    const h = R1t(t, e, o, c)
    if ((!h && u) || ((u = h), m <= 0)) break
    c = m
  }
  if (u) {
    const l = {
      word: u[0],
      startColumn: r + 1 + u.index,
      endColumn: r + 1 + u.index + u[0].length,
    }
    return (t.lastIndex = 0), l
  }
  return null
}
function R1t(i, t, e, r) {
  let s
  for (; (s = i.exec(t)); ) {
    const a = s.index || 0
    if (a <= e && i.lastIndex >= e) return s
    if (r > 0 && a > r) return null
  }
  return null
}
var V2 = new Map()
function D1t(i, t) {
  t ? V2.set(i, t) : V2.delete(i)
}
function F1t(i) {
  return V2.get(i)
}
var _1t = class extends J1t {
    constructor(i, t, e, r, s, a, o) {
      super(t, e, r, s), (this.o = i), (this.p = a), (this.q = o), (this.n = !1)
    }
    dispose() {
      Ji(!this.n), (this.n = !0), (this.q = !1)
    }
    equalLines(i) {
      return fn(this.b, i)
    }
    get document() {
      if (!this.m) {
        const i = this
        this.m = {
          get uri() {
            return i.a
          },
          get fileName() {
            return i.a.fsPath
          },
          get isUntitled() {
            return i.a.scheme === Q.untitled
          },
          get languageId() {
            return i.p
          },
          get version() {
            return i.d
          },
          get isClosed() {
            return i.n
          },
          get isDirty() {
            return i.q
          },
          save() {
            return i.r()
          },
          getText(t) {
            return t ? i.s(t) : i.getText()
          },
          get eol() {
            return i.c ===
              `
`
              ? xr.LF
              : xr.CRLF
          },
          get lineCount() {
            return i.b.length
          },
          lineAt(t) {
            return i.t(t)
          },
          offsetAt(t) {
            return i.u(t)
          },
          positionAt(t) {
            return i.v(t)
          },
          validateRange(t) {
            return i.w(t)
          },
          validatePosition(t) {
            return i.x(t)
          },
          getWordRangeAtPosition(t, e) {
            return i.y(t, e)
          },
          [Symbol.for("debug.description")]() {
            return `TextDocument(${i.a.toString()})`
          },
        }
      }
      return Object.freeze(this.m)
    }
    _acceptLanguageId(i) {
      Ji(!this.n), (this.p = i)
    }
    _acceptIsDirty(i) {
      Ji(!this.n), (this.q = i)
    }
    r() {
      return this.n
        ? Promise.reject(new Error("Document has been closed"))
        : this.o.$trySaveDocument(this.a)
    }
    s(i) {
      const t = this.w(i)
      if (t.isEmpty) return ""
      if (t.isSingleLine)
        return this.b[t.start.line].substring(
          t.start.character,
          t.end.character,
        )
      const e = this.c,
        r = t.start.line,
        s = t.end.line,
        a = []
      a.push(this.b[r].substring(t.start.character))
      for (let o = r + 1; o < s; o++) a.push(this.b[o])
      return a.push(this.b[s].substring(0, t.end.character)), a.join(e)
    }
    t(i) {
      let t
      if (
        (i instanceof Lt ? (t = i.line) : typeof i == "number" && (t = i),
        typeof t != "number" ||
          t < 0 ||
          t >= this.b.length ||
          Math.floor(t) !== t)
      )
        throw new Error("Illegal value for `line`")
      return new A1t(t, this.b[t], t === this.b.length - 1)
    }
    u(i) {
      return (
        (i = this.x(i)), this.h(), this.f.getPrefixSum(i.line - 1) + i.character
      )
    }
    v(i) {
      ;(i = Math.floor(i)), (i = Math.max(0, i)), this.h()
      const t = this.f.getIndexOf(i),
        e = this.b[t.index].length
      return new Lt(t.index, Math.min(t.remainder, e))
    }
    w(i) {
      if (!(i instanceof Nt)) throw new Error("Invalid argument")
      const t = this.x(i.start),
        e = this.x(i.end)
      return t === i.start && e === i.end
        ? i
        : new Nt(t.line, t.character, e.line, e.character)
    }
    x(i) {
      if (!(i instanceof Lt)) throw new Error("Invalid argument")
      if (this.b.length === 0) return i.with(0, 0)
      let { line: t, character: e } = i,
        r = !1
      if (t < 0) (t = 0), (e = 0), (r = !0)
      else if (t >= this.b.length)
        (t = this.b.length - 1), (e = this.b[t].length), (r = !0)
      else {
        const s = this.b[t].length
        e < 0 ? ((e = 0), (r = !0)) : e > s && ((e = s), (r = !0))
      }
      return r ? new Lt(t, e) : i
    }
    y(i, t) {
      const e = this.x(i)
      if (!t) t = F1t(this.p)
      else if (RW(t))
        throw new Error(
          `[getWordRangeAtPosition]: ignoring custom regexp '${t.source}' because it matches the empty string.`,
        )
      const r = pK(e.character + 1, hK(t), this.b[e.line], 0)
      if (r) return new Nt(e.line, r.startColumn - 1, e.line, r.endColumn - 1)
    }
  },
  A1t = class {
    constructor(i, t, e) {
      ;(this.a = i), (this.b = t), (this.c = e)
    }
    get lineNumber() {
      return this.a
    }
    get text() {
      return this.b
    }
    get range() {
      return new Nt(this.a, 0, this.a, this.b.length)
    }
    get rangeIncludingLineBreak() {
      return this.c ? this.range : new Nt(this.a, 0, this.a + 1, 0)
    }
    get firstNonWhitespaceCharacterIndex() {
      return /^(\s*)/.exec(this.b)[1].length
    }
    get isEmptyOrWhitespace() {
      return this.firstNonWhitespaceCharacterIndex === this.b.length
    }
  },
  b7 = class {
    constructor(i) {
      ;(this.a = i), (this.b = 0)
    }
    nextId() {
      return this.a + ++this.b
    }
  },
  _qt = new b7("id#"),
  B1t = class Xnt {
    static {
      this.c = new b7("TextEditorDecorationType")
    }
    constructor(t, e, r) {
      const s = Xnt.c.nextId()
      t.$registerTextEditorDecorationType(e.identifier, s, zO.from(r)),
        (this.value = Object.freeze({
          key: s,
          dispose() {
            t.$removeTextEditorDecorationType(s)
          },
        }))
    }
  },
  O1t = class {
    constructor(i, t) {
      ;(this.g = []),
        (this.h = void 0),
        (this.j = !1),
        (this.c = i),
        (this.d = i.version),
        (this.e = t.undoStopBefore),
        (this.f = t.undoStopAfter)
    }
    finalize() {
      return (
        (this.j = !0),
        {
          documentVersionId: this.d,
          edits: this.g,
          setEndOfLine: this.h,
          undoStopBefore: this.e,
          undoStopAfter: this.f,
        }
      )
    }
    k() {
      if (this.j) throw new Error("Edit is only valid while callback runs")
    }
    replace(i, t) {
      this.k()
      let e = null
      if (i instanceof Lt) e = new Nt(i, i)
      else if (i instanceof Nt) e = i
      else throw new Error("Unrecognized location")
      this.l(e, t, !1)
    }
    insert(i, t) {
      this.k(), this.l(new Nt(i, i), t, !0)
    }
    delete(i) {
      this.k()
      let t = null
      if (i instanceof Nt) t = i
      else throw new Error("Unrecognized location")
      this.l(t, null, !0)
    }
    l(i, t, e) {
      const r = this.c.validateRange(i)
      this.g.push({ range: r, text: t, forceMoveMarkers: e })
    }
    setEndOfLine(i) {
      if ((this.k(), i !== xr.LF && i !== xr.CRLF)) throw xt("endOfLine")
      this.h = i
    }
  },
  q1t = class {
    constructor(i, t, e, r) {
      ;(this.c = i), (this.d = t), this._accept(e), (this.e = r)
      const s = this
      this.value = {
        get tabSize() {
          return s.f
        },
        set tabSize(a) {
          s.n(a)
        },
        get indentSize() {
          return s.g
        },
        set indentSize(a) {
          s.p(a)
        },
        get insertSpaces() {
          return s.j
        },
        set insertSpaces(a) {
          s.s(a)
        },
        get cursorStyle() {
          return s.k
        },
        set cursorStyle(a) {
          s.t(a)
        },
        get lineNumbers() {
          return s.l
        },
        set lineNumbers(a) {
          s.u(a)
        },
      }
    }
    _accept(i) {
      ;(this.f = i.tabSize),
        (this.g = i.indentSize),
        (this.h = i.originalIndentSize),
        (this.j = i.insertSpaces),
        (this.k = i.cursorStyle),
        (this.l = ac.to(i.lineNumbers))
    }
    m(i) {
      if (i === "auto") return "auto"
      if (typeof i == "number") {
        const t = Math.floor(i)
        return t > 0 ? t : null
      }
      if (typeof i == "string") {
        const t = parseInt(i, 10)
        return isNaN(t) ? null : t > 0 ? t : null
      }
      return null
    }
    n(i) {
      const t = this.m(i)
      if (t !== null) {
        if (typeof t == "number") {
          if (this.f === t) return
          this.f = t
        }
        this.v("setTabSize", this.c.$trySetOptions(this.d, { tabSize: t }))
      }
    }
    o(i) {
      if (i === "tabSize") return "tabSize"
      if (typeof i == "number") {
        const t = Math.floor(i)
        return t > 0 ? t : null
      }
      if (typeof i == "string") {
        const t = parseInt(i, 10)
        return isNaN(t) ? null : t > 0 ? t : null
      }
      return null
    }
    p(i) {
      const t = this.o(i)
      if (t !== null) {
        if (typeof t == "number") {
          if (this.h === t) return
          ;(this.g = t), (this.h = t)
        }
        this.v(
          "setIndentSize",
          this.c.$trySetOptions(this.d, { indentSize: t }),
        )
      }
    }
    q(i) {
      return i === "auto" ? "auto" : i === "false" ? !1 : !!i
    }
    s(i) {
      const t = this.q(i)
      if (typeof t == "boolean") {
        if (this.j === t) return
        this.j = t
      }
      this.v(
        "setInsertSpaces",
        this.c.$trySetOptions(this.d, { insertSpaces: t }),
      )
    }
    t(i) {
      this.k !== i &&
        ((this.k = i),
        this.v(
          "setCursorStyle",
          this.c.$trySetOptions(this.d, { cursorStyle: i }),
        ))
    }
    u(i) {
      this.l !== i &&
        ((this.l = i),
        this.v(
          "setLineNumbers",
          this.c.$trySetOptions(this.d, { lineNumbers: ac.from(i) }),
        ))
    }
    assign(i) {
      const t = {}
      let e = !1
      if (typeof i.tabSize < "u") {
        const r = this.m(i.tabSize)
        r === "auto"
          ? ((e = !0), (t.tabSize = r))
          : typeof r == "number" &&
            this.f !== r &&
            ((this.f = r), (e = !0), (t.tabSize = r))
      }
      if (typeof i.indentSize < "u") {
        const r = this.o(i.indentSize)
        r === "tabSize"
          ? ((e = !0), (t.indentSize = r))
          : typeof r == "number" &&
            this.h !== r &&
            ((this.g = r), (this.h = r), (e = !0), (t.indentSize = r))
      }
      if (typeof i.insertSpaces < "u") {
        const r = this.q(i.insertSpaces)
        r === "auto"
          ? ((e = !0), (t.insertSpaces = r))
          : this.j !== r && ((this.j = r), (e = !0), (t.insertSpaces = r))
      }
      typeof i.cursorStyle < "u" &&
        this.k !== i.cursorStyle &&
        ((this.k = i.cursorStyle), (e = !0), (t.cursorStyle = i.cursorStyle)),
        typeof i.lineNumbers < "u" &&
          this.l !== i.lineNumbers &&
          ((this.l = i.lineNumbers),
          (e = !0),
          (t.lineNumbers = ac.from(i.lineNumbers))),
        e && this.v("setOptions", this.c.$trySetOptions(this.d, t))
    }
    v(i, t) {
      t.catch((e) => {
        this.e.warn(`ExtHostTextEditorOptions '${i}' failed:'`), this.e.warn(e)
      })
    }
  },
  U1t = class {
    constructor(i, t, e, r, s, a, o, c) {
      ;(this.id = i),
        (this.k = t),
        (this.l = e),
        (this.g = !1),
        (this.h = new Set()),
        (this.c = s),
        (this.d = new q1t(this.k, this.id, a, e)),
        (this.e = o),
        (this.f = c)
      const u = this
      this.value = Object.freeze({
        get document() {
          return r.value
        },
        set document(l) {
          throw new zs("document")
        },
        get selection() {
          return u.c && u.c[0]
        },
        set selection(l) {
          if (!(l instanceof Pn)) throw xt("selection")
          ;(u.c = [l]), u.m()
        },
        get selections() {
          return u.c
        },
        set selections(l) {
          if (!Array.isArray(l) || l.some((m) => !(m instanceof Pn)))
            throw xt("selections")
          ;(u.c = l), u.m()
        },
        get visibleRanges() {
          return u.e
        },
        set visibleRanges(l) {
          throw new zs("visibleRanges")
        },
        get diffInformation() {
          return u.j
        },
        get options() {
          return u.d.value
        },
        set options(l) {
          u.g || u.d.assign(l)
        },
        get viewColumn() {
          return u.f
        },
        set viewColumn(l) {
          throw new zs("viewColumn")
        },
        edit(l, m = { undoStopBefore: !0, undoStopAfter: !0 }) {
          if (u.g)
            return Promise.reject(
              new Error("TextEditor#edit not possible on closed editors"),
            )
          const h = new O1t(r.value, m)
          return l(h), u.n(h)
        },
        insertSnippet(l, m, h = { undoStopBefore: !0, undoStopAfter: !0 }) {
          if (u.g)
            return Promise.reject(
              new Error(
                "TextEditor#insertSnippet not possible on closed editors",
              ),
            )
          let p
          if (!m || (Array.isArray(m) && m.length === 0))
            p = u.c.map((g) => O.from(g))
          else if (m instanceof Lt) {
            const { lineNumber: g, column: w } = Gt.from(m)
            p = [
              {
                startLineNumber: g,
                startColumn: w,
                endLineNumber: g,
                endColumn: w,
              },
            ]
          } else if (m instanceof Nt) p = [O.from(m)]
          else {
            p = []
            for (const g of m)
              if (g instanceof Nt) p.push(O.from(g))
              else {
                const { lineNumber: w, column: T } = Gt.from(g)
                p.push({
                  startLineNumber: w,
                  startColumn: T,
                  endLineNumber: w,
                  endColumn: T,
                })
              }
          }
          return t.$tryInsertSnippet(i, r.value.version, l.value, p, h)
        },
        setDecorations(l, m) {
          const h = m.length === 0
          ;(h && !u.h.has(l.key)) ||
            (h ? u.h.delete(l.key) : u.h.add(l.key),
            u.o(() => {
              if (SY(m)) return t.$trySetDecorations(i, l.key, jmt(m))
              {
                const p = new Array(4 * m.length)
                for (let g = 0, w = m.length; g < w; g++) {
                  const T = m[g]
                  ;(p[4 * g] = T.start.line + 1),
                    (p[4 * g + 1] = T.start.character + 1),
                    (p[4 * g + 2] = T.end.line + 1),
                    (p[4 * g + 3] = T.end.character + 1)
                }
                return t.$trySetDecorationsFast(i, l.key, p)
              }
            }))
        },
        revealRange(l, m) {
          u.o(() => t.$tryRevealRange(i, O.from(l), m || p6.Default))
        },
        show(l) {
          t.$tryShowEditor(i, Me.from(l))
        },
        hide() {
          t.$tryHideEditor(i)
        },
        [Symbol.for("debug.description")]() {
          return `TextEditor(${this.document.uri.toString()})`
        },
      })
    }
    dispose() {
      Ji(!this.g), (this.g = !0)
    }
    _acceptOptions(i) {
      Ji(!this.g), this.d._accept(i)
    }
    _acceptVisibleRanges(i) {
      Ji(!this.g), (this.e = i)
    }
    _acceptViewColumn(i) {
      Ji(!this.g), (this.f = i)
    }
    _acceptSelections(i) {
      Ji(!this.g), (this.c = i)
    }
    _acceptDiffInformation(i) {
      Ji(!this.g), (this.j = i)
    }
    async m() {
      const i = this.c.map(Cr.from)
      return (
        await this.o(() => this.k.$trySetSelections(this.id, i)), this.value
      )
    }
    n(i) {
      const t = i.finalize()
      if (t.edits.length === 0 && !t.setEndOfLine) return Promise.resolve(!0)
      const e = t.edits.map((s) => s.range)
      e.sort((s, a) =>
        s.end.line === a.end.line
          ? s.end.character === a.end.character
            ? s.start.line === a.start.line
              ? s.start.character - a.start.character
              : s.start.line - a.start.line
            : s.end.character - a.end.character
          : s.end.line - a.end.line,
      )
      for (let s = 0, a = e.length - 1; s < a; s++) {
        const o = e[s].end
        if (e[s + 1].start.isBefore(o))
          return Promise.reject(
            new Error("Overlapping ranges are not allowed!"),
          )
      }
      const r = t.edits.map((s) => ({
        range: O.from(s.range),
        text: s.text,
        forceMoveMarkers: s.forceMoveMarkers,
      }))
      return this.k.$tryApplyEdits(this.id, t.documentVersionId, r, {
        setEndOfLine:
          typeof t.setEndOfLine == "number" ? oc.from(t.setEndOfLine) : void 0,
        undoStopBefore: t.undoStopBefore,
        undoStopAfter: t.undoStopAfter,
      })
    }
    o(i) {
      return this.g
        ? (this.l.warn("TextEditor is closed/disposed"),
          Promise.resolve(void 0))
        : i().then(
            () => this,
            (t) => (
              (t instanceof Error && t.name === "DISPOSED") || this.l.warn(t),
              null
            ),
          )
    }
  },
  M1t = class {
    constructor(i) {
      ;(this.value = i), (this.a = 0)
    }
    ref() {
      this.a++
    }
    unref() {
      return --this.a === 0
    }
  },
  G2 = class {
    constructor(t, e) {
      ;(this.h = t),
        (this.i = e),
        (this.a = null),
        (this.b = new Map()),
        (this.c = new ei()),
        (this.d = new C()),
        (this.e = new C()),
        (this.f = new C()),
        (this.g = new C()),
        (this.onDidAddDocuments = this.d.event),
        (this.onDidRemoveDocuments = this.e.event),
        (this.onDidChangeVisibleTextEditors = this.f.event),
        (this.onDidChangeActiveTextEditor = this.g.event)
    }
    $acceptDocumentsAndEditorsDelta(t) {
      this.acceptDocumentsAndEditorsDelta(t)
    }
    acceptDocumentsAndEditorsDelta(t) {
      const e = [],
        r = [],
        s = []
      if (t.removedDocuments)
        for (const a of t.removedDocuments) {
          const o = S.revive(a),
            c = this.c.get(o)
          c?.unref() && (this.c.delete(o), e.push(c.value))
        }
      if (t.addedDocuments)
        for (const a of t.addedDocuments) {
          const o = S.revive(a.uri)
          let c = this.c.get(o)
          if (
            c &&
            o.scheme !== Q.vscodeNotebookCell &&
            o.scheme !== Q.vscodeInteractiveInput
          )
            throw new Error(`document '${o} already exists!'`)
          c ||
            ((c = new M1t(
              new _1t(
                this.h.getProxy(z.MainThreadDocuments),
                o,
                a.lines,
                a.EOL,
                a.versionId,
                a.languageId,
                a.isDirty,
              ),
            )),
            this.c.set(o, c),
            r.push(c.value)),
            c.ref()
        }
      if (t.removedEditors)
        for (const a of t.removedEditors) {
          const o = this.b.get(a)
          this.b.delete(a), o && s.push(o)
        }
      if (t.addedEditors)
        for (const a of t.addedEditors) {
          const o = S.revive(a.documentUri)
          Ji(this.c.has(o), `document '${o}' does not exist`),
            Ji(!this.b.has(a.id), `editor '${a.id}' already exists!`)
          const c = this.c.get(o).value,
            u = new U1t(
              a.id,
              this.h.getProxy(z.MainThreadTextEditors),
              this.i,
              new qi(() => c.document),
              a.selections.map(Cr.to),
              a.options,
              a.visibleRanges.map((l) => O.to(l)),
              typeof a.editorPosition == "number"
                ? Me.to(a.editorPosition)
                : void 0,
            )
          this.b.set(a.id, u)
        }
      t.newActiveEditor !== void 0 &&
        (Ji(
          t.newActiveEditor === null || this.b.has(t.newActiveEditor),
          `active editor '${t.newActiveEditor}' does not exist`,
        ),
        (this.a = t.newActiveEditor)),
        pn(e),
        pn(s),
        t.removedDocuments && this.e.fire(e),
        t.addedDocuments && this.d.fire(r),
        (t.removedEditors || t.addedEditors) &&
          this.f.fire(this.allEditors().map((a) => a.value)),
        t.newActiveEditor !== void 0 && this.g.fire(this.activeEditor())
    }
    getDocument(t) {
      return this.c.get(t)?.value
    }
    allDocuments() {
      return Yi.map(this.c.values(), (t) => t.value)
    }
    getEditor(t) {
      return this.b.get(t)
    }
    activeEditor(t) {
      if (!this.a) return
      const e = this.b.get(this.a)
      return t ? e : e?.value
    }
    allEditors() {
      return [...this.b.values()]
    }
  }
G2 = __decorate([__param(0, Vt), __param(1, Kt)], G2)
var xc = Y("IExtHostDocumentsAndEditors"),
  E7 = Y("IExtHostApiDeprecationService"),
  z2 = class {
    constructor(t, e) {
      ;(this.c = e),
        (this.a = new Set()),
        (this.b = t.getProxy(z.MainThreadTelemetry))
    }
    report(t, e, r) {
      const s = this.d(t, e)
      this.a.has(s) ||
        (this.a.add(s),
        e.isUnderDevelopment &&
          this.c.warn(`[Deprecation Warning] '${t}' is deprecated. ${r}`),
        this.b.$publicLog2("extHostDeprecatedApiUsage", {
          extensionId: e.identifier.value,
          apiId: t,
        }))
    }
    d(t, e) {
      return `${t}-${e.identifier.value}`
    }
  }
z2 = __decorate([__param(0, Vt), __param(1, Kt)], z2)
var Oqt = Object.freeze(
    new (class {
      report(i, t, e) {}
    })(),
  ),
  H1t = {
    activeComment: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.activeComment.d.ts",
    },
    aiRelatedInformation: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiRelatedInformation.d.ts",
    },
    aiTextSearchProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiTextSearchProvider.d.ts",
      version: 2,
    },
    authLearnMore: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authLearnMore.d.ts",
    },
    authSession: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authSession.d.ts",
    },
    canonicalUriProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.canonicalUriProvider.d.ts",
    },
    chatEditing: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatEditing.d.ts",
    },
    chatParticipantAdditions: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantAdditions.d.ts",
    },
    chatParticipantPrivate: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantPrivate.d.ts",
      version: 2,
    },
    chatProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatProvider.d.ts",
    },
    chatReferenceBinaryData: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatReferenceBinaryData.d.ts",
    },
    chatTab: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatTab.d.ts",
    },
    chatVariableResolver: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatVariableResolver.d.ts",
    },
    codeActionAI: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionAI.d.ts",
    },
    codeActionRanges: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionRanges.d.ts",
    },
    codiconDecoration: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codiconDecoration.d.ts",
    },
    commentReactor: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReactor.d.ts",
    },
    commentReveal: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReveal.d.ts",
    },
    commentThreadApplicability: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentThreadApplicability.d.ts",
    },
    commentingRangeHint: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentingRangeHint.d.ts",
    },
    commentsDraftState: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentsDraftState.d.ts",
    },
    contribAccessibilityHelpContent: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribAccessibilityHelpContent.d.ts",
    },
    contribChatParticipantDetection: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribChatParticipantDetection.d.ts",
    },
    contribCommentEditorActionsMenu: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentEditorActionsMenu.d.ts",
    },
    contribCommentPeekContext: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentPeekContext.d.ts",
    },
    contribCommentThreadAdditionalMenu: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentThreadAdditionalMenu.d.ts",
    },
    contribCommentsViewThreadMenus: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentsViewThreadMenus.d.ts",
    },
    contribDebugCreateConfiguration: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribDebugCreateConfiguration.d.ts",
    },
    contribDiffEditorGutterToolBarMenus: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribDiffEditorGutterToolBarMenus.d.ts",
    },
    contribEditSessions: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditSessions.d.ts",
    },
    contribEditorContentMenu: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditorContentMenu.d.ts",
    },
    contribLabelFormatterWorkspaceTooltip: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribLabelFormatterWorkspaceTooltip.d.ts",
    },
    contribMenuBarHome: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMenuBarHome.d.ts",
    },
    contribMergeEditorMenus: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMergeEditorMenus.d.ts",
    },
    contribMultiDiffEditorMenus: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMultiDiffEditorMenus.d.ts",
    },
    contribNotebookStaticPreloads: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribNotebookStaticPreloads.d.ts",
    },
    contribRemoteHelp: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribRemoteHelp.d.ts",
    },
    contribShareMenu: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribShareMenu.d.ts",
    },
    contribSourceControlHistoryItemMenu: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryItemMenu.d.ts",
    },
    contribSourceControlHistoryTitleMenu: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryTitleMenu.d.ts",
    },
    contribSourceControlInputBoxMenu: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlInputBoxMenu.d.ts",
    },
    contribSourceControlTitleMenu: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlTitleMenu.d.ts",
    },
    contribStatusBarItems: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribStatusBarItems.d.ts",
    },
    contribViewContainerTitle: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewContainerTitle.d.ts",
    },
    contribViewsRemote: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsRemote.d.ts",
    },
    contribViewsWelcome: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsWelcome.d.ts",
    },
    control: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.control.d.ts",
    },
    createFileSystemWatcher: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.createFileSystemWatcher.d.ts",
    },
    cursor: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.cursor.d.ts",
    },
    cursorNoDeps: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.cursorNoDeps.d.ts",
    },
    customEditorMove: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.customEditorMove.d.ts",
    },
    debugVisualization: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.debugVisualization.d.ts",
    },
    defaultChatParticipant: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.defaultChatParticipant.d.ts",
      version: 2,
    },
    diffCommand: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffCommand.d.ts",
    },
    diffContentOptions: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffContentOptions.d.ts",
    },
    documentFiltersExclusive: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.documentFiltersExclusive.d.ts",
    },
    documentPaste: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.documentPaste.d.ts",
    },
    editSessionIdentityProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editSessionIdentityProvider.d.ts",
    },
    editorHoverVerbosityLevel: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorHoverVerbosityLevel.d.ts",
    },
    editorInsets: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorInsets.d.ts",
    },
    embeddings: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.embeddings.d.ts",
    },
    extensionRuntime: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionRuntime.d.ts",
    },
    extensionsAny: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionsAny.d.ts",
    },
    externalUriOpener: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.externalUriOpener.d.ts",
    },
    fileComments: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileComments.d.ts",
    },
    fileSearchProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProvider.d.ts",
    },
    fileSearchProvider2: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProvider2.d.ts",
    },
    findFiles2: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findFiles2.d.ts",
      version: 2,
    },
    findTextInFiles: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFiles.d.ts",
    },
    findTextInFiles2: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFiles2.d.ts",
    },
    fsChunks: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fsChunks.d.ts",
    },
    idToken: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.idToken.d.ts",
    },
    inlineCompletionsAdditions: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.inlineCompletionsAdditions.d.ts",
    },
    inlineEdit: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.inlineEdit.d.ts",
    },
    interactive: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactive.d.ts",
    },
    interactiveWindow: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactiveWindow.d.ts",
    },
    ipc: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.ipc.d.ts",
    },
    languageModelSystem: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelSystem.d.ts",
    },
    languageStatusText: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageStatusText.d.ts",
    },
    mappedEditsProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.mappedEditsProvider.d.ts",
    },
    multiDocumentHighlightProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.multiDocumentHighlightProvider.d.ts",
    },
    nativeWindowHandle: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.nativeWindowHandle.d.ts",
    },
    newSymbolNamesProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.newSymbolNamesProvider.d.ts",
    },
    notebookCellExecution: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCellExecution.d.ts",
    },
    notebookCellExecutionState: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCellExecutionState.d.ts",
    },
    notebookControllerAffinityHidden: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookControllerAffinityHidden.d.ts",
    },
    notebookDeprecated: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookDeprecated.d.ts",
    },
    notebookExecution: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookExecution.d.ts",
    },
    notebookKernelSource: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookKernelSource.d.ts",
    },
    notebookLiveShare: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookLiveShare.d.ts",
    },
    notebookMessaging: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMessaging.d.ts",
    },
    notebookMime: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMime.d.ts",
    },
    notebookReplDocument: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookReplDocument.d.ts",
    },
    notebookVariableProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookVariableProvider.d.ts",
    },
    portsAttributes: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.portsAttributes.d.ts",
    },
    profileContentHandlers: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.profileContentHandlers.d.ts",
    },
    quickDiffProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickDiffProvider.d.ts",
    },
    quickInputButtonLocation: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickInputButtonLocation.d.ts",
    },
    quickPickItemTooltip: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickItemTooltip.d.ts",
    },
    quickPickSortByLabel: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickSortByLabel.d.ts",
    },
    resolvers: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.resolvers.d.ts",
    },
    scmActionButton: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmActionButton.d.ts",
    },
    scmHistoryProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmHistoryProvider.d.ts",
    },
    scmMultiDiffEditor: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmMultiDiffEditor.d.ts",
    },
    scmRemotes: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmRemotes.d.ts",
    },
    scmSelectedProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmSelectedProvider.d.ts",
    },
    scmTextDocument: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmTextDocument.d.ts",
    },
    scmValidation: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmValidation.d.ts",
    },
    shareProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.shareProvider.d.ts",
    },
    showLocal: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.showLocal.d.ts",
    },
    speech: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.speech.d.ts",
    },
    tabInputMultiDiff: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputMultiDiff.d.ts",
    },
    tabInputTextMerge: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputTextMerge.d.ts",
    },
    taskPresentationGroup: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.taskPresentationGroup.d.ts",
    },
    telemetry: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.telemetry.d.ts",
    },
    terminalCompletionProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalCompletionProvider.d.ts",
    },
    terminalDataWriteEvent: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDataWriteEvent.d.ts",
    },
    terminalDimensions: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDimensions.d.ts",
    },
    terminalExecuteCommandEvent: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalExecuteCommandEvent.d.ts",
    },
    terminalQuickFixProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalQuickFixProvider.d.ts",
    },
    terminalSelection: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalSelection.d.ts",
    },
    testObserver: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testObserver.d.ts",
    },
    testRelatedCode: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testRelatedCode.d.ts",
    },
    textEditorDiffInformation: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textEditorDiffInformation.d.ts",
    },
    textSearchComplete2: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchComplete2.d.ts",
    },
    textSearchProvider: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProvider.d.ts",
    },
    textSearchProvider2: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProvider2.d.ts",
    },
    timeline: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.timeline.d.ts",
    },
    tokenInformation: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tokenInformation.d.ts",
    },
    treeViewActiveItem: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewActiveItem.d.ts",
    },
    treeViewMarkdownMessage: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewMarkdownMessage.d.ts",
    },
    treeViewReveal: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewReveal.d.ts",
    },
    tunnelFactory: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnelFactory.d.ts",
    },
    tunnels: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnels.d.ts",
    },
    valueSelectionInQuickPick: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.valueSelectionInQuickPick.d.ts",
    },
    workspaceTrust: {
      proposal:
        "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.workspaceTrust.d.ts",
    },
  },
  I7 = Object.freeze(H1t),
  Y2 = ui.as(J_.JSONContribution),
  W1t = class j8 {
    static a(t) {
      const e = new la()
      for (let r = 0, s = t.length; r < s; r++)
        e.add(t[r].description.identifier)
      return e
    }
    static compute(t, e) {
      if (!t || !t.length) return new j8(e, [])
      if (!e || !e.length) return new j8([], t)
      const r = this.a(t),
        s = this.a(e),
        a = e.filter((c) => !r.has(c.description.identifier)),
        o = t.filter((c) => !s.has(c.description.identifier))
      return new j8(a, o)
    }
    constructor(t, e) {
      ;(this.added = t), (this.removed = e)
    }
  },
  j1t = class {
    constructor(i, t, e) {
      ;(this.name = i),
        (this.defaultExtensionKind = t),
        (this.canHandleResolver = e),
        (this.a = null),
        (this.b = null),
        (this.c = null)
    }
    setHandler(i) {
      if (this.a !== null) throw new Error("Handler already set!")
      return (
        (this.a = i),
        this.d(),
        {
          dispose: () => {
            this.a = null
          },
        }
      )
    }
    acceptUsers(i) {
      ;(this.c = W1t.compute(this.b, i)), (this.b = i), this.d()
    }
    d() {
      if (!(this.a === null || this.b === null || this.c === null))
        try {
          this.a(this.b, this.c)
        } catch (i) {
          Ui(i)
        }
    }
  },
  V1t = {
    type: "string",
    enum: ["ui", "workspace"],
    enumDescriptions: [f(12894, null), f(12895, null)],
  },
  gK = "vscode://schemas/vscode-extensions",
  Q2 = {
    properties: {
      engines: {
        type: "object",
        description: f(12896, null),
        properties: {
          vscode: {
            type: "string",
            description: f(12897, null),
            default: "^1.22.0",
          },
        },
      },
      publisher: { description: f(12898, null), type: "string" },
      displayName: { description: f(12899, null), type: "string" },
      categories: {
        description: f(12900, null),
        type: "array",
        uniqueItems: !0,
        items: {
          oneOf: [
            { type: "string", enum: ndt },
            {
              type: "string",
              const: "Languages",
              deprecationMessage: f(12901, null),
            },
          ],
        },
      },
      galleryBanner: {
        type: "object",
        description: f(12902, null),
        properties: {
          color: { description: f(12903, null), type: "string" },
          theme: {
            description: f(12904, null),
            type: "string",
            enum: ["dark", "light"],
          },
        },
      },
      contributes: {
        description: f(12905, null),
        type: "object",
        properties: {},
        default: {},
      },
      preview: { type: "boolean", description: f(12906, null) },
      enableProposedApi: {
        type: "boolean",
        deprecationMessage: f(12907, null),
      },
      enabledApiProposals: {
        markdownDescription: f(12908, null),
        type: "array",
        uniqueItems: !0,
        items: {
          type: "string",
          enum: Object.keys(I7).map((i) => i),
          markdownEnumDescriptions: Object.values(I7).map((i) => i.proposal),
        },
      },
      api: {
        markdownDescription: f(12909, null),
        type: "string",
        enum: ["none"],
        enumDescriptions: [f(12910, null)],
      },
      activationEvents: {
        description: f(12911, null),
        type: "array",
        items: {
          type: "string",
          defaultSnippets: [
            {
              label: "onWebviewPanel",
              description: f(12912, null),
              body: "onWebviewPanel:viewType",
            },
            {
              label: "onLanguage",
              description: f(12913, null),
              body: "onLanguage:${1:languageId}",
            },
            {
              label: "onCommand",
              description: f(12914, null),
              body: "onCommand:${2:commandId}",
            },
            { label: "onDebug", description: f(12915, null), body: "onDebug" },
            {
              label: "onDebugInitialConfigurations",
              description: f(12916, null),
              body: "onDebugInitialConfigurations",
            },
            {
              label: "onDebugDynamicConfigurations",
              description: f(12917, null),
              body: "onDebugDynamicConfigurations",
            },
            {
              label: "onDebugResolve",
              description: f(12918, null),
              body: "onDebugResolve:${6:type}",
            },
            {
              label: "onDebugAdapterProtocolTracker",
              description: f(12919, null),
              body: "onDebugAdapterProtocolTracker:${6:type}",
            },
            {
              label: "workspaceContains",
              description: f(12920, null),
              body: "workspaceContains:${4:filePattern}",
            },
            {
              label: "onStartupFinished",
              description: f(12921, null),
              body: "onStartupFinished",
            },
            {
              label: "onTaskType",
              description: f(12922, null),
              body: "onTaskType:${1:taskType}",
            },
            {
              label: "onFileSystem",
              description: f(12923, null),
              body: "onFileSystem:${1:scheme}",
            },
            {
              label: "onEditSession",
              description: f(12924, null),
              body: "onEditSession:${1:scheme}",
            },
            {
              label: "onSearch",
              description: f(12925, null),
              body: "onSearch:${7:scheme}",
            },
            {
              label: "onView",
              body: "onView:${5:viewId}",
              description: f(12926, null),
            },
            { label: "onUri", body: "onUri", description: f(12927, null) },
            {
              label: "onOpenExternalUri",
              body: "onOpenExternalUri",
              description: f(12928, null),
            },
            {
              label: "onCustomEditor",
              body: "onCustomEditor:${9:viewType}",
              description: f(12929, null),
            },
            {
              label: "onNotebook",
              body: "onNotebook:${1:type}",
              description: f(12930, null),
            },
            {
              label: "onAuthenticationRequest",
              body: "onAuthenticationRequest:${11:authenticationProviderId}",
              description: f(12931, null),
            },
            {
              label: "onRenderer",
              description: f(12932, null),
              body: "onRenderer:${11:rendererId}",
            },
            {
              label: "onTerminalProfile",
              body: "onTerminalProfile:${1:terminalId}",
              description: f(12933, null),
            },
            {
              label: "onTerminalQuickFixRequest",
              body: "onTerminalQuickFixRequest:${1:quickFixId}",
              description: f(12934, null),
            },
            {
              label: "onWalkthrough",
              body: "onWalkthrough:${1:walkthroughID}",
              description: f(12935, null),
            },
            {
              label: "onIssueReporterOpened",
              body: "onIssueReporterOpened",
              description: f(12936, null),
            },
            {
              label: "onChatParticipant",
              body: "onChatParticipant:${1:participantId}",
              description: f(12937, null),
            },
            {
              label: "onLanguageModelTool",
              body: "onLanguageModelTool:${1:toolId}",
              description: f(12938, null),
            },
            {
              label: "onTerminalCompletionsRequested",
              body: "onTerminalCompletionsRequested",
              description: f(12939, null),
            },
            { label: "*", description: f(12940, null), body: "*" },
          ],
        },
      },
      badges: {
        type: "array",
        description: f(12941, null),
        items: {
          type: "object",
          required: ["url", "href", "description"],
          properties: {
            url: { type: "string", description: f(12942, null) },
            href: { type: "string", description: f(12943, null) },
            description: { type: "string", description: f(12944, null) },
          },
        },
      },
      markdown: {
        type: "string",
        description: f(12945, null),
        enum: ["github", "standard"],
        default: "github",
      },
      qna: {
        default: "marketplace",
        description: f(12946, null),
        anyOf: [
          { type: ["string", "boolean"], enum: ["marketplace", !1] },
          { type: "string" },
        ],
      },
      extensionDependencies: {
        description: f(12947, null),
        type: "array",
        uniqueItems: !0,
        items: { type: "string", pattern: c2 },
      },
      extensionPack: {
        description: f(12948, null),
        type: "array",
        uniqueItems: !0,
        items: { type: "string", pattern: c2 },
      },
      extensionKind: {
        description: f(12949, null),
        type: "array",
        items: V1t,
        default: ["workspace"],
        defaultSnippets: [
          { body: ["ui"], description: f(12950, null) },
          { body: ["workspace"], description: f(12951, null) },
          { body: ["ui", "workspace"], description: f(12952, null) },
          { body: ["workspace", "ui"], description: f(12953, null) },
          { body: [], description: f(12954, null) },
        ],
      },
      capabilities: {
        description: f(12955, null),
        type: "object",
        properties: {
          virtualWorkspaces: {
            description: f(12956, null),
            type: ["boolean", "object"],
            defaultSnippets: [
              {
                label: "limited",
                body: { supported: "${1:limited}", description: "${2}" },
              },
              { label: "false", body: { supported: !1, description: "${2}" } },
            ],
            default: (!0).valueOf,
            properties: {
              supported: {
                markdownDescription: f(12957, null),
                type: ["string", "boolean"],
                enum: ["limited", !0, !1],
                enumDescriptions: [
                  f(12958, null),
                  f(12959, null),
                  f(12960, null),
                ],
              },
              description: {
                type: "string",
                markdownDescription: f(12961, null),
              },
            },
          },
          untrustedWorkspaces: {
            description: f(12962, null),
            type: "object",
            required: ["supported"],
            defaultSnippets: [
              { body: { supported: "${1:limited}", description: "${2}" } },
            ],
            properties: {
              supported: {
                markdownDescription: f(12963, null),
                type: ["string", "boolean"],
                enum: ["limited", !0, !1],
                enumDescriptions: [
                  f(12964, null),
                  f(12965, null),
                  f(12966, null),
                ],
              },
              restrictedConfigurations: {
                description: f(12967, null),
                type: "array",
                items: { type: "string" },
              },
              description: {
                type: "string",
                markdownDescription: f(12968, null),
              },
            },
          },
        },
      },
      sponsor: {
        description: f(12969, null),
        type: "object",
        defaultSnippets: [{ body: { url: "${1:https:}" } }],
        properties: { url: { description: f(12970, null), type: "string" } },
      },
      scripts: {
        type: "object",
        properties: {
          "vscode:prepublish": { description: f(12971, null), type: "string" },
          "vscode:uninstall": { description: f(12972, null), type: "string" },
        },
      },
      icon: { type: "string", description: f(12973, null) },
      l10n: { type: "string", description: f(12974, null) },
      pricing: {
        type: "string",
        markdownDescription: f(12975, null),
        enum: ["Free", "Trial"],
        default: "Free",
      },
    },
  },
  G1t = class {
    constructor() {
      this.a = new Map()
    }
    registerExtensionPoint(i) {
      if (this.a.has(i.extensionPoint))
        throw new Error("Duplicate extension point: " + i.extensionPoint)
      const t = new j1t(
        i.extensionPoint,
        i.defaultExtensionKind,
        i.canHandleResolver,
      )
      return (
        this.a.set(i.extensionPoint, t),
        i.activationEventsGenerator &&
          bvt.register(i.extensionPoint, i.activationEventsGenerator),
        (Q2.properties.contributes.properties[i.extensionPoint] = i.jsonSchema),
        Y2.registerSchema(gK, Q2),
        t
      )
    }
    getExtensionPoints() {
      return Array.from(this.a.values())
    }
  },
  vK = { ExtensionsRegistry: "ExtensionsRegistry" }
ui.add(vK.ExtensionsRegistry, new G1t())
var z1t = ui.as(vK.ExtensionsRegistry)
Y2.registerSchema(gK, Q2),
  Y2.registerSchema(adt, {
    properties: {
      extensionEnabledApiProposals: {
        description: f(12976, null),
        type: "object",
        properties: {},
        additionalProperties: {
          anyOf: [
            {
              type: "array",
              uniqueItems: !0,
              items: {
                type: "string",
                enum: Object.keys(I7),
                markdownEnumDescriptions: Object.values(I7).map(
                  (i) => i.proposal,
                ),
              },
            },
          ],
        },
      },
    },
  })
var Y1t = {
    type: "object",
    additionalProperties: !1,
    properties: {
      type: { type: "string", description: f(10421, null) },
      required: { type: "array", items: { type: "string" } },
      properties: {
        type: "object",
        description: f(10422, null),
        additionalProperties: {
          $ref: "http://json-schema.org/draft-07/schema#",
        },
      },
      when: {
        type: "string",
        markdownDescription: f(10423, null),
        default: "",
      },
    },
  },
  X2
;(function (i) {
  function t(e, r, s) {
    if (!e) return
    const a = Bt(e.type) ? e.type : void 0
    if (!a || a.length === 0) {
      s.error(f(10424, null))
      return
    }
    const o = []
    if (Array.isArray(e.required))
      for (const c of e.required) Bt(c) && o.push(c)
    return {
      extensionId: r.value,
      taskType: a,
      required: o,
      properties: e.properties ? pe(e.properties) : {},
      when: e.when ? ze.deserialize(e.when) : void 0,
    }
  }
  i.from = t
})(X2 || (X2 = {}))
var Q1t = z1t.registerExtensionPoint({
    extensionPoint: "taskDefinitions",
    activationEventsGenerator: (i, t) => {
      for (const e of i) e.type && t.push(`onTaskType:${e.type}`)
    },
    jsonSchema: { description: f(10425, null), type: "array", items: Y1t },
  }),
  X1t = class {
    constructor() {
      ;(this.d = new C()),
        (this.onDefinitionsChanged = this.d.event),
        (this.a = Object.create(null)),
        (this.b = new Promise((i, t) => {
          Q1t.setHandler((e, r) => {
            this.c = void 0
            try {
              for (const s of r.removed) {
                const a = s.value
                for (const o of a)
                  this.a && o.type && this.a[o.type] && delete this.a[o.type]
              }
              for (const s of r.added) {
                const a = s.value
                for (const o of a) {
                  const c = X2.from(o, s.description.identifier, s.collector)
                  c && (this.a[c.taskType] = c)
                }
              }
              ;(r.removed.length > 0 || r.added.length > 0) && this.d.fire()
            } catch {}
            i(void 0)
          })
        }))
    }
    onReady() {
      return this.b
    }
    get(i) {
      return this.a[i]
    }
    all() {
      return Object.keys(this.a).map((i) => this.a[i])
    }
    getJsonSchema() {
      if (this.c === void 0) {
        const i = []
        for (const t of this.all()) {
          const e = { type: "object", additionalProperties: !1 }
          t.required.length > 0 && (e.required = t.required.slice(0)),
            t.properties !== void 0
              ? (e.properties = pe(t.properties))
              : (e.properties = Object.create(null)),
            (e.properties.type = { type: "string", enum: [t.taskType] }),
            i.push(e)
        }
        this.c = { oneOf: i }
      }
      return this.c
    }
  },
  K1t = new X1t(),
  Z1t = "settings",
  qqt = new H("taskRunning", !1, f(10426, null)),
  Uqt = fB(10428, "Tasks"),
  P7
;(function (i) {
  ;(i[(i.Escape = 1)] = "Escape"),
    (i[(i.Strong = 2)] = "Strong"),
    (i[(i.Weak = 3)] = "Weak")
})(P7 || (P7 = {})),
  (function (i) {
    function t(e) {
      if (!e) return i.Strong
      switch (e.toLowerCase()) {
        case "escape":
          return i.Escape
        case "strong":
          return i.Strong
        case "weak":
          return i.Weak
        default:
          return i.Strong
      }
    }
    i.from = t
  })(P7 || (P7 = {}))
var wK
;(function (i) {
  i.defaults = { cwd: "${workspaceFolder}" }
})(wK || (wK = {}))
var Hd
;(function (i) {
  ;(i[(i.Always = 1)] = "Always"),
    (i[(i.Silent = 2)] = "Silent"),
    (i[(i.Never = 3)] = "Never")
})(Hd || (Hd = {})),
  (function (i) {
    function t(e) {
      switch (e.toLowerCase()) {
        case "always":
          return i.Always
        case "silent":
          return i.Silent
        case "never":
          return i.Never
        default:
          return i.Always
      }
    }
    i.fromString = t
  })(Hd || (Hd = {}))
var Wd
;(function (i) {
  ;(i[(i.Never = 1)] = "Never"),
    (i[(i.OnProblem = 2)] = "OnProblem"),
    (i[(i.Always = 3)] = "Always")
})(Wd || (Wd = {})),
  (function (i) {
    function t(e) {
      switch (e.toLowerCase()) {
        case "always":
          return i.Always
        case "never":
          return i.Never
        case "onproblem":
          return i.OnProblem
        default:
          return i.OnProblem
      }
    }
    i.fromString = t
  })(Wd || (Wd = {}))
var jd
;(function (i) {
  ;(i[(i.Shared = 1)] = "Shared"),
    (i[(i.Dedicated = 2)] = "Dedicated"),
    (i[(i.New = 3)] = "New")
})(jd || (jd = {})),
  (function (i) {
    function t(e) {
      switch (e.toLowerCase()) {
        case "shared":
          return i.Shared
        case "dedicated":
          return i.Dedicated
        case "new":
          return i.New
        default:
          return i.Shared
      }
    }
    i.fromString = t
  })(jd || (jd = {}))
var yK
;(function (i) {
  i.defaults = {
    echo: !0,
    reveal: Hd.Always,
    revealProblems: Wd.Never,
    focus: !1,
    panel: jd.Shared,
    showReuseMessage: !0,
    clear: !1,
  }
})(yK || (yK = {}))
var N7
;(function (i) {
  ;(i[(i.Shell = 1)] = "Shell"),
    (i[(i.Process = 2)] = "Process"),
    (i[(i.CustomExecution = 3)] = "CustomExecution")
})(N7 || (N7 = {})),
  (function (i) {
    function t(r) {
      switch (r.toLowerCase()) {
        case "shell":
          return i.Shell
        case "process":
          return i.Process
        case "customExecution":
          return i.CustomExecution
        default:
          return i.Process
      }
    }
    i.fromString = t
    function e(r) {
      switch (r) {
        case i.Shell:
          return "shell"
        case i.Process:
          return "process"
        case i.CustomExecution:
          return "customExecution"
        default:
          return "process"
      }
    }
    i.toString = e
  })(N7 || (N7 = {}))
var TK
;(function (i) {
  function t(e) {
    return Bt(e) ? e : e.value
  }
  i.value = t
})(TK || (TK = {}))
var kK
;(function (i) {
  ;(i.Clean = { _id: "clean", isDefault: !1 }),
    (i.Build = { _id: "build", isDefault: !1 }),
    (i.Rebuild = { _id: "rebuild", isDefault: !1 }),
    (i.Test = { _id: "test", isDefault: !1 })
  function t(r) {
    return (
      r === i.Clean._id ||
      r === i.Build._id ||
      r === i.Rebuild._id ||
      r === i.Test._id
    )
  }
  i.is = t
  function e(r) {
    if (r !== void 0)
      return Bt(r) ? (t(r) ? { _id: r, isDefault: !1 } : void 0) : r
  }
  i.from = e
})(kK || (kK = {}))
var SK
;(function (i) {
  ;(i[(i.Global = 1)] = "Global"),
    (i[(i.Workspace = 2)] = "Workspace"),
    (i[(i.Folder = 3)] = "Folder")
})(SK || (SK = {}))
var bK
;(function (i) {
  ;(i.Workspace = "workspace"),
    (i.Extension = "extension"),
    (i.InMemory = "inMemory"),
    (i.WorkspaceFile = "workspaceFile"),
    (i.User = "user")
  function t(e) {
    switch (e) {
      case i.User:
        return 2
      case i.WorkspaceFile:
        return 5
      default:
        return 6
    }
  }
  i.toConfigurationTarget = t
})(bK || (bK = {}))
var EK
;(function (i) {
  ;(i.parallel = "parallel"), (i.sequence = "sequence")
})(EK || (EK = {}))
var K2
;(function (i) {
  ;(i[(i.default = 1)] = "default"), (i[(i.folderOpen = 2)] = "folderOpen")
})(K2 || (K2 = {}))
var IK
;(function (i) {
  i.defaults = { reevaluateOnRerun: !0, runOn: K2.default, instanceLimit: 1 }
})(IK || (IK = {}))
var $7
;(function (i) {
  ;(i[(i.Process = 1)] = "Process"), (i[(i.Terminal = 2)] = "Terminal")
})($7 || ($7 = {})),
  (function (i) {
    i._default = i.Terminal
  })($7 || ($7 = {}))
var PK
;(function (i) {
  ;(i[(i.V0_1_0 = 1)] = "V0_1_0"), (i[(i.V2_0_0 = 2)] = "V2_0_0")
})(PK || (PK = {}))
var NK
;(function (i) {
  ;(i.DependsOnStarted = "dependsOnStarted"),
    (i.AcquiredInput = "acquiredInput"),
    (i.Start = "start"),
    (i.ProcessStarted = "processStarted"),
    (i.Active = "active"),
    (i.Inactive = "inactive"),
    (i.Changed = "changed"),
    (i.Terminated = "terminated"),
    (i.ProcessEnded = "processEnded"),
    (i.End = "end")
})(NK || (NK = {}))
var $K
;(function (i) {
  ;(i.SingleRun = "singleRun"), (i.Background = "background")
})($K || ($K = {}))
var xK
;(function (i) {
  ;(i[(i.System = 0)] = "System"),
    (i[(i.User = 1)] = "User"),
    (i[(i.FolderOpen = 2)] = "FolderOpen"),
    (i[(i.ConfigurationChange = 3)] = "ConfigurationChange"),
    (i[(i.Reconnect = 4)] = "Reconnect")
})(xK || (xK = {}))
var JK
;(function (i) {
  function t(u) {
    return {
      taskId: u._id,
      taskName: u.configurationProperties.name,
      runType: u.configurationProperties.isBackground
        ? "background"
        : "singleRun",
      group: u.configurationProperties.group,
      __task: u,
    }
  }
  function e(u, l, m) {
    return { ...t(u), kind: "start", terminalId: l, resolvedVariables: m }
  }
  i.start = e
  function r(u, l, m) {
    return { ...t(u), kind: "processStarted", terminalId: l, processId: m }
  }
  i.processStarted = r
  function s(u, l, m) {
    return { ...t(u), kind: "processEnded", terminalId: l, exitCode: m }
  }
  i.processEnded = s
  function a(u, l, m) {
    return { ...t(u), kind: "terminated", exitReason: m, terminalId: l }
  }
  i.terminated = a
  function o(u, l, m) {
    return { ...t(l), kind: u, terminalId: m }
  }
  i.general = o
  function c() {
    return { kind: "changed" }
  }
  i.changed = c
})(JK || (JK = {}))
var x7
;(function (i) {
  function t(r) {
    const s = Object.keys(r).sort()
    let a = ""
    for (const o of s) {
      let c = r[o]
      c instanceof Object
        ? (c = t(c))
        : typeof c == "string" && (c = c.replace(/,/g, ",,")),
        (a += o + "," + c + ",")
    }
    return a
  }
  function e(r) {
    const a = { _key: t(r), type: r.taskType }
    return Object.assign(a, r), a
  }
  i.create = e
})(x7 || (x7 = {}))
var CK
;(function (i) {
  ;(i.AutoDetect = "task.autoDetect"),
    (i.SaveBeforeRun = "task.saveBeforeRun"),
    (i.ShowDecorations = "task.showDecorations"),
    (i.ProblemMatchersNeverPrompt = "task.problemMatchers.neverPrompt"),
    (i.SlowProviderWarning = "task.slowProviderWarning"),
    (i.QuickOpenHistory = "task.quickOpen.history"),
    (i.QuickOpenDetail = "task.quickOpen.detail"),
    (i.QuickOpenSkip = "task.quickOpen.skip"),
    (i.QuickOpenShowAll = "task.quickOpen.showAll"),
    (i.AllowAutomaticTasks = "task.allowAutomaticTasks"),
    (i.Reconnection = "task.reconnection"),
    (i.VerboseLogging = "task.verboseLogging")
})(CK || (CK = {}))
var LK
;(function (i) {
  ;(i.Tasks = "tasks"),
    (i.SuppressTaskName = "tasks.suppressTaskName"),
    (i.Windows = "tasks.windows"),
    (i.Osx = "tasks.osx"),
    (i.Linux = "tasks.linux"),
    (i.ShowOutput = "tasks.showOutput"),
    (i.IsShellCommand = "tasks.isShellCommand"),
    (i.ServiceTestSetting = "tasks.service.testSetting")
})(LK || (LK = {}))
var RK
;(function (i) {
  function t(e, r) {
    const s = K1t.get(e.type)
    if (s === void 0) {
      const u = pe(e)
      return delete u._key, x7.create(u)
    }
    const a = Object.create(null)
    a.type = s.taskType
    const o = new Set()
    s.required.forEach((u) => o.add(u))
    const c = s.properties
    for (const u of Object.keys(c)) {
      const l = e[u]
      if (l != null) a[u] = l
      else if (o.has(u)) {
        const m = c[u]
        if (m.default !== void 0) a[u] = pe(m.default)
        else
          switch (m.type) {
            case "boolean":
              a[u] = !1
              break
            case "number":
            case "integer":
              a[u] = 0
              break
            case "string":
              a[u] = ""
              break
            default:
              r.error(f(10427, null, JSON.stringify(e, void 0, 0), u))
              return
          }
      }
    }
    return x7.create(a)
  }
  i.createTaskIdentifier = t
})(RK || (RK = {}))
var J7
;(function (i) {
  function t(r) {
    if (r != null) return r
  }
  i.from = t
  function e(r) {
    if (r != null) return r
  }
  i.to = e
})(J7 || (J7 = {}))
var C7
;(function (i) {
  function t(r) {
    if (r != null) return r
  }
  i.from = t
  function e(r) {
    if (r != null) return r
  }
  i.to = e
})(C7 || (C7 = {}))
var Z2
;(function (i) {
  function t(r) {
    if (r != null) return r
  }
  i.from = t
  function e(r) {
    if (r != null) return r
  }
  i.to = e
})(Z2 || (Z2 = {}))
var Vd
;(function (i) {
  function t(s) {
    if (s) {
      const a = s
      return a && !!a.process
    } else return !1
  }
  i.is = t
  function e(s) {
    if (s == null) return
    const a = { process: s.process, args: s.args }
    return s.options && (a.options = Z2.from(s.options)), a
  }
  i.from = e
  function r(s) {
    if (s != null) return new Ho(s.process, s.args, s.options)
  }
  i.to = r
})(Vd || (Vd = {}))
var tU
;(function (i) {
  function t(r) {
    if (r != null) return r
  }
  i.from = t
  function e(r) {
    if (r != null) return r
  }
  i.to = e
})(tU || (tU = {}))
var Gd
;(function (i) {
  function t(s) {
    if (s) {
      const a = s
      return a && (!!a.commandLine || !!a.command)
    } else return !1
  }
  i.is = t
  function e(s) {
    if (s == null) return
    const a = {}
    return (
      s.commandLine !== void 0
        ? (a.commandLine = s.commandLine)
        : ((a.command = s.command), (a.args = s.args)),
      s.options && (a.options = tU.from(s.options)),
      a
    )
  }
  i.from = e
  function r(s) {
    if (!(s == null || (s.command === void 0 && s.commandLine === void 0)))
      return s.commandLine
        ? new Sa(s.commandLine, s.options)
        : new Sa(s.command, s.args ? s.args : [], s.options)
  }
  i.to = r
})(Gd || (Gd = {}))
var Bn
;(function (i) {
  function t(s) {
    if (s) {
      const a = s
      return a && a.customExecution === "customExecution"
    } else return !1
  }
  i.is = t
  function e(s) {
    return { customExecution: "customExecution" }
  }
  i.from = e
  function r(s, a) {
    return a.get(s)
  }
  i.to = r
})(Bn || (Bn = {}))
var DK
;(function (i) {
  function t(e, r) {
    let s
    return (
      e.scope !== void 0 && typeof e.scope != "number"
        ? (s = e.scope.uri)
        : e.scope !== void 0 &&
          typeof e.scope == "number" &&
          (e.scope === gs.Workspace && r && r.workspaceFile
            ? (s = r.workspaceFile)
            : (s = Z1t)),
      { id: e._id, workspaceFolder: s }
    )
  }
  i.from = t
})(DK || (DK = {}))
var eU
;(function (i) {
  function t(e) {
    if (e != null) return { _id: e.id, isDefault: e.isDefault }
  }
  i.from = t
})(eU || (eU = {}))
var _s
;(function (i) {
  function t(s, a) {
    if (s == null) return []
    const o = []
    for (const c of s) {
      const u = e(c, a)
      u && o.push(u)
    }
    return o
  }
  i.fromMany = t
  function e(s, a) {
    if (s == null) return
    let o
    s.execution instanceof Ho
      ? (o = Vd.from(s.execution))
      : s.execution instanceof Sa
        ? (o = Gd.from(s.execution))
        : s.execution && s.execution instanceof dO && (o = Bn.from(s.execution))
    const c = J7.from(s.definition)
    let u
    return (
      s.scope
        ? typeof s.scope == "number"
          ? (u = s.scope)
          : (u = s.scope.uri)
        : (u = gs.Workspace),
      !c || !u
        ? void 0
        : {
            _id: s._id,
            definition: c,
            name: s.name,
            source: {
              extensionId: a.identifier.value,
              label: s.source,
              scope: u,
            },
            execution: o,
            isBackground: s.isBackground,
            group: eU.from(s.group),
            presentationOptions: C7.from(s.presentationOptions),
            problemMatchers: Yr(s.problemMatchers),
            hasDefinedMatchers: s.hasDefinedMatchers,
            runOptions: s.runOptions ? s.runOptions : { reevaluateOnRerun: !0 },
            detail: s.detail,
          }
    )
  }
  i.from = e
  async function r(s, a, o) {
    if (s == null) return
    let c
    Vd.is(s.execution)
      ? (c = Vd.to(s.execution))
      : Gd.is(s.execution)
        ? (c = Gd.to(s.execution))
        : Bn.is(s.execution) && (c = Bn.to(s._id, o))
    const u = J7.to(s.definition)
    let l
    if (
      (s.source &&
        (s.source.scope !== void 0
          ? typeof s.source.scope == "number"
            ? (l = s.source.scope)
            : (l = await a.resolveWorkspaceFolder(S.revive(s.source.scope)))
          : (l = gs.Workspace)),
      !u || !l)
    )
      return
    const m = new T6(u, l, s.name, s.source.label, c, s.problemMatchers)
    return (
      s.isBackground !== void 0 && (m.isBackground = s.isBackground),
      s.group !== void 0 &&
        ((m.group = Sl.from(s.group._id)),
        m.group &&
          s.group.isDefault &&
          ((m.group = new Sl(m.group.id, m.group.label)),
          s.group.isDefault === !0 && (m.group.isDefault = s.group.isDefault))),
      s.presentationOptions &&
        (m.presentationOptions = C7.to(s.presentationOptions)),
      s._id && (m._id = s._id),
      s.detail && (m.detail = s.detail),
      m
    )
  }
  i.to = r
})(_s || (_s = {}))
var iU
;(function (i) {
  function t(r) {
    return r
  }
  i.from = t
  function e(r) {
    if (r) return Object.assign(Object.create(null), r)
  }
  i.to = e
})(iU || (iU = {}))
var rU = class {
    #t
    constructor(i, t, e) {
      ;(this._id = t), (this.a = e), (this.#t = i)
    }
    get task() {
      return this.a
    }
    terminate() {
      this.#t.terminateTask(this)
    }
    fireDidStartProcess(i) {}
    fireDidEndProcess(i) {}
  },
  nU = class {
    constructor(t, e, r, s, a, o, c, u) {
      ;(this.q = new C()),
        (this.r = new C()),
        (this.s = new C()),
        (this.u = new C()),
        (this.a = t.getProxy(z.MainThreadTask)),
        (this.b = r),
        (this.c = s),
        (this.d = a),
        (this.e = o),
        (this.h = 0),
        (this.j = new Map()),
        (this.k = new Map()),
        (this.l = new Map()),
        (this.m = new Map()),
        (this.n = new Set()),
        (this.o = new Map()),
        (this.f = c),
        (this.g = u),
        this.a.$registerSupportedExecutions(!0)
    }
    registerTaskProvider(t, e, r) {
      if (!r) return new At(() => {})
      const s = this.x()
      return (
        this.j.set(s, { type: e, provider: r, extension: t }),
        this.a.$registerTaskProvider(s, e),
        new At(() => {
          this.j.delete(s), this.a.$unregisterTaskProvider(s)
        })
      )
    }
    registerTaskSystem(t, e) {
      this.a.$registerTaskSystem(t, e)
    }
    fetchTasks(t) {
      return this.a.$fetchTasks(iU.from(t)).then(async (e) => {
        const r = []
        for (const s of e) {
          const a = await _s.to(s, this.b, this.m)
          a && r.push(a)
        }
        return r
      })
    }
    get taskExecutions() {
      const t = []
      return this.k.forEach((e) => t.push(e)), t
    }
    terminateTask(t) {
      if (!(t instanceof rU))
        throw new Error("No valid task execution provided")
      return this.a.$terminateTask(t._id)
    }
    get onDidStartTask() {
      return this.q.event
    }
    async $onDidStartTask(t, e, r) {
      const s = this.m.get(t.id)
      s &&
        (this.o.set(t.id, s),
        this.e.attachPtyToTerminal(e, await s.callback(r))),
        (this.p = t.id),
        this.q.fire({ execution: await this.z(t) })
    }
    get onDidEndTask() {
      return this.r.event
    }
    async $OnDidEndTask(t) {
      if (!this.l.has(t.id)) return
      const e = await this.z(t)
      this.l.delete(t.id),
        this.k.delete(t.id),
        this.B(t),
        this.r.fire({ execution: e })
    }
    get onDidStartTaskProcess() {
      return this.s.event
    }
    async $onDidStartTaskProcess(t) {
      const e = await this.z(t.id)
      this.s.fire({ execution: e, processId: t.processId })
    }
    get onDidEndTaskProcess() {
      return this.u.event
    }
    async $onDidEndTaskProcess(t) {
      const e = await this.z(t.id)
      this.u.fire({ execution: e, exitCode: t.exitCode })
    }
    $provideTasks(t, e) {
      const r = this.j.get(t)
      if (!r) return Promise.reject(new Error("no handler found"))
      const s = [],
        a = gi(() => r.provider.provideTasks(fe.None)).then((o) =>
          this.v(e, s, r, o),
        )
      return new Promise((o) => {
        a.then((c) => {
          Promise.all(s).then(() => {
            o(c)
          })
        })
      })
    }
    async $resolveTask(t, e) {
      const r = this.j.get(t)
      if (!r) return Promise.reject(new Error("no handler found"))
      if (e.definition.type !== r.type)
        throw new Error(
          `Unexpected: Task of type [${e.definition.type}] cannot be resolved by provider of type [${r.type}].`,
        )
      const s = await _s.to(e, this.b, this.m)
      if (!s) throw new Error("Unexpected: Task cannot be resolved.")
      const a = await r.provider.resolveTask(s, fe.None)
      if (!a) return
      this.A(a, r)
      const o = _s.from(a, r.extension)
      if (!o) throw new Error("Unexpected: Task cannot be resolved.")
      if (a.definition !== s.definition)
        throw new Error(
          "Unexpected: The resolved task definition must be the same object as the original task definition. The task definition cannot be changed.",
        )
      return Bn.is(o.execution) && (await this.y(o, a, !0)), await this.w(o)
    }
    x() {
      return this.h++
    }
    async y(t, e, r) {
      const s = await this.a.$createTaskId(t)
      !r && !this.m.has(s) && (this.n.add(s), this.o.set(s, e.execution)),
        this.m.set(s, e.execution)
    }
    async z(t, e) {
      if (typeof t == "string") {
        const a = this.l.get(t)
        if (!a)
          throw new Kn("Unexpected: The specified task is missing an execution")
        return a
      }
      const r = this.l.get(t.id)
      if (r) return r
      let s
      return (
        e
          ? (s = Promise.resolve(new rU(this, t.id, e)))
          : (s = _s.to(t.task, this.b, this.m).then((a) => {
              if (!a) throw new Kn("Unexpected: Task does not exist.")
              return new rU(this, t.id, a)
            })),
        this.l.set(t.id, s),
        s.then((a) => (this.k.set(t.id, a), a))
      )
    }
    A(t, e) {
      t._deprecated &&
        this.g.report(
          "Task.constructor",
          e.extension,
          "Use the Task constructor that takes a `scope` instead.",
        )
    }
    B(t) {
      this.o.get(t.id) && this.o.delete(t.id),
        this.n.has(t.id) &&
          this.p !== t.id &&
          (this.m.delete(t.id), this.n.delete(t.id))
      const r = this.n.values()
      let s = r.next()
      for (; !s.done; )
        !this.o.has(s.value) &&
          this.p !== s.value &&
          (this.m.delete(s.value), this.n.delete(s.value)),
          (s = r.next())
    }
  }
nU = __decorate(
  [
    __param(0, Vt),
    __param(1, ci),
    __param(2, _n),
    __param(3, xc),
    __param(4, An),
    __param(5, Pc),
    __param(6, Kt),
    __param(7, E7),
  ],
  nU,
)
var sU = class extends nU {
  constructor(t, e, r, s, a, o, c, u) {
    super(t, e, r, s, a, o, c, u),
      this.registerTaskSystem(Q.vscodeRemote, {
        scheme: Q.vscodeRemote,
        authority: "",
        platform: Gat(0),
      })
  }
  async executeTask(t, e) {
    if (!e.execution)
      throw new Error("Tasks to execute must include an execution")
    const r = _s.from(e, t)
    if (r === void 0) throw new Error("Task is not valid")
    if (Bn.is(r.execution)) await this.y(r, e, !1)
    else throw new rB()
    const s = await this.z(await this.a.$getTaskExecution(r), e)
    return (
      this.a.$executeTask(r).catch((a) => {
        throw new Error(a)
      }),
      s
    )
  }
  v(t, e, r, s) {
    const a = []
    if (s)
      for (const o of s) {
        if ((this.A(o, r), !o.definition || !t[o.definition.type])) {
          const u = o.source ? o.source : "No task source"
          this.f.warn(
            `The task [${u}, ${o.name}] uses an undefined task type. The task will be ignored in the future.`,
          )
        }
        const c = _s.from(o, r.extension)
        c && Bn.is(c.execution)
          ? (a.push(c), e.push(this.y(c, o, !0)))
          : this.f.warn("Only custom execution tasks supported.")
      }
    return { tasks: a, extension: r.extension }
  }
  async w(t) {
    if (Bn.is(t.execution)) return t
    this.f.warn("Only custom execution tasks supported.")
  }
  async $resolveVariables(t, e) {
    return { process: void 0, variables: Object.create(null) }
  }
  async $jsonTasksSupported() {
    return !1
  }
  async $findExecutable(t, e, r) {}
}
sU = __decorate(
  [
    __param(0, Vt),
    __param(1, ci),
    __param(2, _n),
    __param(3, xc),
    __param(4, An),
    __param(5, Pc),
    __param(6, Kt),
    __param(7, E7),
  ],
  sU,
)
var FK = Y("IExtHostTask"),
  twt = class {
    constructor() {
      ;(this.f = new Map()),
        (this.m = []),
        (this.n = new C()),
        (this.o = new C()),
        (this.d = 1)
    }
    get onError() {
      return this.n.event
    }
    get onExit() {
      return this.o.event
    }
    onMessage(i) {
      this.k &&
        this.n.fire(
          new Error("attempt to set more than one 'Message' callback"),
        ),
        (this.k = i)
    }
    onEvent(i) {
      this.j &&
        this.n.fire(new Error("attempt to set more than one 'Event' callback")),
        (this.j = i)
    }
    onRequest(i) {
      this.g &&
        this.n.fire(
          new Error("attempt to set more than one 'Request' callback"),
        ),
        (this.g = i)
    }
    sendResponse(i) {
      i.seq > 0
        ? this.n.fire(
            new Error(
              `attempt to send more than one response for command ${i.command}`,
            ),
          )
        : this.u("response", i)
    }
    sendRequest(i, t, e, r) {
      const s = { command: i }
      if (
        (t && Object.keys(t).length > 0 && (s.arguments = t),
        this.u("request", s),
        typeof r == "number")
      ) {
        const a = setTimeout(() => {
          clearTimeout(a)
          const o = this.f.get(s.seq)
          if (o) {
            this.f.delete(s.seq)
            const c = {
              type: "response",
              seq: 0,
              request_seq: s.seq,
              success: !1,
              command: i,
              message: f(6137, null, r, i),
            }
            o(c)
          }
        }, r)
      }
      return e && this.f.set(s.seq, e), s.seq
    }
    acceptMessage(i) {
      this.k ? this.k(i) : (this.m.push(i), this.m.length === 1 && this.s())
    }
    q(i, t) {
      return i.type !== "event" || t.type !== "event"
    }
    async s() {
      let i
      for (; this.m.length; ) {
        if (
          ((!i || this.q(this.m[0], i)) && (await Kr(0)),
          (i = this.m.shift()),
          !i)
        )
          return
        switch (i.type) {
          case "event":
            this.j?.(i)
            break
          case "request":
            this.g?.(i)
            break
          case "response": {
            const t = i,
              e = this.f.get(t.request_seq)
            e && (this.f.delete(t.request_seq), e(t))
            break
          }
        }
      }
    }
    u(i, t) {
      ;(t.type = i), (t.seq = this.d++), this.sendMessage(t)
    }
    async w() {
      if (this.f.size === 0) return Promise.resolve()
      const i = new Map()
      this.f.forEach((t, e) => i.set(e, t)),
        await Kr(500),
        i.forEach((t, e) => {
          t({
            type: "response",
            seq: 0,
            request_seq: e,
            success: !1,
            command: "canceled",
            message: "canceled",
          }),
            this.f.delete(e)
        })
    }
    getPendingRequestIds() {
      return Array.from(this.f.keys())
    }
    dispose() {
      this.m = []
    }
  }
function ewt(i) {
  return i.type && (i.label || i.program || i.runtime)
}
var iwt = /^[a-zA-Z][a-zA-Z0-9\+\-\.]+:/
function rwt(i) {
  return !!(i && i.match(iwt))
}
function _K(i) {
  if (
    typeof i.path == "string" &&
    !(typeof i.sourceReference == "number" && i.sourceReference > 0)
  ) {
    if (rwt(i.path)) return S.parse(i.path)
    if (t_(i.path)) return S.file(i.path)
  }
  return i.path
}
function AK(i) {
  if (typeof i.path == "object") {
    const t = S.revive(i.path)
    if (t) return t.scheme === Q.file ? t.fsPath : t.toString()
  }
  return i.path
}
function nwt(i, t) {
  const e = t ? _K : AK,
    r = pe(i)
  return (
    BK(r, (s, a) => {
      s && a && (a.path = e(a))
    }),
    r
  )
}
function swt(i, t) {
  const e = t ? _K : AK,
    r = pe(i)
  return (
    BK(r, (s, a) => {
      !s && a && (a.path = e(a))
    }),
    r
  )
}
function BK(i, t) {
  switch (i.type) {
    case "event": {
      const e = i
      switch (e.event) {
        case "output":
          t(!1, e.body.source)
          break
        case "loadedSource":
          t(!1, e.body.source)
          break
        case "breakpoint":
          t(!1, e.body.breakpoint.source)
          break
        default:
          break
      }
      break
    }
    case "request": {
      const e = i
      switch (e.command) {
        case "setBreakpoints":
          t(!0, e.arguments.source)
          break
        case "breakpointLocations":
          t(!0, e.arguments.source)
          break
        case "source":
          t(!0, e.arguments.source)
          break
        case "gotoTargets":
          t(!0, e.arguments.source)
          break
        case "launchVSCode":
          e.arguments.args.forEach((r) => t(!1, r))
          break
        default:
          break
      }
      break
    }
    case "response": {
      const e = i
      if (e.success && e.body)
        switch (e.command) {
          case "stackTrace":
            e.body.stackFrames.forEach((r) => t(!1, r.source))
            break
          case "loadedSources":
            e.body.sources.forEach((r) => t(!1, r))
            break
          case "scopes":
            e.body.scopes.forEach((r) => t(!1, r.source))
            break
          case "setFunctionBreakpoints":
            e.body.breakpoints.forEach((r) => t(!1, r.source))
            break
          case "setBreakpoints":
            e.body.breakpoints.forEach((r) => t(!1, r.source))
            break
          case "disassemble":
            e.body?.instructions.forEach((s) => t(!1, s.location))
            break
          case "locations":
            t(!1, e.body?.source)
            break
          default:
            break
        }
      break
    }
  }
}
var zd = Y("IExtHostEditorTabs"),
  OK = class {
    constructor(i, t, e) {
      ;(this.e = e), (this.d = t), this.acceptDtoUpdate(i)
    }
    get apiObject() {
      if (!this.a) {
        const i = this,
          t = {
            get isActive() {
              return i.b.id === i.e()
            },
            get label() {
              return i.b.label
            },
            get input() {
              return i.c
            },
            get isDirty() {
              return i.b.isDirty
            },
            get isPinned() {
              return i.b.isPinned
            },
            get isPreview() {
              return i.b.isPreview
            },
            get group() {
              return i.d.apiObject
            },
          }
        this.a = Object.freeze(t)
      }
      return this.a
    }
    get tabId() {
      return this.b.id
    }
    acceptDtoUpdate(i) {
      ;(this.b = i), (this.c = this.f())
    }
    f() {
      switch (this.b.input.kind) {
        case 1:
          return new JO(S.revive(this.b.input.uri))
        case 2:
          return new j6(
            S.revive(this.b.input.original),
            S.revive(this.b.input.modified),
          )
        case 3:
          return new lY(
            S.revive(this.b.input.base),
            S.revive(this.b.input.input1),
            S.revive(this.b.input.input2),
            S.revive(this.b.input.result),
          )
        case 6:
          return new CO(S.revive(this.b.input.uri), this.b.input.viewType)
        case 7:
          return new dY(this.b.input.viewType)
        case 4:
          return new LO(S.revive(this.b.input.uri), this.b.input.notebookType)
        case 5:
          return new RO(
            S.revive(this.b.input.original),
            S.revive(this.b.input.modified),
            this.b.input.notebookType,
          )
        case 8:
          return new mY()
        case 9:
          return new hY(
            S.revive(this.b.input.uri),
            S.revive(this.b.input.inputBoxUri),
          )
        case 10:
          return new fY()
        case 11:
          return new pY(
            this.b.input.diffEditors.map(
              (i) => new j6(S.revive(i.original), S.revive(i.modified)),
            ),
          )
        default:
          return
      }
    }
  },
  awt = class {
    constructor(i, t) {
      ;(this.c = []), (this.d = ""), (this.b = i), (this.e = t)
      for (const e of i.tabs)
        e.isActive && (this.d = e.id),
          this.c.push(new OK(e, this, () => this.activeTabId()))
    }
    get apiObject() {
      if (!this.a) {
        const i = this,
          t = {
            get isActive() {
              return i.b.groupId === i.e()
            },
            get viewColumn() {
              return Me.to(i.b.viewColumn)
            },
            get activeTab() {
              return i.c.find((e) => e.tabId === i.d)?.apiObject
            },
            get tabs() {
              return Object.freeze(i.c.map((e) => e.apiObject))
            },
          }
        this.a = Object.freeze(t)
      }
      return this.a
    }
    get groupId() {
      return this.b.groupId
    }
    get tabs() {
      return this.c
    }
    acceptGroupDtoUpdate(i) {
      this.b = i
    }
    acceptTabOperation(i) {
      if (i.kind === 0) {
        const e = new OK(i.tabDto, this, () => this.activeTabId())
        return (
          this.c.splice(i.index, 0, e),
          i.tabDto.isActive && (this.d = e.tabId),
          e
        )
      } else if (i.kind === 1) {
        const e = this.c.splice(i.index, 1)[0]
        if (!e)
          throw new Error(
            `Tab close updated received for index ${i.index} which does not exist`,
          )
        return e.tabId === this.d && (this.d = ""), e
      } else if (i.kind === 3) {
        if (i.oldIndex === void 0)
          throw new Error("Invalid old index on move IPC")
        const e = this.c.splice(i.oldIndex, 1)[0]
        if (!e)
          throw new Error(
            `Tab move updated received for index ${i.oldIndex} which does not exist`,
          )
        return this.c.splice(i.index, 0, e), e
      }
      const t = this.c.find((e) => e.tabId === i.tabDto.id)
      if (!t) throw new Error("INVALID tab")
      return (
        i.tabDto.isActive
          ? (this.d = i.tabDto.id)
          : this.d === i.tabDto.id && !i.tabDto.isActive && (this.d = ""),
        t.acceptDtoUpdate(i.tabDto),
        t
      )
    }
    activeTabId() {
      return this.d
    }
  },
  aU = class {
    constructor(t) {
      ;(this.b = new C()),
        (this.c = new C()),
        (this.e = []),
        (this.a = t.getProxy(z.MainThreadEditorTabs))
    }
    get tabGroups() {
      if (!this.f) {
        const t = this,
          e = {
            onDidChangeTabGroups: t.c.event,
            onDidChangeTabs: t.b.event,
            get all() {
              return Object.freeze(t.e.map((r) => r.apiObject))
            },
            get activeTabGroup() {
              const r = t.d
              return fo(t.e.find((a) => a.groupId === r)?.apiObject)
            },
            close: async (r, s) => {
              const a = Array.isArray(r) ? r : [r]
              return a.length ? (owt(a[0]) ? this.j(a, s) : this.i(a, s)) : !0
            },
          }
        this.f = Object.freeze(e)
      }
      return this.f
    }
    $acceptEditorTabModel(t) {
      const e = new Set(this.e.map((l) => l.groupId)),
        r = new Set(t.map((l) => l.groupId)),
        s = iat(e, r),
        a = this.e
          .filter((l) => s.removed.includes(l.groupId))
          .map((l) => l.apiObject),
        o = [],
        c = []
      this.e = t.map((l) => {
        const m = new awt(l, () => this.d)
        return (
          s.added.includes(m.groupId)
            ? o.push(m.apiObject)
            : c.push(m.apiObject),
          m
        )
      })
      const u = fo(t.find((l) => l.isActive === !0)?.groupId)
      u !== void 0 && this.d !== u && (this.d = u),
        this.c.fire(Object.freeze({ opened: o, closed: a, changed: c }))
    }
    $acceptTabGroupUpdate(t) {
      const e = this.e.find((r) => r.groupId === t.groupId)
      if (!e)
        throw new Error("Update Group IPC call received before group creation.")
      e.acceptGroupDtoUpdate(t),
        t.isActive && (this.d = t.groupId),
        this.c.fire(
          Object.freeze({ changed: [e.apiObject], opened: [], closed: [] }),
        )
    }
    $acceptTabOperation(t) {
      const e = this.e.find((s) => s.groupId === t.groupId)
      if (!e)
        throw new Error("Update Tabs IPC call received before group creation.")
      const r = e.acceptTabOperation(t)
      switch (t.kind) {
        case 0:
          this.b.fire(
            Object.freeze({ opened: [r.apiObject], closed: [], changed: [] }),
          )
          return
        case 1:
          this.b.fire(
            Object.freeze({ opened: [], closed: [r.apiObject], changed: [] }),
          )
          return
        case 3:
        case 2:
          this.b.fire(
            Object.freeze({ opened: [], closed: [], changed: [r.apiObject] }),
          )
          return
      }
    }
    g(t) {
      for (const e of this.e)
        for (const r of e.tabs) if (r.apiObject === t) return r
    }
    h(t) {
      return this.e.find((e) => e.apiObject === t)
    }
    async i(t, e) {
      const r = []
      for (const s of t) {
        const a = this.g(s)
        if (!a) throw new Error("Tab close: Invalid tab not found!")
        r.push(a.tabId)
      }
      return this.a.$closeTab(r, e)
    }
    async j(t, e) {
      const r = []
      for (const s of t) {
        const a = this.h(s)
        if (!a) throw new Error("Group close: Invalid group not found!")
        r.push(a.groupId)
      }
      return this.a.$closeGroup(r, e)
    }
  }
aU = __decorate([__param(0, Vt)], aU)
function owt(i) {
  return i.tabs !== void 0
}
var cwt = 0,
  qK = new WeakMap(),
  L7 = Y("IExtHostTesting"),
  oU = class extends dt {
    constructor(t, e, r, s) {
      super(),
        (this.z = e),
        (this.C = r),
        (this.F = s),
        (this.f = this.D(new C())),
        (this.g = new Map()),
        (this.q = this.D(new C())),
        (this.w = new Set()),
        (this.y = new Map()),
        (this.onResultsChanged = this.f.event),
        (this.results = []),
        (this.h = t.getProxy(z.MainThreadTesting)),
        (this.m = new fwt(this.h)),
        (this.j = new dwt(this.h, e)),
        r.registerArgumentProcessor({
          processArgument: (a) => {
            switch (a?.$mid) {
              case 16: {
                const o = a,
                  c = o.tests[o.tests.length - 1].item.extId
                return (
                  this.g.get(Ot.root(c))?.collection.tree.get(c)?.actual ??
                  TX(a)
                )
              }
              case 18: {
                const { test: o, message: c } = a,
                  u = o.item.extId
                return {
                  test:
                    this.g.get(Ot.root(u))?.collection.tree.get(u)?.actual ??
                    TX({ $mid: 16, tests: [o] }),
                  message: dc.to(c),
                }
              }
              default:
                return a
            }
          },
        }),
        r.registerCommand(!1, "testing.getExplorerSelection", async () => {
          const a = await r.executeCommand("_testing.getExplorerSelection"),
            o = (c) => {
              const u = this.g.get(Ot.root(c))
              if (u)
                return Ot.isRoot(c)
                  ? u.controller
                  : u.collection.tree.get(c)?.actual
            }
          return {
            include: a?.include.map(o).filter(ta) || [],
            exclude: a?.exclude.map(o).filter(ta) || [],
          }
        })
    }
    createTestController(t, e, r, s) {
      if (this.g.has(e))
        throw new Error(
          `Attempt to insert a duplicate controller with ID "${e}"`,
        )
      const a = new bt(),
        o = a.add(new _vt(e, r, this.F))
      o.root.label = r
      const c = new Map(),
        u = new Set(),
        l = this.h,
        m = () => {
          let g = 0
          s && (g |= 2)
          const w = p.relatedCodeProvider
          return (
            w &&
              (w?.provideRelatedTests && (g |= 8),
              w?.provideRelatedCode && (g |= 4)),
            g
          )
        },
        h = {
          items: o.root.children,
          get label() {
            return r
          },
          set label(g) {
            ;(r = g), (o.root.label = g), l.$updateController(e, { label: r })
          },
          get refreshHandler() {
            return s
          },
          set refreshHandler(g) {
            ;(s = g), l.$updateController(e, { capabilities: m() })
          },
          get id() {
            return e
          },
          get relatedCodeProvider() {
            return p.relatedCodeProvider
          },
          set relatedCodeProvider(g) {
            F(t, "testRelatedCode"),
              (p.relatedCodeProvider = g),
              l.$updateController(e, { capabilities: m() })
          },
          createRunProfile: (g, w, T, b, N, $) => {
            let L = Au(g)
            for (; c.has(L); ) L++
            return new WK(this.h, c, u, this.q.event, e, L, g, w, T, b, N, $)
          },
          createTestItem(g, w, T) {
            return new Bd(e, g, w, T)
          },
          createTestRun: (g, w, T = !0) =>
            this.j.createTestRun(t, e, o, g, w, T),
          invalidateTestResults: (g) => {
            if (g === void 0) this.h.$markTestRetired(void 0)
            else {
              const w = g instanceof Array ? g : [g]
              this.h.$markTestRetired(
                w.map((T) => Ot.fromExtHostTestItem(T, e).toString()),
              )
            }
          },
          set resolveHandler(g) {
            o.resolveHandler = g
          },
          get resolveHandler() {
            return o.resolveHandler
          },
          dispose: () => {
            a.dispose()
          },
        },
        p = {
          controller: h,
          collection: o,
          profiles: c,
          extension: t,
          activeProfiles: u,
        }
      return (
        l.$registerTestController(e, r, m()),
        a.add(it(() => l.$unregisterTestController(e))),
        this.g.set(e, p),
        a.add(it(() => this.g.delete(e))),
        a.add(
          o.onDidGenerateDiff((g) => l.$publishDiff(e, g.map(Z_.serialize))),
        ),
        h
      )
    }
    createTestObserver() {
      return this.m.checkout()
    }
    async runTests(t, e = fe.None) {
      const r = MK(t)
      if (!r)
        throw new Error(
          "The request passed to `vscode.test.runTests` must include a profile",
        )
      const s = this.g.get(r.controllerId)
      if (!s) throw new Error("Controller not found")
      await this.h.$runTests(
        {
          preserveFocus: t.preserveFocus ?? !0,
          group: mc.from(r.kind),
          targets: [
            {
              testIds: t.include?.map((a) =>
                Ot.fromExtHostTestItem(a, s.collection.root.id).toString(),
              ) ?? [s.collection.root.id],
              profileId: r.profileId,
              controllerId: r.controllerId,
            },
          ],
          exclude: t.exclude?.map((a) => a.id),
        },
        e,
      )
    }
    registerTestFollowupProvider(t) {
      return (
        this.w.add(t),
        {
          dispose: () => {
            this.w.delete(t)
          },
        }
      )
    }
    async $getTestsRelatedToCode(t, e, r) {
      const s = this.F.getDocument(S.revive(t))
      if (!s) return []
      const a = Gt.to(e),
        o = []
      return (
        await Promise.all(
          [...this.g.values()].map(async (c) => {
            let u
            try {
              u = await c.relatedCodeProvider?.provideRelatedTests?.(
                s.document,
                a,
                r,
              )
            } catch (l) {
              r.isCancellationRequested ||
                this.z.warn(
                  `Error thrown while providing related tests for ${c.controller.label}`,
                  l,
                )
            }
            if (u) {
              for (const l of u)
                o.push(Ot.fromExtHostTestItem(l, c.controller.id).toString())
              c.collection.flushDiff()
            }
          }),
        ),
        o
      )
    }
    async $getCodeRelatedToTest(t, e) {
      const r = this.g.get(Ot.root(t))
      if (!r) return []
      const s = r.collection.tree.get(t)
      return s
        ? ((
            await r.relatedCodeProvider?.provideRelatedCode?.(s.actual, e)
          )?.map(Ri.from) ?? [])
        : []
    }
    $syncTests() {
      for (const { collection: t } of this.g.values()) t.flushDiff()
      return Promise.resolve()
    }
    async $getCoverageDetails(t, e, r) {
      return (await this.j.getCoverageDetails(t, e, r))?.map(Kl.fromDetails)
    }
    async $disposeRun(t) {
      this.j.disposeTestRun(t)
    }
    $configureRunProfile(t, e) {
      this.g.get(t)?.profiles.get(e)?.configureHandler?.()
    }
    $setDefaultRunProfiles(t) {
      const e = new Map()
      for (const [r, s] of Object.entries(t)) {
        const a = this.g.get(r)
        if (!a) continue
        const o = new Map(),
          c = s.filter((l) => !a.activeProfiles.has(l)),
          u = [...a.activeProfiles].filter((l) => !s.includes(l))
        for (const l of c) o.set(l, !0), a.activeProfiles.add(l)
        for (const l of u) o.set(l, !1), a.activeProfiles.delete(l)
        o.size && e.set(r, o)
      }
      this.q.fire(e)
    }
    async $refreshTests(t, e) {
      await this.g.get(t)?.controller.refreshHandler?.(e)
    }
    $publishTestResults(t) {
      ;(this.results = Object.freeze(
        t
          .map((e) => {
            const r = hq.to(e),
              s = e.tasks.findIndex((a) => a.hasCoverage)
            return (
              s !== -1 &&
                (r.getDetailedCoverage = (a, o = fe.None) =>
                  this.h
                    .$getCoverageDetails(e.id, s, a, o)
                    .then((c) => c.map(Kl.to))),
              qK.set(r, e.id),
              r
            )
          })
          .concat(this.results)
          .sort((e, r) => r.completedAt - e.completedAt)
          .slice(0, 32),
      )),
        this.f.fire()
    }
    async $expandTest(t, e) {
      const r = this.g.get(Ot.fromString(t).controllerId)?.collection
      r && (await r.expand(t, e < 0 ? 1 / 0 : e), r.flushDiff())
    }
    $acceptDiff(t) {
      this.m.applyDiff(
        t.map((e) => Z_.deserialize({ asCanonicalUri: (r) => r }, e)),
      )
    }
    async $runControllerTests(t, e) {
      return Promise.all(t.map((r) => this.G(r, !1, e)))
    }
    async $startContinuousRun(t, e) {
      const r = new Ie(e),
        s = await Promise.all(t.map((a) => this.G(a, !0, r.token)))
      return (
        !e.isCancellationRequested &&
          !s.some((a) => a.error) &&
          (await new Promise((a) => e.onCancellationRequested(a))),
        r.dispose(!0),
        s
      )
    }
    async $provideTestFollowups(t, e) {
      const r = this.results.find((o) => qK.get(o) === t.resultId),
        s = r && pwt(Ot.fromString(t.extId), r?.results)
      if (!s) return []
      let a = []
      return (
        await Promise.all(
          [...this.w].map(async (o) => {
            try {
              const c = await o.provideFollowup(
                r,
                s,
                t.taskIndex,
                t.messageIndex,
                e,
              )
              c && (a = a.concat(c))
            } catch (c) {
              this.z.error(
                "Error thrown while providing followup for test message",
                c,
              )
            }
          }),
        ),
        e.isCancellationRequested
          ? []
          : a.map((o) => {
              const c = cwt++
              return this.y.set(c, o), { title: o.title, id: c }
            })
      )
    }
    $disposeTestFollowups(t) {
      for (const e of t) this.y.delete(e)
    }
    $executeTestFollowup(t) {
      const e = this.y.get(t)
      return e
        ? this.C.executeCommand(e.command, ...(e.arguments || []))
        : Promise.resolve()
    }
    $cancelExtensionTestRun(t, e) {
      t === void 0 ? this.j.cancelAllRuns() : this.j.cancelRunById(t, e)
    }
    getMetadataForRun(t) {
      for (const e of this.j.trackers) {
        const r = e.getTaskIdForRun(t)
        if (r) return { taskId: r, runId: e.id }
      }
    }
    async G(t, e, r) {
      const s = this.g.get(t.controllerId)
      if (!s) return {}
      const { collection: a, profiles: o, extension: c } = s,
        u = o.get(t.profileId)
      if (!u) return {}
      const l = t.testIds.map((g) => a.tree.get(g)).filter(ta),
        m = t.excludeExtIds
          .map((g) => s.collection.tree.get(g))
          .filter(ta)
          .filter((g) => l.some((w) => w.fullId.compare(g.fullId) === 2))
      if (!l.length) return {}
      const h = new q6(
          l.some((g) => g.actual instanceof k2)
            ? void 0
            : l.map((g) => g.actual),
          m.map((g) => g.actual),
          u,
          e,
        ),
        p =
          nmt(t) &&
          this.j.prepareForMainThreadTestRun(
            c,
            h,
            HK.fromInternal(t, s.collection),
            u,
            r,
          )
      try {
        return await u.runHandler(h, r), {}
      } catch (g) {
        return { error: String(g) }
      } finally {
        p &&
          p.hasRunningTasks &&
          !r.isCancellationRequested &&
          (await Ee.toPromise(p.onEnd))
      }
    }
  }
oU = __decorate(
  [__param(0, Vt), __param(1, Kt), __param(2, Ba), __param(3, xc)],
  oU,
)
var uwt = 1e4,
  UK
;(function (i) {
  ;(i[(i.Running = 0)] = "Running"),
    (i[(i.Cancelling = 1)] = "Cancelling"),
    (i[(i.Ended = 2)] = "Ended")
})(UK || (UK = {}))
var lwt = class extends dt {
    get hasRunningTasks() {
      return this.g > 0
    }
    get id() {
      return this.z.id
    }
    constructor(i, t, e, r, s, a) {
      super(),
        (this.z = i),
        (this.C = t),
        (this.F = e),
        (this.G = r),
        (this.H = s),
        (this.f = 0),
        (this.g = 0),
        (this.h = new Map()),
        (this.j = new Set()),
        (this.q = this.D(new C())),
        (this.y = new Map()),
        (this.onEnd = this.q.event),
        (this.m = this.D(new Ie(a)))
      const o = this.D(new po(() => this.I(), uwt))
      this.D(this.m.token.onCancellationRequested(() => o.schedule()))
      const c = new C()
      ;(this.w = c.event),
        this.D(
          it(() => {
            c.fire(), c.dispose()
          }),
        )
    }
    getTaskIdForRun(i) {
      for (const [t, { run: e }] of this.h) if (e === i) return t
    }
    cancel(i) {
      i
        ? this.h.get(i)?.cts.cancel()
        : this.f === 0
          ? (this.m.cancel(), (this.f = 1))
          : this.f === 1 && this.I()
    }
    async getCoverageDetails(i, t, e) {
      const [, r] = Ot.fromString(i).path,
        s = this.y.get(i)
      if (!s) return []
      const { report: a, extIds: o } = s,
        c = this.h.get(r)
      if (!c) throw new Error("unreachable: run task was not found")
      let u
      if (t && a instanceof W6) {
        const m = o.indexOf(t)
        if (m === -1) return []
        u = a.includesTests[m]
      }
      return (
        (await (u
          ? this.G?.loadDetailedCoverageForTest?.(c.run, a, u, e)
          : this.G?.loadDetailedCoverage?.(c.run, a, e))) ?? []
      )
    }
    createRun(i) {
      const t = this.z.id,
        e = this.z.controllerId,
        r = Ki(),
        s =
          (l) =>
          (m, ...h) => {
            if (o) {
              this.F.warn(
                `Setting the state of test "${m.id}" is a no-op after the run ends.`,
              )
              return
            }
            this.L(m), l(m, ...h)
          },
        a = (l, m) => {
          const h = m instanceof Array ? m.map(dc.from) : [dc.from(m)]
          if (l.uri && l.range) {
            const p = { range: O.from(l.range), uri: l.uri }
            for (const g of h) g.location = g.location || p
          }
          this.C.$appendTestMessagesInRun(
            t,
            r,
            Ot.fromExtHostTestItem(l, e).toString(),
            h,
          )
        }
      let o = !1
      const c = this.D(new Ie(this.m.token)),
        u = {
          isPersisted: this.z.isPersisted,
          token: c.token,
          name: i,
          onDidDispose: this.w,
          addCoverage: (l) => {
            if (o) return
            const m = l instanceof W6 ? l.includesTests : []
            if (m.length) for (const g of m) this.L(g)
            const h = l.uri.toString(),
              p = new Ot([t, r, h]).toString()
            this.y.set(p, {
              report: l,
              extIds: m.map((g) => Ot.fromExtHostTestItem(g, e).toString()),
            }),
              this.C.$appendCoverage(t, r, Kl.fromFile(e, p, l))
          },
          enqueued: s((l) => {
            this.C.$updateTestStateInRun(
              t,
              r,
              Ot.fromExtHostTestItem(l, e).toString(),
              1,
            )
          }),
          skipped: s((l) => {
            this.C.$updateTestStateInRun(
              t,
              r,
              Ot.fromExtHostTestItem(l, e).toString(),
              5,
            )
          }),
          started: s((l) => {
            this.C.$updateTestStateInRun(
              t,
              r,
              Ot.fromExtHostTestItem(l, e).toString(),
              2,
            )
          }),
          errored: s((l, m, h) => {
            a(l, m),
              this.C.$updateTestStateInRun(
                t,
                r,
                Ot.fromExtHostTestItem(l, e).toString(),
                6,
                h,
              )
          }),
          failed: s((l, m, h) => {
            a(l, m),
              this.C.$updateTestStateInRun(
                t,
                r,
                Ot.fromExtHostTestItem(l, e).toString(),
                4,
                h,
              )
          }),
          passed: s((l, m) => {
            this.C.$updateTestStateInRun(
              t,
              r,
              Ot.fromExtHostTestItem(l, this.z.controllerId).toString(),
              3,
              m,
            )
          }),
          appendOutput: (l, m, h) => {
            o ||
              (h && this.L(h),
              this.C.$appendOutputToRun(
                t,
                r,
                Et.fromString(l),
                m && Ri.from(m),
                h && Ot.fromExtHostTestItem(h, e).toString(),
              ))
          },
          end: () => {
            o ||
              ((o = !0),
              this.C.$finishedTestRunTask(t, r),
              --this.g || this.J())
          },
        }
      return (
        this.g++,
        this.h.set(r, { run: u, cts: c }),
        this.C.$startedTestRunTask(t, {
          id: r,
          ctrlId: this.z.controllerId,
          name: i || this.H.displayName || this.H.identifier.value,
          running: !0,
        }),
        u
      )
    }
    I() {
      for (const { run: i } of this.h.values()) i.end()
    }
    J() {
      this.f !== 2 && ((this.f = 2), this.q.fire())
    }
    L(i) {
      if (!(i instanceof Bd)) throw new t6(i.id)
      if (this.j.has(Ot.fromExtHostTestItem(i, this.z.controllerId).toString()))
        return
      const t = [],
        e = this.z.colllection.root
      for (;;) {
        const r = Ss.from(i)
        if (
          (t.unshift(r), this.j.has(r.extId) || (this.j.add(r.extId), i === e))
        )
          break
        i = i.parent || e
      }
      this.C.$addTestsToRun(this.z.controllerId, this.z.id, t)
    }
    dispose() {
      this.J(), super.dispose()
    }
  },
  dwt = class {
    get trackers() {
      return this.f.values()
    }
    constructor(i, t) {
      ;(this.h = i), (this.j = t), (this.f = new Map()), (this.g = new Map())
    }
    getCoverageDetails(i, t, e) {
      const r = Ot.root(i)
      return this.g.get(r)?.getCoverageDetails(i, t, e) || []
    }
    disposeTestRun(i) {
      this.g.get(i)?.dispose(), this.g.delete(i)
      for (const [t, { id: e }] of this.f) e === i && this.f.delete(t)
    }
    prepareForMainThreadTestRun(i, t, e, r, s) {
      return this.k(t, e, r, i, s)
    }
    cancelRunById(i, t) {
      this.g.get(i)?.cancel(t)
    }
    cancelAllRuns() {
      for (const i of this.f.values()) i.cancel()
    }
    createTestRun(i, t, e, r, s, a) {
      const o = this.f.get(r)
      if (o) return o.createRun(s)
      const c = HK.fromPublic(t, e, r, a),
        u = MK(r)
      this.h.$startedExtensionTestRun({
        controllerId: t,
        continuous: !!r.continuous,
        profile: u && { group: mc.from(u.kind), id: u.profileId },
        exclude:
          r.exclude?.map((m) =>
            Ot.fromExtHostTestItem(m, e.root.id).toString(),
          ) ?? [],
        id: c.id,
        include: r.include?.map((m) =>
          Ot.fromExtHostTestItem(m, e.root.id).toString(),
        ) ?? [e.root.id],
        preserveFocus: r.preserveFocus ?? !0,
        persist: a,
      })
      const l = this.k(r, c, r.profile, i)
      return (
        Ee.once(l.onEnd)(() => {
          this.h.$finishedExtensionTestRun(c.id)
        }),
        l.createRun(s)
      )
    }
    k(i, t, e, r, s) {
      const a = new lwt(t, this.h, this.j, e, r, s)
      return this.f.set(i, a), this.g.set(a.id, a), a
    }
  },
  MK = (i) => {
    if (i.profile) {
      if (!(i.profile instanceof WK))
        throw new Error(
          "TestRunRequest.profile is not an instance created from TestController.createRunProfile",
        )
      return i.profile
    }
  },
  HK = class TH {
    static fromPublic(t, e, r, s) {
      return new TH(t, Ki(), s, e)
    }
    static fromInternal(t, e) {
      return new TH(t.controllerId, t.runId, !0, e)
    }
    constructor(t, e, r, s) {
      ;(this.controllerId = t),
        (this.id = e),
        (this.isPersisted = r),
        (this.colllection = s)
    }
  },
  mwt = class {
    get isEmpty() {
      return this.f.size === 0 && this.h.size === 0 && this.g.size === 0
    }
    constructor(i) {
      ;(this.k = i),
        (this.f = new Set()),
        (this.g = new Set()),
        (this.h = new Set()),
        (this.j = new Set())
    }
    add(i) {
      this.f.add(i)
    }
    update(i) {
      Object.assign(i.revived, Ss.toPlain(i.item)),
        this.f.has(i) || this.g.add(i)
    }
    remove(i) {
      if (this.f.has(i)) {
        this.f.delete(i)
        return
      }
      this.g.delete(i)
      const t = Ot.parentId(i.item.extId)
      if (t && this.j.has(t.toString())) {
        this.j.add(i.item.extId)
        return
      }
      this.h.add(i)
    }
    getChangeEvent() {
      const { f: i, g: t, h: e } = this
      return {
        get added() {
          return [...i].map((r) => r.revived)
        },
        get updated() {
          return [...t].map((r) => r.revived)
        },
        get removed() {
          return [...e].map((r) => r.revived)
        },
      }
    }
    complete() {
      this.isEmpty || this.k.fire(this.getChangeEvent())
    }
  },
  hwt = class extends smt {
    constructor() {
      super(...arguments),
        (this.z = new C()),
        (this.onDidChangeTests = this.z.event)
    }
    get rootTests() {
      return this.h
    }
    getMirroredTestDataById(i) {
      return this.g.get(i)
    }
    getMirroredTestDataByReference(i) {
      return this.g.get(i.id)
    }
    y(i, t) {
      return {
        ...i,
        revived: Ss.toPlain(i.item),
        depth: t ? t.depth + 1 : 0,
        children: new Set(),
      }
    }
    x() {
      return new mwt(this.z)
    }
  },
  fwt = class {
    constructor(i) {
      this.g = i
    }
    checkout() {
      this.f || (this.f = this.h())
      const i = this.f
      return (
        i.observers++,
        {
          onDidChangeTest: i.tests.onDidChangeTests,
          get tests() {
            return [...i.tests.rootTests].map((t) => t.revived)
          },
          dispose: cB(() => {
            --i.observers === 0 &&
              (this.g.$unsubscribeFromDiffs(), (this.f = void 0))
          }),
        }
      )
    }
    getMirroredTestDataByReference(i) {
      return this.f?.tests.getMirroredTestDataByReference(i)
    }
    applyDiff(i) {
      this.f?.tests.apply(i)
    }
    h() {
      const i = new hwt({ asCanonicalUri: (t) => t })
      return this.g.$subscribeToDiffs(), { observers: 0, tests: i }
    }
  },
  Yd = (i, t, e, r) => {
    e
      ? Object.assign(e, r)
      : t.$updateTestRunConfig(i.controllerId, i.profileId, r)
  },
  WK = class extends aY {
    #t
    #e
    #i
    #r
    #s
    get label() {
      return this.g
    }
    set label(i) {
      i !== this.g && ((this.g = i), Yd(this, this.#t, this.#r, { label: i }))
    }
    get supportsContinuousRun() {
      return this.j
    }
    set supportsContinuousRun(i) {
      i !== this.j &&
        ((this.j = i), Yd(this, this.#t, this.#r, { supportsContinuousRun: i }))
    }
    get isDefault() {
      return this.#e.has(this.profileId)
    }
    set isDefault(i) {
      i !== this.isDefault &&
        (i ? this.#e.add(this.profileId) : this.#e.delete(this.profileId),
        Yd(this, this.#t, this.#r, { isDefault: i }))
    }
    get tag() {
      return this._tag
    }
    set tag(i) {
      i?.id !== this._tag?.id &&
        ((this._tag = i),
        Yd(this, this.#t, this.#r, {
          tag: i ? Lr.namespace(this.controllerId, i.id) : null,
        }))
    }
    get configureHandler() {
      return this.f
    }
    set configureHandler(i) {
      i !== this.f &&
        ((this.f = i),
        Yd(this, this.#t, this.#r, { hasConfigurationHandler: !!i }))
    }
    get onDidChangeDefault() {
      return Ee.chain(this.#i, (i) =>
        i.map((t) => t.get(this.controllerId)?.get(this.profileId)).filter(ta),
      )
    }
    constructor(i, t, e, r, s, a, o, c, u, l = !1, m = void 0, h = !1) {
      super(s, a, c),
        (this.g = o),
        (this.runHandler = u),
        (this._tag = m),
        (this.j = h),
        (this.#t = i),
        (this.#s = t),
        (this.#e = e),
        (this.#i = r),
        t.set(a, this)
      const p = mc.from(c)
      l && e.add(a),
        (this.#r = {
          profileId: a,
          controllerId: s,
          tag: m ? Lr.namespace(this.controllerId, m.id) : null,
          label: o,
          group: p,
          isDefault: l,
          hasConfigurationHandler: !1,
          supportsContinuousRun: h,
        }),
        queueMicrotask(() => {
          this.#r &&
            (this.#t.$publishTestRunProfile(this.#r), (this.#r = void 0))
        })
    }
    dispose() {
      this.#s?.delete(this.profileId) &&
        ((this.#s = void 0),
        this.#t.$removeTestProfile(this.controllerId, this.profileId)),
        (this.#r = void 0)
    }
  }
function pwt(i, t) {
  for (let e = 0; e < i.path.length; e++) {
    const r = t.find((s) => s.id === i.path[e])
    if (!r) return
    if (e === i.path.length - 1) return r
    t = r.children
  }
}
var Vqt = Y("configurationResolverService"),
  ce
;(function (i) {
  ;(i.Unknown = "unknown"),
    (i.Env = "env"),
    (i.Config = "config"),
    (i.Command = "command"),
    (i.Input = "input"),
    (i.ExtensionInstallFolder = "extensionInstallFolder"),
    (i.WorkspaceFolder = "workspaceFolder"),
    (i.Cwd = "cwd"),
    (i.WorkspaceFolderBasename = "workspaceFolderBasename"),
    (i.UserHome = "userHome"),
    (i.LineNumber = "lineNumber"),
    (i.SelectedText = "selectedText"),
    (i.File = "file"),
    (i.FileWorkspaceFolder = "fileWorkspaceFolder"),
    (i.FileWorkspaceFolderBasename = "fileWorkspaceFolderBasename"),
    (i.RelativeFile = "relativeFile"),
    (i.RelativeFileDirname = "relativeFileDirname"),
    (i.FileDirname = "fileDirname"),
    (i.FileExtname = "fileExtname"),
    (i.FileBasename = "fileBasename"),
    (i.FileBasenameNoExtension = "fileBasenameNoExtension"),
    (i.FileDirnameBasename = "fileDirnameBasename"),
    (i.ExecPath = "execPath"),
    (i.ExecInstallFolder = "execInstallFolder"),
    (i.PathSeparator = "pathSeparator"),
    (i.PathSeparatorAlias = "/")
})(ce || (ce = {}))
var Fi = class extends Kn {
    constructor(i, t) {
      super(t), (this.variable = i)
    }
  },
  gwt = class V8 {
    static {
      this.VARIABLE_LHS = "${"
    }
    static {
      this.VARIABLE_REGEXP = /\$\{(.*?)\}/g
    }
    constructor(t, e, r, s) {
      ;(this.h = new Map()),
        (this.a = t),
        (this.b = e),
        (this.g = r),
        s && (this.c = s.then((a) => this.i(a)))
    }
    i(t) {
      if (Mi) {
        const e = Object.create(null)
        return (
          Object.keys(t).forEach((r) => {
            e[r.toLowerCase()] = t[r]
          }),
          e
        )
      }
      return t
    }
    resolveWithEnvironment(t, e, r) {
      return this.l({ env: this.i(t), userHome: void 0 }, e ? e.uri : void 0, r)
    }
    async resolveAsync(t, e) {
      const r = { env: await this.c, userHome: await this.g }
      return this.l(r, t ? t.uri : void 0, e)
    }
    async j(t, e, r, s) {
      const a = pe(e)
      Mi && a.windows
        ? Object.keys(a.windows).forEach((c) => (a[c] = a.windows[c]))
        : Tr && a.osx
          ? Object.keys(a.osx).forEach((c) => (a[c] = a.osx[c]))
          : es &&
            a.linux &&
            Object.keys(a.linux).forEach((c) => (a[c] = a.linux[c])),
        delete a.windows,
        delete a.osx,
        delete a.linux
      const o = { env: await this.c, userHome: await this.g }
      return this.l(o, t ? t.uri : void 0, a, r, s)
    }
    async resolveAnyAsync(t, e, r) {
      return this.j(t, e, r)
    }
    async resolveAnyMap(t, e, r) {
      const s = new Map()
      return { newConfig: await this.j(t, e, r, s), resolvedVariables: s }
    }
    resolveWithInteractionReplace(t, e, r, s) {
      throw new Error("resolveWithInteractionReplace not implemented.")
    }
    resolveWithInteraction(t, e, r, s) {
      throw new Error("resolveWithInteraction not implemented.")
    }
    contributeVariable(t, e) {
      if (this.h.has(t))
        throw new Error("Variable " + t + " is contributed twice.")
      this.h.set(t, e)
    }
    async l(t, e, r, s, a) {
      if (Bt(r)) return this.m(t, e, r, s, a)
      if (Array.isArray(r))
        return Promise.all(r.map((o) => this.l(t, e, o, s, a)))
      if (Ce(r)) {
        const o = Object.create(null),
          c = await Promise.all(
            Object.keys(r).map(async (u) => [
              await this.m(t, e, u, s, a),
              await this.l(t, e, r[u], s, a),
            ]),
          )
        for (const [u, l] of c) o[u] = l
        return o
      }
      return r
    }
    m(t, e, r, s, a) {
      return Iot(r, V8.VARIABLE_REGEXP, async (o, c) => {
        if (c.includes(V8.VARIABLE_LHS)) return o
        let u = await this.o(t, o, c, e, s)
        return (
          a?.set(c, u),
          u !== o &&
            Bt(u) &&
            u.match(V8.VARIABLE_REGEXP) &&
            (u = await this.m(t, e, u, s, a)),
          u
        )
      })
    }
    n(t) {
      return this.b ? this.b.getUriLabel(t, { noPrefix: !0 }) : t.fsPath
    }
    async o(t, e, r, s, a) {
      let o
      const c = r.split(":")
      c.length > 1 && ((r = c[0]), (o = c[1]))
      const u = (h) => {
          const p = this.a.getFilePath()
          if (p) return Od(p)
          throw new Fi(h, f(12720, null, e))
        },
        l = (h) => {
          const p = u(h)
          if (this.a.getWorkspaceFolderPathForFile) {
            const g = this.a.getWorkspaceFolderPathForFile()
            if (g) return Od(g)
          }
          throw new Fi(h, f(12721, null, e, ji(p)))
        },
        m = (h) => {
          if (o) {
            const p = this.a.getFolderUri(o)
            if (p) return p
            throw new Fi(h, f(12722, null, e, o))
          }
          if (s) return s
          throw this.a.getWorkspaceFolderCount() > 1
            ? new Fi(h, f(12723, null, e))
            : new Fi(h, f(12724, null, e))
        }
      switch (r) {
        case "env":
          if (o) {
            if (t.env) {
              const h = t.env[Mi ? o.toLowerCase() : o]
              if (Bt(h)) return h
            }
            return ""
          }
          throw new Fi(ce.Env, f(12725, null, e))
        case "config":
          if (o) {
            const h = this.a.getConfigurationValue(s, o)
            if (Le(h)) throw new Fi(ce.Config, f(12726, null, e, o))
            if (Ce(h)) throw new Fi(ce.Config, f(12727, null, e, o))
            return h
          }
          throw new Fi(ce.Config, f(12728, null, e))
        case "command":
          return this.p(ce.Command, e, o, a, "command")
        case "input":
          return this.p(ce.Input, e, o, a, "input")
        case "extensionInstallFolder":
          if (o) {
            const h = await this.a.getExtension(o)
            if (!h)
              throw new Fi(ce.ExtensionInstallFolder, f(12729, null, e, o))
            return this.n(h.extensionLocation)
          }
          throw new Fi(ce.ExtensionInstallFolder, f(12730, null, e))
        default:
          switch (r) {
            case "workspaceRoot":
            case "workspaceFolder":
              return Od(this.n(m(ce.WorkspaceFolder)))
            case "cwd":
              return s || o ? Od(this.n(m(ce.Cwd))) : uo()
            case "workspaceRootFolderName":
            case "workspaceFolderBasename":
              return Od(ji(this.n(m(ce.WorkspaceFolderBasename))))
            case "userHome": {
              if (t.userHome) return t.userHome
              throw new Fi(ce.UserHome, f(12731, null, e))
            }
            case "lineNumber": {
              const h = this.a.getLineNumber()
              if (h) return h
              throw new Fi(ce.LineNumber, f(12732, null, e))
            }
            case "selectedText": {
              const h = this.a.getSelectedText()
              if (h) return h
              throw new Fi(ce.SelectedText, f(12733, null, e))
            }
            case "file":
              return u(ce.File)
            case "fileWorkspaceFolder":
              return l(ce.FileWorkspaceFolder)
            case "fileWorkspaceFolderBasename":
              return ji(l(ce.FileWorkspaceFolderBasename))
            case "relativeFile":
              return s || o
                ? Cu(this.n(m(ce.RelativeFile)), u(ce.RelativeFile))
                : u(ce.RelativeFile)
            case "relativeFileDirname": {
              const h = mo(u(ce.RelativeFileDirname))
              if (s || o) {
                const p = Cu(this.n(m(ce.RelativeFileDirname)), h)
                return p.length === 0 ? "." : p
              }
              return h
            }
            case "fileDirname":
              return mo(u(ce.FileDirname))
            case "fileExtname":
              return SB(u(ce.FileExtname))
            case "fileBasename":
              return ji(u(ce.FileBasename))
            case "fileBasenameNoExtension": {
              const h = ji(u(ce.FileBasenameNoExtension))
              return h.slice(0, h.length - SB(h).length)
            }
            case "fileDirnameBasename":
              return ji(mo(u(ce.FileDirnameBasename)))
            case "execPath": {
              const h = this.a.getExecPath()
              return h || e
            }
            case "execInstallFolder": {
              const h = this.a.getAppRoot()
              return h || e
            }
            case "pathSeparator":
            case "/":
              return kr
            default:
              try {
                const h = o ? `${r}:${o}` : r
                return this.p(ce.Unknown, e, h, a, void 0)
              } catch {
                return e
              }
          }
      }
    }
    p(t, e, r, s, a) {
      if (r && s) {
        const o = a === void 0 ? s[r] : s[a + ":" + r]
        if (typeof o == "string") return o
        throw new Fi(t, f(12734, null, e))
      }
      return e
    }
  },
  cU = Y("IExtHostVariableResolverProvider"),
  vwt = class extends gwt {
    constructor(i, t, e, r, s, a, o) {
      function c() {
        if (e) {
          const u = e.activeEditor()
          if (u) return u.document.uri
          const l = r.tabGroups.all.find((m) => m.isActive)?.activeTab
          if (l !== void 0) {
            if (l.input instanceof j6 || l.input instanceof RO)
              return l.input.modified
            if (
              l.input instanceof JO ||
              l.input instanceof LO ||
              l.input instanceof CO
            )
              return l.input.uri
          }
        }
      }
      super(
        {
          getFolderUri: (u) => {
            const l = a.folders.filter((m) => m.name === u)
            if (l && l.length > 0) return l[0].uri
          },
          getWorkspaceFolderCount: () => a.folders.length,
          getConfigurationValue: (u, l) => s.getConfiguration(void 0, u).get(l),
          getAppRoot: () => uo(),
          getExecPath: () => Ju.VSCODE_EXEC_PATH,
          getFilePath: () => {
            const u = c()
            if (u) return lo(u.fsPath)
          },
          getWorkspaceFolderPathForFile: () => {
            if (t) {
              const u = c()
              if (u) {
                const l = t.getWorkspaceFolder(u)
                if (l) return lo(l.uri.fsPath)
              }
            }
          },
          getSelectedText: () => {
            if (e) {
              const u = e.activeEditor()
              if (u && !u.selection.isEmpty)
                return u.document.getText(u.selection)
            }
          },
          getLineNumber: () => {
            if (e) {
              const u = e.activeEditor()
              if (u) return String(u.selection.end.line + 1)
            }
          },
          getExtension: (u) => i.getExtension(u),
        },
        void 0,
        o ? Promise.resolve(o) : void 0,
        Promise.resolve(Ju),
      )
    }
  },
  uU = class extends dt {
    constructor(t, e, r, s, a) {
      super(),
        (this.b = t),
        (this.c = e),
        (this.g = r),
        (this.h = s),
        (this.j = a),
        (this.a = new qi(async () => {
          const o = await this.h.getConfigProvider(),
            u = { folders: (await this.c.getWorkspaceFolders2()) || [] }
          return (
            this.D(
              this.c.onDidChangeWorkspace(async (l) => {
                u.folders = (await this.c.getWorkspaceFolders2()) || []
              }),
            ),
            new vwt(this.b, this.c, this.g, this.j, o, u, this.m())
          )
        }))
    }
    getResolver() {
      return this.a.value
    }
    m() {}
  }
uU = __decorate(
  [
    __param(0, Fs),
    __param(1, _n),
    __param(2, xc),
    __param(3, An),
    __param(4, zd),
  ],
  uU,
)
var jK = Y("IExtHostDebugService"),
  lU = class extends dt {
    get onDidStartDebugSession() {
      return this.w.event
    }
    get onDidTerminateDebugSession() {
      return this.y.event
    }
    get onDidChangeActiveDebugSession() {
      return this.z.event
    }
    get activeDebugSession() {
      return this.C?.api
    }
    get onDidReceiveDebugSessionCustomEvent() {
      return this.F.event
    }
    get activeDebugConsole() {
      return this.G.value
    }
    constructor(t, e, r, s, a, o, c, u) {
      super(),
        (this.Z = e),
        (this.$ = r),
        (this.ab = s),
        (this.bb = a),
        (this.cb = o),
        (this.db = c),
        (this.eb = u),
        (this.u = new Map()),
        (this.O = 0),
        (this.P = new Map()),
        (this.Q = new Map()),
        (this.R = new WeakMap()),
        (this.S = new Map()),
        (this.W = new Map()),
        (this.X = 0),
        (this.f = 0),
        (this.g = []),
        (this.h = 0),
        (this.j = []),
        (this.m = 0),
        (this.n = []),
        (this.M = new Map()),
        (this.N = new Map()),
        (this.w = this.D(new C())),
        (this.y = this.D(new C())),
        (this.z = this.D(new C())),
        (this.F = this.D(new C())),
        (this.q = t.getProxy(z.MainThreadDebugService)),
        (this.I = this.D(new C())),
        (this.L = this.D(new C())),
        (this.G = new ywt(this.q)),
        (this.H = new Map()),
        this.$.getExtensionRegistry().then((l) => {
          this.D(
            l.onDidChange((m) => {
              this.gb(l)
            }),
          ),
            this.gb(l)
        }),
        (this.Y = t.getProxy(z.MainThreadTelemetry))
    }
    async $getVisualizerTreeItem(t, e) {
      const r = this.hb(e)
      if (!r) return
      const s = await this.Q.get(t)?.getTreeItem?.(r)
      return s ? this.fb(t, s) : void 0
    }
    registerDebugVisualizationTree(t, e, r) {
      const s = te.toKey(t.identifier),
        a = this.zb(s, e)
      if (this.P.has(a))
        throw new Error(
          `A debug visualization provider with id '${e}' is already registered`,
        )
      return (
        this.Q.set(a, r),
        this.q.$registerDebugVisualizerTree(a, !!r.editItem),
        it(() => {
          this.q.$unregisterDebugVisualizerTree(a), this.Q.delete(e)
        })
      )
    }
    async $getVisualizerTreeItemChildren(t, e) {
      const r = this.S.get(e)?.item
      return r
        ? (await this.Q.get(t)?.getChildren?.(r))?.map((a) => this.fb(t, a)) ||
            []
        : []
    }
    async $editVisualizerTreeItem(t, e) {
      const r = this.S.get(t)
      if (!r) return
      const s = await this.Q.get(r.provider)?.editItem?.(r.item, e)
      return this.fb(r.provider, s || r.item)
    }
    $disposeVisualizedTree(t) {
      const e = this.S.get(t)
      if (!e) return
      const r = [e.children]
      for (const s of r)
        if (s)
          for (const a of s) r.push(this.S.get(a)?.children), this.S.delete(a)
    }
    fb(t, e) {
      let r = this.R.get(e)
      return (
        r ||
          ((r = this.O++),
          this.R.set(e, r),
          this.S.set(r, { provider: t, item: e })),
        Sq.from(e, r)
      )
    }
    asDebugSourceUri(t, e) {
      const r = t
      if (typeof r.sourceReference == "number" && r.sourceReference > 0) {
        let s = `debug:${encodeURIComponent(r.path || "")}`,
          a = "?"
        return (
          e && ((s += `${a}session=${encodeURIComponent(e.id)}`), (a = "&")),
          (s += `${a}ref=${r.sourceReference}`),
          S.parse(s)
        )
      } else {
        if (r.path) return S.file(r.path)
        throw new Error(
          "cannot create uri from DAP 'source' object; properties 'path' and 'sourceReference' are both missing.",
        )
      }
    }
    gb(t) {
      const e = []
      for (const r of t.getAllExtensionDescriptions())
        if (r.contributes) {
          const s = r.contributes.debuggers
          if (s && s.length > 0) for (const a of s) ewt(a) && e.push(a.type)
        }
      this.q.$registerDebugTypes(e)
    }
    get activeStackItem() {
      return this.J
    }
    get onDidChangeActiveStackItem() {
      return this.L.event
    }
    get onDidChangeBreakpoints() {
      return this.I.event
    }
    get breakpoints() {
      const t = []
      return this.H.forEach((e) => t.push(e)), t
    }
    async $resolveDebugVisualizer(t, e) {
      const r = this.W.get(t)
      if (!r) throw new Error(`No debug visualizer found with id '${t}'`)
      let { v: s, provider: a, extensionId: o } = r
      if (
        (s.visualization ||
          ((s = (await a.resolveDebugVisualization?.(s, e)) || s), (r.v = s)),
        !s.visualization)
      )
        throw new Error(
          `No visualization returned from resolveDebugVisualization in '${a}'`,
        )
      return this.Ab(o, s.visualization)
    }
    async $executeDebugVisualizerCommand(t) {
      const e = this.W.get(t)
      if (!e) throw new Error(`No debug visualizer found with id '${t}'`)
      const r = e.v.visualization
      r &&
        "command" in r &&
        this.db.executeCommand(r.command, ...(r.arguments || []))
    }
    hb(t) {
      const e = this.u.get(t.sessionId)
      return (
        e && {
          session: e.api,
          variable: t.variable,
          containerId: t.containerId,
          frameId: t.frameId,
          threadId: t.threadId,
        }
      )
    }
    async $provideDebugVisualizers(t, e, r, s) {
      const a = this.hb(r),
        o = this.zb(t, e),
        c = this.P.get(o)
      if (!a || !c) return []
      const u = await c.provideDebugVisualization(a, s)
      return u
        ? u.map((l) => {
            const m = ++this.X
            this.W.set(m, { v: l, provider: c, extensionId: t })
            const h = l.iconPath ? this.Bb(l.iconPath) : void 0
            return {
              id: m,
              name: l.name,
              iconClass: h?.iconClass,
              iconPath: h?.iconPath,
              visualization: this.Ab(t, l.visualization),
            }
          })
        : []
    }
    $disposeDebugVisualizers(t) {
      for (const e of t) this.W.delete(e)
    }
    registerDebugVisualizationProvider(t, e, r) {
      if (!t.contributes?.debugVisualizers?.some((o) => o.id === e))
        throw new Error(
          `Extensions may only call registerDebugVisualizationProvider() for renderers they contribute (got ${e})`,
        )
      const s = te.toKey(t.identifier),
        a = this.zb(s, e)
      if (this.P.has(a))
        throw new Error(
          `A debug visualization provider with id '${e}' is already registered`,
        )
      return (
        this.P.set(a, r),
        this.q.$registerDebugVisualizer(s, e),
        it(() => {
          this.q.$unregisterDebugVisualizer(s, e), this.P.delete(e)
        })
      )
    }
    addBreakpoints(t) {
      const e = t.filter((a) => {
        const o = a.id
        return this.H.has(o) ? !1 : (this.H.set(o, a), !0)
      })
      this.wb(e, [], [])
      const r = [],
        s = new Map()
      for (const a of e)
        if (a instanceof Ia) {
          let o = s.get(a.location.uri.toString())
          o ||
            ((o = { type: "sourceMulti", uri: a.location.uri, lines: [] }),
            s.set(a.location.uri.toString(), o),
            r.push(o)),
            o.lines.push({
              id: a.id,
              enabled: a.enabled,
              condition: a.condition,
              hitCondition: a.hitCondition,
              logMessage: a.logMessage,
              line: a.location.range.start.line,
              character: a.location.range.start.character,
              mode: a.mode,
            })
        } else
          a instanceof Pa &&
            r.push({
              type: "function",
              id: a.id,
              enabled: a.enabled,
              hitCondition: a.hitCondition,
              logMessage: a.logMessage,
              condition: a.condition,
              functionName: a.functionName,
              mode: a.mode,
            })
      return this.q.$registerBreakpoints(r)
    }
    removeBreakpoints(t) {
      const e = t.filter((o) => this.H.delete(o.id))
      this.wb([], e, [])
      const r = e.filter((o) => o instanceof Ia).map((o) => o.id),
        s = e.filter((o) => o instanceof Pa).map((o) => o.id),
        a = e.filter((o) => o instanceof E6).map((o) => o.id)
      return this.q.$unregisterBreakpoints(r, s, a)
    }
    startDebugging(t, e, r) {
      const s = r.testRun && this.eb.getMetadataForRun(r.testRun)
      return this.q.$startDebugging(t ? t.uri : void 0, e, {
        parentSessionID: r.parentSession ? r.parentSession.id : void 0,
        lifecycleManagedByParent: r.lifecycleManagedByParent,
        repl:
          r.consoleMode === L6.MergeWithParent ? "mergeWithParent" : "separate",
        noDebug: r.noDebug,
        compact: r.compact,
        suppressSaveBeforeStart: r.suppressSaveBeforeStart,
        testRun: s && { runId: s.runId, taskId: s.taskId },
        suppressDebugStatusbar: r.suppressDebugStatusbar ?? r.debugUI?.simple,
        suppressDebugToolbar: r.suppressDebugToolbar ?? r.debugUI?.simple,
        suppressDebugView: r.suppressDebugView ?? r.debugUI?.simple,
      })
    }
    stopDebugging(t) {
      return this.q.$stopDebugging(t ? t.id : void 0)
    }
    registerDebugConfigurationProvider(t, e, r) {
      if (!e) return new At(() => {})
      const s = this.f++
      return (
        this.g.push({ type: t, handle: s, provider: e }),
        this.q.$registerDebugConfigurationProvider(
          t,
          r,
          !!e.provideDebugConfigurations,
          !!e.resolveDebugConfiguration,
          !!e.resolveDebugConfigurationWithSubstitutedVariables,
          s,
        ),
        new At(() => {
          ;(this.g = this.g.filter((a) => a.provider !== e)),
            this.q.$unregisterDebugConfigurationProvider(s)
        })
      )
    }
    registerDebugAdapterDescriptorFactory(t, e, r) {
      if (!r) return new At(() => {})
      if (!this.sb(t, e))
        throw new Error(
          `a DebugAdapterDescriptorFactory can only be registered from the extension that defines the '${e}' debugger.`,
        )
      if (this.pb(e))
        throw new Error(
          "a DebugAdapterDescriptorFactory can only be registered once per a type.",
        )
      const s = this.h++
      return (
        this.j.push({ type: e, handle: s, factory: r }),
        this.q.$registerDebugAdapterDescriptorFactory(e, s),
        new At(() => {
          ;(this.j = this.j.filter((a) => a.factory !== r)),
            this.q.$unregisterDebugAdapterDescriptorFactory(s)
        })
      )
    }
    registerDebugAdapterTrackerFactory(t, e) {
      if (!e) return new At(() => {})
      const r = this.m++
      return (
        this.n.push({ type: t, handle: r, factory: e }),
        new At(() => {
          this.n = this.n.filter((s) => s.factory !== e)
        })
      )
    }
    async $runInTerminal(t, e) {
      return Promise.resolve(void 0)
    }
    async $substituteVariables(t, e) {
      let r
      const s = await this.yb(t)
      return (
        s &&
          (r = {
            uri: s.uri,
            name: s.name,
            index: s.index,
            toResource: () => {
              throw new Error("Not implemented")
            },
          }),
        (await this.cb.getResolver()).resolveAnyAsync(r, e)
      )
    }
    ib(t, e) {
      if (t instanceof Pl) return new kwt(t.implementation)
    }
    jb() {}
    async $startDASession(t, e) {
      const r = this,
        s = await this.xb(e)
      return this.ub(this.pb(s.type), s).then((a) => {
        if (!a)
          throw new Error(
            `Couldn't find a debug adapter descriptor for debug type '${s.type}' (extension might have failed to activate)`,
          )
        const o = this.ib(a, s)
        if (!o)
          throw new Error(
            `Couldn't create a debug adapter for type '${s.type}'.`,
          )
        const c = o
        return (
          this.M.set(t, c),
          this.tb(s).then(
            (u) => (
              u && this.N.set(t, u),
              c.onMessage(async (l) => {
                if (l.type === "request" && l.command === "handshake") {
                  const m = l,
                    h = {
                      type: "response",
                      seq: 0,
                      command: m.command,
                      request_seq: m.seq,
                      success: !0,
                    }
                  this.U || (this.U = this.jb())
                  try {
                    if (this.U) {
                      const p = await this.U.sign(m.arguments.value)
                      ;(h.body = { signature: p }), c.sendResponse(h)
                    } else throw new Error("no signer")
                  } catch (p) {
                    ;(h.success = !1),
                      (h.message = p.message),
                      c.sendResponse(h)
                  }
                } else {
                  u && u.onDidSendMessage && u.onDidSendMessage(l)
                  try {
                    l = swt(l, !0)
                  } catch (m) {
                    const h = l.type + "_" + (l.command ?? l.event ?? "")
                    throw (
                      (this.Y.$publicLog2("debugProtocolMessageError", {
                        type: h,
                        from: s.type,
                      }),
                      m)
                    )
                  }
                  r.q.$acceptDAMessage(t, l)
                }
              }),
              c.onError((l) => {
                u && u.onError && u.onError(l),
                  this.q.$acceptDAError(t, l.name, l.message, l.stack)
              }),
              c.onExit((l) => {
                u && u.onExit && u.onExit(l ?? void 0, void 0),
                  this.q.$acceptDAExit(t, l ?? void 0, void 0)
              }),
              u && u.onWillStartSession && u.onWillStartSession(),
              c.startSession()
            ),
          )
        )
      })
    }
    $sendDAMessage(t, e) {
      e = nwt(e, !1)
      const r = this.N.get(t)
      r && r.onWillReceiveMessage && r.onWillReceiveMessage(e),
        this.M.get(t)?.sendMessage(e)
    }
    $stopDASession(t) {
      const e = this.N.get(t)
      this.N.delete(t), e && e.onWillStopSession && e.onWillStopSession()
      const r = this.M.get(t)
      return this.M.delete(t), r ? r.stopSession() : Promise.resolve(void 0)
    }
    $acceptBreakpointsDelta(t) {
      const e = [],
        r = [],
        s = []
      if (t.added)
        for (const a of t.added) {
          const o = a.id
          if (o && !this.H.has(o)) {
            let c
            if (a.type === "function")
              c = new Pa(
                a.functionName,
                a.enabled,
                a.condition,
                a.hitCondition,
                a.logMessage,
                a.mode,
              )
            else if (a.type === "data")
              c = new E6(
                a.label,
                a.dataId,
                a.canPersist,
                a.enabled,
                a.hitCondition,
                a.condition,
                a.logMessage,
                a.mode,
              )
            else {
              const u = S.revive(a.uri)
              c = new Ia(
                new er(u, new Lt(a.line, a.character)),
                a.enabled,
                a.condition,
                a.hitCondition,
                a.logMessage,
                a.mode,
              )
            }
            Cmt(c, o), this.H.set(o, c), e.push(c)
          }
        }
      if (t.removed)
        for (const a of t.removed) {
          const o = this.H.get(a)
          o && (this.H.delete(a), r.push(o))
        }
      if (t.changed) {
        for (const a of t.changed)
          if (a.id) {
            const o = this.H.get(a.id)
            if (o) {
              if (o instanceof Pa && a.type === "function") {
                const c = o
                ;(c.enabled = a.enabled),
                  (c.condition = a.condition),
                  (c.hitCondition = a.hitCondition),
                  (c.logMessage = a.logMessage),
                  (c.functionName = a.functionName)
              } else if (o instanceof Ia && a.type === "source") {
                const c = o
                ;(c.enabled = a.enabled),
                  (c.condition = a.condition),
                  (c.hitCondition = a.hitCondition),
                  (c.logMessage = a.logMessage),
                  (c.location = new er(
                    S.revive(a.uri),
                    new Lt(a.line, a.character),
                  ))
              }
              s.push(o)
            }
          }
      }
      this.wb(e, r, s)
    }
    async $acceptStackFrameFocus(t) {
      let e
      if (t) {
        const r = await this.xb(t.sessionId)
        t.kind === "thread"
          ? (e = new eY(r.api, t.threadId))
          : (e = new tY(r.api, t.threadId, t.frameId))
      }
      ;(this.J = e), this.L.fire(this.J)
    }
    $provideDebugConfigurations(t, e, r) {
      return gi(async () => {
        const s = this.rb(t)
        if (!s) throw new Error("no DebugConfigurationProvider found")
        if (!s.provideDebugConfigurations)
          throw new Error(
            "DebugConfigurationProvider has no method provideDebugConfigurations",
          )
        const a = await this.yb(e)
        return s.provideDebugConfigurations(a, r)
      }).then((s) => {
        if (!s)
          throw new Error(
            "nothing returned from DebugConfigurationProvider.provideDebugConfigurations",
          )
        return s
      })
    }
    $resolveDebugConfiguration(t, e, r, s) {
      return gi(async () => {
        const a = this.rb(t)
        if (!a) throw new Error("no DebugConfigurationProvider found")
        if (!a.resolveDebugConfiguration)
          throw new Error(
            "DebugConfigurationProvider has no method resolveDebugConfiguration",
          )
        const o = await this.yb(e)
        return a.resolveDebugConfiguration(o, r, s)
      })
    }
    $resolveDebugConfigurationWithSubstitutedVariables(t, e, r, s) {
      return gi(async () => {
        const a = this.rb(t)
        if (!a) throw new Error("no DebugConfigurationProvider found")
        if (!a.resolveDebugConfigurationWithSubstitutedVariables)
          throw new Error(
            "DebugConfigurationProvider has no method resolveDebugConfigurationWithSubstitutedVariables",
          )
        const o = await this.yb(e)
        return a.resolveDebugConfigurationWithSubstitutedVariables(o, r, s)
      })
    }
    async $provideDebugAdapter(t, e) {
      const r = this.qb(t)
      if (!r)
        return Promise.reject(
          new Error("no adapter descriptor factory found for handle"),
        )
      const s = await this.xb(e)
      return this.ub(r, s).then((a) => {
        if (!a)
          throw new Error(
            `Couldn't find a debug adapter descriptor for debug type '${s.type}'`,
          )
        return this.kb(a)
      })
    }
    async $acceptDebugSessionStarted(t) {
      const e = await this.xb(t)
      this.w.fire(e.api)
    }
    async $acceptDebugSessionTerminated(t) {
      const e = await this.xb(t)
      e && (this.y.fire(e.api), this.u.delete(e.id))
    }
    async $acceptDebugSessionActiveChanged(t) {
      ;(this.C = t ? await this.xb(t) : void 0), this.z.fire(this.C?.api)
    }
    async $acceptDebugSessionNameChanged(t, e) {
      ;(await this.xb(t))?._acceptNameChanged(e)
    }
    async $acceptDebugSessionCustomEvent(t, e) {
      const s = {
        session: (await this.xb(t)).api,
        event: e.event,
        body: e.body,
      }
      this.F.fire(s)
    }
    kb(t) {
      if (t instanceof I6) return this.lb(t)
      if (t instanceof Il) return this.mb(t)
      if (t instanceof P6) return this.nb(t)
      if (t instanceof Pl) return this.ob(t)
      throw new Error("convertToDto unexpected type")
    }
    lb(t) {
      return {
        type: "executable",
        command: t.command,
        args: t.args,
        options: t.options,
      }
    }
    mb(t) {
      return { type: "server", port: t.port, host: t.host }
    }
    nb(t) {
      return { type: "pipeServer", path: t.path }
    }
    ob(t) {
      return { type: "implementation" }
    }
    pb(t) {
      const e = this.j.filter((r) => r.type === t)
      if (e.length > 0) return e[0].factory
    }
    qb(t) {
      const e = this.j.filter((r) => r.handle === t)
      if (e.length > 0) return e[0].factory
    }
    rb(t) {
      const e = this.g.filter((r) => r.handle === t)
      if (e.length > 0) return e[0].provider
    }
    sb(t, e) {
      if (t.contributes) {
        const r = t.contributes.debuggers
        if (r && r.length > 0) {
          for (const s of r) if (s.label && s.type && s.type === e) return !0
        }
      }
      return !1
    }
    tb(t) {
      const r = t.configuration.type,
        s = this.n
          .filter((a) => a.type === r || a.type === "*")
          .map((a) =>
            gi(() => a.factory.createDebugAdapterTracker(t.api)).then(
              (o) => o,
              (o) => null,
            ),
          )
      return Promise.race([
        Promise.all(s).then((a) => {
          const o = Ge(a)
          if (o.length > 0) return new Twt(o)
        }),
        new Promise((a) => setTimeout(() => a(void 0), 1e3)),
      ]).catch((a) => {})
    }
    async ub(t, e) {
      const r = e.configuration.debugServer
      if (typeof r == "number") return Promise.resolve(new Il(r))
      if (t) {
        const a = await this.$.getExtensionRegistry()
        return gi(() =>
          t.createDebugAdapterDescriptor(e.api, this.vb(e, a)),
        ).then((o) => {
          if (o) return o
        })
      }
      const s = await this.$.getExtensionRegistry()
      return Promise.resolve(this.vb(e, s))
    }
    vb(t, e) {}
    wb(t, e, r) {
      ;(t.length > 0 || e.length > 0 || r.length > 0) &&
        this.I.fire(Object.freeze({ added: t, removed: e, changed: r }))
    }
    async xb(t) {
      if (t)
        if (typeof t == "string") {
          const e = this.u.get(t)
          if (e) return e
        } else {
          let e = this.u.get(t.id)
          if (!e) {
            const r = await this.yb(t.folderUri),
              s = t.parent ? this.u.get(t.parent) : void 0
            ;(e = new wwt(
              this.q,
              t.id,
              t.type,
              t.name,
              r,
              t.configuration,
              s?.api,
            )),
              this.u.set(e.id, e),
              this.q.$sessionCached(e.id)
          }
          return e
        }
      throw new Error("cannot find session")
    }
    yb(t) {
      if (t) {
        const e = S.revive(t)
        return this.Z.resolveWorkspaceFolder(e)
      }
      return Promise.resolve(void 0)
    }
    zb(t, e) {
      return `${t}\0${e}`
    }
    Ab(t, e) {
      if (e) {
        if ("title" in e && "command" in e) return { type: 0 }
        if ("treeId" in e) return { type: 1, id: `${t}\0${e.treeId}` }
        throw new Error("Unsupported debug visualization type")
      }
    }
    Bb(t) {
      const e = this.Cb(t)
      let r, s
      return (
        "id" in e ? (s = ri.asClassName(e)) : (r = e),
        { iconPath: r, iconClass: s }
      )
    }
    Cb(t) {
      if (t instanceof Si) return { id: t.id }
      const e = typeof t == "object" && "dark" in t ? t.dark : t,
        r = typeof t == "object" && "light" in t ? t.light : t
      return {
        dark: typeof e == "string" ? S.file(e) : e,
        light: typeof r == "string" ? S.file(r) : r,
      }
    }
  }
lU = __decorate(
  [
    __param(0, Vt),
    __param(1, _n),
    __param(2, Fs),
    __param(3, An),
    __param(4, zd),
    __param(5, cU),
    __param(6, Ba),
    __param(7, L7),
  ],
  lU,
)
var wwt = class {
    constructor(i, t, e, r, s, a, o) {
      ;(this.f = i),
        (this.g = t),
        (this.h = e),
        (this.j = r),
        (this.k = s),
        (this.l = a),
        (this.m = o)
    }
    get api() {
      const i = this
      return (this.d ??= Object.freeze({
        id: i.g,
        type: i.h,
        get name() {
          return i.j
        },
        set name(t) {
          ;(i.j = t), i.f.$setDebugSessionName(i.g, t)
        },
        parentSession: i.m,
        workspaceFolder: i.k,
        configuration: i.l,
        customRequest(t, e) {
          return i.f.$customDebugAdapterRequest(i.g, t, e)
        },
        getDebugProtocolBreakpoint(t) {
          return i.f.$getDebugProtocolBreakpoint(i.g, t.id)
        },
      }))
    }
    get id() {
      return this.g
    }
    get type() {
      return this.h
    }
    _acceptNameChanged(i) {
      this.j = i
    }
    get configuration() {
      return this.l
    }
  },
  ywt = class {
    constructor(i) {
      this.value = Object.freeze({
        append(t) {
          i.$appendDebugConsole(t)
        },
        appendLine(t) {
          this.append(
            t +
              `
`,
          )
        },
      })
    }
  },
  Twt = class {
    constructor(i) {
      this.d = i
    }
    onWillStartSession() {
      this.d.forEach((i) =>
        i.onWillStartSession ? i.onWillStartSession() : void 0,
      )
    }
    onWillReceiveMessage(i) {
      this.d.forEach((t) =>
        t.onWillReceiveMessage ? t.onWillReceiveMessage(i) : void 0,
      )
    }
    onDidSendMessage(i) {
      this.d.forEach((t) =>
        t.onDidSendMessage ? t.onDidSendMessage(i) : void 0,
      )
    }
    onWillStopSession() {
      this.d.forEach((i) =>
        i.onWillStopSession ? i.onWillStopSession() : void 0,
      )
    }
    onError(i) {
      this.d.forEach((t) => (t.onError ? t.onError(i) : void 0))
    }
    onExit(i, t) {
      this.d.forEach((e) => (e.onExit ? e.onExit(i, t) : void 0))
    }
  },
  kwt = class extends twt {
    constructor(i) {
      super(),
        (this.h = i),
        i.onDidSendMessage((t) => {
          this.acceptMessage(t)
        })
    }
    startSession() {
      return Promise.resolve(void 0)
    }
    sendMessage(i) {
      this.h.handleMessage(i)
    }
    stopSession() {
      return this.h.dispose(), Promise.resolve(void 0)
    }
  },
  dU = class extends lU {
    constructor(t, e, r, s, a, o, c, u) {
      super(t, e, r, s, a, o, c, u)
    }
  }
dU = __decorate(
  [
    __param(0, Vt),
    __param(1, _n),
    __param(2, Fs),
    __param(3, An),
    __param(4, zd),
    __param(5, cU),
    __param(6, Ba),
    __param(7, L7),
  ],
  dU,
)
function Swt(i) {
  return "uri" in i && "ranges" in i && "preview" in i
}
function bwt(i) {
  return i.folderOptions.map((t) => ({
    folder: t.folder,
    excludes: t.excludes.map((e) => (typeof e == "string" ? e : e.pattern)),
    includes: t.includes,
    useGlobalIgnoreFiles: t.useIgnoreFiles.global,
    useIgnoreFiles: t.useIgnoreFiles.local,
    useParentIgnoreFiles: t.useIgnoreFiles.parent,
    followSymlinks: t.followSymlinks,
    maxResults: i.maxResults,
    session: i.session,
  }))
}
var VK = class {
  constructor(i) {
    this.a = i
  }
  provideFileSearchResults(i, t, e) {
    return (async () => {
      const s = bwt(t)
      return Promise.all(
        s.map((a) => this.a.provideFileSearchResults({ pattern: i }, a, e)),
      )
    })().then((s) => Ge(s).flat())
  }
}
function Ewt(i) {
  return i.folderOptions.map((t) => ({
    folder: t.folder,
    excludes: t.excludes.map((e) => (typeof e == "string" ? e : e.pattern)),
    includes: t.includes,
    useGlobalIgnoreFiles: t.useIgnoreFiles.global,
    useIgnoreFiles: t.useIgnoreFiles.local,
    useParentIgnoreFiles: t.useIgnoreFiles.parent,
    followSymlinks: t.followSymlinks,
    maxResults: i.maxResults,
    previewOptions: Iwt(i.previewOptions),
    maxFileSize: i.maxFileSize,
    encoding: t.encoding,
    afterContext: i.surroundingContext,
    beforeContext: i.surroundingContext,
  }))
}
function Iwt(i) {
  return {
    matchLines: i?.matchLines ?? Pq.matchLines,
    charsPerLine: i?.charsPerLine ?? Pq.charsPerLine,
  }
}
function Pwt(i) {
  if (Swt(i)) {
    const t = Yr(i.ranges).map((e, r) => {
      const a = Yr(i.preview.matches)[r]
      return { sourceRange: e, previewRange: a }
    })
    return new Is(i.uri, t, i.preview.text)
  } else return new Iq(i.uri, i.text, i.lineNumber)
}
var Nwt = class {
  constructor(i) {
    this.a = i
  }
  provideTextSearchResults(i, t, e, r) {
    const s = (c) => {
      $wt(c) && e.report(Pwt(c))
    }
    return (async () =>
      Ge(
        await Promise.all(
          Ewt(t).map((c) =>
            this.a.provideTextSearchResults(i, c, { report: (u) => s(u) }, r),
          ),
        ),
      ).reduce((c, u) => ({ limitHit: c.limitHit || u.limitHit }), {
        limitHit: !1,
      }))().then((c) => ({ limitHit: c.limitHit, message: Ge(Yr(c.message)) }))
  }
}
function $wt(i) {
  if (xwt(i)) {
    if (Array.isArray(i.ranges)) {
      if (!Array.isArray(i.preview.matches))
        return (
          console.warn(
            "INVALID - A text search provider match's`ranges` and`matches` properties must have the same type.",
          ),
          !1
        )
      if (i.preview.matches.length !== i.ranges.length)
        return (
          console.warn(
            "INVALID - A text search provider match's`ranges` and`matches` properties must have the same length.",
          ),
          !1
        )
    } else if (Array.isArray(i.preview.matches))
      return (
        console.warn(
          "INVALID - A text search provider match's`ranges` and`matches` properties must have the same length.",
        ),
        !1
      )
  }
  return !0
}
function xwt(i) {
  return !!i.preview
}
var GK = class extends ls {
    constructor(i, t, e = () => !1) {
      const r = new Uj(e, () => !1)
      super(r)
      const s = new ei()
      i.forEach((a, o) => {
        const c = a.folder.with({ query: "", fragment: "" })
        s.has(c) ? s.get(c).push({ fq: a, i: o }) : s.set(c, [{ fq: a, i: o }])
      }),
        s.forEach((a, o) => {
          const c = new Map()
          for (const u of a) {
            const l = t(u.fq, u.i)
            c.set(this.l(u.fq.folder), l)
          }
          super.set(o, c)
        })
    }
    findQueryFragmentAwareSubstr(i) {
      const t = super.findSubstr(i.with({ query: "", fragment: "" }))
      if (!t) return
      const e = this.l(i)
      return t.get(e)
    }
    forEachFolderQueryInfo(i) {
      return this.forEach((t) => t.forEach((e) => i(e)))
    }
    l(i) {
      let t = ""
      return i.query && (t += i.query), i.fragment && (t += "#" + i.fragment), t
    }
  },
  Jwt = class {
    constructor(i, t, e) {
      ;(this.l = i),
        (this.o = t),
        (this.p = e),
        (this.f = !1),
        (this.g = 0),
        (this.h = !1),
        (this.a = i.filePattern),
        (this.b = i.includePattern && Jo(i.includePattern)),
        (this.c = i.maxResults || void 0),
        (this.d = i.exists),
        (this.j = new Set()),
        (this.k = i.excludePattern && Jo(i.excludePattern))
    }
    cancel() {
      ;(this.h = !0), this.j.forEach((i) => i.cancel()), (this.j = new Set())
    }
    search(i) {
      const t = this.l.folderQueries || []
      return new Promise((e, r) => {
        const s = (a) => {
          this.g++, i(a)
        }
        if (this.h) return e({ limitHit: this.f })
        this.l.extraFileResources &&
          this.l.extraFileResources.forEach((a) => {
            const o = a.toString(),
              c = ji(o)
            ;(this.k && this.k(o, c)) || this.w(s, { base: a, basename: c })
          }),
          this.q(t, s).then(
            (a) => {
              e({ limitHit: this.f, stats: a || void 0 })
            },
            (a) => {
              r(new Error(ea(a)))
            },
          )
      })
    }
    async q(i, t) {
      const e = new Ie(),
        r = i.map((l) => this.r(l)),
        s = this.o instanceof VK ? this.p?.tokenSource.token : this.p?.obj,
        a = {
          folderOptions: r,
          maxResults: this.l.maxResults ?? bY,
          session: s,
        },
        o = (l) => {
          const m = new FY(this.l, l),
            h = !m.hasSiblingExcludeClauses()
          return {
            queryTester: m,
            noSiblingsClauses: h,
            folder: l.folder,
            tree: this.s(),
          }
        },
        c = new GK(i, o)
      let u
      try {
        this.j.add(e), (u = Ys.create())
        const l = await this.o.provideFileSearchResults(
            this.l.filePattern || "",
            a,
            e.token,
          ),
          m = u.elapsed(),
          h = Ys.create()
        return (this.h && !this.f) ||
          (l &&
            l.forEach((p) => {
              const g = c.findQueryFragmentAwareSubstr(p),
                w = Ut.relative(g.folder.path, p.path)
              if (g.noSiblingsClauses) {
                const T = ji(p.path)
                this.w(t, { base: g.folder, relativePath: w, basename: T })
                return
              }
              this.u(g.tree, g.folder, w, t)
            }),
          this.h && !this.f)
          ? null
          : (c.forEachFolderQueryInfo((p) => {
              this.v(p.tree, p.queryTester, t)
            }),
            { providerTime: m, postProcessTime: h.elapsed() })
      } finally {
        e.dispose(), this.j.delete(e)
      }
    }
    r(i) {
      const t = pc(this.l.includePattern, i.includePattern)
      let e = i.excludePattern?.map((s) => ({
        folder: s.folder,
        patterns: pc(this.l.excludePattern, s.pattern),
      }))
      e?.length ||
        (e = [{ folder: void 0, patterns: pc(this.l.excludePattern, void 0) }])
      const r = AY(e)
      return {
        folder: i.folder,
        excludes: r,
        includes: t,
        useIgnoreFiles: {
          local: !i.disregardIgnoreFiles,
          parent: !i.disregardParentIgnoreFiles,
          global: !i.disregardGlobalIgnoreFiles,
        },
        followSymlinks: !i.ignoreSymlinks,
      }
    }
    s() {
      const i = { rootEntries: [], pathToEntries: Object.create(null) }
      return (i.pathToEntries["."] = i.rootEntries), i
    }
    u({ pathToEntries: i }, t, e, r) {
      if (e === this.a) {
        const a = ji(this.a)
        this.w(r, { base: t, relativePath: this.a, basename: a })
      }
      function s(a) {
        const o = ji(a),
          c = mo(a)
        let u = i[c]
        u || ((u = i[c] = []), s(c)),
          u.push({ base: t, relativePath: a, basename: o })
      }
      s(e)
    }
    v({ rootEntries: i, pathToEntries: t }, e, r) {
      const s = this,
        a = this.a
      function o(c) {
        const u = Zmt(() => c.map((l) => l.basename))
        for (let l = 0, m = c.length; l < m; l++) {
          const h = c[l],
            { relativePath: p, basename: g } = h
          if (e.matchesExcludesSync(p, g, a !== g ? u : void 0)) continue
          const w = t[p]
          if (w) o(w)
          else {
            if (p === a) continue
            s.w(r, h)
          }
          if (s.f) break
        }
      }
      o(i)
    }
    w(i, t) {
      ;(!this.b || (t.relativePath && this.b(t.relativePath, t.basename))) &&
        ((this.d || (this.c && this.g >= this.c)) &&
          ((this.f = !0), this.cancel()),
        this.f || i(t))
    }
  },
  Cwt = class {
    constructor() {
      ;(this.a = new Object()), (this.tokenSource = new Ie())
    }
    get obj() {
      if (this.a) return this.a
      throw new Error("Session object has been dereferenced.")
    }
    cancel() {
      this.tokenSource.cancel(), (this.a = void 0)
    }
  },
  Lwt = class Knt {
    constructor() {
      this.b = new Map()
    }
    static {
      this.a = 512
    }
    fileSearch(t, e, r, s) {
      const a = this.c(t.cacheKey),
        o = new Jwt(t, e, a)
      let c = 0
      const u = (l) => {
        ;(c += l.length), r(l.map((m) => this.d(m)))
      }
      return this.f(o, Knt.a, u, s).then((l) => ({
        limitHit: l.limitHit,
        stats: l.stats
          ? {
              fromCache: !1,
              type: "fileSearchProvider",
              resultCount: c,
              detailStats: l.stats,
            }
          : void 0,
        messages: [],
      }))
    }
    clearCache(t) {
      this.b.get(t)?.cancel(), this.b.delete(t)
    }
    c(t) {
      if (t) return this.b.has(t) || this.b.set(t, new Cwt()), this.b.get(t)
    }
    d(t) {
      return t.relativePath
        ? { resource: Ti(t.base, t.relativePath) }
        : { resource: t.base }
    }
    f(t, e, r, s) {
      const a = s.onCancellationRequested(() => {
          t.cancel()
        }),
        o = (u) => {
          u && (c.push(u), e > 0 && c.length >= e && (r(c), (c = [])))
        }
      let c = []
      return t.search(o).then(
        (u) => (c.length && r(c), a.dispose(), u),
        (u) => (c.length && r(c), a.dispose(), Promise.reject(u)),
      )
    }
  },
  zK = class {
    constructor(i, t, e) {
      ;(this.f = i),
        (this.g = t),
        (this.h = e),
        (this.b = null),
        (this.c = !1),
        (this.d = 0)
    }
    get j() {
      return this.f.query
    }
    search(i, t) {
      const e = this.j.folderQueries || [],
        r = new Ie(t)
      return new Promise((s, a) => {
        this.b = new Dwt(i)
        let o = !1
        const c = (u, l) => {
          if (!o && !this.c) {
            const m = this.l(u)
            u instanceof Is &&
              typeof this.j.maxResults == "number" &&
              this.d + m > this.j.maxResults &&
              ((this.c = !0),
              (o = !0),
              r.cancel(),
              (u = this.m(u, this.j.maxResults - this.d)))
            const h = this.l(u)
            this.d += h
            const p = u instanceof Is
            ;(h > 0 || !p) && this.b.add(u, l)
          }
        }
        this.n(e, c, r.token).then(
          (u) => {
            r.dispose(),
              this.b.flush(),
              s({
                limitHit: this.c || u?.limitHit,
                messages: this.k(u),
                stats: { type: this.h },
              })
          },
          (u) => {
            r.dispose()
            const l = ea(u)
            a(new Error(l))
          },
        )
      })
    }
    k(i) {
      return i?.message
        ? Array.isArray(i.message)
          ? i.message
          : [i.message]
        : []
    }
    l(i) {
      return i instanceof Is
        ? Array.isArray(i.ranges)
          ? i.ranges.length
          : 1
        : 0
    }
    m(i, t) {
      return new Is(i.uri, i.ranges.slice(0, t), i.previewText)
    }
    async n(i, t, e) {
      const r = new GK(
          i,
          (l, m) => ({
            queryTester: new FY(this.j, l),
            folder: l.folder,
            folderIdx: m,
          }),
          () => !0,
        ),
        s = [],
        a = {
          report: (l) => {
            if (l.uri === void 0)
              throw Error(
                "Text search result URI is undefined. Please check provider implementation.",
              )
            const m = r.findQueryFragmentAwareSubstr(l.uri),
              h =
                m.folder.scheme === Q.file
                  ? Kmt(() => this.g.readdir(RB(l.uri)))
                  : void 0,
              p = ZW(m.folder, l.uri)
            if (p) {
              const g = m.queryTester.includedInQuery(p, ji(p), h)
              wn(g)
                ? s.push(
                    g.then((w) => {
                      w && t(l, m.folderIdx)
                    }),
                  )
                : g && t(l, m.folderIdx)
            }
          },
        },
        c = {
          folderOptions: i.map((l) => this.o(l)),
          maxFileSize: this.j.maxFileSize,
          maxResults: this.j.maxResults ?? bY,
          previewOptions: this.j.previewOptions ?? Pq,
          surroundingContext: this.j.surroundingContext ?? 0,
        }
      "usePCRE2" in this.j && (c.usePCRE2 = this.j.usePCRE2)
      let u
      return (
        this.f.query.type === 3
          ? (u = await this.f.provider.provideAITextSearchResults(
              this.f.query.contentPattern,
              c,
              a,
              e,
            ))
          : (u = await this.f.provider.provideTextSearchResults(
              Rwt(this.f.query.contentPattern),
              c,
              a,
              e,
            )),
        s.length && (await Promise.all(s)),
        u
      )
    }
    o(i) {
      const t = pc(this.j.includePattern, i.includePattern)
      let e = i.excludePattern?.map((a) => ({
        folder: a.folder,
        patterns: pc(this.j.excludePattern, a.pattern),
      }))
      ;(!e || e.length === 0) &&
        (e = [{ folder: void 0, patterns: pc(this.j.excludePattern, void 0) }])
      const r = AY(e)
      return {
        folder: S.from(i.folder),
        excludes: r,
        includes: t,
        useIgnoreFiles: {
          local: !i.disregardIgnoreFiles,
          parent: !i.disregardParentIgnoreFiles,
          global: !i.disregardGlobalIgnoreFiles,
        },
        followSymlinks: !i.ignoreSymlinks,
        encoding:
          (i.fileEncoding && this.g.toCanonicalName(i.fileEncoding)) ?? "",
      }
    }
  }
function Rwt(i) {
  return {
    isCaseSensitive: i.isCaseSensitive || !1,
    isRegExp: i.isRegExp || !1,
    isWordMatch: i.isWordMatch || !1,
    isMultiline: i.isMultiline || !1,
    pattern: i.pattern,
  }
}
var Dwt = class {
  constructor(i) {
    ;(this.g = i),
      (this.c = -1),
      (this.f = null),
      (this.b = new _wt(512, (t) => this.j(t)))
  }
  add(i, t) {
    this.f &&
      (this.c !== t || !KW(this.d, i.uri)) &&
      (this.h(), (this.f = null)),
      this.f || ((this.c = t), (this.f = { resource: i.uri, results: [] })),
      this.f.results.push(Fwt(i))
  }
  h() {
    const i = this.f && this.f.results ? this.f.results.length : 0
    this.b.addItem(this.f, i)
  }
  flush() {
    this.h(), this.b.flush()
  }
  j(i) {
    this.g(i)
  }
}
function Fwt(i) {
  return i instanceof Is
    ? {
        previewText: i.previewText,
        rangeLocations: i.ranges.map((t) => ({
          preview: {
            startLineNumber: t.previewRange.start.line,
            startColumn: t.previewRange.start.character,
            endLineNumber: t.previewRange.end.line,
            endColumn: t.previewRange.end.character,
          },
          source: {
            startLineNumber: t.sourceRange.start.line,
            startColumn: t.sourceRange.start.character,
            endLineNumber: t.sourceRange.end.line,
            endColumn: t.sourceRange.end.character,
          },
        })),
      }
    : { text: i.text, lineNumber: i.lineNumber }
}
var _wt = class kH {
    static {
      this.b = 4e3
    }
    static {
      this.c = 50
    }
    constructor(t, e) {
      ;(this.j = t), (this.k = e), (this.d = 0), (this.f = []), (this.g = 0)
    }
    addItem(t, e) {
      t && this.l(t, e)
    }
    addItems(t, e) {
      t && this.m(t, e)
    }
    l(t, e) {
      this.f.push(t), (this.g += e), this.n()
    }
    m(t, e) {
      ;(this.f = this.f.concat(t)), (this.g += e), this.n()
    }
    n() {
      this.d < kH.c
        ? this.flush()
        : this.g >= this.j
          ? this.flush()
          : this.h ||
            (this.h = setTimeout(() => {
              this.flush()
            }, kH.b))
    }
    flush() {
      this.g &&
        ((this.d += this.g),
        this.k(this.f),
        (this.f = []),
        (this.g = 0),
        this.h && (clearTimeout(this.h), (this.h = 0)))
    }
  },
  YK = Y("IExtHostSearch"),
  mU = class {
    constructor(t, e, r) {
      ;(this.o = t),
        (this.q = e),
        (this.s = r),
        (this.c = this.o.getProxy(z.MainThreadSearch)),
        (this.e = 0),
        (this.g = new Map()),
        (this.h = new Set()),
        (this.i = new Map()),
        (this.j = new Set()),
        (this.k = new Map()),
        (this.l = new Set()),
        (this.n = new Lwt())
    }
    t(t) {
      return this.q.transformOutgoingScheme(t)
    }
    registerTextSearchProviderOld(t, e) {
      if (this.h.has(t))
        throw new Error(
          `a text search provider for the scheme '${t}' is already registered`,
        )
      this.h.add(t)
      const r = this.e++
      return (
        this.g.set(r, new Nwt(e)),
        this.c.$registerTextSearchProvider(r, this.t(t)),
        it(() => {
          this.h.delete(t), this.g.delete(r), this.c.$unregisterProvider(r)
        })
      )
    }
    registerTextSearchProvider(t, e) {
      if (this.h.has(t))
        throw new Error(
          `a text search provider for the scheme '${t}' is already registered`,
        )
      this.h.add(t)
      const r = this.e++
      return (
        this.g.set(r, e),
        this.c.$registerTextSearchProvider(r, this.t(t)),
        it(() => {
          this.h.delete(t), this.g.delete(r), this.c.$unregisterProvider(r)
        })
      )
    }
    registerAITextSearchProvider(t, e) {
      if (this.j.has(t))
        throw new Error(
          `an AI text search provider for the scheme '${t}'is already registered`,
        )
      this.j.add(t)
      const r = this.e++
      return (
        this.i.set(r, e),
        this.c.$registerAITextSearchProvider(r, this.t(t)),
        it(() => {
          this.j.delete(t), this.i.delete(r), this.c.$unregisterProvider(r)
        })
      )
    }
    registerFileSearchProviderOld(t, e) {
      if (this.l.has(t))
        throw new Error(
          `a file search provider for the scheme '${t}' is already registered`,
        )
      this.l.add(t)
      const r = this.e++
      return (
        this.k.set(r, new VK(e)),
        this.c.$registerFileSearchProvider(r, this.t(t)),
        it(() => {
          this.l.delete(t), this.k.delete(r), this.c.$unregisterProvider(r)
        })
      )
    }
    registerFileSearchProvider(t, e) {
      if (this.l.has(t))
        throw new Error(
          `a file search provider for the scheme '${t}' is already registered`,
        )
      this.l.add(t)
      const r = this.e++
      return (
        this.k.set(r, e),
        this.c.$registerFileSearchProvider(r, this.t(t)),
        it(() => {
          this.l.delete(t), this.k.delete(r), this.c.$unregisterProvider(r)
        })
      )
    }
    $provideFileSearchResults(t, e, r, s) {
      const a = hU(r),
        o = this.k.get(t)
      if (o)
        return this.n.fileSearch(
          a,
          o,
          (c) => {
            this.c.$handleFileMatch(
              t,
              e,
              c.map((u) => u.resource),
            )
          },
          s,
        )
      throw new Error("unknown provider: " + t)
    }
    async doInternalFileSearchWithCustomCallback(t, e, r) {
      return { messages: [] }
    }
    $clearCache(t) {
      return this.n.clearCache(t), Promise.resolve(void 0)
    }
    $provideTextSearchResults(t, e, r, s) {
      const a = this.g.get(t)
      if (!a || !a.provideTextSearchResults)
        throw new Error(`Unknown Text Search Provider ${t}`)
      const o = hU(r)
      return this.v(o, a).search((u) => this.c.$handleTextMatch(t, e, u), s)
    }
    $provideAITextSearchResults(t, e, r, s) {
      const a = this.i.get(t)
      if (!a || !a.provideAITextSearchResults)
        throw new Error(`Unknown AI Text Search Provider ${t}`)
      const o = hU(r)
      return this.w(o, a).search((u) => this.c.$handleTextMatch(t, e, u), s)
    }
    $enableExtensionHostSearch() {}
    async $getAIName(t) {
      const e = this.i.get(t)
      if (!(!e || !e.provideAITextSearchResults)) return e.name ?? "AI"
    }
    v(t, e) {
      return new zK(
        { query: t, provider: e },
        { readdir: (r) => Promise.resolve([]), toCanonicalName: (r) => r },
        "textSearchProvider",
      )
    }
    w(t, e) {
      return new zK(
        { query: t, provider: e },
        { readdir: (r) => Promise.resolve([]), toCanonicalName: (r) => r },
        "aiTextSearchProvider",
      )
    }
  }
mU = __decorate([__param(0, Vt), __param(1, m_), __param(2, Kt)], mU)
function hU(i) {
  return {
    ...i,
    folderQueries: i.folderQueries && i.folderQueries.map(Awt),
    extraFileResources:
      i.extraFileResources && i.extraFileResources.map((t) => S.revive(t)),
  }
}
function Awt(i) {
  return $i(i)
}
var fU,
  pU = class {
    static {
      fU = this
    }
    static {
      this.a = { focused: !0, active: !0 }
    }
    getState() {
      const t = this.f
      return {
        get focused() {
          return t.focused
        },
        get active() {
          return t.active
        },
      }
    }
    constructor(t, e) {
      ;(this.c = new C()),
        (this.onDidChangeWindowState = this.c.event),
        (this.f = fU.a),
        t.handle && (this.d = jF(t.handle).buffer),
        (this.b = e.getProxy(z.MainThreadWindow)),
        this.b.$getInitialState().then(({ isFocused: r, isActive: s }) => {
          this.onDidChangeWindowProperty("focused", r),
            this.onDidChangeWindowProperty("active", s)
        })
    }
    get nativeHandle() {
      return this.d
    }
    $onDidChangeActiveNativeWindowHandle(t) {
      this.d = t ? jF(t).buffer : void 0
    }
    $onDidChangeWindowFocus(t) {
      this.onDidChangeWindowProperty("focused", t)
    }
    $onDidChangeWindowActive(t) {
      this.onDidChangeWindowProperty("active", t)
    }
    onDidChangeWindowProperty(t, e) {
      e !== this.f[t] && ((this.f = { ...this.f, [t]: e }), this.c.fire(this.f))
    }
    openUri(t, e) {
      let r
      if (typeof t == "string") {
        r = t
        try {
          t = S.parse(t)
        } catch {
          return Promise.reject(`Invalid uri - '${t}'`)
        }
      }
      return s_(t.scheme)
        ? Promise.reject("Invalid scheme - cannot be empty")
        : t.scheme === Q.command
          ? Promise.reject(`Invalid scheme '${t.scheme}'`)
          : this.b.$openUri(t, r, e)
    }
    async asExternalUri(t, e) {
      if (s_(t.scheme))
        return Promise.reject("Invalid scheme - cannot be empty")
      const r = await this.b.$asExternalUri(t, e)
      return S.from(r)
    }
  }
pU = fU = __decorate([__param(0, ci), __param(1, Vt)], pU)
var QK = Y("IExtHostWindow"),
  gU = class extends Zct {
    constructor(t, e) {
      super(
        e.logLevel,
        e.logsLocation,
        e.loggers.map((r) => $i(r)),
      ),
        (this.r = t.getProxy(z.MainThreadLogger))
    }
    $setLogLevel(t, e) {
      e ? this.setLogLevel(S.revive(e), t) : this.setLogLevel(t)
    }
    setVisibility(t, e) {
      super.setVisibility(t, e), this.r.$setVisibility(t, e)
    }
    q(t, e, r) {
      return new Bwt(this.r, t, e, r)
    }
  }
gU = __decorate([__param(0, Vt), __param(1, ci)], gU)
var Bwt = class extends Rj {
    constructor(i, t, e, r) {
      super(r?.logLevel === "always"),
        (this.r = i),
        (this.s = t),
        (this.n = !1),
        (this.q = []),
        this.setLevel(e),
        this.r.$createLogger(t, r).then(() => {
          this.u(this.q), (this.n = !0)
        })
    }
    m(i, t) {
      const e = [[i, t]]
      this.n ? this.u(e) : this.q.push(...e)
    }
    u(i) {
      this.r.$log(this.s, i)
    }
    flush() {
      this.r.$flush(this.s)
    }
  },
  XK = Y("IExtHostTerminalShellIntegration"),
  vU = class extends dt {
    constructor(t, e) {
      super(),
        (this.h = e),
        (this.b = new Map()),
        (this.c = new C()),
        (this.onDidChangeTerminalShellIntegration = this.c.event),
        (this.f = new C()),
        (this.onDidStartTerminalShellExecution = this.f.event),
        (this.g = new C()),
        (this.onDidEndTerminalShellExecution = this.g.event),
        (this.a = t.getProxy(z.MainThreadTerminalShellIntegration)),
        this.D(
          it(() => {
            for (const [r, s] of this.b) s.dispose()
            this.b.clear()
          }),
        )
    }
    $shellIntegrationChange(t) {
      const e = this.h.getTerminalById(t)
      if (!e) return
      const r = e.value
      let s = this.b.get(t)
      s ||
        ((s = new Owt(e.value, this.f)),
        this.b.set(t, s),
        s.store.add(e.onWillDispose(() => this.b.get(t)?.dispose())),
        s.store.add(
          s.onDidRequestShellExecution((a) => this.a.$executeCommand(t, a)),
        ),
        s.store.add(s.onDidRequestEndExecution((a) => this.g.fire(a))),
        s.store.add(
          s.onDidRequestChangeShellIntegration((a) => this.c.fire(a)),
        ),
        (e.shellIntegration = s.value)),
        this.c.fire({ terminal: r, shellIntegration: s.value })
    }
    $shellExecutionStart(t, e, r, s, a) {
      this.b.has(t) || this.$shellIntegrationChange(t)
      const o = { value: e, confidence: r, isTrusted: s }
      this.b.get(t)?.startShellExecution(o, S.revive(a))
    }
    $shellExecutionEnd(t, e, r, s, a) {
      const o = { value: e, confidence: r, isTrusted: s }
      this.b.get(t)?.endShellExecution(o, a)
    }
    $shellExecutionData(t, e) {
      this.b.get(t)?.emitData(e)
    }
    $cwdChange(t, e) {
      this.b.get(t)?.setCwd(S.revive(e))
    }
    $closeTerminal(t) {
      this.b.get(t)?.dispose(), this.b.delete(t)
    }
  }
vU = __decorate([__param(0, Vt), __param(1, Pc)], vU)
var Owt = class extends dt {
    get currentExecution() {
      return this.a
    }
    constructor(i, t) {
      super(),
        (this.j = i),
        (this.m = t),
        (this.b = !1),
        (this.store = this.D(new bt())),
        (this.f = this.D(new C())),
        (this.onDidRequestChangeShellIntegration = this.f.event),
        (this.g = this.D(new C())),
        (this.onDidRequestShellExecution = this.g.event),
        (this.h = this.D(new C())),
        (this.onDidRequestEndExecution = this.h.event)
      const e = this
      this.value = {
        get cwd() {
          return e.c
        },
        executeCommand(r, s) {
          let a = r
          if (s)
            for (const u of s)
              !u.match(/["'`]/) && u.match(/\s/)
                ? (a += ` "${u}"`)
                : (a += ` ${u}`)
          e.g.fire(a)
          const o = { value: a, confidence: y6.High, isTrusted: !0 },
            c = e.startShellExecution(o, e.c, !0).value
          return (e.b = !0), c
        },
      }
    }
    startShellExecution(i, t, e) {
      if (this.b && this.a) this.b = !1
      else {
        this.a &&
          (this.a.endExecution(void 0),
          this.h.fire({
            terminal: this.j,
            shellIntegration: this.value,
            execution: this.a.value,
            exitCode: void 0,
          }))
        const r = (this.a = new qwt(i, t ?? this.c))
        e
          ? queueMicrotask(() =>
              this.m.fire({
                terminal: this.j,
                shellIntegration: this.value,
                execution: r.value,
              }),
            )
          : this.m.fire({
              terminal: this.j,
              shellIntegration: this.value,
              execution: this.a.value,
            })
      }
      return this.a
    }
    emitData(i) {
      this.currentExecution?.emitData(i)
    }
    endShellExecution(i, t) {
      this.a &&
        (this.a.endExecution(i),
        this.h.fire({
          terminal: this.j,
          shellIntegration: this.value,
          execution: this.a.value,
          exitCode: t,
        }),
        (this.a = void 0))
    }
    setCwd(i) {
      let t = !1
      S.isUri(this.c)
        ? (t = !S.isUri(i) || this.c.toString() !== i.toString())
        : this.c !== i && (t = !0),
        t &&
          ((this.c = i),
          this.f.fire({ terminal: this.j, shellIntegration: this.value }))
    }
  },
  qwt = class {
    constructor(i, t) {
      ;(this.c = i), (this.cwd = t), (this.b = !1)
      const e = this
      this.value = {
        get commandLine() {
          return e.c
        },
        get cwd() {
          return e.cwd
        },
        read() {
          return e.d()
        },
      }
    }
    d() {
      if (!this.a) {
        if (this.b) return Fu.EMPTY
        this.a = new Uwt()
      }
      return this.a.createIterable()
    }
    emitData(i) {
      this.a?.emitData(i)
    }
    endExecution(i) {
      i && (this.c = i),
        this.a?.endExecution(),
        (this.a = void 0),
        (this.b = !0)
    }
  },
  Uwt = class extends dt {
    constructor() {
      super(...arguments), (this.b = [])
    }
    createIterable() {
      this.a || (this.a = new Xr())
      const i = this.a
      return new Fu(async (e) => {
        this.b.push(e), await i.wait()
      })
    }
    emitData(i) {
      for (const t of this.b) t.emitOne(i)
    }
    endExecution() {
      this.a?.open(), (this.a = void 0)
    }
  },
  wU = class extends dt {
    constructor(t) {
      super(),
        (this.b = new C()),
        (this.onProcessConfigUpdate = this.b.event),
        (this.a = t.getProxy(z.MainThreadCursor))
    }
    processConfigUpdate(t) {
      this.b.fire(t)
    }
    async sendEnvelope(t, e) {
      await this.a.$sendEnvelope(t, e)
    }
    async sendScopeUpdate(t, e) {
      await this.a.$sendScopeUpdate(t, e)
    }
    async setClientTracingConfig(t) {
      throw new Error("Method not implemented.")
    }
    async setIsPrivacyMode(t) {
      throw new Error("Method not implemented.")
    }
    async setUser(t, e) {
      throw new Error("Method not implemented.")
    }
  }
wU = __decorate([__param(0, Vt)], wU)
var KK = Y("IExtHostTracingService")
Zt(O2, B2, 1),
  Zt(Hu, gU, 1),
  Zt(E7, z2, 1),
  Zt(Ba, b2, 0),
  Zt(N2, $2, 0),
  Zt(x2, J2, 0),
  Zt(An, n2, 0),
  Zt(y7, h2, 0),
  Zt(L7, oU, 0),
  Zt(jK, dU, 0),
  Zt(dK, j2, 0),
  Zt(xc, G2, 0),
  Zt(q2, U2, 0),
  Zt(To, gut, 0),
  Zt(lK, W2, 1),
  Zt(YK, mU, 0),
  Zt(m2, hX, 0),
  Zt(FK, sU, 0),
  Zt(Pc, P2, 0),
  Zt(XK, vU, 0),
  Zt(y2, T2, 0),
  Zt(QK, pU, 0),
  Zt(_n, t2, 0),
  Zt(A2, rK, 0),
  Zt(T7, S2, 0),
  Zt(zd, aU, 0),
  Zt(cU, uU, 0),
  Zt(KK, wU, 0)
var Mwt = class extends dt {
    constructor(i, t = []) {
      super(),
        (this.a = new Kct([i, ...t])),
        this.D(i.onDidChangeLogLevel((e) => this.setLevel(e)))
    }
    get onDidChangeLogLevel() {
      return this.a.onDidChangeLogLevel
    }
    setLevel(i) {
      this.a.setLevel(i)
    }
    getLevel() {
      return this.a.getLevel()
    }
    trace(i, ...t) {
      this.a.trace(i, ...t)
    }
    debug(i, ...t) {
      this.a.debug(i, ...t)
    }
    info(i, ...t) {
      this.a.info(i, ...t)
    }
    warn(i, ...t) {
      this.a.warn(i, ...t)
    }
    error(i, ...t) {
      this.a.error(i, ...t)
    }
    flush() {
      this.a.flush()
    }
  },
  yU = class extends Mwt {
    constructor(t, e, r) {
      const s = r.remote.isRemote
          ? "remoteexthost"
          : t
            ? "workerexthost"
            : "exthost",
        a = r.remote.isRemote ? f(2763, null) : f(t ? 2764 : 2765, null)
      super(e.createLogger(s, { name: a }))
    }
  }
yU = __decorate([__param(1, Hu), __param(2, ci)], yU)
var ZK = {
    tabSize: 4,
    indentSize: 4,
    insertSpaces: !0,
    detectIndentation: !0,
    trimAutoWhitespace: !0,
    largeFileOptimizations: !0,
    bracketPairColorizationOptions: {
      enabled: !0,
      independentColorPoolPerBracketType: !1,
    },
  },
  tZ
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Keep = 1)] = "Keep"),
    (i[(i.Brackets = 2)] = "Brackets"),
    (i[(i.Advanced = 3)] = "Advanced"),
    (i[(i.Full = 4)] = "Full")
})(tZ || (tZ = {}))
var Hwt = 8,
  Wwt = class {
    constructor() {
      ;(this.stableMinimapLayoutInput = null),
        (this.stableFitMaxMinimapScale = 0),
        (this.stableFitRemainingWidth = 0)
    }
  },
  ee = class {
    constructor(i, t, e, r) {
      ;(this.id = i),
        (this.name = t),
        (this.defaultValue = e),
        (this.schema = r)
    }
    applyUpdate(i, t) {
      return D7(i, t)
    }
    compute(i, t, e) {
      return e
    }
  },
  R7 = class {
    constructor(i, t) {
      ;(this.newValue = i), (this.didChange = t)
    }
  }
function D7(i, t) {
  if (typeof i != "object" || typeof t != "object" || !i || !t)
    return new R7(t, i !== t)
  if (Array.isArray(i) || Array.isArray(t)) {
    const r = Array.isArray(i) && Array.isArray(t) && fn(i, t)
    return new R7(t, !r)
  }
  let e = !1
  for (const r in t)
    if (t.hasOwnProperty(r)) {
      const s = D7(i[r], t[r])
      s.didChange && ((i[r] = s.newValue), (e = !0))
    }
  return new R7(i, e)
}
var Jc = class {
    constructor(i) {
      ;(this.schema = void 0),
        (this.id = i),
        (this.name = "_never_"),
        (this.defaultValue = void 0)
    }
    applyUpdate(i, t) {
      return D7(i, t)
    }
    validate(i) {
      return this.defaultValue
    }
  },
  Cc = class {
    constructor(i, t, e, r) {
      ;(this.id = i),
        (this.name = t),
        (this.defaultValue = e),
        (this.schema = r)
    }
    applyUpdate(i, t) {
      return D7(i, t)
    }
    validate(i) {
      return typeof i > "u" ? this.defaultValue : i
    }
    compute(i, t, e) {
      return e
    }
  }
function K(i, t) {
  return typeof i > "u" ? t : i === "false" ? !1 : !!i
}
var kt = class extends Cc {
  constructor(i, t, e, r = void 0) {
    typeof r < "u" && ((r.type = "boolean"), (r.default = e)), super(i, t, e, r)
  }
  validate(i) {
    return K(i, this.defaultValue)
  }
}
function jwt(i, t, e, r) {
  if (typeof i > "u") return t
  let s = parseInt(i, 10)
  return isNaN(s) ? t : ((s = Math.max(e, s)), (s = Math.min(r, s)), s | 0)
}
var Wt = class Znt extends Cc {
    static clampedInt(t, e, r, s) {
      return jwt(t, e, r, s)
    }
    constructor(t, e, r, s, a, o = void 0) {
      typeof o < "u" &&
        ((o.type = "integer"),
        (o.default = r),
        (o.minimum = s),
        (o.maximum = a)),
        super(t, e, r, o),
        (this.minimum = s),
        (this.maximum = a)
    }
    validate(t) {
      return Znt.clampedInt(t, this.defaultValue, this.minimum, this.maximum)
    }
  },
  un = class tst extends Cc {
    static clamp(t, e, r) {
      return t < e ? e : t > r ? r : t
    }
    static float(t, e) {
      if (typeof t == "number") return t
      if (typeof t > "u") return e
      const r = parseFloat(t)
      return isNaN(r) ? e : r
    }
    constructor(t, e, r, s, a) {
      typeof a < "u" && ((a.type = "number"), (a.default = r)),
        super(t, e, r, a),
        (this.validationFn = s)
    }
    validate(t) {
      return this.validationFn(tst.float(t, this.defaultValue))
    }
  },
  _i = class est extends Cc {
    static string(t, e) {
      return typeof t != "string" ? e : t
    }
    constructor(t, e, r, s = void 0) {
      typeof s < "u" && ((s.type = "string"), (s.default = r)),
        super(t, e, r, s)
    }
    validate(t) {
      return est.string(t, this.defaultValue)
    }
  }
function ue(i, t, e, r) {
  return typeof i != "string"
    ? t
    : r && i in r
      ? r[i]
      : e.indexOf(i) === -1
        ? t
        : i
}
var ne = class extends Cc {
    constructor(i, t, e, r, s = void 0) {
      typeof s < "u" && ((s.type = "string"), (s.enum = r), (s.default = e)),
        super(i, t, e, s),
        (this.c = r)
    }
    validate(i) {
      return ue(i, this.defaultValue, this.c)
    }
  },
  Qd = class extends ee {
    constructor(i, t, e, r, s, a, o = void 0) {
      typeof o < "u" && ((o.type = "string"), (o.enum = s), (o.default = r)),
        super(i, t, e, o),
        (this.c = s),
        (this.d = a)
    }
    validate(i) {
      return typeof i != "string"
        ? this.defaultValue
        : this.c.indexOf(i) === -1
          ? this.defaultValue
          : this.d(i)
    }
  }
function Vwt(i) {
  switch (i) {
    case "none":
      return 0
    case "keep":
      return 1
    case "brackets":
      return 2
    case "advanced":
      return 3
    case "full":
      return 4
  }
}
var Gwt = class extends ee {
    constructor() {
      super(2, "accessibilitySupport", 0, {
        type: "string",
        enum: ["auto", "on", "off"],
        enumDescriptions: [f(309, null), f(310, null), f(311, null)],
        default: "auto",
        tags: ["accessibility"],
        description: f(312, null),
      })
    }
    validate(i) {
      switch (i) {
        case "auto":
          return 0
        case "off":
          return 1
        case "on":
          return 2
      }
      return this.defaultValue
    }
    compute(i, t, e) {
      return e === 0 ? i.accessibilitySupport : e
    }
  },
  zwt = class extends ee {
    constructor() {
      const i = { insertSpace: !0, ignoreEmptyLines: !0 }
      super(23, "comments", i, {
        "editor.comments.insertSpace": {
          type: "boolean",
          default: i.insertSpace,
          description: f(313, null),
        },
        "editor.comments.ignoreEmptyLines": {
          type: "boolean",
          default: i.ignoreEmptyLines,
          description: f(314, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        insertSpace: K(t.insertSpace, this.defaultValue.insertSpace),
        ignoreEmptyLines: K(
          t.ignoreEmptyLines,
          this.defaultValue.ignoreEmptyLines,
        ),
      }
    }
  },
  eZ
;(function (i) {
  ;(i[(i.Hidden = 0)] = "Hidden"),
    (i[(i.Blink = 1)] = "Blink"),
    (i[(i.Smooth = 2)] = "Smooth"),
    (i[(i.Phase = 3)] = "Phase"),
    (i[(i.Expand = 4)] = "Expand"),
    (i[(i.Solid = 5)] = "Solid")
})(eZ || (eZ = {}))
function Ywt(i) {
  switch (i) {
    case "blink":
      return 1
    case "smooth":
      return 2
    case "phase":
      return 3
    case "expand":
      return 4
    case "solid":
      return 5
  }
}
var _r
;(function (i) {
  ;(i[(i.Line = 1)] = "Line"),
    (i[(i.Block = 2)] = "Block"),
    (i[(i.Underline = 3)] = "Underline"),
    (i[(i.LineThin = 4)] = "LineThin"),
    (i[(i.BlockOutline = 5)] = "BlockOutline"),
    (i[(i.UnderlineThin = 6)] = "UnderlineThin")
})(_r || (_r = {}))
function iZ(i) {
  switch (i) {
    case "line":
      return _r.Line
    case "block":
      return _r.Block
    case "underline":
      return _r.Underline
    case "line-thin":
      return _r.LineThin
    case "block-outline":
      return _r.BlockOutline
    case "underline-thin":
      return _r.UnderlineThin
  }
}
var Qwt = class extends Jc {
    constructor() {
      super(148)
    }
    compute(i, t, e) {
      const r = ["monaco-editor"]
      return (
        t.get(41) && r.push(t.get(41)),
        i.extraEditorClassName && r.push(i.extraEditorClassName),
        t.get(75) === "default"
          ? r.push("mouse-default")
          : t.get(75) === "copy" && r.push("mouse-copy"),
        t.get(116) && r.push("showUnused"),
        t.get(145) && r.push("showDeprecated"),
        r.join(" ")
      )
    }
  },
  Xwt = class extends kt {
    constructor() {
      super(38, "emptySelectionClipboard", !0, { description: f(315, null) })
    }
    compute(i, t, e) {
      return e && i.emptySelectionClipboard
    }
  },
  Kwt = class extends ee {
    constructor() {
      const i = {
        cursorMoveOnType: !0,
        seedSearchStringFromSelection: "always",
        autoFindInSelection: "never",
        globalFindClipboard: !1,
        addExtraSpaceOnTop: !0,
        loop: !0,
        history: "workspace",
      }
      super(43, "find", i, {
        "editor.find.cursorMoveOnType": {
          type: "boolean",
          default: i.cursorMoveOnType,
          description: f(316, null),
        },
        "editor.find.seedSearchStringFromSelection": {
          type: "string",
          enum: ["never", "always", "selection"],
          default: i.seedSearchStringFromSelection,
          enumDescriptions: [f(317, null), f(318, null), f(319, null)],
          description: f(320, null),
        },
        "editor.find.autoFindInSelection": {
          type: "string",
          enum: ["never", "always", "multiline"],
          default: i.autoFindInSelection,
          enumDescriptions: [f(321, null), f(322, null), f(323, null)],
          description: f(324, null),
        },
        "editor.find.globalFindClipboard": {
          type: "boolean",
          default: i.globalFindClipboard,
          description: f(325, null),
          included: Tr,
        },
        "editor.find.addExtraSpaceOnTop": {
          type: "boolean",
          default: i.addExtraSpaceOnTop,
          description: f(326, null),
        },
        "editor.find.loop": {
          type: "boolean",
          default: i.loop,
          description: f(327, null),
        },
        "editor.find.history": {
          type: "string",
          enum: ["never", "workspace"],
          default: "workspace",
          enumDescriptions: [f(328, null), f(329, null)],
          description: f(330, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        cursorMoveOnType: K(
          t.cursorMoveOnType,
          this.defaultValue.cursorMoveOnType,
        ),
        seedSearchStringFromSelection:
          typeof i.seedSearchStringFromSelection == "boolean"
            ? i.seedSearchStringFromSelection
              ? "always"
              : "never"
            : ue(
                t.seedSearchStringFromSelection,
                this.defaultValue.seedSearchStringFromSelection,
                ["never", "always", "selection"],
              ),
        autoFindInSelection:
          typeof i.autoFindInSelection == "boolean"
            ? i.autoFindInSelection
              ? "always"
              : "never"
            : ue(t.autoFindInSelection, this.defaultValue.autoFindInSelection, [
                "never",
                "always",
                "multiline",
              ]),
        globalFindClipboard: K(
          t.globalFindClipboard,
          this.defaultValue.globalFindClipboard,
        ),
        addExtraSpaceOnTop: K(
          t.addExtraSpaceOnTop,
          this.defaultValue.addExtraSpaceOnTop,
        ),
        loop: K(t.loop, this.defaultValue.loop),
        history: ue(t.history, this.defaultValue.history, [
          "never",
          "workspace",
        ]),
      }
    }
  },
  Zwt = class cu extends ee {
    static {
      this.OFF = '"liga" off, "calt" off'
    }
    static {
      this.ON = '"liga" on, "calt" on'
    }
    constructor() {
      super(53, "fontLigatures", cu.OFF, {
        anyOf: [
          { type: "boolean", description: f(331, null) },
          { type: "string", description: f(332, null) },
        ],
        description: f(333, null),
        default: !1,
      })
    }
    validate(t) {
      return typeof t > "u"
        ? this.defaultValue
        : typeof t == "string"
          ? t === "false" || t.length === 0
            ? cu.OFF
            : t === "true"
              ? cu.ON
              : t
          : t
            ? cu.ON
            : cu.OFF
    }
  },
  tyt = class uu extends ee {
    static {
      this.OFF = "normal"
    }
    static {
      this.TRANSLATE = "translate"
    }
    constructor() {
      super(56, "fontVariations", uu.OFF, {
        anyOf: [
          { type: "boolean", description: f(334, null) },
          { type: "string", description: f(335, null) },
        ],
        description: f(336, null),
        default: !1,
      })
    }
    validate(t) {
      return typeof t > "u"
        ? this.defaultValue
        : typeof t == "string"
          ? t === "false"
            ? uu.OFF
            : t === "true"
              ? uu.TRANSLATE
              : t
          : t
            ? uu.TRANSLATE
            : uu.OFF
    }
    compute(t, e, r) {
      return t.fontInfo.fontVariationSettings
    }
  },
  eyt = class extends Jc {
    constructor() {
      super(52)
    }
    compute(i, t, e) {
      return i.fontInfo
    }
  },
  iyt = class extends Jc {
    constructor() {
      super(147)
    }
    compute(i, t, e) {
      return i.inputMode === "overtype" ? t.get(84) : t.get(28)
    }
  },
  ryt = class extends Cc {
    constructor() {
      super(54, "fontSize", qn.fontSize, {
        type: "number",
        minimum: 6,
        maximum: 100,
        default: qn.fontSize,
        description: f(337, null),
      })
    }
    validate(i) {
      const t = un.float(i, this.defaultValue)
      return t === 0 ? qn.fontSize : un.clamp(t, 6, 100)
    }
    compute(i, t, e) {
      return i.fontInfo.fontSize
    }
  },
  nyt = class lu extends ee {
    static {
      this.c = [
        "normal",
        "bold",
        "100",
        "200",
        "300",
        "400",
        "500",
        "600",
        "700",
        "800",
        "900",
      ]
    }
    static {
      this.d = 1
    }
    static {
      this.e = 1e3
    }
    constructor() {
      super(55, "fontWeight", qn.fontWeight, {
        anyOf: [
          {
            type: "number",
            minimum: lu.d,
            maximum: lu.e,
            errorMessage: f(338, null),
          },
          { type: "string", pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$" },
          { enum: lu.c },
        ],
        default: qn.fontWeight,
        description: f(339, null),
      })
    }
    validate(t) {
      return t === "normal" || t === "bold"
        ? t
        : String(Wt.clampedInt(t, qn.fontWeight, lu.d, lu.e))
    }
  },
  syt = class extends ee {
    constructor() {
      const i = {
          multiple: "peek",
          multipleDefinitions: "peek",
          multipleTypeDefinitions: "peek",
          multipleDeclarations: "peek",
          multipleImplementations: "peek",
          multipleReferences: "peek",
          multipleTests: "peek",
          alternativeDefinitionCommand: "editor.action.goToReferences",
          alternativeTypeDefinitionCommand: "editor.action.goToReferences",
          alternativeDeclarationCommand: "editor.action.goToReferences",
          alternativeImplementationCommand: "",
          alternativeReferenceCommand: "",
          alternativeTestsCommand: "",
        },
        t = {
          type: "string",
          enum: ["peek", "gotoAndPeek", "goto"],
          default: i.multiple,
          enumDescriptions: [f(340, null), f(341, null), f(342, null)],
        },
        e = [
          "",
          "editor.action.referenceSearch.trigger",
          "editor.action.goToReferences",
          "editor.action.peekImplementation",
          "editor.action.goToImplementation",
          "editor.action.peekTypeDefinition",
          "editor.action.goToTypeDefinition",
          "editor.action.explainSymbol",
          "editor.action.peekDeclaration",
          "editor.action.revealDeclaration",
          "editor.action.peekDefinition",
          "editor.action.revealDefinitionAside",
          "editor.action.revealDefinition",
        ]
      super(60, "gotoLocation", i, {
        "editor.gotoLocation.multiple": { deprecationMessage: f(343, null) },
        "editor.gotoLocation.multipleDefinitions": {
          description: f(344, null),
          ...t,
        },
        "editor.gotoLocation.multipleTypeDefinitions": {
          description: f(345, null),
          ...t,
        },
        "editor.gotoLocation.multipleDeclarations": {
          description: f(346, null),
          ...t,
        },
        "editor.gotoLocation.multipleImplementations": {
          description: f(347, null),
          ...t,
        },
        "editor.gotoLocation.multipleReferences": {
          description: f(348, null),
          ...t,
        },
        "editor.gotoLocation.alternativeDefinitionCommand": {
          type: "string",
          default: i.alternativeDefinitionCommand,
          enum: e,
          description: f(349, null),
        },
        "editor.gotoLocation.alternativeTypeDefinitionCommand": {
          type: "string",
          default: i.alternativeTypeDefinitionCommand,
          enum: e,
          description: f(350, null),
        },
        "editor.gotoLocation.alternativeDeclarationCommand": {
          type: "string",
          default: i.alternativeDeclarationCommand,
          enum: e,
          description: f(351, null),
        },
        "editor.gotoLocation.alternativeImplementationCommand": {
          type: "string",
          default: i.alternativeImplementationCommand,
          enum: e,
          description: f(352, null),
        },
        "editor.gotoLocation.alternativeReferenceCommand": {
          type: "string",
          default: i.alternativeReferenceCommand,
          enum: e,
          description: f(353, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        multiple: ue(t.multiple, this.defaultValue.multiple, [
          "peek",
          "gotoAndPeek",
          "goto",
        ]),
        multipleDefinitions:
          t.multipleDefinitions ??
          ue(t.multipleDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
        multipleTypeDefinitions:
          t.multipleTypeDefinitions ??
          ue(t.multipleTypeDefinitions, "peek", [
            "peek",
            "gotoAndPeek",
            "goto",
          ]),
        multipleDeclarations:
          t.multipleDeclarations ??
          ue(t.multipleDeclarations, "peek", ["peek", "gotoAndPeek", "goto"]),
        multipleImplementations:
          t.multipleImplementations ??
          ue(t.multipleImplementations, "peek", [
            "peek",
            "gotoAndPeek",
            "goto",
          ]),
        multipleReferences:
          t.multipleReferences ??
          ue(t.multipleReferences, "peek", ["peek", "gotoAndPeek", "goto"]),
        multipleTests:
          t.multipleTests ??
          ue(t.multipleTests, "peek", ["peek", "gotoAndPeek", "goto"]),
        alternativeDefinitionCommand: _i.string(
          t.alternativeDefinitionCommand,
          this.defaultValue.alternativeDefinitionCommand,
        ),
        alternativeTypeDefinitionCommand: _i.string(
          t.alternativeTypeDefinitionCommand,
          this.defaultValue.alternativeTypeDefinitionCommand,
        ),
        alternativeDeclarationCommand: _i.string(
          t.alternativeDeclarationCommand,
          this.defaultValue.alternativeDeclarationCommand,
        ),
        alternativeImplementationCommand: _i.string(
          t.alternativeImplementationCommand,
          this.defaultValue.alternativeImplementationCommand,
        ),
        alternativeReferenceCommand: _i.string(
          t.alternativeReferenceCommand,
          this.defaultValue.alternativeReferenceCommand,
        ),
        alternativeTestsCommand: _i.string(
          t.alternativeTestsCommand,
          this.defaultValue.alternativeTestsCommand,
        ),
      }
    }
  },
  ayt = class extends ee {
    constructor() {
      const i = {
        enabled: !0,
        delay: 300,
        hidingDelay: 300,
        sticky: !0,
        above: !0,
      }
      super(62, "hover", i, {
        "editor.hover.enabled": {
          type: "boolean",
          default: i.enabled,
          description: f(354, null),
        },
        "editor.hover.delay": {
          type: "number",
          default: i.delay,
          minimum: 0,
          maximum: 1e4,
          description: f(355, null),
        },
        "editor.hover.sticky": {
          type: "boolean",
          default: i.sticky,
          description: f(356, null),
        },
        "editor.hover.hidingDelay": {
          type: "integer",
          minimum: 0,
          default: i.hidingDelay,
          description: f(357, null),
        },
        "editor.hover.above": {
          type: "boolean",
          default: i.above,
          description: f(358, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        enabled: K(t.enabled, this.defaultValue.enabled),
        delay: Wt.clampedInt(t.delay, this.defaultValue.delay, 0, 1e4),
        sticky: K(t.sticky, this.defaultValue.sticky),
        hidingDelay: Wt.clampedInt(
          t.hidingDelay,
          this.defaultValue.hidingDelay,
          0,
          6e5,
        ),
        above: K(t.above, this.defaultValue.above),
      }
    }
  },
  rZ
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Text = 1)] = "Text"),
    (i[(i.Blocks = 2)] = "Blocks")
})(rZ || (rZ = {}))
var oyt = class G8 extends Jc {
    constructor() {
      super(151)
    }
    compute(t, e, r) {
      return G8.computeLayout(e, {
        memory: t.memory,
        outerWidth: t.outerWidth,
        outerHeight: t.outerHeight,
        isDominatedByLongLines: t.isDominatedByLongLines,
        lineHeight: t.fontInfo.lineHeight,
        viewLineCount: t.viewLineCount,
        lineNumbersDigitCount: t.lineNumbersDigitCount,
        typicalHalfwidthCharacterWidth:
          t.fontInfo.typicalHalfwidthCharacterWidth,
        maxDigitWidth: t.fontInfo.maxDigitWidth,
        pixelRatio: t.pixelRatio,
        glyphMarginDecorationLaneCount: t.glyphMarginDecorationLaneCount,
      })
    }
    static computeContainedMinimapLineCount(t) {
      const e = t.height / t.lineHeight,
        r = Math.floor(t.paddingTop / t.lineHeight)
      let s = Math.floor(t.paddingBottom / t.lineHeight)
      t.scrollBeyondLastLine && (s = Math.max(s, e - 1))
      const a = (r + t.viewLineCount + s) / (t.pixelRatio * t.height),
        o = Math.floor(t.viewLineCount / a)
      return {
        typicalViewportLineCount: e,
        extraLinesBeforeFirstLine: r,
        extraLinesBeyondLastLine: s,
        desiredRatio: a,
        minimapLineCount: o,
      }
    }
    static c(t, e) {
      const r = t.outerWidth,
        s = t.outerHeight,
        a = t.pixelRatio
      if (!t.minimap.enabled)
        return {
          renderMinimap: 0,
          minimapLeft: 0,
          minimapWidth: 0,
          minimapHeightIsEditorHeight: !1,
          minimapIsSampling: !1,
          minimapScale: 1,
          minimapLineHeight: 1,
          minimapCanvasInnerWidth: 0,
          minimapCanvasInnerHeight: Math.floor(a * s),
          minimapCanvasOuterWidth: 0,
          minimapCanvasOuterHeight: s,
        }
      const o = e.stableMinimapLayoutInput,
        c =
          o &&
          t.outerHeight === o.outerHeight &&
          t.lineHeight === o.lineHeight &&
          t.typicalHalfwidthCharacterWidth ===
            o.typicalHalfwidthCharacterWidth &&
          t.pixelRatio === o.pixelRatio &&
          t.scrollBeyondLastLine === o.scrollBeyondLastLine &&
          t.paddingTop === o.paddingTop &&
          t.paddingBottom === o.paddingBottom &&
          t.minimap.enabled === o.minimap.enabled &&
          t.minimap.side === o.minimap.side &&
          t.minimap.size === o.minimap.size &&
          t.minimap.showSlider === o.minimap.showSlider &&
          t.minimap.renderCharacters === o.minimap.renderCharacters &&
          t.minimap.maxColumn === o.minimap.maxColumn &&
          t.minimap.scale === o.minimap.scale &&
          t.verticalScrollbarWidth === o.verticalScrollbarWidth &&
          t.isViewportWrapping === o.isViewportWrapping,
        u = t.lineHeight,
        l = t.typicalHalfwidthCharacterWidth,
        m = t.scrollBeyondLastLine,
        h = t.minimap.renderCharacters
      let p = a >= 2 ? Math.round(t.minimap.scale * 2) : t.minimap.scale
      const g = t.minimap.maxColumn,
        w = t.minimap.size,
        T = t.minimap.side,
        b = t.verticalScrollbarWidth,
        N = t.viewLineCount,
        $ = t.remainingWidth,
        L = t.isViewportWrapping,
        U = h ? 2 : 3
      let q = Math.floor(a * s)
      const V = q / a
      let lt = !1,
        at = !1,
        et = U * p,
        wt = p / a,
        zt = 1
      if (w === "fill" || w === "fit") {
        const {
          typicalViewportLineCount: Z,
          extraLinesBeforeFirstLine: St,
          extraLinesBeyondLastLine: Dt,
          desiredRatio: Pt,
          minimapLineCount: ie,
        } = G8.computeContainedMinimapLineCount({
          viewLineCount: N,
          scrollBeyondLastLine: m,
          paddingTop: t.paddingTop,
          paddingBottom: t.paddingBottom,
          height: s,
          lineHeight: u,
          pixelRatio: a,
        })
        if (N / ie > 1) (lt = !0), (at = !0), (p = 1), (et = 1), (wt = p / a)
        else {
          let Te = !1,
            si = p + 1
          if (w === "fit") {
            const wi = Math.ceil((St + N + Dt) * et)
            L && c && $ <= e.stableFitRemainingWidth
              ? ((Te = !0), (si = e.stableFitMaxMinimapScale))
              : (Te = wi > q)
          }
          if (w === "fill" || Te) {
            lt = !0
            const wi = p
            ;(et = Math.min(u * a, Math.max(1, Math.floor(1 / Pt)))),
              L &&
                c &&
                $ <= e.stableFitRemainingWidth &&
                (si = e.stableFitMaxMinimapScale),
              (p = Math.min(si, Math.max(1, Math.floor(et / U)))),
              p > wi && (zt = Math.min(2, p / wi)),
              (wt = p / a / zt),
              (q = Math.ceil(Math.max(Z, St + N + Dt) * et)),
              L
                ? ((e.stableMinimapLayoutInput = t),
                  (e.stableFitRemainingWidth = $),
                  (e.stableFitMaxMinimapScale = p))
                : ((e.stableMinimapLayoutInput = null),
                  (e.stableFitRemainingWidth = 0))
          }
        }
      }
      const Ct = Math.floor(g * wt),
        be = Math.min(
          Ct,
          Math.max(0, Math.floor((($ - b - 2) * wt) / (l + wt))) + Hwt,
        )
      let G = Math.floor(a * be)
      const W = G / a
      G = Math.floor(G * zt)
      const tt = h ? 1 : 2,
        X = T === "left" ? 0 : r - be - b
      return {
        renderMinimap: tt,
        minimapLeft: X,
        minimapWidth: be,
        minimapHeightIsEditorHeight: lt,
        minimapIsSampling: at,
        minimapScale: p,
        minimapLineHeight: et,
        minimapCanvasInnerWidth: G,
        minimapCanvasInnerHeight: q,
        minimapCanvasOuterWidth: W,
        minimapCanvasOuterHeight: V,
      }
    }
    static computeLayout(t, e) {
      const r = e.outerWidth | 0,
        s = e.outerHeight | 0,
        a = e.lineHeight | 0,
        o = e.lineNumbersDigitCount | 0,
        c = e.typicalHalfwidthCharacterWidth,
        u = e.maxDigitWidth,
        l = e.pixelRatio,
        m = e.viewLineCount,
        h = t.get(142),
        p = h === "inherit" ? t.get(141) : h,
        g = p === "inherit" ? t.get(137) : p,
        w = t.get(140),
        T = e.isDominatedByLongLines,
        b = t.get(59),
        N = t.get(69).renderType !== 0,
        $ = t.get(70),
        L = t.get(110),
        U = t.get(88),
        q = t.get(74),
        V = t.get(108),
        lt = V.verticalScrollbarSize,
        at = V.verticalHasArrows,
        et = V.arrowSize,
        wt = V.horizontalScrollbarSize,
        zt = t.get(45),
        Ct = t.get(115) !== "never"
      let be = t.get(67)
      zt && Ct && (be += 16)
      let G = 0
      if (N) {
        const mn = Math.max(o, $)
        G = Math.round(mn * u)
      }
      let W = 0
      b && (W = a * e.glyphMarginDecorationLaneCount)
      let tt = 0,
        X = tt + W,
        Z = X + G,
        St = Z + be
      const Dt = r - W - G - be
      let Pt = !1,
        ie = !1,
        Ze = -1
      p === "inherit" && T
        ? ((Pt = !0), (ie = !0))
        : g === "on" || g === "bounded"
          ? (ie = !0)
          : g === "wordWrapColumn" && (Ze = w)
      const Te = G8.c(
        {
          outerWidth: r,
          outerHeight: s,
          lineHeight: a,
          typicalHalfwidthCharacterWidth: c,
          pixelRatio: l,
          scrollBeyondLastLine: L,
          paddingTop: U.top,
          paddingBottom: U.bottom,
          minimap: q,
          verticalScrollbarWidth: lt,
          viewLineCount: m,
          remainingWidth: Dt,
          isViewportWrapping: ie,
        },
        e.memory || new Wwt(),
      )
      Te.renderMinimap !== 0 &&
        Te.minimapLeft === 0 &&
        ((tt += Te.minimapWidth),
        (X += Te.minimapWidth),
        (Z += Te.minimapWidth),
        (St += Te.minimapWidth))
      const si = Dt - Te.minimapWidth,
        wi = Math.max(1, Math.floor((si - lt - 2) / c)),
        le = at ? et : 0
      return (
        ie &&
          ((Ze = Math.max(1, wi)), g === "bounded" && (Ze = Math.min(Ze, w))),
        {
          width: r,
          height: s,
          glyphMarginLeft: tt,
          glyphMarginWidth: W,
          glyphMarginDecorationLaneCount: e.glyphMarginDecorationLaneCount,
          lineNumbersLeft: X,
          lineNumbersWidth: G,
          decorationsLeft: Z,
          decorationsWidth: be,
          contentLeft: St,
          contentWidth: si,
          minimap: Te,
          viewportColumn: wi,
          isWordWrapMinified: Pt,
          isViewportWrapping: ie,
          wrappingColumn: Ze,
          verticalScrollbarWidth: lt,
          horizontalScrollbarHeight: wt,
          overviewRuler: { top: le, width: lt, height: s - 2 * le, right: 0 },
        }
      )
    }
  },
  cyt = class extends ee {
    constructor() {
      super(144, "wrappingStrategy", "simple", {
        "editor.wrappingStrategy": {
          enumDescriptions: [f(359, null), f(360, null)],
          type: "string",
          enum: ["simple", "advanced"],
          default: "simple",
          description: f(361, null),
        },
      })
    }
    validate(i) {
      return ue(i, "simple", ["simple", "advanced"])
    }
    compute(i, t, e) {
      return t.get(2) === 2 ? "advanced" : e
    }
  },
  On
;(function (i) {
  ;(i.Off = "off"), (i.OnCode = "onCode"), (i.On = "on")
})(On || (On = {}))
var uyt = class extends ee {
    constructor() {
      const i = { enabled: On.Off }
      super(66, "lightbulb", i, {
        "editor.lightbulb.enabled": {
          type: "string",
          enum: [On.Off, On.OnCode, On.On],
          default: i.enabled,
          enumDescriptions: [f(362, null), f(363, null), f(364, null)],
          description: f(365, null),
        },
      })
    }
    validate(i) {
      return !i || typeof i != "object"
        ? this.defaultValue
        : {
            enabled: ue(i.enabled, this.defaultValue.enabled, [
              On.Off,
              On.OnCode,
              On.On,
            ]),
          }
    }
  },
  lyt = class extends ee {
    constructor() {
      const i = {
        enabled: !0,
        maxLineCount: 5,
        defaultModel: "outlineModel",
        scrollWithEditor: !0,
      }
      super(120, "stickyScroll", i, {
        "editor.stickyScroll.enabled": {
          type: "boolean",
          default: i.enabled,
          description: f(366, null),
        },
        "editor.stickyScroll.maxLineCount": {
          type: "number",
          default: i.maxLineCount,
          minimum: 1,
          maximum: 20,
          description: f(367, null),
        },
        "editor.stickyScroll.defaultModel": {
          type: "string",
          enum: ["outlineModel", "foldingProviderModel", "indentationModel"],
          default: i.defaultModel,
          description: f(368, null),
        },
        "editor.stickyScroll.scrollWithEditor": {
          type: "boolean",
          default: i.scrollWithEditor,
          description: f(369, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        enabled: K(t.enabled, this.defaultValue.enabled),
        maxLineCount: Wt.clampedInt(
          t.maxLineCount,
          this.defaultValue.maxLineCount,
          1,
          20,
        ),
        defaultModel: ue(t.defaultModel, this.defaultValue.defaultModel, [
          "outlineModel",
          "foldingProviderModel",
          "indentationModel",
        ]),
        scrollWithEditor: K(
          t.scrollWithEditor,
          this.defaultValue.scrollWithEditor,
        ),
      }
    }
  },
  dyt = class extends ee {
    constructor() {
      const i = {
        enabled: "on",
        fontSize: 0,
        fontFamily: "",
        padding: !1,
        maximumLength: 43,
      }
      super(146, "inlayHints", i, {
        "editor.inlayHints.enabled": {
          type: "string",
          default: i.enabled,
          description: f(370, null),
          enum: ["on", "onUnlessPressed", "offUnlessPressed", "off"],
          markdownEnumDescriptions: [
            f(371, null),
            f(372, null, Tr ? "Ctrl+Option" : "Ctrl+Alt"),
            f(373, null, Tr ? "Ctrl+Option" : "Ctrl+Alt"),
            f(374, null),
          ],
        },
        "editor.inlayHints.fontSize": {
          type: "number",
          default: i.fontSize,
          markdownDescription: f(375, null, "`#editor.fontSize#`", "`5`"),
        },
        "editor.inlayHints.fontFamily": {
          type: "string",
          default: i.fontFamily,
          markdownDescription: f(376, null, "`#editor.fontFamily#`"),
        },
        "editor.inlayHints.padding": {
          type: "boolean",
          default: i.padding,
          description: f(377, null),
        },
        "editor.inlayHints.maximumLength": {
          type: "number",
          default: i.maximumLength,
          markdownDescription: f(378, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return (
        typeof t.enabled == "boolean" && (t.enabled = t.enabled ? "on" : "off"),
        {
          enabled: ue(t.enabled, this.defaultValue.enabled, [
            "on",
            "off",
            "offUnlessPressed",
            "onUnlessPressed",
          ]),
          fontSize: Wt.clampedInt(
            t.fontSize,
            this.defaultValue.fontSize,
            0,
            100,
          ),
          fontFamily: _i.string(t.fontFamily, this.defaultValue.fontFamily),
          padding: K(t.padding, this.defaultValue.padding),
          maximumLength: Wt.clampedInt(
            t.maximumLength,
            this.defaultValue.maximumLength,
            0,
            Number.MAX_SAFE_INTEGER,
          ),
        }
      )
    }
  },
  myt = class extends ee {
    constructor() {
      super(67, "lineDecorationsWidth", 10)
    }
    validate(i) {
      return typeof i == "string" && /^\d+(\.\d+)?ch$/.test(i)
        ? -parseFloat(i.substring(0, i.length - 2))
        : Wt.clampedInt(i, this.defaultValue, 0, 1e3)
    }
    compute(i, t, e) {
      return e < 0
        ? Wt.clampedInt(
            -e * i.fontInfo.typicalHalfwidthCharacterWidth,
            this.defaultValue,
            0,
            1e3,
          )
        : e
    }
  },
  hyt = class extends un {
    constructor() {
      super(68, "lineHeight", qn.lineHeight, (i) => un.clamp(i, 0, 150), {
        markdownDescription: f(379, null),
      })
    }
    compute(i, t, e) {
      return i.fontInfo.lineHeight
    }
  },
  fyt = class extends ee {
    constructor() {
      const i = {
        enabled: !1,
        size: "proportional",
        side: "right",
        showSlider: "mouseover",
        autohide: !1,
        renderCharacters: !0,
        maxColumn: 120,
        scale: 1,
        showRegionSectionHeaders: !0,
        showMarkSectionHeaders: !0,
        sectionHeaderFontSize: 9,
        sectionHeaderLetterSpacing: 1,
      }
      super(74, "minimap", i, {
        "editor.minimap.enabled": {
          type: "boolean",
          default: i.enabled,
          description: f(380, null),
        },
        "editor.minimap.autohide": {
          type: "boolean",
          default: i.autohide,
          description: f(381, null),
        },
        "editor.minimap.size": {
          type: "string",
          enum: ["proportional", "fill", "fit"],
          enumDescriptions: [f(382, null), f(383, null), f(384, null)],
          default: i.size,
          description: f(385, null),
        },
        "editor.minimap.side": {
          type: "string",
          enum: ["left", "right"],
          default: i.side,
          description: f(386, null),
        },
        "editor.minimap.showSlider": {
          type: "string",
          enum: ["always", "mouseover"],
          default: i.showSlider,
          description: f(387, null),
        },
        "editor.minimap.scale": {
          type: "number",
          default: i.scale,
          minimum: 1,
          maximum: 3,
          enum: [1, 2, 3],
          description: f(388, null),
        },
        "editor.minimap.renderCharacters": {
          type: "boolean",
          default: i.renderCharacters,
          description: f(389, null),
        },
        "editor.minimap.maxColumn": {
          type: "number",
          default: i.maxColumn,
          description: f(390, null),
        },
        "editor.minimap.showRegionSectionHeaders": {
          type: "boolean",
          default: i.showRegionSectionHeaders,
          description: f(391, null),
        },
        "editor.minimap.showMarkSectionHeaders": {
          type: "boolean",
          default: i.showMarkSectionHeaders,
          description: f(392, null),
        },
        "editor.minimap.sectionHeaderFontSize": {
          type: "number",
          default: i.sectionHeaderFontSize,
          description: f(393, null),
        },
        "editor.minimap.sectionHeaderLetterSpacing": {
          type: "number",
          default: i.sectionHeaderLetterSpacing,
          description: f(394, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        enabled: K(t.enabled, this.defaultValue.enabled),
        autohide: K(t.autohide, this.defaultValue.autohide),
        size: ue(t.size, this.defaultValue.size, [
          "proportional",
          "fill",
          "fit",
        ]),
        side: ue(t.side, this.defaultValue.side, ["right", "left"]),
        showSlider: ue(t.showSlider, this.defaultValue.showSlider, [
          "always",
          "mouseover",
        ]),
        renderCharacters: K(
          t.renderCharacters,
          this.defaultValue.renderCharacters,
        ),
        scale: Wt.clampedInt(t.scale, 1, 1, 3),
        maxColumn: Wt.clampedInt(
          t.maxColumn,
          this.defaultValue.maxColumn,
          1,
          1e4,
        ),
        showRegionSectionHeaders: K(
          t.showRegionSectionHeaders,
          this.defaultValue.showRegionSectionHeaders,
        ),
        showMarkSectionHeaders: K(
          t.showMarkSectionHeaders,
          this.defaultValue.showMarkSectionHeaders,
        ),
        sectionHeaderFontSize: un.clamp(
          t.sectionHeaderFontSize ?? this.defaultValue.sectionHeaderFontSize,
          4,
          32,
        ),
        sectionHeaderLetterSpacing: un.clamp(
          t.sectionHeaderLetterSpacing ??
            this.defaultValue.sectionHeaderLetterSpacing,
          0,
          5,
        ),
      }
    }
  }
function pyt(i) {
  return i === "ctrlCmd" ? (Tr ? "metaKey" : "ctrlKey") : "altKey"
}
var gyt = class extends ee {
    constructor() {
      super(
        88,
        "padding",
        { top: 0, bottom: 0 },
        {
          "editor.padding.top": {
            type: "number",
            default: 0,
            minimum: 0,
            maximum: 1e3,
            description: f(395, null),
          },
          "editor.padding.bottom": {
            type: "number",
            default: 0,
            minimum: 0,
            maximum: 1e3,
            description: f(396, null),
          },
        },
      )
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        top: Wt.clampedInt(t.top, 0, 0, 1e3),
        bottom: Wt.clampedInt(t.bottom, 0, 0, 1e3),
      }
    }
  },
  vyt = class extends ee {
    constructor() {
      const i = { enabled: !0, cycle: !0 }
      super(90, "parameterHints", i, {
        "editor.parameterHints.enabled": {
          type: "boolean",
          default: i.enabled,
          description: f(397, null),
        },
        "editor.parameterHints.cycle": {
          type: "boolean",
          default: i.cycle,
          description: f(398, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        enabled: K(t.enabled, this.defaultValue.enabled),
        cycle: K(t.cycle, this.defaultValue.cycle),
      }
    }
  },
  wyt = class extends Jc {
    constructor() {
      super(149)
    }
    compute(i, t, e) {
      return i.pixelRatio
    }
  },
  yyt = class extends ee {
    constructor() {
      super(92, "placeholder", void 0)
    }
    validate(i) {
      return typeof i > "u"
        ? this.defaultValue
        : typeof i == "string"
          ? i
          : this.defaultValue
    }
  },
  Tyt = class extends ee {
    constructor() {
      const i = { other: "on", comments: "off", strings: "off" },
        t = [
          { type: "boolean" },
          {
            type: "string",
            enum: ["on", "inline", "off"],
            enumDescriptions: [f(399, null), f(400, null), f(401, null)],
          },
        ]
      super(94, "quickSuggestions", i, {
        type: "object",
        additionalProperties: !1,
        properties: {
          strings: { anyOf: t, default: i.strings, description: f(402, null) },
          comments: {
            anyOf: t,
            default: i.comments,
            description: f(403, null),
          },
          other: { anyOf: t, default: i.other, description: f(404, null) },
        },
        default: i,
        markdownDescription: f(
          405,
          null,
          "`#editor.suggestOnTriggerCharacters#`",
        ),
      }),
        (this.defaultValue = i)
    }
    validate(i) {
      if (typeof i == "boolean") {
        const u = i ? "on" : "off"
        return { comments: u, strings: u, other: u }
      }
      if (!i || typeof i != "object") return this.defaultValue
      const { other: t, comments: e, strings: r } = i,
        s = ["on", "inline", "off"]
      let a, o, c
      return (
        typeof t == "boolean"
          ? (a = t ? "on" : "off")
          : (a = ue(t, this.defaultValue.other, s)),
        typeof e == "boolean"
          ? (o = e ? "on" : "off")
          : (o = ue(e, this.defaultValue.comments, s)),
        typeof r == "boolean"
          ? (c = r ? "on" : "off")
          : (c = ue(r, this.defaultValue.strings, s)),
        { other: a, comments: o, strings: c }
      )
    }
  },
  nZ
;(function (i) {
  ;(i[(i.Off = 0)] = "Off"),
    (i[(i.On = 1)] = "On"),
    (i[(i.Relative = 2)] = "Relative"),
    (i[(i.Interval = 3)] = "Interval"),
    (i[(i.Custom = 4)] = "Custom")
})(nZ || (nZ = {}))
var kyt = class extends ee {
    constructor() {
      super(
        69,
        "lineNumbers",
        { renderType: 1, renderFn: null },
        {
          type: "string",
          enum: ["off", "on", "relative", "interval"],
          enumDescriptions: [
            f(406, null),
            f(407, null),
            f(408, null),
            f(409, null),
          ],
          default: "on",
          description: f(410, null),
        },
      )
    }
    validate(i) {
      let t = this.defaultValue.renderType,
        e = this.defaultValue.renderFn
      return (
        typeof i < "u" &&
          (typeof i == "function"
            ? ((t = 4), (e = i))
            : i === "interval"
              ? (t = 3)
              : i === "relative"
                ? (t = 2)
                : i === "on"
                  ? (t = 1)
                  : (t = 0)),
        { renderType: t, renderFn: e }
      )
    }
  },
  Syt = class extends ee {
    constructor() {
      const i = [],
        t = { type: "number", description: f(411, null) }
      super(107, "rulers", i, {
        type: "array",
        items: {
          anyOf: [
            t,
            {
              type: ["object"],
              properties: {
                column: t,
                color: {
                  type: "string",
                  description: f(412, null),
                  format: "color-hex",
                },
              },
            },
          ],
        },
        default: i,
        description: f(413, null),
      })
    }
    validate(i) {
      if (Array.isArray(i)) {
        const t = []
        for (const e of i)
          if (typeof e == "number")
            t.push({ column: Wt.clampedInt(e, 0, 0, 1e4), color: null })
          else if (e && typeof e == "object") {
            const r = e
            t.push({
              column: Wt.clampedInt(r.column, 0, 0, 1e4),
              color: r.color,
            })
          }
        return t.sort((e, r) => e.column - r.column), t
      }
      return this.defaultValue
    }
  },
  byt = class extends ee {
    constructor() {
      super(97, "readOnlyMessage", void 0)
    }
    validate(i) {
      return !i || typeof i != "object" ? this.defaultValue : i
    }
  }
function sZ(i, t) {
  if (typeof i != "string") return t
  switch (i) {
    case "hidden":
      return 2
    case "visible":
      return 3
    default:
      return 1
  }
}
var Eyt = class extends ee {
    constructor() {
      const i = {
        vertical: 1,
        horizontal: 1,
        arrowSize: 11,
        useShadows: !0,
        verticalHasArrows: !1,
        horizontalHasArrows: !1,
        horizontalScrollbarSize: 12,
        horizontalSliderSize: 12,
        verticalScrollbarSize: 14,
        verticalSliderSize: 14,
        handleMouseWheel: !0,
        ignoreVerticalScrolling: !1,
        alwaysConsumeMouseWheel: !0,
        scrollByPage: !1,
        ignoreHorizontalScrollbarInContentHeight: !1,
      }
      super(108, "scrollbar", i, {
        "editor.scrollbar.vertical": {
          type: "string",
          enum: ["auto", "visible", "hidden"],
          enumDescriptions: [f(414, null), f(415, null), f(416, null)],
          default: "auto",
          description: f(417, null),
        },
        "editor.scrollbar.horizontal": {
          type: "string",
          enum: ["auto", "visible", "hidden"],
          enumDescriptions: [f(418, null), f(419, null), f(420, null)],
          default: "auto",
          description: f(421, null),
        },
        "editor.scrollbar.verticalScrollbarSize": {
          type: "number",
          default: i.verticalScrollbarSize,
          description: f(422, null),
        },
        "editor.scrollbar.horizontalScrollbarSize": {
          type: "number",
          default: i.horizontalScrollbarSize,
          description: f(423, null),
        },
        "editor.scrollbar.scrollByPage": {
          type: "boolean",
          default: i.scrollByPage,
          description: f(424, null),
        },
        "editor.scrollbar.ignoreHorizontalScrollbarInContentHeight": {
          type: "boolean",
          default: i.ignoreHorizontalScrollbarInContentHeight,
          description: f(425, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i,
        e = Wt.clampedInt(
          t.horizontalScrollbarSize,
          this.defaultValue.horizontalScrollbarSize,
          0,
          1e3,
        ),
        r = Wt.clampedInt(
          t.verticalScrollbarSize,
          this.defaultValue.verticalScrollbarSize,
          0,
          1e3,
        )
      return {
        arrowSize: Wt.clampedInt(
          t.arrowSize,
          this.defaultValue.arrowSize,
          0,
          1e3,
        ),
        vertical: sZ(t.vertical, this.defaultValue.vertical),
        horizontal: sZ(t.horizontal, this.defaultValue.horizontal),
        useShadows: K(t.useShadows, this.defaultValue.useShadows),
        verticalHasArrows: K(
          t.verticalHasArrows,
          this.defaultValue.verticalHasArrows,
        ),
        horizontalHasArrows: K(
          t.horizontalHasArrows,
          this.defaultValue.horizontalHasArrows,
        ),
        handleMouseWheel: K(
          t.handleMouseWheel,
          this.defaultValue.handleMouseWheel,
        ),
        ignoreVerticalScrolling: K(
          t.ignoreVerticalScrolling,
          this.defaultValue.ignoreVerticalScrolling,
        ),
        alwaysConsumeMouseWheel: K(
          t.alwaysConsumeMouseWheel,
          this.defaultValue.alwaysConsumeMouseWheel,
        ),
        horizontalScrollbarSize: e,
        horizontalSliderSize: Wt.clampedInt(t.horizontalSliderSize, e, 0, 1e3),
        verticalScrollbarSize: r,
        verticalSliderSize: Wt.clampedInt(t.verticalSliderSize, r, 0, 1e3),
        scrollByPage: K(t.scrollByPage, this.defaultValue.scrollByPage),
        ignoreHorizontalScrollbarInContentHeight: K(
          t.ignoreHorizontalScrollbarInContentHeight,
          this.defaultValue.ignoreHorizontalScrollbarInContentHeight,
        ),
      }
    }
  },
  Ar = "inUntrustedWorkspace",
  Oa = {
    allowedCharacters: "editor.unicodeHighlight.allowedCharacters",
    invisibleCharacters: "editor.unicodeHighlight.invisibleCharacters",
    nonBasicASCII: "editor.unicodeHighlight.nonBasicASCII",
    ambiguousCharacters: "editor.unicodeHighlight.ambiguousCharacters",
    includeComments: "editor.unicodeHighlight.includeComments",
    includeStrings: "editor.unicodeHighlight.includeStrings",
    allowedLocales: "editor.unicodeHighlight.allowedLocales",
  },
  Iyt = class extends ee {
    constructor() {
      const i = {
        nonBasicASCII: Ar,
        invisibleCharacters: !0,
        ambiguousCharacters: !0,
        includeComments: Ar,
        includeStrings: !0,
        allowedCharacters: {},
        allowedLocales: { _os: !0, _vscode: !0 },
      }
      super(130, "unicodeHighlight", i, {
        [Oa.nonBasicASCII]: {
          restricted: !0,
          type: ["boolean", "string"],
          enum: [!0, !1, Ar],
          default: i.nonBasicASCII,
          description: f(426, null),
        },
        [Oa.invisibleCharacters]: {
          restricted: !0,
          type: "boolean",
          default: i.invisibleCharacters,
          description: f(427, null),
        },
        [Oa.ambiguousCharacters]: {
          restricted: !0,
          type: "boolean",
          default: i.ambiguousCharacters,
          description: f(428, null),
        },
        [Oa.includeComments]: {
          restricted: !0,
          type: ["boolean", "string"],
          enum: [!0, !1, Ar],
          default: i.includeComments,
          description: f(429, null),
        },
        [Oa.includeStrings]: {
          restricted: !0,
          type: ["boolean", "string"],
          enum: [!0, !1, Ar],
          default: i.includeStrings,
          description: f(430, null),
        },
        [Oa.allowedCharacters]: {
          restricted: !0,
          type: "object",
          default: i.allowedCharacters,
          description: f(431, null),
          additionalProperties: { type: "boolean" },
        },
        [Oa.allowedLocales]: {
          restricted: !0,
          type: "object",
          additionalProperties: { type: "boolean" },
          default: i.allowedLocales,
          description: f(432, null),
        },
      })
    }
    applyUpdate(i, t) {
      let e = !1
      t.allowedCharacters &&
        i &&
        (Ir(i.allowedCharacters, t.allowedCharacters) ||
          ((i = { ...i, allowedCharacters: t.allowedCharacters }), (e = !0))),
        t.allowedLocales &&
          i &&
          (Ir(i.allowedLocales, t.allowedLocales) ||
            ((i = { ...i, allowedLocales: t.allowedLocales }), (e = !0)))
      const r = super.applyUpdate(i, t)
      return e ? new R7(r.newValue, !0) : r
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        nonBasicASCII: Lc(t.nonBasicASCII, Ar, [!0, !1, Ar]),
        invisibleCharacters: K(
          t.invisibleCharacters,
          this.defaultValue.invisibleCharacters,
        ),
        ambiguousCharacters: K(
          t.ambiguousCharacters,
          this.defaultValue.ambiguousCharacters,
        ),
        includeComments: Lc(t.includeComments, Ar, [!0, !1, Ar]),
        includeStrings: Lc(t.includeStrings, Ar, [!0, !1, Ar]),
        allowedCharacters: this.c(
          i.allowedCharacters,
          this.defaultValue.allowedCharacters,
        ),
        allowedLocales: this.c(
          i.allowedLocales,
          this.defaultValue.allowedLocales,
        ),
      }
    }
    c(i, t) {
      if (typeof i != "object" || !i) return t
      const e = {}
      for (const [r, s] of Object.entries(i)) s === !0 && (e[r] = !0)
      return e
    }
  },
  Pyt = class extends ee {
    constructor() {
      const i = {
        enabled: !0,
        mode: "subwordSmart",
        showToolbar: "onHover",
        suppressSuggestions: !1,
        keepOnBlur: !1,
        fontFamily: "default",
        syntaxHighlightingEnabled: !1,
        edits: {
          experimental: {
            enabled: !0,
            useMixedLinesDiff: "never",
            useInterleavedLinesDiff: "never",
            onlyShowWhenCloseToCursor: !0,
          },
        },
      }
      super(64, "inlineSuggest", i, {
        "editor.inlineSuggest.enabled": {
          type: "boolean",
          default: i.enabled,
          description: f(433, null),
        },
        "editor.inlineSuggest.showToolbar": {
          type: "string",
          default: i.showToolbar,
          enum: ["always", "onHover", "never"],
          enumDescriptions: [f(434, null), f(435, null), f(436, null)],
          description: f(437, null),
        },
        "editor.inlineSuggest.syntaxHighlightingEnabled": {
          type: "boolean",
          default: i.syntaxHighlightingEnabled,
          description: f(438, null),
        },
        "editor.inlineSuggest.suppressSuggestions": {
          type: "boolean",
          default: i.suppressSuggestions,
          description: f(439, null),
        },
        "editor.inlineSuggest.fontFamily": {
          type: "string",
          default: i.fontFamily,
          description: f(440, null),
        },
        "editor.inlineSuggest.edits.experimental.enabled": {
          type: "boolean",
          default: i.edits.experimental.enabled,
          description: f(441, null),
        },
        "editor.inlineSuggest.edits.experimental.useMixedLinesDiff": {
          type: "string",
          default: i.edits.experimental.useMixedLinesDiff,
          description: f(442, null),
          enum: ["never", "whenPossible"],
        },
        "editor.inlineSuggest.edits.experimental.useInterleavedLinesDiff": {
          type: "string",
          default: i.edits.experimental.useInterleavedLinesDiff,
          description: f(443, null),
          enum: ["never", "always", "afterJump"],
        },
        "editor.inlineSuggest.edits.experimental.onlyShowWhenCloseToCursor": {
          type: "boolean",
          default: i.edits.experimental.onlyShowWhenCloseToCursor,
          description: f(444, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        enabled: K(t.enabled, this.defaultValue.enabled),
        mode: ue(t.mode, this.defaultValue.mode, [
          "prefix",
          "subword",
          "subwordSmart",
        ]),
        showToolbar: ue(t.showToolbar, this.defaultValue.showToolbar, [
          "always",
          "onHover",
          "never",
        ]),
        suppressSuggestions: K(
          t.suppressSuggestions,
          this.defaultValue.suppressSuggestions,
        ),
        keepOnBlur: K(t.keepOnBlur, this.defaultValue.keepOnBlur),
        fontFamily: _i.string(t.fontFamily, this.defaultValue.fontFamily),
        syntaxHighlightingEnabled: K(
          t.syntaxHighlightingEnabled,
          this.defaultValue.syntaxHighlightingEnabled,
        ),
        edits: {
          experimental: {
            enabled: K(
              t.edits?.experimental?.enabled,
              this.defaultValue.edits.experimental.enabled,
            ),
            useMixedLinesDiff: ue(
              t.edits?.experimental?.useMixedLinesDiff,
              this.defaultValue.edits.experimental.useMixedLinesDiff,
              ["never", "whenPossible", "afterJumpWhenPossible"],
            ),
            useInterleavedLinesDiff: ue(
              t.edits?.experimental?.useInterleavedLinesDiff,
              this.defaultValue.edits.experimental.useInterleavedLinesDiff,
              ["never", "always", "afterJump"],
            ),
            onlyShowWhenCloseToCursor: K(
              t.edits?.experimental?.onlyShowWhenCloseToCursor,
              this.defaultValue.edits.experimental.onlyShowWhenCloseToCursor,
            ),
          },
        },
      }
    }
  },
  Nyt = class extends ee {
    constructor() {
      const i = {
        enabled: ZK.bracketPairColorizationOptions.enabled,
        independentColorPoolPerBracketType:
          ZK.bracketPairColorizationOptions.independentColorPoolPerBracketType,
      }
      super(15, "bracketPairColorization", i, {
        "editor.bracketPairColorization.enabled": {
          type: "boolean",
          default: i.enabled,
          markdownDescription: f(
            445,
            null,
            "`#workbench.colorCustomizations#`",
          ),
        },
        "editor.bracketPairColorization.independentColorPoolPerBracketType": {
          type: "boolean",
          default: i.independentColorPoolPerBracketType,
          description: f(446, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        enabled: K(t.enabled, this.defaultValue.enabled),
        independentColorPoolPerBracketType: K(
          t.independentColorPoolPerBracketType,
          this.defaultValue.independentColorPoolPerBracketType,
        ),
      }
    }
  },
  $yt = class extends ee {
    constructor() {
      const i = {
        bracketPairs: !1,
        bracketPairsHorizontal: "active",
        highlightActiveBracketPair: !0,
        indentation: !0,
        highlightActiveIndentation: !0,
      }
      super(16, "guides", i, {
        "editor.guides.bracketPairs": {
          type: ["boolean", "string"],
          enum: [!0, "active", !1],
          enumDescriptions: [f(447, null), f(448, null), f(449, null)],
          default: i.bracketPairs,
          description: f(450, null),
        },
        "editor.guides.bracketPairsHorizontal": {
          type: ["boolean", "string"],
          enum: [!0, "active", !1],
          enumDescriptions: [f(451, null), f(452, null), f(453, null)],
          default: i.bracketPairsHorizontal,
          description: f(454, null),
        },
        "editor.guides.highlightActiveBracketPair": {
          type: "boolean",
          default: i.highlightActiveBracketPair,
          description: f(455, null),
        },
        "editor.guides.indentation": {
          type: "boolean",
          default: i.indentation,
          description: f(456, null),
        },
        "editor.guides.highlightActiveIndentation": {
          type: ["boolean", "string"],
          enum: [!0, "always", !1],
          enumDescriptions: [f(457, null), f(458, null), f(459, null)],
          default: i.highlightActiveIndentation,
          description: f(460, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        bracketPairs: Lc(t.bracketPairs, this.defaultValue.bracketPairs, [
          !0,
          !1,
          "active",
        ]),
        bracketPairsHorizontal: Lc(
          t.bracketPairsHorizontal,
          this.defaultValue.bracketPairsHorizontal,
          [!0, !1, "active"],
        ),
        highlightActiveBracketPair: K(
          t.highlightActiveBracketPair,
          this.defaultValue.highlightActiveBracketPair,
        ),
        indentation: K(t.indentation, this.defaultValue.indentation),
        highlightActiveIndentation: Lc(
          t.highlightActiveIndentation,
          this.defaultValue.highlightActiveIndentation,
          [!0, !1, "always"],
        ),
      }
    }
  }
function Lc(i, t, e) {
  const r = e.indexOf(i)
  return r === -1 ? t : e[r]
}
var xyt = class extends ee {
    constructor() {
      const i = {
        insertMode: "insert",
        filterGraceful: !0,
        snippetsPreventQuickSuggestions: !1,
        localityBonus: !1,
        shareSuggestSelections: !1,
        selectionMode: "always",
        showIcons: !0,
        showStatusBar: !1,
        preview: !1,
        previewMode: "subwordSmart",
        showInlineDetails: !0,
        showMethods: !0,
        showFunctions: !0,
        showConstructors: !0,
        showDeprecated: !0,
        matchOnWordStartOnly: !0,
        showFields: !0,
        showVariables: !0,
        showClasses: !0,
        showStructs: !0,
        showInterfaces: !0,
        showModules: !0,
        showProperties: !0,
        showEvents: !0,
        showOperators: !0,
        showUnits: !0,
        showValues: !0,
        showConstants: !0,
        showEnums: !0,
        showEnumMembers: !0,
        showKeywords: !0,
        showWords: !0,
        showColors: !0,
        showFiles: !0,
        showReferences: !0,
        showFolders: !0,
        showTypeParameters: !0,
        showSnippets: !0,
        showUsers: !0,
        showIssues: !0,
      }
      super(123, "suggest", i, {
        "editor.suggest.insertMode": {
          type: "string",
          enum: ["insert", "replace"],
          enumDescriptions: [f(461, null), f(462, null)],
          default: i.insertMode,
          description: f(463, null),
        },
        "editor.suggest.filterGraceful": {
          type: "boolean",
          default: i.filterGraceful,
          description: f(464, null),
        },
        "editor.suggest.localityBonus": {
          type: "boolean",
          default: i.localityBonus,
          description: f(465, null),
        },
        "editor.suggest.shareSuggestSelections": {
          type: "boolean",
          default: i.shareSuggestSelections,
          markdownDescription: f(466, null),
        },
        "editor.suggest.selectionMode": {
          type: "string",
          enum: [
            "always",
            "never",
            "whenTriggerCharacter",
            "whenQuickSuggestion",
          ],
          enumDescriptions: [
            f(467, null),
            f(468, null),
            f(469, null),
            f(470, null),
          ],
          default: i.selectionMode,
          markdownDescription: f(
            471,
            null,
            "`#editor.quickSuggestions#`",
            "`#editor.suggestOnTriggerCharacters#`",
          ),
        },
        "editor.suggest.snippetsPreventQuickSuggestions": {
          type: "boolean",
          default: i.snippetsPreventQuickSuggestions,
          description: f(472, null),
        },
        "editor.suggest.showIcons": {
          type: "boolean",
          default: i.showIcons,
          description: f(473, null),
        },
        "editor.suggest.showStatusBar": {
          type: "boolean",
          default: i.showStatusBar,
          description: f(474, null),
        },
        "editor.suggest.preview": {
          type: "boolean",
          default: i.preview,
          description: f(475, null),
        },
        "editor.suggest.showInlineDetails": {
          type: "boolean",
          default: i.showInlineDetails,
          description: f(476, null),
        },
        "editor.suggest.maxVisibleSuggestions": {
          type: "number",
          deprecationMessage: f(477, null),
        },
        "editor.suggest.filteredTypes": {
          type: "object",
          deprecationMessage: f(478, null),
        },
        "editor.suggest.showMethods": {
          type: "boolean",
          default: !0,
          markdownDescription: f(479, null),
        },
        "editor.suggest.showFunctions": {
          type: "boolean",
          default: !0,
          markdownDescription: f(480, null),
        },
        "editor.suggest.showConstructors": {
          type: "boolean",
          default: !0,
          markdownDescription: f(481, null),
        },
        "editor.suggest.showDeprecated": {
          type: "boolean",
          default: !0,
          markdownDescription: f(482, null),
        },
        "editor.suggest.matchOnWordStartOnly": {
          type: "boolean",
          default: !0,
          markdownDescription: f(483, null),
        },
        "editor.suggest.showFields": {
          type: "boolean",
          default: !0,
          markdownDescription: f(484, null),
        },
        "editor.suggest.showVariables": {
          type: "boolean",
          default: !0,
          markdownDescription: f(485, null),
        },
        "editor.suggest.showClasses": {
          type: "boolean",
          default: !0,
          markdownDescription: f(486, null),
        },
        "editor.suggest.showStructs": {
          type: "boolean",
          default: !0,
          markdownDescription: f(487, null),
        },
        "editor.suggest.showInterfaces": {
          type: "boolean",
          default: !0,
          markdownDescription: f(488, null),
        },
        "editor.suggest.showModules": {
          type: "boolean",
          default: !0,
          markdownDescription: f(489, null),
        },
        "editor.suggest.showProperties": {
          type: "boolean",
          default: !0,
          markdownDescription: f(490, null),
        },
        "editor.suggest.showEvents": {
          type: "boolean",
          default: !0,
          markdownDescription: f(491, null),
        },
        "editor.suggest.showOperators": {
          type: "boolean",
          default: !0,
          markdownDescription: f(492, null),
        },
        "editor.suggest.showUnits": {
          type: "boolean",
          default: !0,
          markdownDescription: f(493, null),
        },
        "editor.suggest.showValues": {
          type: "boolean",
          default: !0,
          markdownDescription: f(494, null),
        },
        "editor.suggest.showConstants": {
          type: "boolean",
          default: !0,
          markdownDescription: f(495, null),
        },
        "editor.suggest.showEnums": {
          type: "boolean",
          default: !0,
          markdownDescription: f(496, null),
        },
        "editor.suggest.showEnumMembers": {
          type: "boolean",
          default: !0,
          markdownDescription: f(497, null),
        },
        "editor.suggest.showKeywords": {
          type: "boolean",
          default: !0,
          markdownDescription: f(498, null),
        },
        "editor.suggest.showWords": {
          type: "boolean",
          default: !0,
          markdownDescription: f(499, null),
        },
        "editor.suggest.showColors": {
          type: "boolean",
          default: !0,
          markdownDescription: f(500, null),
        },
        "editor.suggest.showFiles": {
          type: "boolean",
          default: !0,
          markdownDescription: f(501, null),
        },
        "editor.suggest.showReferences": {
          type: "boolean",
          default: !0,
          markdownDescription: f(502, null),
        },
        "editor.suggest.showCustomcolors": {
          type: "boolean",
          default: !0,
          markdownDescription: f(503, null),
        },
        "editor.suggest.showFolders": {
          type: "boolean",
          default: !0,
          markdownDescription: f(504, null),
        },
        "editor.suggest.showTypeParameters": {
          type: "boolean",
          default: !0,
          markdownDescription: f(505, null),
        },
        "editor.suggest.showSnippets": {
          type: "boolean",
          default: !0,
          markdownDescription: f(506, null),
        },
        "editor.suggest.showUsers": {
          type: "boolean",
          default: !0,
          markdownDescription: f(507, null),
        },
        "editor.suggest.showIssues": {
          type: "boolean",
          default: !0,
          markdownDescription: f(508, null),
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        insertMode: ue(t.insertMode, this.defaultValue.insertMode, [
          "insert",
          "replace",
        ]),
        filterGraceful: K(t.filterGraceful, this.defaultValue.filterGraceful),
        snippetsPreventQuickSuggestions: K(
          t.snippetsPreventQuickSuggestions,
          this.defaultValue.filterGraceful,
        ),
        localityBonus: K(t.localityBonus, this.defaultValue.localityBonus),
        shareSuggestSelections: K(
          t.shareSuggestSelections,
          this.defaultValue.shareSuggestSelections,
        ),
        selectionMode: ue(t.selectionMode, this.defaultValue.selectionMode, [
          "always",
          "never",
          "whenQuickSuggestion",
          "whenTriggerCharacter",
        ]),
        showIcons: K(t.showIcons, this.defaultValue.showIcons),
        showStatusBar: K(t.showStatusBar, this.defaultValue.showStatusBar),
        preview: K(t.preview, this.defaultValue.preview),
        previewMode: ue(t.previewMode, this.defaultValue.previewMode, [
          "prefix",
          "subword",
          "subwordSmart",
        ]),
        showInlineDetails: K(
          t.showInlineDetails,
          this.defaultValue.showInlineDetails,
        ),
        showMethods: K(t.showMethods, this.defaultValue.showMethods),
        showFunctions: K(t.showFunctions, this.defaultValue.showFunctions),
        showConstructors: K(
          t.showConstructors,
          this.defaultValue.showConstructors,
        ),
        showDeprecated: K(t.showDeprecated, this.defaultValue.showDeprecated),
        matchOnWordStartOnly: K(
          t.matchOnWordStartOnly,
          this.defaultValue.matchOnWordStartOnly,
        ),
        showFields: K(t.showFields, this.defaultValue.showFields),
        showVariables: K(t.showVariables, this.defaultValue.showVariables),
        showClasses: K(t.showClasses, this.defaultValue.showClasses),
        showStructs: K(t.showStructs, this.defaultValue.showStructs),
        showInterfaces: K(t.showInterfaces, this.defaultValue.showInterfaces),
        showModules: K(t.showModules, this.defaultValue.showModules),
        showProperties: K(t.showProperties, this.defaultValue.showProperties),
        showEvents: K(t.showEvents, this.defaultValue.showEvents),
        showOperators: K(t.showOperators, this.defaultValue.showOperators),
        showUnits: K(t.showUnits, this.defaultValue.showUnits),
        showValues: K(t.showValues, this.defaultValue.showValues),
        showConstants: K(t.showConstants, this.defaultValue.showConstants),
        showEnums: K(t.showEnums, this.defaultValue.showEnums),
        showEnumMembers: K(
          t.showEnumMembers,
          this.defaultValue.showEnumMembers,
        ),
        showKeywords: K(t.showKeywords, this.defaultValue.showKeywords),
        showWords: K(t.showWords, this.defaultValue.showWords),
        showColors: K(t.showColors, this.defaultValue.showColors),
        showFiles: K(t.showFiles, this.defaultValue.showFiles),
        showReferences: K(t.showReferences, this.defaultValue.showReferences),
        showFolders: K(t.showFolders, this.defaultValue.showFolders),
        showTypeParameters: K(
          t.showTypeParameters,
          this.defaultValue.showTypeParameters,
        ),
        showSnippets: K(t.showSnippets, this.defaultValue.showSnippets),
        showUsers: K(t.showUsers, this.defaultValue.showUsers),
        showIssues: K(t.showIssues, this.defaultValue.showIssues),
      }
    }
  },
  Jyt = class extends ee {
    constructor() {
      super(
        118,
        "smartSelect",
        { selectLeadingAndTrailingWhitespace: !0, selectSubwords: !0 },
        {
          "editor.smartSelect.selectLeadingAndTrailingWhitespace": {
            description: f(509, null),
            default: !0,
            type: "boolean",
          },
          "editor.smartSelect.selectSubwords": {
            description: f(510, null),
            default: !0,
            type: "boolean",
          },
        },
      )
    }
    validate(i) {
      return !i || typeof i != "object"
        ? this.defaultValue
        : {
            selectLeadingAndTrailingWhitespace: K(
              i.selectLeadingAndTrailingWhitespace,
              this.defaultValue.selectLeadingAndTrailingWhitespace,
            ),
            selectSubwords: K(
              i.selectSubwords,
              this.defaultValue.selectSubwords,
            ),
          }
    }
  },
  Cyt = class extends ee {
    constructor() {
      const i = []
      super(135, "wordSegmenterLocales", i, {
        anyOf: [
          { description: f(511, null), type: "string" },
          {
            description: f(512, null),
            type: "array",
            items: { type: "string" },
          },
        ],
      })
    }
    validate(i) {
      if ((typeof i == "string" && (i = [i]), Array.isArray(i))) {
        const t = []
        for (const e of i)
          if (typeof e == "string")
            try {
              Intl.Segmenter.supportedLocalesOf(e).length > 0 && t.push(e)
            } catch {}
        return t
      }
      return this.defaultValue
    }
  },
  aZ
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Same = 1)] = "Same"),
    (i[(i.Indent = 2)] = "Indent"),
    (i[(i.DeepIndent = 3)] = "DeepIndent")
})(aZ || (aZ = {}))
var Lyt = class extends ee {
    constructor() {
      super(143, "wrappingIndent", 1, {
        "editor.wrappingIndent": {
          type: "string",
          enum: ["none", "same", "indent", "deepIndent"],
          enumDescriptions: [
            f(513, null),
            f(514, null),
            f(515, null),
            f(516, null),
          ],
          description: f(517, null),
          default: "same",
        },
      })
    }
    validate(i) {
      switch (i) {
        case "none":
          return 0
        case "same":
          return 1
        case "indent":
          return 2
        case "deepIndent":
          return 3
      }
      return 1
    }
    compute(i, t, e) {
      return t.get(2) === 2 ? 0 : e
    }
  },
  Ryt = class extends Jc {
    constructor() {
      super(152)
    }
    compute(i, t, e) {
      const r = t.get(151)
      return {
        isDominatedByLongLines: i.isDominatedByLongLines,
        isWordWrapMinified: r.isWordWrapMinified,
        isViewportWrapping: r.isViewportWrapping,
        wrappingColumn: r.wrappingColumn,
      }
    }
  },
  Dyt = class extends ee {
    constructor() {
      const i = { enabled: !0, showDropSelector: "afterDrop" }
      super(36, "dropIntoEditor", i, {
        "editor.dropIntoEditor.enabled": {
          type: "boolean",
          default: i.enabled,
          markdownDescription: f(518, null),
        },
        "editor.dropIntoEditor.showDropSelector": {
          type: "string",
          markdownDescription: f(519, null),
          enum: ["afterDrop", "never"],
          enumDescriptions: [f(520, null), f(521, null)],
          default: "afterDrop",
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        enabled: K(t.enabled, this.defaultValue.enabled),
        showDropSelector: ue(
          t.showDropSelector,
          this.defaultValue.showDropSelector,
          ["afterDrop", "never"],
        ),
      }
    }
  },
  Fyt = class extends ee {
    constructor() {
      const i = { enabled: !1, showPasteSelector: "afterPaste" }
      super(89, "pasteAs", i, {
        "editor.pasteAs.enabled": {
          type: "boolean",
          default: i.enabled,
          markdownDescription: f(522, null),
        },
        "editor.pasteAs.showPasteSelector": {
          type: "string",
          markdownDescription: f(523, null),
          enum: ["afterPaste", "never"],
          enumDescriptions: [f(524, null), f(525, null)],
          default: "afterPaste",
        },
      })
    }
    validate(i) {
      if (!i || typeof i != "object") return this.defaultValue
      const t = i
      return {
        enabled: K(t.enabled, this.defaultValue.enabled),
        showPasteSelector: ue(
          t.showPasteSelector,
          this.defaultValue.showPasteSelector,
          ["afterPaste", "never"],
        ),
      }
    }
  },
  _yt = "Consolas, 'Courier New', monospace",
  Ayt = "Menlo, Monaco, 'Courier New', monospace",
  Byt = "'Droid Sans Mono', 'monospace', monospace",
  qn = {
    fontFamily: Tr ? Ayt : es ? Byt : _yt,
    fontWeight: "normal",
    fontSize: Tr ? 12 : 14,
    lineHeight: 0,
    letterSpacing: 0,
  },
  Oyt = []
function R(i) {
  return (Oyt[i.id] = i), i
}
var oZ
;(function (i) {
  ;(i[(i.acceptSuggestionOnCommitCharacter = 0)] =
    "acceptSuggestionOnCommitCharacter"),
    (i[(i.acceptSuggestionOnEnter = 1)] = "acceptSuggestionOnEnter"),
    (i[(i.accessibilitySupport = 2)] = "accessibilitySupport"),
    (i[(i.accessibilityPageSize = 3)] = "accessibilityPageSize"),
    (i[(i.ariaLabel = 4)] = "ariaLabel"),
    (i[(i.ariaRequired = 5)] = "ariaRequired"),
    (i[(i.autoClosingBrackets = 6)] = "autoClosingBrackets"),
    (i[(i.autoClosingComments = 7)] = "autoClosingComments"),
    (i[(i.screenReaderAnnounceInlineSuggestion = 8)] =
      "screenReaderAnnounceInlineSuggestion"),
    (i[(i.autoClosingDelete = 9)] = "autoClosingDelete"),
    (i[(i.autoClosingOvertype = 10)] = "autoClosingOvertype"),
    (i[(i.autoClosingQuotes = 11)] = "autoClosingQuotes"),
    (i[(i.autoIndent = 12)] = "autoIndent"),
    (i[(i.automaticLayout = 13)] = "automaticLayout"),
    (i[(i.autoSurround = 14)] = "autoSurround"),
    (i[(i.bracketPairColorization = 15)] = "bracketPairColorization"),
    (i[(i.guides = 16)] = "guides"),
    (i[(i.codeLens = 17)] = "codeLens"),
    (i[(i.codeLensFontFamily = 18)] = "codeLensFontFamily"),
    (i[(i.codeLensFontSize = 19)] = "codeLensFontSize"),
    (i[(i.colorDecorators = 20)] = "colorDecorators"),
    (i[(i.colorDecoratorsLimit = 21)] = "colorDecoratorsLimit"),
    (i[(i.columnSelection = 22)] = "columnSelection"),
    (i[(i.comments = 23)] = "comments"),
    (i[(i.contextmenu = 24)] = "contextmenu"),
    (i[(i.copyWithSyntaxHighlighting = 25)] = "copyWithSyntaxHighlighting"),
    (i[(i.cursorBlinking = 26)] = "cursorBlinking"),
    (i[(i.cursorSmoothCaretAnimation = 27)] = "cursorSmoothCaretAnimation"),
    (i[(i.cursorStyle = 28)] = "cursorStyle"),
    (i[(i.cursorSurroundingLines = 29)] = "cursorSurroundingLines"),
    (i[(i.cursorSurroundingLinesStyle = 30)] = "cursorSurroundingLinesStyle"),
    (i[(i.cursorWidth = 31)] = "cursorWidth"),
    (i[(i.disableLayerHinting = 32)] = "disableLayerHinting"),
    (i[(i.disableMonospaceOptimizations = 33)] =
      "disableMonospaceOptimizations"),
    (i[(i.domReadOnly = 34)] = "domReadOnly"),
    (i[(i.dragAndDrop = 35)] = "dragAndDrop"),
    (i[(i.dropIntoEditor = 36)] = "dropIntoEditor"),
    (i[(i.experimentalEditContextEnabled = 37)] =
      "experimentalEditContextEnabled"),
    (i[(i.emptySelectionClipboard = 38)] = "emptySelectionClipboard"),
    (i[(i.experimentalGpuAcceleration = 39)] = "experimentalGpuAcceleration"),
    (i[(i.experimentalWhitespaceRendering = 40)] =
      "experimentalWhitespaceRendering"),
    (i[(i.extraEditorClassName = 41)] = "extraEditorClassName"),
    (i[(i.fastScrollSensitivity = 42)] = "fastScrollSensitivity"),
    (i[(i.find = 43)] = "find"),
    (i[(i.fixedOverflowWidgets = 44)] = "fixedOverflowWidgets"),
    (i[(i.folding = 45)] = "folding"),
    (i[(i.foldingStrategy = 46)] = "foldingStrategy"),
    (i[(i.foldingHighlight = 47)] = "foldingHighlight"),
    (i[(i.foldingImportsByDefault = 48)] = "foldingImportsByDefault"),
    (i[(i.foldingMaximumRegions = 49)] = "foldingMaximumRegions"),
    (i[(i.unfoldOnClickAfterEndOfLine = 50)] = "unfoldOnClickAfterEndOfLine"),
    (i[(i.fontFamily = 51)] = "fontFamily"),
    (i[(i.fontInfo = 52)] = "fontInfo"),
    (i[(i.fontLigatures = 53)] = "fontLigatures"),
    (i[(i.fontSize = 54)] = "fontSize"),
    (i[(i.fontWeight = 55)] = "fontWeight"),
    (i[(i.fontVariations = 56)] = "fontVariations"),
    (i[(i.formatOnPaste = 57)] = "formatOnPaste"),
    (i[(i.formatOnType = 58)] = "formatOnType"),
    (i[(i.glyphMargin = 59)] = "glyphMargin"),
    (i[(i.gotoLocation = 60)] = "gotoLocation"),
    (i[(i.hideCursorInOverviewRuler = 61)] = "hideCursorInOverviewRuler"),
    (i[(i.hover = 62)] = "hover"),
    (i[(i.inDiffEditor = 63)] = "inDiffEditor"),
    (i[(i.inlineSuggest = 64)] = "inlineSuggest"),
    (i[(i.letterSpacing = 65)] = "letterSpacing"),
    (i[(i.lightbulb = 66)] = "lightbulb"),
    (i[(i.lineDecorationsWidth = 67)] = "lineDecorationsWidth"),
    (i[(i.lineHeight = 68)] = "lineHeight"),
    (i[(i.lineNumbers = 69)] = "lineNumbers"),
    (i[(i.lineNumbersMinChars = 70)] = "lineNumbersMinChars"),
    (i[(i.linkedEditing = 71)] = "linkedEditing"),
    (i[(i.links = 72)] = "links"),
    (i[(i.matchBrackets = 73)] = "matchBrackets"),
    (i[(i.minimap = 74)] = "minimap"),
    (i[(i.mouseStyle = 75)] = "mouseStyle"),
    (i[(i.mouseWheelScrollSensitivity = 76)] = "mouseWheelScrollSensitivity"),
    (i[(i.mouseWheelZoom = 77)] = "mouseWheelZoom"),
    (i[(i.multiCursorMergeOverlapping = 78)] = "multiCursorMergeOverlapping"),
    (i[(i.multiCursorModifier = 79)] = "multiCursorModifier"),
    (i[(i.multiCursorPaste = 80)] = "multiCursorPaste"),
    (i[(i.multiCursorLimit = 81)] = "multiCursorLimit"),
    (i[(i.occurrencesHighlight = 82)] = "occurrencesHighlight"),
    (i[(i.occurrencesHighlightDelay = 83)] = "occurrencesHighlightDelay"),
    (i[(i.overtypeCursorStyle = 84)] = "overtypeCursorStyle"),
    (i[(i.overtypeOnPaste = 85)] = "overtypeOnPaste"),
    (i[(i.overviewRulerBorder = 86)] = "overviewRulerBorder"),
    (i[(i.overviewRulerLanes = 87)] = "overviewRulerLanes"),
    (i[(i.padding = 88)] = "padding"),
    (i[(i.pasteAs = 89)] = "pasteAs"),
    (i[(i.parameterHints = 90)] = "parameterHints"),
    (i[(i.peekWidgetDefaultFocus = 91)] = "peekWidgetDefaultFocus"),
    (i[(i.placeholder = 92)] = "placeholder"),
    (i[(i.definitionLinkOpensInPeek = 93)] = "definitionLinkOpensInPeek"),
    (i[(i.quickSuggestions = 94)] = "quickSuggestions"),
    (i[(i.quickSuggestionsDelay = 95)] = "quickSuggestionsDelay"),
    (i[(i.readOnly = 96)] = "readOnly"),
    (i[(i.readOnlyMessage = 97)] = "readOnlyMessage"),
    (i[(i.renameOnType = 98)] = "renameOnType"),
    (i[(i.renderControlCharacters = 99)] = "renderControlCharacters"),
    (i[(i.renderFinalNewline = 100)] = "renderFinalNewline"),
    (i[(i.renderLineHighlight = 101)] = "renderLineHighlight"),
    (i[(i.renderLineHighlightOnlyWhenFocus = 102)] =
      "renderLineHighlightOnlyWhenFocus"),
    (i[(i.renderValidationDecorations = 103)] = "renderValidationDecorations"),
    (i[(i.renderWhitespace = 104)] = "renderWhitespace"),
    (i[(i.revealHorizontalRightPadding = 105)] =
      "revealHorizontalRightPadding"),
    (i[(i.roundedSelection = 106)] = "roundedSelection"),
    (i[(i.rulers = 107)] = "rulers"),
    (i[(i.scrollbar = 108)] = "scrollbar"),
    (i[(i.scrollBeyondLastColumn = 109)] = "scrollBeyondLastColumn"),
    (i[(i.scrollBeyondLastLine = 110)] = "scrollBeyondLastLine"),
    (i[(i.scrollPredominantAxis = 111)] = "scrollPredominantAxis"),
    (i[(i.selectionClipboard = 112)] = "selectionClipboard"),
    (i[(i.selectionHighlight = 113)] = "selectionHighlight"),
    (i[(i.selectOnLineNumbers = 114)] = "selectOnLineNumbers"),
    (i[(i.showFoldingControls = 115)] = "showFoldingControls"),
    (i[(i.showUnused = 116)] = "showUnused"),
    (i[(i.snippetSuggestions = 117)] = "snippetSuggestions"),
    (i[(i.smartSelect = 118)] = "smartSelect"),
    (i[(i.smoothScrolling = 119)] = "smoothScrolling"),
    (i[(i.stickyScroll = 120)] = "stickyScroll"),
    (i[(i.stickyTabStops = 121)] = "stickyTabStops"),
    (i[(i.stopRenderingLineAfter = 122)] = "stopRenderingLineAfter"),
    (i[(i.suggest = 123)] = "suggest"),
    (i[(i.suggestFontSize = 124)] = "suggestFontSize"),
    (i[(i.suggestLineHeight = 125)] = "suggestLineHeight"),
    (i[(i.suggestOnTriggerCharacters = 126)] = "suggestOnTriggerCharacters"),
    (i[(i.suggestSelection = 127)] = "suggestSelection"),
    (i[(i.tabCompletion = 128)] = "tabCompletion"),
    (i[(i.tabIndex = 129)] = "tabIndex"),
    (i[(i.unicodeHighlighting = 130)] = "unicodeHighlighting"),
    (i[(i.unusualLineTerminators = 131)] = "unusualLineTerminators"),
    (i[(i.useShadowDOM = 132)] = "useShadowDOM"),
    (i[(i.useTabStops = 133)] = "useTabStops"),
    (i[(i.wordBreak = 134)] = "wordBreak"),
    (i[(i.wordSegmenterLocales = 135)] = "wordSegmenterLocales"),
    (i[(i.wordSeparators = 136)] = "wordSeparators"),
    (i[(i.wordWrap = 137)] = "wordWrap"),
    (i[(i.wordWrapBreakAfterCharacters = 138)] =
      "wordWrapBreakAfterCharacters"),
    (i[(i.wordWrapBreakBeforeCharacters = 139)] =
      "wordWrapBreakBeforeCharacters"),
    (i[(i.wordWrapColumn = 140)] = "wordWrapColumn"),
    (i[(i.wordWrapOverride1 = 141)] = "wordWrapOverride1"),
    (i[(i.wordWrapOverride2 = 142)] = "wordWrapOverride2"),
    (i[(i.wrappingIndent = 143)] = "wrappingIndent"),
    (i[(i.wrappingStrategy = 144)] = "wrappingStrategy"),
    (i[(i.showDeprecated = 145)] = "showDeprecated"),
    (i[(i.inlayHints = 146)] = "inlayHints"),
    (i[(i.effectiveCursorStyle = 147)] = "effectiveCursorStyle"),
    (i[(i.editorClassName = 148)] = "editorClassName"),
    (i[(i.pixelRatio = 149)] = "pixelRatio"),
    (i[(i.tabFocusMode = 150)] = "tabFocusMode"),
    (i[(i.layoutInfo = 151)] = "layoutInfo"),
    (i[(i.wrappingInfo = 152)] = "wrappingInfo"),
    (i[(i.defaultColorDecorators = 153)] = "defaultColorDecorators"),
    (i[(i.colorDecoratorsActivatedOn = 154)] = "colorDecoratorsActivatedOn"),
    (i[(i.inlineCompletionsAccessibilityVerbose = 155)] =
      "inlineCompletionsAccessibilityVerbose"),
    (i[(i.automaticLayoutIgnoreHeight = 156)] = "automaticLayoutIgnoreHeight")
})(oZ || (oZ = {}))
var i2t = {
  acceptSuggestionOnCommitCharacter: R(
    new kt(0, "acceptSuggestionOnCommitCharacter", !0, {
      markdownDescription: f(526, null),
    }),
  ),
  acceptSuggestionOnEnter: R(
    new ne(1, "acceptSuggestionOnEnter", "on", ["on", "smart", "off"], {
      markdownEnumDescriptions: ["", f(527, null), ""],
      markdownDescription: f(528, null),
    }),
  ),
  accessibilitySupport: R(new Gwt()),
  accessibilityPageSize: R(
    new Wt(3, "accessibilityPageSize", 10, 1, 1073741824, {
      description: f(529, null),
      tags: ["accessibility"],
    }),
  ),
  ariaLabel: R(new _i(4, "ariaLabel", f(530, null))),
  ariaRequired: R(new kt(5, "ariaRequired", !1, void 0)),
  screenReaderAnnounceInlineSuggestion: R(
    new kt(8, "screenReaderAnnounceInlineSuggestion", !0, {
      description: f(531, null),
      tags: ["accessibility"],
    }),
  ),
  autoClosingBrackets: R(
    new ne(
      6,
      "autoClosingBrackets",
      "languageDefined",
      ["always", "languageDefined", "beforeWhitespace", "never"],
      {
        enumDescriptions: ["", f(532, null), f(533, null), ""],
        description: f(534, null),
      },
    ),
  ),
  autoClosingComments: R(
    new ne(
      7,
      "autoClosingComments",
      "languageDefined",
      ["always", "languageDefined", "beforeWhitespace", "never"],
      {
        enumDescriptions: ["", f(535, null), f(536, null), ""],
        description: f(537, null),
      },
    ),
  ),
  autoClosingDelete: R(
    new ne(9, "autoClosingDelete", "auto", ["always", "auto", "never"], {
      enumDescriptions: ["", f(538, null), ""],
      description: f(539, null),
    }),
  ),
  autoClosingOvertype: R(
    new ne(10, "autoClosingOvertype", "auto", ["always", "auto", "never"], {
      enumDescriptions: ["", f(540, null), ""],
      description: f(541, null),
    }),
  ),
  autoClosingQuotes: R(
    new ne(
      11,
      "autoClosingQuotes",
      "languageDefined",
      ["always", "languageDefined", "beforeWhitespace", "never"],
      {
        enumDescriptions: ["", f(542, null), f(543, null), ""],
        description: f(544, null),
      },
    ),
  ),
  autoIndent: R(
    new Qd(
      12,
      "autoIndent",
      4,
      "full",
      ["none", "keep", "brackets", "advanced", "full"],
      Vwt,
      {
        enumDescriptions: [
          f(545, null),
          f(546, null),
          f(547, null),
          f(548, null),
          f(549, null),
        ],
        description: f(550, null),
      },
    ),
  ),
  automaticLayout: R(new kt(13, "automaticLayout", !1)),
  autoSurround: R(
    new ne(
      14,
      "autoSurround",
      "languageDefined",
      ["languageDefined", "quotes", "brackets", "never"],
      {
        enumDescriptions: [f(551, null), f(552, null), f(553, null), ""],
        description: f(554, null),
      },
    ),
  ),
  bracketPairColorization: R(new Nyt()),
  bracketPairGuides: R(new $yt()),
  stickyTabStops: R(
    new kt(121, "stickyTabStops", !1, { description: f(555, null) }),
  ),
  codeLens: R(new kt(17, "codeLens", !0, { description: f(556, null) })),
  codeLensFontFamily: R(
    new _i(18, "codeLensFontFamily", "", { description: f(557, null) }),
  ),
  codeLensFontSize: R(
    new Wt(19, "codeLensFontSize", 0, 0, 100, {
      type: "number",
      default: 0,
      minimum: 0,
      maximum: 100,
      markdownDescription: f(558, null),
    }),
  ),
  colorDecorators: R(
    new kt(20, "colorDecorators", !0, { description: f(559, null) }),
  ),
  colorDecoratorActivatedOn: R(
    new ne(
      154,
      "colorDecoratorsActivatedOn",
      "clickAndHover",
      ["clickAndHover", "hover", "click"],
      {
        enumDescriptions: [f(560, null), f(561, null), f(562, null)],
        description: f(563, null),
      },
    ),
  ),
  colorDecoratorsLimit: R(
    new Wt(21, "colorDecoratorsLimit", 500, 1, 1e6, {
      markdownDescription: f(564, null),
    }),
  ),
  columnSelection: R(
    new kt(22, "columnSelection", !1, { description: f(565, null) }),
  ),
  comments: R(new zwt()),
  contextmenu: R(new kt(24, "contextmenu", !0)),
  copyWithSyntaxHighlighting: R(
    new kt(25, "copyWithSyntaxHighlighting", !0, { description: f(566, null) }),
  ),
  cursorBlinking: R(
    new Qd(
      26,
      "cursorBlinking",
      1,
      "blink",
      ["blink", "smooth", "phase", "expand", "solid"],
      Ywt,
      { description: f(567, null) },
    ),
  ),
  cursorSmoothCaretAnimation: R(
    new ne(27, "cursorSmoothCaretAnimation", "off", ["off", "explicit", "on"], {
      enumDescriptions: [f(568, null), f(569, null), f(570, null)],
      description: f(571, null),
    }),
  ),
  cursorStyle: R(
    new Qd(
      28,
      "cursorStyle",
      _r.Line,
      "line",
      [
        "line",
        "block",
        "underline",
        "line-thin",
        "block-outline",
        "underline-thin",
      ],
      iZ,
      { description: f(572, null) },
    ),
  ),
  overtypeCursorStyle: R(
    new Qd(
      84,
      "overtypeCursorStyle",
      _r.Block,
      "block",
      [
        "line",
        "block",
        "underline",
        "line-thin",
        "block-outline",
        "underline-thin",
      ],
      iZ,
      { description: f(573, null) },
    ),
  ),
  cursorSurroundingLines: R(
    new Wt(29, "cursorSurroundingLines", 0, 0, 1073741824, {
      description: f(574, null),
    }),
  ),
  cursorSurroundingLinesStyle: R(
    new ne(30, "cursorSurroundingLinesStyle", "default", ["default", "all"], {
      enumDescriptions: [f(575, null), f(576, null)],
      markdownDescription: f(577, null),
    }),
  ),
  cursorWidth: R(
    new Wt(31, "cursorWidth", 0, 0, 1073741824, {
      markdownDescription: f(578, null),
    }),
  ),
  disableLayerHinting: R(new kt(32, "disableLayerHinting", !1)),
  disableMonospaceOptimizations: R(
    new kt(33, "disableMonospaceOptimizations", !1),
  ),
  domReadOnly: R(new kt(34, "domReadOnly", !1)),
  dragAndDrop: R(new kt(35, "dragAndDrop", !0, { description: f(579, null) })),
  emptySelectionClipboard: R(new Xwt()),
  dropIntoEditor: R(new Dyt()),
  experimentalEditContextEnabled: R(
    new kt(37, "experimentalEditContextEnabled", !1, {
      description: f(580, null),
      included: wB || lW || rW,
    }),
  ),
  stickyScroll: R(new lyt()),
  experimentalGpuAcceleration: R(
    new ne(39, "experimentalGpuAcceleration", "off", ["off", "on"], void 0),
  ),
  experimentalWhitespaceRendering: R(
    new ne(
      40,
      "experimentalWhitespaceRendering",
      "svg",
      ["svg", "font", "off"],
      {
        enumDescriptions: [f(581, null), f(582, null), f(583, null)],
        description: f(584, null),
      },
    ),
  ),
  extraEditorClassName: R(new _i(41, "extraEditorClassName", "")),
  fastScrollSensitivity: R(
    new un(42, "fastScrollSensitivity", 5, (i) => (i <= 0 ? 5 : i), {
      markdownDescription: f(585, null),
    }),
  ),
  find: R(new Kwt()),
  fixedOverflowWidgets: R(new kt(44, "fixedOverflowWidgets", !1)),
  folding: R(new kt(45, "folding", !0, { description: f(586, null) })),
  foldingStrategy: R(
    new ne(46, "foldingStrategy", "auto", ["auto", "indentation"], {
      enumDescriptions: [f(587, null), f(588, null)],
      description: f(589, null),
    }),
  ),
  foldingHighlight: R(
    new kt(47, "foldingHighlight", !0, { description: f(590, null) }),
  ),
  foldingImportsByDefault: R(
    new kt(48, "foldingImportsByDefault", !1, { description: f(591, null) }),
  ),
  foldingMaximumRegions: R(
    new Wt(49, "foldingMaximumRegions", 5e3, 10, 65e3, {
      description: f(592, null),
    }),
  ),
  unfoldOnClickAfterEndOfLine: R(
    new kt(50, "unfoldOnClickAfterEndOfLine", !1, {
      description: f(593, null),
    }),
  ),
  fontFamily: R(
    new _i(51, "fontFamily", qn.fontFamily, { description: f(594, null) }),
  ),
  fontInfo: R(new eyt()),
  fontLigatures2: R(new Zwt()),
  fontSize: R(new ryt()),
  fontWeight: R(new nyt()),
  fontVariations: R(new tyt()),
  formatOnPaste: R(
    new kt(57, "formatOnPaste", !1, { description: f(595, null) }),
  ),
  formatOnType: R(
    new kt(58, "formatOnType", !1, { description: f(596, null) }),
  ),
  glyphMargin: R(new kt(59, "glyphMargin", !0, { description: f(597, null) })),
  gotoLocation: R(new syt()),
  hideCursorInOverviewRuler: R(
    new kt(61, "hideCursorInOverviewRuler", !1, { description: f(598, null) }),
  ),
  hover: R(new ayt()),
  inDiffEditor: R(new kt(63, "inDiffEditor", !1)),
  letterSpacing: R(
    new un(65, "letterSpacing", qn.letterSpacing, (i) => un.clamp(i, -5, 20), {
      description: f(599, null),
    }),
  ),
  lightbulb: R(new uyt()),
  lineDecorationsWidth: R(new myt()),
  lineHeight: R(new hyt()),
  lineNumbers: R(new kyt()),
  lineNumbersMinChars: R(new Wt(70, "lineNumbersMinChars", 5, 1, 300)),
  linkedEditing: R(
    new kt(71, "linkedEditing", !1, { description: f(600, null) }),
  ),
  links: R(new kt(72, "links", !0, { description: f(601, null) })),
  matchBrackets: R(
    new ne(73, "matchBrackets", "always", ["always", "near", "never"], {
      description: f(602, null),
    }),
  ),
  minimap: R(new fyt()),
  mouseStyle: R(new ne(75, "mouseStyle", "text", ["text", "default", "copy"])),
  mouseWheelScrollSensitivity: R(
    new un(76, "mouseWheelScrollSensitivity", 1, (i) => (i === 0 ? 1 : i), {
      markdownDescription: f(603, null),
    }),
  ),
  mouseWheelZoom: R(
    new kt(77, "mouseWheelZoom", !1, {
      markdownDescription: f(Tr ? 604 : 605, null),
    }),
  ),
  multiCursorMergeOverlapping: R(
    new kt(78, "multiCursorMergeOverlapping", !0, {
      description: f(606, null),
    }),
  ),
  multiCursorModifier: R(
    new Qd(
      79,
      "multiCursorModifier",
      "altKey",
      "alt",
      ["ctrlCmd", "alt"],
      pyt,
      {
        markdownEnumDescriptions: [f(607, null), f(608, null)],
        markdownDescription: f(609, null),
      },
    ),
  ),
  multiCursorPaste: R(
    new ne(80, "multiCursorPaste", "spread", ["spread", "full"], {
      markdownEnumDescriptions: [f(610, null), f(611, null)],
      markdownDescription: f(612, null),
    }),
  ),
  multiCursorLimit: R(
    new Wt(81, "multiCursorLimit", 1e4, 1, 1e5, {
      markdownDescription: f(613, null),
    }),
  ),
  occurrencesHighlight: R(
    new ne(
      82,
      "occurrencesHighlight",
      "singleFile",
      ["off", "singleFile", "multiFile"],
      {
        markdownEnumDescriptions: [f(614, null), f(615, null), f(616, null)],
        markdownDescription: f(617, null),
      },
    ),
  ),
  occurrencesHighlightDelay: R(
    new Wt(83, "occurrencesHighlightDelay", 250, 0, 2e3, {
      description: f(618, null),
      tags: ["preview"],
    }),
  ),
  overtypeOnPaste: R(
    new kt(85, "overtypeOnPaste", !0, { description: f(619, null) }),
  ),
  overviewRulerBorder: R(
    new kt(86, "overviewRulerBorder", !0, { description: f(620, null) }),
  ),
  overviewRulerLanes: R(new Wt(87, "overviewRulerLanes", 3, 0, 3)),
  padding: R(new gyt()),
  pasteAs: R(new Fyt()),
  parameterHints: R(new vyt()),
  peekWidgetDefaultFocus: R(
    new ne(91, "peekWidgetDefaultFocus", "tree", ["tree", "editor"], {
      enumDescriptions: [f(621, null), f(622, null)],
      description: f(623, null),
    }),
  ),
  placeholder: R(new yyt()),
  definitionLinkOpensInPeek: R(
    new kt(93, "definitionLinkOpensInPeek", !1, { description: f(624, null) }),
  ),
  quickSuggestions: R(new Tyt()),
  quickSuggestionsDelay: R(
    new Wt(95, "quickSuggestionsDelay", 10, 0, 1073741824, {
      description: f(625, null),
    }),
  ),
  readOnly: R(new kt(96, "readOnly", !1)),
  readOnlyMessage: R(new byt()),
  renameOnType: R(
    new kt(98, "renameOnType", !1, {
      description: f(626, null),
      markdownDeprecationMessage: f(627, null),
    }),
  ),
  renderControlCharacters: R(
    new kt(99, "renderControlCharacters", !0, {
      description: f(628, null),
      restricted: !0,
    }),
  ),
  renderFinalNewline: R(
    new ne(
      100,
      "renderFinalNewline",
      es ? "dimmed" : "on",
      ["off", "on", "dimmed"],
      { description: f(629, null) },
    ),
  ),
  renderLineHighlight: R(
    new ne(
      101,
      "renderLineHighlight",
      "line",
      ["none", "gutter", "line", "all"],
      {
        enumDescriptions: ["", "", "", f(630, null)],
        description: f(631, null),
      },
    ),
  ),
  renderLineHighlightOnlyWhenFocus: R(
    new kt(102, "renderLineHighlightOnlyWhenFocus", !1, {
      description: f(632, null),
    }),
  ),
  renderValidationDecorations: R(
    new ne(103, "renderValidationDecorations", "editable", [
      "editable",
      "on",
      "off",
    ]),
  ),
  renderWhitespace: R(
    new ne(
      104,
      "renderWhitespace",
      "selection",
      ["none", "boundary", "selection", "trailing", "all"],
      {
        enumDescriptions: ["", f(633, null), f(634, null), f(635, null), ""],
        description: f(636, null),
      },
    ),
  ),
  revealHorizontalRightPadding: R(
    new Wt(105, "revealHorizontalRightPadding", 15, 0, 1e3),
  ),
  roundedSelection: R(
    new kt(106, "roundedSelection", !0, { description: f(637, null) }),
  ),
  rulers: R(new Syt()),
  scrollbar: R(new Eyt()),
  scrollBeyondLastColumn: R(
    new Wt(109, "scrollBeyondLastColumn", 4, 0, 1073741824, {
      description: f(638, null),
    }),
  ),
  scrollBeyondLastLine: R(
    new kt(110, "scrollBeyondLastLine", !0, { description: f(639, null) }),
  ),
  scrollPredominantAxis: R(
    new kt(111, "scrollPredominantAxis", !0, { description: f(640, null) }),
  ),
  selectionClipboard: R(
    new kt(112, "selectionClipboard", !0, {
      description: f(641, null),
      included: es,
    }),
  ),
  selectionHighlight: R(
    new kt(113, "selectionHighlight", !0, { description: f(642, null) }),
  ),
  selectOnLineNumbers: R(new kt(114, "selectOnLineNumbers", !0)),
  showFoldingControls: R(
    new ne(
      115,
      "showFoldingControls",
      "mouseover",
      ["always", "never", "mouseover"],
      {
        enumDescriptions: [f(643, null), f(644, null), f(645, null)],
        description: f(646, null),
      },
    ),
  ),
  showUnused: R(new kt(116, "showUnused", !0, { description: f(647, null) })),
  showDeprecated: R(
    new kt(145, "showDeprecated", !0, { description: f(648, null) }),
  ),
  inlayHints: R(new dyt()),
  snippetSuggestions: R(
    new ne(
      117,
      "snippetSuggestions",
      "inline",
      ["top", "bottom", "inline", "none"],
      {
        enumDescriptions: [
          f(649, null),
          f(650, null),
          f(651, null),
          f(652, null),
        ],
        description: f(653, null),
      },
    ),
  ),
  smartSelect: R(new Jyt()),
  smoothScrolling: R(
    new kt(119, "smoothScrolling", !1, { description: f(654, null) }),
  ),
  stopRenderingLineAfter: R(
    new Wt(122, "stopRenderingLineAfter", 1e4, -1, 1073741824),
  ),
  suggest: R(new xyt()),
  inlineSuggest: R(new Pyt()),
  inlineCompletionsAccessibilityVerbose: R(
    new kt(155, "inlineCompletionsAccessibilityVerbose", !1, {
      description: f(655, null),
    }),
  ),
  automaticLayoutIgnoreHeight: R(
    new kt(156, "automaticLayoutIgnoreHeight", !1),
  ),
  suggestFontSize: R(
    new Wt(124, "suggestFontSize", 0, 0, 1e3, {
      markdownDescription: f(656, null, "`0`", "`#editor.fontSize#`"),
    }),
  ),
  suggestLineHeight: R(
    new Wt(125, "suggestLineHeight", 0, 0, 1e3, {
      markdownDescription: f(657, null, "`0`", "`#editor.lineHeight#`"),
    }),
  ),
  suggestOnTriggerCharacters: R(
    new kt(126, "suggestOnTriggerCharacters", !0, {
      description: f(658, null),
    }),
  ),
  suggestSelection: R(
    new ne(
      127,
      "suggestSelection",
      "first",
      ["first", "recentlyUsed", "recentlyUsedByPrefix"],
      {
        markdownEnumDescriptions: [f(659, null), f(660, null), f(661, null)],
        description: f(662, null),
      },
    ),
  ),
  tabCompletion: R(
    new ne(128, "tabCompletion", "off", ["on", "off", "onlySnippets"], {
      enumDescriptions: [f(663, null), f(664, null), f(665, null)],
      description: f(666, null),
    }),
  ),
  tabIndex: R(new Wt(129, "tabIndex", 0, -1, 1073741824)),
  unicodeHighlight: R(new Iyt()),
  unusualLineTerminators: R(
    new ne(131, "unusualLineTerminators", "prompt", ["auto", "off", "prompt"], {
      enumDescriptions: [f(667, null), f(668, null), f(669, null)],
      description: f(670, null),
    }),
  ),
  useShadowDOM: R(new kt(132, "useShadowDOM", !0)),
  useTabStops: R(new kt(133, "useTabStops", !0, { description: f(671, null) })),
  wordBreak: R(
    new ne(134, "wordBreak", "normal", ["normal", "keepAll"], {
      markdownEnumDescriptions: [f(672, null), f(673, null)],
      description: f(674, null),
    }),
  ),
  wordSegmenterLocales: R(new Cyt()),
  wordSeparators: R(
    new _i(136, "wordSeparators", mK, { description: f(675, null) }),
  ),
  wordWrap: R(
    new ne(137, "wordWrap", "off", ["off", "on", "wordWrapColumn", "bounded"], {
      markdownEnumDescriptions: [
        f(676, null),
        f(677, null),
        f(678, null),
        f(679, null),
      ],
      description: f(680, null),
    }),
  ),
  wordWrapBreakAfterCharacters: R(
    new _i(
      138,
      "wordWrapBreakAfterCharacters",
      " 	})]?|/&.,;\xA2\xB0\u2032\u2033\u2030\u2103\u3001\u3002\uFF61\uFF64\uFFE0\uFF0C\uFF0E\uFF1A\uFF1B\uFF1F\uFF01\uFF05\u30FB\uFF65\u309D\u309E\u30FD\u30FE\u30FC\u30A1\u30A3\u30A5\u30A7\u30A9\u30C3\u30E3\u30E5\u30E7\u30EE\u30F5\u30F6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308E\u3095\u3096\u31F0\u31F1\u31F2\u31F3\u31F4\u31F5\u31F6\u31F7\u31F8\u31F9\u31FA\u31FB\u31FC\u31FD\u31FE\u31FF\u3005\u303B\uFF67\uFF68\uFF69\uFF6A\uFF6B\uFF6C\uFF6D\uFF6E\uFF6F\uFF70\u201D\u3009\u300B\u300D\u300F\u3011\u3015\uFF09\uFF3D\uFF5D\uFF63",
    ),
  ),
  wordWrapBreakBeforeCharacters: R(
    new _i(
      139,
      "wordWrapBreakBeforeCharacters",
      "([{\u2018\u201C\u3008\u300A\u300C\u300E\u3010\u3014\uFF08\uFF3B\uFF5B\uFF62\xA3\xA5\uFF04\uFFE1\uFFE5+\uFF0B",
    ),
  ),
  wordWrapColumn: R(
    new Wt(140, "wordWrapColumn", 80, 1, 1073741824, {
      markdownDescription: f(681, null),
    }),
  ),
  wordWrapOverride1: R(
    new ne(141, "wordWrapOverride1", "inherit", ["off", "on", "inherit"]),
  ),
  wordWrapOverride2: R(
    new ne(142, "wordWrapOverride2", "inherit", ["off", "on", "inherit"]),
  ),
  effectiveCursorStyle: R(new iyt()),
  editorClassName: R(new Qwt()),
  defaultColorDecorators: R(
    new ne(153, "defaultColorDecorators", "auto", ["auto", "always", "never"], {
      enumDescriptions: [f(682, null), f(683, null), f(684, null)],
      description: f(685, null),
    }),
  ),
  pixelRatio: R(new wyt()),
  tabFocusMode: R(
    new kt(150, "tabFocusMode", !1, { markdownDescription: f(686, null) }),
  ),
  layoutInfo: R(new oyt()),
  wrappingInfo: R(new Ryt()),
  wrappingIndent: R(new Lyt()),
  wrappingStrategy: R(new cyt()),
}
function cZ(i, t, e, r, s, a) {
  if (Array.isArray(i)) {
    let o = 0
    for (const c of i) {
      const u = cZ(c, t, e, r, s, a)
      if (u === 10) return u
      u > o && (o = u)
    }
    return o
  } else {
    if (typeof i == "string") return r ? (i === "*" ? 5 : i === e ? 10 : 0) : 0
    if (i) {
      const {
        language: o,
        pattern: c,
        scheme: u,
        hasAccessToAllModels: l,
        notebookType: m,
      } = i
      if (!r && !l) return 0
      m && s && (t = s)
      let h = 0
      if (u)
        if (u === t.scheme) h = 10
        else if (u === "*") h = 5
        else return 0
      if (o)
        if (o === e) h = 10
        else if (o === "*") h = Math.max(h, 5)
        else return 0
      if (m)
        if (m === a) h = 10
        else if (m === "*" && a !== void 0) h = Math.max(h, 5)
        else return 0
      if (c) {
        let p
        if (
          (typeof c == "string" ? (p = c) : (p = { ...c, base: lo(c.base) }),
          p === t.fsPath || al(p, t.fsPath))
        )
          h = 10
        else return 0
      }
      return h
    } else return 0
  }
}
function uZ(i) {
  return typeof i == "string"
    ? !1
    : Array.isArray(i)
      ? i.some(uZ)
      : !!i.notebookType
}
var TU
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Indent = 1)] = "Indent"),
    (i[(i.IndentOutdent = 2)] = "IndentOutdent"),
    (i[(i.Outdent = 3)] = "Outdent")
})(TU || (TU = {}))
var lZ
;(function (i) {
  ;(i.keyword = "keyword"), (i.vector = "vector")
})(lZ || (lZ = {}))
var dZ
;(function (i) {
  ;(i.OPEN = "open"), (i.CLOSED = "closed"), (i.MERGED = "merged")
})(dZ || (dZ = {}))
var mZ
;(function (i) {
  ;(i.TO_MAIN_FROM_BRANCH = "to_main_from_branch"), (i.TO_HEAD = "to_head")
})(mZ || (mZ = {}))
var hZ
;(function (i) {
  ;(i.Diff = "diff"), (i.Pr = "pr")
})(hZ || (hZ = {}))
var kU
;(function (i) {
  ;(i.Upload = "upload"), (i.Syncing = "syncing")
})(kU || (kU = {}))
var fZ
;(function (i) {
  ;(i.Hover = "Hover"),
    (i.Definition = "Definition"),
    (i.TypeDefinition = "TypeDefinition"),
    (i.Reference = "Reference"),
    (i.Implementation = "Implementation")
})(fZ || (fZ = {}))
var pZ
;(function (i) {
  ;(i.OK = "OK"),
    (i.ERROR = "ERROR"),
    (i.NO_CHANGES_FOUND = "NO_CHANGES_FOUND"),
    (i.NONE = "NONE")
})(pZ || (pZ = {}))
var gZ
;(function (i) {
  i.id = "local"
})(gZ || (gZ = {}))
var qyt = "x-client-key",
  Uyt = "x-ghost-mode",
  Myt = "x-session-id"
function Hyt(i) {
  if (i === !0) return "true"
  if (i === !1) return "false"
  if (i === void 0) return "implicit-false"
  {
    let t = i
    return (t = t), "true"
  }
}
function Wyt(i) {
  let t = 165
  for (let e = 0; e < i.length; e++) (i[e] = (i[e] ^ t) + (e % 256)), (t = i[e])
  return i
}
function jyt({
  req: i,
  machineId: t,
  macMachineId: e,
  base64Fn: r,
  cursorVersion: s,
  privacyMode: a,
  backupRequestId: o,
  clientKey: c,
  sessionId: u,
}) {
  try {
    const l = Math.floor(Date.now() / 1e6),
      m = new Uint8Array([
        (l >> 40) & 255,
        (l >> 32) & 255,
        (l >> 24) & 255,
        (l >> 16) & 255,
        (l >> 8) & 255,
        l & 255,
      ]),
      h = Wyt(m),
      p = r(h)
    i.header.set(
      "x-cursor-checksum",
      e === void 0 ? `${p}${t}` : `${p}${t}/${e}`,
    )
  } catch {}
  i.header.set("x-cursor-client-version", s),
    u !== void 0 && i.header.set(Myt, u),
    i.header.set(Uyt, Hyt(a)),
    c !== void 0 && i.header.set(qyt, c)
  try {
    const l = Intl.DateTimeFormat().resolvedOptions().timeZone
    i.header.set("x-cursor-timezone", l)
  } catch {}
  try {
    o &&
      (i.header.has("x-request-id") || i.header.set("x-request-id", o),
      i.header.has("x-amzn-trace-id") ||
        i.header.set("x-amzn-trace-id", `Root=${o}`))
  } catch {}
}
var vZ
;(function (i) {
  i.GetCachedServerConfig = "aiServerConfigService.getCachedServerConfig"
})(vZ || (vZ = {}))
var wZ
;(function (i) {
  ;(i.Ack = "editHistoryDiffFormatter.ack"),
    (i.GetModelValueInRanges =
      "editHistoryDiffFormatter.getModelValueInRanges"),
    (i.GetModelValue = "editHistoryDiffFormatter.getModelValue"),
    (i.ProcessModelChange = "editHistoryDiffFormatter.processModelChange"),
    (i.FormatDiffHistory = "editHistoryDiffFormatter.formatDiffHistory"),
    (i.CloseCurrentCmdkDiffHistoryPatch =
      "editHistoryDiffFormatter.closeCurrentCmdkDiffHistoryPatch"),
    (i.InitModel = "editHistoryDiffFormatter.initModel"),
    (i.CompileGlobalDiffTrajectories =
      "editHistoryDiffFormatter.compileGlobalDiffTrajectories"),
    (i.CompileGlobalDiffTrajectoriesForCmdk =
      "editHistoryDiffFormatter.compileGlobalDiffTrajectoriesForCmdk"),
    (i.IsRevertingToRecentModel =
      "editHistoryDiffFormatter.isRevertingToRecentModel"),
    (i.IsSuggestingRecentlyRejectedEdit =
      "editHistoryDiffFormatter.isSuggestingRecentlyRejectedEdit"),
    (i.RecordRejectedEdit = "editHistoryDiffFormatter.recordRejectedEdit"),
    (i.ProcessModelChangeLoop =
      "editHistoryDiffFormatter.processModelChangeLoop"),
    (i.SetEnableCppWhitespaceDiffHistoryMode =
      "editHistoryDiffFormatter.setEnableCppWhitespaceDiffHistoryMode"),
    (i.SetEnableCppIncludeUnchangedLines =
      "editHistoryDiffFormatter.setEnableCppIncludeUnchangedLines")
})(wZ || (wZ = {}))
var yZ
;(function (i) {
  i.GetExtHostInfo = "extHostInfo.getExtHostInfo"
})(yZ || (yZ = {}))
var TZ
;(function (i) {
  ;(i.GetFileSyncUpdates = "fileSync.getFileSyncUpdates"),
    (i.ShouldRelyOnFileSyncForFile = "fileSync.shouldRelyOnFileSyncForFile"),
    (i.GetFileSyncEncryptionHeader = "fileSync.getFileSyncEncryptionHeader"),
    (i.ResetSequentialSuccessfulSync = "fileSync.resetSequentialSuccessfulSync")
})(TZ || (TZ = {}))
var kZ
;(function (i) {
  ;(i.GetCommitNotes = "commitNotesService.getCommitNotes"),
    (i.SearchCommitNotes = "commitNotesService.searchCommitNotes"),
    (i.InitializeNotes = "commitNotesService.initialiezNotes")
})(kZ || (kZ = {}))
var SZ
;(function (i) {
  ;(i.GetRelatedFiles = "contextGraph.getRelatedFiles"),
    (i.InitializeWorkspace = "contextGraph.initializeWorkspace"),
    (i.GetWorkspaceSyncStatus = "contextGraph.getWorkspaceSyncStatus"),
    (i.ResetWorkspace = "contextGraph.resetWorkspace"),
    (i.GetRelatedFilesForLine = "contextGraph.getRelatedFilesForLine"),
    (i.GetRelatedFilesForRange = "contextGraph.getRelatedFilesForRange")
})(SZ || (SZ = {}))
var bZ
;(function (i) {
  i.GetDirectory = "fileRetrievalActions.readDirectory"
})(bZ || (bZ = {}))
var EZ
;(function (i) {
  ;(i.CheckClaudeAPIKey = "misc.checkClaudeAPIKey"),
    (i.CheckGoogleAPIKey = "misc.checkGoogleAPIKey")
})(EZ || (EZ = {}))
var IZ
;(function (i) {
  ;(i.GetReferencedSymbols = "treesitter.getReferencedSymbols"),
    (i.GetDefinedSymbols = "treesitter.getDefinedSymbols"),
    (i.GetImportantDefinitionNames = "treesitter.getImportantDefinitionNames")
})(IZ || (IZ = {}))
var PZ
;(function (i) {
  ;(i.GetRecentCommits = "git.getRecentCommits"),
    (i.GetRecentCommitHashesTouchingFile =
      "git.getRecentCommitHashesTouchingFile"),
    (i.GetCommitByHash = "git.getCommitByHash"),
    (i.GetCommitDetailsByHashes = "git.getCommitDetailsByHashes"),
    (i.GetCurrentIndexAndRecentCommits = "git.getCurrentIndexAndRecentCommits")
})(PZ || (PZ = {}))
var NZ
;(function (i) {
  i.GetFileImports = "lsp.getFileImports"
})(NZ || (NZ = {}))
var $Z
;(function (i) {
  ;(i.Get = "devOnlyRedis.get"),
    (i.Set = "devOnlyRedis.set"),
    (i.SubscribeToChannelForKey = "devOnlyRedis.subscribeToChannelForKey"),
    (i.UnsubscribeFromChannelForKey =
      "devOnlyRedis.unsubscribeFromChannelForKey")
})($Z || ($Z = {}))
var xZ
;(function (i) {
  i.ValueChanged = "devOnlyRedis.valueChanged"
})(xZ || (xZ = {}))
var JZ
;(function (i) {
  i.TakeScreenshot = "puppeteer.takeScreenshot"
})(JZ || (JZ = {}))
var CZ
;(function (i) {
  ;(i.ListTools = "mcp.listTools"),
    (i.CallTool = "mcp.callTool"),
    (i.CreateClient = "mcp.createClient"),
    (i.DeleteClient = "mcp.deleteClient")
})(CZ || (CZ = {}))
var LZ
;(function (i) {
  ;(i.Unknown = "unknown"),
    (i.LineChange = "line_change"),
    (i.Typing = "typing"),
    (i.OptionHold = "option_hold"),
    (i.LinterErrors = "lint_errors"),
    (i.ParameterHints = "parameter_hints"),
    (i.CursorPrediction = "cursor_prediction"),
    (i.ManualTrigger = "manual_trigger"),
    (i.EditorChange = "editor_change"),
    (i.LspSuggestions = "lsp_suggestions")
})(LZ || (LZ = {}))
var RZ
;(function (i) {
  ;(i.FREE = "free"),
    (i.PRO = "pro"),
    (i.ENTERPRISE = "enterprise"),
    (i.FREE_TRIAL = "free_trial")
})(RZ || (RZ = {}))
var DZ
;(function (i) {
  ;(i.Ack = "composerEditHistoryDiffFormatter.ack"),
    (i.CompileGlobalDiffTrajectories =
      "composerEditHistoryDiffFormatter.compileGlobalDiffTrajectories"),
    (i.FormatDiffHistory =
      "composerEditHistoryDiffFormatter.formatDiffHistory"),
    (i.InitModel = "composerEditHistoryDiffFormatter.initModel"),
    (i.ResetModel = "composerEditHistoryDiffFormatter.resetModel"),
    (i.ProcessModelChange =
      "composerEditHistoryDiffFormatter.processModelChange"),
    (i.GetModelValue = "composerEditHistoryDiffFormatter.getModelValue")
})(DZ || (DZ = {}))
var r2t = Y("editSessionIdentityService"),
  SU
;(function (i) {
  ;(i[(i.Complete = 100)] = "Complete"),
    (i[(i.Partial = 50)] = "Partial"),
    (i[(i.None = 0)] = "None")
})(SU || (SU = {}))
var Vyt = class {
    constructor(i) {
      ;(this.a = new Map()),
        (this.b = 0),
        (this.c = i.getProxy(z.MainThreadAiRelatedInformation))
    }
    async $provideAiRelatedInformation(i, t, e) {
      if (this.a.size === 0)
        throw new Error("No related information providers registered")
      const r = this.a.get(i)
      if (!r) throw new Error("related information provider not found")
      return (await r.provideRelatedInformation(t, e)) ?? []
    }
    getRelatedInformation(i, t, e) {
      return this.c.$getAiRelatedInformation(t, e)
    }
    registerRelatedInformationProvider(i, t, e) {
      const r = this.b
      return (
        this.b++,
        this.a.set(r, e),
        this.c.$registerAiRelatedInformationProvider(r, t),
        new At(() => {
          this.c.$unregisterAiRelatedInformationProvider(r), this.a.delete(r)
        })
      )
    }
  },
  FZ
;(function (i) {
  ;(i[(i.Full = 1)] = "Full"), (i[(i.Delta = 2)] = "Delta")
})(FZ || (FZ = {}))
function _Z(i) {
  for (let t = 0, e = i.length; t < e; t += 4) {
    const r = i[t + 0],
      s = i[t + 1],
      a = i[t + 2],
      o = i[t + 3]
    ;(i[t + 0] = o), (i[t + 1] = a), (i[t + 2] = s), (i[t + 3] = r)
  }
}
function Gyt(i) {
  const t = new Uint8Array(i.buffer, i.byteOffset, i.length * 4)
  return uW() || _Z(t), Et.wrap(t)
}
function zyt(i) {
  const t = i.buffer
  if ((uW() || _Z(t), t.byteOffset % 4 === 0))
    return new Uint32Array(t.buffer, t.byteOffset, t.length / 4)
  {
    const e = new Uint8Array(t.byteLength)
    return e.set(t), new Uint32Array(e.buffer, e.byteOffset, e.length / 4)
  }
}
function bU(i) {
  const t = new Uint32Array(Yyt(i))
  let e = 0
  if (((t[e++] = i.id), i.type === "full"))
    (t[e++] = 1),
      (t[e++] = i.data.length),
      t.set(i.data, e),
      (e += i.data.length)
  else {
    ;(t[e++] = 2), (t[e++] = i.deltas.length)
    for (const r of i.deltas)
      (t[e++] = r.start),
        (t[e++] = r.deleteCount),
        r.data
          ? ((t[e++] = r.data.length), t.set(r.data, e), (e += r.data.length))
          : (t[e++] = 0)
  }
  return Gyt(t)
}
function Yyt(i) {
  let t = 0
  if (((t += 2), i.type === "full")) t += 1 + i.data.length
  else {
    ;(t += 1), (t += 3 * i.deltas.length)
    for (const e of i.deltas) e.data && (t += e.data.length)
  }
  return t
}
function AZ(i) {
  const t = zyt(i)
  let e = 0
  const r = t[e++]
  if (t[e++] === 1) {
    const c = t[e++],
      u = t.subarray(e, e + c)
    return (e += c), { id: r, type: "full", data: u }
  }
  const a = t[e++],
    o = []
  for (let c = 0; c < a; c++) {
    const u = t[e++],
      l = t[e++],
      m = t[e++]
    let h
    m > 0 && ((h = t.subarray(e, e + m)), (e += m)),
      (o[c] = { start: u, deleteCount: l, data: h })
  }
  return { id: r, type: "delta", deltas: o }
}
var Qyt = [
    new pt(
      "vscode.executeDocumentHighlights",
      "_executeDocumentHighlights",
      "Execute document highlight provider.",
      [M.Uri, M.Position],
      new ht(
        "A promise that resolves to an array of DocumentHighlight-instances.",
        Br(nc.to),
      ),
    ),
    new pt(
      "vscode.executeDocumentSymbolProvider",
      "_executeDocumentSymbolProvider",
      "Execute document symbol provider.",
      [M.Uri],
      new ht(
        "A promise that resolves to an array of SymbolInformation and DocumentSymbol instances.",
        (i, t) => {
          if (nB(i)) return
          class e extends pl {
            static to(s) {
              const a = new e(
                s.name,
                mr.to(s.kind),
                s.containerName || "",
                new er(t[0], O.to(s.range)),
              )
              return (
                (a.detail = s.detail),
                (a.range = a.location.range),
                (a.selectionRange = O.to(s.selectionRange)),
                (a.children = s.children ? s.children.map(e.to) : []),
                a
              )
            }
          }
          return i.map(e.to)
        },
      ),
    ),
    new pt(
      "vscode.executeFormatDocumentProvider",
      "_executeFormatDocumentProvider",
      "Execute document format provider.",
      [
        M.Uri,
        new M(
          "options",
          "Formatting options",
          (i) => !0,
          (i) => i,
        ),
      ],
      new ht("A promise that resolves to an array of TextEdits.", Br(He.to)),
    ),
    new pt(
      "vscode.executeFormatRangeProvider",
      "_executeFormatRangeProvider",
      "Execute range format provider.",
      [
        M.Uri,
        M.Range,
        new M(
          "options",
          "Formatting options",
          (i) => !0,
          (i) => i,
        ),
      ],
      new ht("A promise that resolves to an array of TextEdits.", Br(He.to)),
    ),
    new pt(
      "vscode.executeFormatOnTypeProvider",
      "_executeFormatOnTypeProvider",
      "Execute format on type provider.",
      [
        M.Uri,
        M.Position,
        new M(
          "ch",
          "Trigger character",
          (i) => typeof i == "string",
          (i) => i,
        ),
        new M(
          "options",
          "Formatting options",
          (i) => !0,
          (i) => i,
        ),
      ],
      new ht("A promise that resolves to an array of TextEdits.", Br(He.to)),
    ),
    new pt(
      "vscode.executeDefinitionProvider",
      "_executeDefinitionProvider",
      "Execute all definition providers.",
      [M.Uri, M.Position],
      new ht(
        "A promise that resolves to an array of Location or LocationLink instances.",
        As,
      ),
    ),
    new pt(
      "vscode.experimental.executeDefinitionProvider_recursive",
      "_executeDefinitionProvider_recursive",
      "Execute all definition providers.",
      [M.Uri, M.Position],
      new ht(
        "A promise that resolves to an array of Location or LocationLink instances.",
        As,
      ),
    ),
    new pt(
      "vscode.executeTypeDefinitionProvider",
      "_executeTypeDefinitionProvider",
      "Execute all type definition providers.",
      [M.Uri, M.Position],
      new ht(
        "A promise that resolves to an array of Location or LocationLink instances.",
        As,
      ),
    ),
    new pt(
      "vscode.experimental.executeTypeDefinitionProvider_recursive",
      "_executeTypeDefinitionProvider_recursive",
      "Execute all type definition providers.",
      [M.Uri, M.Position],
      new ht(
        "A promise that resolves to an array of Location or LocationLink instances.",
        As,
      ),
    ),
    new pt(
      "vscode.executeDeclarationProvider",
      "_executeDeclarationProvider",
      "Execute all declaration providers.",
      [M.Uri, M.Position],
      new ht(
        "A promise that resolves to an array of Location or LocationLink instances.",
        As,
      ),
    ),
    new pt(
      "vscode.experimental.executeDeclarationProvider_recursive",
      "_executeDeclarationProvider_recursive",
      "Execute all declaration providers.",
      [M.Uri, M.Position],
      new ht(
        "A promise that resolves to an array of Location or LocationLink instances.",
        As,
      ),
    ),
    new pt(
      "vscode.executeImplementationProvider",
      "_executeImplementationProvider",
      "Execute all implementation providers.",
      [M.Uri, M.Position],
      new ht(
        "A promise that resolves to an array of Location or LocationLink instances.",
        As,
      ),
    ),
    new pt(
      "vscode.experimental.executeImplementationProvider_recursive",
      "_executeImplementationProvider_recursive",
      "Execute all implementation providers.",
      [M.Uri, M.Position],
      new ht(
        "A promise that resolves to an array of Location or LocationLink instances.",
        As,
      ),
    ),
    new pt(
      "vscode.executeReferenceProvider",
      "_executeReferenceProvider",
      "Execute all reference providers.",
      [M.Uri, M.Position],
      new ht(
        "A promise that resolves to an array of Location-instances.",
        Br(Ri.to),
      ),
    ),
    new pt(
      "vscode.experimental.executeReferenceProvider",
      "_executeReferenceProvider_recursive",
      "Execute all reference providers.",
      [M.Uri, M.Position],
      new ht(
        "A promise that resolves to an array of Location-instances.",
        Br(Ri.to),
      ),
    ),
    new pt(
      "vscode.executeHoverProvider",
      "_executeHoverProvider",
      "Execute all hover providers.",
      [M.Uri, M.Position],
      new ht(
        "A promise that resolves to an array of Hover-instances.",
        Br(Gl.to),
      ),
    ),
    new pt(
      "vscode.experimental.executeHoverProvider_recursive",
      "_executeHoverProvider_recursive",
      "Execute all hover providers.",
      [M.Uri, M.Position],
      new ht(
        "A promise that resolves to an array of Hover-instances.",
        Br(Gl.to),
      ),
    ),
    new pt(
      "vscode.executeSelectionRangeProvider",
      "_executeSelectionRangeProvider",
      "Execute selection range provider.",
      [
        M.Uri,
        new M(
          "position",
          "A position in a text document",
          (i) => Array.isArray(i) && i.every((t) => Lt.isPosition(t)),
          (i) => i.map(Gt.from),
        ),
      ],
      new ht("A promise that resolves to an array of ranges.", (i) =>
        i.map((t) => {
          let e
          for (const r of t.reverse()) e = new wl(O.to(r), e)
          return e
        }),
      ),
    ),
    new pt(
      "vscode.executeWorkspaceSymbolProvider",
      "_executeWorkspaceSymbolProvider",
      "Execute all workspace symbol providers.",
      [M.String.with("query", "Search string")],
      new ht(
        "A promise that resolves to an array of SymbolInformation-instances.",
        (i) => i.map(Ja.to),
      ),
    ),
    new pt(
      "vscode.prepareCallHierarchy",
      "_executePrepareCallHierarchy",
      "Prepare call hierarchy at a position inside a document",
      [M.Uri, M.Position],
      new ht(
        "A promise that resolves to an array of CallHierarchyItem-instances",
        (i) => i.map(Ca.to),
      ),
    ),
    new pt(
      "vscode.provideIncomingCalls",
      "_executeProvideIncomingCalls",
      "Compute incoming calls for an item",
      [M.CallHierarchyItem],
      new ht(
        "A promise that resolves to an array of CallHierarchyIncomingCall-instances",
        (i) => i.map(QO.to),
      ),
    ),
    new pt(
      "vscode.provideOutgoingCalls",
      "_executeProvideOutgoingCalls",
      "Compute outgoing calls for an item",
      [M.CallHierarchyItem],
      new ht(
        "A promise that resolves to an array of CallHierarchyOutgoingCall-instances",
        (i) => i.map(XO.to),
      ),
    ),
    new pt(
      "vscode.prepareRename",
      "_executePrepareRename",
      "Execute the prepareRename of rename provider.",
      [M.Uri, M.Position],
      new ht(
        "A promise that resolves to a range and placeholder text.",
        (i) => {
          if (i) return { range: O.to(i.range), placeholder: i.text }
        },
      ),
    ),
    new pt(
      "vscode.executeDocumentRenameProvider",
      "_executeDocumentRenameProvider",
      "Execute rename provider.",
      [M.Uri, M.Position, M.String.with("newName", "The new symbol name")],
      new ht("A promise that resolves to a WorkspaceEdit.", (i) => {
        if (i) {
          if (i.rejectReason) throw new Error(i.rejectReason)
          return bi.to(i)
        }
      }),
    ),
    new pt(
      "vscode.executeLinkProvider",
      "_executeLinkProvider",
      "Execute document link provider.",
      [
        M.Uri,
        M.Number.with(
          "linkResolveCount",
          "Number of links that should be resolved, only when links are unresolved.",
        ).optional(),
      ],
      new ht(
        "A promise that resolves to an array of DocumentLink-instances.",
        (i) => i.map(La.to),
      ),
    ),
    new pt(
      "vscode.provideDocumentSemanticTokensLegend",
      "_provideDocumentSemanticTokensLegend",
      "Provide semantic tokens legend for a document",
      [M.Uri],
      new ht("A promise that resolves to SemanticTokensLegend.", (i) => {
        if (i) return new TO(i.tokenTypes, i.tokenModifiers)
      }),
    ),
    new pt(
      "vscode.provideDocumentSemanticTokens",
      "_provideDocumentSemanticTokens",
      "Provide semantic tokens for a document",
      [M.Uri],
      new ht("A promise that resolves to SemanticTokens.", (i) => {
        if (!i) return
        const t = AZ(i)
        if (t.type === "full") return new Yo(t.data, void 0)
      }),
    ),
    new pt(
      "vscode.provideDocumentRangeSemanticTokensLegend",
      "_provideDocumentRangeSemanticTokensLegend",
      "Provide semantic tokens legend for a document range",
      [M.Uri, M.Range.optional()],
      new ht("A promise that resolves to SemanticTokensLegend.", (i) => {
        if (i) return new TO(i.tokenTypes, i.tokenModifiers)
      }),
    ),
    new pt(
      "vscode.provideDocumentRangeSemanticTokens",
      "_provideDocumentRangeSemanticTokens",
      "Provide semantic tokens for a document range",
      [M.Uri, M.Range],
      new ht("A promise that resolves to SemanticTokens.", (i) => {
        if (!i) return
        const t = AZ(i)
        if (t.type === "full") return new Yo(t.data, void 0)
      }),
    ),
    new pt(
      "vscode.executeCompletionItemProvider",
      "_executeCompletionItemProvider",
      "Execute completion item provider.",
      [
        M.Uri,
        M.Position,
        M.String.with(
          "triggerCharacter",
          "Trigger completion when the user types the character, like `,` or `(`",
        ).optional(),
        M.Number.with(
          "itemResolveCount",
          "Number of completions to resolve (too large numbers slow down completions)",
        ).optional(),
      ],
      new ht(
        "A promise that resolves to a CompletionList-instance.",
        (i, t, e) => {
          if (!i) return new Ao([])
          const r = i.suggestions.map((s) => iq.to(s, e))
          return new Ao(r, i.incomplete)
        },
      ),
    ),
    new pt(
      "vscode.executeSignatureHelpProvider",
      "_executeSignatureHelpProvider",
      "Execute signature help provider.",
      [
        M.Uri,
        M.Position,
        M.String.with(
          "triggerCharacter",
          "Trigger signature help when the user types the character, like `,` or `(`",
        ).optional(),
      ],
      new ht("A promise that resolves to SignatureHelp.", (i) => {
        if (i) return zl.to(i)
      }),
    ),
    new pt(
      "vscode.executeCodeLensProvider",
      "_executeCodeLensProvider",
      "Execute code lens provider.",
      [
        M.Uri,
        M.Number.with(
          "itemResolveCount",
          "Number of lenses that should be resolved and returned. Will only return resolved lenses, will impact performance)",
        ).optional(),
      ],
      new ht(
        "A promise that resolves to an array of CodeLens-instances.",
        (i, t, e) =>
          Br(
            (r) =>
              new d6(O.to(r.range), r.command && e.fromInternal(r.command)),
          )(i),
      ),
    ),
    new pt(
      "vscode.executeCodeActionProvider",
      "_executeCodeActionProvider",
      "Execute code action provider.",
      [
        M.Uri,
        new M(
          "rangeOrSelection",
          "Range in a text document. Some refactoring provider requires Selection object.",
          (i) => Nt.isRange(i),
          (i) => (Pn.isSelection(i) ? Cr.from(i) : O.from(i)),
        ),
        M.String.with(
          "kind",
          "Code action kind to return code actions for",
        ).optional(),
        M.Number.with(
          "itemResolveCount",
          "Number of code actions to resolve (too large numbers slow down code actions)",
        ).optional(),
      ],
      new ht(
        "A promise that resolves to an array of Command-instances.",
        (i, t, e) =>
          Br((r) => {
            if (r._isSynthetic) {
              if (!r.command)
                throw new Error("Synthetic code actions must have a command")
              return e.fromInternal(r.command)
            } else {
              const s = new l6(r.title, r.kind ? new ge(r.kind) : void 0)
              return (
                r.edit && (s.edit = bi.to(r.edit)),
                r.command && (s.command = e.fromInternal(r.command)),
                (s.isPreferred = r.isPreferred),
                s
              )
            }
          })(i),
      ),
    ),
    new pt(
      "vscode.executeDocumentColorProvider",
      "_executeDocumentColorProvider",
      "Execute document color provider.",
      [M.Uri],
      new ht(
        "A promise that resolves to an array of ColorInformation objects.",
        (i) => (i ? i.map((t) => new v6(O.to(t.range), sc.to(t.color))) : []),
      ),
    ),
    new pt(
      "vscode.executeColorPresentationProvider",
      "_executeColorPresentationProvider",
      "Execute color presentation provider.",
      [
        new M(
          "color",
          "The color to show and insert",
          (i) => i instanceof Mo,
          sc.from,
        ),
        new M(
          "context",
          "Context object with uri and range",
          (i) => !0,
          (i) => ({ uri: i.uri, range: O.from(i.range) }),
        ),
      ],
      new ht(
        "A promise that resolves to an array of ColorPresentation objects.",
        (i) => (i ? i.map(mA.to) : []),
      ),
    ),
    new pt(
      "vscode.executeInlayHintProvider",
      "_executeInlayHintProvider",
      "Execute inlay hints provider",
      [M.Uri, M.Range],
      new ht(
        "A promise that resolves to an array of Inlay objects",
        (i, t, e) => i.map(rq.to.bind(void 0, e)),
      ),
    ),
    new pt(
      "vscode.executeFoldingRangeProvider",
      "_executeFoldingRangeProvider",
      "Execute folding range provider",
      [M.Uri],
      new ht(
        "A promise that resolves to an array of FoldingRange objects",
        (i, t) => {
          if (i) return i.map(fA.to)
        },
      ),
    ),
    new pt(
      "vscode.resolveNotebookContentProviders",
      "_resolveNotebookContentProvider",
      "Resolve Notebook Content Providers",
      [],
      new ht(
        "A promise that resolves to an array of NotebookContentProvider static info objects.",
        Br((i) => ({
          viewType: i.viewType,
          displayName: i.displayName,
          options: {
            transientOutputs: i.options.transientOutputs,
            transientCellMetadata: i.options.transientCellMetadata,
            transientDocumentMetadata: i.options.transientDocumentMetadata,
          },
          filenamePattern: i.filenamePattern.map((t) => vA.to(t)),
        })),
      ),
    ),
    new pt(
      "vscode.executeInlineValueProvider",
      "_executeInlineValueProvider",
      "Execute inline value provider",
      [
        M.Uri,
        M.Range,
        new M(
          "context",
          "An InlineValueContext",
          (i) =>
            i &&
            typeof i.frameId == "number" &&
            i.stoppedLocation instanceof Nt,
          (i) => aA.from(i),
        ),
      ],
      new ht(
        "A promise that resolves to an array of InlineValue objects",
        (i) => i.map(sA.to),
      ),
    ),
    new pt(
      "vscode.open",
      "_workbench.open",
      "Opens the provided resource in the editor. Can be a text or binary file, or an http(s) URL. If you need more control over the options for opening a text file, use vscode.window.showTextDocument instead.",
      [
        new M(
          "uriOrString",
          "Uri-instance or string (only http/https)",
          (i) =>
            S.isUri(i) || (typeof i == "string" && Yot(i, Q.http, Q.https)),
          (i) => i,
        ),
        new M(
          "columnOrOptions",
          "Either the column in which to open or editor options, see vscode.TextDocumentShowOptions",
          (i) => i === void 0 || typeof i == "number" || typeof i == "object",
          (i) =>
            i &&
            (typeof i == "number"
              ? [Me.from(i), void 0]
              : [Me.from(i.viewColumn), Yl.from(i)]),
        ).optional(),
        M.String.with("label", "").optional(),
      ],
      ht.Void,
    ),
    new pt(
      "vscode.openWith",
      "_workbench.openWith",
      "Opens the provided resource with a specific editor.",
      [
        M.Uri.with("resource", "Resource to open"),
        M.String.with(
          "viewId",
          "Custom editor view id. This should be the viewType string for custom editors or the notebookType string for notebooks. Use 'default' to use VS Code's default text editor",
        ),
        new M(
          "columnOrOptions",
          "Either the column in which to open or editor options, see vscode.TextDocumentShowOptions",
          (i) => i === void 0 || typeof i == "number" || typeof i == "object",
          (i) =>
            i &&
            (typeof i == "number"
              ? [Me.from(i), void 0]
              : [Me.from(i.viewColumn), Yl.from(i)]),
        ).optional(),
      ],
      ht.Void,
    ),
    new pt(
      "vscode.diff",
      "_workbench.diff",
      "Opens the provided resources in the diff editor to compare their contents.",
      [
        M.Uri.with("left", "Left-hand side resource of the diff editor"),
        M.Uri.with("right", "Right-hand side resource of the diff editor"),
        M.String.with(
          "title",
          "Human readable title for the diff editor",
        ).optional(),
        new M(
          "columnOrOptions",
          "Either the column in which to open or editor options, see vscode.TextDocumentShowOptions",
          (i) => i === void 0 || typeof i == "object",
          (i) => i && [Me.from(i.viewColumn), Yl.from(i)],
        ).optional(),
      ],
      ht.Void,
    ),
    new pt(
      "vscode.changes",
      "_workbench.changes",
      "Opens a list of resources in the changes editor to compare their contents.",
      [
        M.String.with("title", "Human readable title for the changes editor"),
        new M(
          "resourceList",
          "List of resources to compare",
          (i) => {
            for (const t of i) {
              if (t.length !== 3) return !1
              const [e, r, s] = t
              if (
                !S.isUri(e) ||
                (!S.isUri(r) && r !== void 0 && r !== null) ||
                (!S.isUri(s) && s !== void 0 && s !== null)
              )
                return !1
            }
            return !0
          },
          (i) => i,
        ),
      ],
      ht.Void,
    ),
    new pt(
      "vscode.prepareTypeHierarchy",
      "_executePrepareTypeHierarchy",
      "Prepare type hierarchy at a position inside a document",
      [M.Uri, M.Position],
      new ht(
        "A promise that resolves to an array of TypeHierarchyItem-instances",
        (i) => i.map(Ra.to),
      ),
    ),
    new pt(
      "vscode.provideSupertypes",
      "_executeProvideSupertypes",
      "Compute supertypes for an item",
      [M.TypeHierarchyItem],
      new ht(
        "A promise that resolves to an array of TypeHierarchyItem-instances",
        (i) => i.map(Ra.to),
      ),
    ),
    new pt(
      "vscode.provideSubtypes",
      "_executeProvideSubtypes",
      "Compute subtypes for an item",
      [M.TypeHierarchyItem],
      new ht(
        "A promise that resolves to an array of TypeHierarchyItem-instances",
        (i) => i.map(Ra.to),
      ),
    ),
    new pt(
      "vscode.revealTestInExplorer",
      "_revealTestInExplorer",
      "Reveals a test instance in the explorer",
      [M.TestItem],
      ht.Void,
    ),
    new pt(
      "vscode.startContinuousTestRun",
      "testing.startContinuousRunFromExtension",
      "Starts running the given tests with continuous run mode.",
      [M.TestProfile, M.Arr(M.TestItem)],
      ht.Void,
    ),
    new pt(
      "vscode.stopContinuousTestRun",
      "testing.stopContinuousRunFromExtension",
      "Stops running the given tests with continuous run mode.",
      [M.Arr(M.TestItem)],
      ht.Void,
    ),
    new pt(
      "vscode.experimental.editSession.continue",
      "_workbench.editSessions.actions.continueEditSession",
      "Continue the current edit session in a different workspace",
      [
        M.Uri.with(
          "workspaceUri",
          "The target workspace to continue the current edit session in",
        ),
      ],
      ht.Void,
    ),
    new pt(
      "setContext",
      "_setContext",
      "Set a custom context key value that can be used in when clauses.",
      [
        M.String.with("name", "The context key name"),
        new M(
          "value",
          "The context key value",
          () => !0,
          (i) => i,
        ),
      ],
      ht.Void,
    ),
    new pt(
      "vscode.executeMappedEditsProvider",
      "_executeMappedEditsProvider",
      "Execute Mapped Edits Provider",
      [
        M.Uri,
        M.StringArray,
        new M(
          "MappedEditsContext",
          "Mapped Edits Context",
          (i) => gA.is(i),
          (i) => gA.from(i),
        ),
      ],
      new ht("A promise that resolves to a workspace edit or null", (i) =>
        i ? bi.to(i) : null,
      ),
    ),
    new pt(
      "vscode.editorChat.start",
      "inlineChat.start",
      "Invoke a new editor chat session",
      [
        new M(
          "Run arguments",
          "",
          (i) => !0,
          (i) => {
            if (i)
              return {
                initialRange: i.initialRange ? O.from(i.initialRange) : void 0,
                initialSelection: Pn.isSelection(i.initialSelection)
                  ? Cr.from(i.initialSelection)
                  : void 0,
                message: i.message,
                autoSend: i.autoSend,
                position: i.position ? Gt.from(i.position) : void 0,
              }
          },
        ),
      ],
      ht.Void,
    ),
  ],
  Xyt = class {
    static register(i) {
      Qyt.forEach(i.registerApiCommand, i), this.a(i)
    }
    static a(i) {
      i.registerCommand(!1, "_validateWhenClauses", jct)
    }
  }
function Br(i) {
  return (t) => {
    if (Array.isArray(t)) return t.map(i)
  }
}
function As(i) {
  if (!Array.isArray(i)) return
  const t = []
  for (const e of i) vlt(e) ? t.push(Vl.to(e)) : t.push(Ri.to(e))
  return t
}
var EU = class {
  constructor(t, e) {
    ;(this.a = t.getProxy(z.MainThreadBulkEdits)),
      (this.b = {
        getTextDocumentVersion: (r) => e.getDocument(r)?.version,
        getNotebookDocumentVersion: () => {},
      })
  }
  applyWorkspaceEdit(t, e, r) {
    const s = new Xi(bi.from(t, this.b))
    return this.a.$tryApplyWorkspaceEdit(s, void 0, r?.isRefactoring ?? !1)
  }
}
EU = __decorate([__param(0, Vt)], EU)
var BZ
;(function (i) {
  ;(i[(i.Complete = 1)] = "Complete"),
    (i[(i.Partial = 2)] = "Partial"),
    (i[(i.Omitted = 3)] = "Omitted")
})(BZ || (BZ = {}))
var F7
;(function (i) {
  ;(i[(i.Down = 0)] = "Down"), (i[(i.Up = 1)] = "Up")
})(F7 || (F7 = {}))
var OZ
;(function (i) {
  ;(i.IncorrectCode = "incorrectCode"),
    (i.DidNotFollowInstructions = "didNotFollowInstructions"),
    (i.IncompleteCode = "incompleteCode"),
    (i.MissingContext = "missingContext"),
    (i.PoorlyWrittenOrFormatted = "poorlyWrittenOrFormatted"),
    (i.RefusedAValidRequest = "refusedAValidRequest"),
    (i.OffensiveOrUnsafe = "offensiveOrUnsafe"),
    (i.Other = "other"),
    (i.WillReportIssue = "willReportIssue")
})(OZ || (OZ = {}))
var qZ
;(function (i) {
  ;(i[(i.Action = 1)] = "Action"), (i[(i.Toolbar = 2)] = "Toolbar")
})(qZ || (qZ = {}))
var s2t = Y("IChatService")
function Kyt(i) {
  return !!i && typeof i.sessionId == "string" && i.$mid === 19
}
var Zyt = class {
    constructor(i, t, e, r, s) {
      ;(this.j = i),
        (this.k = t),
        (this.l = e),
        (this.m = r),
        (this.n = s),
        (this.b = Ys.create(!1)),
        (this.c = !1)
    }
    close() {
      this.c = !0
    }
    get timings() {
      return { firstProgress: this.d, totalElapsed: this.b.elapsed() }
    }
    get apiObject() {
      if (!this.g) {
        let t = function (s) {
          if (e.c) {
            const a = new Error("Response stream has been closed")
            throw (Error.captureStackTrace(a, s), a)
          }
        }
        var i = t
        const e = this
        this.b.reset()
        const r = (s, a) => {
          if (
            (typeof this.d > "u" &&
              (s.kind === "markdownContent" || s.kind === "markdownVuln") &&
              (this.d = this.b.elapsed()),
            a)
          ) {
            const o = this.l.$handleProgressChunk(this.k.requestId, s),
              c = {
                report: (u) => {
                  o?.then((l) => {
                    l &&
                      (Gi.isMarkdownString(u.value)
                        ? this.l.$handleProgressChunk(
                            this.k.requestId,
                            id.from(u),
                            l,
                          )
                        : this.l.$handleProgressChunk(
                            this.k.requestId,
                            Ln.from(u),
                            l,
                          ))
                  })
                },
              }
            Promise.all([o, a?.(c)]).then(([u, l]) => {
              u !== void 0 &&
                this.l.$handleProgressChunk(this.k.requestId, gq.from(l), u)
            })
          } else this.l.$handleProgressChunk(this.k.requestId, s)
        }
        this.g = Object.freeze({
          markdown(s) {
            t(this.markdown)
            const a = new V6(s),
              o = td.from(a)
            return r(o), this
          },
          markdownWithVulnerabilities(s, a) {
            t(this.markdown), a && F(e.j, "chatParticipantAdditions")
            const o = new Bl(s, a),
              c = bA.from(o)
            return r(c), this
          },
          codeblockUri(s) {
            t(this.codeblockUri), F(e.j, "chatParticipantAdditions")
            const a = new X6(s),
              o = SA.from(a)
            return r(o), this
          },
          filetree(s, a) {
            t(this.filetree)
            const o = new z6(s, a),
              c = ed.from(o)
            return r(c), this
          },
          anchor(s, a) {
            const o = new ql(s, a)
            return this.push(o)
          },
          button(s) {
            t(this.anchor)
            const a = new Q6(s),
              o = rd.from(a, e.m, e.n)
            return r(o), this
          },
          progress(s, a) {
            t(this.progress)
            const o = new Y6(s, a),
              c = a ? PA.from(o) : Da.from(o)
            return r(c, a), this
          },
          warning(s) {
            t(this.progress), F(e.j, "chatParticipantAdditions")
            const a = new Ml(s),
              o = id.from(a)
            return r(o), this
          },
          reference(s, a) {
            return this.reference2(s, a)
          },
          reference2(s, a, o) {
            if (
              (t(this.reference),
              typeof s == "object" &&
                "variableName" in s &&
                F(e.j, "chatParticipantAdditions"),
              typeof s == "object" && "variableName" in s && !s.value)
            ) {
              const c = e.k.variables.variables.find(
                (u) => u.name === s.variableName,
              )
              if (c) {
                let u
                if (c.references?.length)
                  u = c.references.map((l) => ({
                    kind: "reference",
                    reference: {
                      variableName: s.variableName,
                      value: l.reference,
                    },
                  }))
                else {
                  const l = new xn(s, a, o)
                  u = [Ln.from(l)]
                }
                return u.forEach((l) => r(l)), this
              }
            } else {
              const c = new xn(s, a, o),
                u = Ln.from(c)
              r(u)
            }
            return this
          },
          codeCitation(s, a, o) {
            t(this.codeCitation), F(e.j, "chatParticipantAdditions")
            const c = new K6(s, a, o),
              u = $A.from(c)
            r(u)
          },
          textEdit(s, a) {
            t(this.textEdit), F(e.j, "chatParticipantAdditions")
            const o = new Hl(s, Array.isArray(a) ? a : [])
            o.isDone = a === !0 ? !0 : void 0
            const c = NA.from(o)
            return r(c), this
          },
          detectedParticipant(s, a) {
            t(this.detectedParticipant), F(e.j, "chatParticipantAdditions")
            const o = new Ol(s, a),
              c = EA.from(o)
            return r(c), this
          },
          confirmation(s, a, o, c) {
            t(this.confirmation), F(e.j, "chatParticipantAdditions")
            const u = new G6(s, a, o, c),
              l = IA.from(u)
            return r(l), this
          },
          push(s) {
            if (
              (t(this.push),
              (s instanceof Hl ||
                s instanceof Bl ||
                s instanceof Ol ||
                s instanceof Ml ||
                s instanceof G6 ||
                s instanceof K6 ||
                s instanceof Z6 ||
                s instanceof Y6) &&
                F(e.j, "chatParticipantAdditions"),
              s instanceof xn)
            )
              this.reference2(s.value, s.iconPath, s.options)
            else if (s instanceof Y6) {
              const a = s.task ? PA.from(s) : Da.from(s)
              r(a, s.task)
            } else if (s instanceof ql) {
              const a = fc.from(s)
              if (s.resolve) {
                F(e.j, "chatParticipantAdditions"), (a.resolveId = Ki())
                const o = new Ie()
                s
                  .resolve(o.token)
                  .then(() => {
                    const c = fc.from(s)
                    e.l.$handleAnchorResolve(e.k.requestId, a.resolveId, c)
                  })
                  .then(
                    () => o.dispose(),
                    () => o.dispose(),
                  ),
                  e.n.add(it(() => o.dispose(!0)))
              }
              r(a)
            } else {
              const a = xA.from(s, e.m, e.n)
              r(a)
            }
            return this
          },
        })
      }
      return this.g
    }
  },
  t0t = class q1 extends dt {
    static {
      this.b = 0
    }
    static {
      this.j = 0
    }
    static {
      this.n = 0
    }
    constructor(t, e, r, s, a) {
      super(),
        (this.u = e),
        (this.w = r),
        (this.y = s),
        (this.z = a),
        (this.c = new Map()),
        (this.m = new Map()),
        (this.q = new Map()),
        (this.s = this.D(new uB())),
        (this.t = this.D(new uB())),
        (this.g = t.getProxy(z.MainThreadChatAgents2)),
        r.registerArgumentProcessor({
          processArgument: (o) => (Kyt(o) ? null : o),
        })
    }
    transferActiveChat(t) {
      this.g.$transferActiveChatSession(t)
    }
    createChatAgent(t, e, r) {
      const s = q1.b++,
        a = new UZ(t, e, this.g, s, r)
      return (
        this.c.set(s, a),
        this.g.$registerAgent(s, t.identifier, e, {}, void 0),
        a.apiAgent
      )
    }
    createDynamicChatAgent(t, e, r, s) {
      const a = q1.b++,
        o = new UZ(t, e, this.g, a, s)
      return (
        this.c.set(a, o),
        this.g.$registerAgent(a, t.identifier, e, { isSticky: !0 }, r),
        o.apiAgent
      )
    }
    registerChatParticipantDetectionProvider(t, e) {
      const r = q1.j++
      return (
        this.m.set(r, new e0t(t, e)),
        this.g.$registerChatParticipantDetectionProvider(r),
        it(() => {
          this.m.delete(r),
            this.g.$unregisterChatParticipantDetectionProvider(r)
        })
      )
    }
    registerRelatedFilesProvider(t, e, r) {
      const s = q1.n++
      return (
        this.q.set(s, new i0t(t, e)),
        this.g.$registerRelatedFilesProvider(s, r),
        it(() => {
          this.q.delete(s), this.g.$unregisterRelatedFilesProvider(s)
        })
      )
    }
    async $provideRelatedFiles(t, e, r) {
      const s = this.q.get(t)
      if (!s) return Promise.resolve([])
      const a = vq.to(e)
      return (await s.provider.provideRelatedFiles(a, r)) ?? void 0
    }
    async $detectChatParticipant(t, e, r, s, a) {
      const { request: o, location: c, history: u } = await this.C(e, r),
        l = this.m.get(t)
      if (!l) return
      const m = await this.F(o, l.extension),
        h = JA.to(o, c, m)
      return l.provider.provideParticipantDetection(
        h,
        { history: u },
        { participants: s.participants, location: nd.to(s.location) },
        a,
      )
    }
    async C(t, e) {
      const r = $i(t),
        s = await this.G(r.agentId, e)
      let a
      if (r.locationData?.type === li.Editor) {
        const o = this.y.getDocument(r.locationData.document)
        a = new wY(
          o,
          Cr.to(r.locationData.selection),
          O.to(r.locationData.wholeRange),
        )
      } else if (r.locationData?.type === li.Notebook) {
        const o = this.y.getDocument(r.locationData.sessionInputUri)
        a = new yY(o)
      } else r.locationData?.type, li.Terminal
      return { request: r, location: a, history: s }
    }
    async F(t, e) {
      let r
      if (
        (t.userSelectedModelId &&
          (r = await this.z.getLanguageModelByIdentifier(
            e,
            t.userSelectedModelId,
          )),
        !r && ((r = await this.z.getDefaultLanguageModel(e)), !r))
      )
        throw new Error("Language model unavailable")
      return r
    }
    async $invokeAgent(t, e, r, s) {
      const a = this.c.get(t)
      if (!a)
        throw new Error(
          `[CHAT](${t}) CANNOT invoke agent because the agent is not registered`,
        )
      let o
      try {
        const { request: c, location: u, history: l } = await this.C(e, r)
        let m = this.s.get(c.sessionId)
        m || ((m = new bt()), this.s.set(c.sessionId, m)),
          (o = new Zyt(a.extension, c, this.g, this.w.converter, m))
        const h = await this.F(c, a.extension),
          p = JA.to(c, u, h),
          g = a.invoke(p, { history: l }, o.apiObject, s)
        return await rj(
          Promise.resolve(g).then((w) => {
            if (w?.metadata)
              try {
                JSON.stringify(w.metadata)
              } catch (b) {
                const N = `result.metadata MUST be JSON.stringify-able. Got error: ${b.message}`
                return (
                  this.u.error(
                    `[${a.extension.identifier.value}] [@${a.id}] ${N}`,
                    a.extension,
                  ),
                  {
                    errorDetails: { message: N },
                    timings: o?.timings,
                    nextQuestion: w.nextQuestion,
                  }
                )
              }
            let T
            return (
              w?.errorDetails &&
                (T = { ...w.errorDetails, responseIsIncomplete: !0 }),
              (T?.responseIsRedacted || T?.isQuotaExceeded) &&
                F(a.extension, "chatParticipantPrivate"),
              {
                errorDetails: T,
                timings: o?.timings,
                metadata: w?.metadata,
                nextQuestion: w?.nextQuestion,
              }
            )
          }),
          s,
        )
      } catch (c) {
        this.u.error(c, a.extension),
          c instanceof Jn && c.cause && (c = c.cause)
        const u = c instanceof Error && c.name === "ChatQuotaExceeded"
        return {
          errorDetails: {
            message: ea(c),
            responseIsIncomplete: !0,
            isQuotaExceeded: u,
          },
        }
      } finally {
        o?.close()
      }
    }
    async G(t, e) {
      const r = []
      for (const s of e.history) {
        const a = Es.to(s.result),
          o = t === s.request.agentId ? a : { ...a, metadata: void 0 },
          c = s.request.variables.variables.filter((h) => !h.isTool).map(CA.to),
          u = s.request.variables.variables.filter((h) => h.isTool).map(LA.to),
          l = new gY(
            s.request.message,
            s.request.command,
            c,
            s.request.agentId,
            u,
          )
        r.push(l)
        const m = Ge(s.response.map((h) => xA.toContent(h, this.w.converter)))
        r.push(new vY(m, o, s.request.agentId, s.request.command))
      }
      return r
    }
    $releaseSession(t) {
      this.s.deleteAndDispose(t)
    }
    async $provideFollowups(t, e, r, s, a) {
      const o = this.c.get(e)
      if (!o) return Promise.resolve([])
      const c = $i(t),
        u = await this.G(o.id, s),
        l = Es.to(r)
      return (await o.provideFollowups(l, { history: u }, a))
        .filter((m) => {
          const h =
            !m.participant ||
            Yi.some(
              this.c.values(),
              (p) =>
                p.id === m.participant &&
                te.equals(p.extension.identifier, o.extension.identifier),
            )
          return (
            h ||
              this.u.warn(
                `[@${o.id}] ChatFollowup refers to an unknown participant: ${m.participant}`,
              ),
            h
          )
        })
        .map((m) => Zl.from(m, c))
    }
    $acceptFeedback(t, e, r) {
      const s = this.c.get(t)
      if (!s) return
      const a = Es.to(e)
      let o
      switch (r.direction) {
        case F7.Down:
          o = Al.Unhelpful
          break
        case F7.Up:
          o = Al.Helpful
          break
      }
      const c = {
        result: a,
        kind: o,
        unhelpfulReason: Qe(s.extension, "chatParticipantAdditions")
          ? r.reason
          : void 0,
      }
      s.acceptFeedback(Object.freeze(c))
    }
    $acceptAction(t, e, r) {
      const s = this.c.get(t)
      if (!s || r.action.kind === "vote") return
      const a = yq.to(e, r, this.w.converter)
      a && s.acceptAction(Object.freeze(a))
    }
    async $invokeCompletionProvider(t, e, r) {
      const s = this.c.get(t)
      if (!s) return []
      let a = this.t.get(t)
      return (
        a ? a.clear() : ((a = new bt()), this.t.set(t, a)),
        (await s.invokeCompletionProvider(e, r)).map((c) =>
          wq.from(c, this.w.converter, a),
        )
      )
    }
    async $provideWelcomeMessage(t, e) {
      const r = this.c.get(t)
      if (r) return await r.provideWelcomeMessage(e)
    }
    async $provideChatTitle(t, e, r) {
      const s = this.c.get(t)
      if (!s) return
      const a = await this.G(s.id, { history: e })
      return await s.provideTitle({ history: a }, r)
    }
    async $provideSampleQuestions(t, e, r) {
      const s = this.c.get(t)
      if (s)
        return (await s.provideSampleQuestions(nd.to(e), r)).map((a) =>
          Zl.from(a, void 0),
        )
    }
  },
  e0t = class {
    constructor(i, t) {
      ;(this.extension = i), (this.provider = t)
    }
  },
  i0t = class {
    constructor(i, t) {
      ;(this.extension = i), (this.provider = t)
    }
  },
  UZ = class {
    constructor(i, t, e, r, s) {
      ;(this.extension = i),
        (this.id = t),
        (this.w = e),
        (this.x = r),
        (this.y = s),
        (this.l = new C()),
        (this.m = new C())
    }
    acceptFeedback(i) {
      this.l.fire(i)
    }
    acceptAction(i) {
      this.m.fire(i)
    }
    async invokeCompletionProvider(i, t) {
      return this.o
        ? ((await this.o.provider.provideCompletionItems(i, t)) ?? [])
        : []
    }
    async provideFollowups(i, t, e) {
      if (!this.b) return []
      const r = await this.b.provideFollowups(i, t, e)
      return r
        ? r
            .filter((s) => !(s && "commandId" in s))
            .filter((s) => !(s && "message" in s))
        : []
    }
    async provideWelcomeMessage(i) {
      if (!this.q?.provideWelcomeMessage) return
      const t = await this.q.provideWelcomeMessage(i),
        e = t?.icon
      if (!(!t || !ri.isThemeIcon(e)))
        return { ...t, icon: e, message: Jt.from(t.message) }
    }
    async provideTitle(i, t) {
      if (this.s) return (await this.s.provideChatTitle(i, t)) ?? void 0
    }
    async provideSampleQuestions(i, t) {
      if (!this.q || !this.q.provideSampleQuestions) return []
      const e = await this.q.provideSampleQuestions(i, t)
      return e || []
    }
    get apiAgent() {
      let i = !1,
        t = !1
      const e = () => {
          i ||
            t ||
            ((t = !0),
            queueMicrotask(() => {
              this.w.$updateAgent(this.x, {
                icon: this.c
                  ? this.c instanceof S
                    ? this.c
                    : "light" in this.c
                      ? this.c.light
                      : void 0
                  : void 0,
                iconDark: this.c && "dark" in this.c ? this.c.dark : void 0,
                themeIcon: this.c instanceof Si ? this.c : void 0,
                hasFollowups: this.b !== void 0,
                isSecondary: this.k,
                helpTextPrefix:
                  !this.d || typeof this.d == "string"
                    ? this.d
                    : Jt.from(this.d),
                helpTextVariablesPrefix:
                  !this.g || typeof this.g == "string"
                    ? this.g
                    : Jt.from(this.g),
                helpTextPostfix:
                  !this.j || typeof this.j == "string"
                    ? this.j
                    : Jt.from(this.j),
                supportIssueReporting: this.n,
                requester: this.t,
                supportsSlowVariables: this.u,
              }),
                (t = !1)
            }))
        },
        r = this
      return {
        get id() {
          return r.id
        },
        get iconPath() {
          return r.c
        },
        set iconPath(s) {
          ;(r.c = s), e()
        },
        get requestHandler() {
          return r.y
        },
        set requestHandler(s) {
          VW(typeof s == "function", "Invalid request handler"), (r.y = s)
        },
        get followupProvider() {
          return r.b
        },
        set followupProvider(s) {
          ;(r.b = s), e()
        },
        get helpTextPrefix() {
          return F(r.extension, "defaultChatParticipant"), r.d
        },
        set helpTextPrefix(s) {
          F(r.extension, "defaultChatParticipant"), (r.d = s), e()
        },
        get helpTextVariablesPrefix() {
          return F(r.extension, "defaultChatParticipant"), r.g
        },
        set helpTextVariablesPrefix(s) {
          F(r.extension, "defaultChatParticipant"), (r.g = s), e()
        },
        get helpTextPostfix() {
          return F(r.extension, "defaultChatParticipant"), r.j
        },
        set helpTextPostfix(s) {
          F(r.extension, "defaultChatParticipant"), (r.j = s), e()
        },
        get isSecondary() {
          return F(r.extension, "defaultChatParticipant"), r.k
        },
        set isSecondary(s) {
          F(r.extension, "defaultChatParticipant"), (r.k = s), e()
        },
        get supportIssueReporting() {
          return F(r.extension, "chatParticipantPrivate"), r.n
        },
        set supportIssueReporting(s) {
          F(r.extension, "chatParticipantPrivate"), (r.n = s), e()
        },
        get onDidReceiveFeedback() {
          return r.l.event
        },
        set participantVariableProvider(s) {
          if ((F(r.extension, "chatParticipantAdditions"), (r.o = s), s)) {
            if (!s.triggerCharacters.length)
              throw new Error("triggerCharacters are required")
            r.w.$registerAgentCompletionsProvider(
              r.x,
              r.id,
              s.triggerCharacters,
            )
          } else r.w.$unregisterAgentCompletionsProvider(r.x, r.id)
        },
        get participantVariableProvider() {
          return F(r.extension, "chatParticipantAdditions"), r.o
        },
        set welcomeMessageProvider(s) {
          F(r.extension, "defaultChatParticipant"), (r.q = s), e()
        },
        get welcomeMessageProvider() {
          return F(r.extension, "defaultChatParticipant"), r.q
        },
        set titleProvider(s) {
          F(r.extension, "defaultChatParticipant"), (r.s = s), e()
        },
        get titleProvider() {
          return F(r.extension, "defaultChatParticipant"), r.s
        },
        onDidPerformAction: Qe(this.extension, "chatParticipantAdditions")
          ? this.m.event
          : void 0,
        set requester(s) {
          ;(r.t = s), e()
        },
        get requester() {
          return r.t
        },
        set supportsSlowReferences(s) {
          F(r.extension, "chatParticipantPrivate"), (r.u = s), e()
        },
        get supportsSlowReferences() {
          return F(r.extension, "chatParticipantPrivate"), r.u
        },
        dispose() {
          ;(i = !0), (r.b = void 0), r.l.dispose(), r.w.$unregisterAgent(r.x)
        },
      }
    }
    invoke(i, t, e, r) {
      return this.y(i, t, e, r)
    }
  },
  r0t = class ist {
    static {
      this.a = 0
    }
    constructor(t) {
      ;(this.b = new Map()), (this.c = t.getProxy(z.MainThreadChatVariables))
    }
    async $resolveVariable(t, e, r, s) {
      const a = this.b.get(t)
      if (a)
        try {
          if (a.resolver.resolve2) {
            F(a.extension, "chatParticipantAdditions")
            const o = new n0t(e, this.c),
              c = await a.resolver.resolve2(
                a.data.name,
                { prompt: r },
                o.apiObject,
                s,
              )
            if (c && c[0]) return c[0].value
          } else {
            const o = await a.resolver.resolve(a.data.name, { prompt: r }, s)
            if (o && o[0]) return o[0].value
          }
        } catch (o) {
          eB(o)
        }
    }
    registerVariableResolver(t, e, r, s, a, o, c, u, l) {
      const m = ist.a++,
        h = l ? ri.fromId(l) : void 0
      return (
        this.b.set(m, {
          extension: t,
          data: {
            id: e,
            name: r,
            description: s,
            modelDescription: a,
            icon: h,
          },
          resolver: c,
        }),
        this.c.$registerVariable(m, {
          id: e,
          name: r,
          description: s,
          modelDescription: a,
          isSlow: o,
          fullName: u,
          icon: h,
        }),
        it(() => {
          this.b.delete(m), this.c.$unregisterVariable(m)
        })
      )
    }
  },
  n0t = class {
    constructor(i, t) {
      ;(this.c = i), (this.d = t), (this.a = !1)
    }
    close() {
      this.a = !0
    }
    get apiObject() {
      if (!this.b) {
        let t = function (s) {
          if (e.a) {
            const a = new Error("Response stream has been closed")
            throw (Error.captureStackTrace(a, s), a)
          }
        }
        var i = t
        const e = this,
          r = (s) => {
            this.d.$handleProgressChunk(this.c, s)
          }
        this.b = {
          progress(s) {
            t(this.progress)
            const a = new Ul(s),
              o = Da.from(a)
            return r(o), this
          },
          reference(s) {
            t(this.reference)
            const a = new xn(s),
              o = Ln.from(a)
            return r(o), this
          },
          push(s) {
            return (
              t(this.push),
              s instanceof xn
                ? r(Ln.from(s))
                : s instanceof Ul && r(Da.from(s)),
              this
            )
          },
        }
      }
      return this.b
    }
  },
  s0t = class {
    constructor(i) {
      const t = i.getProxy(z.MainThreadClipboard)
      this.value = Object.freeze({
        readText() {
          return t.$readText()
        },
        writeText(e) {
          return t.$writeText(e)
        },
      })
    }
  },
  MZ = "vscode-cdn.net",
  a0t = `vscode-resource.${MZ}`,
  IU = `'self' https://*.${MZ}`
function Xd(i, t) {
  return i.scheme === Q.http || i.scheme === Q.https
    ? i
    : (t &&
        t.authority &&
        t.isRemote &&
        i.scheme === Q.file &&
        (i = S.from({
          scheme: Q.vscodeRemote,
          authority: t.authority,
          path: i.path,
        })),
      S.from({
        scheme: Q.https,
        authority: `${i.scheme}+${o0t(i.authority)}.${a0t}`,
        path: i.path,
        fragment: i.fragment,
        query: i.query,
      }))
}
function o0t(i) {
  return i.replace(/./g, (t) => {
    const e = t.charCodeAt(0)
    return (e >= 97 && e <= 122) || (e >= 65 && e <= 90) || (e >= 48 && e <= 57)
      ? t
      : "-" + e.toString(16).padStart(4, "0")
  })
}
var c0t = class {
  constructor(i, t, e) {
    ;(this.d = i),
      (this.e = t),
      (this.f = e),
      (this.a = 0),
      (this.b = new bt()),
      (this.c = new Map()),
      this.b.add(
        t.onDidChangeVisibleTextEditors(() => {
          const r = t.getVisibleTextEditors()
          for (const s of this.c.values())
            r.indexOf(s.editor) < 0 && s.inset.dispose()
        }),
      )
  }
  dispose() {
    this.c.forEach((i) => i.inset.dispose()), this.b.dispose()
  }
  createWebviewEditorInset(i, t, e, r, s) {
    let a
    for (const p of this.e.getVisibleTextEditors(!0))
      if (p.value === i) {
        a = p
        break
      }
    if (!a) throw new Error("not a visible editor")
    const o = this,
      c = this.a++,
      u = new C(),
      l = new C(),
      m = new (class {
        constructor() {
          ;(this.a = ""), (this.b = Object.create(null))
        }
        asWebviewUri(p) {
          return Xd(p, o.f)
        }
        get cspSource() {
          return IU
        }
        set options(p) {
          ;(this.b = p), o.d.$setOptions(c, p)
        }
        get options() {
          return this.b
        }
        set html(p) {
          ;(this.a = p), o.d.$setHtml(c, p)
        }
        get html() {
          return this.a
        }
        get onDidReceiveMessage() {
          return u.event
        }
        postMessage(p) {
          return o.d.$postMessage(c, p)
        }
      })(),
      h = new (class {
        constructor() {
          ;(this.editor = i),
            (this.line = t),
            (this.height = e),
            (this.webview = m),
            (this.onDidDispose = l.event)
        }
        dispose() {
          o.c.has(c) &&
            (o.c.delete(c),
            o.d.$disposeEditorInset(c),
            l.fire(),
            l.dispose(),
            u.dispose())
        }
      })()
    return (
      this.d.$createEditorInset(
        c,
        a.id,
        a.value.document.uri,
        t + 1,
        e,
        r || {},
        s.identifier,
        s.extensionLocation,
      ),
      this.c.set(c, { editor: i, inset: h, onDidReceiveMessage: u }),
      h
    )
  }
  $onDidDispose(i) {
    const t = this.c.get(i)
    t && t.inset.dispose()
  }
  $onDidReceiveMessage(i, t) {
    this.c.get(i)?.onDidReceiveMessage.fire(t)
  }
}
function HZ(i) {
  return (t, e, r) => {
    let s = null,
      a = null
    if (
      (typeof r.value == "function"
        ? ((s = "value"), (a = r.value))
        : typeof r.get == "function" && ((s = "get"), (a = r.get)),
      !a || typeof e == "symbol")
    )
      throw new Error("not supported")
    r[s] = i(a, e)
  }
}
function PU(i, t, e) {
  return HZ((r, s) => {
    const a = `$debounce$${s}`,
      o = `$debounce$result$${s}`
    return function (...c) {
      this[o] || (this[o] = e ? e() : void 0),
        clearTimeout(this[a]),
        t && ((this[o] = t(this[o], ...c)), (c = [this[o]])),
        (this[a] = setTimeout(() => {
          r.apply(this, c), (this[o] = e ? e() : void 0)
        }, i))
    }
  })
}
function u0t(i, t, e) {
  return HZ((r, s) => {
    const a = `$throttle$timer$${s}`,
      o = `$throttle$result$${s}`,
      c = `$throttle$lastRun$${s}`,
      u = `$throttle$pending$${s}`
    return function (...l) {
      if (
        (this[o] || (this[o] = e ? e() : void 0),
        (this[c] === null || this[c] === void 0) &&
          (this[c] = -Number.MAX_VALUE),
        t && (this[o] = t(this[o], ...l)),
        this[u])
      )
        return
      const m = this[c] + i
      m <= Date.now()
        ? ((this[c] = Date.now()),
          r.apply(this, [this[o]]),
          (this[o] = e ? e() : void 0))
        : ((this[u] = !0),
          (this[a] = setTimeout(() => {
            ;(this[u] = !1),
              (this[c] = Date.now()),
              r.apply(this, [this[o]]),
              (this[o] = e ? e() : void 0)
          }, m - Date.now())))
    }
  })
}
function l0t(i, t, e) {
  const r = i.getProxy(z.MainThreadComments)
  class s {
    static {
      this.a = 0
    }
    constructor() {
      ;(this.b = new Map()),
        (this.c = new bn()),
        t.registerArgumentProcessor({
          processArgument: (w) => {
            if (w && w.$mid === 6) {
              const T = this.b.get(w.handle)
              return T ? T.value : w
            } else if (w && w.$mid === 7) {
              const T = w,
                b = this.b.get(T.commentControlHandle)
              if (!b) return T
              const N = b.getCommentThread(T.commentThreadHandle)
              return N ? N.value : T
            } else if (w && (w.$mid === 9 || w.$mid === 8)) {
              const T = this.b.get(w.thread.commentControlHandle)
              if (!T) return w
              const b = T.getCommentThread(w.thread.commentThreadHandle)
              return b
                ? w.$mid === 8
                  ? b.value
                  : { thread: b.value, text: w.text }
                : w
            } else if (w && w.$mid === 10) {
              const T = this.b.get(w.thread.commentControlHandle)
              if (!T) return w
              const b = T.getCommentThread(w.thread.commentThreadHandle)
              if (!b) return w
              const N = w.commentUniqueId,
                $ = b.getCommentByUniqueId(N)
              return $ || w
            } else if (w && w.$mid === 11) {
              const T = this.b.get(w.thread.commentControlHandle)
              if (!T) return w
              const b = T.getCommentThread(w.thread.commentThreadHandle)
              if (!b) return w
              const N = w.text,
                $ = w.commentUniqueId,
                L = b.getCommentByUniqueId($)
              return L
                ? (typeof L.body == "string"
                    ? (L.body = N)
                    : (L.body = new Gi(N)),
                  L)
                : w
            }
            return w
          },
        })
    }
    createCommentController(w, T, b) {
      const N = s.a++,
        $ = new o(w, N, T, b)
      this.b.set($.handle, $)
      const L = this.c.get(w.identifier) || []
      return L.push($), this.c.set(w.identifier, L), $.value
    }
    async $createCommentThreadTemplate(w, T, b, N) {
      const $ = this.b.get(w)
      $ && $.$createCommentThreadTemplate(T, b, N)
    }
    async $setActiveComment(w, T) {
      const b = this.b.get(w)
      b && b.$setActiveComment(T ?? void 0)
    }
    async $updateCommentThreadTemplate(w, T, b) {
      const N = this.b.get(w)
      N && N.$updateCommentThreadTemplate(T, b)
    }
    $deleteCommentThread(w, T) {
      this.b.get(w)?.$deleteCommentThread(T)
    }
    async $updateCommentThread(w, T, b) {
      this.b.get(w)?.$updateCommentThread(T, b)
    }
    async $provideCommentingRanges(w, T, b) {
      const N = this.b.get(w)
      if (!N || !N.commentingRangeProvider) return Promise.resolve(void 0)
      const $ = await e.ensureDocumentData(S.revive(T))
      return gi(async () => {
        const L = await N.commentingRangeProvider.provideCommentingRanges(
          $.document,
          b,
        )
        let U
        return (
          Array.isArray(L)
            ? (U = { ranges: L, fileComments: !1 })
            : L
              ? (U = {
                  ranges: L.ranges || [],
                  fileComments: L.enableFileComments || !1,
                })
              : (U = L ?? void 0),
          U
        )
      }).then((L) => {
        let U
        return (
          L &&
            (U = {
              ranges: L.ranges.map((q) => O.from(q)),
              fileComments: L.fileComments,
            }),
          U
        )
      })
    }
    $toggleReaction(w, T, b, N, $) {
      const L = this.b.get(w)
      return !L || !L.reactionHandler
        ? Promise.resolve(void 0)
        : gi(() => {
            const U = L.getCommentThread(T)
            if (U) {
              const q = U.getCommentByUniqueId(N.uniqueIdInThread)
              if (L !== void 0 && q && L.reactionHandler)
                return L.reactionHandler(q, l($))
            }
            return Promise.resolve(void 0)
          })
    }
  }
  class a {
    static {
      this.a = 0
    }
    set threadId(w) {
      this.n = w
    }
    get threadId() {
      return this.n
    }
    get id() {
      return this.n
    }
    get resource() {
      return this.o
    }
    get uri() {
      return this.o
    }
    set range(w) {
      ;((w === void 0) != (this.p === void 0) ||
        !w ||
        !this.p ||
        !w.isEqual(this.p)) &&
        ((this.p = w), (this.b.range = w), this.c.fire())
    }
    get range() {
      return this.p
    }
    set canReply(w) {
      this.d !== w && ((this.d = w), (this.b.canReply = w), this.c.fire())
    }
    get canReply() {
      return this.d
    }
    get label() {
      return this.e
    }
    set label(w) {
      ;(this.e = w), (this.b.label = w), this.c.fire()
    }
    get contextValue() {
      return this.f
    }
    set contextValue(w) {
      ;(this.f = w), (this.b.contextValue = w), this.c.fire()
    }
    get comments() {
      return this.q
    }
    set comments(w) {
      ;(this.q = w), (this.b.comments = w), this.c.fire()
    }
    get collapsibleState() {
      return this.g
    }
    set collapsibleState(w) {
      this.g !== w &&
        ((this.g = w), (this.b.collapsibleState = w), this.c.fire())
    }
    get state() {
      return this.h
    }
    set state(w) {
      ;(this.h = w),
        typeof w == "object"
          ? (F(this.extensionDescription, "commentThreadApplicability"),
            (this.b.state = w.resolved),
            (this.b.applicability = w.applicability))
          : (this.b.state = w),
        this.c.fire()
    }
    get isDisposed() {
      return this.j
    }
    constructor(w, T, b, N, $, L, U, q, V) {
      ;(this.m = T),
        (this.n = b),
        (this.o = N),
        (this.p = $),
        (this.q = L),
        (this.extensionDescription = U),
        (this.r = q),
        (this.handle = a.a++),
        (this.commentHandle = 0),
        (this.b = Object.create(null)),
        (this.c = new C()),
        (this.onDidUpdateCommentThread = this.c.event),
        (this.d = !0),
        (this.k = new Map()),
        (this.l = new Zn()),
        (this.l.value = new bt()),
        this.n === void 0 && (this.n = `${w}.${this.handle}`),
        r.$createCommentThread(
          T,
          this.handle,
          this.n,
          this.o,
          O.from(this.p),
          this.q.map((at) => c(this, at, this.k, this.extensionDescription)),
          U.identifier,
          this.r,
          V,
        ),
        (this.i = []),
        (this.j = !1),
        this.i.push(
          this.onDidUpdateCommentThread(() => {
            this.eventuallyUpdateCommentThread()
          }),
        ),
        this.i.push({
          dispose: () => {
            r.$deleteCommentThread(T, this.handle)
          },
        })
      const lt = this
      this.value = {
        get uri() {
          return lt.uri
        },
        get range() {
          return lt.range
        },
        set range(at) {
          lt.range = at
        },
        get comments() {
          return lt.comments
        },
        set comments(at) {
          lt.comments = at
        },
        get collapsibleState() {
          return lt.collapsibleState
        },
        set collapsibleState(at) {
          lt.collapsibleState = at
        },
        get canReply() {
          return lt.canReply
        },
        set canReply(at) {
          lt.canReply = at
        },
        get contextValue() {
          return lt.contextValue
        },
        set contextValue(at) {
          lt.contextValue = at
        },
        get label() {
          return lt.label
        },
        set label(at) {
          lt.label = at
        },
        get state() {
          return lt.state
        },
        set state(at) {
          lt.state = at
        },
        reveal: (at, et) => lt.reveal(at, et),
        hide: () => lt.hide(),
        dispose: () => {
          lt.dispose()
        },
      }
    }
    s() {
      this.r && ((this.r = !1), (this.b.isTemplate = !1))
    }
    eventuallyUpdateCommentThread() {
      if (this.j) return
      this.s(), this.l.value || (this.l.value = new bt())
      const w = (b) => Object.prototype.hasOwnProperty.call(this.b, b),
        T = {}
      w("range") && (T.range = O.from(this.p)),
        w("label") && (T.label = this.label),
        w("contextValue") && (T.contextValue = this.contextValue ?? null),
        w("comments") &&
          (T.comments = this.q.map((b) =>
            c(this, b, this.k, this.extensionDescription),
          )),
        w("collapsibleState") && (T.collapseState = m(this.g)),
        w("canReply") && (T.canReply = this.canReply),
        w("state") && (T.state = h(this.h)),
        w("applicability") && (T.applicability = p(this.h)),
        w("isTemplate") && (T.isTemplate = this.r),
        (this.b = {}),
        r.$updateCommentThread(this.m, this.handle, this.n, this.o, T)
    }
    getCommentByUniqueId(w) {
      for (const T of this.k) {
        const b = T[0],
          N = T[1]
        if (w === N) return b
      }
    }
    async reveal(w, T) {
      F(this.extensionDescription, "commentReveal")
      let b
      w && w.body !== void 0 ? (b = w) : (T = T ?? w)
      let N = b ? this.k.get(b) : void 0
      N ??= this.k.get(this.q[0])
      let $ = !0,
        L = !1
      return (
        T?.focus === Ll.Reply
          ? ((L = !0), ($ = !1))
          : T?.focus === Ll.Comment && ($ = !1),
        r.$revealCommentThread(this.m, this.handle, N, {
          preserveFocus: $,
          focusReply: L,
        })
      )
    }
    async hide() {
      return r.$hideCommentThread(this.m, this.handle)
    }
    dispose() {
      ;(this.j = !0), this.l.dispose(), this.i.forEach((w) => w.dispose())
    }
  }
  __decorate([PU(100)], a.prototype, "eventuallyUpdateCommentThread", null)
  class o {
    get id() {
      return this.j
    }
    get label() {
      return this.k
    }
    get handle() {
      return this.i
    }
    get commentingRangeProvider() {
      return this.b
    }
    set commentingRangeProvider(w) {
      ;(this.b = w),
        w?.resourceHints && F(this.h, "commentingRangeHint"),
        r.$updateCommentingRanges(this.handle, w?.resourceHints)
    }
    get reactionHandler() {
      return this.c
    }
    set reactionHandler(w) {
      ;(this.c = w),
        r.$updateCommentControllerFeatures(this.handle, {
          reactionHandler: !!w,
        })
    }
    get options() {
      return this.d
    }
    set options(w) {
      ;(this.d = w),
        r.$updateCommentControllerFeatures(this.handle, { options: this.d })
    }
    get activeComment() {
      return F(this.h, "activeComment"), this.e
    }
    get activeCommentThread() {
      return F(this.h, "activeComment"), this.f?.value
    }
    constructor(w, T, b, N) {
      ;(this.h = w),
        (this.i = T),
        (this.j = b),
        (this.k = N),
        (this.a = new Map()),
        r.$registerCommentController(this.handle, b, N, this.h.identifier.value)
      const $ = this
      ;(this.value = Object.freeze({
        id: $.id,
        label: $.label,
        get options() {
          return $.options
        },
        set options(L) {
          $.options = L
        },
        get commentingRangeProvider() {
          return $.commentingRangeProvider
        },
        set commentingRangeProvider(L) {
          $.commentingRangeProvider = L
        },
        get reactionHandler() {
          return $.reactionHandler
        },
        set reactionHandler(L) {
          $.reactionHandler = L
        },
        get activeCommentThread() {
          return $.activeCommentThread
        },
        createCommentThread(L, U, q) {
          return $.createCommentThread(L, U, q).value
        },
        dispose: () => {
          $.dispose()
        },
      })),
        (this.g = []),
        this.g.push({
          dispose: () => {
            r.$unregisterCommentController(this.handle)
          },
        })
    }
    createCommentThread(w, T, b) {
      T === void 0 && F(this.h, "fileComments")
      const N = new a(this.id, this.handle, void 0, w, T, b, this.h, !1)
      return this.a.set(N.handle, N), N
    }
    $setActiveComment(w) {
      if (!w) {
        ;(this.e = void 0), (this.f = void 0)
        return
      }
      const T = this.a.get(w.commentThreadHandle)
      T &&
        ((this.e = w.uniqueIdInThread
          ? T.getCommentByUniqueId(w.uniqueIdInThread)
          : void 0),
        (this.f = T))
    }
    $createCommentThreadTemplate(w, T, b) {
      const N = new a(
        this.id,
        this.handle,
        void 0,
        S.revive(w),
        O.to(T),
        [],
        this.h,
        !0,
        b,
      )
      return (N.collapsibleState = bo.Expanded), this.a.set(N.handle, N), N
    }
    $updateCommentThreadTemplate(w, T) {
      const b = this.a.get(w)
      b && (b.range = O.to(T))
    }
    $updateCommentThread(w, T) {
      const b = this.a.get(w)
      if (!b) return
      ;(($) => Object.prototype.hasOwnProperty.call(T, $))("collapseState") &&
        (b.collapsibleState = m(T.collapseState))
    }
    $deleteCommentThread(w) {
      this.a.get(w)?.dispose(), this.a.delete(w)
    }
    getCommentThread(w) {
      return this.a.get(w)
    }
    dispose() {
      this.a.forEach((w) => {
        w.dispose()
      }),
        this.g.forEach((w) => w.dispose())
    }
  }
  function c(g, w, T, b) {
    let N = T.get(w)
    return (
      N || ((N = ++g.commentHandle), T.set(w, N)),
      w.state !== void 0 && F(b, "commentsDraftState"),
      w.reactions?.some(($) => $.reactors !== void 0) && F(b, "commentReactor"),
      {
        mode: w.mode,
        contextValue: w.contextValue,
        uniqueIdInThread: N,
        body: typeof w.body == "string" ? w.body : Jt.from(w.body),
        userName: w.author.name,
        userIconPath: w.author.iconPath,
        label: w.label,
        commentReactions: w.reactions ? w.reactions.map(($) => u($)) : void 0,
        state: w.state,
        timestamp: w.timestamp?.toJSON(),
      }
    )
  }
  function u(g) {
    return {
      label: g.label,
      iconPath: g.iconPath ? rA(g.iconPath) : void 0,
      count: g.count,
      hasReacted: g.authorHasReacted,
      reactors:
        g.reactors && g.reactors.length > 0 && typeof g.reactors[0] != "string"
          ? g.reactors.map((w) => w.name)
          : g.reactors,
    }
  }
  function l(g) {
    return {
      label: g.label || "",
      count: g.count || 0,
      iconPath: g.iconPath ? S.revive(g.iconPath) : "",
      authorHasReacted: g.hasReacted || !1,
      reactors: g.reactors?.map((w) => ({ name: w })),
    }
  }
  function m(g) {
    if (g !== void 0)
      switch (g) {
        case xl.Expanded:
          return bo.Expanded
        case xl.Collapsed:
          return bo.Collapsed
      }
    return bo.Collapsed
  }
  function h(g) {
    let w
    if ((typeof g == "object" ? (w = g.resolved) : (w = g), w !== void 0))
      switch (w) {
        case Jl.Unresolved:
          return Qu.Unresolved
        case Jl.Resolved:
          return Qu.Resolved
      }
    return Qu.Unresolved
  }
  function p(g) {
    let w
    if ((typeof g == "object" && (w = g.applicability), w !== void 0))
      switch (w) {
        case Cl.Current:
          return Xu.Current
        case Cl.Outdated:
          return Xu.Outdated
      }
    return Xu.Current
  }
  return new s()
}
var d0t = class U1 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ShadowHealthCheckRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new U1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new U1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new U1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(U1, t, e)
    }
  },
  m0t = class M1 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ShadowHealthCheckResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new M1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new M1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new M1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(M1, t, e)
    }
  },
  h0t = class H1 extends d {
    constructor(t) {
      super(),
        (this.files = []),
        (this.includeQuickFixes = !1),
        (this.doNotUseInProdNewFilesShouldBeTemporarilyCreatedForIncreasedAccuracy =
          !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetLintsForChangeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: f0t, repeated: !0 },
        { no: 2, name: "include_quick_fixes", kind: "scalar", T: 8 },
        {
          no: 3,
          name: "do_not_use_in_prod_new_files_should_be_temporarily_created_for_increased_accuracy",
          kind: "scalar",
          T: 8,
        },
      ])
    }
    static fromBinary(t, e) {
      return new H1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new H1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new H1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(H1, t, e)
    }
  },
  f0t = class W1 extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.initialContent = ""),
        (this.finalContent = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetLintsForChangeRequest.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "initial_content", kind: "scalar", T: 9 },
        { no: 3, name: "final_content", kind: "scalar", T: 9 },
        {
          no: 4,
          name: "get_all_lints_not_just_delta_lints_for_ranges_in_final_model",
          kind: "message",
          T: p0t,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new W1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new W1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new W1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(W1, t, e)
    }
  },
  p0t = class j1 extends d {
    constructor(t) {
      super(), (this.ranges = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.GetLintsForChangeRequest.File.RangeCollection"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ranges", kind: "message", T: g0t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new j1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new j1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new j1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(j1, t, e)
    }
  },
  g0t = class V1 extends d {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.startColumn = 0),
        (this.endLineNumber = 0),
        (this.endColumn = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetLintsForChangeRequest.File.IRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "start_column", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "end_column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new V1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new V1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new V1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(V1, t, e)
    }
  },
  _7 = class G1 extends d {
    constructor(t) {
      super(), (this.lints = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetLintsForChangeResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "lints", kind: "message", T: v0t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new G1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new G1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new G1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(G1, t, e)
    }
  },
  v0t = class z1 extends d {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.severity = ""),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumberOneIndexed = 0),
        (this.startColumnOneIndexed = 0),
        (this.endLineNumberInclusiveOneIndexed = 0),
        (this.endColumnOneIndexed = 0),
        (this.quickFixes = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetLintsForChangeResponse.Lint"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "severity", kind: "scalar", T: 9 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "start_line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 5, name: "start_column_one_indexed", kind: "scalar", T: 5 },
        {
          no: 6,
          name: "end_line_number_inclusive_one_indexed",
          kind: "scalar",
          T: 5,
        },
        { no: 7, name: "end_column_one_indexed", kind: "scalar", T: 5 },
        { no: 9, name: "quick_fixes", kind: "message", T: w0t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new z1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new z1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new z1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(z1, t, e)
    }
  },
  w0t = class Y1 extends d {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.kind = ""),
        (this.isPreferred = !1),
        (this.edits = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetLintsForChangeResponse.Lint.QuickFix"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "kind", kind: "scalar", T: 9 },
        { no: 3, name: "is_preferred", kind: "scalar", T: 8 },
        { no: 4, name: "edits", kind: "message", T: y0t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Y1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Y1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Y1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Y1, t, e)
    }
  },
  y0t = class Q1 extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.text = ""),
        (this.startLineNumberOneIndexed = 0),
        (this.startColumnOneIndexed = 0),
        (this.endLineNumberInclusiveOneIndexed = 0),
        (this.endColumnOneIndexed = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetLintsForChangeResponse.Lint.QuickFix.Edit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
        { no: 3, name: "start_line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 4, name: "start_column_one_indexed", kind: "scalar", T: 5 },
        {
          no: 5,
          name: "end_line_number_inclusive_one_indexed",
          kind: "scalar",
          T: 5,
        },
        { no: 6, name: "end_column_one_indexed", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Q1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Q1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Q1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Q1, t, e)
    }
  },
  Kd = {
    typeName: "aiserver.v1.ShadowWorkspaceService",
    methods: {
      getLintsForChange: {
        name: "GetLintsForChange",
        I: h0t,
        O: _7,
        kind: E.Unary,
      },
      shadowHealthCheck: {
        name: "ShadowHealthCheck",
        I: d0t,
        O: m0t,
        kind: E.Unary,
      },
    },
  },
  T0t = class X1 extends d {
    constructor(t) {
      super(),
        (this.files = []),
        (this.targetDir = ""),
        (this.repo = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateExperimentalIndexRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "target_dir", kind: "scalar", T: 9 },
        { no: 3, name: "repo", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new X1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new X1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new X1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(X1, t, e)
    }
  },
  k0t = class K1 extends d {
    constructor(t) {
      super(), (this.indexId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateExperimentalIndexResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new K1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new K1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new K1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(K1, t, e)
    }
  },
  S0t = class Z1 extends d {
    constructor(t) {
      super(), (this.indexId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListExperimentalIndexFilesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Z1().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Z1().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Z1().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Z1, t, e)
    }
  },
  b0t = class tw extends d {
    constructor(t) {
      super(),
        (this.indexId = ""),
        (this.files = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListExperimentalIndexFilesResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
        { no: 2, name: "files", kind: "message", T: VZ, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new tw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tw, t, e)
    }
  },
  WZ = class ew extends d {
    constructor(t) {
      super(), (this.indexId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListenExperimentalIndexRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ew().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ew().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ew().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ew, t, e)
    }
  },
  E0t = class iw extends d {
    constructor(t) {
      super(),
        (this.indexId = ""),
        (this.item = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListenExperimentalIndexResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
        { no: 2, name: "ready", kind: "message", T: I0t, oneof: "item" },
        { no: 3, name: "register", kind: "message", T: P0t, oneof: "item" },
        { no: 4, name: "choose", kind: "message", T: N0t, oneof: "item" },
        { no: 5, name: "summarize", kind: "message", T: $0t, oneof: "item" },
        { no: 6, name: "error", kind: "message", T: x0t, oneof: "item" },
      ])
    }
    static fromBinary(t, e) {
      return new iw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iw, t, e)
    }
  },
  I0t = class rw extends d {
    constructor(t) {
      super(), (this.indexId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListenExperimentalIndexResponse.ReadyItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
        { no: 2, name: "request", kind: "message", T: WZ },
      ])
    }
    static fromBinary(t, e) {
      return new rw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rw, t, e)
    }
  },
  P0t = class nw extends d {
    constructor(t) {
      super(), (this.reqUuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListenExperimentalIndexResponse.RegisterItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "response", kind: "message", T: J0t },
        { no: 2, name: "request", kind: "message", T: NU },
        { no: 3, name: "req_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new nw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nw, t, e)
    }
  },
  N0t = class sw extends d {
    constructor(t) {
      super(), (this.reqUuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListenExperimentalIndexResponse.ChooseItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "response", kind: "message", T: A0t },
        { no: 2, name: "request", kind: "message", T: $U },
        { no: 3, name: "req_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new sw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sw, t, e)
    }
  },
  $0t = class aw extends d {
    constructor(t) {
      super(), (this.reqUuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ListenExperimentalIndexResponse.SummarizeItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "response", kind: "message", T: U0t },
        { no: 2, name: "request", kind: "message", T: xU },
        { no: 3, name: "req_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new aw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aw, t, e)
    }
  },
  x0t = class ow extends d {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.statusCode = 0),
        (this.request = { case: void 0 }),
        (this.reqUuid = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListenExperimentalIndexResponse.ErrorItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "status_code", kind: "scalar", T: 5 },
        { no: 3, name: "register", kind: "message", T: NU, oneof: "request" },
        { no: 4, name: "choose", kind: "message", T: $U, oneof: "request" },
        { no: 5, name: "summarize", kind: "message", T: xU, oneof: "request" },
        { no: 6, name: "req_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ow().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ow().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ow().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ow, t, e)
    }
  },
  NU = class cw extends d {
    constructor(t) {
      super(),
        (this.indexId = ""),
        (this.workspaceRelativePath = ""),
        (this.content = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RegisterFileToIndexRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
        { no: 2, name: "workspace_relative_path", kind: "scalar", T: 9 },
        { no: 3, name: "root_context_node", kind: "message", T: j0t },
        { no: 4, name: "content", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new cw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cw, t, e)
    }
  },
  J0t = class uw extends d {
    constructor(t) {
      super(),
        (this.fileId = ""),
        (this.rootContextNodeId = ""),
        (this.dependencyResolutionAttempts = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RegisterFileToIndexResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_id", kind: "scalar", T: 9 },
        { no: 2, name: "root_context_node_id", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "dependency_resolution_attempts",
          kind: "message",
          T: zZ,
          repeated: !0,
        },
        { no: 4, name: "file_data", kind: "message", T: VZ },
      ])
    }
    static fromBinary(t, e) {
      return new uw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uw, t, e)
    }
  },
  C0t = class lw extends d {
    constructor(t) {
      super(),
        (this.indexId = ""),
        (this.fileId = ""),
        (this.dependencyResolutionResults = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SetupIndexDependenciesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
        { no: 3, name: "file_id", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "dependency_resolution_results",
          kind: "message",
          T: V0t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new lw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lw, t, e)
    }
  },
  L0t = class dw extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SetupIndexDependenciesResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new dw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dw, t, e)
    }
  },
  R0t = class mw extends d {
    constructor(t) {
      super(), (this.indexId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComputeIndexTopoSortRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new mw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mw, t, e)
    }
  },
  D0t = class hw extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComputeIndexTopoSortResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new hw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hw, t, e)
    }
  },
  $U = class fw extends d {
    constructor(t) {
      super(),
        (this.indexId = ""),
        (this.request = { case: void 0 }),
        (this.recompute = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChooseCodeReferencesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
        { no: 2, name: "file", kind: "message", T: F0t, oneof: "request" },
        { no: 3, name: "node", kind: "message", T: _0t, oneof: "request" },
        { no: 4, name: "recompute", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new fw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fw, t, e)
    }
  },
  F0t = class pw extends d {
    constructor(t) {
      super(), (this.fileId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChooseCodeReferencesRequest.FileRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new pw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pw, t, e)
    }
  },
  _0t = class gw extends d {
    constructor(t) {
      super(), (this.nodeId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChooseCodeReferencesRequest.NodeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "node_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new gw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gw, t, e)
    }
  },
  A0t = class vw extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChooseCodeReferencesResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "message", T: B0t, oneof: "response" },
        { no: 2, name: "node", kind: "message", T: jZ, oneof: "response" },
      ])
    }
    static fromBinary(t, e) {
      return new vw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vw, t, e)
    }
  },
  jZ = class ww extends d {
    constructor(t) {
      super(),
        (this.nodeId = ""),
        (this.actions = []),
        (this.skipped = !1),
        (this.dependencies = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChooseCodeReferencesResponse.NodeResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "node_id", kind: "scalar", T: 9 },
        { no: 2, name: "actions", kind: "message", T: A7, repeated: !0 },
        { no: 3, name: "skipped", kind: "scalar", T: 8 },
        { no: 4, name: "dependencies", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ww().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ww().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ww().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ww, t, e)
    }
  },
  B0t = class yw extends d {
    constructor(t) {
      super(),
        (this.fileId = ""),
        (this.nodeResponses = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChooseCodeReferencesResponse.FileResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_id", kind: "scalar", T: 9 },
        { no: 2, name: "node_responses", kind: "message", T: jZ, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new yw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yw, t, e)
    }
  },
  O0t = class Tw extends d {
    constructor(t) {
      super(),
        (this.nodeId = ""),
        (this.references = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RegisterCodeReferencesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "node_id", kind: "scalar", T: 9 },
        { no: 2, name: "references", kind: "message", T: Y0t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Tw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Tw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Tw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Tw, t, e)
    }
  },
  q0t = class kw extends d {
    constructor(t) {
      super(), (this.dependencies = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RegisterCodeReferencesResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "dependencies", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new kw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kw, t, e)
    }
  },
  xU = class Sw extends d {
    constructor(t) {
      super(),
        (this.indexId = ""),
        (this.nodeId = ""),
        (this.recompute = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SummarizeWithReferencesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
        { no: 2, name: "node_id", kind: "scalar", T: 9 },
        { no: 3, name: "recompute", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Sw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Sw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Sw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Sw, t, e)
    }
  },
  U0t = class bw extends d {
    constructor(t) {
      super(),
        (this.response = { case: void 0 }),
        (this.nodeId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SummarizeWithReferencesResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "success", kind: "message", T: M0t, oneof: "response" },
        {
          no: 2,
          name: "dependency",
          kind: "message",
          T: H0t,
          oneof: "response",
        },
        { no: 3, name: "node_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new bw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bw, t, e)
    }
  },
  M0t = class Ew extends d {
    constructor(t) {
      super(), (this.summary = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SummarizeWithReferencesResponse.Success"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "summary", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ew().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ew().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ew().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ew, t, e)
    }
  },
  H0t = class Iw extends d {
    constructor(t) {
      super(), (this.nodes = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SummarizeWithReferencesResponse.Dependency"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "nodes", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Iw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Iw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Iw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Iw, t, e)
    }
  },
  JU = class Pw extends d {
    constructor(t) {
      super(), (this.reqUuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RequestReceivedResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "req_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Pw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Pw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Pw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Pw, t, e)
    }
  },
  W0t = class Nw extends d {
    constructor(t) {
      super(),
        (this.indexId = ""),
        (this.id = ""),
        (this.summary = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReflectionData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
        { no: 2, name: "id", kind: "scalar", T: 9 },
        { no: 3, name: "summary", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Nw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Nw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Nw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Nw, t, e)
    }
  },
  VZ = class $w extends d {
    constructor(t) {
      super(),
        (this.indexId = ""),
        (this.workspaceRelativePath = ""),
        (this.stage = ""),
        (this.order = 0),
        (this.nodes = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IndexFileData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index_id", kind: "scalar", T: 9 },
        { no: 2, name: "workspace_relative_path", kind: "scalar", T: 9 },
        { no: 3, name: "stage", kind: "scalar", T: 9 },
        { no: 4, name: "order", kind: "scalar", T: 5 },
        { no: 5, name: "nodes", kind: "message", T: GZ, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new $w().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $w().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $w().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($w, t, e)
    }
  },
  GZ = class xw extends d {
    constructor(t) {
      super(),
        (this.nodeId = ""),
        (this.stage = ""),
        (this.content = ""),
        (this.summary = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IndexFileData.NodeData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "node_id", kind: "scalar", T: 9 },
        { no: 2, name: "stage", kind: "scalar", T: 9 },
        { no: 3, name: "content", kind: "scalar", T: 9 },
        { no: 4, name: "summary", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new xw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xw, t, e)
    }
  },
  j0t = class du extends d {
    constructor(t) {
      super(),
        (this.workspaceRelativePath = ""),
        (this.startLineNumber = 0),
        (this.endLineNumber = 0),
        (this.children = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SerializedContextNode"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "workspace_relative_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "children", kind: "message", T: du, repeated: !0 },
        { no: 5, name: "node_snippets", kind: "message", T: CU },
      ])
    }
    static fromBinary(t, e) {
      return new du().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new du().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new du().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(du, t, e)
    }
  },
  zZ = class Jw extends d {
    constructor(t) {
      super(),
        (this.workspaceRelativePath = ""),
        (this.nodeId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.URIResolutionAttempt"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "workspace_relative_path", kind: "scalar", T: 9 },
        { no: 2, name: "node_id", kind: "scalar", T: 9 },
        { no: 3, name: "symbol", kind: "message", T: A7 },
      ])
    }
    static fromBinary(t, e) {
      return new Jw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Jw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Jw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Jw, t, e)
    }
  },
  V0t = class Cw extends d {
    constructor(t) {
      super(), (this.resolvedPaths = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.URIResolutionResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request", kind: "message", T: zZ },
        { no: 2, name: "resolved_paths", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Cw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Cw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Cw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Cw, t, e)
    }
  },
  G0t = class Lw extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ExtractPathsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_code_snippets", kind: "message", T: CU },
      ])
    }
    static fromBinary(t, e) {
      return new Lw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Lw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Lw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Lw, t, e)
    }
  },
  z0t = class Rw extends d {
    constructor(t) {
      super(), (this.paths = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ExtractPathsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "paths", kind: "message", T: A7, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Rw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Rw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Rw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Rw, t, e)
    }
  },
  Y0t = class Dw extends d {
    constructor(t) {
      super(), (this.references = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SymbolActionResults"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "action", kind: "message", T: A7 },
        { no: 2, name: "references", kind: "message", T: Q0t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Dw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Dw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Dw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Dw, t, e)
    }
  },
  Q0t = class Fw extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SymbolActionResultReference"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "range", kind: "message", T: mi },
        { no: 2, name: "reference", kind: "message", T: CU },
      ])
    }
    static fromBinary(t, e) {
      return new Fw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Fw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Fw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Fw, t, e)
    }
  },
  CU = class _w extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.totalLines = 0),
        (this.snippets = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileCodeSnippets"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "total_lines", kind: "scalar", T: 5 },
        { no: 3, name: "snippets", kind: "message", T: X0t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new _w().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _w().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _w().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_w, t, e)
    }
  },
  X0t = class Aw extends d {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.endLineNumber = 0),
        (this.lines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodeSnippet"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Aw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Aw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Aw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Aw, t, e)
    }
  },
  A7 = class Bw extends d {
    constructor(t) {
      super(),
        (this.workspaceRelativePath = ""),
        (this.lineNumber = 0),
        (this.symbolStartColumn = 0),
        (this.symbolEndColumn = 0),
        (this.action = Zd.UNSPECIFIED),
        (this.symbol = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodeSymbolWithAction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "workspace_relative_path", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
        { no: 3, name: "symbol_start_column", kind: "scalar", T: 5 },
        { no: 4, name: "symbol_end_column", kind: "scalar", T: 5 },
        { no: 5, name: "action", kind: "enum", T: n.getEnumType(Zd) },
        { no: 6, name: "symbol", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Bw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Bw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Bw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Bw, t, e)
    }
  },
  Zd
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.GO_TO_DEFINITION = 1)] = "GO_TO_DEFINITION"),
    (i[(i.GO_TO_IMPLEMENTATION = 2)] = "GO_TO_IMPLEMENTATION"),
    (i[(i.REFERENCES = 3)] = "REFERENCES")
})(Zd || (Zd = {})),
  n.util.setEnumType(Zd, "aiserver.v1.CodeSymbolWithAction.CodeSymbolAction", [
    { no: 0, name: "CODE_SYMBOL_ACTION_UNSPECIFIED" },
    { no: 1, name: "CODE_SYMBOL_ACTION_GO_TO_DEFINITION" },
    { no: 2, name: "CODE_SYMBOL_ACTION_GO_TO_IMPLEMENTATION" },
    { no: 3, name: "CODE_SYMBOL_ACTION_REFERENCES" },
  ])
var B7
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"), (i[(i.DEFAULT = 1)] = "DEFAULT")
})(B7 || (B7 = {})),
  n.util.setEnumType(B7, "aiserver.v1.ChunkingStrategy", [
    { no: 0, name: "CHUNKING_STRATEGY_UNSPECIFIED" },
    { no: 1, name: "CHUNKING_STRATEGY_DEFAULT" },
  ])
var tm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.LULEA = 1)] = "LULEA"),
    (i[(i.UMEA = 2)] = "UMEA"),
    (i[(i.NONE = 3)] = "NONE"),
    (i[(i.LLAMA = 4)] = "LLAMA"),
    (i[(i.STARCODER_V1 = 5)] = "STARCODER_V1"),
    (i[(i.GPT_3_5_LOGPROBS = 6)] = "GPT_3_5_LOGPROBS"),
    (i[(i.LULEA_HAIKU = 7)] = "LULEA_HAIKU"),
    (i[(i.COHERE = 8)] = "COHERE"),
    (i[(i.VOYAGE = 9)] = "VOYAGE"),
    (i[(i.VOYAGE_EMBEDS = 10)] = "VOYAGE_EMBEDS"),
    (i[(i.IDENTITY = 11)] = "IDENTITY"),
    (i[(i.ADA_EMBEDS = 12)] = "ADA_EMBEDS")
})(tm || (tm = {})),
  n.util.setEnumType(tm, "aiserver.v1.RerankerAlgorithm", [
    { no: 0, name: "RERANKER_ALGORITHM_UNSPECIFIED" },
    { no: 1, name: "RERANKER_ALGORITHM_LULEA" },
    { no: 2, name: "RERANKER_ALGORITHM_UMEA" },
    { no: 3, name: "RERANKER_ALGORITHM_NONE" },
    { no: 4, name: "RERANKER_ALGORITHM_LLAMA" },
    { no: 5, name: "RERANKER_ALGORITHM_STARCODER_V1" },
    { no: 6, name: "RERANKER_ALGORITHM_GPT_3_5_LOGPROBS" },
    { no: 7, name: "RERANKER_ALGORITHM_LULEA_HAIKU" },
    { no: 8, name: "RERANKER_ALGORITHM_COHERE" },
    { no: 9, name: "RERANKER_ALGORITHM_VOYAGE" },
    { no: 10, name: "RERANKER_ALGORITHM_VOYAGE_EMBEDS" },
    { no: 11, name: "RERANKER_ALGORITHM_IDENTITY" },
    { no: 12, name: "RERANKER_ALGORITHM_ADA_EMBEDS" },
  ])
var O7
;(function (i) {
  ;(i[(i.RECHUNKER_CHOICE_UNSPECIFIED = 0)] = "RECHUNKER_CHOICE_UNSPECIFIED"),
    (i[(i.RECHUNKER_CHOICE_IDENTITY = 1)] = "RECHUNKER_CHOICE_IDENTITY"),
    (i[(i.RECHUNKER_CHOICE_600_TOKS = 2)] = "RECHUNKER_CHOICE_600_TOKS"),
    (i[(i.RECHUNKER_CHOICE_2400_TOKS = 3)] = "RECHUNKER_CHOICE_2400_TOKS"),
    (i[(i.RECHUNKER_CHOICE_4000_TOKS = 4)] = "RECHUNKER_CHOICE_4000_TOKS")
})(O7 || (O7 = {})),
  n.util.setEnumType(O7, "aiserver.v1.RechunkerChoice", [
    { no: 0, name: "RECHUNKER_CHOICE_UNSPECIFIED" },
    { no: 1, name: "RECHUNKER_CHOICE_IDENTITY" },
    { no: 2, name: "RECHUNKER_CHOICE_600_TOKS" },
    { no: 3, name: "RECHUNKER_CHOICE_2400_TOKS" },
    { no: 4, name: "RECHUNKER_CHOICE_4000_TOKS" },
  ])
var K0t = class Ow extends d {
    constructor(t) {
      super(),
        (this.readmes = []),
        (this.topLevelRelativeWorkspacePaths = []),
        (this.workspaceRootPath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetHighLevelFolderDescriptionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "readmes", kind: "message", T: Z0t, repeated: !0 },
        {
          no: 2,
          name: "top_level_relative_workspace_paths",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 4, name: "workspace_root_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ow().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ow().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ow().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ow, t, e)
    }
  },
  Z0t = class qw extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetHighLevelFolderDescriptionRequest.Readme"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new qw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qw, t, e)
    }
  },
  tTt = class Uw extends d {
    constructor(t) {
      super(), (this.description = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetHighLevelFolderDescriptionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "description", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Uw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Uw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Uw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Uw, t, e)
    }
  },
  eTt = class Mw extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EnsureIndexCreatedRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: _t },
      ])
    }
    static fromBinary(t, e) {
      return new Mw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Mw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Mw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Mw, t, e)
    }
  },
  iTt = class Hw extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EnsureIndexCreatedResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Hw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Hw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Hw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Hw, t, e)
    }
  },
  Bs = class Ww extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.hashOfNode = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PartialPathItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "hash_of_node", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ww().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ww().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ww().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ww, t, e)
    }
  },
  rTt = class jw extends d {
    constructor(t) {
      super(),
        (this.rootHash = ""),
        (this.potentialLegacyRepoName = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastRepoInitHandshakeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: _t },
        { no: 2, name: "root_hash", kind: "scalar", T: 9 },
        { no: 3, name: "potential_legacy_repo_name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new jw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jw, t, e)
    }
  },
  nTt = class Vw extends d {
    constructor(t) {
      super(),
        (this.status = em.UNSPECIFIED),
        (this.repoName = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastRepoInitHandshakeResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(em) },
        { no: 2, name: "repo_name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Vw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Vw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Vw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Vw, t, e)
    }
  },
  em
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.UP_TO_DATE = 1)] = "UP_TO_DATE"),
    (i[(i.OUT_OF_SYNC = 2)] = "OUT_OF_SYNC"),
    (i[(i.FAILURE = 3)] = "FAILURE"),
    (i[(i.EMPTY = 4)] = "EMPTY")
})(em || (em = {})),
  n.util.setEnumType(em, "aiserver.v1.FastRepoInitHandshakeResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_UP_TO_DATE" },
    { no: 2, name: "STATUS_OUT_OF_SYNC" },
    { no: 3, name: "STATUS_FAILURE" },
    { no: 4, name: "STATUS_EMPTY" },
  ])
var sTt = class Gw extends d {
    constructor(t) {
      super(), (this.rootHash = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastRepoInitHandshakeV2Request"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: _t },
        { no: 2, name: "root_hash", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Gw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Gw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Gw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Gw, t, e)
    }
  },
  aTt = class zw extends d {
    constructor(t) {
      super(),
        (this.codebaseId = ""),
        (this.status = im.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryCodebaseInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "codebase_id", kind: "scalar", T: 9 },
        { no: 2, name: "status", kind: "enum", T: n.getEnumType(im) },
      ])
    }
    static fromBinary(t, e) {
      return new zw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zw, t, e)
    }
  },
  im
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.UP_TO_DATE = 1)] = "UP_TO_DATE"),
    (i[(i.OUT_OF_SYNC = 2)] = "OUT_OF_SYNC"),
    (i[(i.EMPTY = 3)] = "EMPTY")
})(im || (im = {})),
  n.util.setEnumType(im, "aiserver.v1.RepositoryCodebaseInfo.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_UP_TO_DATE" },
    { no: 2, name: "STATUS_OUT_OF_SYNC" },
    { no: 3, name: "STATUS_EMPTY" },
  ])
var oTt = class Yw extends d {
    constructor(t) {
      super(),
        (this.status = rm.UNSPECIFIED),
        (this.codebases = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastRepoInitHandshakeV2Response"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(rm) },
        { no: 2, name: "codebases", kind: "message", T: aTt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Yw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Yw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Yw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Yw, t, e)
    }
  },
  rm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.FAILURE = 1)] = "FAILURE"),
    (i[(i.SUCCESS = 2)] = "SUCCESS")
})(rm || (rm = {})),
  n.util.setEnumType(rm, "aiserver.v1.FastRepoInitHandshakeV2Response.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_FAILURE" },
    { no: 2, name: "STATUS_SUCCESS" },
  ])
var cTt = class Qw extends d {
    constructor(t) {
      super(),
        (this.codebaseId = ""),
        (this.status = nm.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryCodebaseSyncStatus"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "codebase_id", kind: "scalar", T: 9 },
        { no: 2, name: "status", kind: "enum", T: n.getEnumType(nm) },
      ])
    }
    static fromBinary(t, e) {
      return new Qw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Qw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Qw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Qw, t, e)
    }
  },
  nm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE")
})(nm || (nm = {})),
  n.util.setEnumType(nm, "aiserver.v1.RepositoryCodebaseSyncStatus.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
  ])
var uTt = class Xw extends d {
    constructor(t) {
      super(), (this.codebases = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastRepoSyncCompleteRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "codebases", kind: "message", T: cTt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Xw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Xw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Xw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Xw, t, e)
    }
  },
  lTt = class Kw extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastRepoSyncCompleteResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Kw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Kw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Kw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Kw, t, e)
    }
  },
  dTt = class Zw extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SyncMerkleSubtreeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: _t },
        { no: 2, name: "local_partial_path", kind: "message", T: Bs },
      ])
    }
    static fromBinary(t, e) {
      return new Zw().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Zw().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Zw().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Zw, t, e)
    }
  },
  mTt = class ty extends d {
    constructor(t) {
      super(), (this.result = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SyncMerkleSubtreeResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "match", kind: "scalar", T: 8, oneof: "result" },
        { no: 2, name: "mismatch", kind: "message", T: hTt, oneof: "result" },
      ])
    }
    static fromBinary(t, e) {
      return new ty().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ty().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ty().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ty, t, e)
    }
  },
  hTt = class ey extends d {
    constructor(t) {
      super(), (this.children = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SyncMerkleSubtreeResponse.Mismatch"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "children", kind: "message", T: Bs, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ey().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ey().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ey().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ey, t, e)
    }
  },
  YZ = class iy extends d {
    constructor(t) {
      super(), (this.orthogonalTransformSeed = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ClientRepositoryInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "orthogonal_transform_seed", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new iy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iy, t, e)
    }
  },
  fTt = class ry extends d {
    constructor(t) {
      super(), (this.codebaseId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SyncMerkleSubtreeV2Request"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "client_repository_info", kind: "message", T: YZ },
        { no: 2, name: "codebase_id", kind: "scalar", T: 9 },
        { no: 3, name: "local_partial_path", kind: "message", T: Bs },
      ])
    }
    static fromBinary(t, e) {
      return new ry().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ry().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ry().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ry, t, e)
    }
  },
  pTt = class ny extends d {
    constructor(t) {
      super(), (this.result = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SyncMerkleSubtreeV2Response"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "match", kind: "scalar", T: 8, oneof: "result" },
        { no: 2, name: "mismatch", kind: "message", T: gTt, oneof: "result" },
      ])
    }
    static fromBinary(t, e) {
      return new ny().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ny().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ny().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ny, t, e)
    }
  },
  gTt = class sy extends d {
    constructor(t) {
      super(), (this.children = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SyncMerkleSubtreeV2Response.Mismatch"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "children", kind: "message", T: Bs, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new sy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sy, t, e)
    }
  },
  vTt = class ay extends d {
    constructor(t) {
      super(),
        (this.partialPath = { case: void 0 }),
        (this.ancestorSpline = []),
        (this.updateType = sm.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastUpdateFileRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: _t },
        {
          no: 2,
          name: "directory",
          kind: "message",
          T: Bs,
          oneof: "partial_path",
        },
        {
          no: 3,
          name: "local_file",
          kind: "message",
          T: wTt,
          oneof: "partial_path",
        },
        {
          no: 4,
          name: "ancestor_spline",
          kind: "message",
          T: Bs,
          repeated: !0,
        },
        { no: 5, name: "update_type", kind: "enum", T: n.getEnumType(sm) },
      ])
    }
    static fromBinary(t, e) {
      return new ay().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ay().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ay().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ay, t, e)
    }
  },
  sm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.ADD = 1)] = "ADD"),
    (i[(i.DELETE = 2)] = "DELETE"),
    (i[(i.MODIFY = 3)] = "MODIFY")
})(sm || (sm = {})),
  n.util.setEnumType(sm, "aiserver.v1.FastUpdateFileRequest.UpdateType", [
    { no: 0, name: "UPDATE_TYPE_UNSPECIFIED" },
    { no: 1, name: "UPDATE_TYPE_ADD" },
    { no: 2, name: "UPDATE_TYPE_DELETE" },
    { no: 3, name: "UPDATE_TYPE_MODIFY" },
  ])
var wTt = class oy extends d {
    constructor(t) {
      super(),
        (this.hash = ""),
        (this.unencryptedRelativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastUpdateFileRequest.LocalFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "message", T: nr },
        { no: 2, name: "hash", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "unencrypted_relative_workspace_path",
          kind: "scalar",
          T: 9,
        },
      ])
    }
    static fromBinary(t, e) {
      return new oy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oy, t, e)
    }
  },
  yTt = class cy extends d {
    constructor(t) {
      super(), (this.status = am.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastUpdateFileResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(am) },
      ])
    }
    static fromBinary(t, e) {
      return new cy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cy, t, e)
    }
  },
  am
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.EXPECTED_FAILURE = 3)] = "EXPECTED_FAILURE")
})(am || (am = {})),
  n.util.setEnumType(am, "aiserver.v1.FastUpdateFileResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_EXPECTED_FAILURE" },
  ])
var TTt = class uy extends d {
    constructor(t) {
      super(),
        (this.codebaseId = ""),
        (this.partialPath = { case: void 0 }),
        (this.ancestorSpline = []),
        (this.updateType = om.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastUpdateFileV2Request"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "client_repository_info", kind: "message", T: YZ },
        { no: 2, name: "codebase_id", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "directory",
          kind: "message",
          T: Bs,
          oneof: "partial_path",
        },
        {
          no: 4,
          name: "local_file",
          kind: "message",
          T: kTt,
          oneof: "partial_path",
        },
        {
          no: 5,
          name: "ancestor_spline",
          kind: "message",
          T: Bs,
          repeated: !0,
        },
        { no: 6, name: "update_type", kind: "enum", T: n.getEnumType(om) },
      ])
    }
    static fromBinary(t, e) {
      return new uy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uy, t, e)
    }
  },
  om
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.ADD = 1)] = "ADD"),
    (i[(i.DELETE = 2)] = "DELETE"),
    (i[(i.MODIFY = 3)] = "MODIFY")
})(om || (om = {})),
  n.util.setEnumType(om, "aiserver.v1.FastUpdateFileV2Request.UpdateType", [
    { no: 0, name: "UPDATE_TYPE_UNSPECIFIED" },
    { no: 1, name: "UPDATE_TYPE_ADD" },
    { no: 2, name: "UPDATE_TYPE_DELETE" },
    { no: 3, name: "UPDATE_TYPE_MODIFY" },
  ])
var kTt = class ly extends d {
    constructor(t) {
      super(),
        (this.hash = ""),
        (this.unencryptedRelativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastUpdateFileV2Request.LocalFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "message", T: nr },
        { no: 2, name: "hash", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "unencrypted_relative_workspace_path",
          kind: "scalar",
          T: 9,
        },
      ])
    }
    static fromBinary(t, e) {
      return new ly().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ly().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ly().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ly, t, e)
    }
  },
  STt = class dy extends d {
    constructor(t) {
      super(), (this.status = cm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastUpdateFileV2Response"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(cm) },
      ])
    }
    static fromBinary(t, e) {
      return new dy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dy, t, e)
    }
  },
  cm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.EXPECTED_FAILURE = 3)] = "EXPECTED_FAILURE")
})(cm || (cm = {})),
  n.util.setEnumType(cm, "aiserver.v1.FastUpdateFileV2Response.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_EXPECTED_FAILURE" },
  ])
var bTt = class my extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetUploadLimitsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: _t, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new my().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new my().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new my().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(my, t, e)
    }
  },
  ETt = class hy extends d {
    constructor(t) {
      super(),
        (this.softLimit = 0),
        (this.hardLimit = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetUploadLimitsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "soft_limit", kind: "scalar", T: 5 },
        { no: 2, name: "hard_limit", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new hy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hy, t, e)
    }
  },
  ITt = class fy extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetNumFilesToSendRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: _t },
      ])
    }
    static fromBinary(t, e) {
      return new fy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fy, t, e)
    }
  },
  PTt = class py extends d {
    constructor(t) {
      super(), (this.numFiles = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetNumFilesToSendResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "num_files", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new py().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new py().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new py().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(py, t, e)
    }
  },
  NTt = class gy extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetAvailableChunkingStrategiesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: _t },
      ])
    }
    static fromBinary(t, e) {
      return new gy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gy, t, e)
    }
  },
  $Tt = class vy extends d {
    constructor(t) {
      super(), (this.chunkingStrategies = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetAvailableChunkingStrategiesResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "chunking_strategies",
          kind: "enum",
          T: n.getEnumType(B7),
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new vy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vy, t, e)
    }
  },
  xTt = class wy extends d {
    constructor(t) {
      super(), (this.texts = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetEmbeddingsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "texts", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new wy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wy, t, e)
    }
  },
  JTt = class yy extends d {
    constructor(t) {
      super(), (this.embeddings = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetEmbeddingsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "embeddings", kind: "message", T: CTt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new yy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yy, t, e)
    }
  },
  CTt = class Ty extends d {
    constructor(t) {
      super(), (this.embedding = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetEmbeddingsResponse.Embedding"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "embedding", kind: "scalar", T: 2, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Ty().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ty().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ty().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ty, t, e)
    }
  },
  a2t = class ky extends d {
    constructor(t) {
      super(), (this.codebaseId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AdminRemoveRepositoryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "codebase_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new ky().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ky().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ky().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ky, t, e)
    }
  },
  o2t = class Sy extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AdminRemoveRepositoryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Sy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Sy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Sy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Sy, t, e)
    }
  },
  c2t = class by extends d {
    constructor(t) {
      super(), (this.codebaseId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SyncRepositoryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "codebase_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new by().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new by().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new by().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(by, t, e)
    }
  },
  u2t = class Ey extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SyncRepositoryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Ey().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ey().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ey().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ey, t, e)
    }
  },
  l2t = class Iy extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StartUploadRepoRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: _t },
      ])
    }
    static fromBinary(t, e) {
      return new Iy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Iy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Iy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Iy, t, e)
    }
  },
  d2t = class Py extends d {
    constructor(t) {
      super(),
        (this.status = um.UNSPECIFIED),
        (this.seenFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StartUploadRepoResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(um) },
        { no: 2, name: "seen_files", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Py().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Py().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Py().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Py, t, e)
    }
  },
  um
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.ALREADY_EXISTS = 3)] = "ALREADY_EXISTS")
})(um || (um = {})),
  n.util.setEnumType(um, "aiserver.v1.StartUploadRepoResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_ALREADY_EXISTS" },
  ])
var m2t = class Ny extends d {
    constructor(t) {
      super(),
        (this.commitSha = ""),
        (this.queueId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UploadFileRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: _t },
        { no: 2, name: "file", kind: "message", T: nr },
        { no: 3, name: "commit_sha", kind: "scalar", T: 9 },
        { no: 4, name: "queue_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ny().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ny().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ny().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ny, t, e)
    }
  },
  h2t = class $y extends d {
    constructor(t) {
      super(), (this.status = lm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UploadFileResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(lm) },
      ])
    }
    static fromBinary(t, e) {
      return new $y().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $y().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $y().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($y, t, e)
    }
  },
  lm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.EXPECTED_FAILURE = 3)] = "EXPECTED_FAILURE"),
    (i[(i.QUEUE_BACKED_UP = 4)] = "QUEUE_BACKED_UP")
})(lm || (lm = {})),
  n.util.setEnumType(lm, "aiserver.v1.UploadFileResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_EXPECTED_FAILURE" },
    { no: 4, name: "STATUS_QUEUE_BACKED_UP" },
  ])
var f2t = class xy extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FinishUploadRepoRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: _t },
      ])
    }
    static fromBinary(t, e) {
      return new xy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xy, t, e)
    }
  },
  p2t = class Jy extends d {
    constructor(t) {
      super(), (this.status = dm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FinishUploadRepoResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(dm) },
      ])
    }
    static fromBinary(t, e) {
      return new Jy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Jy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Jy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Jy, t, e)
    }
  },
  dm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE")
})(dm || (dm = {})),
  n.util.setEnumType(dm, "aiserver.v1.FinishUploadRepoResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
  ])
var g2t = class Cy extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StartUpdateRepoRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: _t },
      ])
    }
    static fromBinary(t, e) {
      return new Cy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Cy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Cy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Cy, t, e)
    }
  },
  v2t = class Ly extends d {
    constructor(t) {
      super(), (this.status = mm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StartUpdateRepoResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(mm) },
      ])
    }
    static fromBinary(t, e) {
      return new Ly().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ly().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ly().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ly, t, e)
    }
  },
  mm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.NOT_FOUND = 3)] = "NOT_FOUND"),
    (i[(i.ALREADY_SYNCING = 4)] = "ALREADY_SYNCING")
})(mm || (mm = {})),
  n.util.setEnumType(mm, "aiserver.v1.StartUpdateRepoResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_NOT_FOUND" },
    { no: 4, name: "STATUS_ALREADY_SYNCING" },
  ])
var w2t = class Ry extends d {
    constructor(t) {
      super(),
        (this.commitSha = ""),
        (this.queueId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpdateFileRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: _t },
        { no: 2, name: "added_file", kind: "message", T: nr },
        { no: 3, name: "deleted_file_path", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "commit_sha", kind: "scalar", T: 9 },
        { no: 5, name: "queue_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ry().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ry().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ry().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ry, t, e)
    }
  },
  y2t = class Dy extends d {
    constructor(t) {
      super(), (this.status = hm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpdateFileResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(hm) },
      ])
    }
    static fromBinary(t, e) {
      return new Dy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Dy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Dy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Dy, t, e)
    }
  },
  hm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.EXPECTED_FAILURE = 3)] = "EXPECTED_FAILURE"),
    (i[(i.QUEUE_BACKED_UP = 4)] = "QUEUE_BACKED_UP")
})(hm || (hm = {})),
  n.util.setEnumType(hm, "aiserver.v1.UpdateFileResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_EXPECTED_FAILURE" },
    { no: 4, name: "STATUS_QUEUE_BACKED_UP" },
  ])
var T2t = class Fy extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FinishUpdateRepoRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: _t },
      ])
    }
    static fromBinary(t, e) {
      return new Fy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Fy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Fy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Fy, t, e)
    }
  },
  k2t = class _y extends d {
    constructor(t) {
      super(), (this.status = fm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FinishUpdateRepoResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(fm) },
      ])
    }
    static fromBinary(t, e) {
      return new _y().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _y().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _y().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_y, t, e)
    }
  },
  fm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE")
})(fm || (fm = {})),
  n.util.setEnumType(fm, "aiserver.v1.FinishUpdateRepoResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
  ])
var S2t = class Ay extends d {
    constructor(t) {
      super(), (this.requests = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BatchRepositoryStatusRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "requests", kind: "message", T: ATt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Ay().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ay().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ay().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ay, t, e)
    }
  },
  b2t = class By extends d {
    constructor(t) {
      super(), (this.responses = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BatchRepositoryStatusResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "responses", kind: "message", T: BTt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new By().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new By().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new By().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(By, t, e)
    }
  },
  E2t = class Oy extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UnsubscribeRepositoryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: _t },
      ])
    }
    static fromBinary(t, e) {
      return new Oy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Oy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Oy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Oy, t, e)
    }
  },
  I2t = class qy extends d {
    constructor(t) {
      super(), (this.status = pm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UnsubscribeRepositoryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(pm) },
      ])
    }
    static fromBinary(t, e) {
      return new qy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qy, t, e)
    }
  },
  pm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.NOT_FOUND = 1)] = "NOT_FOUND"),
    (i[(i.NOT_SUBSCRIBED = 2)] = "NOT_SUBSCRIBED"),
    (i[(i.SUCCESS = 3)] = "SUCCESS")
})(pm || (pm = {})),
  n.util.setEnumType(pm, "aiserver.v1.UnsubscribeRepositoryResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_NOT_FOUND" },
    { no: 2, name: "STATUS_NOT_SUBSCRIBED" },
    { no: 3, name: "STATUS_SUCCESS" },
  ])
var P2t = class Uy extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogoutRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Uy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Uy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Uy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Uy, t, e)
    }
  },
  N2t = class My extends d {
    constructor(t) {
      super(), (this.status = gm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogoutResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(gm) },
      ])
    }
    static fromBinary(t, e) {
      return new My().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new My().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new My().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(My, t, e)
    }
  },
  gm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.NOT_LOGGED_IN = 3)] = "NOT_LOGGED_IN")
})(gm || (gm = {})),
  n.util.setEnumType(gm, "aiserver.v1.LogoutResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_NOT_LOGGED_IN" },
  ])
var LTt = class Hy extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RemoveRepositoryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: _t },
      ])
    }
    static fromBinary(t, e) {
      return new Hy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Hy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Hy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Hy, t, e)
    }
  },
  RTt = class Wy extends d {
    constructor(t) {
      super(), (this.status = vm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RemoveRepositoryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(vm) },
      ])
    }
    static fromBinary(t, e) {
      return new Wy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Wy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Wy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Wy, t, e)
    }
  },
  vm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.NOT_FOUND = 1)] = "NOT_FOUND"),
    (i[(i.NOT_AUTHORIZED = 2)] = "NOT_AUTHORIZED"),
    (i[(i.STARTED = 3)] = "STARTED"),
    (i[(i.SUCCESS = 4)] = "SUCCESS")
})(vm || (vm = {})),
  n.util.setEnumType(vm, "aiserver.v1.RemoveRepositoryResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_NOT_FOUND" },
    { no: 2, name: "STATUS_NOT_AUTHORIZED" },
    { no: 3, name: "STATUS_STARTED" },
    { no: 4, name: "STATUS_SUCCESS" },
  ])
var $2t = class jy extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SubscribeRepositoryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: _t },
      ])
    }
    static fromBinary(t, e) {
      return new jy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jy, t, e)
    }
  },
  x2t = class Vy extends d {
    constructor(t) {
      super(), (this.status = wm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SubscribeRepositoryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(wm) },
      ])
    }
    static fromBinary(t, e) {
      return new Vy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Vy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Vy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Vy, t, e)
    }
  },
  wm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.NOT_FOUND = 1)] = "NOT_FOUND"),
    (i[(i.NOT_AUTHORIZED = 2)] = "NOT_AUTHORIZED"),
    (i[(i.ALREADY_SUBSCRIBED = 3)] = "ALREADY_SUBSCRIBED"),
    (i[(i.SUCCESS = 4)] = "SUCCESS")
})(wm || (wm = {})),
  n.util.setEnumType(wm, "aiserver.v1.SubscribeRepositoryResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_NOT_FOUND" },
    { no: 2, name: "STATUS_NOT_AUTHORIZED" },
    { no: 3, name: "STATUS_ALREADY_SUBSCRIBED" },
    { no: 4, name: "STATUS_SUCCESS" },
  ])
var QZ = class Gy extends d {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.topK = 0),
        (this.rerank = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchRepositoryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "repository", kind: "message", T: _t },
        { no: 3, name: "top_k", kind: "scalar", T: 5 },
        { no: 4, name: "model_details", kind: "message", T: vt },
        { no: 5, name: "rerank", kind: "scalar", T: 8 },
        { no: 6, name: "context_cache_request", kind: "scalar", T: 8, opt: !0 },
        { no: 7, name: "glob_filter", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "not_glob_filter", kind: "scalar", T: 9, opt: !0 },
        { no: 9, name: "race_n_requests", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Gy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Gy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Gy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Gy, t, e)
    }
  },
  fi = class zy extends d {
    constructor(t) {
      super(), (this.score = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodeResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_block", kind: "message", T: ye },
        { no: 2, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new zy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zy, t, e)
    }
  },
  DTt = class Yy extends d {
    constructor(t) {
      super(), (this.score = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "message", T: nr },
        { no: 2, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new Yy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Yy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Yy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Yy, t, e)
    }
  },
  XZ = class Qy extends d {
    constructor(t) {
      super(), (this.codeResults = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchRepositoryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_results", kind: "message", T: fi, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Qy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Qy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Qy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Qy, t, e)
    }
  },
  KZ = class Xy extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemSearchRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request", kind: "message", T: QZ },
      ])
    }
    static fromBinary(t, e) {
      return new Xy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Xy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Xy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Xy, t, e)
    }
  },
  ZZ = class Ky extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodeResultWithClassificationInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_result", kind: "message", T: fi },
        {
          no: 2,
          name: "line_number_classification",
          kind: "message",
          T: FTt,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Ky().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ky().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ky().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ky, t, e)
    }
  },
  FTt = class Zy extends d {
    constructor(t) {
      super(),
        (this.queryComputedFor = ""),
        (this.matchedStrings = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.CodeResultWithClassificationInfo.LineNumberClassification"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "detailed_line", kind: "message", T: _q },
        { no: 2, name: "query_computed_for", kind: "scalar", T: 9 },
        { no: 3, name: "matched_strings", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "highlight_range", kind: "message", T: mi },
      ])
    }
    static fromBinary(t, e) {
      return new Zy().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Zy().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Zy().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Zy, t, e)
    }
  },
  ttt = class t0 extends d {
    constructor(t) {
      super(), (this.codeResults = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemSearchResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "response", kind: "message", T: XZ },
        { no: 2, name: "metadata", kind: "message", T: _Tt, opt: !0 },
        { no: 3, name: "code_results", kind: "message", T: ZZ, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new t0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new t0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new t0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(t0, t, e)
    }
  },
  _Tt = class e0 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemSearchResponse.SemSearchMetadata"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query_embedding_model", kind: "scalar", T: 9, opt: !0 },
        {
          no: 2,
          name: "server_side_latency_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 3, name: "embed_latency_ms", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "knn_latency_ms", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new e0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new e0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new e0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(e0, t, e)
    }
  },
  J2t = class i0 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LoginRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new i0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new i0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new i0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(i0, t, e)
    }
  },
  C2t = class r0 extends d {
    constructor(t) {
      super(), (this.loginUrl = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LoginResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "login_url", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new r0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new r0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new r0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(r0, t, e)
    }
  },
  L2t = class n0 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IsLoggedInRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new n0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new n0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new n0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(n0, t, e)
    }
  },
  R2t = class s0 extends d {
    constructor(t) {
      super(), (this.loggedIn = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IsLoggedInResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "logged_in", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new s0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new s0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new s0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(s0, t, e)
    }
  },
  D2t = class a0 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PollLoginRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new a0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new a0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new a0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(a0, t, e)
    }
  },
  F2t = class o0 extends d {
    constructor(t) {
      super(), (this.status = ym.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PollLoginResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(ym) },
      ])
    }
    static fromBinary(t, e) {
      return new o0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new o0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new o0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(o0, t, e)
    }
  },
  ym
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.LOGGED_IN = 1)] = "LOGGED_IN"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.CHECKING = 3)] = "CHECKING")
})(ym || (ym = {})),
  n.util.setEnumType(ym, "aiserver.v1.PollLoginResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_LOGGED_IN" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_CHECKING" },
  ])
var _2t = class c0 extends d {
    constructor(t) {
      super(), (this.scopes = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpgradeScopeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "scopes", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new c0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new c0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new c0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(c0, t, e)
    }
  },
  A2t = class u0 extends d {
    constructor(t) {
      super(), (this.status = Tm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpgradeScopeResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(Tm) },
      ])
    }
    static fromBinary(t, e) {
      return new u0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new u0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new u0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(u0, t, e)
    }
  },
  Tm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE")
})(Tm || (Tm = {})),
  n.util.setEnumType(Tm, "aiserver.v1.UpgradeScopeResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
  ])
var B2t = class l0 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoriesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new l0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new l0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new l0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(l0, t, e)
    }
  },
  O2t = class d0 extends d {
    constructor(t) {
      super(), (this.repositories = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoriesResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repositories", kind: "message", T: _t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new d0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new d0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new d0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(d0, t, e)
    }
  },
  q2t = class m0 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UploadRepositoryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: _t },
      ])
    }
    static fromBinary(t, e) {
      return new m0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new m0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new m0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(m0, t, e)
    }
  },
  U2t = class h0 extends d {
    constructor(t) {
      super(), (this.status = km.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UploadRepositoryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(km) },
      ])
    }
    static fromBinary(t, e) {
      return new h0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new h0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new h0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(h0, t, e)
    }
  },
  km
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.AUTH_TOKEN_BAD_PERMISSIONS = 3)] = "AUTH_TOKEN_BAD_PERMISSIONS"),
    (i[(i.ALREADY_EXISTS = 4)] = "ALREADY_EXISTS")
})(km || (km = {})),
  n.util.setEnumType(km, "aiserver.v1.UploadRepositoryResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_AUTH_TOKEN_BAD_PERMISSIONS" },
    { no: 4, name: "STATUS_ALREADY_EXISTS" },
  ])
var ATt = class f0 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository", kind: "message", T: _t },
      ])
    }
    static fromBinary(t, e) {
      return new f0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new f0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new f0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(f0, t, e)
    }
  },
  BTt = class p0 extends d {
    constructor(t) {
      super(), (this.status = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "not_found", kind: "message", T: OTt, oneof: "status" },
        { no: 2, name: "uploading", kind: "message", T: UTt, oneof: "status" },
        { no: 3, name: "syncing", kind: "message", T: MTt, oneof: "status" },
        { no: 4, name: "synced", kind: "message", T: HTt, oneof: "status" },
        {
          no: 5,
          name: "not_subscribed",
          kind: "message",
          T: qTt,
          oneof: "status",
        },
        { no: 6, name: "too_big", kind: "message", T: WTt, oneof: "status" },
        {
          no: 7,
          name: "auth_token_not_found",
          kind: "message",
          T: jTt,
          oneof: "status",
        },
        {
          no: 8,
          name: "auth_token_not_authorized",
          kind: "message",
          T: VTt,
          oneof: "status",
        },
        {
          no: 10,
          name: "error_uploading",
          kind: "message",
          T: ett,
          oneof: "status",
        },
        {
          no: 11,
          name: "error_syncing",
          kind: "message",
          T: ett,
          oneof: "status",
        },
        { no: 9, name: "is_owner", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new p0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new p0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new p0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(p0, t, e)
    }
  },
  OTt = class g0 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusResponse.NotFound"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new g0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new g0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new g0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(g0, t, e)
    }
  },
  qTt = class v0 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusResponse.NotSubscribed"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new v0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new v0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new v0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(v0, t, e)
    }
  },
  UTt = class w0 extends d {
    constructor(t) {
      super(), (this.progress = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusResponse.Uploading"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "progress", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new w0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new w0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new w0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(w0, t, e)
    }
  },
  MTt = class y0 extends d {
    constructor(t) {
      super(),
        (this.branch = ""),
        (this.oldCommit = ""),
        (this.newCommit = ""),
        (this.progress = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusResponse.Syncing"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "branch", kind: "scalar", T: 9 },
        { no: 2, name: "old_commit", kind: "scalar", T: 9 },
        { no: 3, name: "new_commit", kind: "scalar", T: 9 },
        { no: 4, name: "progress", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new y0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new y0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new y0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(y0, t, e)
    }
  },
  HTt = class T0 extends d {
    constructor(t) {
      super(),
        (this.branch = ""),
        (this.commit = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusResponse.Synced"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "branch", kind: "scalar", T: 9 },
        { no: 2, name: "commit", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new T0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new T0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new T0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(T0, t, e)
    }
  },
  WTt = class k0 extends d {
    constructor(t) {
      super(), (this.maxSize = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusResponse.TooBig"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "max_size", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new k0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new k0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new k0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(k0, t, e)
    }
  },
  jTt = class S0 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusResponse.AuthTokenNotFound"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new S0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new S0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new S0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(S0, t, e)
    }
  },
  VTt = class b0 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RepositoryStatusResponse.AuthTokenNotAuthorized"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new b0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new b0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new b0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(b0, t, e)
    }
  },
  ett = class E0 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryStatusResponse.EmptyMessage"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new E0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new E0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new E0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(E0, t, e)
    }
  },
  _t = class I0 extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.remoteUrls = []),
        (this.remoteNames = []),
        (this.repoName = ""),
        (this.repoOwner = ""),
        (this.isTracked = !1),
        (this.isLocal = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RepositoryInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "remote_urls", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "remote_names", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "repo_name", kind: "scalar", T: 9 },
        { no: 5, name: "repo_owner", kind: "scalar", T: 9 },
        { no: 6, name: "is_tracked", kind: "scalar", T: 8 },
        { no: 7, name: "is_local", kind: "scalar", T: 8 },
        { no: 8, name: "num_files", kind: "scalar", T: 5, opt: !0 },
        {
          no: 9,
          name: "orthogonal_transform_seed",
          kind: "scalar",
          T: 1,
          opt: !0,
        },
        {
          no: 10,
          name: "preferred_embedding_model",
          kind: "enum",
          T: n.getEnumType(e7),
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new I0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new I0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new I0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(I0, t, e)
    }
  },
  M2t = class P0 extends d {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.topK = 0),
        (this.topReflectionsK = 0),
        (this.indexIds = []),
        (this.useModelOnFiles = !1),
        (this.useReflections = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchRepositoryDeepContextRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "top_k", kind: "scalar", T: 5 },
        { no: 3, name: "top_reflections_k", kind: "scalar", T: 5 },
        { no: 4, name: "index_ids", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "use_model_on_files", kind: "scalar", T: 8 },
        { no: 6, name: "use_reflections", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new P0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new P0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new P0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(P0, t, e)
    }
  },
  GTt = class N0 extends d {
    constructor(t) {
      super(), (this.score = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.NodeResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "node", kind: "message", T: GZ },
        { no: 2, name: "file", kind: "message", T: nr },
        { no: 3, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new N0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new N0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new N0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(N0, t, e)
    }
  },
  zTt = class $0 extends d {
    constructor(t) {
      super(), (this.score = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReflectionResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "reflection", kind: "message", T: W0t },
        { no: 2, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new $0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($0, t, e)
    }
  },
  YTt = class x0 extends d {
    constructor(t) {
      super(),
        (this.topNodes = []),
        (this.reflections = []),
        (this.indexId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchRepositoryDeepContextResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "top_nodes", kind: "message", T: GTt, repeated: !0 },
        { no: 2, name: "reflections", kind: "message", T: zTt, repeated: !0 },
        { no: 3, name: "index_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new x0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new x0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new x0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(x0, t, e)
    }
  },
  QTt = class J0 extends d {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.codeResults = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetLineNumberClassificationsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "code_results", kind: "message", T: fi, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new J0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new J0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new J0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(J0, t, e)
    }
  },
  XTt = class C0 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetLineNumberClassificationsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "classified_result", kind: "message", T: ZZ },
      ])
    }
    static fromBinary(t, e) {
      return new C0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new C0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new C0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(C0, t, e)
    }
  },
  fr
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.READ_SEMSEARCH_FILES = 1)] = "READ_SEMSEARCH_FILES"),
    (i[(i.READ_FILE_FOR_IMPORTS = 2)] = "READ_FILE_FOR_IMPORTS"),
    (i[(i.RIPGREP_SEARCH = 3)] = "RIPGREP_SEARCH"),
    (i[(i.RUN_TERMINAL_COMMAND = 4)] = "RUN_TERMINAL_COMMAND"),
    (i[(i.READ_FILE = 5)] = "READ_FILE"),
    (i[(i.LIST_DIR = 6)] = "LIST_DIR"),
    (i[(i.EDIT_FILE = 7)] = "EDIT_FILE"),
    (i[(i.FILE_SEARCH = 8)] = "FILE_SEARCH"),
    (i[(i.SEMANTIC_SEARCH_FULL = 9)] = "SEMANTIC_SEARCH_FULL"),
    (i[(i.CREATE_FILE = 10)] = "CREATE_FILE"),
    (i[(i.DELETE_FILE = 11)] = "DELETE_FILE"),
    (i[(i.REAPPLY = 12)] = "REAPPLY"),
    (i[(i.GET_RELATED_FILES = 13)] = "GET_RELATED_FILES"),
    (i[(i.PARALLEL_APPLY = 14)] = "PARALLEL_APPLY"),
    (i[(i.RUN_TERMINAL_COMMAND_V2 = 15)] = "RUN_TERMINAL_COMMAND_V2"),
    (i[(i.FETCH_RULES = 16)] = "FETCH_RULES"),
    (i[(i.PLANNER = 17)] = "PLANNER"),
    (i[(i.WEB_SEARCH = 18)] = "WEB_SEARCH"),
    (i[(i.MCP = 19)] = "MCP"),
    (i[(i.WEB_VIEWER = 20)] = "WEB_VIEWER"),
    (i[(i.DIFF_HISTORY = 21)] = "DIFF_HISTORY")
})(fr || (fr = {})),
  n.util.setEnumType(fr, "aiserver.v1.ClientSideToolV2", [
    { no: 0, name: "CLIENT_SIDE_TOOL_V2_UNSPECIFIED" },
    { no: 1, name: "CLIENT_SIDE_TOOL_V2_READ_SEMSEARCH_FILES" },
    { no: 2, name: "CLIENT_SIDE_TOOL_V2_READ_FILE_FOR_IMPORTS" },
    { no: 3, name: "CLIENT_SIDE_TOOL_V2_RIPGREP_SEARCH" },
    { no: 4, name: "CLIENT_SIDE_TOOL_V2_RUN_TERMINAL_COMMAND" },
    { no: 5, name: "CLIENT_SIDE_TOOL_V2_READ_FILE" },
    { no: 6, name: "CLIENT_SIDE_TOOL_V2_LIST_DIR" },
    { no: 7, name: "CLIENT_SIDE_TOOL_V2_EDIT_FILE" },
    { no: 8, name: "CLIENT_SIDE_TOOL_V2_FILE_SEARCH" },
    { no: 9, name: "CLIENT_SIDE_TOOL_V2_SEMANTIC_SEARCH_FULL" },
    { no: 10, name: "CLIENT_SIDE_TOOL_V2_CREATE_FILE" },
    { no: 11, name: "CLIENT_SIDE_TOOL_V2_DELETE_FILE" },
    { no: 12, name: "CLIENT_SIDE_TOOL_V2_REAPPLY" },
    { no: 13, name: "CLIENT_SIDE_TOOL_V2_GET_RELATED_FILES" },
    { no: 14, name: "CLIENT_SIDE_TOOL_V2_PARALLEL_APPLY" },
    { no: 15, name: "CLIENT_SIDE_TOOL_V2_RUN_TERMINAL_COMMAND_V2" },
    { no: 16, name: "CLIENT_SIDE_TOOL_V2_FETCH_RULES" },
    { no: 17, name: "CLIENT_SIDE_TOOL_V2_PLANNER" },
    { no: 18, name: "CLIENT_SIDE_TOOL_V2_WEB_SEARCH" },
    { no: 19, name: "CLIENT_SIDE_TOOL_V2_MCP" },
    { no: 20, name: "CLIENT_SIDE_TOOL_V2_WEB_VIEWER" },
    { no: 21, name: "CLIENT_SIDE_TOOL_V2_DIFF_HISTORY" },
  ])
var qa
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.BASH = 1)] = "BASH"),
    (i[(i.POWERSHELL = 2)] = "POWERSHELL")
})(qa || (qa = {})),
  n.util.setEnumType(qa, "aiserver.v1.ShellType", [
    { no: 0, name: "SHELL_TYPE_UNSPECIFIED" },
    { no: 1, name: "SHELL_TYPE_BASH" },
    { no: 2, name: "SHELL_TYPE_POWERSHELL" },
  ])
var Ua
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SEARCH = 1)] = "SEARCH"),
    (i[(i.READ_CHUNK = 2)] = "READ_CHUNK"),
    (i[(i.GOTODEF = 3)] = "GOTODEF"),
    (i[(i.EDIT = 4)] = "EDIT"),
    (i[(i.UNDO_EDIT = 5)] = "UNDO_EDIT"),
    (i[(i.END = 6)] = "END"),
    (i[(i.NEW_FILE = 7)] = "NEW_FILE"),
    (i[(i.ADD_TEST = 8)] = "ADD_TEST"),
    (i[(i.RUN_TEST = 9)] = "RUN_TEST"),
    (i[(i.DELETE_TEST = 10)] = "DELETE_TEST"),
    (i[(i.SAVE_FILE = 11)] = "SAVE_FILE"),
    (i[(i.GET_TESTS = 12)] = "GET_TESTS"),
    (i[(i.GET_SYMBOLS = 13)] = "GET_SYMBOLS"),
    (i[(i.SEMANTIC_SEARCH = 14)] = "SEMANTIC_SEARCH"),
    (i[(i.GET_PROJECT_STRUCTURE = 15)] = "GET_PROJECT_STRUCTURE"),
    (i[(i.CREATE_RM_FILES = 16)] = "CREATE_RM_FILES"),
    (i[(i.RUN_TERMINAL_COMMANDS = 17)] = "RUN_TERMINAL_COMMANDS"),
    (i[(i.NEW_EDIT = 18)] = "NEW_EDIT"),
    (i[(i.READ_WITH_LINTER = 19)] = "READ_WITH_LINTER")
})(Ua || (Ua = {})),
  n.util.setEnumType(Ua, "aiserver.v1.BuiltinTool", [
    { no: 0, name: "BUILTIN_TOOL_UNSPECIFIED" },
    { no: 1, name: "BUILTIN_TOOL_SEARCH" },
    { no: 2, name: "BUILTIN_TOOL_READ_CHUNK" },
    { no: 3, name: "BUILTIN_TOOL_GOTODEF" },
    { no: 4, name: "BUILTIN_TOOL_EDIT" },
    { no: 5, name: "BUILTIN_TOOL_UNDO_EDIT" },
    { no: 6, name: "BUILTIN_TOOL_END" },
    { no: 7, name: "BUILTIN_TOOL_NEW_FILE" },
    { no: 8, name: "BUILTIN_TOOL_ADD_TEST" },
    { no: 9, name: "BUILTIN_TOOL_RUN_TEST" },
    { no: 10, name: "BUILTIN_TOOL_DELETE_TEST" },
    { no: 11, name: "BUILTIN_TOOL_SAVE_FILE" },
    { no: 12, name: "BUILTIN_TOOL_GET_TESTS" },
    { no: 13, name: "BUILTIN_TOOL_GET_SYMBOLS" },
    { no: 14, name: "BUILTIN_TOOL_SEMANTIC_SEARCH" },
    { no: 15, name: "BUILTIN_TOOL_GET_PROJECT_STRUCTURE" },
    { no: 16, name: "BUILTIN_TOOL_CREATE_RM_FILES" },
    { no: 17, name: "BUILTIN_TOOL_RUN_TERMINAL_COMMANDS" },
    { no: 18, name: "BUILTIN_TOOL_NEW_EDIT" },
    { no: 19, name: "BUILTIN_TOOL_READ_WITH_LINTER" },
  ])
var Rc
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.EXECUTION_COMPLETED = 1)] = "EXECUTION_COMPLETED"),
    (i[(i.EXECUTION_ABORTED = 2)] = "EXECUTION_ABORTED"),
    (i[(i.EXECUTION_FAILED = 3)] = "EXECUTION_FAILED"),
    (i[(i.ERROR_OCCURRED_CHECKING_REASON = 4)] =
      "ERROR_OCCURRED_CHECKING_REASON")
})(Rc || (Rc = {})),
  n.util.setEnumType(Rc, "aiserver.v1.RunTerminalCommandEndedReason", [
    { no: 0, name: "RUN_TERMINAL_COMMAND_ENDED_REASON_UNSPECIFIED" },
    { no: 1, name: "RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_COMPLETED" },
    { no: 2, name: "RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_ABORTED" },
    { no: 3, name: "RUN_TERMINAL_COMMAND_ENDED_REASON_EXECUTION_FAILED" },
    {
      no: 4,
      name: "RUN_TERMINAL_COMMAND_ENDED_REASON_ERROR_OCCURRED_CHECKING_REASON",
    },
  ])
var KTt = class L0 extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReapplyParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new L0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new L0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new L0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(L0, t, e)
    }
  },
  ZTt = class R0 extends d {
    constructor(t) {
      super(),
        (this.isApplied = !1),
        (this.applyFailed = !1),
        (this.linterErrors = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReapplyResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diff", kind: "message", T: RU },
        { no: 2, name: "is_applied", kind: "scalar", T: 8 },
        { no: 3, name: "apply_failed", kind: "scalar", T: 8 },
        { no: 4, name: "linter_errors", kind: "message", T: Js, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new R0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new R0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new R0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(R0, t, e)
    }
  },
  tkt = class D0 extends d {
    constructor(t) {
      super(), (this.ruleNames = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FetchRulesParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "rule_names", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new D0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new D0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new D0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(D0, t, e)
    }
  },
  ekt = class F0 extends d {
    constructor(t) {
      super(), (this.rules = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FetchRulesResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "rules", kind: "message", T: Aq, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new F0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new F0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new F0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(F0, t, e)
    }
  },
  ikt = class _0 extends d {
    constructor(t) {
      super(), (this.instruction = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PlannerParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "instruction", kind: "scalar", T: 9 },
        { no: 2, name: "plan", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new _0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_0, t, e)
    }
  },
  rkt = class A0 extends d {
    constructor(t) {
      super(), (this.plan = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PlannerResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "plan", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new A0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new A0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new A0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(A0, t, e)
    }
  },
  nkt = class B0 extends d {
    constructor(t) {
      super(), (this.targetFiles = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetRelatedFilesParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "target_files", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new B0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new B0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new B0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(B0, t, e)
    }
  },
  skt = class O0 extends d {
    constructor(t) {
      super(), (this.files = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetRelatedFilesResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: akt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new O0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new O0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new O0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(O0, t, e)
    }
  },
  akt = class q0 extends d {
    constructor(t) {
      super(), (this.uri = ""), (this.score = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetRelatedFilesResult.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uri", kind: "scalar", T: 9 },
        { no: 2, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new q0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new q0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new q0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(q0, t, e)
    }
  },
  okt = class U0 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReapplyStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new U0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new U0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new U0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(U0, t, e)
    }
  },
  H2t = class M0 extends d {
    constructor(t) {
      super(),
        (this.command = ""),
        (this.explanation = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandArguments"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
        { no: 2, name: "explanation", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new M0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new M0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new M0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(M0, t, e)
    }
  },
  W2t = class H0 extends d {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.targetDirectories = []),
        (this.explanation = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemanticSearchArguments"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "target_directories",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 3, name: "explanation", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new H0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new H0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new H0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(H0, t, e)
    }
  },
  LU = class W0 extends d {
    constructor(t) {
      super(),
        (this.clientVisibleErrorMessage = ""),
        (this.modelVisibleErrorMessage = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToolResultError"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "client_visible_error_message", kind: "scalar", T: 9 },
        { no: 2, name: "model_visible_error_message", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "actual_error_message_only_send_from_client_to_server_never_the_other_way_around_because_that_may_be_a_security_risk",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new W0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new W0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new W0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(W0, t, e)
    }
  },
  itt = class j0 extends d {
    constructor(t) {
      super(),
        (this.tool = fr.UNSPECIFIED),
        (this.params = { case: void 0 }),
        (this.toolCallId = ""),
        (this.name = ""),
        (this.rawArgs = ""),
        (this.isStreaming = !1),
        (this.isLastMessage = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ClientSideToolV2Call"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool", kind: "enum", T: n.getEnumType(fr) },
        {
          no: 2,
          name: "read_semsearch_files_params",
          kind: "message",
          T: att,
          oneof: "params",
        },
        {
          no: 4,
          name: "read_file_for_imports_params",
          kind: "message",
          T: utt,
          oneof: "params",
        },
        {
          no: 5,
          name: "ripgrep_search_params",
          kind: "message",
          T: Ekt,
          oneof: "params",
        },
        {
          no: 7,
          name: "run_terminal_command_params",
          kind: "message",
          T: iSt,
          oneof: "params",
        },
        {
          no: 8,
          name: "read_file_params",
          kind: "message",
          T: kkt,
          oneof: "params",
        },
        {
          no: 12,
          name: "list_dir_params",
          kind: "message",
          T: wkt,
          oneof: "params",
        },
        {
          no: 13,
          name: "edit_file_params",
          kind: "message",
          T: lkt,
          oneof: "params",
        },
        {
          no: 16,
          name: "file_search_params",
          kind: "message",
          T: fkt,
          oneof: "params",
        },
        {
          no: 17,
          name: "semantic_search_full_params",
          kind: "message",
          T: Ykt,
          oneof: "params",
        },
        {
          no: 18,
          name: "create_file_params",
          kind: "message",
          T: ltt,
          oneof: "params",
        },
        {
          no: 19,
          name: "delete_file_params",
          kind: "message",
          T: mtt,
          oneof: "params",
        },
        {
          no: 20,
          name: "reapply_params",
          kind: "message",
          T: KTt,
          oneof: "params",
        },
        {
          no: 21,
          name: "get_related_files_params",
          kind: "message",
          T: nkt,
          oneof: "params",
        },
        {
          no: 22,
          name: "parallel_apply_params",
          kind: "message",
          T: dbt,
          oneof: "params",
        },
        {
          no: 23,
          name: "run_terminal_command_v2_params",
          kind: "message",
          T: gbt,
          oneof: "params",
        },
        {
          no: 24,
          name: "fetch_rules_params",
          kind: "message",
          T: tkt,
          oneof: "params",
        },
        {
          no: 25,
          name: "planner_params",
          kind: "message",
          T: ikt,
          oneof: "params",
        },
        {
          no: 26,
          name: "web_search_params",
          kind: "message",
          T: Sbt,
          oneof: "params",
        },
        {
          no: 27,
          name: "mcp_params",
          kind: "message",
          T: xbt,
          oneof: "params",
        },
        {
          no: 28,
          name: "web_viewer_params",
          kind: "message",
          T: Pbt,
          oneof: "params",
        },
        {
          no: 29,
          name: "diff_history_params",
          kind: "message",
          T: Lbt,
          oneof: "params",
        },
        { no: 3, name: "tool_call_id", kind: "scalar", T: 9 },
        { no: 6, name: "timeout_ms", kind: "scalar", T: 1, opt: !0 },
        { no: 9, name: "name", kind: "scalar", T: 9 },
        { no: 10, name: "raw_args", kind: "scalar", T: 9 },
        { no: 14, name: "is_streaming", kind: "scalar", T: 8 },
        { no: 15, name: "is_last_message", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new j0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new j0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new j0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(j0, t, e)
    }
  },
  q7 = class V0 extends d {
    constructor(t) {
      super(),
        (this.tool = fr.UNSPECIFIED),
        (this.result = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ClientSideToolV2Result"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool", kind: "enum", T: n.getEnumType(fr) },
        {
          no: 2,
          name: "read_semsearch_files_result",
          kind: "message",
          T: ctt,
          oneof: "result",
        },
        {
          no: 3,
          name: "read_file_for_imports_result",
          kind: "message",
          T: Zkt,
          oneof: "result",
        },
        {
          no: 4,
          name: "ripgrep_search_result",
          kind: "message",
          T: Rkt,
          oneof: "result",
        },
        {
          no: 5,
          name: "run_terminal_command_result",
          kind: "message",
          T: nSt,
          oneof: "result",
        },
        {
          no: 6,
          name: "read_file_result",
          kind: "message",
          T: Skt,
          oneof: "result",
        },
        {
          no: 9,
          name: "list_dir_result",
          kind: "message",
          T: rtt,
          oneof: "result",
        },
        {
          no: 10,
          name: "edit_file_result",
          kind: "message",
          T: dkt,
          oneof: "result",
        },
        {
          no: 11,
          name: "file_search_result",
          kind: "message",
          T: gkt,
          oneof: "result",
        },
        {
          no: 18,
          name: "semantic_search_full_result",
          kind: "message",
          T: Qkt,
          oneof: "result",
        },
        {
          no: 19,
          name: "create_file_result",
          kind: "message",
          T: dtt,
          oneof: "result",
        },
        {
          no: 20,
          name: "delete_file_result",
          kind: "message",
          T: htt,
          oneof: "result",
        },
        {
          no: 21,
          name: "reapply_result",
          kind: "message",
          T: ZTt,
          oneof: "result",
        },
        {
          no: 22,
          name: "get_related_files_result",
          kind: "message",
          T: skt,
          oneof: "result",
        },
        {
          no: 23,
          name: "parallel_apply_result",
          kind: "message",
          T: hbt,
          oneof: "result",
        },
        {
          no: 24,
          name: "run_terminal_command_v2_result",
          kind: "message",
          T: wbt,
          oneof: "result",
        },
        {
          no: 25,
          name: "fetch_rules_result",
          kind: "message",
          T: ekt,
          oneof: "result",
        },
        {
          no: 26,
          name: "planner_result",
          kind: "message",
          T: rkt,
          oneof: "result",
        },
        {
          no: 27,
          name: "web_search_result",
          kind: "message",
          T: bbt,
          oneof: "result",
        },
        {
          no: 28,
          name: "mcp_result",
          kind: "message",
          T: Jbt,
          oneof: "result",
        },
        {
          no: 29,
          name: "web_viewer_result",
          kind: "message",
          T: Nbt,
          oneof: "result",
        },
        {
          no: 30,
          name: "diff_history_result",
          kind: "message",
          T: Rbt,
          oneof: "result",
        },
        { no: 8, name: "error", kind: "message", T: LU, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new V0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new V0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new V0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(V0, t, e)
    }
  },
  ckt = class G0 extends d {
    constructor(t) {
      super(),
        (this.tool = fr.UNSPECIFIED),
        (this.toolCallId = ""),
        (this.name = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamedBackPartialToolCall"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool", kind: "enum", T: n.getEnumType(fr) },
        { no: 2, name: "tool_call_id", kind: "scalar", T: 9 },
        { no: 3, name: "name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new G0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new G0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new G0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(G0, t, e)
    }
  },
  ukt = class z0 extends d {
    constructor(t) {
      super(),
        (this.tool = fr.UNSPECIFIED),
        (this.toolCallId = ""),
        (this.params = { case: void 0 }),
        (this.name = ""),
        (this.rawArgs = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamedBackToolCall"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool", kind: "enum", T: n.getEnumType(fr) },
        { no: 2, name: "tool_call_id", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "read_semsearch_files_stream",
          kind: "message",
          T: Gkt,
          oneof: "params",
        },
        {
          no: 4,
          name: "read_file_for_imports_stream",
          kind: "message",
          T: Kkt,
          oneof: "params",
        },
        {
          no: 5,
          name: "ripgrep_search_stream",
          kind: "message",
          T: Vkt,
          oneof: "params",
        },
        {
          no: 6,
          name: "run_terminal_command_stream",
          kind: "message",
          T: sSt,
          oneof: "params",
        },
        {
          no: 7,
          name: "read_file_stream",
          kind: "message",
          T: bkt,
          oneof: "params",
        },
        {
          no: 12,
          name: "list_dir_stream",
          kind: "message",
          T: Tkt,
          oneof: "params",
        },
        {
          no: 13,
          name: "edit_file_stream",
          kind: "message",
          T: hkt,
          oneof: "params",
        },
        {
          no: 14,
          name: "file_search_stream",
          kind: "message",
          T: pkt,
          oneof: "params",
        },
        {
          no: 19,
          name: "semantic_search_full_stream",
          kind: "message",
          T: Xkt,
          oneof: "params",
        },
        {
          no: 20,
          name: "create_file_stream",
          kind: "message",
          T: tSt,
          oneof: "params",
        },
        {
          no: 21,
          name: "delete_file_stream",
          kind: "message",
          T: eSt,
          oneof: "params",
        },
        {
          no: 22,
          name: "reapply_stream",
          kind: "message",
          T: okt,
          oneof: "params",
        },
        {
          no: 23,
          name: "get_related_files_stream",
          kind: "message",
          T: zkt,
          oneof: "params",
        },
        {
          no: 24,
          name: "parallel_apply_stream",
          kind: "message",
          T: pbt,
          oneof: "params",
        },
        {
          no: 25,
          name: "run_terminal_command_v2_stream",
          kind: "message",
          T: ybt,
          oneof: "params",
        },
        {
          no: 26,
          name: "fetch_rules_stream",
          kind: "message",
          T: Tbt,
          oneof: "params",
        },
        {
          no: 27,
          name: "planner_stream",
          kind: "message",
          T: kbt,
          oneof: "params",
        },
        {
          no: 28,
          name: "web_search_stream",
          kind: "message",
          T: Ibt,
          oneof: "params",
        },
        {
          no: 29,
          name: "mcp_stream",
          kind: "message",
          T: Cbt,
          oneof: "params",
        },
        {
          no: 30,
          name: "web_viewer_stream",
          kind: "message",
          T: $bt,
          oneof: "params",
        },
        {
          no: 31,
          name: "diff_history_stream",
          kind: "message",
          T: _bt,
          oneof: "params",
        },
        { no: 8, name: "name", kind: "scalar", T: 9 },
        { no: 9, name: "raw_args", kind: "scalar", T: 9 },
        { no: 10, name: "error", kind: "message", T: LU, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new z0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new z0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new z0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(z0, t, e)
    }
  },
  lkt = class Y0 extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.language = ""),
        (this.contents = ""),
        (this.blocking = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditFileParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "language", kind: "scalar", T: 9 },
        { no: 3, name: "contents", kind: "scalar", T: 9 },
        { no: 4, name: "blocking", kind: "scalar", T: 8 },
        { no: 5, name: "instructions", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Y0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Y0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Y0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Y0, t, e)
    }
  },
  dkt = class Q0 extends d {
    constructor(t) {
      super(),
        (this.isApplied = !1),
        (this.applyFailed = !1),
        (this.linterErrors = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditFileResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diff", kind: "message", T: RU },
        { no: 2, name: "is_applied", kind: "scalar", T: 8 },
        { no: 3, name: "apply_failed", kind: "scalar", T: 8 },
        { no: 4, name: "linter_errors", kind: "message", T: Js, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Q0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Q0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Q0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Q0, t, e)
    }
  },
  RU = class X0 extends d {
    constructor(t) {
      super(),
        (this.chunks = []),
        (this.editor = Sm.UNSPECIFIED),
        (this.hitTimeout = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditFileResult.FileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunks", kind: "message", T: mkt, repeated: !0 },
        { no: 2, name: "editor", kind: "enum", T: n.getEnumType(Sm) },
        { no: 3, name: "hit_timeout", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new X0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new X0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new X0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(X0, t, e)
    }
  },
  Sm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.AI = 1)] = "AI"),
    (i[(i.HUMAN = 2)] = "HUMAN")
})(Sm || (Sm = {})),
  n.util.setEnumType(Sm, "aiserver.v1.EditFileResult.FileDiff.Editor", [
    { no: 0, name: "EDITOR_UNSPECIFIED" },
    { no: 1, name: "EDITOR_AI" },
    { no: 2, name: "EDITOR_HUMAN" },
  ])
var mkt = class K0 extends d {
    constructor(t) {
      super(),
        (this.diffString = ""),
        (this.oldStart = 0),
        (this.newStart = 0),
        (this.oldLines = 0),
        (this.newLines = 0),
        (this.linesRemoved = 0),
        (this.linesAdded = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditFileResult.FileDiff.ChunkDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diff_string", kind: "scalar", T: 9 },
        { no: 2, name: "old_start", kind: "scalar", T: 5 },
        { no: 3, name: "new_start", kind: "scalar", T: 5 },
        { no: 4, name: "old_lines", kind: "scalar", T: 5 },
        { no: 5, name: "new_lines", kind: "scalar", T: 5 },
        { no: 6, name: "lines_removed", kind: "scalar", T: 5 },
        { no: 7, name: "lines_added", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new K0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new K0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new K0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(K0, t, e)
    }
  },
  hkt = class Z0 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditFileStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Z0().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Z0().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Z0().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Z0, t, e)
    }
  },
  fkt = class tT extends d {
    constructor(t) {
      super(), (this.query = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToolCallFileSearchParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new tT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tT, t, e)
    }
  },
  j2t = class eT extends d {
    constructor(t) {
      super(), (this.targetFiles = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToolCallGetRelatedFilesParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "target_files", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new eT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eT, t, e)
    }
  },
  pkt = class iT extends d {
    constructor(t) {
      super(), (this.query = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToolCallFileSearchStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new iT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iT, t, e)
    }
  },
  gkt = class rT extends d {
    constructor(t) {
      super(),
        (this.files = []),
        (this.numResults = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToolCallFileSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: vkt, repeated: !0 },
        { no: 2, name: "limit_hit", kind: "scalar", T: 8, opt: !0 },
        { no: 3, name: "num_results", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new rT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rT, t, e)
    }
  },
  vkt = class nT extends d {
    constructor(t) {
      super(), (this.uri = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToolCallFileSearchResult.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uri", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new nT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nT, t, e)
    }
  },
  wkt = class sT extends d {
    constructor(t) {
      super(), (this.directoryPath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListDirParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "directory_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new sT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sT, t, e)
    }
  },
  rtt = class aT extends d {
    constructor(t) {
      super(),
        (this.files = []),
        (this.directoryRelativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListDirResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: ykt, repeated: !0 },
        {
          no: 2,
          name: "directory_relative_workspace_path",
          kind: "scalar",
          T: 9,
        },
      ])
    }
    static fromBinary(t, e) {
      return new aT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aT, t, e)
    }
  },
  ykt = class oT extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.isDirectory = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListDirResult.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "is_directory", kind: "scalar", T: 8 },
        { no: 3, name: "size", kind: "scalar", T: 3, opt: !0 },
        { no: 4, name: "last_modified", kind: "message", T: bQ, opt: !0 },
        { no: 5, name: "num_children", kind: "scalar", T: 5, opt: !0 },
        { no: 6, name: "num_lines", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new oT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oT, t, e)
    }
  },
  Tkt = class cT extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ListDirStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new cT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cT, t, e)
    }
  },
  kkt = class uT extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.readEntireFile = !1),
        (this.fileIsAllowedToBeReadEntirely = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadFileParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "read_entire_file", kind: "scalar", T: 8 },
        {
          no: 3,
          name: "start_line_one_indexed",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 4,
          name: "end_line_one_indexed_inclusive",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 5,
          name: "file_is_allowed_to_be_read_entirely",
          kind: "scalar",
          T: 8,
        },
      ])
    }
    static fromBinary(t, e) {
      return new uT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uT, t, e)
    }
  },
  Skt = class lT extends d {
    constructor(t) {
      super(),
        (this.contents = ""),
        (this.didDowngradeToLineRange = !1),
        (this.didShortenLineRange = !1),
        (this.didSetDefaultLineRange = !1),
        (this.relativeWorkspacePath = ""),
        (this.didShortenCharRange = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadFileResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "contents", kind: "scalar", T: 9 },
        { no: 2, name: "did_downgrade_to_line_range", kind: "scalar", T: 8 },
        { no: 3, name: "did_shorten_line_range", kind: "scalar", T: 8 },
        { no: 4, name: "did_set_default_line_range", kind: "scalar", T: 8 },
        { no: 5, name: "full_file_contents", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "outline", kind: "scalar", T: 9, opt: !0 },
        {
          no: 7,
          name: "start_line_one_indexed",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 8,
          name: "end_line_one_indexed_inclusive",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 9, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 10, name: "did_shorten_char_range", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new lT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lT, t, e)
    }
  },
  bkt = class dT extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadFileStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new dT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dT, t, e)
    }
  },
  Ekt = class mT extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "options", kind: "message", T: Nkt },
        { no: 2, name: "pattern_info", kind: "message", T: Ikt },
      ])
    }
    static fromBinary(t, e) {
      return new mT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mT, t, e)
    }
  },
  Ikt = class hT extends d {
    constructor(t) {
      super(), (this.pattern = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchParams.IPatternInfoProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "pattern", kind: "scalar", T: 9 },
        { no: 2, name: "is_reg_exp", kind: "scalar", T: 8, opt: !0 },
        { no: 3, name: "is_word_match", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "word_separators", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "is_multiline", kind: "scalar", T: 8, opt: !0 },
        { no: 6, name: "is_unicode", kind: "scalar", T: 8, opt: !0 },
        { no: 7, name: "is_case_sensitive", kind: "scalar", T: 8, opt: !0 },
        { no: 8, name: "notebook_info", kind: "message", T: Pkt },
      ])
    }
    static fromBinary(t, e) {
      return new hT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hT, t, e)
    }
  },
  Pkt = class fT extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchParams.IPatternInfoProto.INotebookPatternInfoProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "is_in_notebook_markdown_input",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 2,
          name: "is_in_notebook_markdown_preview",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 3,
          name: "is_in_notebook_cell_input",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 4,
          name: "is_in_notebook_cell_output",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new fT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fT, t, e)
    }
  },
  Nkt = class pT extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchParams.ITextQueryBuilderOptionsProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "preview_options", kind: "message", T: Ckt },
        { no: 2, name: "file_encoding", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "surrounding_context", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "is_smart_case", kind: "scalar", T: 8, opt: !0 },
        { no: 5, name: "notebook_search_config", kind: "message", T: Lkt },
        { no: 6, name: "exclude_pattern", kind: "message", T: xkt },
        { no: 7, name: "include_pattern", kind: "message", T: ntt },
        { no: 8, name: "expand_patterns", kind: "scalar", T: 8, opt: !0 },
        { no: 9, name: "max_results", kind: "scalar", T: 5, opt: !0 },
        { no: 10, name: "max_file_size", kind: "scalar", T: 5, opt: !0 },
        {
          no: 11,
          name: "disregard_ignore_files",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 12,
          name: "disregard_global_ignore_files",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 13,
          name: "disregard_parent_ignore_files",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 14,
          name: "disregard_exclude_settings",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 15,
          name: "disregard_search_exclude_settings",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 16, name: "ignore_symlinks", kind: "scalar", T: 8, opt: !0 },
        { no: 17, name: "only_open_editors", kind: "scalar", T: 8, opt: !0 },
        { no: 18, name: "only_file_scheme", kind: "scalar", T: 8, opt: !0 },
        { no: 19, name: "reason", kind: "scalar", T: 9, opt: !0 },
        { no: 20, name: "extra_file_resources", kind: "message", T: $kt },
      ])
    }
    static fromBinary(t, e) {
      return new pT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pT, t, e)
    }
  },
  $kt = class gT extends d {
    constructor(t) {
      super(), (this.extraFileResources = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchParams.ITextQueryBuilderOptionsProto.ExtraFileResourcesProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "extra_file_resources",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new gT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gT, t, e)
    }
  },
  xkt = class vT extends d {
    constructor(t) {
      super(), (this.excludePattern = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchParams.ITextQueryBuilderOptionsProto.ExcludePatternProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "exclude_pattern",
          kind: "message",
          T: Jkt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new vT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vT, t, e)
    }
  },
  Jkt = class wT extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchParams.ITextQueryBuilderOptionsProto.ISearchPatternBuilderProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uri", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "pattern", kind: "message", T: ntt },
      ])
    }
    static fromBinary(t, e) {
      return new wT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wT, t, e)
    }
  },
  ntt = class yT extends d {
    constructor(t) {
      super(), (this.patterns = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchParams.ITextQueryBuilderOptionsProto.ISearchPathPatternBuilderProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "pattern", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "patterns", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new yT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yT, t, e)
    }
  },
  Ckt = class TT extends d {
    constructor(t) {
      super(),
        (this.matchLines = 0),
        (this.charsPerLine = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchParams.ITextQueryBuilderOptionsProto.ITextSearchPreviewOptionsProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "match_lines", kind: "scalar", T: 5 },
        { no: 2, name: "chars_per_line", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new TT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TT, t, e)
    }
  },
  Lkt = class kT extends d {
    constructor(t) {
      super(),
        (this.includeMarkupInput = !1),
        (this.includeMarkupPreview = !1),
        (this.includeCodeInput = !1),
        (this.includeOutput = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchParams.ITextQueryBuilderOptionsProto.INotebookSearchConfigProto"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "include_markup_input", kind: "scalar", T: 8 },
        { no: 2, name: "include_markup_preview", kind: "scalar", T: 8 },
        { no: 3, name: "include_code_input", kind: "scalar", T: 8 },
        { no: 4, name: "include_output", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new kT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kT, t, e)
    }
  },
  Rkt = class ST extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "internal", kind: "message", T: Dkt },
      ])
    }
    static fromBinary(t, e) {
      return new ST().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ST().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ST().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ST, t, e)
    }
  },
  Dkt = class bT extends d {
    constructor(t) {
      super(),
        (this.results = []),
        (this.messages = []),
        (this.stats = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchResultInternal"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "results", kind: "message", T: Fkt, repeated: !0 },
        { no: 2, name: "exit", kind: "enum", T: n.getEnumType(U7), opt: !0 },
        { no: 3, name: "limit_hit", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "messages", kind: "message", T: qkt, repeated: !0 },
        {
          no: 5,
          name: "file_search_stats",
          kind: "message",
          T: Ukt,
          oneof: "stats",
        },
        {
          no: 6,
          name: "text_search_stats",
          kind: "message",
          T: Mkt,
          oneof: "stats",
        },
      ])
    }
    static fromBinary(t, e) {
      return new bT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bT, t, e)
    }
  },
  bm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.INFORMATION = 1)] = "INFORMATION"),
    (i[(i.WARNING = 2)] = "WARNING")
})(bm || (bm = {})),
  n.util.setEnumType(
    bm,
    "aiserver.v1.RipgrepSearchResultInternal.TextSearchCompleteMessageType",
    [
      { no: 0, name: "TEXT_SEARCH_COMPLETE_MESSAGE_TYPE_UNSPECIFIED" },
      { no: 1, name: "TEXT_SEARCH_COMPLETE_MESSAGE_TYPE_INFORMATION" },
      { no: 2, name: "TEXT_SEARCH_COMPLETE_MESSAGE_TYPE_WARNING" },
    ],
  )
var U7
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.NORMAL = 1)] = "NORMAL"),
    (i[(i.NEW_SEARCH_STARTED = 2)] = "NEW_SEARCH_STARTED")
})(U7 || (U7 = {})),
  n.util.setEnumType(
    U7,
    "aiserver.v1.RipgrepSearchResultInternal.SearchCompletionExitCode",
    [
      { no: 0, name: "SEARCH_COMPLETION_EXIT_CODE_UNSPECIFIED" },
      { no: 1, name: "SEARCH_COMPLETION_EXIT_CODE_NORMAL" },
      { no: 2, name: "SEARCH_COMPLETION_EXIT_CODE_NEW_SEARCH_STARTED" },
    ],
  )
var Fkt = class ET extends d {
    constructor(t) {
      super(),
        (this.resource = ""),
        (this.results = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchResultInternal.IFileMatch"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "resource", kind: "scalar", T: 9 },
        { no: 2, name: "results", kind: "message", T: _kt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ET().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ET().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ET().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ET, t, e)
    }
  },
  _kt = class IT extends d {
    constructor(t) {
      super(), (this.result = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchResultInternal.ITextSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "match", kind: "message", T: Akt, oneof: "result" },
        { no: 2, name: "context", kind: "message", T: Bkt, oneof: "result" },
      ])
    }
    static fromBinary(t, e) {
      return new IT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IT, t, e)
    }
  },
  Akt = class PT extends d {
    constructor(t) {
      super(),
        (this.rangeLocations = []),
        (this.previewText = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchResultInternal.ITextSearchMatch"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uri", kind: "scalar", T: 9, opt: !0 },
        {
          no: 2,
          name: "range_locations",
          kind: "message",
          T: Okt,
          repeated: !0,
        },
        { no: 3, name: "preview_text", kind: "scalar", T: 9 },
        { no: 4, name: "webview_index", kind: "scalar", T: 5, opt: !0 },
        { no: 5, name: "cell_fragment", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new PT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PT, t, e)
    }
  },
  Bkt = class NT extends d {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.lineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchResultInternal.ITextSearchContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uri", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
        { no: 3, name: "line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new NT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NT, t, e)
    }
  },
  Okt = class $T extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchResultInternal.ISearchRangeSetPairing"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "source", kind: "message", T: stt },
        { no: 2, name: "preview", kind: "message", T: stt },
      ])
    }
    static fromBinary(t, e) {
      return new $T().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $T().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $T().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($T, t, e)
    }
  },
  stt = class xT extends d {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.startColumn = 0),
        (this.endLineNumber = 0),
        (this.endColumn = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchResultInternal.ISearchRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "start_column", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "end_column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new xT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xT, t, e)
    }
  },
  qkt = class JT extends d {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.type = bm.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchResultInternal.ITextSearchCompleteMessage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "type", kind: "enum", T: n.getEnumType(bm) },
        { no: 3, name: "trusted", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new JT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JT, t, e)
    }
  },
  Ukt = class CT extends d {
    constructor(t) {
      super(),
        (this.fromCache = !1),
        (this.detailStats = { case: void 0 }),
        (this.resultCount = 0),
        (this.type = Em.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchResultInternal.IFileSearchStats"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "from_cache", kind: "scalar", T: 8 },
        {
          no: 2,
          name: "search_engine_stats",
          kind: "message",
          T: Hkt,
          oneof: "detail_stats",
        },
        {
          no: 3,
          name: "cached_search_stats",
          kind: "message",
          T: Wkt,
          oneof: "detail_stats",
        },
        {
          no: 4,
          name: "file_search_provider_stats",
          kind: "message",
          T: jkt,
          oneof: "detail_stats",
        },
        { no: 5, name: "result_count", kind: "scalar", T: 5 },
        { no: 6, name: "type", kind: "enum", T: n.getEnumType(Em) },
        { no: 7, name: "sorting_time", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new CT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CT, t, e)
    }
  },
  Em
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.FILE_SEARCH_PROVIDER = 1)] = "FILE_SEARCH_PROVIDER"),
    (i[(i.SEARCH_PROCESS = 2)] = "SEARCH_PROCESS")
})(Em || (Em = {})),
  n.util.setEnumType(
    Em,
    "aiserver.v1.RipgrepSearchResultInternal.IFileSearchStats.FileSearchProviderType",
    [
      { no: 0, name: "FILE_SEARCH_PROVIDER_TYPE_UNSPECIFIED" },
      { no: 1, name: "FILE_SEARCH_PROVIDER_TYPE_FILE_SEARCH_PROVIDER" },
      { no: 2, name: "FILE_SEARCH_PROVIDER_TYPE_SEARCH_PROCESS" },
    ],
  )
var Mkt = class LT extends d {
    constructor(t) {
      super(), (this.type = Im.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchResultInternal.ITextSearchStats"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type", kind: "enum", T: n.getEnumType(Im) },
      ])
    }
    static fromBinary(t, e) {
      return new LT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LT, t, e)
    }
  },
  Im
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.TEXT_SEARCH_PROVIDER = 1)] = "TEXT_SEARCH_PROVIDER"),
    (i[(i.SEARCH_PROCESS = 2)] = "SEARCH_PROCESS"),
    (i[(i.AI_TEXT_SEARCH_PROVIDER = 3)] = "AI_TEXT_SEARCH_PROVIDER")
})(Im || (Im = {})),
  n.util.setEnumType(
    Im,
    "aiserver.v1.RipgrepSearchResultInternal.ITextSearchStats.TextSearchProviderType",
    [
      { no: 0, name: "TEXT_SEARCH_PROVIDER_TYPE_UNSPECIFIED" },
      { no: 1, name: "TEXT_SEARCH_PROVIDER_TYPE_TEXT_SEARCH_PROVIDER" },
      { no: 2, name: "TEXT_SEARCH_PROVIDER_TYPE_SEARCH_PROCESS" },
      { no: 3, name: "TEXT_SEARCH_PROVIDER_TYPE_AI_TEXT_SEARCH_PROVIDER" },
    ],
  )
var Hkt = class RT extends d {
    constructor(t) {
      super(),
        (this.fileWalkTime = 0),
        (this.directoriesWalked = 0),
        (this.filesWalked = 0),
        (this.cmdTime = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchResultInternal.ISearchEngineStats"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_walk_time", kind: "scalar", T: 5 },
        { no: 2, name: "directories_walked", kind: "scalar", T: 5 },
        { no: 3, name: "files_walked", kind: "scalar", T: 5 },
        { no: 4, name: "cmd_time", kind: "scalar", T: 5 },
        { no: 5, name: "cmd_result_count", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new RT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RT, t, e)
    }
  },
  Wkt = class DT extends d {
    constructor(t) {
      super(),
        (this.cacheWasResolved = !1),
        (this.cacheLookupTime = 0),
        (this.cacheFilterTime = 0),
        (this.cacheEntryCount = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchResultInternal.ICachedSearchStats"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cache_was_resolved", kind: "scalar", T: 8 },
        { no: 2, name: "cache_lookup_time", kind: "scalar", T: 5 },
        { no: 3, name: "cache_filter_time", kind: "scalar", T: 5 },
        { no: 4, name: "cache_entry_count", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new DT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DT, t, e)
    }
  },
  jkt = class FT extends d {
    constructor(t) {
      super(),
        (this.providerTime = 0),
        (this.postProcessTime = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.RipgrepSearchResultInternal.IFileSearchProviderStats"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "provider_time", kind: "scalar", T: 5 },
        { no: 2, name: "post_process_time", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new FT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FT, t, e)
    }
  },
  Vkt = class _T extends d {
    constructor(t) {
      super(), (this.query = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RipgrepSearchStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new _T().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _T().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _T().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_T, t, e)
    }
  },
  att = class AT extends d {
    constructor(t) {
      super(),
        (this.codeResults = []),
        (this.query = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadSemsearchFilesParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository_info", kind: "message", T: _t },
        { no: 2, name: "code_results", kind: "message", T: fi, repeated: !0 },
        { no: 3, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new AT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AT, t, e)
    }
  },
  ott = class BT extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.missingReason = Pm.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MissingFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "missing_reason", kind: "enum", T: n.getEnumType(Pm) },
        { no: 3, name: "num_lines", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new BT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BT, t, e)
    }
  },
  Pm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.TOO_LARGE = 1)] = "TOO_LARGE"),
    (i[(i.NOT_FOUND = 2)] = "NOT_FOUND")
})(Pm || (Pm = {})),
  n.util.setEnumType(Pm, "aiserver.v1.MissingFile.MissingReason", [
    { no: 0, name: "MISSING_REASON_UNSPECIFIED" },
    { no: 1, name: "MISSING_REASON_TOO_LARGE" },
    { no: 2, name: "MISSING_REASON_NOT_FOUND" },
  ])
var ctt = class OT extends d {
    constructor(t) {
      super(),
        (this.codeResults = []),
        (this.allFiles = []),
        (this.missingFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadSemsearchFilesResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_results", kind: "message", T: fi, repeated: !0 },
        { no: 2, name: "all_files", kind: "message", T: nr, repeated: !0 },
        { no: 3, name: "missing_files", kind: "message", T: ott, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new OT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OT, t, e)
    }
  },
  Gkt = class qT extends d {
    constructor(t) {
      super(), (this.numFiles = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadSemsearchFilesStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "num_files", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new qT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qT, t, e)
    }
  },
  zkt = class UT extends d {
    constructor(t) {
      super(), (this.targetFiles = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetRelatedFilesStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "target_files", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new UT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UT, t, e)
    }
  },
  Ykt = class MT extends d {
    constructor(t) {
      super(), (this.query = ""), (this.topK = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemanticSearchFullParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository_info", kind: "message", T: _t },
        { no: 2, name: "query", kind: "scalar", T: 9 },
        { no: 3, name: "include_pattern", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "exclude_pattern", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "top_k", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new MT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MT, t, e)
    }
  },
  Qkt = class HT extends d {
    constructor(t) {
      super(),
        (this.codeResults = []),
        (this.allFiles = []),
        (this.missingFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemanticSearchFullResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_results", kind: "message", T: fi, repeated: !0 },
        { no: 2, name: "all_files", kind: "message", T: nr, repeated: !0 },
        { no: 3, name: "missing_files", kind: "message", T: ott, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new HT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HT, t, e)
    }
  },
  Xkt = class WT extends d {
    constructor(t) {
      super(), (this.numFiles = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemanticSearchFullStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "num_files", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new WT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WT, t, e)
    }
  },
  Kkt = class jT extends d {
    constructor(t) {
      super(), (this.relativeFilePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadFileForImportsStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_file_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new jT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jT, t, e)
    }
  },
  utt = class VT extends d {
    constructor(t) {
      super(), (this.relativeFilePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadFileForImportsParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_file_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new VT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VT, t, e)
    }
  },
  Zkt = class GT extends d {
    constructor(t) {
      super(), (this.contents = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadFileForImportsResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new GT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GT, t, e)
    }
  },
  tSt = class zT extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateFileStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new zT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zT, t, e)
    }
  },
  ltt = class YT extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateFileParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new YT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YT, t, e)
    }
  },
  dtt = class QT extends d {
    constructor(t) {
      super(),
        (this.fileCreatedSuccessfully = !1),
        (this.fileAlreadyExists = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateFileResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_created_successfully", kind: "scalar", T: 8 },
        { no: 2, name: "file_already_exists", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new QT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QT, t, e)
    }
  },
  mtt = class XT extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteFileParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new XT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XT, t, e)
    }
  },
  htt = class KT extends d {
    constructor(t) {
      super(),
        (this.rejected = !1),
        (this.fileNonExistent = !1),
        (this.fileDeletedSuccessfully = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteFileResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "rejected", kind: "scalar", T: 8 },
        { no: 2, name: "file_non_existent", kind: "scalar", T: 8 },
        { no: 3, name: "file_deleted_successfully", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new KT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KT, t, e)
    }
  },
  eSt = class ZT extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteFileStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ZT().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZT().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZT().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZT, t, e)
    }
  },
  iSt = class tk extends d {
    constructor(t) {
      super(),
        (this.command = ""),
        (this.requireUserApproval = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
        { no: 2, name: "cwd", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "new_session", kind: "scalar", T: 8, opt: !0 },
        { no: 5, name: "require_user_approval", kind: "scalar", T: 8 },
        { no: 4, name: "options", kind: "message", T: rSt, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new tk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tk, t, e)
    }
  },
  rSt = class ek extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandParams.ExecutionOptions"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "timeout", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "skip_ai_check", kind: "scalar", T: 8, opt: !0 },
        {
          no: 3,
          name: "command_run_timeout_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 4,
          name: "command_change_check_interval_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 5,
          name: "ai_finish_check_max_attempts",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 6,
          name: "ai_finish_check_interval_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 7, name: "delayer_interval_ms", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ek().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ek().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ek().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ek, t, e)
    }
  },
  nSt = class ik extends d {
    constructor(t) {
      super(),
        (this.output = ""),
        (this.exitCode = 0),
        (this.poppedOutIntoBackground = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "output", kind: "scalar", T: 9 },
        { no: 2, name: "exit_code", kind: "scalar", T: 5 },
        { no: 3, name: "rejected", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "popped_out_into_background", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new ik().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ik().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ik().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ik, t, e)
    }
  },
  sSt = class rk extends d {
    constructor(t) {
      super(), (this.command = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new rk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rk, t, e)
    }
  },
  aSt = class nk extends d {
    constructor(t) {
      super(),
        (this.tool = Ua.UNSPECIFIED),
        (this.params = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BuiltinToolCall"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool", kind: "enum", T: n.getEnumType(Ua) },
        {
          no: 2,
          name: "search_params",
          kind: "message",
          T: ISt,
          oneof: "params",
        },
        {
          no: 3,
          name: "read_chunk_params",
          kind: "message",
          T: xSt,
          oneof: "params",
        },
        {
          no: 4,
          name: "gotodef_params",
          kind: "message",
          T: BSt,
          oneof: "params",
        },
        {
          no: 5,
          name: "edit_params",
          kind: "message",
          T: jSt,
          oneof: "params",
        },
        {
          no: 6,
          name: "undo_edit_params",
          kind: "message",
          T: CSt,
          oneof: "params",
        },
        { no: 7, name: "end_params", kind: "message", T: LSt, oneof: "params" },
        {
          no: 8,
          name: "new_file_params",
          kind: "message",
          T: kSt,
          oneof: "params",
        },
        {
          no: 9,
          name: "add_test_params",
          kind: "message",
          T: YSt,
          oneof: "params",
        },
        {
          no: 10,
          name: "run_test_params",
          kind: "message",
          T: ZSt,
          oneof: "params",
        },
        {
          no: 11,
          name: "delete_test_params",
          kind: "message",
          T: nbt,
          oneof: "params",
        },
        {
          no: 12,
          name: "save_file_params",
          kind: "message",
          T: abt,
          oneof: "params",
        },
        {
          no: 13,
          name: "get_tests_params",
          kind: "message",
          T: ebt,
          oneof: "params",
        },
        {
          no: 14,
          name: "get_symbols_params",
          kind: "message",
          T: cbt,
          oneof: "params",
        },
        {
          no: 15,
          name: "semantic_search_params",
          kind: "message",
          T: SSt,
          oneof: "params",
        },
        {
          no: 16,
          name: "get_project_structure_params",
          kind: "message",
          T: wSt,
          oneof: "params",
        },
        {
          no: 17,
          name: "create_rm_files_params",
          kind: "message",
          T: gSt,
          oneof: "params",
        },
        {
          no: 18,
          name: "run_terminal_commands_params",
          kind: "message",
          T: fSt,
          oneof: "params",
        },
        {
          no: 19,
          name: "new_edit_params",
          kind: "message",
          T: HSt,
          oneof: "params",
        },
        {
          no: 20,
          name: "read_with_linter_params",
          kind: "message",
          T: mSt,
          oneof: "params",
        },
        {
          no: 21,
          name: "add_ui_step_params",
          kind: "message",
          T: cSt,
          oneof: "params",
        },
        {
          no: 23,
          name: "read_semsearch_files_params",
          kind: "message",
          T: att,
          oneof: "params",
        },
        {
          no: 24,
          name: "read_file_for_imports_params",
          kind: "message",
          T: utt,
          oneof: "params",
        },
        {
          no: 25,
          name: "create_file_params",
          kind: "message",
          T: ltt,
          oneof: "params",
        },
        {
          no: 26,
          name: "delete_file_params",
          kind: "message",
          T: mtt,
          oneof: "params",
        },
        { no: 22, name: "tool_call_id", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new nk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nk, t, e)
    }
  },
  oSt = class sk extends d {
    constructor(t) {
      super(),
        (this.tool = Ua.UNSPECIFIED),
        (this.result = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BuiltinToolResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool", kind: "enum", T: n.getEnumType(Ua) },
        {
          no: 2,
          name: "search_result",
          kind: "message",
          T: $St,
          oneof: "result",
        },
        {
          no: 3,
          name: "read_chunk_result",
          kind: "message",
          T: JSt,
          oneof: "result",
        },
        {
          no: 4,
          name: "gotodef_result",
          kind: "message",
          T: USt,
          oneof: "result",
        },
        {
          no: 5,
          name: "edit_result",
          kind: "message",
          T: VSt,
          oneof: "result",
        },
        {
          no: 6,
          name: "undo_edit_result",
          kind: "message",
          T: DSt,
          oneof: "result",
        },
        { no: 7, name: "end_result", kind: "message", T: FSt, oneof: "result" },
        {
          no: 8,
          name: "new_file_result",
          kind: "message",
          T: RSt,
          oneof: "result",
        },
        {
          no: 9,
          name: "add_test_result",
          kind: "message",
          T: QSt,
          oneof: "result",
        },
        {
          no: 10,
          name: "run_test_result",
          kind: "message",
          T: tbt,
          oneof: "result",
        },
        {
          no: 11,
          name: "delete_test_result",
          kind: "message",
          T: sbt,
          oneof: "result",
        },
        {
          no: 12,
          name: "save_file_result",
          kind: "message",
          T: obt,
          oneof: "result",
        },
        {
          no: 13,
          name: "get_tests_result",
          kind: "message",
          T: ibt,
          oneof: "result",
        },
        {
          no: 14,
          name: "get_symbols_result",
          kind: "message",
          T: lbt,
          oneof: "result",
        },
        {
          no: 15,
          name: "semantic_search_result",
          kind: "message",
          T: bSt,
          oneof: "result",
        },
        {
          no: 16,
          name: "get_project_structure_result",
          kind: "message",
          T: ySt,
          oneof: "result",
        },
        {
          no: 17,
          name: "create_rm_files_result",
          kind: "message",
          T: vSt,
          oneof: "result",
        },
        {
          no: 18,
          name: "run_terminal_commands_result",
          kind: "message",
          T: pSt,
          oneof: "result",
        },
        {
          no: 19,
          name: "new_edit_result",
          kind: "message",
          T: WSt,
          oneof: "result",
        },
        {
          no: 20,
          name: "read_with_linter_result",
          kind: "message",
          T: hSt,
          oneof: "result",
        },
        {
          no: 21,
          name: "add_ui_step_result",
          kind: "message",
          T: dSt,
          oneof: "result",
        },
        {
          no: 22,
          name: "read_semsearch_files_result",
          kind: "message",
          T: ctt,
          oneof: "result",
        },
        {
          no: 23,
          name: "create_file_result",
          kind: "message",
          T: dtt,
          oneof: "result",
        },
        {
          no: 24,
          name: "delete_file_result",
          kind: "message",
          T: htt,
          oneof: "result",
        },
      ])
    }
    static fromBinary(t, e) {
      return new sk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sk, t, e)
    }
  },
  cSt = class ak extends d {
    constructor(t) {
      super(),
        (this.conversationId = ""),
        (this.step = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddUiStepParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "conversation_id", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "search_results",
          kind: "message",
          T: lSt,
          oneof: "step",
        },
      ])
    }
    static fromBinary(t, e) {
      return new ak().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ak().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ak().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ak, t, e)
    }
  },
  uSt = class ok extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddUiStepParams.SearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ok().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ok().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ok().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ok, t, e)
    }
  },
  lSt = class ck extends d {
    constructor(t) {
      super(), (this.searchResults = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddUiStepParams.SearchResults"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "search_results",
          kind: "message",
          T: uSt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new ck().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ck().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ck().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ck, t, e)
    }
  },
  dSt = class uk extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddUiStepResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new uk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uk, t, e)
    }
  },
  V2t = class lk extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ServerSideToolResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new lk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lk, t, e)
    }
  },
  ftt = class dk extends d {
    constructor(t) {
      super(), (this.toolCall = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToolCall"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "builtin_tool_call",
          kind: "message",
          T: aSt,
          oneof: "tool_call",
        },
        {
          no: 2,
          name: "custom_tool_call",
          kind: "message",
          T: _St,
          oneof: "tool_call",
        },
      ])
    }
    static fromBinary(t, e) {
      return new dk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dk, t, e)
    }
  },
  DU = class mk extends d {
    constructor(t) {
      super(), (this.toolResult = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToolResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "builtin_tool_result",
          kind: "message",
          T: oSt,
          oneof: "tool_result",
        },
        {
          no: 2,
          name: "custom_tool_result",
          kind: "message",
          T: ASt,
          oneof: "tool_result",
        },
        {
          no: 3,
          name: "error_tool_result",
          kind: "message",
          T: MSt,
          oneof: "tool_result",
        },
      ])
    }
    static fromBinary(t, e) {
      return new mk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mk, t, e)
    }
  },
  mSt = class hk extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadWithLinterParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new hk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hk, t, e)
    }
  },
  hSt = class fk extends d {
    constructor(t) {
      super(),
        (this.contents = ""),
        (this.diagnostics = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadWithLinterResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "contents", kind: "scalar", T: 9 },
        { no: 2, name: "diagnostics", kind: "message", T: PQ, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new fk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fk, t, e)
    }
  },
  fSt = class pk extends d {
    constructor(t) {
      super(),
        (this.commands = []),
        (this.commandsUuid = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandsParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "commands", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "commands_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new pk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pk, t, e)
    }
  },
  pSt = class gk extends d {
    constructor(t) {
      super(), (this.outputs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandsResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "outputs", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new gk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gk, t, e)
    }
  },
  gSt = class vk extends d {
    constructor(t) {
      super(),
        (this.removedFilePaths = []),
        (this.createdFilePaths = []),
        (this.createdDirectoryPaths = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateRmFilesParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "removed_file_paths",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 2,
          name: "created_file_paths",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 3,
          name: "created_directory_paths",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new vk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vk, t, e)
    }
  },
  vSt = class wk extends d {
    constructor(t) {
      super(),
        (this.createdFilePaths = []),
        (this.removedFilePaths = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateRmFilesResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "created_file_paths",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 2,
          name: "removed_file_paths",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new wk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wk, t, e)
    }
  },
  wSt = class yk extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetProjectStructureParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new yk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yk, t, e)
    }
  },
  ySt = class Tk extends d {
    constructor(t) {
      super(),
        (this.files = []),
        (this.rootWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetProjectStructureResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: TSt, repeated: !0 },
        { no: 2, name: "root_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Tk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Tk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Tk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Tk, t, e)
    }
  },
  TSt = class kk extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.outline = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetProjectStructureResult.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "outline", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new kk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kk, t, e)
    }
  },
  kSt = class Sk extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.NewFileParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Sk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Sk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Sk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Sk, t, e)
    }
  },
  SSt = class bk extends d {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.topK = 0),
        (this.grabWholeFile = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemanticSearchParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "include_pattern", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "exclude_pattern", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "top_k", kind: "scalar", T: 5 },
        { no: 5, name: "index_id", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "grab_whole_file", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new bk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bk, t, e)
    }
  },
  bSt = class Ek extends d {
    constructor(t) {
      super(),
        (this.results = []),
        (this.files = {}),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemanticSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "results", kind: "message", T: ESt, repeated: !0 },
        {
          no: 2,
          name: "files",
          kind: "map",
          K: 9,
          V: { kind: "scalar", T: 9 },
        },
      ])
    }
    static fromBinary(t, e) {
      return new Ek().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ek().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ek().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ek, t, e)
    }
  },
  ESt = class Ik extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.score = 0),
        (this.content = ""),
        (this.detailedLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SemanticSearchResult.Item"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "score", kind: "scalar", T: 2 },
        { no: 3, name: "content", kind: "scalar", T: 9 },
        { no: 4, name: "range", kind: "message", T: mi },
        { no: 5, name: "original_content", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "detailed_lines", kind: "message", T: _q, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Ik().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ik().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ik().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ik, t, e)
    }
  },
  ISt = class Pk extends d {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.regex = !1),
        (this.includePattern = ""),
        (this.excludePattern = ""),
        (this.filenameSearch = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "regex", kind: "scalar", T: 8 },
        { no: 3, name: "include_pattern", kind: "scalar", T: 9 },
        { no: 4, name: "exclude_pattern", kind: "scalar", T: 9 },
        { no: 5, name: "filename_search", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Pk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Pk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Pk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Pk, t, e)
    }
  },
  PSt = class Nk extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.numMatches = 0),
        (this.potentiallyRelevantLines = []),
        (this.cropped = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchToolFileSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "num_matches", kind: "scalar", T: 5 },
        {
          no: 3,
          name: "potentially_relevant_lines",
          kind: "message",
          T: NSt,
          repeated: !0,
        },
        { no: 4, name: "cropped", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Nk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Nk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Nk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Nk, t, e)
    }
  },
  NSt = class $k extends d {
    constructor(t) {
      super(),
        (this.lineNumber = 0),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchToolFileSearchResult.Line"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line_number", kind: "scalar", T: 5 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $k().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $k().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $k().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($k, t, e)
    }
  },
  $St = class xk extends d {
    constructor(t) {
      super(),
        (this.fileResults = []),
        (this.numTotalMatches = 0),
        (this.numTotalMatchedFiles = 0),
        (this.numTotalMayBeIncomplete = !1),
        (this.filesOnly = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_results", kind: "message", T: PSt, repeated: !0 },
        { no: 2, name: "num_total_matches", kind: "scalar", T: 5 },
        { no: 3, name: "num_total_matched_files", kind: "scalar", T: 5 },
        { no: 4, name: "num_total_may_be_incomplete", kind: "scalar", T: 8 },
        { no: 5, name: "files_only", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new xk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xk, t, e)
    }
  },
  xSt = class Jk extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadChunkParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "num_lines", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Jk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Jk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Jk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Jk, t, e)
    }
  },
  JSt = class Ck extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumber = 0),
        (this.lines = []),
        (this.totalNumLines = 0),
        (this.cropped = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReadChunkResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "total_num_lines", kind: "scalar", T: 5 },
        { no: 5, name: "cropped", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Ck().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ck().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ck().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ck, t, e)
    }
  },
  CSt = class Lk extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UndoEditParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Lk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Lk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Lk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Lk, t, e)
    }
  },
  LSt = class Rk extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EndParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Rk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Rk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Rk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Rk, t, e)
    }
  },
  RSt = class Dk extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.fileTotalLines = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.NewFileResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_total_lines", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Dk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Dk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Dk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Dk, t, e)
    }
  },
  DSt = class Fk extends d {
    constructor(t) {
      super(),
        (this.feedback = []),
        (this.relativeWorkspacePath = ""),
        (this.contextStartLineNumber = 0),
        (this.contextLines = []),
        (this.contextTotalNumLines = 0),
        (this.fileTotalLines = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UndoEditResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "feedback", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "context_start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "context_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "context_total_num_lines", kind: "scalar", T: 5 },
        { no: 6, name: "file_total_lines", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Fk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Fk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Fk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Fk, t, e)
    }
  },
  FSt = class _k extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EndResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new _k().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _k().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _k().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_k, t, e)
    }
  },
  _St = class Ak extends d {
    constructor(t) {
      super(),
        (this.toolId = ""),
        (this.params = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CustomToolCall"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool_id", kind: "scalar", T: 9 },
        { no: 2, name: "params", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ak().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ak().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ak().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ak, t, e)
    }
  },
  G2t = class Bk extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ScratchpadResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Bk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Bk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Bk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Bk, t, e)
    }
  },
  ASt = class Ok extends d {
    constructor(t) {
      super(),
        (this.toolId = ""),
        (this.result = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CustomToolResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool_id", kind: "scalar", T: 9 },
        { no: 2, name: "result", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ok().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ok().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ok().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ok, t, e)
    }
  },
  BSt = class qk extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.lineNumber = 0),
        (this.symbol = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GotodefParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
        { no: 3, name: "symbol", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new qk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qk, t, e)
    }
  },
  OSt = class Uk extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.potentiallyRelevantLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GotodefToolFileSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "potentially_relevant_lines",
          kind: "message",
          T: qSt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Uk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Uk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Uk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Uk, t, e)
    }
  },
  qSt = class Mk extends d {
    constructor(t) {
      super(),
        (this.lineNumber = 0),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GotodefToolFileSearchResult.Line"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line_number", kind: "scalar", T: 5 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Mk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Mk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Mk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Mk, t, e)
    }
  },
  USt = class Hk extends d {
    constructor(t) {
      super(), (this.results = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GotodefResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "results", kind: "message", T: OSt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Hk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Hk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Hk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Hk, t, e)
    }
  },
  MSt = class Wk extends d {
    constructor(t) {
      super(), (this.errorMessage = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ErrorToolResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "error_message", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Wk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Wk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Wk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Wk, t, e)
    }
  },
  HSt = class jk extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.text = ""),
        (this.editId = ""),
        (this.firstEdit = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.NewEditParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "text", kind: "scalar", T: 9 },
        { no: 5, name: "edit_id", kind: "scalar", T: 9 },
        { no: 6, name: "first_edit", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new jk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jk, t, e)
    }
  },
  WSt = class Vk extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.NewEditResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Vk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Vk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Vk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Vk, t, e)
    }
  },
  jSt = class Gk extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.replaceNumLines = 0),
        (this.newLines = []),
        (this.editId = ""),
        (this.frontendEditType = Nm.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "replace_num_lines", kind: "scalar", T: 5 },
        { no: 4, name: "new_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 7, name: "replace_whole_file", kind: "scalar", T: 8, opt: !0 },
        { no: 5, name: "edit_id", kind: "scalar", T: 9 },
        {
          no: 6,
          name: "frontend_edit_type",
          kind: "enum",
          T: n.getEnumType(Nm),
        },
        {
          no: 8,
          name: "auto_fix_all_linter_errors_in_file",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Gk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Gk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Gk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Gk, t, e)
    }
  },
  Nm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.INLINE_DIFFS = 1)] = "INLINE_DIFFS"),
    (i[(i.SIMPLE = 2)] = "SIMPLE")
})(Nm || (Nm = {})),
  n.util.setEnumType(Nm, "aiserver.v1.EditParams.FrontendEditType", [
    { no: 0, name: "FRONTEND_EDIT_TYPE_UNSPECIFIED" },
    { no: 1, name: "FRONTEND_EDIT_TYPE_INLINE_DIFFS" },
    { no: 2, name: "FRONTEND_EDIT_TYPE_SIMPLE" },
  ])
var VSt = class zk extends d {
    constructor(t) {
      super(),
        (this.feedback = []),
        (this.contextStartLineNumber = 0),
        (this.contextLines = []),
        (this.file = ""),
        (this.fileTotalLines = 0),
        (this.structuredFeedback = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "feedback", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "context_start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "context_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "file", kind: "scalar", T: 9 },
        { no: 5, name: "file_total_lines", kind: "scalar", T: 5 },
        {
          no: 6,
          name: "structured_feedback",
          kind: "message",
          T: zSt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new zk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zk, t, e)
    }
  },
  GSt = class Yk extends d {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.startLineNumber = 0),
        (this.endLineNumber = 0),
        (this.relativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditResult.RelatedInformation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Yk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Yk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Yk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Yk, t, e)
    }
  },
  zSt = class Qk extends d {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.severity = ""),
        (this.startLineNumber = 0),
        (this.endLineNumber = 0),
        (this.relatedInformation = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EditResult.Feedback"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "severity", kind: "scalar", T: 9 },
        { no: 3, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "end_line_number", kind: "scalar", T: 5 },
        {
          no: 5,
          name: "related_information",
          kind: "message",
          T: GSt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Qk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Qk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Qk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Qk, t, e)
    }
  },
  YSt = class Xk extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.testName = ""),
        (this.testCode = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddTestParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "test_name", kind: "scalar", T: 9 },
        { no: 3, name: "test_code", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Xk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Xk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Xk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Xk, t, e)
    }
  },
  QSt = class Kk extends d {
    constructor(t) {
      super(), (this.feedback = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddTestResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "feedback", kind: "message", T: KSt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Kk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Kk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Kk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Kk, t, e)
    }
  },
  XSt = class Zk extends d {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.startLineNumber = 0),
        (this.endLineNumber = 0),
        (this.relativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddTestResult.RelatedInformation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Zk().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Zk().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Zk().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Zk, t, e)
    }
  },
  KSt = class tS extends d {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.severity = ""),
        (this.startLineNumber = 0),
        (this.endLineNumber = 0),
        (this.relatedInformation = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddTestResult.Feedback"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "severity", kind: "scalar", T: 9 },
        { no: 3, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "end_line_number", kind: "scalar", T: 5 },
        {
          no: 5,
          name: "related_information",
          kind: "message",
          T: XSt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new tS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tS, t, e)
    }
  },
  ZSt = class eS extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTestParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "test_name", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new eS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eS, t, e)
    }
  },
  tbt = class iS extends d {
    constructor(t) {
      super(), (this.result = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTestResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "result", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new iS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iS, t, e)
    }
  },
  ebt = class rS extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTestsParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new rS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rS, t, e)
    }
  },
  ibt = class nS extends d {
    constructor(t) {
      super(), (this.tests = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTestsResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tests", kind: "message", T: rbt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new nS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nS, t, e)
    }
  },
  rbt = class sS extends d {
    constructor(t) {
      super(), (this.name = ""), (this.lines = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTestsResult.Test"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new sS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sS, t, e)
    }
  },
  nbt = class aS extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteTestParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "test_name", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new aS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aS, t, e)
    }
  },
  sbt = class oS extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteTestResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new oS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oS, t, e)
    }
  },
  abt = class cS extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SaveFileParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new cS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cS, t, e)
    }
  },
  obt = class uS extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SaveFileResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new uS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uS, t, e)
    }
  },
  cbt = class lS extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.includeChildren = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSymbolsParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "line_range", kind: "message", T: ubt, opt: !0 },
        { no: 3, name: "include_children", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new lS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lS, t, e)
    }
  },
  ubt = class dS extends d {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.endLineNumberInclusive = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSymbolsParams.LineRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_number_inclusive", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new dS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dS, t, e)
    }
  },
  lbt = class mS extends d {
    constructor(t) {
      super(), (this.symbols = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSymbolsResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "symbols", kind: "message", T: Bq, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new mS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mS, t, e)
    }
  },
  dbt = class hS extends d {
    constructor(t) {
      super(),
        (this.editPlan = ""),
        (this.fileRegions = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ParallelApplyParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "edit_plan", kind: "scalar", T: 9 },
        { no: 2, name: "file_regions", kind: "message", T: mbt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new hS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hS, t, e)
    }
  },
  mbt = class fS extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ParallelApplyParams.FileRegion"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: mi },
      ])
    }
    static fromBinary(t, e) {
      return new fS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fS, t, e)
    }
  },
  hbt = class pS extends d {
    constructor(t) {
      super(), (this.fileResults = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ParallelApplyResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_results", kind: "message", T: fbt, repeated: !0 },
        { no: 2, name: "error", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new pS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pS, t, e)
    }
  },
  fbt = class gS extends d {
    constructor(t) {
      super(),
        (this.filePath = ""),
        (this.isApplied = !1),
        (this.applyFailed = !1),
        (this.linterErrors = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ParallelApplyResult.FileResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_path", kind: "scalar", T: 9 },
        { no: 2, name: "diff", kind: "message", T: RU },
        { no: 3, name: "is_applied", kind: "scalar", T: 8 },
        { no: 4, name: "apply_failed", kind: "scalar", T: 8 },
        { no: 5, name: "error", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "linter_errors", kind: "message", T: Js, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new gS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gS, t, e)
    }
  },
  pbt = class vS extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ParallelApplyStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new vS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vS, t, e)
    }
  },
  gbt = class wS extends d {
    constructor(t) {
      super(),
        (this.command = ""),
        (this.isBackground = !1),
        (this.requireUserApproval = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandV2Params"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
        { no: 2, name: "cwd", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "new_session", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "options", kind: "message", T: vbt, opt: !0 },
        { no: 5, name: "is_background", kind: "scalar", T: 8 },
        { no: 6, name: "require_user_approval", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new wS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wS, t, e)
    }
  },
  vbt = class yS extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandV2Params.ExecutionOptions"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "timeout", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "skip_ai_check", kind: "scalar", T: 8, opt: !0 },
        {
          no: 3,
          name: "command_run_timeout_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 4,
          name: "command_change_check_interval_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 5,
          name: "ai_finish_check_max_attempts",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 6,
          name: "ai_finish_check_interval_ms",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 7, name: "delayer_interval_ms", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new yS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yS, t, e)
    }
  },
  wbt = class TS extends d {
    constructor(t) {
      super(),
        (this.output = ""),
        (this.exitCode = 0),
        (this.poppedOutIntoBackground = !1),
        (this.isRunningInBackground = !1),
        (this.notInterrupted = !1),
        (this.resultingWorkingDirectory = ""),
        (this.didUserChange = !1),
        (this.endedReason = Rc.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandV2Result"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "output", kind: "scalar", T: 9 },
        { no: 2, name: "exit_code", kind: "scalar", T: 5 },
        { no: 3, name: "rejected", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "popped_out_into_background", kind: "scalar", T: 8 },
        { no: 5, name: "is_running_in_background", kind: "scalar", T: 8 },
        { no: 6, name: "not_interrupted", kind: "scalar", T: 8 },
        { no: 7, name: "resulting_working_directory", kind: "scalar", T: 9 },
        { no: 8, name: "did_user_change", kind: "scalar", T: 8 },
        { no: 9, name: "ended_reason", kind: "enum", T: n.getEnumType(Rc) },
        { no: 10, name: "exit_code_v2", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new TS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TS, t, e)
    }
  },
  ybt = class kS extends d {
    constructor(t) {
      super(),
        (this.command = ""),
        (this.isBackground = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTerminalCommandV2Stream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
        { no: 2, name: "is_background", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new kS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kS, t, e)
    }
  },
  Tbt = class SS extends d {
    constructor(t) {
      super(), (this.ruleNames = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FetchRulesStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "rule_names", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new SS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SS, t, e)
    }
  },
  kbt = class bS extends d {
    constructor(t) {
      super(), (this.instruction = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PlannerStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "instruction", kind: "scalar", T: 9 },
        { no: 2, name: "plan", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new bS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bS, t, e)
    }
  },
  Sbt = class ES extends d {
    constructor(t) {
      super(), (this.searchTerm = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WebSearchParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "search_term", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ES().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ES().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ES().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ES, t, e)
    }
  },
  bbt = class IS extends d {
    constructor(t) {
      super(), (this.references = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WebSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "references", kind: "message", T: Ebt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new IS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IS, t, e)
    }
  },
  Ebt = class PS extends d {
    constructor(t) {
      super(),
        (this.title = ""),
        (this.url = ""),
        (this.chunk = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WebSearchResult.WebReference"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "url", kind: "scalar", T: 9 },
        { no: 3, name: "chunk", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new PS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PS, t, e)
    }
  },
  Ibt = class NS extends d {
    constructor(t) {
      super(), (this.searchTerm = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WebSearchStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "search_term", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new NS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NS, t, e)
    }
  },
  Pbt = class $S extends d {
    constructor(t) {
      super(), (this.url = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WebViewerParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "url", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $S().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $S().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $S().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($S, t, e)
    }
  },
  Nbt = class xS extends d {
    constructor(t) {
      super(), (this.url = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WebViewerResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "url", kind: "scalar", T: 9 },
        { no: 2, name: "screenshot", kind: "message", T: Ls },
      ])
    }
    static fromBinary(t, e) {
      return new xS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xS, t, e)
    }
  },
  $bt = class JS extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WebViewerStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new JS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JS, t, e)
    }
  },
  xbt = class CS extends d {
    constructor(t) {
      super(), (this.tools = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MCPParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tools", kind: "message", T: FU, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new CS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CS, t, e)
    }
  },
  FU = class LS extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.description = ""),
        (this.parameters = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MCPParams.Tool"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "description", kind: "scalar", T: 9 },
        { no: 3, name: "parameters", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new LS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LS, t, e)
    }
  },
  Jbt = class RS extends d {
    constructor(t) {
      super(),
        (this.selectedTool = ""),
        (this.result = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MCPResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "selected_tool", kind: "scalar", T: 9 },
        { no: 2, name: "result", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new RS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RS, t, e)
    }
  },
  Cbt = class DS extends d {
    constructor(t) {
      super(), (this.tools = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MCPStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tools", kind: "message", T: FU, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new DS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DS, t, e)
    }
  },
  Lbt = class FS extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DiffHistoryParams"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new FS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FS, t, e)
    }
  },
  Rbt = class _S extends d {
    constructor(t) {
      super(), (this.humanChanges = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DiffHistoryResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 40,
          name: "human_changes",
          kind: "message",
          T: Fbt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new _S().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _S().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _S().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_S, t, e)
    }
  },
  Dbt = class AS extends d {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.endLineNumberExclusive = 0),
        (this.beforeContextLines = []),
        (this.removedLines = []),
        (this.addedLines = []),
        (this.afterContextLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DiffHistoryResult.RenderedDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_number_exclusive", kind: "scalar", T: 5 },
        {
          no: 3,
          name: "before_context_lines",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 4, name: "removed_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "added_lines", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 6,
          name: "after_context_lines",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new AS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AS, t, e)
    }
  },
  Fbt = class BS extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.renderedDiffs = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DiffHistoryResult.HumanChange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "rendered_diffs",
          kind: "message",
          T: Dbt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new BS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BS, t, e)
    }
  },
  _bt = class OS extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DiffHistoryStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new OS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OS, t, e)
    }
  },
  Or
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.READ_WRITE_FILE = 1)] = "READ_WRITE_FILE"),
    (i[(i.RUN_TERM = 2)] = "RUN_TERM"),
    (i[(i.CREATE_RM_FILES = 3)] = "CREATE_RM_FILES")
})(Or || (Or = {})),
  n.util.setEnumType(Or, "aiserver.v1.AiProjectStepType", [
    { no: 0, name: "AI_PROJECT_STEP_TYPE_UNSPECIFIED" },
    { no: 1, name: "AI_PROJECT_STEP_TYPE_READ_WRITE_FILE" },
    { no: 2, name: "AI_PROJECT_STEP_TYPE_RUN_TERM" },
    { no: 3, name: "AI_PROJECT_STEP_TYPE_CREATE_RM_FILES" },
  ])
var Abt = class qS extends d {
    constructor(t) {
      super(), (this.prompt = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectAgentInitRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: vt },
        { no: 2, name: "prompt", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new qS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qS, t, e)
    }
  },
  $m = class US extends d {
    constructor(t) {
      super(),
        (this.fullUserMessage = ""),
        (this.fullBotMessage = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MessagePayload"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "full_user_message", kind: "scalar", T: 9 },
        { no: 2, name: "full_bot_message", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new US().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new US().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new US().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(US, t, e)
    }
  },
  Bbt = class MS extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectClarification"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "output", kind: "scalar", T: 9, oneof: "response" },
        { no: 2, name: "thought", kind: "scalar", T: 9, oneof: "response" },
        {
          no: 3,
          name: "message_payload",
          kind: "message",
          T: $m,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new MS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MS, t, e)
    }
  },
  Obt = class HS extends d {
    constructor(t) {
      super(),
        (this.clarificationResponse = ""),
        (this.previousMessages = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectClarificationRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: vt },
        { no: 2, name: "clarification_response", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "previous_messages",
          kind: "message",
          T: vd,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new HS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HS, t, e)
    }
  },
  ptt = class WS extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectClarificationResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "clarification",
          kind: "message",
          T: Bbt,
          oneof: "response",
        },
        {
          no: 2,
          name: "repeat_clarification",
          kind: "scalar",
          T: 8,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new WS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WS, t, e)
    }
  },
  qbt = class jS extends d {
    constructor(t) {
      super(), (this.previousMessages = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectAgentPlanRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: vt },
        {
          no: 3,
          name: "previous_messages",
          kind: "message",
          T: vd,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new jS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jS, t, e)
    }
  },
  gtt = class VS extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectAgentPlanResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "thought", kind: "scalar", T: 9, oneof: "response" },
        { no: 2, name: "output", kind: "scalar", T: 9, oneof: "response" },
        {
          no: 3,
          name: "message_payload",
          kind: "message",
          T: $m,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new VS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VS, t, e)
    }
  },
  Ubt = class GS extends d {
    constructor(t) {
      super(),
        (this.previousMessages = []),
        (this.feedbackOrProgress = ""),
        (this.forceMoveToNextStep = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectPlanFeedbackRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: vt },
        {
          no: 2,
          name: "previous_messages",
          kind: "message",
          T: vd,
          repeated: !0,
        },
        { no: 3, name: "feedback_or_progress", kind: "scalar", T: 9 },
        { no: 4, name: "force_move_to_next_step", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new GS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GS, t, e)
    }
  },
  Mbt = class zS extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectPlanFeedbackResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "revised_plan",
          kind: "message",
          T: gtt,
          oneof: "response",
        },
        {
          no: 2,
          name: "repeat_feedback",
          kind: "scalar",
          T: 8,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new zS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zS, t, e)
    }
  },
  Hbt = class YS extends d {
    constructor(t) {
      super(),
        (this.description = ""),
        (this.spec = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectBreakdownRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: vt },
        { no: 2, name: "description", kind: "scalar", T: 9 },
        { no: 3, name: "spec", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new YS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YS, t, e)
    }
  },
  vtt = class QS extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectBreakdownResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "thought", kind: "scalar", T: 9, oneof: "response" },
        { no: 2, name: "step", kind: "message", T: Wbt, oneof: "response" },
        {
          no: 3,
          name: "message_payload",
          kind: "message",
          T: $m,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new QS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QS, t, e)
    }
  },
  Wbt = class XS extends d {
    constructor(t) {
      super(),
        (this.stepNumber = 0),
        (this.stepDescription = ""),
        (this.stepType = Or.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectBreakdownResponse.Step"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "step_number", kind: "scalar", T: 5 },
        { no: 2, name: "step_description", kind: "scalar", T: 9 },
        { no: 3, name: "step_type", kind: "enum", T: n.getEnumType(Or) },
      ])
    }
    static fromBinary(t, e) {
      return new XS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XS, t, e)
    }
  },
  jbt = class KS extends d {
    constructor(t) {
      super(),
        (this.previousMessages = []),
        (this.feedbackOrProgress = ""),
        (this.forceMoveToNextStep = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectBreakdownFeedbackRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: vt },
        {
          no: 2,
          name: "previous_messages",
          kind: "message",
          T: vd,
          repeated: !0,
        },
        { no: 3, name: "feedback_or_progress", kind: "scalar", T: 9 },
        { no: 4, name: "force_move_to_next_step", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new KS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KS, t, e)
    }
  },
  Vbt = class ZS extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectBreakdownFeedbackResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "revised_breakdown",
          kind: "message",
          T: vtt,
          oneof: "response",
        },
        {
          no: 2,
          name: "repeat_feedback",
          kind: "scalar",
          T: 8,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new ZS().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZS().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZS().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZS, t, e)
    }
  },
  Gbt = class tb extends d {
    constructor(t) {
      super(),
        (this.stepDescription = ""),
        (this.projectPlan = ""),
        (this.projectBreakdown = []),
        (this.stepType = Or.UNSPECIFIED),
        (this.shellType = qa.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: vt },
        { no: 2, name: "step_description", kind: "scalar", T: 9 },
        { no: 3, name: "project_plan", kind: "scalar", T: 9 },
        {
          no: 4,
          name: "project_breakdown",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 5, name: "step_type", kind: "enum", T: n.getEnumType(Or) },
        { no: 6, name: "shell_type", kind: "enum", T: n.getEnumType(qa) },
      ])
    }
    static fromBinary(t, e) {
      return new tb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tb, t, e)
    }
  },
  wtt = class eb extends d {
    constructor(t) {
      super(),
        (this.response = { case: void 0 }),
        (this.stepType = Or.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "thought", kind: "scalar", T: 9, oneof: "response" },
        { no: 2, name: "output", kind: "scalar", T: 9, oneof: "response" },
        {
          no: 3,
          name: "message_payload",
          kind: "message",
          T: $m,
          oneof: "response",
        },
        {
          no: 5,
          name: "step_payload",
          kind: "message",
          T: Kbt,
          oneof: "response",
        },
        { no: 4, name: "step_type", kind: "enum", T: n.getEnumType(Or) },
      ])
    }
    static fromBinary(t, e) {
      return new eb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eb, t, e)
    }
  },
  zbt = class ib extends d {
    constructor(t) {
      super(), (this.filename = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepResponse.WriteCode"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "filename", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ib().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ib().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ib().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ib, t, e)
    }
  },
  Ybt = class rb extends d {
    constructor(t) {
      super(), (this.thought = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepResponse.ReviseCode"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "thought", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new rb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rb, t, e)
    }
  },
  Qbt = class nb extends d {
    constructor(t) {
      super(),
        (this.commandBatchUuid = ""),
        (this.command = ""),
        (this.response = ""),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepResponse.RunTerm"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command_batch_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "command", kind: "scalar", T: 9 },
        { no: 3, name: "response", kind: "scalar", T: 9 },
        { no: 4, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new nb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nb, t, e)
    }
  },
  Xbt = class sb extends d {
    constructor(t) {
      super(), (this.payload = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepResponse.CreatingFiles"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "filename", kind: "scalar", T: 9, oneof: "payload" },
        { no: 2, name: "directory", kind: "scalar", T: 9, oneof: "payload" },
      ])
    }
    static fromBinary(t, e) {
      return new sb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sb, t, e)
    }
  },
  z2t = class ab extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepResponse.Nothing"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new ab().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ab().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ab().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ab, t, e)
    }
  },
  Kbt = class ob extends d {
    constructor(t) {
      super(), (this.payload = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepResponse.StepPayload"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 5,
          name: "write_code",
          kind: "message",
          T: zbt,
          oneof: "payload",
        },
        { no: 6, name: "run_term", kind: "message", T: Qbt, oneof: "payload" },
        {
          no: 7,
          name: "creating_files",
          kind: "message",
          T: Xbt,
          oneof: "payload",
        },
        {
          no: 8,
          name: "revise_code",
          kind: "message",
          T: Ybt,
          oneof: "payload",
        },
      ])
    }
    static fromBinary(t, e) {
      return new ob().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ob().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ob().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ob, t, e)
    }
  },
  Zbt = class cb extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepResponseWrapped"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "real_response",
          kind: "message",
          T: wtt,
          oneof: "response",
        },
        {
          no: 2,
          name: "background_task_uuid",
          kind: "scalar",
          T: 9,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new cb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cb, t, e)
    }
  },
  tEt = class ub extends d {
    constructor(t) {
      super(),
        (this.stepDescription = ""),
        (this.projectPlan = ""),
        (this.projectBreakdown = []),
        (this.stepType = Or.UNSPECIFIED),
        (this.shellType = qa.UNSPECIFIED),
        (this.previousFeedbackMessages = []),
        (this.forceMoveToNextStep = !1),
        (this.feedbackPayload = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepFeedbackRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: vt },
        { no: 2, name: "step_description", kind: "scalar", T: 9 },
        { no: 3, name: "project_plan", kind: "scalar", T: 9 },
        {
          no: 4,
          name: "project_breakdown",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 5, name: "step_type", kind: "enum", T: n.getEnumType(Or) },
        { no: 6, name: "shell_type", kind: "enum", T: n.getEnumType(qa) },
        {
          no: 7,
          name: "previous_feedback_messages",
          kind: "message",
          T: vd,
          repeated: !0,
        },
        { no: 8, name: "force_move_to_next_step", kind: "scalar", T: 8 },
        {
          no: 9,
          name: "modify_code_payload",
          kind: "message",
          T: eEt,
          oneof: "feedback_payload",
        },
      ])
    }
    static fromBinary(t, e) {
      return new ub().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ub().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ub().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ub, t, e)
    }
  },
  eEt = class lb extends d {
    constructor(t) {
      super(),
        (this.filesToModify = []),
        (this.feedbackText = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.AiProjectStepFeedbackRequest.ModifyCodePayload"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files_to_modify", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "feedback_text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new lb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lb, t, e)
    }
  },
  iEt = class db extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepFeedbackResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "response_from_feedback",
          kind: "message",
          T: wtt,
          oneof: "response",
        },
        {
          no: 2,
          name: "repeat_feedback",
          kind: "scalar",
          T: 8,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new db().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new db().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new db().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(db, t, e)
    }
  },
  rEt = class mb extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectStepFeedbackResponseWrapped"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "real_response",
          kind: "message",
          T: iEt,
          oneof: "response",
        },
        {
          no: 2,
          name: "background_task_uuid",
          kind: "scalar",
          T: 9,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new mb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mb, t, e)
    }
  },
  Y2t = class hb extends d {
    constructor(t) {
      super(), (this.code = ""), (this.path = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectAgentWriteCode"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "code", kind: "scalar", T: 9 },
        { no: 3, name: "path", kind: "scalar", T: 9 },
        { no: 4, name: "message_payload", kind: "message", T: $m },
      ])
    }
    static fromBinary(t, e) {
      return new hb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hb, t, e)
    }
  },
  ytt = {
    typeName: "aiserver.v1.AiProjectService",
    methods: {
      aiProjectAgentInit: {
        name: "AiProjectAgentInit",
        I: Abt,
        O: ptt,
        kind: E.ServerStreaming,
      },
      aiProjectClarification: {
        name: "AiProjectClarification",
        I: Obt,
        O: ptt,
        kind: E.ServerStreaming,
      },
      aiProjectPlan: {
        name: "AiProjectPlan",
        I: qbt,
        O: gtt,
        kind: E.ServerStreaming,
      },
      aiProjectPlanFeedback: {
        name: "AiProjectPlanFeedback",
        I: Ubt,
        O: Mbt,
        kind: E.ServerStreaming,
      },
      aiProjectBreakdown: {
        name: "AiProjectBreakdown",
        I: Hbt,
        O: vtt,
        kind: E.ServerStreaming,
      },
      aiProjectBreakdownFeedback: {
        name: "AiProjectBreakdownFeedback",
        I: jbt,
        O: Vbt,
        kind: E.ServerStreaming,
      },
      aiProjectStep: {
        name: "AiProjectStep",
        I: Gbt,
        O: Zbt,
        kind: E.ServerStreaming,
      },
      aiProjectStepFeedback: {
        name: "AiProjectStepFeedback",
        I: tEt,
        O: rEt,
        kind: E.ServerStreaming,
      },
    },
  },
  nEt = class fb extends d {
    constructor(t) {
      super(), (this.mode = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportModeSelectionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "mode", kind: "scalar", T: 9 },
        { no: 2, name: "debug_info", kind: "message", T: hr },
      ])
    }
    static fromBinary(t, e) {
      return new fb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fb, t, e)
    }
  },
  sEt = class pb extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportModeSelectionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new pb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pb, t, e)
    }
  },
  aEt = class gb extends d {
    constructor(t) {
      super(),
        (this.patchUuid = ""),
        (this.patchString = ""),
        (this.source = ""),
        (this.reflection = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RecordAcceptedPatchRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "patch_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "patch_string", kind: "scalar", T: 9 },
        { no: 3, name: "source", kind: "scalar", T: 9 },
        { no: 4, name: "reflection", kind: "scalar", T: 9 },
        { no: 5, name: "debug_info", kind: "message", T: hr },
      ])
    }
    static fromBinary(t, e) {
      return new gb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gb, t, e)
    }
  },
  oEt = class vb extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RecordAcceptedPatchResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new vb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vb, t, e)
    }
  },
  cEt = class wb extends d {
    constructor(t) {
      super(), (this.ans = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainGetFilePathsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ans", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new wb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wb, t, e)
    }
  },
  uEt = class yb extends d {
    constructor(t) {
      super(), (this.paths = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainGetFilePathsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "paths", kind: "message", T: lEt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new yb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yb, t, e)
    }
  },
  lEt = class Tb extends d {
    constructor(t) {
      super(),
        (this.rawPath = ""),
        (this.interestingLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainGetFilePathsResponse.Path"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "raw_path", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "interesting_lines",
          kind: "scalar",
          T: 5,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Tb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Tb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Tb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Tb, t, e)
    }
  },
  dEt = class kb extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.oldFileContents = ""),
        (this.newFileContents = ""),
        (this.patchString = ""),
        (this.branchNotes = ""),
        (this.branchName = ""),
        (this.highLevelAiAnswer = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainReflectRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "old_file_contents", kind: "scalar", T: 9 },
        { no: 3, name: "new_file_contents", kind: "scalar", T: 9 },
        { no: 9, name: "patch_string", kind: "scalar", T: 9 },
        { no: 4, name: "branch_notes", kind: "scalar", T: 9 },
        { no: 5, name: "branch_name", kind: "scalar", T: 9 },
        { no: 6, name: "high_level_ai_answer", kind: "scalar", T: 9 },
        { no: 7, name: "override_model", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "override_token_limit", kind: "scalar", T: 5, opt: !0 },
        { no: 10, name: "lints", kind: "message", T: _7 },
      ])
    }
    static fromBinary(t, e) {
      return new kb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kb, t, e)
    }
  },
  mEt = class Sb extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainReflectResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "decision", kind: "message", T: gEt },
      ])
    }
    static fromBinary(t, e) {
      return new Sb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Sb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Sb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Sb, t, e)
    }
  },
  hEt = class bb extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainReflectResponse.AcceptDecision"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new bb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bb, t, e)
    }
  },
  fEt = class Eb extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.OpusChainReflectResponse.RetryWithoutMoreInformationDecision"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Eb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Eb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Eb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Eb, t, e)
    }
  },
  pEt = class Ib extends d {
    constructor(t) {
      super(), (this.codebaseQuestions = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.OpusChainReflectResponse.RetryWithCodebaseQuestionDecision"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "codebase_questions",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Ib().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ib().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ib().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ib, t, e)
    }
  },
  gEt = class Pb extends d {
    constructor(t) {
      super(), (this.decision = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainReflectResponse.Decision"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "accept", kind: "message", T: hEt, oneof: "decision" },
        {
          no: 2,
          name: "retry_without_more_information",
          kind: "message",
          T: fEt,
          oneof: "decision",
        },
        {
          no: 3,
          name: "retry_with_codebase_question",
          kind: "message",
          T: pEt,
          oneof: "decision",
        },
      ])
    }
    static fromBinary(t, e) {
      return new Pb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Pb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Pb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Pb, t, e)
    }
  },
  vEt = class Nb extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.highLevelAiAnswer = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainGetFileInstructionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "high_level_ai_answer", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Nb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Nb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Nb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Nb, t, e)
    }
  },
  wEt = class $b extends d {
    constructor(t) {
      super(), (this.fileInstruction = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainGetFileInstructionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_instruction", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $b().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $b().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $b().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($b, t, e)
    }
  },
  yEt = class xb extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.fileContents = ""),
        (this.branchNotes = ""),
        (this.branchName = ""),
        (this.highLevelAiAnswer = ""),
        (this.originatingReflection = ""),
        (this.scoredCodebaseContext = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainGetPlanRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_contents", kind: "scalar", T: 9 },
        { no: 3, name: "branch_notes", kind: "scalar", T: 9 },
        { no: 4, name: "branch_name", kind: "scalar", T: 9 },
        { no: 5, name: "high_level_ai_answer", kind: "scalar", T: 9 },
        { no: 9, name: "originating_reflection", kind: "scalar", T: 9 },
        { no: 6, name: "override_model", kind: "scalar", T: 9, opt: !0 },
        { no: 7, name: "override_token_limit", kind: "scalar", T: 5, opt: !0 },
        {
          no: 15,
          name: "scored_codebase_context",
          kind: "message",
          T: fi,
          repeated: !0,
        },
        {
          no: 8,
          name: "codebase_information",
          kind: "message",
          T: TEt,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new xb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xb, t, e)
    }
  },
  TEt = class Jb extends d {
    constructor(t) {
      super(), (this.files = []), (this.qa = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainGetPlanRequest.CodebaseInformation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: kEt, repeated: !0 },
        { no: 2, name: "qa", kind: "message", T: SEt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Jb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Jb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Jb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Jb, t, e)
    }
  },
  kEt = class Cb extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.interestingLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.OpusChainGetPlanRequest.CodebaseInformation.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "interesting_lines",
          kind: "scalar",
          T: 5,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Cb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Cb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Cb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Cb, t, e)
    }
  },
  SEt = class Lb extends d {
    constructor(t) {
      super(),
        (this.question = ""),
        (this.answer = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.OpusChainGetPlanRequest.CodebaseInformation.QA"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "question", kind: "scalar", T: 9 },
        { no: 2, name: "answer", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Lb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Lb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Lb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Lb, t, e)
    }
  },
  bEt = class Rb extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.OpusChainGetPlanResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Rb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Rb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Rb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Rb, t, e)
    }
  },
  Ttt = {
    typeName: "aiserver.v1.AiBranchService",
    methods: {
      opusChainGetPlan: {
        name: "OpusChainGetPlan",
        I: yEt,
        O: bEt,
        kind: E.ServerStreaming,
      },
      opusChainGetFileInstruction: {
        name: "OpusChainGetFileInstruction",
        I: vEt,
        O: wEt,
        kind: E.Unary,
      },
      opusChainReflect: {
        name: "OpusChainReflect",
        I: dEt,
        O: mEt,
        kind: E.ServerStreaming,
      },
      opusChainGetFilePaths: {
        name: "OpusChainGetFilePaths",
        I: cEt,
        O: uEt,
        kind: E.Unary,
      },
      recordAcceptedPatch: {
        name: "RecordAcceptedPatch",
        I: aEt,
        O: oEt,
        kind: E.Unary,
      },
      reportModeSelection: {
        name: "ReportModeSelection",
        I: nEt,
        O: sEt,
        kind: E.Unary,
      },
    },
  },
  ktt = class Db extends d {
    constructor(t) {
      super(),
        (this.prefixUrl = ""),
        (this.docName = ""),
        (this.isDifferentPrefixOrigin = !1),
        (this.truePrefixUrl = ""),
        (this.public = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentationMetadata"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "prefix_url", kind: "scalar", T: 9 },
        { no: 2, name: "doc_name", kind: "scalar", T: 9 },
        { no: 3, name: "is_different_prefix_origin", kind: "scalar", T: 8 },
        { no: 4, name: "true_prefix_url", kind: "scalar", T: 9 },
        { no: 5, name: "public", kind: "scalar", T: 8 },
        { no: 6, name: "team_id", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Db().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Db().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Db().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Db, t, e)
    }
  },
  Stt = class Fb extends d {
    constructor(t) {
      super(),
        (this.docName = ""),
        (this.pageUrl = ""),
        (this.documentationChunk = ""),
        (this.score = 0),
        (this.pageTitle = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentationChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_name", kind: "scalar", T: 9 },
        { no: 2, name: "page_url", kind: "scalar", T: 9 },
        { no: 3, name: "documentation_chunk", kind: "scalar", T: 9 },
        { no: 4, name: "score", kind: "scalar", T: 2 },
        { no: 5, name: "page_title", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Fb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Fb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Fb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Fb, t, e)
    }
  },
  EEt = class _b extends d {
    constructor(t) {
      super(),
        (this.docIdentifier = ""),
        (this.query = ""),
        (this.topK = 0),
        (this.rerankResults = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentationQueryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
        { no: 2, name: "query", kind: "scalar", T: 9 },
        { no: 3, name: "top_k", kind: "scalar", T: 13 },
        { no: 4, name: "rerank_results", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new _b().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _b().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _b().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_b, t, e)
    }
  },
  IEt = class Ab extends d {
    constructor(t) {
      super(),
        (this.docIdentifier = ""),
        (this.docName = ""),
        (this.docChunks = []),
        (this.status = xm.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentationQueryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
        { no: 2, name: "doc_name", kind: "scalar", T: 9 },
        { no: 3, name: "doc_chunks", kind: "message", T: Stt, repeated: !0 },
        { no: 4, name: "status", kind: "enum", T: n.getEnumType(xm) },
      ])
    }
    static fromBinary(t, e) {
      return new Ab().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ab().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ab().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ab, t, e)
    }
  },
  xm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.NOT_FOUND = 1)] = "NOT_FOUND"),
    (i[(i.SUCCESS = 2)] = "SUCCESS"),
    (i[(i.FAILURE = 3)] = "FAILURE")
})(xm || (xm = {})),
  n.util.setEnumType(xm, "aiserver.v1.DocumentationQueryResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_NOT_FOUND" },
    { no: 2, name: "STATUS_SUCCESS" },
    { no: 3, name: "STATUS_FAILURE" },
  ])
var PEt = class Bb extends d {
    constructor(t) {
      super(),
        (this.type = Jm.UNSPECIFIED),
        (this.data = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComposerCapabilityRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type", kind: "enum", T: n.getEnumType(Jm) },
        {
          no: 2,
          name: "loop_on_lints",
          kind: "message",
          T: xEt,
          oneof: "data",
        },
        {
          no: 3,
          name: "loop_on_tests",
          kind: "message",
          T: JEt,
          oneof: "data",
        },
        { no: 4, name: "mega_planner", kind: "message", T: CEt, oneof: "data" },
        {
          no: 5,
          name: "loop_on_command",
          kind: "message",
          T: LEt,
          oneof: "data",
        },
        { no: 6, name: "tool_call", kind: "message", T: REt, oneof: "data" },
        { no: 7, name: "diff_review", kind: "message", T: DEt, oneof: "data" },
        {
          no: 8,
          name: "context_picking",
          kind: "message",
          T: BEt,
          oneof: "data",
        },
        { no: 9, name: "edit_trail", kind: "message", T: OEt, oneof: "data" },
        {
          no: 10,
          name: "auto_context",
          kind: "message",
          T: qEt,
          oneof: "data",
        },
        {
          no: 11,
          name: "context_planner",
          kind: "message",
          T: UEt,
          oneof: "data",
        },
        {
          no: 12,
          name: "remember_this",
          kind: "message",
          T: MEt,
          oneof: "data",
        },
        { no: 13, name: "decomposer", kind: "message", T: AEt, oneof: "data" },
        {
          no: 14,
          name: "cursor_rules",
          kind: "message",
          T: HEt,
          oneof: "data",
        },
      ])
    }
    static fromBinary(t, e) {
      return new Bb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Bb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Bb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Bb, t, e)
    }
  },
  Jm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.LOOP_ON_LINTS = 1)] = "LOOP_ON_LINTS"),
    (i[(i.LOOP_ON_TESTS = 2)] = "LOOP_ON_TESTS"),
    (i[(i.MEGA_PLANNER = 3)] = "MEGA_PLANNER"),
    (i[(i.LOOP_ON_COMMAND = 4)] = "LOOP_ON_COMMAND"),
    (i[(i.TOOL_CALL = 5)] = "TOOL_CALL"),
    (i[(i.DIFF_REVIEW = 6)] = "DIFF_REVIEW"),
    (i[(i.CONTEXT_PICKING = 7)] = "CONTEXT_PICKING"),
    (i[(i.EDIT_TRAIL = 8)] = "EDIT_TRAIL"),
    (i[(i.AUTO_CONTEXT = 9)] = "AUTO_CONTEXT"),
    (i[(i.CONTEXT_PLANNER = 10)] = "CONTEXT_PLANNER"),
    (i[(i.DIFF_HISTORY = 11)] = "DIFF_HISTORY"),
    (i[(i.REMEMBER_THIS = 12)] = "REMEMBER_THIS"),
    (i[(i.DECOMPOSER = 13)] = "DECOMPOSER"),
    (i[(i.USES_CODEBASE = 14)] = "USES_CODEBASE"),
    (i[(i.TOOL_FORMER = 15)] = "TOOL_FORMER"),
    (i[(i.CURSOR_RULES = 16)] = "CURSOR_RULES")
})(Jm || (Jm = {})),
  n.util.setEnumType(
    Jm,
    "aiserver.v1.ComposerCapabilityRequest.ComposerCapabilityType",
    [
      { no: 0, name: "COMPOSER_CAPABILITY_TYPE_UNSPECIFIED" },
      { no: 1, name: "COMPOSER_CAPABILITY_TYPE_LOOP_ON_LINTS" },
      { no: 2, name: "COMPOSER_CAPABILITY_TYPE_LOOP_ON_TESTS" },
      { no: 3, name: "COMPOSER_CAPABILITY_TYPE_MEGA_PLANNER" },
      { no: 4, name: "COMPOSER_CAPABILITY_TYPE_LOOP_ON_COMMAND" },
      { no: 5, name: "COMPOSER_CAPABILITY_TYPE_TOOL_CALL" },
      { no: 6, name: "COMPOSER_CAPABILITY_TYPE_DIFF_REVIEW" },
      { no: 7, name: "COMPOSER_CAPABILITY_TYPE_CONTEXT_PICKING" },
      { no: 8, name: "COMPOSER_CAPABILITY_TYPE_EDIT_TRAIL" },
      { no: 9, name: "COMPOSER_CAPABILITY_TYPE_AUTO_CONTEXT" },
      { no: 10, name: "COMPOSER_CAPABILITY_TYPE_CONTEXT_PLANNER" },
      { no: 11, name: "COMPOSER_CAPABILITY_TYPE_DIFF_HISTORY" },
      { no: 12, name: "COMPOSER_CAPABILITY_TYPE_REMEMBER_THIS" },
      { no: 13, name: "COMPOSER_CAPABILITY_TYPE_DECOMPOSER" },
      { no: 14, name: "COMPOSER_CAPABILITY_TYPE_USES_CODEBASE" },
      { no: 15, name: "COMPOSER_CAPABILITY_TYPE_TOOL_FORMER" },
      { no: 16, name: "COMPOSER_CAPABILITY_TYPE_CURSOR_RULES" },
    ],
  )
var Cm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.ADD_FILE_TO_CONTEXT = 1)] = "ADD_FILE_TO_CONTEXT"),
    (i[(i.RUN_TERMINAL_COMMAND = 2)] = "RUN_TERMINAL_COMMAND"),
    (i[(i.ITERATE = 3)] = "ITERATE"),
    (i[(i.REMOVE_FILE_FROM_CONTEXT = 4)] = "REMOVE_FILE_FROM_CONTEXT"),
    (i[(i.SEMANTIC_SEARCH_CODEBASE = 5)] = "SEMANTIC_SEARCH_CODEBASE")
})(Cm || (Cm = {})),
  n.util.setEnumType(Cm, "aiserver.v1.ComposerCapabilityRequest.ToolType", [
    { no: 0, name: "TOOL_TYPE_UNSPECIFIED" },
    { no: 1, name: "TOOL_TYPE_ADD_FILE_TO_CONTEXT" },
    { no: 2, name: "TOOL_TYPE_RUN_TERMINAL_COMMAND" },
    { no: 3, name: "TOOL_TYPE_ITERATE" },
    { no: 4, name: "TOOL_TYPE_REMOVE_FILE_FROM_CONTEXT" },
    { no: 5, name: "TOOL_TYPE_SEMANTIC_SEARCH_CODEBASE" },
  ])
var NEt = class Ob extends d {
    constructor(t) {
      super(),
        (this.type = Cm.UNSPECIFIED),
        (this.name = ""),
        (this.properties = {}),
        (this.required = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComposerCapabilityRequest.ToolSchema"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type", kind: "enum", T: n.getEnumType(Cm) },
        { no: 2, name: "name", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "properties",
          kind: "map",
          K: 9,
          V: { kind: "message", T: $Et },
        },
        { no: 4, name: "required", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Ob().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ob().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ob().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ob, t, e)
    }
  },
  $Et = class qb extends d {
    constructor(t) {
      super(), (this.type = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComposerCapabilityRequest.SchemaProperty"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type", kind: "scalar", T: 9 },
        { no: 2, name: "description", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new qb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qb, t, e)
    }
  },
  xEt = class Ub extends d {
    constructor(t) {
      super(), (this.linterErrors = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.LoopOnLintsCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "linter_errors", kind: "message", T: hi, repeated: !0 },
        { no: 2, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Ub().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ub().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ub().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ub, t, e)
    }
  },
  JEt = class Mb extends d {
    constructor(t) {
      super(), (this.testNames = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.LoopOnTestsCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "test_names", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Mb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Mb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Mb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Mb, t, e)
    }
  },
  CEt = class Hb extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.MegaPlannerCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Hb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Hb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Hb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Hb, t, e)
    }
  },
  LEt = class Wb extends d {
    constructor(t) {
      super(), (this.command = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.LoopOnCommandCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
        { no: 2, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "output", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "exit_code", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Wb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Wb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Wb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Wb, t, e)
    }
  },
  REt = class jb extends d {
    constructor(t) {
      super(),
        (this.toolSchemas = []),
        (this.relevantFiles = []),
        (this.filesInContext = []),
        (this.semanticSearchFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComposerCapabilityRequest.ToolCallCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "tool_schemas", kind: "message", T: NEt, repeated: !0 },
        { no: 3, name: "relevant_files", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "files_in_context", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 5,
          name: "semantic_search_files",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new jb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jb, t, e)
    }
  },
  DEt = class Vb extends d {
    constructor(t) {
      super(), (this.diffs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.DiffReviewCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "diffs", kind: "message", T: FEt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Vb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Vb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Vb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Vb, t, e)
    }
  },
  FEt = class Gb extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.chunks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.DiffReviewCapability.SimpleFileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 3, name: "chunks", kind: "message", T: _Et, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Gb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Gb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Gb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Gb, t, e)
    }
  },
  _Et = class zb extends d {
    constructor(t) {
      super(),
        (this.oldLines = []),
        (this.newLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.DiffReviewCapability.SimpleFileDiff.Chunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "old_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "new_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "old_range", kind: "message", T: vi },
        { no: 4, name: "new_range", kind: "message", T: vi },
      ])
    }
    static fromBinary(t, e) {
      return new zb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zb, t, e)
    }
  },
  AEt = class Yb extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.DecomposerCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Yb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Yb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Yb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Yb, t, e)
    }
  },
  BEt = class Qb extends d {
    constructor(t) {
      super(),
        (this.potentialContextFiles = []),
        (this.potentialContextCodeChunks = []),
        (this.filesInContext = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.ContextPickingCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
        {
          no: 2,
          name: "potential_context_files",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 3,
          name: "potential_context_code_chunks",
          kind: "message",
          T: CQ,
          repeated: !0,
        },
        { no: 4, name: "files_in_context", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Qb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Qb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Qb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Qb, t, e)
    }
  },
  OEt = class Xb extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.EditTrailCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Xb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Xb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Xb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Xb, t, e)
    }
  },
  qEt = class Kb extends d {
    constructor(t) {
      super(), (this.additionalFiles = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.AutoContextCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "additional_files", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Kb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Kb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Kb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Kb, t, e)
    }
  },
  UEt = class Zb extends d {
    constructor(t) {
      super(), (this.attachedCodeChunks = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.ContextPlannerCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
        {
          no: 2,
          name: "attached_code_chunks",
          kind: "message",
          T: CQ,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Zb().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Zb().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Zb().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Zb, t, e)
    }
  },
  MEt = class tE extends d {
    constructor(t) {
      super(), (this.memory = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.RememberThisCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "memory", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new tE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tE, t, e)
    }
  },
  HEt = class eE extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ComposerCapabilityRequest.CursorRulesCapability"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new eE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eE, t, e)
    }
  },
  Un
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.CODEBASE = 1)] = "CODEBASE"),
    (i[(i.LONG_FILE = 2)] = "LONG_FILE"),
    (i[(i.DOCS = 3)] = "DOCS")
})(Un || (Un = {})),
  n.util.setEnumType(Un, "aiserver.v1.ChunkType", [
    { no: 0, name: "CHUNK_TYPE_UNSPECIFIED" },
    { no: 1, name: "CHUNK_TYPE_CODEBASE" },
    { no: 2, name: "CHUNK_TYPE_LONG_FILE" },
    { no: 3, name: "CHUNK_TYPE_DOCS" },
  ])
var WEt = class iE extends d {
    constructor(t) {
      super(), (this.editPlan = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamParallelApplyRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_block", kind: "message", T: ye },
        { no: 2, name: "file", kind: "message", T: nr },
        { no: 3, name: "edit_plan", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new iE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iE, t, e)
    }
  },
  jEt = class rE extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamParallelApplyResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new rE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rE, t, e)
    }
  },
  VEt = class nE extends d {
    constructor(t) {
      super(), (this.request = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamUnifiedChatRequestWithTools"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "stream_unified_chat_request",
          kind: "message",
          T: OU,
          oneof: "request",
        },
        {
          no: 2,
          name: "client_side_tool_v2_result",
          kind: "message",
          T: q7,
          oneof: "request",
        },
      ])
    }
    static fromBinary(t, e) {
      return new nE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nE, t, e)
    }
  },
  GEt = class sE extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamUnifiedChatResponseWithTools"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "client_side_tool_v2_call",
          kind: "message",
          T: itt,
          oneof: "response",
        },
        {
          no: 2,
          name: "stream_unified_chat_response",
          kind: "message",
          T: Ntt,
          oneof: "response",
        },
        {
          no: 3,
          name: "conversation_summary",
          kind: "message",
          T: Mn,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new sE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sE, t, e)
    }
  },
  Q2t = class aE extends d {
    constructor(t) {
      super(), (this.strategy = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationSummaryStrategy"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "plain_text_summary",
          kind: "scalar",
          T: 9,
          oneof: "strategy",
        },
        {
          no: 2,
          name: "arbitrary_summary_plus_tool_result_truncation",
          kind: "message",
          T: zEt,
          oneof: "strategy",
        },
      ])
    }
    static fromBinary(t, e) {
      return new aE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aE, t, e)
    }
  },
  zEt = class oE extends d {
    constructor(t) {
      super(),
        (this.toolResultTruncationLength = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ConversationSummaryStrategy.ArbitrarySummaryPlusToolResultTruncation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "arbitrary_summary", kind: "message", T: Mn },
        { no: 2, name: "tool_result_truncation_length", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new oE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oE, t, e)
    }
  },
  Mn = class cE extends d {
    constructor(t) {
      super(),
        (this.summary = ""),
        (this.truncationLastBubbleIdInclusive = ""),
        (this.clientShouldStartSendingFromInclusiveBubbleId = ""),
        (this.previousConversationSummaryBubbleId = ""),
        (this.includesToolResults = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationSummary"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "summary", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "truncation_last_bubble_id_inclusive",
          kind: "scalar",
          T: 9,
        },
        {
          no: 3,
          name: "client_should_start_sending_from_inclusive_bubble_id",
          kind: "scalar",
          T: 9,
        },
        {
          no: 4,
          name: "previous_conversation_summary_bubble_id",
          kind: "scalar",
          T: 9,
        },
        { no: 5, name: "includes_tool_results", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new cE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cE, t, e)
    }
  },
  btt = class uE extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextToRank"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        { no: 3, name: "line_range", kind: "message", T: vi, opt: !0 },
        { no: 4, name: "code_block", kind: "message", T: ye, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new uE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uE, t, e)
    }
  },
  _U = class lE extends d {
    constructor(t) {
      super(), (this.score = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RankedContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context", kind: "message", T: btt },
        { no: 2, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new lE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lE, t, e)
    }
  },
  AU = class dE extends d {
    constructor(t) {
      super(), (this.chunks = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentationCitation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunks", kind: "message", T: Stt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new dE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dE, t, e)
    }
  },
  Ett = class mE extends d {
    constructor(t) {
      super(), (this.references = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WebCitation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "references", kind: "message", T: Itt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new mE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mE, t, e)
    }
  },
  Itt = class hE extends d {
    constructor(t) {
      super(),
        (this.title = ""),
        (this.url = ""),
        (this.chunk = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WebReference"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "title", kind: "scalar", T: 9 },
        { no: 1, name: "url", kind: "scalar", T: 9 },
        { no: 3, name: "chunk", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new hE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hE, t, e)
    }
  },
  M7 = class fE extends d {
    constructor(t) {
      super(),
        (this.title = ""),
        (this.url = ""),
        (this.chunk = ""),
        (this.name = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocsReference"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "url", kind: "scalar", T: 9 },
        { no: 3, name: "chunk", kind: "scalar", T: 9 },
        { no: 4, name: "name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new fE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fE, t, e)
    }
  },
  YEt = class pE extends d {
    constructor(t) {
      super(), (this.message = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StatusUpdate"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "metadata", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new pE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pE, t, e)
    }
  },
  Ptt = class gE extends d {
    constructor(t) {
      super(), (this.updates = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StatusUpdates"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "updates", kind: "message", T: YEt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new gE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gE, t, e)
    }
  },
  QEt = class vE extends d {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.documents = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RerankDocumentsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "documents", kind: "message", T: KEt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new vE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vE, t, e)
    }
  },
  XEt = class wE extends d {
    constructor(t) {
      super(), (this.documents = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RerankDocumentsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "documents", kind: "message", T: ZEt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new wE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wE, t, e)
    }
  },
  KEt = class yE extends d {
    constructor(t) {
      super(), (this.content = ""), (this.id = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Document"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "content", kind: "scalar", T: 9 },
        { no: 2, name: "id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new yE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yE, t, e)
    }
  },
  ZEt = class TE extends d {
    constructor(t) {
      super(),
        (this.documentId = ""),
        (this.score = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentIdsWithScores"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "document_id", kind: "scalar", T: 9 },
        { no: 2, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new TE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TE, t, e)
    }
  },
  BU = class kE extends d {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.diffHistory = []),
        (this.diffHistoryTimestamps = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComposerFileDiffHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "diff_history", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 3,
          name: "diff_history_timestamps",
          kind: "scalar",
          T: 1,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new kE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kE, t, e)
    }
  },
  tIt = class SE extends d {
    constructor(t) {
      super(), (this.workspaceUris = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EnvironmentInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "exthost_platform", kind: "scalar", T: 9, opt: !0 },
        { no: 2, name: "exthost_arch", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "exthost_release", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "exthost_shell", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "local_timestamp", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "workspace_uris", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new SE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SE, t, e)
    }
  },
  OU = class bE extends d {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.fullConversationHeadersOnly = []),
        (this.documentationIdentifiers = []),
        (this.externalLinks = []),
        (this.diffsForCompressingFiles = []),
        (this.multiFileLinterErrors = []),
        (this.fileDiffHistories = []),
        (this.quotes = []),
        (this.additionalRankedContext = []),
        (this.isChat = !1),
        (this.conversationId = ""),
        (this.repositoryInfoShouldQueryStaging = !1),
        (this.isAgentic = !1),
        (this.supportedTools = []),
        (this.enableYoloMode = !1),
        (this.yoloPrompt = ""),
        (this.useUnifiedChatPrompt = !1),
        (this.mcpTools = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamUnifiedChatRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "conversation", kind: "message", T: se, repeated: !0 },
        {
          no: 30,
          name: "full_conversation_headers_only",
          kind: "message",
          T: cIt,
          repeated: !0,
        },
        { no: 2, name: "allow_long_file_scan", kind: "scalar", T: 8, opt: !0 },
        { no: 3, name: "explicit_context", kind: "message", T: Ne },
        {
          no: 4,
          name: "can_handle_filenames_after_language_ids",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 5, name: "model_details", kind: "message", T: vt },
        { no: 6, name: "linter_errors", kind: "message", T: hi },
        {
          no: 7,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 8, name: "use_web", kind: "scalar", T: 9, opt: !0 },
        { no: 9, name: "external_links", kind: "message", T: qq, repeated: !0 },
        { no: 10, name: "project_context", kind: "message", T: se, opt: !0 },
        {
          no: 11,
          name: "diffs_for_compressing_files",
          kind: "message",
          T: eIt,
          repeated: !0,
        },
        { no: 12, name: "compress_edits", kind: "scalar", T: 8, opt: !0 },
        { no: 13, name: "should_cache", kind: "scalar", T: 8, opt: !0 },
        {
          no: 14,
          name: "multi_file_linter_errors",
          kind: "message",
          T: hi,
          repeated: !0,
        },
        { no: 15, name: "current_file", kind: "message", T: Ht },
        { no: 16, name: "recent_edits", kind: "message", T: iIt, opt: !0 },
        {
          no: 17,
          name: "use_reference_composer_diff_prompt",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 18,
          name: "file_diff_histories",
          kind: "message",
          T: BU,
          repeated: !0,
        },
        {
          no: 19,
          name: "use_new_compression_scheme",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 21, name: "quotes", kind: "message", T: n7, repeated: !0 },
        {
          no: 20,
          name: "additional_ranked_context",
          kind: "message",
          T: _U,
          repeated: !0,
        },
        { no: 22, name: "is_chat", kind: "scalar", T: 8 },
        { no: 23, name: "conversation_id", kind: "scalar", T: 9 },
        { no: 24, name: "repository_info", kind: "message", T: _t },
        {
          no: 25,
          name: "repository_info_should_query_staging",
          kind: "scalar",
          T: 8,
        },
        { no: 26, name: "environment_info", kind: "message", T: tIt },
        { no: 27, name: "is_agentic", kind: "scalar", T: 8 },
        {
          no: 28,
          name: "conversation_summary",
          kind: "message",
          T: Mn,
          opt: !0,
        },
        {
          no: 29,
          name: "supported_tools",
          kind: "enum",
          T: n.getEnumType(fr),
          repeated: !0,
        },
        { no: 31, name: "enable_yolo_mode", kind: "scalar", T: 8 },
        { no: 32, name: "yolo_prompt", kind: "scalar", T: 9 },
        { no: 33, name: "use_unified_chat_prompt", kind: "scalar", T: 8 },
        { no: 34, name: "mcp_tools", kind: "message", T: FU, repeated: !0 },
        {
          no: 35,
          name: "use_full_inputs_context",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 36, name: "is_resume", kind: "scalar", T: 8, opt: !0 },
        {
          no: 37,
          name: "allow_model_fallbacks",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 38,
          name: "number_of_times_shown_fallback_model_warning",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new bE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bE, t, e)
    }
  },
  eIt = class EE extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.redRanges = []),
        (this.redRangesReversed = []),
        (this.startHash = ""),
        (this.endHash = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamUnifiedChatRequest.RedDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "red_ranges", kind: "message", T: rr, repeated: !0 },
        {
          no: 3,
          name: "red_ranges_reversed",
          kind: "message",
          T: rr,
          repeated: !0,
        },
        { no: 4, name: "start_hash", kind: "scalar", T: 9 },
        { no: 5, name: "end_hash", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new EE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new EE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new EE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(EE, t, e)
    }
  },
  iIt = class IE extends d {
    constructor(t) {
      super(),
        (this.codeBlockInfo = []),
        (this.finalFileValues = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamUnifiedChatRequest.RecentEdits"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "code_block_info",
          kind: "message",
          T: rIt,
          repeated: !0,
        },
        {
          no: 2,
          name: "final_file_values",
          kind: "message",
          T: nIt,
          repeated: !0,
        },
        {
          no: 3,
          name: "edits_belong_to_composer_generation_uuid",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new IE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IE, t, e)
    }
  },
  rIt = class PE extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamUnifiedChatRequest.RecentEdits.CodeBlockInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "content_before", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "content_after", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "generation_uuid", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "version", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new PE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PE, t, e)
    }
  },
  nIt = class NE extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.content = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamUnifiedChatRequest.RecentEdits.FileInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "content", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new NE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NE, t, e)
    }
  },
  Ntt = class $E extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamUnifiedChatResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 22, name: "server_bubble_id", kind: "scalar", T: 9, opt: !0 },
        {
          no: 2,
          name: "debugging_only_chat_prompt",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        {
          no: 3,
          name: "debugging_only_token_count",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 4, name: "document_citation", kind: "message", T: AU },
        { no: 5, name: "filled_prompt", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "is_big_file", kind: "scalar", T: 8, opt: !0 },
        { no: 7, name: "intermediate_text", kind: "scalar", T: 9, opt: !0 },
        {
          no: 10,
          name: "is_using_slow_request",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 8, name: "chunk_identity", kind: "message", T: sIt, opt: !0 },
        { no: 9, name: "docs_reference", kind: "message", T: M7, opt: !0 },
        { no: 11, name: "web_citation", kind: "message", T: Ett, opt: !0 },
        { no: 12, name: "status_updates", kind: "message", T: Ptt, opt: !0 },
        { no: 13, name: "tool_call", kind: "message", T: ukt, opt: !0 },
        {
          no: 14,
          name: "should_break_ai_message",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 15, name: "partial_tool_call", kind: "message", T: ckt, opt: !0 },
        { no: 16, name: "final_tool_result", kind: "message", T: aIt, opt: !0 },
        { no: 17, name: "symbol_link", kind: "message", T: qU, opt: !0 },
        { no: 19, name: "file_link", kind: "message", T: UU, opt: !0 },
        {
          no: 18,
          name: "conversation_summary",
          kind: "message",
          T: Mn,
          opt: !0,
        },
        {
          no: 20,
          name: "service_status_update",
          kind: "message",
          T: $tt,
          opt: !0,
        },
        {
          no: 21,
          name: "viewable_git_context",
          kind: "message",
          T: xtt,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new $E().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $E().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $E().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($E, t, e)
    }
  },
  sIt = class xE extends d {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.startLine = 0),
        (this.endLine = 0),
        (this.text = ""),
        (this.chunkType = Un.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamUnifiedChatResponse.ChunkIdentity"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "end_line", kind: "scalar", T: 5 },
        { no: 4, name: "text", kind: "scalar", T: 9 },
        { no: 5, name: "chunk_type", kind: "enum", T: n.getEnumType(Un) },
      ])
    }
    static fromBinary(t, e) {
      return new xE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xE, t, e)
    }
  },
  aIt = class JE extends d {
    constructor(t) {
      super(), (this.toolCallId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamUnifiedChatResponse.FinalToolResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool_call_id", kind: "scalar", T: 9 },
        { no: 2, name: "result", kind: "message", T: q7 },
      ])
    }
    static fromBinary(t, e) {
      return new JE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JE, t, e)
    }
  },
  $tt = class CE extends d {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.codicon = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ServiceStatusUpdate"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "codicon", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "allow_command_links_potentially_unsafe_please_only_use_for_handwritten_trusted_markdown",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 4,
          name: "action_to_run_on_status_update",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new CE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CE, t, e)
    }
  },
  qU = class LE extends d {
    constructor(t) {
      super(),
        (this.symbolName = ""),
        (this.symbolSearchString = ""),
        (this.relativeWorkspacePath = ""),
        (this.roughLineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SymbolLink"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "symbol_name", kind: "scalar", T: 9 },
        { no: 2, name: "symbol_search_string", kind: "scalar", T: 9 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "rough_line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new LE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LE, t, e)
    }
  },
  UU = class RE extends d {
    constructor(t) {
      super(),
        (this.displayName = ""),
        (this.relativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileLink"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "display_name", kind: "scalar", T: 9 },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new RE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RE, t, e)
    }
  },
  oIt = class DE extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.redRanges = []),
        (this.redRangesReversed = []),
        (this.startHash = ""),
        (this.endHash = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RedDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "red_ranges", kind: "message", T: rr, repeated: !0 },
        {
          no: 3,
          name: "red_ranges_reversed",
          kind: "message",
          T: rr,
          repeated: !0,
        },
        { no: 4, name: "start_hash", kind: "scalar", T: 9 },
        { no: 5, name: "end_hash", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new DE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DE, t, e)
    }
  },
  cIt = class FE extends d {
    constructor(t) {
      super(),
        (this.bubbleId = ""),
        (this.type = Ma.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessageHeader"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bubble_id", kind: "scalar", T: 9 },
        { no: 2, name: "server_bubble_id", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "type", kind: "enum", T: n.getEnumType(Ma) },
      ])
    }
    static fromBinary(t, e) {
      return new FE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FE, t, e)
    }
  },
  MU = class _E extends d {
    constructor(t) {
      super(),
        (this.fileDetails = ""),
        (this.fileName = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DiffFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_details", kind: "scalar", T: 9 },
        { no: 2, name: "file_name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new _E().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _E().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _E().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_E, t, e)
    }
  },
  uIt = class AE extends d {
    constructor(t) {
      super(),
        (this.description = ""),
        (this.message = ""),
        (this.files = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ViewableCommitProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "description", kind: "scalar", T: 9 },
        { no: 2, name: "message", kind: "scalar", T: 9 },
        { no: 3, name: "files", kind: "message", T: MU, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new AE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AE, t, e)
    }
  },
  lIt = class BE extends d {
    constructor(t) {
      super(),
        (this.title = ""),
        (this.body = ""),
        (this.files = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ViewablePRProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "body", kind: "scalar", T: 9 },
        { no: 3, name: "files", kind: "message", T: MU, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new BE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BE, t, e)
    }
  },
  dIt = class OE extends d {
    constructor(t) {
      super(),
        (this.files = []),
        (this.diffPreface = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ViewableDiffProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: MU, repeated: !0 },
        { no: 2, name: "diff_preface", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new OE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OE, t, e)
    }
  },
  xtt = class qE extends d {
    constructor(t) {
      super(), (this.diffData = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ViewableGitContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "commit_data", kind: "message", T: uIt, opt: !0 },
        { no: 2, name: "pull_request_data", kind: "message", T: lIt, opt: !0 },
        { no: 3, name: "diff_data", kind: "message", T: dIt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new qE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qE, t, e)
    }
  },
  se = class UE extends d {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.type = Ma.UNSPECIFIED),
        (this.attachedCodeChunks = []),
        (this.codebaseContextChunks = []),
        (this.commits = []),
        (this.pullRequests = []),
        (this.gitDiffs = []),
        (this.assistantSuggestedDiffs = []),
        (this.interpreterResults = []),
        (this.images = []),
        (this.attachedFolders = []),
        (this.approximateLintErrors = []),
        (this.bubbleId = ""),
        (this.attachedFoldersNew = []),
        (this.lints = []),
        (this.userResponsesToSuggestedCodeBlocks = []),
        (this.relevantFiles = []),
        (this.toolResults = []),
        (this.notepads = []),
        (this.capabilities = []),
        (this.editTrailContexts = []),
        (this.suggestedCodeBlocks = []),
        (this.diffsForCompressingFiles = []),
        (this.multiFileLinterErrors = []),
        (this.diffHistories = []),
        (this.recentlyViewedFiles = []),
        (this.recentLocationsHistory = []),
        (this.isAgentic = !1),
        (this.fileDiffTrajectories = []),
        (this.existedSubsequentTerminalCommand = !1),
        (this.existedPreviousTerminalCommand = !1),
        (this.docsReferences = []),
        (this.webReferences = []),
        (this.attachedFoldersListDirResults = []),
        (this.humanChanges = []),
        (this.attachedHumanChanges = !1),
        (this.summarizedComposers = []),
        (this.cursorRules = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "type", kind: "enum", T: n.getEnumType(Ma) },
        {
          no: 3,
          name: "attached_code_chunks",
          kind: "message",
          T: Lm,
          repeated: !0,
        },
        {
          no: 4,
          name: "codebase_context_chunks",
          kind: "message",
          T: ye,
          repeated: !0,
        },
        { no: 5, name: "commits", kind: "message", T: Os, repeated: !0 },
        { no: 6, name: "pull_requests", kind: "message", T: Jtt, repeated: !0 },
        { no: 7, name: "git_diffs", kind: "message", T: i7, repeated: !0 },
        {
          no: 8,
          name: "assistant_suggested_diffs",
          kind: "message",
          T: NIt,
          repeated: !0,
        },
        {
          no: 9,
          name: "interpreter_results",
          kind: "message",
          T: PIt,
          repeated: !0,
        },
        { no: 10, name: "images", kind: "message", T: Ls, repeated: !0 },
        {
          no: 11,
          name: "attached_folders",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 12,
          name: "approximate_lint_errors",
          kind: "message",
          T: wIt,
          repeated: !0,
        },
        { no: 13, name: "bubble_id", kind: "scalar", T: 9 },
        { no: 32, name: "server_bubble_id", kind: "scalar", T: 9, opt: !0 },
        {
          no: 14,
          name: "attached_folders_new",
          kind: "message",
          T: EIt,
          repeated: !0,
        },
        { no: 15, name: "lints", kind: "message", T: yIt, repeated: !0 },
        {
          no: 16,
          name: "user_responses_to_suggested_code_blocks",
          kind: "message",
          T: JIt,
          repeated: !0,
        },
        { no: 17, name: "relevant_files", kind: "scalar", T: 9, repeated: !0 },
        { no: 18, name: "tool_results", kind: "message", T: mIt, repeated: !0 },
        { no: 19, name: "notepads", kind: "message", T: fIt, repeated: !0 },
        {
          no: 20,
          name: "is_capability_iteration",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 21, name: "capabilities", kind: "message", T: PEt, repeated: !0 },
        {
          no: 22,
          name: "edit_trail_contexts",
          kind: "message",
          T: vIt,
          repeated: !0,
        },
        {
          no: 23,
          name: "suggested_code_blocks",
          kind: "message",
          T: xIt,
          repeated: !0,
        },
        {
          no: 24,
          name: "diffs_for_compressing_files",
          kind: "message",
          T: oIt,
          repeated: !0,
        },
        {
          no: 25,
          name: "multi_file_linter_errors",
          kind: "message",
          T: Jft,
          repeated: !0,
        },
        {
          no: 26,
          name: "diff_histories",
          kind: "message",
          T: RIt,
          repeated: !0,
        },
        {
          no: 27,
          name: "recently_viewed_files",
          kind: "message",
          T: Lm,
          repeated: !0,
        },
        {
          no: 28,
          name: "recent_locations_history",
          kind: "message",
          T: TIt,
          repeated: !0,
        },
        { no: 29, name: "is_agentic", kind: "scalar", T: 8 },
        {
          no: 30,
          name: "file_diff_trajectories",
          kind: "message",
          T: BU,
          repeated: !0,
        },
        {
          no: 31,
          name: "conversation_summary",
          kind: "message",
          T: Mn,
          opt: !0,
        },
        {
          no: 33,
          name: "existed_subsequent_terminal_command",
          kind: "scalar",
          T: 8,
        },
        {
          no: 34,
          name: "existed_previous_terminal_command",
          kind: "scalar",
          T: 8,
        },
        {
          no: 35,
          name: "docs_references",
          kind: "message",
          T: M7,
          repeated: !0,
        },
        {
          no: 36,
          name: "web_references",
          kind: "message",
          T: Itt,
          repeated: !0,
        },
        { no: 37, name: "git_context", kind: "message", T: xtt, opt: !0 },
        {
          no: 38,
          name: "attached_folders_list_dir_results",
          kind: "message",
          T: rtt,
          repeated: !0,
        },
        {
          no: 39,
          name: "cached_conversation_summary",
          kind: "message",
          T: Mn,
          opt: !0,
        },
        {
          no: 40,
          name: "human_changes",
          kind: "message",
          T: SIt,
          repeated: !0,
        },
        { no: 41, name: "attached_human_changes", kind: "scalar", T: 8 },
        {
          no: 42,
          name: "summarized_composers",
          kind: "message",
          T: pIt,
          repeated: !0,
        },
        { no: 43, name: "cursor_rules", kind: "message", T: Aq, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new UE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UE, t, e)
    }
  },
  Ma
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.HUMAN = 1)] = "HUMAN"),
    (i[(i.AI = 2)] = "AI")
})(Ma || (Ma = {})),
  n.util.setEnumType(Ma, "aiserver.v1.ConversationMessage.MessageType", [
    { no: 0, name: "MESSAGE_TYPE_UNSPECIFIED" },
    { no: 1, name: "MESSAGE_TYPE_HUMAN" },
    { no: 2, name: "MESSAGE_TYPE_AI" },
  ])
var Lm = class ME extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumber = 0),
        (this.lines = []),
        (this.languageIdentifier = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.CodeChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "lines", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 4,
          name: "summarization_strategy",
          kind: "enum",
          T: n.getEnumType(W7),
          opt: !0,
        },
        { no: 5, name: "language_identifier", kind: "scalar", T: 9 },
        { no: 6, name: "intent", kind: "enum", T: n.getEnumType(H7), opt: !0 },
        { no: 7, name: "is_final_version", kind: "scalar", T: 8, opt: !0 },
        { no: 8, name: "is_first_version", kind: "scalar", T: 8, opt: !0 },
        { no: 9, name: "contents_are_missing", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ME().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ME().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ME().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ME, t, e)
    }
  },
  H7
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.COMPOSER_FILE = 1)] = "COMPOSER_FILE"),
    (i[(i.COMPRESSED_COMPOSER_FILE = 2)] = "COMPRESSED_COMPOSER_FILE"),
    (i[(i.RECENTLY_VIEWED_FILE = 3)] = "RECENTLY_VIEWED_FILE"),
    (i[(i.OUTLINE = 4)] = "OUTLINE"),
    (i[(i.MENTIONED_FILE = 5)] = "MENTIONED_FILE"),
    (i[(i.CODE_SELECTION = 6)] = "CODE_SELECTION")
})(H7 || (H7 = {})),
  n.util.setEnumType(H7, "aiserver.v1.ConversationMessage.CodeChunk.Intent", [
    { no: 0, name: "INTENT_UNSPECIFIED" },
    { no: 1, name: "INTENT_COMPOSER_FILE" },
    { no: 2, name: "INTENT_COMPRESSED_COMPOSER_FILE" },
    { no: 3, name: "INTENT_RECENTLY_VIEWED_FILE" },
    { no: 4, name: "INTENT_OUTLINE" },
    { no: 5, name: "INTENT_MENTIONED_FILE" },
    { no: 6, name: "INTENT_CODE_SELECTION" },
  ])
var W7
;(function (i) {
  ;(i[(i.NONE_UNSPECIFIED = 0)] = "NONE_UNSPECIFIED"),
    (i[(i.SUMMARIZED = 1)] = "SUMMARIZED"),
    (i[(i.EMBEDDED = 2)] = "EMBEDDED")
})(W7 || (W7 = {})),
  n.util.setEnumType(
    W7,
    "aiserver.v1.ConversationMessage.CodeChunk.SummarizationStrategy",
    [
      { no: 0, name: "SUMMARIZATION_STRATEGY_NONE_UNSPECIFIED" },
      { no: 1, name: "SUMMARIZATION_STRATEGY_SUMMARIZED" },
      { no: 2, name: "SUMMARIZATION_STRATEGY_EMBEDDED" },
    ],
  )
var mIt = class HE extends d {
    constructor(t) {
      super(),
        (this.toolCallId = ""),
        (this.toolName = ""),
        (this.toolIndex = 0),
        (this.args = ""),
        (this.rawArgs = ""),
        (this.attachedCodeChunks = []),
        (this.images = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.ToolResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool_call_id", kind: "scalar", T: 9 },
        { no: 2, name: "tool_name", kind: "scalar", T: 9 },
        { no: 3, name: "tool_index", kind: "scalar", T: 13 },
        { no: 4, name: "args", kind: "scalar", T: 9 },
        { no: 5, name: "raw_args", kind: "scalar", T: 9 },
        {
          no: 6,
          name: "attached_code_chunks",
          kind: "message",
          T: Lm,
          repeated: !0,
        },
        { no: 7, name: "content", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "result", kind: "message", T: q7 },
        { no: 9, name: "error", kind: "message", T: LU, opt: !0 },
        { no: 10, name: "images", kind: "message", T: Ls, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new HE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HE, t, e)
    }
  },
  X2t = class WE extends d {
    constructor(t) {
      super(),
        (this.ranges = []),
        (this.content = ""),
        (this.relativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.MultiRangeCodeChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ranges", kind: "message", T: hIt, repeated: !0 },
        { no: 2, name: "content", kind: "scalar", T: 9 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new WE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WE, t, e)
    }
  },
  hIt = class jE extends d {
    constructor(t) {
      super(), (this.priority = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ConversationMessage.MultiRangeCodeChunk.RangeWithPriority"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "range", kind: "message", T: rr },
        { no: 2, name: "priority", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new jE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jE, t, e)
    }
  },
  fIt = class VE extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.text = ""),
        (this.attachedCodeChunks = []),
        (this.attachedFolders = []),
        (this.commits = []),
        (this.pullRequests = []),
        (this.gitDiffs = []),
        (this.images = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.NotepadContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "attached_code_chunks",
          kind: "message",
          T: Lm,
          repeated: !0,
        },
        { no: 4, name: "attached_folders", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "commits", kind: "message", T: Os, repeated: !0 },
        { no: 6, name: "pull_requests", kind: "message", T: Jtt, repeated: !0 },
        { no: 7, name: "git_diffs", kind: "message", T: i7, repeated: !0 },
        { no: 8, name: "images", kind: "message", T: Ls, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new VE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VE, t, e)
    }
  },
  pIt = class GE extends d {
    constructor(t) {
      super(), (this.name = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.ComposerContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "conversation_summary", kind: "message", T: Mn },
      ])
    }
    static fromBinary(t, e) {
      return new GE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GE, t, e)
    }
  },
  gIt = class zE extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contextLines = ""),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.EditLocation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 3, name: "range", kind: "message", T: rr },
        { no: 4, name: "initial_range", kind: "message", T: rr },
        { no: 5, name: "context_lines", kind: "scalar", T: 9 },
        { no: 6, name: "text", kind: "scalar", T: 9 },
        { no: 7, name: "text_range", kind: "message", T: rr },
      ])
    }
    static fromBinary(t, e) {
      return new zE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zE, t, e)
    }
  },
  vIt = class YE extends d {
    constructor(t) {
      super(),
        (this.uniqueId = ""),
        (this.editTrailSorted = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.EditTrailContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "unique_id", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "edit_trail_sorted",
          kind: "message",
          T: gIt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new YE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YE, t, e)
    }
  },
  wIt = class QE extends d {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.value = ""),
        (this.startLine = 0),
        (this.endLine = 0),
        (this.startColumn = 0),
        (this.endColumn = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.ApproximateLintError"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "value", kind: "scalar", T: 9 },
        { no: 3, name: "start_line", kind: "scalar", T: 5 },
        { no: 4, name: "end_line", kind: "scalar", T: 5 },
        { no: 5, name: "start_column", kind: "scalar", T: 5 },
        { no: 6, name: "end_column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new QE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QE, t, e)
    }
  },
  yIt = class XE extends d {
    constructor(t) {
      super(), (this.chatCodeblockModelValue = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.Lints"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "lints", kind: "message", T: _7 },
        { no: 2, name: "chat_codeblock_model_value", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new XE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XE, t, e)
    }
  },
  TIt = class KE extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.lineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.RecentLocation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new KE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KE, t, e)
    }
  },
  kIt = class ZE extends d {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.endLineNumberExclusive = 0),
        (this.beforeContextLines = []),
        (this.removedLines = []),
        (this.addedLines = []),
        (this.afterContextLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.RenderedDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_number_exclusive", kind: "scalar", T: 5 },
        {
          no: 3,
          name: "before_context_lines",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 4, name: "removed_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "added_lines", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 6,
          name: "after_context_lines",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new ZE().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZE().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZE().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZE, t, e)
    }
  },
  SIt = class tI extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.renderedDiffs = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ConversationMessage.HumanChange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "rendered_diffs",
          kind: "message",
          T: kIt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new tI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tI, t, e)
    }
  },
  K2t = class eI extends d {
    constructor(t) {
      super(), (this.query = ""), (this.files = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "files", kind: "message", T: bIt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new eI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eI, t, e)
    }
  },
  bIt = class iI extends d {
    constructor(t) {
      super(),
        (this.relativePath = ""),
        (this.content = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SearchFileInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_path", kind: "scalar", T: 9 },
        { no: 2, name: "content", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new iI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iI, t, e)
    }
  },
  EIt = class rI extends d {
    constructor(t) {
      super(),
        (this.relativePath = ""),
        (this.files = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FolderInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_path", kind: "scalar", T: 9 },
        { no: 2, name: "files", kind: "message", T: IIt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new rI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rI, t, e)
    }
  },
  IIt = class nI extends d {
    constructor(t) {
      super(),
        (this.relativePath = ""),
        (this.content = ""),
        (this.truncated = !1),
        (this.score = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FolderFileInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_path", kind: "scalar", T: 9 },
        { no: 2, name: "content", kind: "scalar", T: 9 },
        { no: 3, name: "truncated", kind: "scalar", T: 8 },
        { no: 4, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new nI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nI, t, e)
    }
  },
  PIt = class sI extends d {
    constructor(t) {
      super(),
        (this.output = ""),
        (this.success = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.InterpreterResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "output", kind: "scalar", T: 9 },
        { no: 2, name: "success", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new sI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sI, t, e)
    }
  },
  NIt = class aI extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.chunks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SimpleFileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 3, name: "chunks", kind: "message", T: $It, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new aI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aI, t, e)
    }
  },
  $It = class oI extends d {
    constructor(t) {
      super(),
        (this.oldLines = []),
        (this.newLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SimpleFileDiff.Chunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "old_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "new_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "old_range", kind: "message", T: vi },
        { no: 4, name: "new_range", kind: "message", T: vi },
      ])
    }
    static fromBinary(t, e) {
      return new oI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oI, t, e)
    }
  },
  Os = class cI extends d {
    constructor(t) {
      super(),
        (this.sha = ""),
        (this.message = ""),
        (this.description = ""),
        (this.diff = []),
        (this.author = ""),
        (this.date = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Commit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "sha", kind: "scalar", T: 9 },
        { no: 2, name: "message", kind: "scalar", T: 9 },
        { no: 3, name: "description", kind: "scalar", T: 9 },
        { no: 4, name: "diff", kind: "message", T: r7, repeated: !0 },
        { no: 5, name: "author", kind: "scalar", T: 9 },
        { no: 6, name: "date", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new cI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cI, t, e)
    }
  },
  Jtt = class uI extends d {
    constructor(t) {
      super(),
        (this.title = ""),
        (this.body = ""),
        (this.diff = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PullRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "body", kind: "scalar", T: 9 },
        { no: 3, name: "diff", kind: "message", T: r7, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new uI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uI, t, e)
    }
  },
  xIt = class lI extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SuggestedCodeBlock"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new lI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lI, t, e)
    }
  },
  JIt = class dI extends d {
    constructor(t) {
      super(),
        (this.userResponseType = Rm.UNSPECIFIED),
        (this.filePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UserResponseToSuggestedCodeBlock"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "user_response_type",
          kind: "enum",
          T: n.getEnumType(Rm),
        },
        { no: 2, name: "file_path", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "user_modifications_to_suggested_code_blocks",
          kind: "message",
          T: r7,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new dI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dI, t, e)
    }
  },
  Rm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.ACCEPT = 1)] = "ACCEPT"),
    (i[(i.REJECT = 2)] = "REJECT"),
    (i[(i.MODIFY = 3)] = "MODIFY")
})(Rm || (Rm = {})),
  n.util.setEnumType(
    Rm,
    "aiserver.v1.UserResponseToSuggestedCodeBlock.UserResponseType",
    [
      { no: 0, name: "USER_RESPONSE_TYPE_UNSPECIFIED" },
      { no: 1, name: "USER_RESPONSE_TYPE_ACCEPT" },
      { no: 2, name: "USER_RESPONSE_TYPE_REJECT" },
      { no: 3, name: "USER_RESPONSE_TYPE_MODIFY" },
    ],
  )
var CIt = class mI extends d {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.fileContent = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextRerankingCandidateFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "file_content", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new mI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mI, t, e)
    }
  },
  Ctt = class hI extends d {
    constructor(t) {
      super(),
        (this.chunks = []),
        (this.editor = Dm.UNSPECIFIED),
        (this.hitTimeout = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComposerFileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunks", kind: "message", T: LIt, repeated: !0 },
        { no: 2, name: "editor", kind: "enum", T: n.getEnumType(Dm) },
        { no: 3, name: "hit_timeout", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new hI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hI, t, e)
    }
  },
  Dm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.AI = 1)] = "AI"),
    (i[(i.HUMAN = 2)] = "HUMAN")
})(Dm || (Dm = {})),
  n.util.setEnumType(Dm, "aiserver.v1.ComposerFileDiff.Editor", [
    { no: 0, name: "EDITOR_UNSPECIFIED" },
    { no: 1, name: "EDITOR_AI" },
    { no: 2, name: "EDITOR_HUMAN" },
  ])
var LIt = class fI extends d {
    constructor(t) {
      super(),
        (this.diffString = ""),
        (this.oldStart = 0),
        (this.newStart = 0),
        (this.oldLines = 0),
        (this.newLines = 0),
        (this.linesRemoved = 0),
        (this.linesAdded = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ComposerFileDiff.ChunkDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diff_string", kind: "scalar", T: 9 },
        { no: 2, name: "old_start", kind: "scalar", T: 5 },
        { no: 3, name: "new_start", kind: "scalar", T: 5 },
        { no: 4, name: "old_lines", kind: "scalar", T: 5 },
        { no: 5, name: "new_lines", kind: "scalar", T: 5 },
        { no: 6, name: "lines_removed", kind: "scalar", T: 5 },
        { no: 7, name: "lines_added", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new fI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fI, t, e)
    }
  },
  RIt = class pI extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.diffs = []),
        (this.timestamp = 0),
        (this.uniqueId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DiffHistoryData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "diffs", kind: "message", T: Ctt, repeated: !0 },
        { no: 3, name: "timestamp", kind: "scalar", T: 1 },
        { no: 4, name: "unique_id", kind: "scalar", T: 9 },
        { no: 5, name: "start_to_end_diff", kind: "message", T: Ctt },
      ])
    }
    static fromBinary(t, e) {
      return new pI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pI, t, e)
    }
  },
  Ha = class gI extends d {
    constructor(t) {
      super(), (this.item = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PotentiallyCachedContextItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context_item", kind: "message", T: Ltt, oneof: "item" },
        {
          no: 2,
          name: "context_item_hash",
          kind: "scalar",
          T: 9,
          oneof: "item",
        },
      ])
    }
    static fromBinary(t, e) {
      return new gI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gI, t, e)
    }
  },
  j7 = class vI extends d {
    constructor(t) {
      super(), (this.contextItemStatuses = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextStatusUpdate"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "context_item_statuses",
          kind: "message",
          T: DIt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new vI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vI, t, e)
    }
  },
  V7 = class wI extends d {
    constructor(t) {
      super(), (this.missingContextItemHashes = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MissingContextItems"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 2,
          name: "missing_context_item_hashes",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new wI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wI, t, e)
    }
  },
  DIt = class yI extends d {
    constructor(t) {
      super(),
        (this.contextItemHash = ""),
        (this.shownToTheModel = !1),
        (this.score = 0),
        (this.percentageOfAvailableSpace = 0),
        (this.postGenerationEvaluation = Fm.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItemStatus"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context_item_hash", kind: "scalar", T: 9 },
        { no: 2, name: "shown_to_the_model", kind: "scalar", T: 8 },
        { no: 3, name: "score", kind: "scalar", T: 2 },
        { no: 4, name: "percentage_of_available_space", kind: "scalar", T: 2 },
        {
          no: 5,
          name: "post_generation_evaluation",
          kind: "enum",
          T: n.getEnumType(Fm),
        },
      ])
    }
    static fromBinary(t, e) {
      return new yI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yI, t, e)
    }
  },
  Fm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.USEFUL = 1)] = "USEFUL"),
    (i[(i.USELESS = 2)] = "USELESS")
})(Fm || (Fm = {})),
  n.util.setEnumType(
    Fm,
    "aiserver.v1.ContextItemStatus.PostGenerationEvaluation",
    [
      { no: 0, name: "POST_GENERATION_EVALUATION_UNSPECIFIED" },
      { no: 1, name: "POST_GENERATION_EVALUATION_USEFUL" },
      { no: 2, name: "POST_GENERATION_EVALUATION_USELESS" },
    ],
  )
var Ltt = class TI extends d {
    constructor(t) {
      super(), (this.item = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "intent", kind: "message", T: tPt },
        { no: 2, name: "file_chunk", kind: "message", T: Rtt, oneof: "item" },
        {
          no: 3,
          name: "outline_chunk",
          kind: "message",
          T: AIt,
          oneof: "item",
        },
        {
          no: 4,
          name: "cmd_k_selection",
          kind: "message",
          T: Dtt,
          oneof: "item",
        },
        {
          no: 5,
          name: "cmd_k_immediate_context",
          kind: "message",
          T: Ftt,
          oneof: "item",
        },
        { no: 6, name: "cmd_k_query", kind: "message", T: HU, oneof: "item" },
        {
          no: 7,
          name: "cmd_k_query_history",
          kind: "message",
          T: UIt,
          oneof: "item",
        },
        {
          no: 8,
          name: "custom_instructions",
          kind: "message",
          T: VIt,
          oneof: "item",
        },
        {
          no: 9,
          name: "go_to_definition_result",
          kind: "message",
          T: GIt,
          oneof: "item",
        },
        {
          no: 10,
          name: "documentation_chunk",
          kind: "message",
          T: zIt,
          oneof: "item",
        },
        { no: 11, name: "lints", kind: "message", T: YIt, oneof: "item" },
        {
          no: 12,
          name: "chat_history",
          kind: "message",
          T: WIt,
          oneof: "item",
        },
        {
          no: 13,
          name: "notebook_cell_output",
          kind: "message",
          T: XIt,
          oneof: "item",
        },
        {
          no: 14,
          name: "terminal_history",
          kind: "message",
          T: jIt,
          oneof: "item",
        },
        {
          no: 15,
          name: "terminal_cmd_k_query",
          kind: "message",
          T: _tt,
          oneof: "item",
        },
        {
          no: 16,
          name: "terminal_cmd_k_query_history",
          kind: "message",
          T: qIt,
          oneof: "item",
        },
        {
          no: 17,
          name: "sparse_file_chunk",
          kind: "message",
          T: FIt,
          oneof: "item",
        },
        {
          no: 18,
          name: "lsp_subgraph_chunk",
          kind: "message",
          T: KIt,
          oneof: "item",
        },
        {
          no: 19,
          name: "commit_note_chunk",
          kind: "message",
          T: ZIt,
          oneof: "item",
        },
        {
          no: 20,
          name: "file_diff_history",
          kind: "message",
          T: BIt,
          oneof: "item",
        },
        {
          no: 21,
          name: "cmd_k_query_history_in_diff_session",
          kind: "message",
          T: MIt,
          oneof: "item",
        },
      ])
    }
    static fromBinary(t, e) {
      return new TI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TI, t, e)
    }
  },
  Rtt = class kI extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.chunkContents = ""),
        (this.startLineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.FileChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "chunk_contents", kind: "scalar", T: 9 },
        { no: 3, name: "start_line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new kI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kI, t, e)
    }
  },
  FIt = class SI extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.lines = []),
        (this.totalNumberOfLinesInFile = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.SparseFileChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "lines", kind: "message", T: _It, repeated: !0 },
        { no: 3, name: "total_number_of_lines_in_file", kind: "scalar", T: 5 },
        { no: 4, name: "cell_number", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new SI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SI, t, e)
    }
  },
  _It = class bI extends d {
    constructor(t) {
      super(),
        (this.line = ""),
        (this.lineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.SparseFileChunk.Line"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new bI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bI, t, e)
    }
  },
  AIt = class EI extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.OutlineChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        { no: 3, name: "full_range", kind: "message", T: vi },
      ])
    }
    static fromBinary(t, e) {
      return new EI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new EI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new EI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(EI, t, e)
    }
  },
  Dtt = class II extends d {
    constructor(t) {
      super(),
        (this.lines = []),
        (this.startLineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.CmdKSelection"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new II().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new II().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new II().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(II, t, e)
    }
  },
  BIt = class PI extends d {
    constructor(t) {
      super(),
        (this.howManyDiffsAgo = 0),
        (this.isVeryRecent = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.FileDiffHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cpp_file_diff_history", kind: "message", T: Di },
        { no: 2, name: "how_many_diffs_ago", kind: "scalar", T: 5 },
        { no: 3, name: "is_very_recent", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new PI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PI, t, e)
    }
  },
  Ftt = class NI extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.lines = []),
        (this.totalNumberOfLinesInFile = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.CmdKImmediateContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "lines", kind: "message", T: OIt, repeated: !0 },
        { no: 3, name: "total_number_of_lines_in_file", kind: "scalar", T: 5 },
        { no: 4, name: "cell_number", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new NI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NI, t, e)
    }
  },
  OIt = class $I extends d {
    constructor(t) {
      super(),
        (this.line = ""),
        (this.lineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.CmdKImmediateContext.Line"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new $I().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $I().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $I().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($I, t, e)
    }
  },
  HU = class xI extends d {
    constructor(t) {
      super(), (this.query = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.CmdKQuery"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new xI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xI, t, e)
    }
  },
  _tt = class JI extends d {
    constructor(t) {
      super(), (this.query = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.TerminalCmdKQuery"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new JI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JI, t, e)
    }
  },
  qIt = class mu extends d {
    constructor(t) {
      super(),
        (this.contextItemHashes = []),
        (this.suggestedCommand = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.TerminalCmdKQueryHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "message", T: _tt },
        { no: 2, name: "query_history", kind: "message", T: mu },
        {
          no: 5,
          name: "context_item_hashes",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 6, name: "suggested_command", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new mu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mu, t, e)
    }
  },
  UIt = class hu extends d {
    constructor(t) {
      super(), (this.contextItemHashes = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.CmdKQueryHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "message", T: HU },
        { no: 2, name: "immediate_context", kind: "message", T: Ftt },
        { no: 3, name: "selection", kind: "message", T: Dtt },
        { no: 4, name: "query_history", kind: "message", T: hu },
        {
          no: 5,
          name: "context_item_hashes",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 6, name: "timestamp", kind: "scalar", T: 3, opt: !0 },
        { no: 7, name: "timestamp_double", kind: "scalar", T: 1, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new hu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hu, t, e)
    }
  },
  MIt = class CI extends d {
    constructor(t) {
      super(),
        (this.pastCmdkQueries = []),
        (this.currTimestampDouble = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.CmdKQueryHistoryInDiffSession"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "past_cmdk_queries",
          kind: "message",
          T: HIt,
          repeated: !0,
        },
        { no: 3, name: "curr_timestamp_double", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new CI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CI, t, e)
    }
  },
  HIt = class LI extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.timestampDouble = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ContextItem.CmdKQueryHistoryInDiffSession.PastCmdKQueryInDiffSession"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "message", T: HU },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 5, name: "cmdk_was_accepted", kind: "scalar", T: 8, opt: !0 },
        { no: 6, name: "timestamp_double", kind: "scalar", T: 1 },
        {
          no: 7,
          name: "timestamp_for_diff_interleaving",
          kind: "scalar",
          T: 1,
          opt: !0,
        },
        { no: 8, name: "request_id", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new LI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LI, t, e)
    }
  },
  WIt = class fu extends d {
    constructor(t) {
      super(),
        (this.userMessage = ""),
        (this.assistantResponse = ""),
        (this.activeForCmdK = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.ChatHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "user_message", kind: "scalar", T: 9 },
        { no: 2, name: "assistant_response", kind: "scalar", T: 9 },
        { no: 3, name: "chat_history", kind: "message", T: fu },
        { no: 4, name: "active_for_cmd_k", kind: "scalar", T: 8 },
        { no: 5, name: "timestamp", kind: "scalar", T: 3, opt: !0 },
        { no: 6, name: "timestamp_double", kind: "scalar", T: 1, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new fu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fu, t, e)
    }
  },
  jIt = class RI extends d {
    constructor(t) {
      super(),
        (this.history = ""),
        (this.cwdFull = ""),
        (this.cwdRelativeWorkspacePath = ""),
        (this.activeForCmdK = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.TerminalHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "history", kind: "scalar", T: 9 },
        { no: 5, name: "cwd_full", kind: "scalar", T: 9 },
        { no: 6, name: "cwd_relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "active_for_cmd_k", kind: "scalar", T: 8 },
        { no: 7, name: "timestamp", kind: "scalar", T: 3, opt: !0 },
        { no: 8, name: "timestamp_double", kind: "scalar", T: 1, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new RI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RI, t, e)
    }
  },
  VIt = class DI extends d {
    constructor(t) {
      super(), (this.instructions = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.CustomInstructions"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "instructions", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new DI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DI, t, e)
    }
  },
  GIt = class FI extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.line = ""),
        (this.lineNumber = 0),
        (this.columnNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.GoToDefinitionResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "line", kind: "scalar", T: 9 },
        { no: 3, name: "line_number", kind: "scalar", T: 5 },
        { no: 4, name: "column_number", kind: "scalar", T: 5 },
        { no: 5, name: "definition_chunk", kind: "message", T: Rtt },
      ])
    }
    static fromBinary(t, e) {
      return new FI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FI, t, e)
    }
  },
  zIt = class _I extends d {
    constructor(t) {
      super(),
        (this.docName = ""),
        (this.pageUrl = ""),
        (this.documentationChunk = ""),
        (this.score = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.DocumentationChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_name", kind: "scalar", T: 9 },
        { no: 2, name: "page_url", kind: "scalar", T: 9 },
        { no: 3, name: "documentation_chunk", kind: "scalar", T: 9 },
        { no: 4, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new _I().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _I().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _I().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_I, t, e)
    }
  },
  YIt = class AI extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.lints = []),
        (this.contextLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.Lints"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "lints", kind: "message", T: Ift, repeated: !0 },
        { no: 3, name: "context_lines", kind: "message", T: QIt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new AI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AI, t, e)
    }
  },
  QIt = class BI extends d {
    constructor(t) {
      super(),
        (this.line = ""),
        (this.lineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.Lints.Line"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new BI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BI, t, e)
    }
  },
  XIt = class OI extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.cellOutput = ""),
        (this.cellNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.NotebookCellOutput"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "cell_output", kind: "scalar", T: 9 },
        { no: 3, name: "cell_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new OI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OI, t, e)
    }
  },
  KIt = class qI extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.LspSubgraphChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "lsp_subgraph_full_context", kind: "message", T: Wq },
      ])
    }
    static fromBinary(t, e) {
      return new qI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qI, t, e)
    }
  },
  ZIt = class UI extends d {
    constructor(t) {
      super(), (this.note = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItem.CommitNoteChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "note", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new UI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UI, t, e)
    }
  },
  tPt = class MI extends d {
    constructor(t) {
      super(),
        (this.type = _m.UNSPECIFIED),
        (this.uuid = ""),
        (this.intent = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type", kind: "enum", T: n.getEnumType(_m) },
        { no: 15, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "file", kind: "message", T: iPt, oneof: "intent" },
        {
          no: 3,
          name: "code_selection",
          kind: "message",
          T: rPt,
          oneof: "intent",
        },
        { no: 5, name: "lints", kind: "message", T: sPt, oneof: "intent" },
        {
          no: 6,
          name: "recent_locations",
          kind: "message",
          T: cPt,
          oneof: "intent",
        },
        {
          no: 8,
          name: "cmd_k_current_file",
          kind: "message",
          T: dPt,
          oneof: "intent",
        },
        {
          no: 9,
          name: "cmd_k_query_etc",
          kind: "message",
          T: mPt,
          oneof: "intent",
        },
        {
          no: 14,
          name: "terminal_cmd_k_defaults",
          kind: "message",
          T: vPt,
          oneof: "intent",
        },
        {
          no: 10,
          name: "cmd_k_definitions",
          kind: "message",
          T: fPt,
          oneof: "intent",
        },
        {
          no: 11,
          name: "documentation",
          kind: "message",
          T: ePt,
          oneof: "intent",
        },
        {
          no: 12,
          name: "custom_instructions",
          kind: "message",
          T: hPt,
          oneof: "intent",
        },
        {
          no: 13,
          name: "chat_history",
          kind: "message",
          T: pPt,
          oneof: "intent",
        },
        {
          no: 16,
          name: "terminal_history",
          kind: "message",
          T: wPt,
          oneof: "intent",
        },
        {
          no: 17,
          name: "visible_tabs",
          kind: "message",
          T: lPt,
          oneof: "intent",
        },
        {
          no: 18,
          name: "lsp_subgraph",
          kind: "message",
          T: yPt,
          oneof: "intent",
        },
        {
          no: 19,
          name: "commit_notes",
          kind: "message",
          T: nPt,
          oneof: "intent",
        },
        {
          no: 20,
          name: "diff_history",
          kind: "message",
          T: gPt,
          oneof: "intent",
        },
        {
          no: 21,
          name: "past_cmdk_messages_in_diff_sessions",
          kind: "message",
          T: uPt,
          oneof: "intent",
        },
      ])
    }
    static fromBinary(t, e) {
      return new MI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MI, t, e)
    }
  },
  _m
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.USER_ADDED = 1)] = "USER_ADDED"),
    (i[(i.AUTOMATIC = 2)] = "AUTOMATIC")
})(_m || (_m = {})),
  n.util.setEnumType(_m, "aiserver.v1.ContextIntent.Type", [
    { no: 0, name: "TYPE_UNSPECIFIED" },
    { no: 1, name: "TYPE_USER_ADDED" },
    { no: 2, name: "TYPE_AUTOMATIC" },
  ])
var ePt = class HI extends d {
    constructor(t) {
      super(), (this.documentationIdentifier = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.Documentation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "documentation_identifier", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new HI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HI, t, e)
    }
  },
  iPt = class WI extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.mode = Am.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "mode", kind: "enum", T: n.getEnumType(Am) },
      ])
    }
    static fromBinary(t, e) {
      return new WI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WI, t, e)
    }
  },
  Am
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.FULL = 1)] = "FULL"),
    (i[(i.OUTLINE = 2)] = "OUTLINE"),
    (i[(i.CHUNKS = 3)] = "CHUNKS")
})(Am || (Am = {})),
  n.util.setEnumType(Am, "aiserver.v1.ContextIntent.File.Mode", [
    { no: 0, name: "MODE_UNSPECIFIED" },
    { no: 1, name: "MODE_FULL" },
    { no: 2, name: "MODE_OUTLINE" },
    { no: 3, name: "MODE_CHUNKS" },
  ])
var rPt = class jI extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.CodeSelection"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "potentially_out_of_date_range",
          kind: "message",
          T: mi,
        },
        { no: 3, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new jI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jI, t, e)
    }
  },
  Z2t = class VI extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.Symbol"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "symbol", kind: "message", T: Bq },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new VI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VI, t, e)
    }
  },
  nPt = class GI extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.CommitNotes"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new GI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GI, t, e)
    }
  },
  sPt = class zI extends d {
    constructor(t) {
      super(),
        (this.scope = { case: void 0 }),
        (this.filterToSeverities = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.Lints"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cmdk_scope", kind: "message", T: aPt, oneof: "scope" },
        { no: 2, name: "file_scope", kind: "message", T: oPt, oneof: "scope" },
        {
          no: 3,
          name: "filter_to_severities",
          kind: "enum",
          T: n.getEnumType(Tc),
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new zI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zI, t, e)
    }
  },
  aPt = class YI extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.Lints.CmdKScope"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new YI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YI, t, e)
    }
  },
  oPt = class QI extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.Lints.FileScope"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "filter_range", kind: "message", T: vi, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new QI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QI, t, e)
    }
  },
  cPt = class XI extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.RecentLocations"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "timestamp", kind: "scalar", T: 1, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new XI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XI, t, e)
    }
  },
  uPt = class KI extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ContextIntent.PastCmdkConversationsInDiffSessions"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new KI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KI, t, e)
    }
  },
  lPt = class ZI extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.VisibleTabs"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new ZI().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZI().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZI().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZI, t, e)
    }
  },
  tUt = class tP extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.CodebaseChunks"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new tP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tP, t, e)
    }
  },
  dPt = class eP extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.CmdKCurrentFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new eP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eP, t, e)
    }
  },
  mPt = class iP extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.CmdKQueryEtc"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new iP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iP, t, e)
    }
  },
  hPt = class rP extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.CustomInstructions"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new rP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rP, t, e)
    }
  },
  fPt = class nP extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.CmdKDefinitions"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new nP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nP, t, e)
    }
  },
  pPt = class sP extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.ChatHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new sP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sP, t, e)
    }
  },
  gPt = class aP extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.DiffHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new aP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aP, t, e)
    }
  },
  vPt = class oP extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.TerminalCmdKDefaults"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new oP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oP, t, e)
    }
  },
  wPt = class cP extends d {
    constructor(t) {
      super(),
        (this.instanceId = 0),
        (this.activeForCmdK = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.TerminalHistory"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "instance_id", kind: "scalar", T: 5 },
        { no: 2, name: "active_for_cmd_k", kind: "scalar", T: 8 },
        {
          no: 3,
          name: "use_active_instance_as_fallback",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new cP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cP, t, e)
    }
  },
  yPt = class uP extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextIntent.LspSubgraph"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new uP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uP, t, e)
    }
  },
  TPt = class lP extends d {
    constructor(t) {
      super(), (this.contextItems = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RerankCmdKContextRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context_items", kind: "message", T: Ha, repeated: !0 },
        { no: 3, name: "legacy_context", kind: "message", T: Bm },
        { no: 2, name: "cmd_k_options", kind: "message", T: G7 },
      ])
    }
    static fromBinary(t, e) {
      return new lP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lP, t, e)
    }
  },
  kPt = class dP extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RerankCmdKContextResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "context_status_update",
          kind: "message",
          T: j7,
          oneof: "response",
        },
        {
          no: 2,
          name: "missing_context_items",
          kind: "message",
          T: V7,
          oneof: "response",
        },
        { no: 3, name: "did_call", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new dP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dP, t, e)
    }
  },
  SPt = class mP extends d {
    constructor(t) {
      super(), (this.contextItems = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RerankTerminalCmdKContextRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context_items", kind: "message", T: Ha, repeated: !0 },
        { no: 2, name: "cmd_k_options", kind: "message", T: Att },
      ])
    }
    static fromBinary(t, e) {
      return new mP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mP, t, e)
    }
  },
  bPt = class hP extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RerankTerminalCmdKContextResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "context_status_update",
          kind: "message",
          T: j7,
          oneof: "response",
        },
        {
          no: 2,
          name: "missing_context_items",
          kind: "message",
          T: V7,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new hP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hP, t, e)
    }
  },
  Att = class fP extends d {
    constructor(t) {
      super(),
        (this.chatMode = !1),
        (this.adaCmdKContext = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TerminalCmdKOptions"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 3, name: "model_details", kind: "message", T: vt },
        { no: 1, name: "chat_mode", kind: "scalar", T: 8 },
        { no: 2, name: "ada_cmd_k_context", kind: "scalar", T: 8 },
        { no: 4, name: "use_web", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new fP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fP, t, e)
    }
  },
  G7 = class pP extends d {
    constructor(t) {
      super(),
        (this.chatMode = !1),
        (this.adaCmdKContext = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKOptions"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 3, name: "model_details", kind: "message", T: vt },
        { no: 1, name: "chat_mode", kind: "scalar", T: 8 },
        { no: 2, name: "ada_cmd_k_context", kind: "scalar", T: 8 },
        { no: 4, name: "use_reranker", kind: "scalar", T: 8, opt: !0 },
        { no: 5, name: "use_web", kind: "scalar", T: 8, opt: !0 },
        {
          no: 6,
          name: "request_is_for_caching",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new pP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pP, t, e)
    }
  },
  Btt = class gP extends d {
    constructor(t) {
      super(),
        (this.originalLines = []),
        (this.relativePath = ""),
        (this.extraContextAbove = []),
        (this.extraContextBelow = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKUpcomingEdit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "original_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "relative_path", kind: "scalar", T: 9 },
        {
          no: 4,
          name: "extra_context_above",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 5,
          name: "extra_context_below",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new gP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gP, t, e)
    }
  },
  z7 = class vP extends d {
    constructor(t) {
      super(),
        (this.originalLines = []),
        (this.newLines = []),
        (this.relativePath = ""),
        (this.extraContextAbove = []),
        (this.extraContextBelow = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKPreviousEdit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "original_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "new_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "relative_path", kind: "scalar", T: 9 },
        {
          no: 4,
          name: "extra_context_above",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 5,
          name: "extra_context_below",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new vP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vP, t, e)
    }
  },
  EPt = class wP extends d {
    constructor(t) {
      super(),
        (this.contextItems = []),
        (this.sessionId = ""),
        (this.previousEdits = []),
        (this.upcomingEdits = []),
        (this.images = []),
        (this.links = []),
        (this.diffHistory = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamHypermodeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context_items", kind: "message", T: Ha, repeated: !0 },
        { no: 2, name: "cmd_k_options", kind: "message", T: G7 },
        { no: 4, name: "cmd_k_debug_info", kind: "message", T: hr },
        { no: 6, name: "session_id", kind: "scalar", T: 9 },
        { no: 5, name: "legacy_context", kind: "message", T: Bm },
        { no: 7, name: "previous_edit", kind: "message", T: z7, opt: !0 },
        { no: 8, name: "previous_edits", kind: "message", T: z7, repeated: !0 },
        {
          no: 12,
          name: "upcoming_edits",
          kind: "message",
          T: Btt,
          repeated: !0,
        },
        {
          no: 9,
          name: "use_big_cmdk_for_multi_file_edit",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 10, name: "images", kind: "message", T: Ls, repeated: !0 },
        { no: 11, name: "links", kind: "message", T: Uq, repeated: !0 },
        { no: 13, name: "diff_history", kind: "message", T: Di, repeated: !0 },
        { no: 14, name: "hyper_model", kind: "scalar", T: 9, opt: !0 },
        { no: 15, name: "timing_info", kind: "message", T: Ott, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new wP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wP, t, e)
    }
  },
  IPt = class yP extends d {
    constructor(t) {
      super(),
        (this.contextItems = []),
        (this.sessionId = ""),
        (this.previousEdits = []),
        (this.upcomingEdits = []),
        (this.images = []),
        (this.links = []),
        (this.diffHistory = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context_items", kind: "message", T: Ha, repeated: !0 },
        { no: 2, name: "cmd_k_options", kind: "message", T: G7 },
        { no: 4, name: "cmd_k_debug_info", kind: "message", T: hr },
        { no: 6, name: "session_id", kind: "scalar", T: 9 },
        { no: 5, name: "legacy_context", kind: "message", T: Bm },
        { no: 7, name: "previous_edit", kind: "message", T: z7, opt: !0 },
        { no: 8, name: "previous_edits", kind: "message", T: z7, repeated: !0 },
        {
          no: 12,
          name: "upcoming_edits",
          kind: "message",
          T: Btt,
          repeated: !0,
        },
        {
          no: 9,
          name: "use_big_cmdk_for_multi_file_edit",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 10, name: "images", kind: "message", T: Ls, repeated: !0 },
        { no: 11, name: "links", kind: "message", T: Uq, repeated: !0 },
        { no: 13, name: "diff_history", kind: "message", T: Di, repeated: !0 },
        {
          no: 14,
          name: "diff_to_base_branch",
          kind: "message",
          T: PPt,
          opt: !0,
        },
        { no: 15, name: "timing_info", kind: "message", T: Ott, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new yP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yP, t, e)
    }
  },
  PPt = class TP extends d {
    constructor(t) {
      super(),
        (this.fileDiffs = []),
        (this.commits = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKRequest.BranchDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_diffs", kind: "message", T: NPt, repeated: !0 },
        { no: 2, name: "commits", kind: "message", T: Os, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new TP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TP, t, e)
    }
  },
  NPt = class kP extends d {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.diff = ""),
        (this.tooBig = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKRequest.BranchDiff.FileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "diff", kind: "scalar", T: 9 },
        { no: 3, name: "too_big", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new kP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kP, t, e)
    }
  },
  Ott = class SP extends d {
    constructor(t) {
      super(),
        (this.userInputTime = 0),
        (this.streamCmdkTime = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TimingInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "user_input_time", kind: "scalar", T: 1 },
        { no: 2, name: "stream_cmdk_time", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new SP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SP, t, e)
    }
  },
  $Pt = class bP extends d {
    constructor(t) {
      super(),
        (this.contextItems = []),
        (this.sessionId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamTerminalCmdKRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context_items", kind: "message", T: Ha, repeated: !0 },
        { no: 2, name: "cmd_k_options", kind: "message", T: Att },
        { no: 6, name: "session_id", kind: "scalar", T: 9 },
        { no: 5, name: "legacy_context", kind: "message", T: Bm },
      ])
    }
    static fromBinary(t, e) {
      return new bP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bP, t, e)
    }
  },
  Bm = class EP extends d {
    constructor(t) {
      super(),
        (this.promptCodeBlocks = []),
        (this.documentationIdentifiers = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CmdKLegacyContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 4, name: "explicit_context", kind: "message", T: Ne },
        {
          no: 12,
          name: "prompt_code_blocks",
          kind: "message",
          T: ye,
          repeated: !0,
        },
        {
          no: 10,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new EP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new EP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new EP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(EP, t, e)
    }
  },
  qtt = class IP extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKResponseContextWrapped"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "real_response",
          kind: "message",
          T: WU,
          oneof: "response",
        },
        {
          no: 2,
          name: "context_status_update",
          kind: "message",
          T: j7,
          oneof: "response",
        },
        {
          no: 3,
          name: "missing_context_items",
          kind: "message",
          T: V7,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new IP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IP, t, e)
    }
  },
  xPt = class PP extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamTerminalCmdKResponseContextWrapped"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "real_response",
          kind: "message",
          T: JPt,
          oneof: "response",
        },
        {
          no: 2,
          name: "context_status_update",
          kind: "message",
          T: j7,
          oneof: "response",
        },
        {
          no: 3,
          name: "missing_context_items",
          kind: "message",
          T: V7,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new PP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PP, t, e)
    }
  },
  JPt = class NP extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamTerminalCmdKResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "terminal_command",
          kind: "message",
          T: CPt,
          oneof: "response",
        },
        { no: 4, name: "chat", kind: "message", T: LPt, oneof: "response" },
        {
          no: 5,
          name: "status_update",
          kind: "message",
          T: RPt,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new NP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NP, t, e)
    }
  },
  CPt = class $P extends d {
    constructor(t) {
      super(), (this.partialCommand = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamTerminalCmdKResponse.TerminalCommand"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "partial_command", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $P().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $P().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $P().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($P, t, e)
    }
  },
  LPt = class xP extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamTerminalCmdKResponse.Chat"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new xP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xP, t, e)
    }
  },
  RPt = class JP extends d {
    constructor(t) {
      super(), (this.messages = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamTerminalCmdKResponse.StatusUpdate"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "messages", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new JP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JP, t, e)
    }
  },
  WU = class CP extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "edit_start",
          kind: "message",
          T: DPt,
          oneof: "response",
        },
        {
          no: 2,
          name: "edit_stream",
          kind: "message",
          T: FPt,
          oneof: "response",
        },
        { no: 3, name: "edit_end", kind: "message", T: _Pt, oneof: "response" },
        { no: 4, name: "chat", kind: "message", T: APt, oneof: "response" },
        {
          no: 5,
          name: "status_update",
          kind: "message",
          T: BPt,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new CP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CP, t, e)
    }
  },
  DPt = class LP extends d {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.editId = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKResponse.EditStart"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "edit_id", kind: "scalar", T: 5 },
        {
          no: 3,
          name: "max_end_line_number_exclusive",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 4, name: "file_path", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new LP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LP, t, e)
    }
  },
  FPt = class RP extends d {
    constructor(t) {
      super(), (this.text = ""), (this.editId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKResponse.EditStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "edit_id", kind: "scalar", T: 5 },
        { no: 3, name: "file_path", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new RP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RP, t, e)
    }
  },
  _Pt = class DP extends d {
    constructor(t) {
      super(),
        (this.endLineNumberExclusive = 0),
        (this.editId = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKResponse.EditEnd"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "end_line_number_exclusive", kind: "scalar", T: 5 },
        { no: 2, name: "edit_id", kind: "scalar", T: 5 },
        { no: 3, name: "file_path", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new DP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DP, t, e)
    }
  },
  APt = class FP extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKResponse.Chat"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new FP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FP, t, e)
    }
  },
  BPt = class _P extends d {
    constructor(t) {
      super(), (this.messages = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCmdKResponse.StatusUpdate"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "messages", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new _P().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _P().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _P().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_P, t, e)
    }
  },
  OPt = class AP extends d {
    constructor(t) {
      super(),
        (this.codeBlocks = []),
        (this.contextItems = []),
        (this.sessionId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetRelevantChunksRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_blocks", kind: "message", T: ye, repeated: !0 },
        { no: 2, name: "cmd_k_options", kind: "message", T: G7 },
        { no: 3, name: "context_items", kind: "message", T: Ha, repeated: !0 },
        { no: 4, name: "session_id", kind: "scalar", T: 9 },
        { no: 5, name: "legacy_context", kind: "message", T: Bm },
      ])
    }
    static fromBinary(t, e) {
      return new AP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AP, t, e)
    }
  },
  qPt = class BP extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamGetRelevantChunksResponseContextWrapped"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "real_response",
          kind: "message",
          T: UPt,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new BP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BP, t, e)
    }
  },
  UPt = class OP extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetRelevantChunksResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "code_blocks",
          kind: "message",
          T: HPt,
          oneof: "response",
        },
        {
          no: 2,
          name: "chain_of_thought_stream",
          kind: "message",
          T: MPt,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new OP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OP, t, e)
    }
  },
  MPt = class qP extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.GetRelevantChunksResponse.ChainOfThoughtStream"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new qP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qP, t, e)
    }
  },
  HPt = class UP extends d {
    constructor(t) {
      super(), (this.codeBlocks = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetRelevantChunksResponse.CodeBlocks"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_blocks", kind: "message", T: ye, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new UP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UP, t, e)
    }
  },
  Y7
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.ACCEPTED = 1)] = "ACCEPTED"),
    (i[(i.REJECTED = 2)] = "REJECTED"),
    (i[(i.PARTIALLY_ACCEPTED = 3)] = "PARTIALLY_ACCEPTED")
})(Y7 || (Y7 = {})),
  n.util.setEnumType(Y7, "aiserver.v1.EditFate", [
    { no: 0, name: "EDIT_FATE_UNSPECIFIED" },
    { no: 1, name: "EDIT_FATE_ACCEPTED" },
    { no: 2, name: "EDIT_FATE_REJECTED" },
    { no: 3, name: "EDIT_FATE_PARTIALLY_ACCEPTED" },
  ])
var Dc
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.COMPOSER = 1)] = "COMPOSER"),
    (i[(i.CLICKED_APPLY = 2)] = "CLICKED_APPLY"),
    (i[(i.CACHED_APPLY = 3)] = "CACHED_APPLY"),
    (i[(i.COMPOSER_AGENT = 4)] = "COMPOSER_AGENT")
})(Dc || (Dc = {})),
  n.util.setEnumType(Dc, "aiserver.v1.FastApplySource", [
    { no: 0, name: "FAST_APPLY_SOURCE_UNSPECIFIED" },
    { no: 1, name: "FAST_APPLY_SOURCE_COMPOSER" },
    { no: 2, name: "FAST_APPLY_SOURCE_CLICKED_APPLY" },
    { no: 3, name: "FAST_APPLY_SOURCE_CACHED_APPLY" },
    { no: 4, name: "FAST_APPLY_SOURCE_COMPOSER_AGENT" },
  ])
var WPt = class MP extends d {
    constructor(t) {
      super(), (this.requestId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportEditFateRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "fate", kind: "enum", T: n.getEnumType(Y7), opt: !0 },
        {
          no: 3,
          name: "num_accepted_partial_diffs",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 4,
          name: "num_rejected_partial_diffs",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new MP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MP, t, e)
    }
  },
  jPt = class HP extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportEditFateResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new HP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HP, t, e)
    }
  },
  VPt = class WP extends d {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.source = Dc.UNSPECIFIED),
        (this.willingToPayExtraForSpeed = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WarmApplyRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "current_file", kind: "message", T: Ht },
        { no: 3, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Ne },
        { no: 5, name: "source", kind: "enum", T: n.getEnumType(Dc) },
        { no: 6, name: "willing_to_pay_extra_for_speed", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new WP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WP, t, e)
    }
  },
  GPt = class jP extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WarmApplyResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new jP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jP, t, e)
    }
  },
  Wa
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SPECIFIC_RULES = 1)] = "SPECIFIC_RULES"),
    (i[(i.COMPILE_ERRORS = 2)] = "COMPILE_ERRORS"),
    (i[(i.CHANGE_BEHAVIOR = 3)] = "CHANGE_BEHAVIOR"),
    (i[(i.RELEVANCE = 5)] = "RELEVANCE"),
    (i[(i.USER_AWARENESS = 6)] = "USER_AWARENESS"),
    (i[(i.CORRECTNESS = 7)] = "CORRECTNESS"),
    (i[(i.CHUNKING = 8)] = "CHUNKING"),
    (i[(i.TYPO = 9)] = "TYPO"),
    (i[(i.CONFIDENCE = 10)] = "CONFIDENCE"),
    (i[(i.DISMISSED_BUGS = 11)] = "DISMISSED_BUGS")
})(Wa || (Wa = {})),
  n.util.setEnumType(Wa, "aiserver.v1.LintDiscriminator", [
    { no: 0, name: "LINT_DISCRIMINATOR_UNSPECIFIED" },
    { no: 1, name: "LINT_DISCRIMINATOR_SPECIFIC_RULES" },
    { no: 2, name: "LINT_DISCRIMINATOR_COMPILE_ERRORS" },
    { no: 3, name: "LINT_DISCRIMINATOR_CHANGE_BEHAVIOR" },
    { no: 5, name: "LINT_DISCRIMINATOR_RELEVANCE" },
    { no: 6, name: "LINT_DISCRIMINATOR_USER_AWARENESS" },
    { no: 7, name: "LINT_DISCRIMINATOR_CORRECTNESS" },
    { no: 8, name: "LINT_DISCRIMINATOR_CHUNKING" },
    { no: 9, name: "LINT_DISCRIMINATOR_TYPO" },
    { no: 10, name: "LINT_DISCRIMINATOR_CONFIDENCE" },
    { no: 11, name: "LINT_DISCRIMINATOR_DISMISSED_BUGS" },
  ])
var ja
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.NAIVE = 1)] = "NAIVE"),
    (i[(i.COMMENT_PIPELINE = 2)] = "COMMENT_PIPELINE"),
    (i[(i.SIMPLE_BUG = 3)] = "SIMPLE_BUG"),
    (i[(i.SIMPLE_LINT_RULES = 4)] = "SIMPLE_LINT_RULES")
})(ja || (ja = {})),
  n.util.setEnumType(ja, "aiserver.v1.LintGenerator", [
    { no: 0, name: "LINT_GENERATOR_UNSPECIFIED" },
    { no: 1, name: "LINT_GENERATOR_NAIVE" },
    { no: 2, name: "LINT_GENERATOR_COMMENT_PIPELINE" },
    { no: 3, name: "LINT_GENERATOR_SIMPLE_BUG" },
    { no: 4, name: "LINT_GENERATOR_SIMPLE_LINT_RULES" },
  ])
var Utt = class VP extends d {
    constructor(t) {
      super(),
        (this.relativeFilePath = ""),
        (this.lineSelection = ""),
        (this.tokenStartIndex = 0),
        (this.tokenEndIndex = 0),
        (this.likelyAlternateToken = ""),
        (this.lineChunkIndexZeroBased = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintExplanationRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_file_path", kind: "scalar", T: 9 },
        { no: 2, name: "chunk", kind: "message", T: Om },
        { no: 3, name: "line_selection", kind: "scalar", T: 9 },
        { no: 4, name: "token_start_index", kind: "scalar", T: 5 },
        { no: 5, name: "token_end_index", kind: "scalar", T: 5 },
        { no: 6, name: "likely_alternate_token", kind: "scalar", T: 9 },
        { no: 7, name: "line_chunk_index_zero_based", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new VP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VP, t, e)
    }
  },
  zPt = class GP extends d {
    constructor(t) {
      super(), (this.explanation = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintExplanationResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "explanation", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new GP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GP, t, e)
    }
  },
  YPt = class zP extends d {
    constructor(t) {
      super(),
        (this.origLine = ""),
        (this.newLine = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintExplanationResponse2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "orig_line", kind: "scalar", T: 9 },
        { no: 2, name: "new_line", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new zP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zP, t, e)
    }
  },
  Om = class YP extends d {
    constructor(t) {
      super(),
        (this.chunkContents = ""),
        (this.startLineNumber = 0),
        (this.numRemainingLines = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "chunk_contents", kind: "scalar", T: 9 },
        { no: 3, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "num_remaining_lines", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new YP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YP, t, e)
    }
  },
  QPt = class QP extends d {
    constructor(t) {
      super(), (this.relativeFilePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintChunkRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_file_path", kind: "scalar", T: 9 },
        { no: 2, name: "chunk", kind: "message", T: Om },
        {
          no: 3,
          name: "use_speculative_linter",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new QP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QP, t, e)
    }
  },
  XPt = class XP extends d {
    constructor(t) {
      super(), (this.chunkTokens = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintChunkResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunk_tokens", kind: "message", T: jU, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new XP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XP, t, e)
    }
  },
  KPt = class KP extends d {
    constructor(t) {
      super(), (this.relativeFilePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintFimChunkRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_file_path", kind: "scalar", T: 9 },
        { no: 2, name: "prefix", kind: "message", T: Om },
        { no: 3, name: "suffix", kind: "message", T: Om },
        { no: 4, name: "middle", kind: "message", T: Om },
      ])
    }
    static fromBinary(t, e) {
      return new KP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KP, t, e)
    }
  },
  ZPt = class ZP extends d {
    constructor(t) {
      super(), (this.middleChunkTokens = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintFimChunkResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "middle_chunk_tokens",
          kind: "message",
          T: jU,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new ZP().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZP().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZP().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZP, t, e)
    }
  },
  tNt = class tN extends d {
    constructor(t) {
      super(),
        (this.relativeFilePath = ""),
        (this.fileContents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintFileRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_file_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new tN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tN, t, e)
    }
  },
  eNt = class eN extends d {
    constructor(t) {
      super(),
        (this.token = ""),
        (this.logProbability = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TokensWithLogprobs"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "token", kind: "scalar", T: 9 },
        { no: 2, name: "log_probability", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new eN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eN, t, e)
    }
  },
  jU = class iN extends d {
    constructor(t) {
      super(),
        (this.tokensWithLogprobs = []),
        (this.actualToken = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TokenIndex"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "tokens_with_logprobs",
          kind: "message",
          T: eNt,
          repeated: !0,
        },
        { no: 2, name: "actual_token", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new iN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iN, t, e)
    }
  },
  iNt = class rN extends d {
    constructor(t) {
      super(), (this.tokens = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintFileResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tokens", kind: "message", T: jU, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new rN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rN, t, e)
    }
  },
  rNt = class nN extends d {
    constructor(t) {
      super(),
        (this.discriminator = Wa.UNSPECIFIED),
        (this.allow = !1),
        (this.reasoning = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LintDiscriminatorResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "discriminator", kind: "enum", T: n.getEnumType(Wa) },
        { no: 2, name: "allow", kind: "scalar", T: 8 },
        { no: 3, name: "reasoning", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new nN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nN, t, e)
    }
  },
  Q7 = class sN extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.uuid = ""),
        (this.message = ""),
        (this.replaceText = ""),
        (this.replaceInitialText = ""),
        (this.reevaluateInitialText = ""),
        (this.generator = ja.UNSPECIFIED),
        (this.discriminatorResults = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiLintBug"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 8, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "message", kind: "scalar", T: 9 },
        { no: 3, name: "replace_range", kind: "message", T: mi },
        { no: 4, name: "replace_text", kind: "scalar", T: 9 },
        { no: 5, name: "replace_initial_text", kind: "scalar", T: 9 },
        { no: 6, name: "reevaluate_range", kind: "message", T: mi },
        { no: 7, name: "reevaluate_initial_text", kind: "scalar", T: 9 },
        { no: 9, name: "generator", kind: "enum", T: n.getEnumType(ja) },
        {
          no: 10,
          name: "discriminator_results",
          kind: "message",
          T: rNt,
          repeated: !0,
        },
        { no: 11, name: "logprobs_payload", kind: "message", T: nNt },
      ])
    }
    static fromBinary(t, e) {
      return new sN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sN, t, e)
    }
  },
  nNt = class aN extends d {
    constructor(t) {
      super(),
        (this.chunk = ""),
        (this.problematicLine = ""),
        (this.startCol = 0),
        (this.endCol = 0),
        (this.mostLikelyReplace = ""),
        (this.lineChunkIndexZeroBased = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogprobsLintPayload"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunk", kind: "scalar", T: 9 },
        { no: 2, name: "problematic_line", kind: "scalar", T: 9 },
        { no: 3, name: "start_col", kind: "scalar", T: 5 },
        { no: 4, name: "end_col", kind: "scalar", T: 5 },
        { no: 5, name: "most_likely_replace", kind: "scalar", T: 9 },
        { no: 6, name: "line_chunk_index_zero_based", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new aN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aN, t, e)
    }
  },
  eUt = class oN extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.uuid = ""),
        (this.message = ""),
        (this.lineNumber = 0),
        (this.reevaluateInitialText = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiLintInlineSuggestion"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 8, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "message", kind: "scalar", T: 9 },
        { no: 3, name: "line_number", kind: "scalar", T: 5 },
        { no: 4, name: "reevaluate_range", kind: "message", T: mi },
        { no: 5, name: "reevaluate_initial_text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new oN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oN, t, e)
    }
  },
  iUt = class cN extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.uuid = ""),
        (this.message = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiLintOutOfFlowSuggestion"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 8, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "message", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new cN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cN, t, e)
    }
  },
  sNt = class uN extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiLintRule"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new uN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uN, t, e)
    }
  },
  Mtt = class lN extends d {
    constructor(t) {
      super(), (this.files = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextAST"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: aNt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new lN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lN, t, e)
    }
  },
  aNt = class dN extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.nodes = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContainerTree"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "nodes", kind: "message", T: Htt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new dN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dN, t, e)
    }
  },
  Htt = class mN extends d {
    constructor(t) {
      super(), (this.node = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContainerTreeNode"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "container", kind: "message", T: cNt, oneof: "node" },
        { no: 2, name: "blob", kind: "message", T: uNt, oneof: "node" },
        { no: 3, name: "symbol", kind: "message", T: oNt, oneof: "node" },
      ])
    }
    static fromBinary(t, e) {
      return new mN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mN, t, e)
    }
  },
  oNt = class hN extends d {
    constructor(t) {
      super(),
        (this.docString = ""),
        (this.value = ""),
        (this.references = []),
        (this.score = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContainerTreeNode.Symbol"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_string", kind: "scalar", T: 9 },
        { no: 2, name: "value", kind: "scalar", T: 9 },
        { no: 6, name: "references", kind: "message", T: Wtt, repeated: !0 },
        { no: 7, name: "score", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new hN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hN, t, e)
    }
  },
  cNt = class fN extends d {
    constructor(t) {
      super(),
        (this.docString = ""),
        (this.header = ""),
        (this.trailer = ""),
        (this.children = []),
        (this.references = []),
        (this.score = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContainerTreeNode.Container"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_string", kind: "scalar", T: 9 },
        { no: 2, name: "header", kind: "scalar", T: 9 },
        { no: 3, name: "trailer", kind: "scalar", T: 9 },
        { no: 5, name: "children", kind: "message", T: Htt, repeated: !0 },
        { no: 6, name: "references", kind: "message", T: Wtt, repeated: !0 },
        { no: 7, name: "score", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new fN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fN, t, e)
    }
  },
  uNt = class pN extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContainerTreeNode.Blob"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new pN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pN, t, e)
    }
  },
  Wtt = class gN extends d {
    constructor(t) {
      super(),
        (this.value = ""),
        (this.relativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContainerTreeNode.Reference"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 9 },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new gN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gN, t, e)
    }
  },
  VU = class vN extends d {
    constructor(t) {
      super(), (this.feature = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chat", kind: "message", T: dNt, oneof: "feature" },
        {
          no: 2,
          name: "context_chat",
          kind: "message",
          T: gNt,
          oneof: "feature",
        },
        { no: 3, name: "cmd_k", kind: "message", T: vNt, oneof: "feature" },
        {
          no: 4,
          name: "terminal_cmd_k",
          kind: "message",
          T: wNt,
          oneof: "feature",
        },
        {
          no: 5,
          name: "ai_review_accepted_comment",
          kind: "message",
          T: yNt,
          oneof: "feature",
        },
        {
          no: 6,
          name: "interpreter_chat",
          kind: "message",
          T: TNt,
          oneof: "feature",
        },
        {
          no: 7,
          name: "slash_edit",
          kind: "message",
          T: kNt,
          oneof: "feature",
        },
        { no: 8, name: "composer", kind: "message", T: hNt, oneof: "feature" },
        {
          no: 9,
          name: "fast_apply",
          kind: "message",
          T: mNt,
          oneof: "feature",
        },
        {
          no: 10,
          name: "warm_composer",
          kind: "message",
          T: pNt,
          oneof: "feature",
        },
        {
          no: 11,
          name: "bug_finder_trigger_v1",
          kind: "message",
          T: lNt,
          oneof: "feature",
        },
        {
          no: 12,
          name: "tool_call_composer",
          kind: "message",
          T: fNt,
          oneof: "feature",
        },
        {
          no: 13,
          name: "override_num_requests_counted",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new vN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vN, t, e)
    }
  },
  lNt = class wN extends d {
    constructor(t) {
      super(),
        (this.inBackgroundSubsidized = !1),
        (this.costCents = 0),
        (this.isFast = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.BugFinderTriggerV1"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "in_background_subsidized", kind: "scalar", T: 8 },
        { no: 2, name: "cost_cents", kind: "scalar", T: 5 },
        { no: 3, name: "is_fast", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new wN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wN, t, e)
    }
  },
  dNt = class yN extends d {
    constructor(t) {
      super(), (this.modelIntent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.Chat"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_intent", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new yN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yN, t, e)
    }
  },
  mNt = class TN extends d {
    constructor(t) {
      super(),
        (this.isOptimistic = !1),
        (this.willingToPayExtraForSpeed = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.FastApply"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "is_optimistic", kind: "scalar", T: 8 },
        { no: 2, name: "willing_to_pay_extra_for_speed", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new TN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TN, t, e)
    }
  },
  hNt = class kN extends d {
    constructor(t) {
      super(), (this.modelIntent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.Composer"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_intent", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new kN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kN, t, e)
    }
  },
  fNt = class SN extends d {
    constructor(t) {
      super(), (this.modelIntent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.ToolCallComposer"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_intent", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new SN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SN, t, e)
    }
  },
  pNt = class bN extends d {
    constructor(t) {
      super(), (this.modelIntent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.WarmComposer"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_intent", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new bN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bN, t, e)
    }
  },
  gNt = class EN extends d {
    constructor(t) {
      super(), (this.modelIntent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.ContextChat"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_intent", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new EN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new EN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new EN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(EN, t, e)
    }
  },
  vNt = class IN extends d {
    constructor(t) {
      super(), (this.modelIntent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.CmdK"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_intent", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new IN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IN, t, e)
    }
  },
  wNt = class PN extends d {
    constructor(t) {
      super(), (this.modelIntent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.TerminalCmdK"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_intent", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new PN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PN, t, e)
    }
  },
  yNt = class NN extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.AiReviewAcceptedComment"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new NN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NN, t, e)
    }
  },
  TNt = class $N extends d {
    constructor(t) {
      super(), (this.modelIntent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.InterpreterChat"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_intent", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $N().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $N().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $N().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($N, t, e)
    }
  },
  kNt = class xN extends d {
    constructor(t) {
      super(), (this.modelIntent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEventDetails.SlashEdit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_intent", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new xN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xN, t, e)
    }
  },
  SNt = class JN extends d {
    constructor(t) {
      super(),
        (this.timestamp = Pe.zero),
        (this.isSlow = !1),
        (this.status = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "timestamp", kind: "scalar", T: 3 },
        { no: 2, name: "details", kind: "message", T: VU },
        {
          no: 3,
          name: "subscription_product_id",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        { no: 4, name: "usage_price_id", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "is_slow", kind: "scalar", T: 8 },
        { no: 6, name: "status", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new JN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JN, t, e)
    }
  },
  jtt = class CN extends d {
    constructor(t) {
      super(),
        (this.interfaceRelativeWorkspacePath = ""),
        (this.interfaceLines = []),
        (this.testLines = []),
        (this.implementationLines = []),
        (this.language = ""),
        (this.testingFramework = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.InterfaceAgentClientState"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 3,
          name: "interface_relative_workspace_path",
          kind: "scalar",
          T: 9,
        },
        { no: 4, name: "interface_lines", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 5,
          name: "test_relative_workspace_path",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        { no: 10, name: "test_lines", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 6,
          name: "implementation_relative_workspace_path",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        {
          no: 7,
          name: "implementation_lines",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 8, name: "language", kind: "scalar", T: 9 },
        { no: 9, name: "testing_framework", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new CN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CN, t, e)
    }
  },
  Vtt = class LN extends d {
    constructor(t) {
      super(),
        (this.validateConfiguration = ni.UNSPECIFIED),
        (this.stubNewFunction = ni.UNSPECIFIED),
        (this.verifySpec = ni.UNSPECIFIED),
        (this.writeTestPlan = ni.UNSPECIFIED),
        (this.writeTests = ni.UNSPECIFIED),
        (this.writeImplementation = ni.UNSPECIFIED),
        (this.implementNewFunction = ni.UNSPECIFIED),
        (this.runTests = ni.UNSPECIFIED),
        (this.validateConfigurationMessage = ""),
        (this.stubNewFunctionMessage = ""),
        (this.verifySpecMessage = ""),
        (this.writeTestPlanMessage = ""),
        (this.writeTestsMessage = ""),
        (this.writeImplementationMessage = ""),
        (this.implementNewFunctionMessage = ""),
        (this.runTestsMessage = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.InterfaceAgentStatus"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "validate_configuration",
          kind: "enum",
          T: n.getEnumType(ni),
        },
        {
          no: 2,
          name: "stub_new_function",
          kind: "enum",
          T: n.getEnumType(ni),
        },
        { no: 3, name: "verify_spec", kind: "enum", T: n.getEnumType(ni) },
        { no: 15, name: "write_test_plan", kind: "enum", T: n.getEnumType(ni) },
        { no: 4, name: "write_tests", kind: "enum", T: n.getEnumType(ni) },
        {
          no: 5,
          name: "write_implementation",
          kind: "enum",
          T: n.getEnumType(ni),
        },
        {
          no: 6,
          name: "implement_new_function",
          kind: "enum",
          T: n.getEnumType(ni),
        },
        { no: 7, name: "run_tests", kind: "enum", T: n.getEnumType(ni) },
        { no: 8, name: "validate_configuration_message", kind: "scalar", T: 9 },
        { no: 9, name: "stub_new_function_message", kind: "scalar", T: 9 },
        { no: 10, name: "verify_spec_message", kind: "scalar", T: 9 },
        { no: 16, name: "write_test_plan_message", kind: "scalar", T: 9 },
        { no: 11, name: "write_tests_message", kind: "scalar", T: 9 },
        { no: 12, name: "write_implementation_message", kind: "scalar", T: 9 },
        {
          no: 13,
          name: "implement_new_function_message",
          kind: "scalar",
          T: 9,
        },
        { no: 14, name: "run_tests_message", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new LN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LN, t, e)
    }
  },
  ni
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.WAITING = 1)] = "WAITING"),
    (i[(i.RUNNING = 2)] = "RUNNING"),
    (i[(i.SUCCESS = 3)] = "SUCCESS"),
    (i[(i.FAILURE = 4)] = "FAILURE")
})(ni || (ni = {})),
  n.util.setEnumType(ni, "aiserver.v1.InterfaceAgentStatus.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_WAITING" },
    { no: 2, name: "STATUS_RUNNING" },
    { no: 3, name: "STATUS_SUCCESS" },
    { no: 4, name: "STATUS_FAILURE" },
  ])
var Fc
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.RUNNING = 1)] = "RUNNING"),
    (i[(i.PAUSED = 2)] = "PAUSED"),
    (i[(i.DONE = 3)] = "DONE"),
    (i[(i.NOT_STARTED = 4)] = "NOT_STARTED")
})(Fc || (Fc = {})),
  n.util.setEnumType(Fc, "aiserver.v1.TaskStatus", [
    { no: 0, name: "TASK_STATUS_UNSPECIFIED" },
    { no: 1, name: "TASK_STATUS_RUNNING" },
    { no: 2, name: "TASK_STATUS_PAUSED" },
    { no: 3, name: "TASK_STATUS_DONE" },
    { no: 4, name: "TASK_STATUS_NOT_STARTED" },
  ])
var Gtt = class RN extends d {
    constructor(t) {
      super(), (this.terminalContent = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IsTerminalFinishedRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "terminal_content", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new RN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RN, t, e)
    }
  },
  bNt = class DN extends d {
    constructor(t) {
      super(), (this.isFinished = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IsTerminalFinishedResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "is_finished", kind: "scalar", T: 8 },
        { no: 2, name: "reason", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new DN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DN, t, e)
    }
  },
  ENt = class FN extends d {
    constructor(t) {
      super(), (this.isFinished = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IsTerminalFinishedResponseV2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "is_finished", kind: "scalar", T: 8 },
        {
          no: 2,
          name: "ended_reason",
          kind: "enum",
          T: n.getEnumType(Rc),
          opt: !0,
        },
        { no: 3, name: "exit_code", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new FN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FN, t, e)
    }
  },
  INt = class _N extends d {
    constructor(t) {
      super(), (this.message = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TestBidiRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new _N().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _N().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _N().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_N, t, e)
    }
  },
  PNt = class AN extends d {
    constructor(t) {
      super(), (this.message = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TestBidiResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new AN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AN, t, e)
    }
  },
  NNt = class BN extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.fileContent = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AutoContextFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_content", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new BN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BN, t, e)
    }
  },
  $Nt = class ON extends d {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.candidateFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AutoContextRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "candidate_files",
          kind: "message",
          T: NNt,
          repeated: !0,
        },
        { no: 3, name: "model_details", kind: "message", T: vt },
      ])
    }
    static fromBinary(t, e) {
      return new ON().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ON().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ON().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ON, t, e)
    }
  },
  xNt = class qN extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.rerankingScore = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AutoContextRankedFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "reranking_score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new qN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qN, t, e)
    }
  },
  JNt = class UN extends d {
    constructor(t) {
      super(), (this.rankedFiles = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AutoContextResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ranked_files", kind: "message", T: xNt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new UN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UN, t, e)
    }
  },
  CNt = class MN extends d {
    constructor(t) {
      super(),
        (this.diffCharLen = 0),
        (this.iterations = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckBugBotPriceRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diff_char_len", kind: "scalar", T: 5 },
        { no: 2, name: "iterations", kind: "scalar", T: 5 },
        { no: 3, name: "model_details", kind: "message", T: vt },
        { no: 4, name: "session_id", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new MN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MN, t, e)
    }
  },
  LNt = class HN extends d {
    constructor(t) {
      super(), (this.cost = 0), (this.priceId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckBugBotPriceResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cost", kind: "scalar", T: 1 },
        { no: 2, name: "price_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new HN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HN, t, e)
    }
  },
  RNt = class WN extends d {
    constructor(t) {
      super(), (this.sessionId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckBugBotTelemetryHealthyRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "session_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new WN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WN, t, e)
    }
  },
  DNt = class jN extends d {
    constructor(t) {
      super(), (this.isHealthy = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckBugBotTelemetryHealthyResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "is_healthy", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new jN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jN, t, e)
    }
  },
  FNt = class VN extends d {
    constructor(t) {
      super(), (this.diffCharLen = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSuggestedBugBotIterationsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diff_char_len", kind: "scalar", T: 5 },
        { no: 2, name: "model_details", kind: "message", T: vt },
      ])
    }
    static fromBinary(t, e) {
      return new VN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VN, t, e)
    }
  },
  _Nt = class GN extends d {
    constructor(t) {
      super(), (this.iterations = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSuggestedBugBotIterationsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "iterations", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new GN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GN, t, e)
    }
  },
  ANt = class zN extends d {
    constructor(t) {
      super(),
        (this.status = qm.UNSPECIFIED),
        (this.message = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugBotStatus"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(qm) },
        { no: 2, name: "message", kind: "scalar", T: 9 },
        { no: 3, name: "iterations_completed", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "total_iterations", kind: "scalar", T: 5, opt: !0 },
        { no: 5, name: "total_tokens", kind: "scalar", T: 5, opt: !0 },
        { no: 6, name: "processed_tokens", kind: "scalar", T: 5, opt: !0 },
        { no: 7, name: "processed_cost", kind: "scalar", T: 2, opt: !0 },
        { no: 8, name: "thinking_tokens", kind: "scalar", T: 5, opt: !0 },
        { no: 9, name: "thinking_cost", kind: "scalar", T: 2, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new zN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zN, t, e)
    }
  },
  qm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.IN_PROGRESS = 1)] = "IN_PROGRESS"),
    (i[(i.IN_PROGRESS_ITERATIONS = 2)] = "IN_PROGRESS_ITERATIONS"),
    (i[(i.DONE = 3)] = "DONE")
})(qm || (qm = {})),
  n.util.setEnumType(qm, "aiserver.v1.BugBotStatus.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_IN_PROGRESS" },
    { no: 2, name: "STATUS_IN_PROGRESS_ITERATIONS" },
    { no: 3, name: "STATUS_DONE" },
  ])
var BNt = class YN extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugBotResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_reports", kind: "message", T: RQ, opt: !0 },
        { no: 2, name: "status", kind: "message", T: ANt },
      ])
    }
    static fromBinary(t, e) {
      return new YN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YN, t, e)
    }
  },
  ONt = class QN extends d {
    constructor(t) {
      super(),
        (this.chatConversationHistory = []),
        (this.cppDiffTrajectories = []),
        (this.candidateFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextRerankingRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht, opt: !0 },
        {
          no: 2,
          name: "chat_conversation_history",
          kind: "message",
          T: se,
          repeated: !0,
        },
        {
          no: 3,
          name: "cpp_diff_trajectories",
          kind: "message",
          T: Di,
          repeated: !0,
        },
        {
          no: 4,
          name: "candidate_files",
          kind: "message",
          T: CIt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new QN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QN, t, e)
    }
  },
  qNt = class XN extends d {
    constructor(t) {
      super(), (this.rerankingScores = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextRerankingResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "reranking_scores", kind: "scalar", T: 2, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new XN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XN, t, e)
    }
  },
  UNt = class KN extends d {
    constructor(t) {
      super(), (this.messages = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.NameTabRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "messages", kind: "message", T: se, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new KN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KN, t, e)
    }
  },
  MNt = class ZN extends d {
    constructor(t) {
      super(), (this.name = ""), (this.reason = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.NameTabResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "reason", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ZN().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZN().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZN().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZN, t, e)
    }
  },
  HNt = class t$ extends d {
    constructor(t) {
      super(), (this.modelName = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TestModelStatusRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new t$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new t$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new t$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(t$, t, e)
    }
  },
  WNt = class e$ extends d {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.latency = 0),
        (this.ttft = 0),
        (this.maxTimeBetweenChunks = 0),
        (this.serverTiming = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TestModelStatusResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "latency", kind: "scalar", T: 2 },
        { no: 3, name: "ttft", kind: "scalar", T: 2 },
        { no: 4, name: "max_time_between_chunks", kind: "scalar", T: 2 },
        { no: 5, name: "server_timing", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new e$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new e$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new e$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(e$, t, e)
    }
  },
  jNt = class i$ extends d {
    constructor(t) {
      super(),
        (this.workspaceRelativePath = ""),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TryParseTypeScriptTreeSitterRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "workspace_relative_path", kind: "scalar", T: 9 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new i$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new i$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new i$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(i$, t, e)
    }
  },
  VNt = class r$ extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TryParseTypeScriptTreeSitterResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new r$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new r$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new r$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(r$, t, e)
    }
  },
  GNt = class n$ extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DevOnlyGetPastRequestIdsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "count", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "page", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new n$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new n$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new n$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(n$, t, e)
    }
  },
  zNt = class s$ extends d {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.dateTime = ""),
        (this.modelName = ""),
        (this.featureName = ""),
        (this.s3Uri = ""),
        (this.status = ""),
        (this.numPromptTokens = 0),
        (this.numCompletionTokens = 0),
        (this.apiCallMethod = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DevOnlyPastRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "date_time", kind: "scalar", T: 9 },
        { no: 3, name: "model_name", kind: "scalar", T: 9 },
        { no: 4, name: "feature_name", kind: "scalar", T: 9 },
        { no: 5, name: "s3_uri", kind: "scalar", T: 9 },
        { no: 6, name: "status", kind: "scalar", T: 9 },
        { no: 7, name: "num_prompt_tokens", kind: "scalar", T: 5 },
        { no: 8, name: "num_completion_tokens", kind: "scalar", T: 5 },
        { no: 9, name: "api_call_method", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new s$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new s$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new s$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(s$, t, e)
    }
  },
  YNt = class a$ extends d {
    constructor(t) {
      super(),
        (this.pastRequests = []),
        (this.totalCount = 0),
        (this.hasMore = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DevOnlyGetPastRequestIdsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "past_requests", kind: "message", T: zNt, repeated: !0 },
        { no: 10, name: "total_count", kind: "scalar", T: 5 },
        { no: 11, name: "has_more", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new a$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new a$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new a$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(a$, t, e)
    }
  },
  QNt = class o$ extends d {
    constructor(t) {
      super(), (this.contextToRank = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetRankedContextFromContextBankRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "composer_request", kind: "message", T: Z7 },
        {
          no: 2,
          name: "context_to_rank",
          kind: "message",
          T: btt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new o$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new o$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new o$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(o$, t, e)
    }
  },
  XNt = class c$ extends d {
    constructor(t) {
      super(), (this.rankedContext = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetRankedContextFromContextBankResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ranked_context", kind: "message", T: _U, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new c$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new c$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new c$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(c$, t, e)
    }
  },
  KNt = class u$ extends d {
    constructor(t) {
      super(), (this.questions = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetCodebaseQuestionsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "questions", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new u$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new u$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new u$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(u$, t, e)
    }
  },
  ZNt = class l$ extends d {
    constructor(t) {
      super(),
        (this.index = 0),
        (this.text = ""),
        (this.type = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AtSymbolOption"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "index", kind: "scalar", T: 5 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
        { no: 3, name: "type", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new l$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new l$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new l$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(l$, t, e)
    }
  },
  t$t = class d$ extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.fromFile = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AtSymbolDependencyInformation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "from_file", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new d$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new d$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new d$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(d$, t, e)
    }
  },
  e$t = class m$ extends d {
    constructor(t) {
      super(),
        (this.atSymbolDependencies = []),
        (this.atSymbolOptions = []),
        (this.userQuery = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetAtSymbolSuggestionsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file_info", kind: "message", T: Ht },
        {
          no: 2,
          name: "at_symbol_dependencies",
          kind: "message",
          T: t$t,
          repeated: !0,
        },
        {
          no: 3,
          name: "at_symbol_options",
          kind: "message",
          T: ZNt,
          repeated: !0,
        },
        { no: 4, name: "user_query", kind: "scalar", T: 9 },
        { no: 5, name: "model_details", kind: "message", T: vt },
      ])
    }
    static fromBinary(t, e) {
      return new m$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new m$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new m$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(m$, t, e)
    }
  },
  i$t = class h$ extends d {
    constructor(t) {
      super(),
        (this.indices = []),
        (this.explanation = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetAtSymbolSuggestionsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "indices", kind: "scalar", T: 5, repeated: !0 },
        { no: 2, name: "explanation", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new h$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new h$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new h$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(h$, t, e)
    }
  },
  r$t = class f$ extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.isFolder = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CurrentFolderFileOrFolder"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "is_folder", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new f$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new f$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new f$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(f$, t, e)
    }
  },
  n$t = class p$ extends d {
    constructor(t) {
      super(),
        (this.currentCommand = ""),
        (this.commandHistory = []),
        (this.fileDiffHistories = []),
        (this.commitHistory = []),
        (this.pastResults = []),
        (this.userPlatform = ""),
        (this.currentFolder = ""),
        (this.currentFolderStructure = []),
        (this.relevantFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTerminalCompletionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_command", kind: "scalar", T: 9 },
        { no: 2, name: "command_history", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "model_name", kind: "scalar", T: 9, opt: !0 },
        {
          no: 4,
          name: "file_diff_histories",
          kind: "message",
          T: Di,
          repeated: !0,
        },
        { no: 5, name: "git_diff", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "commit_history", kind: "scalar", T: 9, repeated: !0 },
        { no: 7, name: "past_results", kind: "scalar", T: 9, repeated: !0 },
        { no: 8, name: "model_details", kind: "message", T: vt },
        { no: 9, name: "user_platform", kind: "scalar", T: 9 },
        { no: 10, name: "current_folder", kind: "scalar", T: 9 },
        {
          no: 11,
          name: "current_folder_structure",
          kind: "message",
          T: r$t,
          repeated: !0,
        },
        {
          no: 12,
          name: "relevant_files",
          kind: "message",
          T: nr,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new p$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new p$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new p$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(p$, t, e)
    }
  },
  s$t = class g$ extends d {
    constructor(t) {
      super(), (this.command = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTerminalCompletionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new g$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new g$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new g$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(g$, t, e)
    }
  },
  a$t = class v$ extends d {
    constructor(t) {
      super(),
        (this.type = Um.UNSPECIFIED),
        (this.startLine = 0),
        (this.endLine = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HeuristicsSelection"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "type", kind: "enum", T: n.getEnumType(Um) },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "end_line", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new v$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new v$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new v$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(v$, t, e)
    }
  },
  Um
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.GROUP = 1)] = "GROUP"),
    (i[(i.LINE = 2)] = "LINE"),
    (i[(i.FOLDING = 3)] = "FOLDING")
})(Um || (Um = {})),
  n.util.setEnumType(
    Um,
    "aiserver.v1.HeuristicsSelection.HeuristicsSelectionType",
    [
      { no: 0, name: "HEURISTICS_SELECTION_TYPE_UNSPECIFIED" },
      { no: 1, name: "HEURISTICS_SELECTION_TYPE_GROUP" },
      { no: 2, name: "HEURISTICS_SELECTION_TYPE_LINE" },
      { no: 3, name: "HEURISTICS_SELECTION_TYPE_FOLDING" },
    ],
  )
var o$t = class w$ extends d {
    constructor(t) {
      super(), (this.heuristicsSelections = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CalculateAutoSelectionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file_info", kind: "message", T: Ht },
        { no: 2, name: "cursor_position", kind: "message", T: $s },
        { no: 3, name: "selection_range", kind: "message", T: mi },
        { no: 4, name: "model_details", kind: "message", T: vt },
        {
          no: 5,
          name: "heuristics_selections",
          kind: "message",
          T: a$t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new w$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new w$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new w$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(w$, t, e)
    }
  },
  c$t = class y$ extends d {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.startLine = 0),
        (this.endLine = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AutoSelectionInstructions"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "end_line", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new y$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new y$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new y$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(y$, t, e)
    }
  },
  u$t = class T$ extends d {
    constructor(t) {
      super(),
        (this.startLine = 0),
        (this.endLine = 0),
        (this.instructions = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AutoSelectionResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line", kind: "scalar", T: 5 },
        { no: 2, name: "end_line", kind: "scalar", T: 5 },
        { no: 3, name: "instructions", kind: "message", T: c$t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new T$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new T$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new T$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(T$, t, e)
    }
  },
  l$t = class k$ extends d {
    constructor(t) {
      super(), (this.results = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CalculateAutoSelectionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "results", kind: "message", T: u$t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new k$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new k$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new k$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(k$, t, e)
    }
  },
  d$t = class S$ extends d {
    constructor(t) {
      super(), (this.instruction = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCursorMotionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file_info", kind: "message", T: Ht },
        { no: 2, name: "selection_range", kind: "message", T: mi },
        { no: 3, name: "instruction", kind: "scalar", T: 9 },
        { no: 4, name: "model_details", kind: "message", T: vt },
      ])
    }
    static fromBinary(t, e) {
      return new S$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new S$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new S$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(S$, t, e)
    }
  },
  m$t = class b$ extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCursorMotionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new b$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new b$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new b$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(b$, t, e)
    }
  },
  h$t = class E$ extends d {
    constructor(t) {
      super(),
        (this.instruction = ""),
        (this.type = Mm.UNSPECIFIED),
        (this.proposedChangeHistory = []),
        (this.relatedCodeBlocks = []),
        (this.diffHistory = []),
        (this.linterErrors = []),
        (this.usefulTypes = []),
        (this.recentlyViewedFiles = []),
        (this.recentDiffs = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "instruction", kind: "scalar", T: 9 },
        { no: 2, name: "current_file", kind: "message", T: Ht },
        { no: 3, name: "selection_range", kind: "message", T: mi },
        { no: 4, name: "type", kind: "enum", T: n.getEnumType(Mm) },
        {
          no: 5,
          name: "proposed_change_history",
          kind: "message",
          T: g$t,
          repeated: !0,
        },
        {
          no: 6,
          name: "related_code_blocks",
          kind: "message",
          T: ye,
          repeated: !0,
        },
        { no: 7, name: "diff_history", kind: "message", T: Di, repeated: !0 },
        { no: 8, name: "linter_errors", kind: "message", T: ztt, repeated: !0 },
        { no: 9, name: "useful_types", kind: "message", T: v$t, repeated: !0 },
        {
          no: 10,
          name: "recently_viewed_files",
          kind: "message",
          T: w$t,
          repeated: !0,
        },
        { no: 11, name: "recent_diffs", kind: "message", T: T$t, repeated: !0 },
        { no: 12, name: "multiple_completions", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new E$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new E$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new E$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(E$, t, e)
    }
  },
  Mm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.REFLECT = 1)] = "REFLECT"),
    (i[(i.LOOP_ON_LINTS = 2)] = "LOOP_ON_LINTS"),
    (i[(i.CHAT_AND_APPLY = 3)] = "CHAT_AND_APPLY"),
    (i[(i.COALESCE_GENERATIONS = 4)] = "COALESCE_GENERATIONS"),
    (i[(i.CODEBASE_CHUNKS = 5)] = "CODEBASE_CHUNKS"),
    (i[(i.SPEC_AND_APPLY = 6)] = "SPEC_AND_APPLY"),
    (i[(i.ASK_CODEBASE = 7)] = "ASK_CODEBASE"),
    (i[(i.FINETUNED_INSTRUCTIONS = 8)] = "FINETUNED_INSTRUCTIONS"),
    (i[(i.USEFUL_TYPES = 9)] = "USEFUL_TYPES"),
    (i[(i.CHAT_AND_APPLY_UNDERSPECIFIED = 10)] =
      "CHAT_AND_APPLY_UNDERSPECIFIED")
})(Mm || (Mm = {})),
  n.util.setEnumType(Mm, "aiserver.v1.BackgroundCmdKRequest.Type", [
    { no: 0, name: "TYPE_UNSPECIFIED" },
    { no: 1, name: "TYPE_REFLECT" },
    { no: 2, name: "TYPE_LOOP_ON_LINTS" },
    { no: 3, name: "TYPE_CHAT_AND_APPLY" },
    { no: 4, name: "TYPE_COALESCE_GENERATIONS" },
    { no: 5, name: "TYPE_CODEBASE_CHUNKS" },
    { no: 6, name: "TYPE_SPEC_AND_APPLY" },
    { no: 7, name: "TYPE_ASK_CODEBASE" },
    { no: 8, name: "TYPE_FINETUNED_INSTRUCTIONS" },
    { no: 9, name: "TYPE_USEFUL_TYPES" },
    { no: 10, name: "TYPE_CHAT_AND_APPLY_UNDERSPECIFIED" },
  ])
var ztt = class I$ extends d {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.severity = ""),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumberOneIndexed = 0),
        (this.startColumnOneIndexed = 0),
        (this.endLineNumberInclusiveOneIndexed = 0),
        (this.endColumnOneIndexed = 0),
        (this.quickFixes = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKRequest.Lint"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "severity", kind: "scalar", T: 9 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "start_line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 5, name: "start_column_one_indexed", kind: "scalar", T: 5 },
        {
          no: 6,
          name: "end_line_number_inclusive_one_indexed",
          kind: "scalar",
          T: 5,
        },
        { no: 7, name: "end_column_one_indexed", kind: "scalar", T: 5 },
        { no: 9, name: "quick_fixes", kind: "message", T: f$t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new I$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new I$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new I$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(I$, t, e)
    }
  },
  f$t = class P$ extends d {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.kind = ""),
        (this.isPreferred = !1),
        (this.edits = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKRequest.Lint.QuickFix"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "kind", kind: "scalar", T: 9 },
        { no: 3, name: "is_preferred", kind: "scalar", T: 8 },
        { no: 4, name: "edits", kind: "message", T: p$t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new P$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new P$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new P$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(P$, t, e)
    }
  },
  p$t = class N$ extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.text = ""),
        (this.startLineNumberOneIndexed = 0),
        (this.startColumnOneIndexed = 0),
        (this.endLineNumberInclusiveOneIndexed = 0),
        (this.endColumnOneIndexed = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKRequest.Lint.QuickFix.Edit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
        { no: 3, name: "start_line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 4, name: "start_column_one_indexed", kind: "scalar", T: 5 },
        {
          no: 5,
          name: "end_line_number_inclusive_one_indexed",
          kind: "scalar",
          T: 5,
        },
        { no: 6, name: "end_column_one_indexed", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new N$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new N$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new N$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(N$, t, e)
    }
  },
  g$t = class $$ extends d {
    constructor(t) {
      super(),
        (this.change = ""),
        (this.linterErrors = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKRequest.ProposedChange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "change", kind: "scalar", T: 9 },
        { no: 2, name: "linter_errors", kind: "message", T: ztt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new $$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($$, t, e)
    }
  },
  v$t = class x$ extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLine = 0),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKRequest.UsefulType"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "text", kind: "scalar", T: 9 },
        { no: 4, name: "score", kind: "scalar", T: 1, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new x$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new x$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new x$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(x$, t, e)
    }
  },
  w$t = class J$ extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.visibleRanges = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKRequest.RecentlyViewedFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "visible_ranges",
          kind: "message",
          T: y$t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new J$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new J$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new J$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(J$, t, e)
    }
  },
  y$t = class C$ extends d {
    constructor(t) {
      super(),
        (this.startLineNumberInclusive = 0),
        (this.endLineNumberExclusive = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.BackgroundCmdKRequest.RecentlyViewedFile.VisibleRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number_inclusive", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_number_exclusive", kind: "scalar", T: 5 },
        { no: 3, name: "viewed_at", kind: "scalar", T: 5, opt: !0 },
        {
          no: 4,
          name: "global_order_descending",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new C$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new C$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new C$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(C$, t, e)
    }
  },
  T$t = class L$ extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.diff = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKRequest.Diff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "diff", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new L$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new L$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new L$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(L$, t, e)
    }
  },
  k$t = class R$ extends d {
    constructor(t) {
      super(), (this.proposedChange = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "proposed_change", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new R$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new R$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new R$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(R$, t, e)
    }
  },
  S$t = class D$ extends d {
    constructor(t) {
      super(),
        (this.instruction = ""),
        (this.groundTruth = ""),
        (this.experiment = Hm.UNSPECIFIED),
        (this.runAutomatedEval = !1),
        (this.proposedChangeHistory = []),
        (this.commitNotes = []),
        (this.relatedCodeBlocks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKEvalRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "instruction", kind: "scalar", T: 9 },
        { no: 2, name: "current_file", kind: "message", T: Ht },
        { no: 3, name: "selection_range", kind: "message", T: mi },
        { no: 4, name: "ground_truth", kind: "scalar", T: 9 },
        { no: 5, name: "experiment", kind: "enum", T: n.getEnumType(Hm) },
        { no: 6, name: "run_automated_eval", kind: "scalar", T: 8 },
        {
          no: 7,
          name: "proposed_change_history",
          kind: "message",
          T: P$t,
          repeated: !0,
        },
        { no: 8, name: "commit_notes", kind: "message", T: Mq, repeated: !0 },
        {
          no: 9,
          name: "related_code_blocks",
          kind: "message",
          T: ye,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new D$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new D$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new D$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(D$, t, e)
    }
  },
  Hm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.REFLECT = 1)] = "REFLECT"),
    (i[(i.CMD_K_ORIGINAL_RADIUS = 2)] = "CMD_K_ORIGINAL_RADIUS"),
    (i[(i.LOOP_ON_LINTS = 3)] = "LOOP_ON_LINTS"),
    (i[(i.CHAT_AND_APPLY = 4)] = "CHAT_AND_APPLY"),
    (i[(i.COMMIT_NOTES = 5)] = "COMMIT_NOTES"),
    (i[(i.COALESCE_GENERATIONS = 6)] = "COALESCE_GENERATIONS"),
    (i[(i.REWORD_INSTRUCTIONS = 7)] = "REWORD_INSTRUCTIONS"),
    (i[(i.CODEBASE_CHUNKS = 8)] = "CODEBASE_CHUNKS"),
    (i[(i.SPEC_AND_APPLY = 9)] = "SPEC_AND_APPLY"),
    (i[(i.ASK_CODEBASE = 10)] = "ASK_CODEBASE")
})(Hm || (Hm = {})),
  n.util.setEnumType(Hm, "aiserver.v1.BackgroundCmdKEvalRequest.Experiment", [
    { no: 0, name: "EXPERIMENT_UNSPECIFIED" },
    { no: 1, name: "EXPERIMENT_REFLECT" },
    { no: 2, name: "EXPERIMENT_CMD_K_ORIGINAL_RADIUS" },
    { no: 3, name: "EXPERIMENT_LOOP_ON_LINTS" },
    { no: 4, name: "EXPERIMENT_CHAT_AND_APPLY" },
    { no: 5, name: "EXPERIMENT_COMMIT_NOTES" },
    { no: 6, name: "EXPERIMENT_COALESCE_GENERATIONS" },
    { no: 7, name: "EXPERIMENT_REWORD_INSTRUCTIONS" },
    { no: 8, name: "EXPERIMENT_CODEBASE_CHUNKS" },
    { no: 9, name: "EXPERIMENT_SPEC_AND_APPLY" },
    { no: 10, name: "EXPERIMENT_ASK_CODEBASE" },
  ])
var b$t = class F$ extends d {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.severity = ""),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumberOneIndexed = 0),
        (this.startColumnOneIndexed = 0),
        (this.endLineNumberInclusiveOneIndexed = 0),
        (this.endColumnOneIndexed = 0),
        (this.quickFixes = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKEvalRequest.Lint"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "severity", kind: "scalar", T: 9 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "start_line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 5, name: "start_column_one_indexed", kind: "scalar", T: 5 },
        {
          no: 6,
          name: "end_line_number_inclusive_one_indexed",
          kind: "scalar",
          T: 5,
        },
        { no: 7, name: "end_column_one_indexed", kind: "scalar", T: 5 },
        { no: 9, name: "quick_fixes", kind: "message", T: E$t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new F$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new F$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new F$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(F$, t, e)
    }
  },
  E$t = class _$ extends d {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.kind = ""),
        (this.isPreferred = !1),
        (this.edits = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKEvalRequest.Lint.QuickFix"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "kind", kind: "scalar", T: 9 },
        { no: 3, name: "is_preferred", kind: "scalar", T: 8 },
        { no: 4, name: "edits", kind: "message", T: I$t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new _$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_$, t, e)
    }
  },
  I$t = class A$ extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.text = ""),
        (this.startLineNumberOneIndexed = 0),
        (this.startColumnOneIndexed = 0),
        (this.endLineNumberInclusiveOneIndexed = 0),
        (this.endColumnOneIndexed = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKEvalRequest.Lint.QuickFix.Edit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
        { no: 3, name: "start_line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 4, name: "start_column_one_indexed", kind: "scalar", T: 5 },
        {
          no: 5,
          name: "end_line_number_inclusive_one_indexed",
          kind: "scalar",
          T: 5,
        },
        { no: 6, name: "end_column_one_indexed", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new A$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new A$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new A$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(A$, t, e)
    }
  },
  P$t = class B$ extends d {
    constructor(t) {
      super(),
        (this.change = ""),
        (this.linterErrors = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKEvalRequest.ProposedChange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "change", kind: "scalar", T: 9 },
        { no: 2, name: "linter_errors", kind: "message", T: b$t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new B$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new B$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new B$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(B$, t, e)
    }
  },
  N$t = class O$ extends d {
    constructor(t) {
      super(), (this.proposedChange = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BackgroundCmdKEvalResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "proposed_change", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new O$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new O$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new O$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(O$, t, e)
    }
  },
  $$t = class q$ extends d {
    constructor(t) {
      super(), (this.requestId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetThoughtAnnotationRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new q$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new q$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new q$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(q$, t, e)
    }
  },
  x$t = class U$ extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetThoughtAnnotationResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "thought_annotation", kind: "message", T: J$t },
      ])
    }
    static fromBinary(t, e) {
      return new U$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new U$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new U$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(U$, t, e)
    }
  },
  J$t = class M$ extends d {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.authId = ""),
        (this.thought = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiThoughtAnnotation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "auth_id", kind: "scalar", T: 9 },
        { no: 3, name: "debug_info", kind: "message", T: hr },
        { no: 4, name: "thought", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new M$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new M$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new M$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(M$, t, e)
    }
  },
  C$t = class H$ extends d {
    constructor(t) {
      super(), (this.texts = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BulkEmbedRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "texts", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new H$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new H$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new H$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(H$, t, e)
    }
  },
  L$t = class W$ extends d {
    constructor(t) {
      super(), (this.embeddings = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BulkEmbedResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "embeddings", kind: "message", T: R$t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new W$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new W$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new W$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(W$, t, e)
    }
  },
  R$t = class j$ extends d {
    constructor(t) {
      super(), (this.embedding = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EmbeddingResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "embedding", kind: "scalar", T: 1, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new j$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new j$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new j$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(j$, t, e)
    }
  },
  D$t = class V$ extends d {
    constructor(t) {
      super(), (this.commitHash = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TakeNotesOnCommitDiffRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diff", kind: "message", T: Aft },
        { no: 2, name: "commit_hash", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new V$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new V$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new V$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(V$, t, e)
    }
  },
  F$t = class G$ extends d {
    constructor(t) {
      super(), (this.notes = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TakeNotesOnCommitDiffResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "notes", kind: "message", T: _ft, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new G$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new G$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new G$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(G$, t, e)
    }
  },
  _$t = class z$ extends d {
    constructor(t) {
      super(),
        (this.sessionId = ""),
        (this.commits = []),
        (this.requestId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContinueChatRequestWithCommitsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "session_id", kind: "scalar", T: 9 },
        { no: 2, name: "commits", kind: "message", T: A$t, repeated: !0 },
        { no: 3, name: "request_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new z$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new z$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new z$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(z$, t, e)
    }
  },
  A$t = class Y$ extends d {
    constructor(t) {
      super(),
        (this.commitHash = ""),
        (this.diff = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SimpleCommitWithDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "commit_hash", kind: "scalar", T: 9 },
        { no: 2, name: "diff", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Y$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Y$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Y$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Y$, t, e)
    }
  },
  B$t = class Q$ extends d {
    constructor(t) {
      super(), (this.aiResponse = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBranchFileSelectionsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ai_response", kind: "scalar", T: 9 },
        { no: 2, name: "override_model", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "override_token_limit", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Q$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Q$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Q$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Q$, t, e)
    }
  },
  O$t = class X$ extends d {
    constructor(t) {
      super(), (this.fileInstructions = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBranchFileSelectionsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "file_instructions",
          kind: "message",
          T: q$t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new X$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new X$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new X$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(X$, t, e)
    }
  },
  q$t = class K$ extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.instruction = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamBranchFileSelectionsResponse.FileInstruction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "instruction", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new K$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new K$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new K$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(K$, t, e)
    }
  },
  U$t = class Z$ extends d {
    constructor(t) {
      super(),
        (this.branchName = ""),
        (this.branchNotes = ""),
        (this.globalNotes = ""),
        (this.pastThoughts = []),
        (this.potentiallyRelevantCommits = []),
        (this.files = []),
        (this.contextGraphFiles = []),
        (this.crucialFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBranchGeminiRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "branch_name", kind: "scalar", T: 9 },
        { no: 2, name: "branch_notes", kind: "scalar", T: 9 },
        { no: 3, name: "global_notes", kind: "scalar", T: 9 },
        { no: 4, name: "past_thoughts", kind: "message", T: W$t, repeated: !0 },
        { no: 5, name: "diff_to_base_branch", kind: "message", T: M$t },
        {
          no: 6,
          name: "potentially_relevant_commits",
          kind: "message",
          T: Os,
          repeated: !0,
        },
        { no: 7, name: "files", kind: "message", T: Ytt, repeated: !0 },
        {
          no: 8,
          name: "context_graph_files",
          kind: "message",
          T: j$t,
          repeated: !0,
        },
        {
          no: 12,
          name: "crucial_files",
          kind: "message",
          T: Ytt,
          repeated: !0,
        },
        { no: 9, name: "override_model", kind: "scalar", T: 9, opt: !0 },
        { no: 10, name: "override_token_limit", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Z$().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Z$().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Z$().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Z$, t, e)
    }
  },
  M$t = class tx extends d {
    constructor(t) {
      super(),
        (this.fileDiffs = []),
        (this.commits = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBranchGeminiRequest.BranchDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_diffs", kind: "message", T: H$t, repeated: !0 },
        { no: 2, name: "commits", kind: "message", T: Os, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new tx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tx, t, e)
    }
  },
  H$t = class ex extends d {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.diff = ""),
        (this.tooBig = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamBranchGeminiRequest.BranchDiff.FileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "diff", kind: "scalar", T: 9 },
        { no: 3, name: "too_big", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new ex().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ex().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ex().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ex, t, e)
    }
  },
  W$t = class ix extends d {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.timeInUnixSeconds = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBranchGeminiRequest.PastThought"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "time_in_unix_seconds", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new ix().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ix().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ix().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ix, t, e)
    }
  },
  Ytt = class rx extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBranchGeminiRequest.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new rx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rx, t, e)
    }
  },
  j$t = class nx extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.text = ""),
        (this.priority = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBranchGeminiRequest.FileWithPriority"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
        { no: 3, name: "priority", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new nx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nx, t, e)
    }
  },
  V$t = class sx extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBranchGeminiResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "cached_prompt", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new sx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sx, t, e)
    }
  },
  G$t = class ax extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IsCursorPredictionEnabledRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new ax().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ax().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ax().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ax, t, e)
    }
  },
  z$t = class ox extends d {
    constructor(t) {
      super(), (this.enabled = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IsCursorPredictionEnabledResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "enabled", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new ox().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ox().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ox().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ox, t, e)
    }
  },
  Y$t = class cx extends d {
    constructor(t) {
      super(),
        (this.diffHistory = []),
        (this.contextItems = []),
        (this.diffHistoryKeys = []),
        (this.fileDiffHistories = []),
        (this.mergedDiffHistories = []),
        (this.blockDiffPatches = []),
        (this.parameterHints = []),
        (this.lspContexts = []),
        (this.fileSyncUpdates = []),
        (this.fileVisibleRanges = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamNextCursorPredictionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
        { no: 2, name: "diff_history", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "model_name", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "linter_errors", kind: "message", T: hi, opt: !0 },
        { no: 13, name: "context_items", kind: "message", T: zq, repeated: !0 },
        {
          no: 5,
          name: "diff_history_keys",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 6, name: "give_debug_output", kind: "scalar", T: 8, opt: !0 },
        {
          no: 7,
          name: "file_diff_histories",
          kind: "message",
          T: Di,
          repeated: !0,
        },
        {
          no: 8,
          name: "merged_diff_histories",
          kind: "message",
          T: Di,
          repeated: !0,
        },
        {
          no: 9,
          name: "block_diff_patches",
          kind: "message",
          T: Xq,
          repeated: !0,
        },
        { no: 10, name: "is_nightly", kind: "scalar", T: 8, opt: !0 },
        { no: 11, name: "is_debug", kind: "scalar", T: 8, opt: !0 },
        { no: 12, name: "immediately_ack", kind: "scalar", T: 8, opt: !0 },
        { no: 17, name: "enable_more_context", kind: "scalar", T: 8, opt: !0 },
        {
          no: 14,
          name: "parameter_hints",
          kind: "message",
          T: _Q,
          repeated: !0,
        },
        { no: 15, name: "lsp_contexts", kind: "message", T: Wq, repeated: !0 },
        { no: 16, name: "cpp_intent_info", kind: "message", T: DQ, opt: !0 },
        { no: 18, name: "workspace_id", kind: "scalar", T: 9, opt: !0 },
        {
          no: 19,
          name: "file_sync_updates",
          kind: "message",
          T: Sd,
          repeated: !0,
        },
        {
          no: 20,
          name: "file_visible_ranges",
          kind: "message",
          T: X$t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new cx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cx, t, e)
    }
  },
  Q$t = class ux extends d {
    constructor(t) {
      super(),
        (this.startLineNumberInclusive = 0),
        (this.endLineNumberExclusive = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamNextCursorPredictionRequest.VisibleRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number_inclusive", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_number_exclusive", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new ux().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ux().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ux().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ux, t, e)
    }
  },
  X$t = class lx extends d {
    constructor(t) {
      super(),
        (this.filename = ""),
        (this.visibleRanges = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamNextCursorPredictionRequest.FileVisibleRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "filename", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "visible_ranges",
          kind: "message",
          T: Q$t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new lx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lx, t, e)
    }
  },
  K$t = class dx extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamNextCursorPredictionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9, oneof: "response" },
        { no: 2, name: "line_number", kind: "scalar", T: 5, oneof: "response" },
        {
          no: 3,
          name: "is_not_in_range",
          kind: "scalar",
          T: 8,
          oneof: "response",
        },
        { no: 4, name: "file_name", kind: "scalar", T: 9, oneof: "response" },
      ])
    }
    static fromBinary(t, e) {
      return new dx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dx, t, e)
    }
  },
  Z$t = class mx extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.fileContents = ""),
        (this.prompt = ""),
        (this.images = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamWebCmdKV1Request"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_contents", kind: "scalar", T: 9 },
        { no: 3, name: "prompt", kind: "scalar", T: 9 },
        { no: 4, name: "selection_range", kind: "message", T: vi },
        { no: 5, name: "model_details", kind: "message", T: vt },
        { no: 10, name: "images", kind: "message", T: Ls, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new mx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mx, t, e)
    }
  },
  txt = class hx extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamWebCmdKV1Response"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cmd_k_response", kind: "message", T: WU },
      ])
    }
    static fromBinary(t, e) {
      return new hx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hx, t, e)
    }
  },
  ext = class fx extends d {
    constructor(t) {
      super(),
        (this.sourceRange = ""),
        (this.methodSignatures = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextScoresRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "source_range", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "method_signatures",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new fx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fx, t, e)
    }
  },
  ixt = class px extends d {
    constructor(t) {
      super(), (this.scores = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextScoresResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "scores", kind: "scalar", T: 2, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new px().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new px().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new px().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(px, t, e)
    }
  },
  rxt = class gx extends d {
    constructor(t) {
      super(),
        (this.feedbackType = Wm.UNSPECIFIED),
        (this.requestId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportGenerationFeedbackRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "feedback_type", kind: "enum", T: n.getEnumType(Wm) },
        { no: 2, name: "request_id", kind: "scalar", T: 9 },
        { no: 3, name: "comment", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new gx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gx, t, e)
    }
  },
  Wm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.THUMBS_UP = 1)] = "THUMBS_UP"),
    (i[(i.THUMBS_DOWN = 2)] = "THUMBS_DOWN"),
    (i[(i.NEUTRAL = 3)] = "NEUTRAL")
})(Wm || (Wm = {})),
  n.util.setEnumType(
    Wm,
    "aiserver.v1.ReportGenerationFeedbackRequest.FeedbackType",
    [
      { no: 0, name: "FEEDBACK_TYPE_UNSPECIFIED" },
      { no: 1, name: "FEEDBACK_TYPE_THUMBS_UP" },
      { no: 2, name: "FEEDBACK_TYPE_THUMBS_DOWN" },
      { no: 3, name: "FEEDBACK_TYPE_NEUTRAL" },
    ],
  )
var nxt = class vx extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportGenerationFeedbackResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new vx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vx, t, e)
    }
  },
  sxt = class wx extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ShowWelcomeScreenRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new wx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wx, t, e)
    }
  },
  axt = class yx extends d {
    constructor(t) {
      super(), (this.enableCards = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ShowWelcomeScreenResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "enable_cards", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new yx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yx, t, e)
    }
  },
  oxt = class Tx extends d {
    constructor(t) {
      super(), (this.description = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "description", kind: "scalar", T: 9 },
        { no: 2, name: "model_details", kind: "message", T: vt },
      ])
    }
    static fromBinary(t, e) {
      return new Tx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Tx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Tx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Tx, t, e)
    }
  },
  cxt = class kx extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AiProjectResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new kx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kx, t, e)
    }
  },
  uxt = class Sx extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToCamelCaseRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Sx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Sx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Sx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Sx, t, e)
    }
  },
  lxt = class bx extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ToCamelCaseResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new bx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bx, t, e)
    }
  },
  dxt = class Ex extends d {
    constructor(t) {
      super(),
        (this.promptProps = ""),
        (this.promptPropsTypeName = ""),
        (this.skipLoginCheck = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamPriomptPromptRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "prompt_props", kind: "scalar", T: 9 },
        { no: 3, name: "prompt_props_type_name", kind: "scalar", T: 9 },
        { no: 5, name: "skip_login_check", kind: "scalar", T: 8 },
        { no: 4, name: "model_details", kind: "message", T: vt },
      ])
    }
    static fromBinary(t, e) {
      return new Ex().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ex().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ex().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ex, t, e)
    }
  },
  mxt = class Ix extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamPriomptPromptResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ix().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ix().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ix().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ix, t, e)
    }
  },
  hxt = class Px extends d {
    constructor(t) {
      super(), (this.featureName = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckFeatureStatusRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "feature_name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Px().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Px().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Px().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Px, t, e)
    }
  },
  fxt = class Nx extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetEffectiveTokenLimitRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: vt },
      ])
    }
    static fromBinary(t, e) {
      return new Nx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Nx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Nx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Nx, t, e)
    }
  },
  pxt = class $x extends d {
    constructor(t) {
      super(), (this.tokenLimit = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetEffectiveTokenLimitResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "token_limit", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new $x().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $x().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $x().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($x, t, e)
    }
  },
  gxt = class xx extends d {
    constructor(t) {
      super(), (this.enabled = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckFeatureStatusResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "enabled", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new xx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xx, t, e)
    }
  },
  vxt = class Jx extends d {
    constructor(t) {
      super(), (this.key = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckNumberConfigRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "key", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Jx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Jx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Jx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Jx, t, e)
    }
  },
  wxt = class Cx extends d {
    constructor(t) {
      super(), (this.value = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckNumberConfigResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Cx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Cx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Cx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Cx, t, e)
    }
  },
  yxt = class Lx extends d {
    constructor(t) {
      super(), (this.messages = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IntentPredictionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "messages", kind: "message", T: se, repeated: !0 },
        { no: 2, name: "context_options", kind: "message", T: Ext },
        { no: 3, name: "model_details", kind: "message", T: vt },
      ])
    }
    static fromBinary(t, e) {
      return new Lx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Lx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Lx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Lx, t, e)
    }
  },
  Txt = class Rx extends d {
    constructor(t) {
      super(),
        (this.useGlobalContext = !1),
        (this.useWithFolderContext = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IntentPredictionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chosen_documentation", kind: "message", T: kxt },
        { no: 2, name: "chosen_file_contents", kind: "message", T: Sxt },
        { no: 3, name: "chosen_linter_diagnostics", kind: "message", T: bxt },
        { no: 4, name: "use_global_context", kind: "scalar", T: 8 },
        { no: 5, name: "use_with_folder_context", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Rx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Rx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Rx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Rx, t, e)
    }
  },
  kxt = class Dx extends d {
    constructor(t) {
      super(),
        (this.docIndices = []),
        (this.docIdentifiers = []),
        (this.docNames = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IntentPredictionResponse.ChosenDocumentation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_indices", kind: "scalar", T: 5, repeated: !0 },
        { no: 2, name: "doc_identifiers", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "doc_names", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Dx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Dx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Dx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Dx, t, e)
    }
  },
  Sxt = class Fx extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IntentPredictionResponse.ChosenFileContents"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Fx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Fx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Fx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Fx, t, e)
    }
  },
  bxt = class _x extends d {
    constructor(t) {
      super(), (this.diagnosticIndices = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.IntentPredictionResponse.ChosenLinterDiagnostics"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "diagnostic_indices",
          kind: "scalar",
          T: 5,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new _x().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _x().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _x().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_x, t, e)
    }
  },
  Ext = class Ax extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextOptions"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "all_documentation", kind: "message", T: Ixt },
        { no: 2, name: "current_file_contents", kind: "message", T: Nxt },
        { no: 3, name: "linter_diagnostics", kind: "message", T: $xt },
        { no: 4, name: "global_context", kind: "message", T: Jxt },
      ])
    }
    static fromBinary(t, e) {
      return new Ax().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ax().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ax().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ax, t, e)
    }
  },
  Ixt = class Bx extends d {
    constructor(t) {
      super(), (this.availableDocs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextOptions.AllDocumentation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "available_docs",
          kind: "message",
          T: Pxt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new Bx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Bx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Bx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Bx, t, e)
    }
  },
  Pxt = class Ox extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.url = ""),
        (this.identifier = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ContextOptions.AllDocumentation.Documentation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "url", kind: "scalar", T: 9 },
        { no: 3, name: "identifier", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Ox().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ox().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ox().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ox, t, e)
    }
  },
  Nxt = class qx extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.dataframes = []),
        (this.languageId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextOptions.CurrentFileContents"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        { no: 3, name: "cursor_position", kind: "message", T: $s },
        { no: 4, name: "dataframes", kind: "message", T: $Q, repeated: !0 },
        { no: 5, name: "language_id", kind: "scalar", T: 9 },
        { no: 6, name: "selection", kind: "message", T: xs },
      ])
    }
    static fromBinary(t, e) {
      return new qx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qx, t, e)
    }
  },
  $xt = class Ux extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.diagnostics = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextOptions.LinterDiagnostics"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        { no: 3, name: "diagnostics", kind: "message", T: xxt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Ux().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Ux().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Ux().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Ux, t, e)
    }
  },
  xxt = class Mx extends d {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.source = ""),
        (this.relativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextOptions.LinterDiagnostics.Diagnostic"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "source", kind: "scalar", T: 9 },
        { no: 3, name: "range", kind: "message", T: xs },
        { no: 4, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Mx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Mx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Mx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Mx, t, e)
    }
  },
  Jxt = class Hx extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextOptions.GlobalContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Hx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Hx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Hx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Hx, t, e)
    }
  },
  Cxt = class Wx extends d {
    constructor(t) {
      super(), (this.conversation = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCursorTutorRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 2, name: "model_details", kind: "message", T: vt },
      ])
    }
    static fromBinary(t, e) {
      return new Wx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Wx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Wx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Wx, t, e)
    }
  },
  Lxt = class jx extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamCursorTutorResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new jx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jx, t, e)
    }
  },
  Qtt = class Vx extends d {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.repositories = []),
        (this.codeBlocks = []),
        (this.queryType = jm.UNSPECIFIED),
        (this.fasterAndStupider = !1),
        (this.useGlobs = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelQueryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
        { no: 2, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 3, name: "repositories", kind: "message", T: _t, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Ne },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "code_blocks", kind: "message", T: ye, repeated: !0 },
        { no: 7, name: "model_details", kind: "message", T: vt },
        { no: 8, name: "query_type", kind: "enum", T: n.getEnumType(jm) },
        { no: 9, name: "repository_info", kind: "message", T: _t },
        { no: 10, name: "faster_and_stupider", kind: "scalar", T: 8 },
        { no: 11, name: "use_globs", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Vx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Vx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Vx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Vx, t, e)
    }
  },
  jm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.KEYWORDS = 1)] = "KEYWORDS"),
    (i[(i.EMBEDDINGS = 2)] = "EMBEDDINGS")
})(jm || (jm = {})),
  n.util.setEnumType(jm, "aiserver.v1.ModelQueryRequest.QueryType", [
    { no: 0, name: "QUERY_TYPE_UNSPECIFIED" },
    { no: 1, name: "QUERY_TYPE_KEYWORDS" },
    { no: 2, name: "QUERY_TYPE_EMBEDDINGS" },
  ])
var Rxt = class Gx extends d {
    constructor(t) {
      super(), (this.queries = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelQueryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "queries", kind: "message", T: Dxt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Gx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Gx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Gx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Gx, t, e)
    }
  },
  Dxt = class zx extends d {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.successfulParse = !1),
        (this.goodFileExtensions = []),
        (this.badFileExtensions = []),
        (this.goodPaths = []),
        (this.badPaths = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelQueryResponse.Query"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "successful_parse", kind: "scalar", T: 8 },
        {
          no: 3,
          name: "good_file_extensions",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 4,
          name: "bad_file_extensions",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 5, name: "good_paths", kind: "scalar", T: 9, repeated: !0 },
        { no: 6, name: "bad_paths", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new zx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zx, t, e)
    }
  },
  Fxt = class Yx extends d {
    constructor(t) {
      super(),
        (this.queryOrReasoning = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelQueryResponseV2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "query",
          kind: "message",
          T: _xt,
          oneof: "query_or_reasoning",
        },
        {
          no: 2,
          name: "reasoning",
          kind: "scalar",
          T: 9,
          oneof: "query_or_reasoning",
        },
      ])
    }
    static fromBinary(t, e) {
      return new Yx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Yx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Yx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Yx, t, e)
    }
  },
  _xt = class Qx extends d {
    constructor(t) {
      super(),
        (this.partialQuery = { case: void 0 }),
        (this.index = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelQueryResponseV2.QueryItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9, oneof: "partial_query" },
        { no: 2, name: "glob", kind: "scalar", T: 9, oneof: "partial_query" },
        { no: 3, name: "index", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new Qx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Qx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Qx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Qx, t, e)
    }
  },
  Axt = class Xx extends d {
    constructor(t) {
      super(), (this.apiKey = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ApiDetails"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "api_key", kind: "scalar", T: 9 },
        { no: 2, name: "enable_ghost_mode", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Xx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Xx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Xx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Xx, t, e)
    }
  },
  X7 = class Kx extends d {
    constructor(t) {
      super(), (this.results = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FullFileSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "results", kind: "message", T: DTt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Kx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Kx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Kx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Kx, t, e)
    }
  },
  K7 = class Zx extends d {
    constructor(t) {
      super(),
        (this.results = []),
        (this.allFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodeSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "results", kind: "message", T: fi, repeated: !0 },
        { no: 2, name: "all_files", kind: "message", T: nr, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Zx().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Zx().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Zx().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Zx, t, e)
    }
  },
  Bxt = class t9 extends d {
    constructor(t) {
      super(),
        (this.codeResults = []),
        (this.query = ""),
        (this.numBlocks = 0),
        (this.conversation = []),
        (this.contextResults = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RerankerRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_results", kind: "message", T: fi, repeated: !0 },
        { no: 2, name: "query", kind: "scalar", T: 9 },
        { no: 3, name: "num_blocks", kind: "scalar", T: 5 },
        { no: 4, name: "current_file", kind: "message", T: Ht },
        { no: 5, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 6, name: "api_details", kind: "message", T: Axt },
        {
          no: 7,
          name: "file_search_results",
          kind: "message",
          T: X7,
          oneof: "context_results",
        },
        {
          no: 8,
          name: "code_search_results",
          kind: "message",
          T: K7,
          oneof: "context_results",
        },
      ])
    }
    static fromBinary(t, e) {
      return new t9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new t9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new t9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(t9, t, e)
    }
  },
  Oxt = class e9 extends d {
    constructor(t) {
      super(), (this.results = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RerankerResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "results", kind: "message", T: fi, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new e9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new e9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new e9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(e9, t, e)
    }
  },
  qxt = class i9 extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GenerateTldrRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new i9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new i9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new i9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(i9, t, e)
    }
  },
  Uxt = class r9 extends d {
    constructor(t) {
      super(), (this.summary = ""), (this.all = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GenerateTldrResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "summary", kind: "scalar", T: 9 },
        { no: 2, name: "all", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new r9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new r9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new r9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(r9, t, e)
    }
  },
  Mxt = class n9 extends d {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.repositories = []),
        (this.codeBlocks = []),
        (this.documentationIdentifiers = []),
        (this.requestId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamChatContextRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
        { no: 2, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 3, name: "repositories", kind: "message", T: _t, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Ne },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "code_blocks", kind: "message", T: ye, repeated: !0 },
        { no: 7, name: "model_details", kind: "message", T: vt },
        {
          no: 8,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 14, name: "linter_errors", kind: "message", T: hi },
        { no: 15, name: "advanced_codebase_context", kind: "message", T: Hxt },
        { no: 16, name: "is_eval", kind: "scalar", T: 8, opt: !0 },
        { no: 17, name: "request_id", kind: "scalar", T: 9 },
        { no: 18, name: "desired_token_limit", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new n9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new n9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new n9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(n9, t, e)
    }
  },
  Hxt = class s9 extends d {
    constructor(t) {
      super(),
        (this.numResultsPerSearch = 0),
        (this.reranker = tm.UNSPECIFIED),
        (this.reasoningStep = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AdvancedCodebaseContextOptions"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "num_results_per_search", kind: "scalar", T: 5 },
        { no: 2, name: "include_pattern", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "exclude_pattern", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "reranker", kind: "enum", T: n.getEnumType(tm) },
        { no: 5, name: "index_id", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "reasoning_step", kind: "scalar", T: 8 },
        {
          no: 7,
          name: "rechunker",
          kind: "enum",
          T: n.getEnumType(O7),
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new s9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new s9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new s9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(s9, t, e)
    }
  },
  Wxt = class a9 extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamChatContextResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "output", kind: "message", T: jxt, oneof: "response" },
        {
          no: 2,
          name: "gathering_step",
          kind: "message",
          T: Gxt,
          oneof: "response",
        },
        {
          no: 3,
          name: "gathering_file",
          kind: "message",
          T: Vxt,
          oneof: "response",
        },
        {
          no: 4,
          name: "reranking_step",
          kind: "message",
          T: zxt,
          oneof: "response",
        },
        {
          no: 5,
          name: "reranking_file",
          kind: "message",
          T: Yxt,
          oneof: "response",
        },
        {
          no: 6,
          name: "reasoning_step",
          kind: "message",
          T: Qxt,
          oneof: "response",
        },
        {
          no: 7,
          name: "reasoning_substep",
          kind: "message",
          T: Xxt,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new a9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new a9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new a9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(a9, t, e)
    }
  },
  jxt = class o9 extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamChatContextResponse.Output"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new o9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new o9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new o9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(o9, t, e)
    }
  },
  Vxt = class c9 extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.stepIndex = 0),
        (this.score = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamChatContextResponse.GatheringFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: mi },
        { no: 3, name: "step_index", kind: "scalar", T: 5 },
        { no: 4, name: "score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new c9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new c9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new c9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(c9, t, e)
    }
  },
  Gxt = class u9 extends d {
    constructor(t) {
      super(),
        (this.title = ""),
        (this.index = 0),
        (this.query = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamChatContextResponse.GatheringStep"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "index", kind: "scalar", T: 5 },
        { no: 3, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new u9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new u9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new u9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(u9, t, e)
    }
  },
  zxt = class l9 extends d {
    constructor(t) {
      super(), (this.title = ""), (this.index = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamChatContextResponse.RerankingStep"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "index", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new l9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new l9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new l9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(l9, t, e)
    }
  },
  Yxt = class d9 extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.reason = ""),
        (this.failed = !1),
        (this.score = 0),
        (this.stepIndex = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamChatContextResponse.RerankingFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "range", kind: "message", T: mi },
        { no: 3, name: "reason", kind: "scalar", T: 9 },
        { no: 4, name: "failed", kind: "scalar", T: 8 },
        { no: 5, name: "score", kind: "scalar", T: 2 },
        { no: 6, name: "step_index", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new d9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new d9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new d9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(d9, t, e)
    }
  },
  Qxt = class m9 extends d {
    constructor(t) {
      super(), (this.title = ""), (this.index = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamChatContextResponse.ReasoningStep"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
        { no: 2, name: "index", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new m9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new m9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new m9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(m9, t, e)
    }
  },
  Xxt = class h9 extends d {
    constructor(t) {
      super(),
        (this.markdownExplanation = ""),
        (this.stepIndex = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.TaskStreamChatContextResponse.ReasoningSubstep"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "markdown_explanation", kind: "scalar", T: 9 },
        { no: 2, name: "step_index", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new h9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new h9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new h9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(h9, t, e)
    }
  },
  Kxt = class f9 extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamChatContextResponseWrapped"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "real_response",
          kind: "message",
          T: Wxt,
          oneof: "response",
        },
        {
          no: 2,
          name: "background_task_uuid",
          kind: "scalar",
          T: 9,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new f9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new f9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new f9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(f9, t, e)
    }
  },
  Xtt = class p9 extends d {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.repositories = []),
        (this.codeBlocks = []),
        (this.documentationIdentifiers = []),
        (this.query = ""),
        (this.rerankResults = !1),
        (this.contextResults = { case: void 0 }),
        (this.rerankResultsV2 = !1),
        (this.conversationId = ""),
        (this.canHandleFilenamesAfterLanguageIds = !1),
        (this.longContextMode = !1),
        (this.isEval = !1),
        (this.requestId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatContextRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
        { no: 2, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 3, name: "repositories", kind: "message", T: _t, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Ne },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "code_blocks", kind: "message", T: ye, repeated: !0 },
        { no: 7, name: "model_details", kind: "message", T: vt },
        {
          no: 8,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 9, name: "query", kind: "scalar", T: 9 },
        { no: 10, name: "code_context", kind: "message", T: Zxt },
        { no: 11, name: "rerank_results", kind: "scalar", T: 8 },
        {
          no: 12,
          name: "file_search_results",
          kind: "message",
          T: X7,
          oneof: "context_results",
        },
        {
          no: 13,
          name: "code_search_results",
          kind: "message",
          T: K7,
          oneof: "context_results",
        },
        { no: 14, name: "linter_errors", kind: "message", T: hi },
        { no: 15, name: "is_bash", kind: "scalar", T: 8, opt: !0 },
        { no: 16, name: "rerank_results_v2", kind: "scalar", T: 8 },
        { no: 17, name: "conversation_id", kind: "scalar", T: 9 },
        {
          no: 18,
          name: "can_handle_filenames_after_language_ids",
          kind: "scalar",
          T: 8,
        },
        { no: 19, name: "long_context_mode", kind: "scalar", T: 8 },
        { no: 20, name: "is_eval", kind: "scalar", T: 8 },
        { no: 21, name: "request_id", kind: "scalar", T: 9 },
        { no: 22, name: "desired_max_tokens", kind: "scalar", T: 5, opt: !0 },
        { no: 23, name: "runnable_code_blocks", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new p9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new p9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new p9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(p9, t, e)
    }
  },
  Zxt = class g9 extends d {
    constructor(t) {
      super(),
        (this.chunks = []),
        (this.scoredChunks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatContextRequest.CodeContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunks", kind: "message", T: ye, repeated: !0 },
        { no: 2, name: "scored_chunks", kind: "message", T: fi, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new g9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new g9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new g9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(g9, t, e)
    }
  },
  Ktt = class v9 extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatContextResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "debugging_only_chat_prompt",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        {
          no: 3,
          name: "debugging_only_token_count",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 4, name: "document_citation", kind: "message", T: AU },
        { no: 5, name: "filled_prompt", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "used_code", kind: "message", T: t9t },
        { no: 7, name: "code_link", kind: "message", T: e9t },
        { no: 8, name: "chunk_identity", kind: "message", T: i9t, opt: !0 },
        { no: 9, name: "docs_reference", kind: "message", T: M7, opt: !0 },
        { no: 10, name: "symbol_link", kind: "message", T: qU, opt: !0 },
        { no: 11, name: "file_link", kind: "message", T: UU, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new v9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new v9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new v9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(v9, t, e)
    }
  },
  t9t = class w9 extends d {
    constructor(t) {
      super(), (this.codeResults = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatContextResponse.UsedCode"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "code_results", kind: "message", T: fi, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new w9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new w9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new w9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(w9, t, e)
    }
  },
  e9t = class y9 extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumber = 0),
        (this.endLineNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatContextResponse.CodeLink"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new y9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new y9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new y9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(y9, t, e)
    }
  },
  i9t = class T9 extends d {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.startLine = 0),
        (this.endLine = 0),
        (this.text = ""),
        (this.chunkType = Un.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatContextResponse.ChunkIdentity"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "end_line", kind: "scalar", T: 5 },
        { no: 4, name: "text", kind: "scalar", T: 9 },
        { no: 5, name: "chunk_type", kind: "enum", T: n.getEnumType(Un) },
      ])
    }
    static fromBinary(t, e) {
      return new T9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new T9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new T9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(T9, t, e)
    }
  },
  r9t = class k9 extends d {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.rerankResults = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatDeepContextRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 2, name: "explicit_context", kind: "message", T: Ne },
        { no: 3, name: "model_details", kind: "message", T: vt },
        { no: 4, name: "context_results", kind: "message", T: YTt },
        { no: 5, name: "rerank_results", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new k9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new k9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new k9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(k9, t, e)
    }
  },
  n9t = class S9 extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatDeepContextResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new S9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new S9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new S9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(S9, t, e)
    }
  },
  s9t = class b9 extends d {
    constructor(t) {
      super(), (this.docIdentifier = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DocumentationInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
        { no: 2, name: "metadata", kind: "message", T: ktt },
      ])
    }
    static fromBinary(t, e) {
      return new b9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new b9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new b9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(b9, t, e)
    }
  },
  a9t = class E9 extends d {
    constructor(t) {
      super(),
        (this.partialDoc = { case: void 0 }),
        (this.additionalDocIdentifiers = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AvailableDocsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "partial_url",
          kind: "scalar",
          T: 9,
          oneof: "partial_doc",
        },
        {
          no: 2,
          name: "partial_doc_name",
          kind: "scalar",
          T: 9,
          oneof: "partial_doc",
        },
        { no: 3, name: "get_all", kind: "scalar", T: 8, oneof: "partial_doc" },
        {
          no: 4,
          name: "additional_doc_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new E9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new E9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new E9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(E9, t, e)
    }
  },
  o9t = class I9 extends d {
    constructor(t) {
      super(), (this.docs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AvailableDocsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "docs", kind: "message", T: s9t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new I9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new I9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new I9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(I9, t, e)
    }
  },
  c9t = class P9 extends d {
    constructor(t) {
      super(), (this.error = Cs.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ThrowErrorCheckRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "error", kind: "enum", T: n.getEnumType(Cs) },
      ])
    }
    static fromBinary(t, e) {
      return new P9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new P9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new P9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(P9, t, e)
    }
  },
  u9t = class N9 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ThrowErrorCheckResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new N9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new N9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new N9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(N9, t, e)
    }
  },
  l9t = class $9 extends d {
    constructor(t) {
      super(),
        (this.isNightly = !1),
        (this.includeLongContextModels = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AvailableModelsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "is_nightly", kind: "scalar", T: 8 },
        { no: 2, name: "include_long_context_models", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new $9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($9, t, e)
    }
  },
  d9t = class x9 extends d {
    constructor(t) {
      super(),
        (this.models = []),
        (this.modelNames = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AvailableModelsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "models", kind: "message", T: m9t, repeated: !0 },
        { no: 1, name: "model_names", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new x9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new x9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new x9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(x9, t, e)
    }
  },
  m9t = class J9 extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.defaultOn = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AvailableModelsResponse.AvailableModel"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "default_on", kind: "scalar", T: 8 },
        { no: 3, name: "is_long_context_only", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "is_chat_only", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new J9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new J9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new J9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(J9, t, e)
    }
  },
  Ztt = class C9 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HealthCheckRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new C9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new C9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new C9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(C9, t, e)
    }
  },
  h9t = class L9 extends d {
    constructor(t) {
      super(), (this.status = Vm.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HealthCheckResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(Vm) },
      ])
    }
    static fromBinary(t, e) {
      return new L9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new L9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new L9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(L9, t, e)
    }
  },
  Vm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"), (i[(i.HEALTHY = 1)] = "HEALTHY")
})(Vm || (Vm = {})),
  n.util.setEnumType(Vm, "aiserver.v1.HealthCheckResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_HEALTHY" },
  ])
var f9t = class R9 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PrivacyCheckRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new R9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new R9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new R9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(R9, t, e)
    }
  },
  p9t = class D9 extends d {
    constructor(t) {
      super(),
        (this.isOnPrivacyPod = !1),
        (this.isGhostModeOn = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PrivacyCheckResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "is_on_privacy_pod", kind: "scalar", T: 8 },
        { no: 2, name: "is_ghost_mode_on", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new D9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new D9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new D9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(D9, t, e)
    }
  },
  g9t = class F9 extends d {
    constructor(t) {
      super(), (this.timeLeft = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TimeLeftHealthCheckResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "time_left", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new F9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new F9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new F9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(F9, t, e)
    }
  },
  v9t = class pu extends d {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.repositories = []),
        (this.query = ""),
        (this.codeBlocks = []),
        (this.documentationIdentifiers = []),
        (this.promptCodeBlocks = []),
        (this.sessionId = ""),
        (this.fastMode = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamGenerateRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
        { no: 2, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 3, name: "repositories", kind: "message", T: _t, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Ne },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "query", kind: "scalar", T: 9 },
        { no: 7, name: "code_blocks", kind: "message", T: ye, repeated: !0 },
        { no: 9, name: "model_details", kind: "message", T: vt },
        {
          no: 10,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 11, name: "linter_errors", kind: "message", T: hi },
        {
          no: 12,
          name: "prompt_code_blocks",
          kind: "message",
          T: ye,
          repeated: !0,
        },
        { no: 14, name: "session_id", kind: "scalar", T: 9 },
        { no: 13, name: "cmd_k_debug_info", kind: "message", T: hr },
        { no: 15, name: "fast_mode", kind: "scalar", T: 8 },
        { no: 16, name: "original_request", kind: "message", T: pu },
      ])
    }
    static fromBinary(t, e) {
      return new pu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pu, t, e)
    }
  },
  w9t = class _9 extends d {
    constructor(t) {
      super(),
        (this.chunk = ""),
        (this.fileContext = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunk", kind: "scalar", T: 9 },
        { no: 2, name: "file_context", kind: "scalar", T: 9 },
        { no: 3, name: "chunk_range", kind: "message", T: vi },
        { no: 4, name: "diff_string", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new _9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_9, t, e)
    }
  },
  tet = class A9 extends d {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.type = Gm.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewChatMessage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "type", kind: "enum", T: n.getEnumType(Gm) },
      ])
    }
    static fromBinary(t, e) {
      return new A9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new A9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new A9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(A9, t, e)
    }
  },
  Gm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.HUMAN = 1)] = "HUMAN"),
    (i[(i.AI = 2)] = "AI")
})(Gm || (Gm = {})),
  n.util.setEnumType(
    Gm,
    "aiserver.v1.ReviewChatMessage.ReviewChatMessageType",
    [
      { no: 0, name: "REVIEW_CHAT_MESSAGE_TYPE_UNSPECIFIED" },
      { no: 1, name: "REVIEW_CHAT_MESSAGE_TYPE_HUMAN" },
      { no: 2, name: "REVIEW_CHAT_MESSAGE_TYPE_AI" },
    ],
  )
var y9t = class B9 extends d {
    constructor(t) {
      super(),
        (this.chunk = ""),
        (this.fileContext = ""),
        (this.messages = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewChatRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunk", kind: "scalar", T: 9 },
        { no: 2, name: "file_context", kind: "scalar", T: 9 },
        { no: 3, name: "chunk_range", kind: "message", T: vi },
        { no: 4, name: "messages", kind: "message", T: tet, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new B9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new B9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new B9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(B9, t, e)
    }
  },
  T9t = class O9 extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewChatResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "should_resolve", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new O9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new O9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new O9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(O9, t, e)
    }
  },
  k9t = class q9 extends d {
    constructor(t) {
      super(), (this.id = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewBug"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "end_line", kind: "scalar", T: 5, opt: !0 },
        { no: 4, name: "description", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "severity", kind: "scalar", T: 5, opt: !0 },
        { no: 6, name: "tldr", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new q9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new q9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new q9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(q9, t, e)
    }
  },
  S9t = class U9 extends d {
    constructor(t) {
      super(), (this.text = ""), (this.bugs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "prompt", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "tldr", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "is_bug", kind: "scalar", T: 8, opt: !0 },
        { no: 5, name: "bugs", kind: "message", T: k9t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new U9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new U9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new U9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(U9, t, e)
    }
  },
  b9t = class M9 extends d {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.isCmdI = !1),
        (this.files = []),
        (this.useFastApply = !1),
        (this.fastApplyModelType = zm.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SlashEditRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "current_file", kind: "message", T: Ht },
        { no: 3, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Ne },
        { no: 7, name: "model_details", kind: "message", T: vt },
        { no: 8, name: "is_cmd_i", kind: "scalar", T: 8 },
        { no: 11, name: "summary", kind: "scalar", T: 9, opt: !0 },
        {
          no: 12,
          name: "summary_up_until_index",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 13,
          name: "should_use_turbo_debug_prompt",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 14, name: "edit_selection", kind: "message", T: vi, opt: !0 },
        { no: 15, name: "files", kind: "message", T: Ht, repeated: !0 },
        {
          no: 16,
          name: "clicked_code_block_contents",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        {
          no: 17,
          name: "is_an_optimistic_request_for_caching_and_linting",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 18,
          name: "specific_instructions",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        { no: 19, name: "use_fast_apply", kind: "scalar", T: 8 },
        {
          no: 20,
          name: "fast_apply_model_type",
          kind: "enum",
          T: n.getEnumType(zm),
        },
        {
          no: 25,
          name: "use_chunk_speculation_for_long_files",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 26, name: "parent_request_id", kind: "scalar", T: 9, opt: !0 },
        { no: 27, name: "source", kind: "enum", T: n.getEnumType(Dc), opt: !0 },
        { no: 28, name: "is_reapply", kind: "scalar", T: 8, opt: !0 },
        {
          no: 29,
          name: "willing_to_pay_extra_for_speed",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new M9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new M9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new M9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(M9, t, e)
    }
  },
  zm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.DEFAULT = 1)] = "DEFAULT"),
    (i[(i.DEEPSEEK = 2)] = "DEEPSEEK"),
    (i[(i.SONNET = 3)] = "SONNET"),
    (i[(i.OPUS_DIFF = 4)] = "OPUS_DIFF"),
    (i[(i.SMART_REWRITE = 5)] = "SMART_REWRITE"),
    (i[(i.GPT4 = 6)] = "GPT4"),
    (i[(i.GPT4_NOSPEC = 7)] = "GPT4_NOSPEC"),
    (i[(i.SMART_REWRITE_NOSPEC = 8)] = "SMART_REWRITE_NOSPEC"),
    (i[(i.OPUS = 9)] = "OPUS"),
    (i[(i.HAIKU = 10)] = "HAIKU"),
    (i[(i.GPT4O_NOSPEC = 11)] = "GPT4O_NOSPEC"),
    (i[(i.GPT4O_DIFF = 12)] = "GPT4O_DIFF"),
    (i[(i.CODESTRAL_REWRITE = 13)] = "CODESTRAL_REWRITE"),
    (i[(i.DEEPSEEK_33B = 14)] = "DEEPSEEK_33B"),
    (i[(i.SONNET_35_DIFF = 15)] = "SONNET_35_DIFF"),
    (i[(i.SONNET_35_REWRITE = 16)] = "SONNET_35_REWRITE"),
    (i[(i.PROMPTED_DEEPSEEK_V2 = 17)] = "PROMPTED_DEEPSEEK_V2"),
    (i[(i.CODESTRAL_REWRITE_OLD = 18)] = "CODESTRAL_REWRITE_OLD"),
    (i[(i.CODESTRAL_REWRITE_FP16 = 19)] = "CODESTRAL_REWRITE_FP16"),
    (i[(i.DEEPSEEK_33B_V2 = 20)] = "DEEPSEEK_33B_V2"),
    (i[(i.CODESTRAL_V4 = 21)] = "CODESTRAL_V4"),
    (i[(i.CODESTRAL_V5 = 22)] = "CODESTRAL_V5"),
    (i[(i.CODESTRAL_V6 = 23)] = "CODESTRAL_V6"),
    (i[(i.CODESTRAL_V7 = 24)] = "CODESTRAL_V7")
})(zm || (zm = {})),
  n.util.setEnumType(zm, "aiserver.v1.SlashEditRequest.FastApplyModelType", [
    { no: 0, name: "FAST_APPLY_MODEL_TYPE_UNSPECIFIED" },
    { no: 1, name: "FAST_APPLY_MODEL_TYPE_DEFAULT" },
    { no: 2, name: "FAST_APPLY_MODEL_TYPE_DEEPSEEK" },
    { no: 3, name: "FAST_APPLY_MODEL_TYPE_SONNET" },
    { no: 4, name: "FAST_APPLY_MODEL_TYPE_OPUS_DIFF" },
    { no: 5, name: "FAST_APPLY_MODEL_TYPE_SMART_REWRITE" },
    { no: 6, name: "FAST_APPLY_MODEL_TYPE_GPT4" },
    { no: 7, name: "FAST_APPLY_MODEL_TYPE_GPT4_NOSPEC" },
    { no: 8, name: "FAST_APPLY_MODEL_TYPE_SMART_REWRITE_NOSPEC" },
    { no: 9, name: "FAST_APPLY_MODEL_TYPE_OPUS" },
    { no: 10, name: "FAST_APPLY_MODEL_TYPE_HAIKU" },
    { no: 11, name: "FAST_APPLY_MODEL_TYPE_GPT4O_NOSPEC" },
    { no: 12, name: "FAST_APPLY_MODEL_TYPE_GPT4O_DIFF" },
    { no: 13, name: "FAST_APPLY_MODEL_TYPE_CODESTRAL_REWRITE" },
    { no: 14, name: "FAST_APPLY_MODEL_TYPE_DEEPSEEK_33B" },
    { no: 15, name: "FAST_APPLY_MODEL_TYPE_SONNET_35_DIFF" },
    { no: 16, name: "FAST_APPLY_MODEL_TYPE_SONNET_35_REWRITE" },
    { no: 17, name: "FAST_APPLY_MODEL_TYPE_PROMPTED_DEEPSEEK_V2" },
    { no: 18, name: "FAST_APPLY_MODEL_TYPE_CODESTRAL_REWRITE_OLD" },
    { no: 19, name: "FAST_APPLY_MODEL_TYPE_CODESTRAL_REWRITE_FP16" },
    { no: 20, name: "FAST_APPLY_MODEL_TYPE_DEEPSEEK_33B_V2" },
    { no: 21, name: "FAST_APPLY_MODEL_TYPE_CODESTRAL_V4" },
    { no: 22, name: "FAST_APPLY_MODEL_TYPE_CODESTRAL_V5" },
    { no: 23, name: "FAST_APPLY_MODEL_TYPE_CODESTRAL_V6" },
    { no: 24, name: "FAST_APPLY_MODEL_TYPE_CODESTRAL_V7" },
  ])
var E9t = class H9 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SlashEditResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cmd_k_response", kind: "message", T: WU },
      ])
    }
    static fromBinary(t, e) {
      return new H9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new H9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new H9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(H9, t, e)
    }
  },
  eet = class W9 extends d {
    constructor(t) {
      super(),
        (this.originalLines = []),
        (this.newLines = []),
        (this.relativeWorkspacePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SlashEditPreviousEdit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "original_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "new_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "range", kind: "message", T: vi },
      ])
    }
    static fromBinary(t, e) {
      return new W9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new W9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new W9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(W9, t, e)
    }
  },
  I9t = class j9 extends d {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.previousEdits = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SlashEditFollowUpWithPreviousEditsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 2, name: "model_details", kind: "message", T: vt },
        {
          no: 3,
          name: "previous_edits",
          kind: "message",
          T: eet,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new j9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new j9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new j9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(j9, t, e)
    }
  },
  P9t = class V9 extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamSlashEditFollowUpWithPreviousEditsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chat", kind: "message", T: N9t, oneof: "response" },
        {
          no: 2,
          name: "edits_to_update",
          kind: "message",
          T: $9t,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new V9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new V9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new V9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(V9, t, e)
    }
  },
  N9t = class G9 extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamSlashEditFollowUpWithPreviousEditsResponse.Chat"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new G9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new G9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new G9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(G9, t, e)
    }
  },
  $9t = class z9 extends d {
    constructor(t) {
      super(), (this.previousEdits = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamSlashEditFollowUpWithPreviousEditsResponse.EditsToUpdate"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "previous_edits",
          kind: "message",
          T: eet,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new z9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new z9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new z9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(z9, t, e)
    }
  },
  x9t = class Y9 extends d {
    constructor(t) {
      super(),
        (this.repositories = []),
        (this.query = ""),
        (this.codeBlocks = []),
        (this.documentationIdentifiers = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamFastEditRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
        { no: 3, name: "repositories", kind: "message", T: _t, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Ne },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "query", kind: "scalar", T: 9 },
        { no: 7, name: "code_blocks", kind: "message", T: ye, repeated: !0 },
        { no: 9, name: "model_details", kind: "message", T: vt },
        {
          no: 10,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 11, name: "linter_errors", kind: "message", T: hi },
      ])
    }
    static fromBinary(t, e) {
      return new Y9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Y9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Y9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Y9, t, e)
    }
  },
  J9t = class Q9 extends d {
    constructor(t) {
      super(),
        (this.lineNumber = 0),
        (this.replaceNumLines = 0),
        (this.editUuid = ""),
        (this.resetNewLines = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamFastEditResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
        { no: 3, name: "replace_num_lines", kind: "scalar", T: 5 },
        { no: 5, name: "edit_uuid", kind: "scalar", T: 9 },
        { no: 4, name: "done", kind: "scalar", T: 8, opt: !0 },
        { no: 6, name: "new_line", kind: "scalar", T: 9, opt: !0 },
        { no: 7, name: "reset_new_lines", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Q9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Q9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Q9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Q9, t, e)
    }
  },
  iet = class gu extends d {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.repositories = []),
        (this.query = ""),
        (this.codeBlocks = []),
        (this.documentationIdentifiers = []),
        (this.promptCodeBlocks = []),
        (this.sessionId = ""),
        (this.fastMode = !1),
        (this.images = []),
        (this.links = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamEditRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
        { no: 2, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 3, name: "repositories", kind: "message", T: _t, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Ne },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "query", kind: "scalar", T: 9 },
        { no: 7, name: "code_blocks", kind: "message", T: ye, repeated: !0 },
        { no: 9, name: "model_details", kind: "message", T: vt },
        {
          no: 10,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 11, name: "linter_errors", kind: "message", T: hi },
        {
          no: 12,
          name: "prompt_code_blocks",
          kind: "message",
          T: ye,
          repeated: !0,
        },
        { no: 14, name: "session_id", kind: "scalar", T: 9 },
        { no: 13, name: "cmd_k_debug_info", kind: "message", T: hr },
        { no: 15, name: "fast_mode", kind: "scalar", T: 8 },
        { no: 16, name: "original_request", kind: "message", T: gu },
        { no: 17, name: "images", kind: "message", T: Ls, repeated: !0 },
        { no: 18, name: "links", kind: "message", T: Uq, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new gu().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gu().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gu().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gu, t, e)
    }
  },
  C9t = class X9 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PreloadEditRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "req", kind: "message", T: iet },
      ])
    }
    static fromBinary(t, e) {
      return new X9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new X9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new X9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(X9, t, e)
    }
  },
  L9t = class K9 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PreloadEditResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new K9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new K9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new K9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(K9, t, e)
    }
  },
  R9t = class Z9 extends d {
    constructor(t) {
      super(),
        (this.chunksToAnalyze = []),
        (this.dismissedBugs = []),
        (this.activeBugs = []),
        (this.lintRules = []),
        (this.clients = []),
        (this.forceEnableDiscriminators = []),
        (this.forceDisableDiscriminators = []),
        (this.forceEnableGenerators = []),
        (this.forceDisableGenerators = []),
        (this.version = 0),
        (this.debugMode = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiLintBugRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "chunks_to_analyze",
          kind: "message",
          T: ret,
          repeated: !0,
        },
        { no: 4, name: "explicit_context", kind: "message", T: Ne },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 9, name: "model_details", kind: "message", T: vt },
        {
          no: 10,
          name: "dismissed_bugs",
          kind: "message",
          T: Q7,
          repeated: !0,
        },
        { no: 11, name: "active_bugs", kind: "message", T: Q7, repeated: !0 },
        { no: 12, name: "lint_rules", kind: "message", T: sNt, repeated: !0 },
        { no: 14, name: "clients", kind: "message", T: D9t, repeated: !0 },
        {
          no: 17,
          name: "force_enable_discriminators",
          kind: "enum",
          T: n.getEnumType(Wa),
          repeated: !0,
        },
        {
          no: 18,
          name: "force_disable_discriminators",
          kind: "enum",
          T: n.getEnumType(Wa),
          repeated: !0,
        },
        {
          no: 19,
          name: "force_enable_generators",
          kind: "enum",
          T: n.getEnumType(ja),
          repeated: !0,
        },
        {
          no: 20,
          name: "force_disable_generators",
          kind: "enum",
          T: n.getEnumType(ja),
          repeated: !0,
        },
        { no: 21, name: "version", kind: "scalar", T: 5 },
        {
          no: 15,
          name: "discriminator_options",
          kind: "message",
          T: F9t,
          opt: !0,
        },
        { no: 16, name: "debug_mode", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Z9().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Z9().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Z9().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Z9, t, e)
    }
  },
  ret = class tJ extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumber = 0),
        (this.lines = []),
        (this.contextLinesBefore = []),
        (this.contextLinesAfter = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiLintBugRequest.CodeChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "lines", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 4,
          name: "context_lines_before",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 5,
          name: "context_lines_after",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new tJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tJ, t, e)
    }
  },
  D9t = class eJ extends d {
    constructor(t) {
      super(),
        (this.chunks = []),
        (this.referredStartLines = []),
        (this.referredEndLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiLintBugRequest.CodeChunkList"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 13, name: "chunks", kind: "message", T: ret, repeated: !0 },
        {
          no: 14,
          name: "referred_start_lines",
          kind: "scalar",
          T: 5,
          repeated: !0,
        },
        {
          no: 15,
          name: "referred_end_lines",
          kind: "scalar",
          T: 5,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new eJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eJ, t, e)
    }
  },
  F9t = class iJ extends d {
    constructor(t) {
      super(),
        (this.specificRules = !1),
        (this.compileErrors = !1),
        (this.changeBehavior = !1),
        (this.matchCode = !1),
        (this.relevance = !1),
        (this.userAwareness = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiLintBugRequest.DiscriminatorOptions"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "specific_rules", kind: "scalar", T: 8 },
        { no: 2, name: "compile_errors", kind: "scalar", T: 8 },
        { no: 3, name: "change_behavior", kind: "scalar", T: 8 },
        { no: 4, name: "match_code", kind: "scalar", T: 8 },
        { no: 5, name: "relevance", kind: "scalar", T: 8 },
        { no: 6, name: "user_awareness", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new iJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iJ, t, e)
    }
  },
  _9t = class rJ extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiLintBugResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug", kind: "message", T: Q7, oneof: "response" },
        {
          no: 2,
          name: "background_task_uuid",
          kind: "scalar",
          T: 9,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new rJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rJ, t, e)
    }
  },
  A9t = class nJ extends d {
    constructor(t) {
      super(),
        (this.uuid = ""),
        (this.userAction = ""),
        (this.debugMode = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogUserLintReplyRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "user_action", kind: "scalar", T: 9 },
        { no: 3, name: "debug_mode", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new nJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nJ, t, e)
    }
  },
  B9t = class sJ extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogUserLintReplyResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new sJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sJ, t, e)
    }
  },
  O9t = class aJ extends d {
    constructor(t) {
      super(),
        (this.userFeedback = Ym.UNSPECIFIED),
        (this.userFeedbackDetails = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogLinterExplicitUserFeedbackRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug", kind: "message", T: Q7 },
        { no: 3, name: "user_feedback", kind: "enum", T: n.getEnumType(Ym) },
        { no: 4, name: "user_feedback_details", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new aJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aJ, t, e)
    }
  },
  Ym
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.CORRECT = 1)] = "CORRECT"),
    (i[(i.INCORRECT = 2)] = "INCORRECT"),
    (i[(i.OTHER = 3)] = "OTHER")
})(Ym || (Ym = {})),
  n.util.setEnumType(
    Ym,
    "aiserver.v1.LogLinterExplicitUserFeedbackRequest.LinterUserFeedback",
    [
      { no: 0, name: "LINTER_USER_FEEDBACK_UNSPECIFIED" },
      { no: 1, name: "LINTER_USER_FEEDBACK_CORRECT" },
      { no: 2, name: "LINTER_USER_FEEDBACK_INCORRECT" },
      { no: 3, name: "LINTER_USER_FEEDBACK_OTHER" },
    ],
  )
var q9t = class oJ extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogLinterExplicitUserFeedbackResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new oJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oJ, t, e)
    }
  },
  U9t = class cJ extends d {
    constructor(t) {
      super(),
        (this.currentRules = ""),
        (this.dismissedBug = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamNewRuleRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_rules", kind: "scalar", T: 9 },
        { no: 2, name: "dismissed_bug", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new cJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cJ, t, e)
    }
  },
  M9t = class uJ extends d {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.repositories = []),
        (this.query = ""),
        (this.codeBlocks = []),
        (this.sessionId = ""),
        (this.documentationIdentifiers = []),
        (this.promptCodeBlocks = []),
        (this.fastMode = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamGPTFourEditRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
        { no: 2, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 3, name: "repositories", kind: "message", T: _t, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Ne },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "query", kind: "scalar", T: 9 },
        { no: 7, name: "code_blocks", kind: "message", T: ye, repeated: !0 },
        { no: 14, name: "session_id", kind: "scalar", T: 9 },
        { no: 9, name: "model_details", kind: "message", T: vt },
        {
          no: 10,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 11, name: "linter_errors", kind: "message", T: hi },
        {
          no: 12,
          name: "prompt_code_blocks",
          kind: "message",
          T: ye,
          repeated: !0,
        },
        { no: 13, name: "fast_mode", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new uJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uJ, t, e)
    }
  },
  H9t = class lJ extends d {
    constructor(t) {
      super(),
        (this.id = ""),
        (this.role = ""),
        (this.content = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CursorHelpConversationMessage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 9 },
        { no: 2, name: "role", kind: "scalar", T: 9 },
        { no: 3, name: "content", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new lJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lJ, t, e)
    }
  },
  W9t = class dJ extends d {
    constructor(t) {
      super(),
        (this.messages = []),
        (this.userOs = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiCursorHelpRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "messages", kind: "message", T: H9t, repeated: !0 },
        { no: 2, name: "user_os", kind: "scalar", T: 9 },
        { no: 3, name: "model_details", kind: "message", T: vt },
      ])
    }
    static fromBinary(t, e) {
      return new dJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dJ, t, e)
    }
  },
  j9t = class mJ extends d {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.actions = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiCursorHelpResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "actions", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new mJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mJ, t, e)
    }
  },
  V9t = class hJ extends d {
    constructor(t) {
      super(),
        (this.currentCommand = ""),
        (this.commandHistory = []),
        (this.fileDiffHistories = []),
        (this.commitHistory = []),
        (this.pastResults = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamTerminalAutocompleteRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_command", kind: "scalar", T: 9 },
        { no: 2, name: "command_history", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "model_name", kind: "scalar", T: 9, opt: !0 },
        {
          no: 4,
          name: "file_diff_histories",
          kind: "message",
          T: Di,
          repeated: !0,
        },
        { no: 5, name: "git_diff", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "commit_history", kind: "scalar", T: 9, repeated: !0 },
        { no: 7, name: "past_results", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new hJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hJ, t, e)
    }
  },
  net = class fJ extends d {
    constructor(t) {
      super(), (this.content = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PseudocodeTarget"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "range", kind: "message", T: mi },
        { no: 2, name: "content", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new fJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fJ, t, e)
    }
  },
  G9t = class pJ extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamPseudocodeGeneratorRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
        { no: 2, name: "target", kind: "message", T: net },
      ])
    }
    static fromBinary(t, e) {
      return new pJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pJ, t, e)
    }
  },
  z9t = class gJ extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamPseudocodeGeneratorResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new gJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gJ, t, e)
    }
  },
  Y9t = class vJ extends d {
    constructor(t) {
      super(), (this.pseudocode = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamPseudocodeMapperRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "target", kind: "message", T: net },
        { no: 1, name: "pseudocode", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new vJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vJ, t, e)
    }
  },
  Q9t = class wJ extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamPseudocodeMapperResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new wJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wJ, t, e)
    }
  },
  X9t = class yJ extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamTerminalAutocompleteResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "done_stream", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new yJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yJ, t, e)
    }
  },
  K9t = class TJ extends d {
    constructor(t) {
      super(),
        (this.repositories = []),
        (this.gitDiff = ""),
        (this.conversation = []),
        (this.query = ""),
        (this.stop = ""),
        (this.importLineInDiff = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBackgroundEditRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
        { no: 2, name: "repositories", kind: "message", T: _t, repeated: !0 },
        { no: 3, name: "explicit_context", kind: "message", T: Ne },
        { no: 4, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "git_diff", kind: "scalar", T: 9 },
        { no: 6, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 7, name: "query", kind: "scalar", T: 9 },
        { no: 8, name: "model_details", kind: "message", T: vt },
        { no: 9, name: "stop", kind: "scalar", T: 9 },
        { no: 10, name: "import_line_in_diff", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new TJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TJ, t, e)
    }
  },
  Z9t = class kJ extends d {
    constructor(t) {
      super(),
        (this.callStack = []),
        (this.history = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DebugInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "breakpoint", kind: "message", T: rJt },
        { no: 2, name: "call_stack", kind: "message", T: iJt, repeated: !0 },
        { no: 3, name: "history", kind: "message", T: ye, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new kJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kJ, t, e)
    }
  },
  tJt = class SJ extends d {
    constructor(t) {
      super(), (this.name = ""), (this.value = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DebugInfo.Variable"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "value", kind: "scalar", T: 9 },
        { no: 3, name: "type", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new SJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SJ, t, e)
    }
  },
  eJt = class bJ extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.variables = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DebugInfo.Scope"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "variables", kind: "message", T: tJt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new bJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bJ, t, e)
    }
  },
  iJt = class EJ extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.lineNumber = 0),
        (this.functionName = ""),
        (this.scopes = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DebugInfo.CallStackFrame"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
        { no: 3, name: "function_name", kind: "scalar", T: 9 },
        { no: 4, name: "scopes", kind: "message", T: eJt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new EJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new EJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new EJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(EJ, t, e)
    }
  },
  rJt = class IJ extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.lineNumber = 0),
        (this.linesBeforeBreakpoint = []),
        (this.linesAfterBreakpoint = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DebugInfo.Breakpoint"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
        {
          no: 3,
          name: "lines_before_breakpoint",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 4,
          name: "lines_after_breakpoint",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 5, name: "exception_info", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new IJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IJ, t, e)
    }
  },
  qs = class PJ extends d {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.repositories = []),
        (this.codeBlocks = []),
        (this.documentationIdentifiers = []),
        (this.requestId = ""),
        (this.conversationId = ""),
        (this.quotes = []),
        (this.externalLinks = []),
        (this.commitNotes = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetChatRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
        { no: 2, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 3, name: "repositories", kind: "message", T: _t, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Ne },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "code_blocks", kind: "message", T: ye, repeated: !0 },
        { no: 7, name: "model_details", kind: "message", T: vt },
        {
          no: 8,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 9, name: "request_id", kind: "scalar", T: 9 },
        { no: 10, name: "linter_errors", kind: "message", T: hi },
        { no: 11, name: "summary", kind: "scalar", T: 9, opt: !0 },
        {
          no: 12,
          name: "summary_up_until_index",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 13, name: "allow_long_file_scan", kind: "scalar", T: 8, opt: !0 },
        { no: 14, name: "is_bash", kind: "scalar", T: 8, opt: !0 },
        { no: 15, name: "conversation_id", kind: "scalar", T: 9 },
        {
          no: 16,
          name: "can_handle_filenames_after_language_ids",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 17, name: "use_web", kind: "scalar", T: 9, opt: !0 },
        { no: 18, name: "quotes", kind: "message", T: n7, repeated: !0 },
        { no: 19, name: "debug_info", kind: "message", T: Z9t, opt: !0 },
        { no: 20, name: "workspace_id", kind: "scalar", T: 9, opt: !0 },
        {
          no: 21,
          name: "external_links",
          kind: "message",
          T: Fft,
          repeated: !0,
        },
        { no: 23, name: "commit_notes", kind: "message", T: Mq, repeated: !0 },
        { no: 22, name: "long_context_mode", kind: "scalar", T: 8, opt: !0 },
        { no: 24, name: "is_eval", kind: "scalar", T: 8, opt: !0 },
        { no: 26, name: "desired_max_tokens", kind: "scalar", T: 5, opt: !0 },
        { no: 25, name: "context_ast", kind: "message", T: Mtt },
        { no: 27, name: "is_composer", kind: "scalar", T: 8, opt: !0 },
        { no: 28, name: "runnable_code_blocks", kind: "scalar", T: 8, opt: !0 },
        { no: 29, name: "should_cache", kind: "scalar", T: 8, opt: !0 },
        {
          no: 30,
          name: "allow_model_fallbacks",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 31,
          name: "number_of_times_shown_fallback_model_warning",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new PJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PJ, t, e)
    }
  },
  nJt = class NJ extends d {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.documentationIdentifiers = []),
        (this.externalLinks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetNotepadChatRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 2, name: "allow_long_file_scan", kind: "scalar", T: 8, opt: !0 },
        { no: 3, name: "explicit_context", kind: "message", T: Ne },
        {
          no: 4,
          name: "can_handle_filenames_after_language_ids",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 5, name: "model_details", kind: "message", T: vt },
        { no: 6, name: "linter_errors", kind: "message", T: hi },
        {
          no: 7,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 8, name: "use_web", kind: "scalar", T: 9, opt: !0 },
        { no: 9, name: "external_links", kind: "message", T: qq, repeated: !0 },
        { no: 10, name: "project_context", kind: "message", T: se, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new NJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NJ, t, e)
    }
  },
  sJt = class $J extends d {
    constructor(t) {
      super(), (this.query = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PotentialLocsInitialQueriesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $J().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $J().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $J().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($J, t, e)
    }
  },
  aJt = class xJ extends d {
    constructor(t) {
      super(), (this.hydeQuery = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PotentialLocsInitialQueriesResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "hyde_query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new xJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xJ, t, e)
    }
  },
  oJt = class JJ extends d {
    constructor(t) {
      super(),
        (this.file = ""),
        (this.ranges = []),
        (this.query = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PotentialLocsUnderneathRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "scalar", T: 9 },
        { no: 2, name: "ranges", kind: "message", T: rr, repeated: !0 },
        { no: 3, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new JJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JJ, t, e)
    }
  },
  cJt = class CJ extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PotentialLocsUnderneathResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new CJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CJ, t, e)
    }
  },
  uJt = class LJ extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PotentialLocsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new LJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LJ, t, e)
    }
  },
  lJt = class RJ extends d {
    constructor(t) {
      super(), (this.potentialLoc = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PotentialLocsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "potential_loc", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new RJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RJ, t, e)
    }
  },
  Z7 = class DJ extends d {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.documentationIdentifiers = []),
        (this.externalLinks = []),
        (this.diffsForCompressingFiles = []),
        (this.multiFileLinterErrors = []),
        (this.fileDiffHistories = []),
        (this.additionalRankedContext = []),
        (this.quotes = []),
        (this.conversationId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetComposerChatRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 2, name: "allow_long_file_scan", kind: "scalar", T: 8, opt: !0 },
        { no: 3, name: "explicit_context", kind: "message", T: Ne },
        {
          no: 4,
          name: "can_handle_filenames_after_language_ids",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 5, name: "model_details", kind: "message", T: vt },
        { no: 6, name: "linter_errors", kind: "message", T: hi },
        {
          no: 7,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 8, name: "use_web", kind: "scalar", T: 9, opt: !0 },
        { no: 9, name: "external_links", kind: "message", T: qq, repeated: !0 },
        { no: 10, name: "project_context", kind: "message", T: se, opt: !0 },
        {
          no: 11,
          name: "diffs_for_compressing_files",
          kind: "message",
          T: dJt,
          repeated: !0,
        },
        { no: 12, name: "compress_edits", kind: "scalar", T: 8, opt: !0 },
        { no: 13, name: "should_cache", kind: "scalar", T: 8, opt: !0 },
        {
          no: 14,
          name: "multi_file_linter_errors",
          kind: "message",
          T: hi,
          repeated: !0,
        },
        { no: 15, name: "current_file", kind: "message", T: Ht },
        { no: 16, name: "recent_edits", kind: "message", T: mJt, opt: !0 },
        {
          no: 17,
          name: "use_reference_composer_diff_prompt",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 18,
          name: "file_diff_histories",
          kind: "message",
          T: BU,
          repeated: !0,
        },
        {
          no: 19,
          name: "use_new_compression_scheme",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 20,
          name: "additional_ranked_context",
          kind: "message",
          T: _U,
          repeated: !0,
        },
        { no: 21, name: "quotes", kind: "message", T: n7, repeated: !0 },
        {
          no: 22,
          name: "willing_to_pay_extra_for_speed",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 23, name: "conversation_id", kind: "scalar", T: 9 },
        {
          no: 24,
          name: "use_unified_chat_prompt",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 25,
          name: "use_full_inputs_context",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 26, name: "is_resume", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new DJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DJ, t, e)
    }
  },
  dJt = class FJ extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.redRanges = []),
        (this.redRangesReversed = []),
        (this.startHash = ""),
        (this.endHash = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetComposerChatRequest.RedDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "red_ranges", kind: "message", T: rr, repeated: !0 },
        {
          no: 3,
          name: "red_ranges_reversed",
          kind: "message",
          T: rr,
          repeated: !0,
        },
        { no: 4, name: "start_hash", kind: "scalar", T: 9 },
        { no: 5, name: "end_hash", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new FJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FJ, t, e)
    }
  },
  mJt = class _J extends d {
    constructor(t) {
      super(),
        (this.codeBlockInfo = []),
        (this.finalFileValues = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetComposerChatRequest.RecentEdits"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "code_block_info",
          kind: "message",
          T: hJt,
          repeated: !0,
        },
        {
          no: 2,
          name: "final_file_values",
          kind: "message",
          T: fJt,
          repeated: !0,
        },
        {
          no: 3,
          name: "edits_belong_to_composer_generation_uuid",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new _J().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _J().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _J().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_J, t, e)
    }
  },
  hJt = class AJ extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.GetComposerChatRequest.RecentEdits.CodeBlockInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "content_before", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "content_after", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "generation_uuid", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "version", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new AJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AJ, t, e)
    }
  },
  fJt = class BJ extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.content = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetComposerChatRequest.RecentEdits.FileInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "content", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new BJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BJ, t, e)
    }
  },
  rUt = class OJ extends d {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.repositories = []),
        (this.codeBlocks = []),
        (this.documentationIdentifiers = []),
        (this.query = ""),
        (this.rerankResults = !1),
        (this.contextResults = { case: void 0 }),
        (this.rerankResultsV2 = !1),
        (this.conversationId = ""),
        (this.canHandleFilenamesAfterLanguageIds = !1),
        (this.longContextMode = !1),
        (this.isEval = !1),
        (this.requestId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamComposerContextRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
        { no: 2, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 3, name: "repositories", kind: "message", T: _t, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Ne },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "code_blocks", kind: "message", T: ye, repeated: !0 },
        { no: 7, name: "model_details", kind: "message", T: vt },
        {
          no: 8,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 9, name: "query", kind: "scalar", T: 9 },
        { no: 10, name: "code_context", kind: "message", T: pJt },
        { no: 11, name: "rerank_results", kind: "scalar", T: 8 },
        {
          no: 12,
          name: "file_search_results",
          kind: "message",
          T: X7,
          oneof: "context_results",
        },
        {
          no: 13,
          name: "code_search_results",
          kind: "message",
          T: K7,
          oneof: "context_results",
        },
        { no: 14, name: "linter_errors", kind: "message", T: hi },
        { no: 15, name: "is_bash", kind: "scalar", T: 8, opt: !0 },
        { no: 16, name: "rerank_results_v2", kind: "scalar", T: 8 },
        { no: 17, name: "conversation_id", kind: "scalar", T: 9 },
        {
          no: 18,
          name: "can_handle_filenames_after_language_ids",
          kind: "scalar",
          T: 8,
        },
        { no: 19, name: "long_context_mode", kind: "scalar", T: 8 },
        { no: 20, name: "is_eval", kind: "scalar", T: 8 },
        { no: 21, name: "request_id", kind: "scalar", T: 9 },
        { no: 22, name: "desired_max_tokens", kind: "scalar", T: 5, opt: !0 },
        { no: 23, name: "runnable_code_blocks", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new OJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OJ, t, e)
    }
  },
  pJt = class qJ extends d {
    constructor(t) {
      super(),
        (this.chunks = []),
        (this.scoredChunks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamComposerContextRequest.CodeContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunks", kind: "message", T: ye, repeated: !0 },
        { no: 2, name: "scored_chunks", kind: "message", T: fi, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new qJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qJ, t, e)
    }
  },
  gJt = class UJ extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckUsageBasedPriceRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "usage_event_details", kind: "message", T: VU },
      ])
    }
    static fromBinary(t, e) {
      return new UJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UJ, t, e)
    }
  },
  vJt = class MJ extends d {
    constructor(t) {
      super(),
        (this.markdownResponse = ""),
        (this.cents = 0),
        (this.priceId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckUsageBasedPriceResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "markdown_response", kind: "scalar", T: 9 },
        { no: 2, name: "cents", kind: "scalar", T: 5 },
        { no: 3, name: "price_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new MJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MJ, t, e)
    }
  },
  wJt = class HJ extends d {
    constructor(t) {
      super(),
        (this.origRequestId = ""),
        (this.usageUuid = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckQueuePositionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "orig_request_id", kind: "scalar", T: 9 },
        { no: 2, name: "model_details", kind: "message", T: vt },
        { no: 3, name: "usage_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new HJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HJ, t, e)
    }
  },
  yJt = class WJ extends d {
    constructor(t) {
      super(),
        (this.position = 0),
        (this.hitHardLimit = !1),
        (this.couldEnableUsageBasedPricingToSkip = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckQueuePositionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "position", kind: "scalar", T: 5 },
        { no: 2, name: "seconds_left_to_wait", kind: "scalar", T: 5, opt: !0 },
        { no: 7, name: "new_queue_position", kind: "scalar", T: 5, opt: !0 },
        { no: 3, name: "hit_hard_limit", kind: "scalar", T: 8 },
        {
          no: 4,
          name: "could_enable_usage_based_pricing_to_skip",
          kind: "scalar",
          T: 8,
        },
        { no: 5, name: "usage_event_details", kind: "message", T: VU },
        { no: 6, name: "custom_link", kind: "message", T: TJt },
      ])
    }
    static fromBinary(t, e) {
      return new WJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WJ, t, e)
    }
  },
  TJt = class jJ extends d {
    constructor(t) {
      super(),
        (this.address = ""),
        (this.message = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckQueuePositionResponse.CustomLink"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "address", kind: "scalar", T: 9 },
        { no: 2, name: "message", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new jJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jJ, t, e)
    }
  },
  kJt = class VJ extends d {
    constructor(t) {
      super(),
        (this.fileContent = ""),
        (this.languageId = ""),
        (this.commandId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IsolatedTreesitterRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_content", kind: "scalar", T: 9 },
        { no: 2, name: "language_id", kind: "scalar", T: 9 },
        { no: 3, name: "command_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new VJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VJ, t, e)
    }
  },
  SJt = class GJ extends d {
    constructor(t) {
      super(), (this.items = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IsolatedTreesitterResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "items", kind: "message", T: bJt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new GJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GJ, t, e)
    }
  },
  set = class zJ extends d {
    constructor(t) {
      super(), (this.row = 0), (this.column = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.IsolatedTreesitterResponse.TreeSitterPosition"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "row", kind: "scalar", T: 5 },
        { no: 2, name: "column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new zJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zJ, t, e)
    }
  },
  bJt = class YJ extends d {
    constructor(t) {
      super(), (this.symbolName = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.IsolatedTreesitterResponse.TreesitterSymbolNameItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "symbol_name", kind: "scalar", T: 9 },
        { no: 2, name: "start_position", kind: "message", T: set, opt: !0 },
        { no: 3, name: "end_position", kind: "message", T: set, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new YJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YJ, t, e)
    }
  },
  EJt = class QJ extends d {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.answerPlaceholder = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSimplePromptRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "answer_placeholder", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new QJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QJ, t, e)
    }
  },
  IJt = class XJ extends d {
    constructor(t) {
      super(), (this.result = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSimplePromptResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "result", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new XJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XJ, t, e)
    }
  },
  PJt = class KJ extends d {
    constructor(t) {
      super(), (this.didFit = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckLongFilesFitResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "did_fit", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new KJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KJ, t, e)
    }
  },
  NJt = class ZJ extends d {
    constructor(t) {
      super(),
        (this.promptType = Qm.UNSPECIFIED),
        (this.query = ""),
        (this.bucketId = ""),
        (this.queryStrategy = ""),
        (this.tokenLimit = 0),
        (this.rerankingStrategy = Xm.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetEvaluationPromptRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "prompt_type", kind: "enum", T: n.getEnumType(Qm) },
        { no: 2, name: "current_file", kind: "message", T: Ht },
        { no: 3, name: "query", kind: "scalar", T: 9 },
        { no: 4, name: "bucket_id", kind: "scalar", T: 9 },
        { no: 5, name: "query_strategy", kind: "scalar", T: 9 },
        { no: 6, name: "token_limit", kind: "scalar", T: 5 },
        {
          no: 7,
          name: "reranking_strategy",
          kind: "enum",
          T: n.getEnumType(Xm),
        },
      ])
    }
    static fromBinary(t, e) {
      return new ZJ().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZJ().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZJ().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZJ, t, e)
    }
  },
  Qm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.GENERATE = 1)] = "GENERATE"),
    (i[(i.CHAT = 2)] = "CHAT")
})(Qm || (Qm = {})),
  n.util.setEnumType(
    Qm,
    "aiserver.v1.GetEvaluationPromptRequest.EvaluationPromptType",
    [
      { no: 0, name: "EVALUATION_PROMPT_TYPE_UNSPECIFIED" },
      { no: 1, name: "EVALUATION_PROMPT_TYPE_GENERATE" },
      { no: 2, name: "EVALUATION_PROMPT_TYPE_CHAT" },
    ],
  )
var Xm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.DISTANCE_ONLY = 1)] = "DISTANCE_ONLY"),
    (i[(i.GPT4_RELEVANCE = 2)] = "GPT4_RELEVANCE")
})(Xm || (Xm = {})),
  n.util.setEnumType(
    Xm,
    "aiserver.v1.GetEvaluationPromptRequest.RerankingStrategy",
    [
      { no: 0, name: "RERANKING_STRATEGY_UNSPECIFIED" },
      { no: 1, name: "RERANKING_STRATEGY_DISTANCE_ONLY" },
      { no: 2, name: "RERANKING_STRATEGY_GPT4_RELEVANCE" },
    ],
  )
var $Jt = class tC extends d {
    constructor(t) {
      super(),
        (this.prompt = ""),
        (this.tokenCount = 0),
        (this.estimatedTokenCount = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetEvaluationPromptResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "prompt", kind: "scalar", T: 9 },
        { no: 2, name: "token_count", kind: "scalar", T: 5 },
        { no: 3, name: "estimated_token_count", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new tC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tC, t, e)
    }
  },
  xJt = class eC extends d {
    constructor(t) {
      super(),
        (this.prompt = ""),
        (this.repositories = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamInlineEditsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
        { no: 2, name: "prompt", kind: "scalar", T: 9 },
        { no: 3, name: "repositories", kind: "message", T: _t, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Ne },
      ])
    }
    static fromBinary(t, e) {
      return new eC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eC, t, e)
    }
  },
  JJt = class iC extends d {
    constructor(t) {
      super(), (this.line = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamInlineEditsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "line", kind: "scalar", T: 9 },
        { no: 2, name: "debugging_only_prompt", kind: "scalar", T: 9, opt: !0 },
        {
          no: 3,
          name: "debugging_only_token_count",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new iC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iC, t, e)
    }
  },
  CJt = class rC extends d {
    constructor(t) {
      super(),
        (this.didSummarize = !1),
        (this.upUntilIndex = 0),
        (this.summary = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SummarizeConversationResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "did_summarize", kind: "scalar", T: 8 },
        { no: 2, name: "up_until_index", kind: "scalar", T: 5 },
        { no: 3, name: "summary", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new rC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rC, t, e)
    }
  },
  LJt = class nC extends d {
    constructor(t) {
      super(), (this.conversation = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetChatTitleRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "conversation", kind: "message", T: se, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new nC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nC, t, e)
    }
  },
  RJt = class sC extends d {
    constructor(t) {
      super(), (this.title = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetChatTitleResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "title", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new sC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sC, t, e)
    }
  },
  nUt = class aC extends d {
    constructor(t) {
      super(),
        (this.prompt = ""),
        (this.tokenCount = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetChatPromptResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "prompt", kind: "scalar", T: 9 },
        { no: 2, name: "token_count", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new aC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aC, t, e)
    }
  },
  DJt = class oC extends d {
    constructor(t) {
      super(),
        (this.serverStartTime = 0),
        (this.serverFirstTokenTime = 0),
        (this.serverRequestSentTime = 0),
        (this.serverEndTime = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ServerTimingInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "server_start_time", kind: "scalar", T: 1 },
        { no: 2, name: "server_first_token_time", kind: "scalar", T: 1 },
        { no: 3, name: "server_request_sent_time", kind: "scalar", T: 1 },
        { no: 4, name: "server_end_time", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new oC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oC, t, e)
    }
  },
  pr = class cC extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 22, name: "server_bubble_id", kind: "scalar", T: 9, opt: !0 },
        {
          no: 2,
          name: "debugging_only_chat_prompt",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        {
          no: 3,
          name: "debugging_only_token_count",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 4, name: "document_citation", kind: "message", T: AU },
        { no: 5, name: "filled_prompt", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "is_big_file", kind: "scalar", T: 8, opt: !0 },
        { no: 7, name: "intermediate_text", kind: "scalar", T: 9, opt: !0 },
        {
          no: 10,
          name: "is_using_slow_request",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        { no: 8, name: "chunk_identity", kind: "message", T: FJt, opt: !0 },
        { no: 9, name: "docs_reference", kind: "message", T: M7, opt: !0 },
        { no: 11, name: "web_citation", kind: "message", T: Ett, opt: !0 },
        { no: 12, name: "status_updates", kind: "message", T: Ptt, opt: !0 },
        { no: 13, name: "timing_info", kind: "message", T: DJt, opt: !0 },
        { no: 14, name: "symbol_link", kind: "message", T: qU, opt: !0 },
        { no: 15, name: "file_link", kind: "message", T: UU, opt: !0 },
        {
          no: 16,
          name: "conversation_summary",
          kind: "message",
          T: Mn,
          opt: !0,
        },
        {
          no: 17,
          name: "service_status_update",
          kind: "message",
          T: $tt,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new cC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cC, t, e)
    }
  },
  FJt = class uC extends d {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.startLine = 0),
        (this.endLine = 0),
        (this.text = ""),
        (this.chunkType = Un.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatResponse.ChunkIdentity"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "end_line", kind: "scalar", T: 5 },
        { no: 4, name: "text", kind: "scalar", T: 9 },
        { no: 5, name: "chunk_type", kind: "enum", T: n.getEnumType(Un) },
      ])
    }
    static fromBinary(t, e) {
      return new uC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uC, t, e)
    }
  },
  _Jt = class lC extends d {
    constructor(t) {
      super(), (this.didWarmCache = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WarmComposerCacheResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "did_warm_cache", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new lC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lC, t, e)
    }
  },
  AJt = class dC extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WarmChatCacheRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request", kind: "message", T: qs },
      ])
    }
    static fromBinary(t, e) {
      return new dC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dC, t, e)
    }
  },
  BJt = class mC extends d {
    constructor(t) {
      super(), (this.didWarmCache = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WarmChatCacheResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "did_warm_cache", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new mC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mC, t, e)
    }
  },
  OJt = class hC extends d {
    constructor(t) {
      super(),
        (this.startLine = 0),
        (this.lines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SurroundingLines"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line", kind: "scalar", T: 5 },
        { no: 2, name: "lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new hC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hC, t, e)
    }
  },
  qJt = class fC extends d {
    constructor(t) {
      super(), (this.suggestionsFromEditor = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetCompletionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_identifier", kind: "message", T: jJt },
        { no: 2, name: "cursor_position", kind: "message", T: $s },
        { no: 3, name: "surrounding_lines", kind: "message", T: OJt },
        { no: 4, name: "explicit_context", kind: "message", T: Ne },
        {
          no: 5,
          name: "suggestions_from_editor",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new fC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fC, t, e)
    }
  },
  UJt = class pC extends d {
    constructor(t) {
      super(),
        (this.completion = ""),
        (this.score = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetCompletionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "completion", kind: "scalar", T: 9 },
        { no: 2, name: "score", kind: "scalar", T: 2 },
        {
          no: 3,
          name: "debugging_only_completion_prompt",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new pC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pC, t, e)
    }
  },
  MJt = class gC extends d {
    constructor(t) {
      super(),
        (this.query = ""),
        (this.repositories = []),
        (this.topK = 0),
        (this.restrictToBuckets = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSearchRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "query", kind: "scalar", T: 9 },
        { no: 2, name: "repositories", kind: "message", T: _t, repeated: !0 },
        { no: 3, name: "top_k", kind: "scalar", T: 5 },
        {
          no: 4,
          name: "restrict_to_buckets",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new gC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gC, t, e)
    }
  },
  HJt = class vC extends d {
    constructor(t) {
      super(),
        (this.repositoryRelativeWorkspacePath = ""),
        (this.fileRelativeRepositoryPath = ""),
        (this.chunk = ""),
        (this.distance = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileSearchResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "repository_relative_workspace_path",
          kind: "scalar",
          T: 9,
        },
        { no: 2, name: "file_relative_repository_path", kind: "scalar", T: 9 },
        { no: 3, name: "chunk", kind: "scalar", T: 9 },
        { no: 4, name: "distance", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new vC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vC, t, e)
    }
  },
  WJt = class wC extends d {
    constructor(t) {
      super(), (this.results = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSearchResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "results", kind: "message", T: HJt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new wC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wC, t, e)
    }
  },
  jJt = class yC extends d {
    constructor(t) {
      super(),
        (this.projectUuid = ""),
        (this.relativePath = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UniqueFileIdentifier"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "project_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "relative_path", kind: "scalar", T: 9 },
        { no: 3, name: "language_id", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new yC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yC, t, e)
    }
  },
  VJt = class TC extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetUserInfoRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new TC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TC, t, e)
    }
  },
  GJt = class kC extends d {
    constructor(t) {
      super(),
        (this.gpt4Requests = 0),
        (this.gpt4MaxRequests = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsageData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "gpt4_requests", kind: "scalar", T: 5 },
        { no: 3, name: "gpt4_max_requests", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new kC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kC, t, e)
    }
  },
  zJt = class SC extends d {
    constructor(t) {
      super(),
        (this.userId = ""),
        (this.jupyterToken = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetUserInfoResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "user_id", kind: "scalar", T: 9 },
        { no: 2, name: "jupyter_token", kind: "scalar", T: 9 },
        { no: 3, name: "usage", kind: "message", T: GJt },
      ])
    }
    static fromBinary(t, e) {
      return new SC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SC, t, e)
    }
  },
  YJt = class bC extends d {
    constructor(t) {
      super(), (this.bucketId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ClearAndRedoEntireBucketRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bucket_id", kind: "scalar", T: 9 },
        { no: 2, name: "commit", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new bC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bC, t, e)
    }
  },
  QJt = class EC extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ClearAndRedoEntireBucketResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new EC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new EC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new EC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(EC, t, e)
    }
  },
  XJt = class IC extends d {
    constructor(t) {
      super(),
        (this.generationUuid = ""),
        (this.completion = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeCheckRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "generation_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "completion", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new IC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IC, t, e)
    }
  },
  aet = class PC extends d {
    constructor(t) {
      super(),
        (this.action = { case: void 0 }),
        (this.reasoning = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeCheckResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "skip_action",
          kind: "message",
          T: KJt,
          oneof: "action",
        },
        {
          no: 2,
          name: "edit_action",
          kind: "message",
          T: ZJt,
          oneof: "action",
        },
        {
          no: 3,
          name: "create_action",
          kind: "message",
          T: tCt,
          oneof: "action",
        },
        { no: 4, name: "run_action", kind: "message", T: eCt, oneof: "action" },
        { no: 5, name: "reasoning", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new PC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PC, t, e)
    }
  },
  KJt = class NC extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeCheckResponse.SkipAction"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new NC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NC, t, e)
    }
  },
  ZJt = class $C extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeCheckResponse.EditAction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $C().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $C().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $C().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($C, t, e)
    }
  },
  tCt = class xC extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeCheckResponse.CreateAction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new xC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xC, t, e)
    }
  },
  eCt = class JC extends d {
    constructor(t) {
      super(), (this.command = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeCheckResponse.RunAction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "command", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new JC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JC, t, e)
    }
  },
  iCt = class CC extends d {
    constructor(t) {
      super(),
        (this.generationUuid = ""),
        (this.completion = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "generation_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "completion", kind: "scalar", T: 9 },
        { no: 3, name: "action", kind: "message", T: aet },
      ])
    }
    static fromBinary(t, e) {
      return new CC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CC, t, e)
    }
  },
  rCt = class LC extends d {
    constructor(t) {
      super(), (this.event = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "update_status",
          kind: "message",
          T: nCt,
          oneof: "event",
        },
      ])
    }
    static fromBinary(t, e) {
      return new LC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LC, t, e)
    }
  },
  nCt = class RC extends d {
    constructor(t) {
      super(), (this.status = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeResponse.UpdateStatus"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new RC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RC, t, e)
    }
  },
  sCt = class DC extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DoThisForMeResponseWrapped"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "real_response",
          kind: "message",
          T: rCt,
          oneof: "response",
        },
        {
          no: 2,
          name: "background_task_uuid",
          kind: "scalar",
          T: 9,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new DC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DC, t, e)
    }
  },
  aCt = class FC extends d {
    constructor(t) {
      super(), (this.toolformerSessionId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatToolformerContinueRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "toolformer_session_id", kind: "scalar", T: 9 },
        { no: 2, name: "tool_result", kind: "message", T: DU },
      ])
    }
    static fromBinary(t, e) {
      return new FC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FC, t, e)
    }
  },
  oet = class _C extends d {
    constructor(t) {
      super(),
        (this.responseType = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatToolformerResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "toolformer_session_id", kind: "scalar", T: 9, opt: !0 },
        {
          no: 2,
          name: "output",
          kind: "message",
          T: oCt,
          oneof: "response_type",
        },
        {
          no: 3,
          name: "tool_action",
          kind: "message",
          T: uCt,
          oneof: "response_type",
        },
        {
          no: 4,
          name: "thought",
          kind: "message",
          T: cCt,
          oneof: "response_type",
        },
      ])
    }
    static fromBinary(t, e) {
      return new _C().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _C().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _C().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_C, t, e)
    }
  },
  oCt = class AC extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatToolformerResponse.Output"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new AC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AC, t, e)
    }
  },
  cCt = class BC extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatToolformerResponse.Thought"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new BC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BC, t, e)
    }
  },
  uCt = class OC extends d {
    constructor(t) {
      super(),
        (this.userFacingText = ""),
        (this.rawModelOutput = ""),
        (this.moreToCome = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamChatToolformerResponse.ToolAction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "user_facing_text", kind: "scalar", T: 9 },
        { no: 3, name: "raw_model_output", kind: "scalar", T: 9 },
        { no: 2, name: "tool_call", kind: "message", T: ftt },
        { no: 4, name: "more_to_come", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new OC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OC, t, e)
    }
  },
  cet = class qC extends d {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.attachedCodeChunks = []),
        (this.repositories = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskInstruction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "attached_code_chunks",
          kind: "message",
          T: lCt,
          repeated: !0,
        },
        { no: 3, name: "current_file", kind: "message", T: Ht },
        { no: 4, name: "repositories", kind: "message", T: _t, repeated: !0 },
        { no: 5, name: "explicit_context", kind: "message", T: Ne },
      ])
    }
    static fromBinary(t, e) {
      return new qC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qC, t, e)
    }
  },
  lCt = class UC extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumber = 0),
        (this.lines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskInstruction.CodeChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new UC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UC, t, e)
    }
  },
  uet = class MC extends d {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.attachedCodeChunks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskUserMessage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "attached_code_chunks",
          kind: "message",
          T: dCt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new MC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MC, t, e)
    }
  },
  dCt = class HC extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLineNumber = 0),
        (this.lines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskUserMessage.CodeChunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 3, name: "lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new HC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HC, t, e)
    }
  },
  mCt = class WC extends d {
    constructor(t) {
      super(),
        (this.thought = ""),
        (this.automated = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PushAiThoughtRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "thought", kind: "scalar", T: 9 },
        { no: 2, name: "cmd_k_debug_info", kind: "message", T: hr },
        { no: 3, name: "automated", kind: "scalar", T: 8 },
        { no: 4, name: "metadata", kind: "message", T: hCt, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new WC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WC, t, e)
    }
  },
  hCt = class jC extends d {
    constructor(t) {
      super(), (this.event = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PushAiThoughtRequest.Metadata"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "accepted_hallucinated_function_event",
          kind: "message",
          T: fCt,
          oneof: "event",
        },
      ])
    }
    static fromBinary(t, e) {
      return new jC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jC, t, e)
    }
  },
  fCt = class VC extends d {
    constructor(t) {
      super(),
        (this.implementationUuid = ""),
        (this.hallucinatedFunctionUuid = ""),
        (this.implementation = ""),
        (this.source = ""),
        (this.implementationReqid = ""),
        (this.planReqid = ""),
        (this.reflectionReqid = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.PushAiThoughtRequest.Metadata.AcceptedHallucinatedFunctionEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "implementation_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "hallucinated_function_uuid", kind: "scalar", T: 9 },
        { no: 3, name: "implementation", kind: "scalar", T: 9 },
        { no: 4, name: "source", kind: "scalar", T: 9 },
        { no: 5, name: "implementation_reqid", kind: "scalar", T: 9 },
        { no: 6, name: "plan_reqid", kind: "scalar", T: 9 },
        { no: 7, name: "reflection_reqid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new VC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VC, t, e)
    }
  },
  pCt = class GC extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PushAiThoughtResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new GC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GC, t, e)
    }
  },
  gCt = class zC extends d {
    constructor(t) {
      super(), (this.modelOutput = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckDoableAsTaskRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_output", kind: "scalar", T: 9 },
        { no: 2, name: "model_details", kind: "message", T: vt },
      ])
    }
    static fromBinary(t, e) {
      return new zC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zC, t, e)
    }
  },
  vCt = class YC extends d {
    constructor(t) {
      super(), (this.doableAsTask = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckDoableAsTaskResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doable_as_task", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new YC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YC, t, e)
    }
  },
  wCt = class QC extends d {
    constructor(t) {
      super(), (this.debuggingOnlyLiveMode = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.InterfaceAgentInitRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_details", kind: "message", T: vt },
        { no: 2, name: "debugging_only_live_mode", kind: "scalar", T: 8 },
        {
          no: 3,
          name: "interface_agent_client_state",
          kind: "message",
          T: jtt,
        },
      ])
    }
    static fromBinary(t, e) {
      return new QC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QC, t, e)
    }
  },
  yCt = class XC extends d {
    constructor(t) {
      super(),
        (this.taskUuid = ""),
        (this.humanReadableTitle = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.InterfaceAgentInitResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "task_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "human_readable_title", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new XC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XC, t, e)
    }
  },
  TCt = class KC extends d {
    constructor(t) {
      super(), (this.taskUuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamInterfaceAgentStatusRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "task_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new KC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KC, t, e)
    }
  },
  kCt = class ZC extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamInterfaceAgentStatusResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "message", T: Vtt },
      ])
    }
    static fromBinary(t, e) {
      return new ZC().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZC().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZC().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZC, t, e)
    }
  },
  SCt = class t5 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskGetInterfaceAgentStatusRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "interface_agent_client_state",
          kind: "message",
          T: jtt,
        },
      ])
    }
    static fromBinary(t, e) {
      return new t5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new t5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new t5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(t5, t, e)
    }
  },
  bCt = class e5 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskGetInterfaceAgentStatusResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "message", T: Vtt },
      ])
    }
    static fromBinary(t, e) {
      return new e5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new e5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new e5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(e5, t, e)
    }
  },
  ECt = class i5 extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskGetInterfaceAgentStatusResponseWrapped"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "real_response",
          kind: "message",
          T: bCt,
          oneof: "response",
        },
        {
          no: 2,
          name: "background_task_uuid",
          kind: "scalar",
          T: 9,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new i5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new i5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new i5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(i5, t, e)
    }
  },
  ICt = class r5 extends d {
    constructor(t) {
      super(), (this.debuggingOnlyLiveMode = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskInitRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "instruction", kind: "message", T: cet },
        { no: 2, name: "model_details", kind: "message", T: vt },
        { no: 3, name: "debugging_only_live_mode", kind: "scalar", T: 8 },
        { no: 4, name: "engine_id", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new r5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new r5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new r5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(r5, t, e)
    }
  },
  PCt = class n5 extends d {
    constructor(t) {
      super(),
        (this.taskUuid = ""),
        (this.humanReadableTitle = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskInitResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "task_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "human_readable_title", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new n5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new n5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new n5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(n5, t, e)
    }
  },
  NCt = class s5 extends d {
    constructor(t) {
      super(),
        (this.taskUuid = ""),
        (this.startSequenceNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamLogRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "task_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "start_sequence_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new s5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new s5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new s5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(s5, t, e)
    }
  },
  $Ct = class a5 extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskLogOutput"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new a5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new a5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new a5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(a5, t, e)
    }
  },
  xCt = class o5 extends d {
    constructor(t) {
      super(),
        (this.userFacingText = ""),
        (this.rawModelOutput = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskLogToolAction"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "user_facing_text", kind: "scalar", T: 9 },
        { no: 3, name: "raw_model_output", kind: "scalar", T: 9 },
        { no: 2, name: "tool_call", kind: "message", T: ftt },
      ])
    }
    static fromBinary(t, e) {
      return new o5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new o5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new o5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(o5, t, e)
    }
  },
  JCt = class c5 extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskLogThought"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new c5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new c5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new c5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(c5, t, e)
    }
  },
  CCt = class u5 extends d {
    constructor(t) {
      super(), (this.actionSequenceNumber = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskLogToolResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool_result", kind: "message", T: DU },
        { no: 2, name: "action_sequence_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new u5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new u5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new u5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(u5, t, e)
    }
  },
  LCt = class l5 extends d {
    constructor(t) {
      super(),
        (this.sequenceNumber = 0),
        (this.isNotDone = !1),
        (this.logItem = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskLogItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "sequence_number", kind: "scalar", T: 5 },
        { no: 2, name: "is_not_done", kind: "scalar", T: 8 },
        { no: 3, name: "output", kind: "message", T: $Ct, oneof: "log_item" },
        {
          no: 4,
          name: "tool_action",
          kind: "message",
          T: xCt,
          oneof: "log_item",
        },
        { no: 5, name: "thought", kind: "message", T: JCt, oneof: "log_item" },
        {
          no: 6,
          name: "user_message",
          kind: "message",
          T: uet,
          oneof: "log_item",
        },
        {
          no: 7,
          name: "instruction",
          kind: "message",
          T: cet,
          oneof: "log_item",
        },
        {
          no: 8,
          name: "tool_result",
          kind: "message",
          T: CCt,
          oneof: "log_item",
        },
      ])
    }
    static fromBinary(t, e) {
      return new l5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new l5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new l5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(l5, t, e)
    }
  },
  RCt = class d5 extends d {
    constructor(t) {
      super(), (this.taskUuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskInfoRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "task_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new d5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new d5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new d5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(d5, t, e)
    }
  },
  DCt = class m5 extends d {
    constructor(t) {
      super(), (this.taskUuid = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskPauseRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "task_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new m5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new m5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new m5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(m5, t, e)
    }
  },
  FCt = class h5 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskPauseResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new h5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new h5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new h5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(h5, t, e)
    }
  },
  det = class f5 extends d {
    constructor(t) {
      super(),
        (this.humanReadableTitle = ""),
        (this.taskStatus = Fc.UNSPECIFIED),
        (this.lastLogSequenceNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskInfoResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "human_readable_title", kind: "scalar", T: 9 },
        { no: 2, name: "task_status", kind: "enum", T: n.getEnumType(Fc) },
        { no: 3, name: "last_log_sequence_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new f5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new f5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new f5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(f5, t, e)
    }
  },
  _Ct = class p5 extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamLogResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "streamed_log_item",
          kind: "message",
          T: LCt,
          oneof: "response",
        },
        {
          no: 2,
          name: "info_update",
          kind: "message",
          T: ACt,
          oneof: "response",
        },
        {
          no: 3,
          name: "initial_task_info",
          kind: "message",
          T: det,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new p5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new p5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new p5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(p5, t, e)
    }
  },
  ACt = class g5 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskStreamLogResponse.InfoUpdate"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "human_readable_title", kind: "scalar", T: 9, opt: !0 },
        {
          no: 2,
          name: "task_status",
          kind: "enum",
          T: n.getEnumType(Fc),
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new g5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new g5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new g5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(g5, t, e)
    }
  },
  BCt = class v5 extends d {
    constructor(t) {
      super(),
        (this.taskUuid = ""),
        (this.actionSequenceNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskProvideResultRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "task_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "action_sequence_number", kind: "scalar", T: 5 },
        { no: 3, name: "tool_result", kind: "message", T: DU },
      ])
    }
    static fromBinary(t, e) {
      return new v5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new v5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new v5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(v5, t, e)
    }
  },
  OCt = class w5 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskProvideResultResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new w5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new w5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new w5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(w5, t, e)
    }
  },
  qCt = class y5 extends d {
    constructor(t) {
      super(),
        (this.taskUuid = ""),
        (this.wantsAttentionRightNow = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskSendMessageRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "task_uuid", kind: "scalar", T: 9 },
        { no: 2, name: "user_message", kind: "message", T: uet },
        { no: 3, name: "wants_attention_right_now", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new y5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new y5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new y5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(y5, t, e)
    }
  },
  UCt = class T5 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TaskSendMessageResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new T5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new T5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new T5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(T5, t, e)
    }
  },
  MCt = class k5 extends d {
    constructor(t) {
      super(),
        (this.feedback = ""),
        (this.feedbackType = Km.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportFeedbackRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "feedback", kind: "scalar", T: 9 },
        { no: 2, name: "feedback_type", kind: "enum", T: n.getEnumType(Km) },
      ])
    }
    static fromBinary(t, e) {
      return new k5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new k5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new k5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(k5, t, e)
    }
  },
  Km
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.LOW_PRIORITY = 1)] = "LOW_PRIORITY"),
    (i[(i.HIGH_PRIORITY = 2)] = "HIGH_PRIORITY")
})(Km || (Km = {})),
  n.util.setEnumType(Km, "aiserver.v1.ReportFeedbackRequest.FeedbackType", [
    { no: 0, name: "FEEDBACK_TYPE_UNSPECIFIED" },
    { no: 1, name: "FEEDBACK_TYPE_LOW_PRIORITY" },
    { no: 2, name: "FEEDBACK_TYPE_HIGH_PRIORITY" },
  ])
var HCt = class S5 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportFeedbackResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new S5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new S5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new S5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(S5, t, e)
    }
  },
  WCt = class b5 extends d {
    constructor(t) {
      super(),
        (this.relativePathToCursorFolder = ""),
        (this.contents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogFile"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_path_to_cursor_folder", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new b5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new b5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new b5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(b5, t, e)
    }
  },
  jCt = class E5 extends d {
    constructor(t) {
      super(),
        (this.screenshots = []),
        (this.conversation = []),
        (this.logs = []),
        (this.consoleLogs = ""),
        (this.cursorVersion = ""),
        (this.os = ""),
        (this.protoUrl = ""),
        (this.failingRequstId = ""),
        (this.connectionErrorRaw = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "screenshots", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "current_file", kind: "message", T: Ht },
        { no: 3, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 4, name: "logs", kind: "message", T: WCt, repeated: !0 },
        { no: 5, name: "console_logs", kind: "scalar", T: 9 },
        { no: 6, name: "cursor_version", kind: "scalar", T: 9 },
        { no: 7, name: "os", kind: "scalar", T: 9 },
        { no: 8, name: "proto_url", kind: "scalar", T: 9 },
        { no: 9, name: "failing_requst_id", kind: "scalar", T: 9 },
        { no: 10, name: "connection_error_raw", kind: "scalar", T: 9 },
        { no: 12, name: "debug_info", kind: "message", T: hr },
        { no: 13, name: "connect_error_code", kind: "scalar", T: 5, opt: !0 },
        {
          no: 14,
          name: "error_detail_code",
          kind: "enum",
          T: n.getEnumType(Cs),
          opt: !0,
        },
        { no: 15, name: "error_detail_title", kind: "scalar", T: 9, opt: !0 },
        { no: 16, name: "error_detail_detail", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new E5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new E5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new E5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(E5, t, e)
    }
  },
  VCt = class I5 extends d {
    constructor(t) {
      super(),
        (this.bug = ""),
        (this.bugType = Zm.UNSPECIFIED),
        (this.contactEmail = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportBugRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug", kind: "scalar", T: 9 },
        { no: 2, name: "bug_type", kind: "enum", T: n.getEnumType(Zm) },
        { no: 3, name: "context", kind: "message", T: jCt },
        { no: 4, name: "contact_email", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new I5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new I5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new I5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(I5, t, e)
    }
  },
  Zm
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.LOW = 1)] = "LOW"),
    (i[(i.MEDIUM = 2)] = "MEDIUM"),
    (i[(i.URGENT = 3)] = "URGENT"),
    (i[(i.CRASH = 4)] = "CRASH"),
    (i[(i.CONNECTION_ERROR = 5)] = "CONNECTION_ERROR"),
    (i[(i.IDEA = 6)] = "IDEA"),
    (i[(i.MISC_AUTOMATIC_ERROR = 7)] = "MISC_AUTOMATIC_ERROR")
})(Zm || (Zm = {})),
  n.util.setEnumType(Zm, "aiserver.v1.ReportBugRequest.BugType", [
    { no: 0, name: "BUG_TYPE_UNSPECIFIED" },
    { no: 1, name: "BUG_TYPE_LOW" },
    { no: 2, name: "BUG_TYPE_MEDIUM" },
    { no: 3, name: "BUG_TYPE_URGENT" },
    { no: 4, name: "BUG_TYPE_CRASH" },
    { no: 5, name: "BUG_TYPE_CONNECTION_ERROR" },
    { no: 6, name: "BUG_TYPE_IDEA" },
    { no: 7, name: "BUG_TYPE_MISC_AUTOMATIC_ERROR" },
  ])
var GCt = class P5 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportBugResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new P5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new P5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new P5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(P5, t, e)
    }
  },
  zCt = class N5 extends d {
    constructor(t) {
      super(),
        (this.markers = []),
        (this.iterationNumber = 0),
        (this.sequenceId = ""),
        (this.userInstruction = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "markers", kind: "message", T: YCt, repeated: !0 },
        { no: 2, name: "model_details", kind: "message", T: vt },
        { no: 3, name: "iteration_number", kind: "scalar", T: 5 },
        { no: 4, name: "sequence_id", kind: "scalar", T: 9 },
        { no: 5, name: "user_instruction", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new N5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new N5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new N5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(N5, t, e)
    }
  },
  YCt = class $5 extends d {
    constructor(t) {
      super(),
        (this.lines = []),
        (this.startLine = 0),
        (this.endLineInclusive = 0),
        (this.message = ""),
        (this.relativeWorkspacePath = ""),
        (this.relatedInformation = []),
        (this.contextRanges = []),
        (this.ancestorTypeDefinitions = []),
        (this.insertedSymbolTypes = []),
        (this.quickFixes = []),
        (this.startColumn = 0),
        (this.endColumnInclusive = 0),
        (this.classInformation = []),
        (this.functionSignatures = []),
        (this.snapshot = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersRequest.Marker"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_inclusive", kind: "scalar", T: 5 },
        { no: 4, name: "message", kind: "scalar", T: 9 },
        { no: 5, name: "relative_workspace_path", kind: "scalar", T: 9 },
        {
          no: 6,
          name: "related_information",
          kind: "message",
          T: QCt,
          repeated: !0,
        },
        {
          no: 7,
          name: "context_ranges",
          kind: "message",
          T: XCt,
          repeated: !0,
        },
        {
          no: 8,
          name: "ancestor_type_definitions",
          kind: "message",
          T: KCt,
          repeated: !0,
        },
        {
          no: 9,
          name: "inserted_symbol_types",
          kind: "message",
          T: ZCt,
          repeated: !0,
        },
        { no: 10, name: "quick_fixes", kind: "message", T: t5t, repeated: !0 },
        { no: 11, name: "start_column", kind: "scalar", T: 5 },
        { no: 12, name: "end_column_inclusive", kind: "scalar", T: 5 },
        {
          no: 13,
          name: "class_information",
          kind: "message",
          T: i5t,
          repeated: !0,
        },
        {
          no: 14,
          name: "function_signatures",
          kind: "message",
          T: n5t,
          repeated: !0,
        },
        { no: 15, name: "snapshot", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new $5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($5, t, e)
    }
  },
  QCt = class x5 extends d {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.relativeWorkspacePath = ""),
        (this.relevantLines = []),
        (this.startLine = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersRequest.Marker.RelatedInformation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 3, name: "relevant_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "start_line", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new x5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new x5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new x5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(x5, t, e)
    }
  },
  XCt = class J5 extends d {
    constructor(t) {
      super(),
        (this.startLine = 0),
        (this.endLineInclusive = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersRequest.Marker.ContextRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_inclusive", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new J5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new J5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new J5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(J5, t, e)
    }
  },
  KCt = class C5 extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.relativeWorkspacePath = ""),
        (this.startLine = 0),
        (this.lines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.FixMarkersRequest.Marker.AncestorTypeDefinition"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 3, name: "start_line", kind: "scalar", T: 5 },
        { no: 4, name: "lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new C5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new C5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new C5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(C5, t, e)
    }
  },
  ZCt = class L5 extends d {
    constructor(t) {
      super(),
        (this.symbolName = ""),
        (this.symbolType = ""),
        (this.relativeWorkspacePath = ""),
        (this.symbolLine = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersRequest.Marker.InsertedSymbolType"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "symbol_name", kind: "scalar", T: 9 },
        { no: 2, name: "symbol_type", kind: "scalar", T: 9 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "symbol_line", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new L5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new L5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new L5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(L5, t, e)
    }
  },
  t5t = class R5 extends d {
    constructor(t) {
      super(),
        (this.message = ""),
        (this.kind = ""),
        (this.isPreferred = !1),
        (this.edits = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersRequest.Marker.QuickFix"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "message", kind: "scalar", T: 9 },
        { no: 2, name: "kind", kind: "scalar", T: 9 },
        { no: 3, name: "is_preferred", kind: "scalar", T: 8 },
        { no: 4, name: "edits", kind: "message", T: e5t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new R5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new R5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new R5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(R5, t, e)
    }
  },
  e5t = class D5 extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLine = 0),
        (this.endLineInclusive = 0),
        (this.deletedLines = []),
        (this.addLines = []),
        (this.snapshot = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersRequest.Marker.QuickFix.Edit"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_inclusive", kind: "scalar", T: 5 },
        { no: 4, name: "deleted_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "add_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 6, name: "snapshot", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new D5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new D5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new D5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(D5, t, e)
    }
  },
  i5t = class F5 extends d {
    constructor(t) {
      super(),
        (this.className = ""),
        (this.startLine = 0),
        (this.topLevelLines = []),
        (this.lines = []),
        (this.constructors = []),
        (this.detail = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersRequest.Marker.ClassInformation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "class_name", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "top_level_lines", kind: "scalar", T: 5, repeated: !0 },
        { no: 4, name: "lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "constructors", kind: "message", T: r5t, repeated: !0 },
        { no: 6, name: "detail", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new F5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new F5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new F5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(F5, t, e)
    }
  },
  r5t = class _5 extends d {
    constructor(t) {
      super(),
        (this.startLine = 0),
        (this.endLineInclusive = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.FixMarkersRequest.Marker.ClassInformation.Constructor"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_inclusive", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new _5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_5, t, e)
    }
  },
  n5t = class A5 extends d {
    constructor(t) {
      super(),
        (this.label = ""),
        (this.documentation = ""),
        (this.parameters = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersRequest.Marker.FunctionSignature"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "label", kind: "scalar", T: 9 },
        { no: 2, name: "documentation", kind: "scalar", T: 9 },
        { no: 3, name: "parameters", kind: "message", T: s5t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new A5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new A5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new A5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(A5, t, e)
    }
  },
  s5t = class B5 extends d {
    constructor(t) {
      super(),
        (this.label = ""),
        (this.documentation = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.FixMarkersRequest.Marker.FunctionSignature.FunctionParameter"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "label", kind: "scalar", T: 9 },
        { no: 2, name: "documentation", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new B5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new B5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new B5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(B5, t, e)
    }
  },
  a5t = class O5 extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.changes = []),
        (this.success = !1),
        (this.iterationNumber = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "changes", kind: "message", T: o5t, repeated: !0 },
        { no: 3, name: "success", kind: "scalar", T: 8 },
        { no: 4, name: "iteration_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new O5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new O5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new O5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(O5, t, e)
    }
  },
  o5t = class q5 extends d {
    constructor(t) {
      super(),
        (this.startLine = 0),
        (this.endLineExclusive = 0),
        (this.deletedLines = []),
        (this.addLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FixMarkersResponse.Change"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line", kind: "scalar", T: 5 },
        { no: 2, name: "end_line_exclusive", kind: "scalar", T: 5 },
        { no: 3, name: "deleted_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "add_lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new q5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new q5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new q5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(q5, t, e)
    }
  },
  c5t = class U5 extends d {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.repositories = []),
        (this.query = ""),
        (this.codeBlocks = []),
        (this.documentationIdentifiers = []),
        (this.badNotifications = []),
        (this.lintRules = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamLintRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
        { no: 2, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 3, name: "repositories", kind: "message", T: _t, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Ne },
        { no: 5, name: "workspace_root_path", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "query", kind: "scalar", T: 9 },
        { no: 7, name: "code_blocks", kind: "message", T: ye, repeated: !0 },
        { no: 9, name: "model_details", kind: "message", T: vt },
        {
          no: 10,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 11,
          name: "bad_notifications",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 12, name: "lint_rules", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new U5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new U5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new U5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(U5, t, e)
    }
  },
  u5t = class M5 extends d {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.timeSinceCompletedActionMs = 0),
        (this.featureType = pd.UNSPECIFIED),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.linesAboveAndBelow = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportGroundTruthCandidateRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "time_since_completed_action_ms", kind: "scalar", T: 5 },
        { no: 3, name: "feature_type", kind: "enum", T: n.getEnumType(pd) },
        { no: 4, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 5, name: "contents", kind: "scalar", T: 9 },
        { no: 6, name: "selection_in_question", kind: "message", T: vi },
        { no: 7, name: "lines_above_and_below", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new M5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new M5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new M5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(M5, t, e)
    }
  },
  l5t = class H5 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportGroundTruthCandidateResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new H5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new H5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new H5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(H5, t, e)
    }
  },
  d5t = class W5 extends d {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.fate = th.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportCmdKFateRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_id", kind: "scalar", T: 9 },
        { no: 2, name: "fate", kind: "enum", T: n.getEnumType(th) },
      ])
    }
    static fromBinary(t, e) {
      return new W5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new W5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new W5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(W5, t, e)
    }
  },
  th
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.CANCELLED = 1)] = "CANCELLED"),
    (i[(i.ACCEPTED = 2)] = "ACCEPTED"),
    (i[(i.REJECTED = 3)] = "REJECTED"),
    (i[(i.FOLLOWED_UP = 4)] = "FOLLOWED_UP"),
    (i[(i.REPROMPTED = 5)] = "REPROMPTED")
})(th || (th = {})),
  n.util.setEnumType(th, "aiserver.v1.ReportCmdKFateRequest.Fate", [
    { no: 0, name: "FATE_UNSPECIFIED" },
    { no: 1, name: "FATE_CANCELLED" },
    { no: 2, name: "FATE_ACCEPTED" },
    { no: 3, name: "FATE_REJECTED" },
    { no: 4, name: "FATE_FOLLOWED_UP" },
    { no: 5, name: "FATE_REPROMPTED" },
  ])
var m5t = class j5 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportCmdKFateResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new j5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new j5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new j5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(j5, t, e)
    }
  },
  sUt = class V5 extends d {
    constructor(t) {
      super(), (this.sshString = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SshConfigPromptProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ssh_string", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new V5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new V5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new V5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(V5, t, e)
    }
  },
  h5t = class G5 extends d {
    constructor(t) {
      super(),
        (this.conversation = []),
        (this.files = []),
        (this.contextResults = { case: void 0 }),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetFilesForComposerRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 2, name: "files", kind: "message", T: Ht, repeated: !0 },
        { no: 3, name: "rerank_results", kind: "scalar", T: 8, opt: !0 },
        {
          no: 4,
          name: "file_search_results",
          kind: "message",
          T: X7,
          oneof: "context_results",
        },
        {
          no: 5,
          name: "code_search_results",
          kind: "message",
          T: K7,
          oneof: "context_results",
        },
        { no: 6, name: "rerank_results_v2", kind: "scalar", T: 8, opt: !0 },
        { no: 7, name: "long_context_mode", kind: "scalar", T: 8, opt: !0 },
        { no: 8, name: "is_eval", kind: "scalar", T: 8, opt: !0 },
        { no: 9, name: "request_id", kind: "scalar", T: 9, opt: !0 },
        { no: 10, name: "model_details", kind: "message", T: vt },
      ])
    }
    static fromBinary(t, e) {
      return new G5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new G5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new G5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(G5, t, e)
    }
  },
  f5t = class z5 extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePaths = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetFilesForComposerResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "relative_workspace_paths",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new z5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new z5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new z5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(z5, t, e)
    }
  },
  p5t = class Y5 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FindBugsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
        { no: 2, name: "model_details", kind: "message", T: vt },
      ])
    }
    static fromBinary(t, e) {
      return new Y5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Y5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Y5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Y5, t, e)
    }
  },
  g5t = class Q5 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FindBugsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug", kind: "message", T: v5t, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new Q5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Q5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Q5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Q5, t, e)
    }
  },
  v5t = class X5 extends d {
    constructor(t) {
      super(),
        (this.description = ""),
        (this.lineNumber = 0),
        (this.confidence = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FindBugsResponse.Bug"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "description", kind: "scalar", T: 9 },
        { no: 2, name: "line_number", kind: "scalar", T: 5 },
        { no: 3, name: "confidence", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new X5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new X5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new X5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(X5, t, e)
    }
  },
  w5t = class K5 extends d {
    constructor(t) {
      super(),
        (this.diffs = []),
        (this.previousCommitMessages = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WriteGitCommitMessageRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diffs", kind: "scalar", T: 9, repeated: !0 },
        {
          no: 2,
          name: "previous_commit_messages",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new K5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new K5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new K5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(K5, t, e)
    }
  },
  y5t = class Z5 extends d {
    constructor(t) {
      super(), (this.commitMessage = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.WriteGitCommitMessageResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "commit_message", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new Z5().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Z5().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Z5().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Z5, t, e)
    }
  },
  T5t = class t4 extends d {
    constructor(t) {
      super(),
        (this.requestId = ""),
        (this.isComposerVisible = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.KeepComposerCacheWarmRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request", kind: "message", T: Z7 },
        { no: 2, name: "request_id", kind: "scalar", T: 9 },
        { no: 3, name: "is_composer_visible", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new t4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new t4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new t4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(t4, t, e)
    }
  },
  k5t = class e4 extends d {
    constructor(t) {
      super(), (this.didKeepWarm = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.KeepComposerCacheWarmResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "did_keep_warm", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new e4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new e4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new e4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(e4, t, e)
    }
  },
  S5t = class i4 extends d {
    constructor(t) {
      super(), (this.diffs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetDiffReviewRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diffs", kind: "message", T: b5t, repeated: !0 },
        { no: 2, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "use_premium_model", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new i4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new i4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new i4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(i4, t, e)
    }
  },
  b5t = class r4 extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.chunks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetDiffReviewRequest.SimpleFileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "chunks", kind: "message", T: E5t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new r4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new r4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new r4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(r4, t, e)
    }
  },
  E5t = class n4 extends d {
    constructor(t) {
      super(),
        (this.oldLines = []),
        (this.newLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetDiffReviewRequest.SimpleFileDiff.Chunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "old_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "new_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "old_range", kind: "message", T: vi },
        { no: 4, name: "new_range", kind: "message", T: vi },
      ])
    }
    static fromBinary(t, e) {
      return new n4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new n4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new n4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(n4, t, e)
    }
  },
  I5t = class s4 extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamDiffReviewResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new s4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new s4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new s4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(s4, t, e)
    }
  },
  P5t = class a4 extends d {
    constructor(t) {
      super(),
        (this.contextItems = []),
        (this.modelName = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CountTokensRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context_items", kind: "message", T: Ltt, repeated: !0 },
        { no: 2, name: "model_name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new a4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new a4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new a4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(a4, t, e)
    }
  },
  N5t = class o4 extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.count = 0),
        (this.lineCount = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ContextItemTokenDetail"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "count", kind: "scalar", T: 5 },
        { no: 3, name: "line_count", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new o4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new o4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new o4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(o4, t, e)
    }
  },
  $5t = class c4 extends d {
    constructor(t) {
      super(),
        (this.count = 0),
        (this.tokenDetails = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CountTokensResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "count", kind: "scalar", T: 5 },
        { no: 2, name: "token_details", kind: "message", T: N5t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new c4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new c4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new c4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(c4, t, e)
    }
  },
  aUt = class u4 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.InlineGPT4PromptProtoV1"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
      ])
    }
    static fromBinary(t, e) {
      return new u4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new u4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new u4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(u4, t, e)
    }
  },
  x5t = class l4 extends d {
    constructor(t) {
      super(),
        (this.repositories = []),
        (this.contextBlocks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamInlineLongCompletionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
        { no: 6, name: "repositories", kind: "message", T: _t, repeated: !0 },
        {
          no: 7,
          name: "context_blocks",
          kind: "message",
          T: J5t,
          repeated: !0,
        },
        { no: 13, name: "explicit_context", kind: "message", T: Ne },
        { no: 14, name: "model_details", kind: "message", T: vt },
        { no: 15, name: "linter_errors", kind: "message", T: hi },
      ])
    }
    static fromBinary(t, e) {
      return new l4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new l4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new l4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(l4, t, e)
    }
  },
  J5t = class d4 extends d {
    constructor(t) {
      super(),
        (this.contextType = eh.UNSPECIFIED),
        (this.blocks = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamInlineLongCompletionRequest.ContextBlock"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "context_type", kind: "enum", T: n.getEnumType(eh) },
        { no: 2, name: "blocks", kind: "message", T: ye, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new d4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new d4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new d4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(d4, t, e)
    }
  },
  eh
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.RECENT_LOCATIONS = 1)] = "RECENT_LOCATIONS")
})(eh || (eh = {})),
  n.util.setEnumType(
    eh,
    "aiserver.v1.StreamInlineLongCompletionRequest.ContextBlock.ContextType",
    [
      { no: 0, name: "CONTEXT_TYPE_UNSPECIFIED" },
      { no: 1, name: "CONTEXT_TYPE_RECENT_LOCATIONS" },
    ],
  )
var C5t = class m4 extends d {
    constructor(t) {
      super(),
        (this.mainSymbolsToAnalyzeFromGoToDef = []),
        (this.relatedSymbols = []),
        (this.mainSymbolsToAnalyzeFromImplementations = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiPreviewsIntent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "main_symbols_to_analyze_from_go_to_def",
          kind: "message",
          T: Oq,
          repeated: !0,
        },
        { no: 4, name: "main_symbol_hover_details", kind: "message", T: Cft },
        {
          no: 3,
          name: "related_symbols",
          kind: "message",
          T: Oq,
          repeated: !0,
        },
        {
          no: 6,
          name: "main_symbols_to_analyze_from_implementations",
          kind: "message",
          T: Oq,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new m4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new m4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new m4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(m4, t, e)
    }
  },
  L5t = class h4 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiPreviewsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "current_file", kind: "message", T: Ht },
        { no: 2, name: "intent", kind: "message", T: C5t },
        { no: 14, name: "model_details", kind: "message", T: vt },
        { no: 15, name: "is_detailed", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new h4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new h4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new h4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(h4, t, e)
    }
  },
  R5t = class f4 extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamAiPreviewsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new f4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new f4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new f4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(f4, t, e)
    }
  },
  D5t = class p4 extends d {
    constructor(t) {
      super(),
        (this.action = ""),
        (this.generationUuid = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportInlineActionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "action", kind: "scalar", T: 9 },
        { no: 2, name: "generation_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new p4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new p4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new p4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(p4, t, e)
    }
  },
  F5t = class g4 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportInlineActionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new g4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new g4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new g4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(g4, t, e)
    }
  },
  t8 = class v4 extends d {
    constructor(t) {
      super(), (this.metrics = {}), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportMetricsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "metrics",
          kind: "map",
          K: 9,
          V: { kind: "message", T: _5t },
        },
      ])
    }
    static fromBinary(t, e) {
      return new v4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new v4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new v4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(v4, t, e)
    }
  },
  _5t = class w4 extends d {
    constructor(t) {
      super(), (this.tags = {}), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportMetricsRequest.Metric"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 1, opt: !0 },
        { no: 2, name: "tags", kind: "map", K: 9, V: { kind: "scalar", T: 9 } },
      ])
    }
    static fromBinary(t, e) {
      return new w4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new w4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new w4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(w4, t, e)
    }
  },
  e8 = class y4 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReportMetricsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new y4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new y4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new y4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(y4, t, e)
    }
  },
  A5t = class T4 extends d {
    constructor(t) {
      super(), (this.generateTheWholeThing = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Specedits1Request"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "generate_the_whole_thing", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new T4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new T4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new T4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(T4, t, e)
    }
  },
  B5t = class k4 extends d {
    constructor(t) {
      super(), (this.fullFile = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Specedits1Response"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "full_file", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new k4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new k4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new k4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(k4, t, e)
    }
  },
  O5t = class S4 extends d {
    constructor(t) {
      super(), (this.name = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SimpleRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new S4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new S4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new S4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(S4, t, e)
    }
  },
  q5t = class b4 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SimpleResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new b4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new b4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new b4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(b4, t, e)
    }
  },
  oUt = class E4 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EmptyRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new E4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new E4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new E4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(E4, t, e)
    }
  },
  U5t = class I4 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EmptyResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new I4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new I4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new I4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(I4, t, e)
    }
  },
  M5t = class P4 extends d {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.fileSelections = []),
        (this.fileAttachments = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HeadlessAgenticComposerPrompt"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "file_selections",
          kind: "message",
          T: H5t,
          repeated: !0,
        },
        {
          no: 3,
          name: "file_attachments",
          kind: "message",
          T: W5t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new P4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new P4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new P4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(P4, t, e)
    }
  },
  H5t = class N4 extends d {
    constructor(t) {
      super(), (this.relativeWorkspacePath = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HeadlessAgenticComposerPrompt.FileSelection"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new N4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new N4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new N4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(N4, t, e)
    }
  },
  W5t = class $4 extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.contents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HeadlessAgenticComposerPrompt.FileAttachment"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($4, t, e)
    }
  },
  j5t = class x4 extends d {
    constructor(t) {
      super(), (this.chatModelName = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HeadlessAgenticComposerConfig"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "chat_model_name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new x4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new x4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new x4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(x4, t, e)
    }
  },
  V5t = class J4 extends d {
    constructor(t) {
      super(),
        (this.pathEncryptionKey = ""),
        (this.repositoryInfoShouldQueryStaging = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HeadlessAgenticComposerRepositoryInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repository_info", kind: "message", T: _t },
        { no: 2, name: "path_encryption_key", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "repository_info_should_query_staging",
          kind: "scalar",
          T: 8,
        },
      ])
    }
    static fromBinary(t, e) {
      return new J4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new J4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new J4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(J4, t, e)
    }
  },
  G5t = class C4 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamHeadlessAgenticComposerRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "prompt", kind: "message", T: M5t },
        { no: 2, name: "config", kind: "message", T: j5t },
        { no: 3, name: "repository_info", kind: "message", T: V5t },
      ])
    }
    static fromBinary(t, e) {
      return new C4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new C4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new C4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(C4, t, e)
    }
  },
  z5t = class L4 extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamHeadlessAgenticComposerResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "tool_call", kind: "message", T: itt, opt: !0 },
        { no: 3, name: "final_tool_result", kind: "message", T: Y5t, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new L4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new L4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new L4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(L4, t, e)
    }
  },
  Y5t = class R4 extends d {
    constructor(t) {
      super(), (this.toolCallId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.StreamHeadlessAgenticComposerResponse.FinalToolResult"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "tool_call_id", kind: "scalar", T: 9 },
        { no: 2, name: "result", kind: "message", T: q7 },
      ])
    }
    static fromBinary(t, e) {
      return new R4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new R4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new R4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(R4, t, e)
    }
  },
  met = {
    typeName: "aiserver.v1.AiService",
    methods: {
      healthCheck: { name: "HealthCheck", I: Ztt, O: h9t, kind: E.Unary },
      privacyCheck: { name: "PrivacyCheck", I: f9t, O: p9t, kind: E.Unary },
      timeLeftHealthCheck: {
        name: "TimeLeftHealthCheck",
        I: Ztt,
        O: g9t,
        kind: E.Unary,
      },
      throwErrorCheck: {
        name: "ThrowErrorCheck",
        I: c9t,
        O: u9t,
        kind: E.Unary,
      },
      availableModels: {
        name: "AvailableModels",
        I: l9t,
        O: d9t,
        kind: E.Unary,
      },
      streamChatTryReallyHard: {
        name: "StreamChatTryReallyHard",
        I: qs,
        O: pr,
        kind: E.ServerStreaming,
      },
      rerankDocuments: {
        name: "RerankDocuments",
        I: QEt,
        O: XEt,
        kind: E.Unary,
      },
      streamComposer: {
        name: "StreamComposer",
        I: Z7,
        O: pr,
        kind: E.ServerStreaming,
      },
      streamComposerContext: {
        name: "StreamComposerContext",
        I: Xtt,
        O: Ktt,
        kind: E.ServerStreaming,
      },
      warmComposerCache: {
        name: "WarmComposerCache",
        I: Z7,
        O: _Jt,
        kind: E.Unary,
      },
      keepComposerCacheWarm: {
        name: "KeepComposerCacheWarm",
        I: T5t,
        O: k5t,
        kind: E.Unary,
      },
      countTokens: { name: "CountTokens", I: P5t, O: $5t, kind: E.Unary },
      streamPotentialLocs: {
        name: "StreamPotentialLocs",
        I: uJt,
        O: lJt,
        kind: E.ServerStreaming,
      },
      streamPotentialLocsUnderneath: {
        name: "StreamPotentialLocsUnderneath",
        I: oJt,
        O: cJt,
        kind: E.ServerStreaming,
      },
      streamPotentialLocsInitialQueries: {
        name: "StreamPotentialLocsInitialQueries",
        I: sJt,
        O: aJt,
        kind: E.ServerStreaming,
      },
      streamNotepadChat: {
        name: "StreamNotepadChat",
        I: nJt,
        O: pr,
        kind: E.ServerStreaming,
      },
      getChatTitle: { name: "GetChatTitle", I: LJt, O: RJt, kind: E.Unary },
      getCompletion: { name: "GetCompletion", I: qJt, O: UJt, kind: E.Unary },
      getSearch: { name: "GetSearch", I: MJt, O: WJt, kind: E.Unary },
      streamInlineEdits: {
        name: "StreamInlineEdits",
        I: xJt,
        O: JJt,
        kind: E.ServerStreaming,
      },
      summarizeConversation: {
        name: "SummarizeConversation",
        I: qs,
        O: CJt,
        kind: E.Unary,
      },
      isolatedTreesitter: {
        name: "IsolatedTreesitter",
        I: kJt,
        O: SJt,
        kind: E.Unary,
      },
      getSimplePrompt: {
        name: "GetSimplePrompt",
        I: EJt,
        O: IJt,
        kind: E.Unary,
      },
      checkLongFilesFit: {
        name: "CheckLongFilesFit",
        I: qs,
        O: PJt,
        kind: E.Unary,
      },
      getEvaluationPrompt: {
        name: "GetEvaluationPrompt",
        I: NJt,
        O: $Jt,
        kind: E.Unary,
      },
      getUserInfo: { name: "GetUserInfo", I: VJt, O: zJt, kind: E.Unary },
      clearAndRedoEntireBucket: {
        name: "ClearAndRedoEntireBucket",
        I: YJt,
        O: QJt,
        kind: E.Unary,
      },
      streamBranchGemini: {
        name: "StreamBranchGemini",
        I: U$t,
        O: V$t,
        kind: E.ServerStreaming,
      },
      streamBranchFileSelections: {
        name: "StreamBranchFileSelections",
        I: B$t,
        O: O$t,
        kind: E.ServerStreaming,
      },
      streamBackgroundEdit: {
        name: "StreamBackgroundEdit",
        I: K9t,
        O: pr,
        kind: E.ServerStreaming,
      },
      streamGPTFourEdit: {
        name: "StreamGPTFourEdit",
        I: M9t,
        O: pr,
        kind: E.ServerStreaming,
      },
      streamChat: { name: "StreamChat", I: qs, O: pr, kind: E.ServerStreaming },
      streamChatWeb: {
        name: "StreamChatWeb",
        I: qs,
        O: pr,
        kind: E.ServerStreaming,
      },
      warmChatCache: { name: "WarmChatCache", I: AJt, O: BJt, kind: E.Unary },
      streamEdit: {
        name: "StreamEdit",
        I: iet,
        O: pr,
        kind: E.ServerStreaming,
      },
      preloadEdit: { name: "PreloadEdit", I: C9t, O: L9t, kind: E.Unary },
      streamFastEdit: {
        name: "StreamFastEdit",
        I: x9t,
        O: J9t,
        kind: E.ServerStreaming,
      },
      streamGenerate: {
        name: "StreamGenerate",
        I: v9t,
        O: pr,
        kind: E.ServerStreaming,
      },
      streamInlineLongCompletion: {
        name: "StreamInlineLongCompletion",
        I: x5t,
        O: pr,
        kind: E.ServerStreaming,
      },
      slashEdit: { name: "SlashEdit", I: b9t, O: E9t, kind: E.ServerStreaming },
      slashEditFollowUpWithPreviousEdits: {
        name: "SlashEditFollowUpWithPreviousEdits",
        I: I9t,
        O: P9t,
        kind: E.ServerStreaming,
      },
      streamAiPreviews: {
        name: "StreamAiPreviews",
        I: L5t,
        O: R5t,
        kind: E.ServerStreaming,
      },
      shouldTurnOnCppOnboarding: {
        name: "ShouldTurnOnCppOnboarding",
        I: zft,
        O: Yft,
        kind: E.Unary,
      },
      streamReview: {
        name: "StreamReview",
        I: w9t,
        O: S9t,
        kind: E.ServerStreaming,
      },
      streamReviewChat: {
        name: "StreamReviewChat",
        I: y9t,
        O: T9t,
        kind: E.ServerStreaming,
      },
      checkQueuePosition: {
        name: "CheckQueuePosition",
        I: wJt,
        O: yJt,
        kind: E.Unary,
      },
      checkUsageBasedPrice: {
        name: "CheckUsageBasedPrice",
        I: gJt,
        O: vJt,
        kind: E.Unary,
      },
      doThisForMeCheck: {
        name: "DoThisForMeCheck",
        I: XJt,
        O: aet,
        kind: E.Unary,
      },
      streamDoThisForMe: {
        name: "StreamDoThisForMe",
        I: iCt,
        O: sCt,
        kind: E.ServerStreaming,
      },
      streamChatToolformer: {
        name: "StreamChatToolformer",
        I: qs,
        O: oet,
        kind: E.ServerStreaming,
      },
      streamChatToolformerContinue: {
        name: "StreamChatToolformerContinue",
        I: aCt,
        O: oet,
        kind: E.ServerStreaming,
      },
      pushAiThought: { name: "PushAiThought", I: mCt, O: pCt, kind: E.Unary },
      checkDoableAsTask: {
        name: "CheckDoableAsTask",
        I: gCt,
        O: vCt,
        kind: E.Unary,
      },
      reportGroundTruthCandidate: {
        name: "ReportGroundTruthCandidate",
        I: u5t,
        O: l5t,
        kind: E.Unary,
      },
      reportCmdKFate: { name: "ReportCmdKFate", I: d5t, O: m5t, kind: E.Unary },
      showWelcomeScreen: {
        name: "ShowWelcomeScreen",
        I: sxt,
        O: axt,
        kind: E.Unary,
      },
      interfaceAgentInit: {
        name: "InterfaceAgentInit",
        I: wCt,
        O: yCt,
        kind: E.Unary,
      },
      streamInterfaceAgentStatus: {
        name: "StreamInterfaceAgentStatus",
        I: TCt,
        O: kCt,
        kind: E.ServerStreaming,
      },
      taskGetInterfaceAgentStatus: {
        name: "TaskGetInterfaceAgentStatus",
        I: SCt,
        O: ECt,
        kind: E.ServerStreaming,
      },
      taskInit: { name: "TaskInit", I: ICt, O: PCt, kind: E.Unary },
      taskPause: { name: "TaskPause", I: DCt, O: FCt, kind: E.Unary },
      taskInfo: { name: "TaskInfo", I: RCt, O: det, kind: E.Unary },
      taskStreamLog: {
        name: "TaskStreamLog",
        I: NCt,
        O: _Ct,
        kind: E.ServerStreaming,
      },
      taskSendMessage: {
        name: "TaskSendMessage",
        I: qCt,
        O: UCt,
        kind: E.Unary,
      },
      taskProvideResult: {
        name: "TaskProvideResult",
        I: BCt,
        O: OCt,
        kind: E.Unary,
      },
      createExperimentalIndex: {
        name: "CreateExperimentalIndex",
        I: T0t,
        O: k0t,
        kind: E.Unary,
      },
      listExperimentalIndexFiles: {
        name: "ListExperimentalIndexFiles",
        I: S0t,
        O: b0t,
        kind: E.Unary,
      },
      listenExperimentalIndex: {
        name: "ListenExperimentalIndex",
        I: WZ,
        O: E0t,
        kind: E.ServerStreaming,
      },
      registerFileToIndex: {
        name: "RegisterFileToIndex",
        I: NU,
        O: JU,
        kind: E.Unary,
      },
      setupIndexDependencies: {
        name: "SetupIndexDependencies",
        I: C0t,
        O: L0t,
        kind: E.Unary,
      },
      computeIndexTopoSort: {
        name: "ComputeIndexTopoSort",
        I: R0t,
        O: D0t,
        kind: E.Unary,
      },
      streamChatDeepContext: {
        name: "StreamChatDeepContext",
        I: r9t,
        O: n9t,
        kind: E.ServerStreaming,
      },
      chooseCodeReferences: {
        name: "ChooseCodeReferences",
        I: $U,
        O: JU,
        kind: E.Unary,
      },
      registerCodeReferences: {
        name: "RegisterCodeReferences",
        I: O0t,
        O: q0t,
        kind: E.Unary,
      },
      extractPaths: { name: "ExtractPaths", I: G0t, O: z0t, kind: E.Unary },
      summarizeWithReferences: {
        name: "SummarizeWithReferences",
        I: xU,
        O: JU,
        kind: E.Unary,
      },
      documentationQuery: {
        name: "DocumentationQuery",
        I: EEt,
        O: IEt,
        kind: E.Unary,
      },
      availableDocs: { name: "AvailableDocs", I: a9t, O: o9t, kind: E.Unary },
      reportFeedback: { name: "ReportFeedback", I: MCt, O: HCt, kind: E.Unary },
      reportBug: { name: "ReportBug", I: VCt, O: GCt, kind: E.Unary },
      streamChatContext: {
        name: "StreamChatContext",
        I: Xtt,
        O: Ktt,
        kind: E.ServerStreaming,
      },
      generateTldr: { name: "GenerateTldr", I: qxt, O: Uxt, kind: E.Unary },
      taskStreamChatContext: {
        name: "TaskStreamChatContext",
        I: Mxt,
        O: Kxt,
        kind: E.ServerStreaming,
      },
      rerankResults: { name: "RerankResults", I: Bxt, O: Oxt, kind: E.Unary },
      modelQuery: { name: "ModelQuery", I: Qtt, O: Rxt, kind: E.Unary },
      modelQueryV2: {
        name: "ModelQueryV2",
        I: Qtt,
        O: Fxt,
        kind: E.ServerStreaming,
      },
      intentPrediction: {
        name: "IntentPrediction",
        I: yxt,
        O: Txt,
        kind: E.Unary,
      },
      streamCursorTutor: {
        name: "StreamCursorTutor",
        I: Cxt,
        O: Lxt,
        kind: E.ServerStreaming,
      },
      checkFeatureStatus: {
        name: "CheckFeatureStatus",
        I: hxt,
        O: gxt,
        kind: E.Unary,
      },
      getEffectiveTokenLimit: {
        name: "GetEffectiveTokenLimit",
        I: fxt,
        O: pxt,
        kind: E.Unary,
      },
      getContextScores: {
        name: "GetContextScores",
        I: ext,
        O: ixt,
        kind: E.Unary,
      },
      streamCpp: { name: "StreamCpp", I: Vq, O: Qft, kind: E.ServerStreaming },
      cppConfig: { name: "CppConfig", I: Zft, O: tpt, kind: E.Unary },
      cppEditHistoryStatus: {
        name: "CppEditHistoryStatus",
        I: jgt,
        O: Vgt,
        kind: E.Unary,
      },
      cppAppend: { name: "CppAppend", I: Ugt, O: Mgt, kind: E.Unary },
      checkNumberConfig: {
        name: "CheckNumberConfig",
        I: vxt,
        O: wxt,
        kind: E.Unary,
      },
      streamTerminalAutocomplete: {
        name: "StreamTerminalAutocomplete",
        I: V9t,
        O: X9t,
        kind: E.ServerStreaming,
      },
      streamPseudocodeGenerator: {
        name: "StreamPseudocodeGenerator",
        I: G9t,
        O: z9t,
        kind: E.ServerStreaming,
      },
      streamPseudocodeMapper: {
        name: "StreamPseudocodeMapper",
        I: Y9t,
        O: Q9t,
        kind: E.ServerStreaming,
      },
      streamAiLintBug: {
        name: "StreamAiLintBug",
        I: R9t,
        O: _9t,
        kind: E.ServerStreaming,
      },
      streamAiCursorHelp: {
        name: "StreamAiCursorHelp",
        I: W9t,
        O: j9t,
        kind: E.ServerStreaming,
      },
      logUserLintReply: {
        name: "LogUserLintReply",
        I: A9t,
        O: B9t,
        kind: E.Unary,
      },
      logLinterExplicitUserFeedback: {
        name: "LogLinterExplicitUserFeedback",
        I: O9t,
        O: q9t,
        kind: E.Unary,
      },
      streamFixMarkers: {
        name: "StreamFixMarkers",
        I: zCt,
        O: a5t,
        kind: E.ServerStreaming,
      },
      reportInlineAction: {
        name: "ReportInlineAction",
        I: D5t,
        O: F5t,
        kind: E.Unary,
      },
      streamPriomptPrompt: {
        name: "StreamPriomptPrompt",
        I: dxt,
        O: mxt,
        kind: E.ServerStreaming,
      },
      streamLint: {
        name: "StreamLint",
        I: c5t,
        O: pr,
        kind: E.ServerStreaming,
      },
      streamNewLintRule: {
        name: "StreamNewLintRule",
        I: U9t,
        O: pr,
        kind: E.ServerStreaming,
      },
      aiProject: { name: "AiProject", I: oxt, O: cxt, kind: E.ServerStreaming },
      toCamelCase: { name: "ToCamelCase", I: uxt, O: lxt, kind: E.Unary },
      reportGenerationFeedback: {
        name: "ReportGenerationFeedback",
        I: rxt,
        O: nxt,
        kind: E.Unary,
      },
      getThoughtAnnotation: {
        name: "GetThoughtAnnotation",
        I: $$t,
        O: x$t,
        kind: E.Unary,
      },
      streamWebCmdKV1: {
        name: "StreamWebCmdKV1",
        I: Z$t,
        O: txt,
        kind: E.ServerStreaming,
      },
      streamNextCursorPrediction: {
        name: "StreamNextCursorPrediction",
        I: Y$t,
        O: K$t,
        kind: E.ServerStreaming,
      },
      isCursorPredictionEnabled: {
        name: "IsCursorPredictionEnabled",
        I: G$t,
        O: z$t,
        kind: E.Unary,
      },
      getCppEditClassification: {
        name: "GetCppEditClassification",
        I: spt,
        O: apt,
        kind: E.Unary,
      },
      getTerminalCompletion: {
        name: "GetTerminalCompletion",
        I: n$t,
        O: s$t,
        kind: E.Unary,
      },
      takeNotesOnCommitDiff: {
        name: "TakeNotesOnCommitDiff",
        I: D$t,
        O: F$t,
        kind: E.Unary,
      },
      bulkEmbed: { name: "BulkEmbed", I: C$t, O: L$t, kind: E.Unary },
      continueChatRequestWithCommits: {
        name: "ContinueChatRequestWithCommits",
        I: _$t,
        O: U5t,
        kind: E.Unary,
      },
      backgroundCmdKEval: {
        name: "BackgroundCmdKEval",
        I: S$t,
        O: N$t,
        kind: E.ServerStreaming,
      },
      backgroundCmdK: {
        name: "BackgroundCmdK",
        I: h$t,
        O: k$t,
        kind: E.ServerStreaming,
      },
      streamCursorMotion: {
        name: "StreamCursorMotion",
        I: d$t,
        O: m$t,
        kind: E.ServerStreaming,
      },
      calculateAutoSelection: {
        name: "CalculateAutoSelection",
        I: o$t,
        O: l$t,
        kind: E.Unary,
      },
      getAtSymbolSuggestions: {
        name: "GetAtSymbolSuggestions",
        I: e$t,
        O: i$t,
        kind: E.Unary,
      },
      getCodebaseQuestions: {
        name: "GetCodebaseQuestions",
        I: qs,
        O: KNt,
        kind: E.Unary,
      },
      getRankedContextFromContextBank: {
        name: "GetRankedContextFromContextBank",
        I: QNt,
        O: XNt,
        kind: E.ServerStreaming,
      },
      cppEditHistoryAppend: {
        name: "CppEditHistoryAppend",
        I: Hgt,
        O: Wgt,
        kind: E.Unary,
      },
      devOnlyGetPastRequestIds: {
        name: "DevOnlyGetPastRequestIds",
        I: GNt,
        O: YNt,
        kind: E.Unary,
      },
      getFilesForComposer: {
        name: "GetFilesForComposer",
        I: h5t,
        O: f5t,
        kind: E.Unary,
      },
      tryParseTypeScriptTreeSitter: {
        name: "TryParseTypeScriptTreeSitter",
        I: jNt,
        O: VNt,
        kind: E.Unary,
      },
      nameTab: { name: "NameTab", I: UNt, O: MNt, kind: E.Unary },
      isTerminalFinished: {
        name: "IsTerminalFinished",
        I: Gtt,
        O: bNt,
        kind: E.Unary,
      },
      isTerminalFinishedV2: {
        name: "IsTerminalFinishedV2",
        I: Gtt,
        O: ENt,
        kind: E.Unary,
      },
      testModelStatus: {
        name: "TestModelStatus",
        I: HNt,
        O: WNt,
        kind: E.Unary,
      },
      findBugs: { name: "FindBugs", I: p5t, O: g5t, kind: E.Unary },
      contextReranking: {
        name: "ContextReranking",
        I: ONt,
        O: qNt,
        kind: E.Unary,
      },
      autoContext: { name: "AutoContext", I: $Nt, O: JNt, kind: E.Unary },
      writeGitCommitMessage: {
        name: "WriteGitCommitMessage",
        I: w5t,
        O: y5t,
        kind: E.Unary,
      },
      streamBugBot: {
        name: "StreamBugBot",
        I: jq,
        O: BNt,
        kind: E.ServerStreaming,
      },
      checkBugBotPrice: {
        name: "CheckBugBotPrice",
        I: CNt,
        O: LNt,
        kind: E.Unary,
      },
      checkBugBotTelemetryHealthy: {
        name: "CheckBugBotTelemetryHealthy",
        I: RNt,
        O: DNt,
        kind: E.Unary,
      },
      getSuggestedBugBotIterations: {
        name: "GetSuggestedBugBotIterations",
        I: FNt,
        O: _Nt,
        kind: E.Unary,
      },
      testBidi: { name: "TestBidi", I: INt, O: PNt, kind: E.BiDiStreaming },
      streamDiffReview: {
        name: "StreamDiffReview",
        I: S5t,
        O: I5t,
        kind: E.ServerStreaming,
      },
    },
  },
  het = class D4 extends d {
    constructor(t) {
      super(), (this.id = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.User"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "id", kind: "scalar", T: 9 },
        { no: 3, name: "email", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "email_verified", kind: "scalar", T: 8, opt: !0 },
        { no: 5, name: "first_name", kind: "scalar", T: 9, opt: !0 },
        { no: 6, name: "last_name", kind: "scalar", T: 9, opt: !0 },
        { no: 7, name: "created_at", kind: "scalar", T: 9, opt: !0 },
        { no: 8, name: "updated_at", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new D4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new D4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new D4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(D4, t, e)
    }
  },
  Q5t = class F4 extends d {
    constructor(t) {
      super(), (this.destination = ih.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSessionTokenRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "user", kind: "message", T: het },
        { no: 2, name: "destination", kind: "enum", T: n.getEnumType(ih) },
        { no: 3, name: "stub", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "code", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new F4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new F4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new F4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(F4, t, e)
    }
  },
  ih
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.PORTAL = 1)] = "PORTAL"),
    (i[(i.AISERVER = 2)] = "AISERVER"),
    (i[(i.AUTH_PROXY = 3)] = "AUTH_PROXY")
})(ih || (ih = {})),
  n.util.setEnumType(ih, "aiserver.v1.GetSessionTokenRequest.Destination", [
    { no: 0, name: "DESTINATION_UNSPECIFIED" },
    { no: 1, name: "DESTINATION_PORTAL" },
    { no: 2, name: "DESTINATION_AISERVER" },
    { no: 3, name: "DESTINATION_AUTH_PROXY" },
  ])
var X5t = class _4 extends d {
    constructor(t) {
      super(), (this.sessionToken = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSessionTokenResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "session_token", kind: "scalar", T: 9 },
        { no: 2, name: "id", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new _4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_4, t, e)
    }
  },
  K5t = class A4 extends d {
    constructor(t) {
      super(), (this.sessionToken = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckSessionTokenRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "session_token", kind: "scalar", T: 9 },
        { no: 2, name: "user", kind: "message", T: het },
      ])
    }
    static fromBinary(t, e) {
      return new A4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new A4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new A4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(A4, t, e)
    }
  },
  Z5t = class B4 extends d {
    constructor(t) {
      super(), (this.valid = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckSessionTokenResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "valid", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new B4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new B4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new B4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(B4, t, e)
    }
  },
  t4t = class O4 extends d {
    constructor(t) {
      super(), (this.email = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CustomerIdRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "email", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new O4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new O4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new O4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(O4, t, e)
    }
  },
  e4t = class q4 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CustomerIdResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "customer_id", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new q4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new q4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new q4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(q4, t, e)
    }
  },
  i4t = class U4 extends d {
    constructor(t) {
      super(),
        (this.isUsingCurrentAndOnboardingFormat = !1),
        (this.privacy = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MarkPrivacyRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 2, name: "current_privacy_mode", kind: "scalar", T: 8, opt: !0 },
        {
          no: 3,
          name: "onboarding_privacy_mode",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 4,
          name: "is_using_current_and_onboarding_format",
          kind: "scalar",
          T: 8,
        },
        { no: 1, name: "privacy", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new U4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new U4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new U4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(U4, t, e)
    }
  },
  r4t = class M4 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MarkPrivacyResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new M4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new M4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new M4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(M4, t, e)
    }
  },
  n4t = class H4 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetEmailRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new H4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new H4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new H4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(H4, t, e)
    }
  },
  s4t = class W4 extends d {
    constructor(t) {
      super(),
        (this.email = ""),
        (this.signUpType = rh.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetEmailResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "email", kind: "scalar", T: 9 },
        { no: 2, name: "sign_up_type", kind: "enum", T: n.getEnumType(rh) },
      ])
    }
    static fromBinary(t, e) {
      return new W4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new W4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new W4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(W4, t, e)
    }
  },
  rh
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.AUTH_0 = 1)] = "AUTH_0"),
    (i[(i.GITHUB = 2)] = "GITHUB"),
    (i[(i.GOOGLE = 3)] = "GOOGLE"),
    (i[(i.WORKOS = 4)] = "WORKOS")
})(rh || (rh = {})),
  n.util.setEnumType(rh, "aiserver.v1.GetEmailResponse.SignUpType", [
    { no: 0, name: "SIGN_UP_TYPE_UNSPECIFIED" },
    { no: 1, name: "SIGN_UP_TYPE_AUTH_0" },
    { no: 2, name: "SIGN_UP_TYPE_GITHUB" },
    { no: 3, name: "SIGN_UP_TYPE_GOOGLE" },
    { no: 4, name: "SIGN_UP_TYPE_WORKOS" },
  ])
var a4t = class j4 extends d {
    constructor(t) {
      super(), (this.email = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EmailValidRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "email", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new j4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new j4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new j4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(j4, t, e)
    }
  },
  o4t = class V4 extends d {
    constructor(t) {
      super(), (this.valid = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EmailValidResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "valid", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new V4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new V4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new V4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(V4, t, e)
    }
  },
  c4t = class G4 extends d {
    constructor(t) {
      super(),
        (this.machineId = ""),
        (this.applicationName = ""),
        (this.version = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DownloadUpdateRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "machine_id", kind: "scalar", T: 9 },
        { no: 2, name: "application_name", kind: "scalar", T: 9 },
        { no: 3, name: "version", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new G4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new G4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new G4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(G4, t, e)
    }
  },
  u4t = class z4 extends d {
    constructor(t) {
      super(), (this.canDownload = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DownloadUpdateResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "can_download", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new z4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new z4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new z4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(z4, t, e)
    }
  },
  l4t = class Y4 extends d {
    constructor(t) {
      super(), (this.useTurbo = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SwitchCmdKFractionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "use_turbo", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new Y4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Y4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Y4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Y4, t, e)
    }
  },
  d4t = class Q4 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SwitchCmdKFractionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Q4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Q4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Q4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Q4, t, e)
    }
  },
  fet = {
    typeName: "aiserver.v1.AuthService",
    methods: {
      getEmail: { name: "GetEmail", I: n4t, O: s4t, kind: E.Unary },
      emailValid: { name: "EmailValid", I: a4t, O: o4t, kind: E.Unary },
      downloadUpdate: { name: "DownloadUpdate", I: c4t, O: u4t, kind: E.Unary },
      markPrivacy: { name: "MarkPrivacy", I: i4t, O: r4t, kind: E.Unary },
      switchCmdKFraction: {
        name: "SwitchCmdKFraction",
        I: l4t,
        O: d4t,
        kind: E.Unary,
      },
      getCustomerId: { name: "GetCustomerId", I: t4t, O: e4t, kind: E.Unary },
      getSessionToken: {
        name: "GetSessionToken",
        I: Q5t,
        O: X5t,
        kind: E.Unary,
      },
      checkSessionToken: {
        name: "CheckSessionToken",
        I: K5t,
        O: Z5t,
        kind: E.Unary,
      },
    },
  },
  pet = {
    typeName: "aiserver.v1.CmdKService",
    methods: {
      streamCmdK: {
        name: "StreamCmdK",
        I: IPt,
        O: qtt,
        kind: E.ServerStreaming,
      },
      streamHypermode: {
        name: "StreamHypermode",
        I: EPt,
        O: qtt,
        kind: E.ServerStreaming,
      },
      rerankCmdKContext: {
        name: "RerankCmdKContext",
        I: TPt,
        O: kPt,
        kind: E.Unary,
      },
      streamTerminalCmdK: {
        name: "StreamTerminalCmdK",
        I: $Pt,
        O: xPt,
        kind: E.ServerStreaming,
      },
      rerankTerminalCmdKContext: {
        name: "RerankTerminalCmdKContext",
        I: SPt,
        O: bPt,
        kind: E.Unary,
      },
      getRelevantChunks: {
        name: "GetRelevantChunks",
        I: OPt,
        O: qPt,
        kind: E.ServerStreaming,
      },
    },
  },
  get = {
    typeName: "aiserver.v1.CppService",
    methods: {
      markCppForEval: { name: "MarkCppForEval", I: ppt, O: vpt, kind: E.Unary },
      streamHoldCpp: {
        name: "StreamHoldCpp",
        I: hpt,
        O: fpt,
        kind: E.ServerStreaming,
      },
      availableModels: {
        name: "AvailableModels",
        I: dpt,
        O: mpt,
        kind: E.Unary,
      },
      recordCppFate: { name: "RecordCppFate", I: upt, O: lpt, kind: E.Unary },
    },
  },
  qr
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.OWNER = 1)] = "OWNER"),
    (i[(i.MEMBER = 2)] = "MEMBER"),
    (i[(i.FREE_OWNER = 3)] = "FREE_OWNER")
})(qr || (qr = {})),
  n.util.setEnumType(qr, "aiserver.v1.TeamRole", [
    { no: 0, name: "TEAM_ROLE_UNSPECIFIED" },
    { no: 1, name: "TEAM_ROLE_OWNER" },
    { no: 2, name: "TEAM_ROLE_MEMBER" },
    { no: 3, name: "TEAM_ROLE_FREE_OWNER" },
  ])
var m4t = class X4 extends d {
    constructor(t) {
      super(), (this.requestQuota = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpdateFastRequestsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_quota", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new X4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new X4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new X4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(X4, t, e)
    }
  },
  h4t = class K4 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpdateFastRequestsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new K4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new K4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new K4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(K4, t, e)
    }
  },
  f4t = class Z4 extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetFastRequestsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new Z4().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new Z4().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new Z4().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(Z4, t, e)
    }
  },
  p4t = class tL extends d {
    constructor(t) {
      super(), (this.requestQuota = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetFastRequestsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request_quota", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new tL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tL, t, e)
    }
  },
  g4t = class eL extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteAccountRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new eL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eL, t, e)
    }
  },
  v4t = class iL extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteAccountResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new iL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iL, t, e)
    }
  },
  w4t = class rL extends d {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.privacyModeForced = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SwitchTeamPrivacyModeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "privacy_mode_forced", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new rL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rL, t, e)
    }
  },
  y4t = class nL extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SwitchTeamPrivacyModeResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new nL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nL, t, e)
    }
  },
  T4t = class sL extends d {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamPrivacyModeForcedRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new sL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sL, t, e)
    }
  },
  k4t = class aL extends d {
    constructor(t) {
      super(), (this.privacyModeForced = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamPrivacyModeForcedResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "privacy_mode_forced", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new aL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aL, t, e)
    }
  },
  S4t = class oL extends d {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamHasValidPaymentMethodRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new oL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oL, t, e)
    }
  },
  b4t = class cL extends d {
    constructor(t) {
      super(),
        (this.hasValidPaymentMethod = !1),
        (this.trialDaysRemaining = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamHasValidPaymentMethodResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "has_valid_payment_method", kind: "scalar", T: 8 },
        { no: 2, name: "trial_days_remaining", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new cL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cL, t, e)
    }
  },
  E4t = class uL extends d {
    constructor(t) {
      super(), (this.name = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateTeamWithFreeTrialRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "privacy_mode_forced", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new uL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uL, t, e)
    }
  },
  I4t = class lL extends d {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateTeamWithFreeTrialResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new lL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lL, t, e)
    }
  },
  P4t = class dL extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetPricingHistoryRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new dL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dL, t, e)
    }
  },
  N4t = class mL extends d {
    constructor(t) {
      super(), (this.pricingHistory = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetPricingHistoryResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "pricing_history",
          kind: "message",
          T: $4t,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new mL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mL, t, e)
    }
  },
  $4t = class hL extends d {
    constructor(t) {
      super(),
        (this.description = ""),
        (this.id = ""),
        (this.changelog = ""),
        (this.createdAt = Pe.zero),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetPricingHistoryResponse.PricingDescription"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "description", kind: "scalar", T: 9 },
        { no: 2, name: "id", kind: "scalar", T: 9 },
        { no: 3, name: "changelog", kind: "scalar", T: 9 },
        { no: 4, name: "created_at", kind: "scalar", T: 3 },
      ])
    }
    static fromBinary(t, e) {
      return new hL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hL, t, e)
    }
  },
  x4t = class fL extends d {
    constructor(t) {
      super(), (this.month = 0), (this.year = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetMonthlyInvoiceRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "month", kind: "scalar", T: 5 },
        { no: 3, name: "year", kind: "scalar", T: 5 },
        { no: 4, name: "include_usage_events", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new fL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fL, t, e)
    }
  },
  J4t = class pL extends d {
    constructor(t) {
      super(),
        (this.items = []),
        (this.usageEvents = []),
        (this.isUsageEventsMaybeCutoff = !1),
        (this.hasUnpaidMidMonthInvoice = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetMonthlyInvoiceResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "items", kind: "message", T: C4t, repeated: !0 },
        { no: 2, name: "pricing_description", kind: "message", T: L4t },
        { no: 3, name: "usage_events", kind: "message", T: SNt, repeated: !0 },
        { no: 4, name: "is_usage_events_maybe_cutoff", kind: "scalar", T: 8 },
        { no: 5, name: "has_unpaid_mid_month_invoice", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new pL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pL, t, e)
    }
  },
  C4t = class gL extends d {
    constructor(t) {
      super(),
        (this.description = ""),
        (this.cents = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetMonthlyInvoiceResponse.InvoiceItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "description", kind: "scalar", T: 9 },
        { no: 2, name: "cents", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new gL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gL, t, e)
    }
  },
  L4t = class vL extends d {
    constructor(t) {
      super(),
        (this.description = ""),
        (this.id = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetMonthlyInvoiceResponse.PricingDescription"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "description", kind: "scalar", T: 9 },
        { no: 2, name: "id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new vL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vL, t, e)
    }
  },
  R4t = class wL extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetHardLimitRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new wL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wL, t, e)
    }
  },
  D4t = class yL extends d {
    constructor(t) {
      super(),
        (this.hardLimit = 0),
        (this.noUsageBasedAllowed = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetHardLimitResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "hard_limit", kind: "scalar", T: 5 },
        { no: 2, name: "no_usage_based_allowed", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new yL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yL, t, e)
    }
  },
  F4t = class TL extends d {
    constructor(t) {
      super(),
        (this.hardLimit = 0),
        (this.noUsageBasedAllowed = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SetHardLimitRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5, opt: !0 },
        { no: 2, name: "hard_limit", kind: "scalar", T: 5 },
        { no: 3, name: "no_usage_based_allowed", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new TL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TL, t, e)
    }
  },
  _4t = class kL extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SetHardLimitResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new kL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kL, t, e)
    }
  },
  A4t = class SL extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.id = 0),
        (this.role = qr.UNSPECIFIED),
        (this.seats = 0),
        (this.hasBilling = !1),
        (this.requestQuotaPerSeat = 0),
        (this.privacyModeForced = !1),
        (this.allowSso = !1),
        (this.adminOnlyUsagePricing = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Team"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "id", kind: "scalar", T: 5 },
        { no: 3, name: "role", kind: "enum", T: n.getEnumType(qr) },
        { no: 4, name: "seats", kind: "scalar", T: 5 },
        { no: 5, name: "has_billing", kind: "scalar", T: 8 },
        { no: 6, name: "request_quota_per_seat", kind: "scalar", T: 5 },
        { no: 7, name: "privacy_mode_forced", kind: "scalar", T: 8 },
        { no: 8, name: "allow_sso", kind: "scalar", T: 8 },
        { no: 9, name: "admin_only_usage_pricing", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new SL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SL, t, e)
    }
  },
  B4t = class bL extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new bL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bL, t, e)
    }
  },
  O4t = class EL extends d {
    constructor(t) {
      super(), (this.teams = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "teams", kind: "message", T: A4t, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new EL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new EL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new EL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(EL, t, e)
    }
  },
  q4t = class IL extends d {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.seats = 0),
        (this.yearly = !1),
        (this.requestQuotaPerSeat = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetActivationCheckoutUrlRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "seats", kind: "scalar", T: 5 },
        { no: 3, name: "yearly", kind: "scalar", T: 8 },
        { no: 4, name: "request_quota_per_seat", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new IL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IL, t, e)
    }
  },
  U4t = class PL extends d {
    constructor(t) {
      super(), (this.checkoutUrl = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetActivationCheckoutUrlResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "checkout_url", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new PL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PL, t, e)
    }
  },
  M4t = class NL extends d {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamCustomerPortalUrlRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new NL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NL, t, e)
    }
  },
  H4t = class $L extends d {
    constructor(t) {
      super(), (this.portalUrl = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamCustomerPortalUrlResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "portal_url", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $L().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $L().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $L().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($L, t, e)
    }
  },
  W4t = class xL extends d {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamMembersRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new xL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xL, t, e)
    }
  },
  j4t = class JL extends d {
    constructor(t) {
      super(),
        (this.name = ""),
        (this.email = ""),
        (this.id = 0),
        (this.role = qr.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TeamMember"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 4, name: "email", kind: "scalar", T: 9 },
        { no: 2, name: "id", kind: "scalar", T: 5 },
        { no: 3, name: "role", kind: "enum", T: n.getEnumType(qr) },
      ])
    }
    static fromBinary(t, e) {
      return new JL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JL, t, e)
    }
  },
  V4t = class CL extends d {
    constructor(t) {
      super(),
        (this.teamMembers = []),
        (this.userId = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamMembersResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_members", kind: "message", T: j4t, repeated: !0 },
        { no: 2, name: "user_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new CL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CL, t, e)
    }
  },
  G4t = class LL extends d {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamInviteLinkRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new LL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LL, t, e)
    }
  },
  z4t = class RL extends d {
    constructor(t) {
      super(), (this.inviteLink = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamInviteLinkResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "invite_link", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new RL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RL, t, e)
    }
  },
  Y4t = class DL extends d {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.email = ""),
        (this.role = qr.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SendTeamInviteRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "email", kind: "scalar", T: 9 },
        { no: 3, name: "role", kind: "enum", T: n.getEnumType(qr) },
      ])
    }
    static fromBinary(t, e) {
      return new DL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DL, t, e)
    }
  },
  Q4t = class FL extends d {
    constructor(t) {
      super(), (this.validUntil = Pe.zero), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SendTeamInviteResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "valid_until", kind: "scalar", T: 3 },
      ])
    }
    static fromBinary(t, e) {
      return new FL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FL, t, e)
    }
  },
  X4t = class _L extends d {
    constructor(t) {
      super(), (this.inviteCode = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AcceptInviteRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "invite_code", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new _L().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _L().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _L().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_L, t, e)
    }
  },
  K4t = class AL extends d {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AcceptInviteResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new AL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AL, t, e)
    }
  },
  Z4t = class BL extends d {
    constructor(t) {
      super(), (this.name = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateTeamRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "privacy_mode_forced", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new BL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BL, t, e)
    }
  },
  tLt = class OL extends d {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateTeamResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new OL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OL, t, e)
    }
  },
  eLt = class qL extends d {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.userId = 0),
        (this.role = qr.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpdateRoleRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "user_id", kind: "scalar", T: 5 },
        { no: 3, name: "role", kind: "enum", T: n.getEnumType(qr) },
      ])
    }
    static fromBinary(t, e) {
      return new qL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qL, t, e)
    }
  },
  iLt = class UL extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpdateRoleResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new UL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UL, t, e)
    }
  },
  rLt = class ML extends d {
    constructor(t) {
      super(), (this.teamId = 0), (this.userId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RemoveMemberRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "user_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new ML().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ML().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ML().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ML, t, e)
    }
  },
  nLt = class HL extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RemoveMemberResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new HL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HL, t, e)
    }
  },
  sLt = class WL extends d {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.newSeats = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChangeSeatRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "new_seats", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new WL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WL, t, e)
    }
  },
  aLt = class jL extends d {
    constructor(t) {
      super(), (this.success = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChangeSeatResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "success", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new jL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jL, t, e)
    }
  },
  oLt = class VL extends d {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.newNumSeats = 0),
        (this.newRequestQuotaPerSeat = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChangeTeamSubscriptionRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "new_num_seats", kind: "scalar", T: 5 },
        { no: 3, name: "new_request_quota_per_seat", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new VL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VL, t, e)
    }
  },
  cLt = class GL extends d {
    constructor(t) {
      super(), (this.success = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChangeTeamSubscriptionResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "success", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new GL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GL, t, e)
    }
  },
  uLt = class zL extends d {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamUsageRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new zL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zL, t, e)
    }
  },
  lLt = class YL extends d {
    constructor(t) {
      super(), (this.teamMemberUsage = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamUsageResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "team_member_usage",
          kind: "message",
          T: dLt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new YL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YL, t, e)
    }
  },
  dLt = class QL extends d {
    constructor(t) {
      super(), (this.id = 0), (this.usageData = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TeamMemberUsage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 5 },
        { no: 2, name: "usage_data", kind: "message", T: mLt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new QL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QL, t, e)
    }
  },
  mLt = class XL extends d {
    constructor(t) {
      super(),
        (this.modelType = ""),
        (this.numRequests = 0),
        (this.numTokens = 0),
        (this.maxTokenUsage = 0),
        (this.maxRequestUsage = 0),
        (this.lastUsage = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TeamMemberUsageData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_type", kind: "scalar", T: 9 },
        { no: 2, name: "num_requests", kind: "scalar", T: 5 },
        { no: 3, name: "num_tokens", kind: "scalar", T: 5 },
        { no: 4, name: "max_token_usage", kind: "scalar", T: 5 },
        { no: 5, name: "max_request_usage", kind: "scalar", T: 5 },
        { no: 6, name: "last_usage", kind: "scalar", T: 9 },
        { no: 7, name: "copilot_usage", kind: "scalar", T: 5, opt: !0 },
        { no: 8, name: "docs_count", kind: "scalar", T: 5, opt: !0 },
        {
          no: 9,
          name: "copilot_accepted_usage",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new XL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XL, t, e)
    }
  },
  hLt = class KL extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSignUpTypeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new KL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KL, t, e)
    }
  },
  fLt = class ZL extends d {
    constructor(t) {
      super(), (this.signUpType = nh.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSignUpTypeResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "sign_up_type", kind: "enum", T: n.getEnumType(nh) },
      ])
    }
    static fromBinary(t, e) {
      return new ZL().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZL().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZL().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZL, t, e)
    }
  },
  nh
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.AUTH_0 = 1)] = "AUTH_0"),
    (i[(i.GOOGLE = 2)] = "GOOGLE"),
    (i[(i.GITHUB = 3)] = "GITHUB"),
    (i[(i.WORKOS = 4)] = "WORKOS")
})(nh || (nh = {})),
  n.util.setEnumType(nh, "aiserver.v1.GetSignUpTypeResponse.SignUpType", [
    { no: 0, name: "SIGN_UP_TYPE_UNSPECIFIED" },
    { no: 1, name: "SIGN_UP_TYPE_AUTH_0" },
    { no: 2, name: "SIGN_UP_TYPE_GOOGLE" },
    { no: 3, name: "SIGN_UP_TYPE_GITHUB" },
    { no: 4, name: "SIGN_UP_TYPE_WORKOS" },
  ])
var pLt = class tR extends d {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetDailyTeamUsageRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new tR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tR, t, e)
    }
  },
  gLt = class eR extends d {
    constructor(t) {
      super(), (this.dailyTeamMemberUsage = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetDailyTeamUsageResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "daily_team_member_usage",
          kind: "message",
          T: vLt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new eR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eR, t, e)
    }
  },
  vLt = class iR extends d {
    constructor(t) {
      super(),
        (this.id = 0),
        (this.dailyUsageData = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DailyTeamMemberUsage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 5 },
        {
          no: 2,
          name: "daily_usage_data",
          kind: "message",
          T: wLt,
          repeated: !0,
        },
        { no: 3, name: "last_usage", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new iR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iR, t, e)
    }
  },
  wLt = class rR extends d {
    constructor(t) {
      super(),
        (this.date = ""),
        (this.modelUsageData = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DailyUsageData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "date", kind: "scalar", T: 9 },
        { no: 4, name: "copilot_usage", kind: "scalar", T: 5, opt: !0 },
        {
          no: 2,
          name: "model_usage_data",
          kind: "message",
          T: yLt,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new rR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rR, t, e)
    }
  },
  yLt = class nR extends d {
    constructor(t) {
      super(),
        (this.modelType = ""),
        (this.numRequests = 0),
        (this.numTokens = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ModelUsageData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "model_type", kind: "scalar", T: 9 },
        { no: 2, name: "num_requests", kind: "scalar", T: 5 },
        { no: 3, name: "num_tokens", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new nR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nR, t, e)
    }
  },
  TLt = class sR extends d {
    constructor(t) {
      super(), (this.platform = sh.UNSPECIFIED), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetDownloadLinkRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "platform", kind: "enum", T: n.getEnumType(sh) },
      ])
    }
    static fromBinary(t, e) {
      return new sR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sR, t, e)
    }
  },
  sh
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.MAC_APPLE_SILICON = 1)] = "MAC_APPLE_SILICON"),
    (i[(i.MAC_INTEL = 2)] = "MAC_INTEL"),
    (i[(i.MAC_UNIVERSAL = 3)] = "MAC_UNIVERSAL"),
    (i[(i.WINDOWS = 4)] = "WINDOWS"),
    (i[(i.LINUX = 5)] = "LINUX")
})(sh || (sh = {})),
  n.util.setEnumType(sh, "aiserver.v1.GetDownloadLinkRequest.Platform", [
    { no: 0, name: "PLATFORM_UNSPECIFIED" },
    { no: 1, name: "PLATFORM_MAC_APPLE_SILICON" },
    { no: 2, name: "PLATFORM_MAC_INTEL" },
    { no: 3, name: "PLATFORM_MAC_UNIVERSAL" },
    { no: 4, name: "PLATFORM_WINDOWS" },
    { no: 5, name: "PLATFORM_LINUX" },
  ])
var kLt = class aR extends d {
    constructor(t) {
      super(), (this.cachedDownloadLink = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetDownloadLinkResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "cached_download_link", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new aR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aR, t, e)
    }
  },
  SLt = class oR extends d {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSsoConfigurationLinksRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new oR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oR, t, e)
    }
  },
  bLt = class cR extends d {
    constructor(t) {
      super(),
        (this.ssoUrl = ""),
        (this.domainVerificationUrl = ""),
        (this.ssoStatus = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetSsoConfigurationLinksResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "sso_url", kind: "scalar", T: 9 },
        { no: 2, name: "domain_verification_url", kind: "scalar", T: 9 },
        { no: 3, name: "sso_status", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new cR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cR, t, e)
    }
  },
  ELt = class uR extends d {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.adminOnlyUsagePricing = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SetAdminOnlyUsagePricingRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "admin_only_usage_pricing", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new uR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uR, t, e)
    }
  },
  ILt = class lR extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SetAdminOnlyUsagePricingResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new lR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lR, t, e)
    }
  },
  PLt = class dR extends d {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetYearlyUpgradeEligibilityRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new dR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dR, t, e)
    }
  },
  NLt = class mR extends d {
    constructor(t) {
      super(), (this.eligible = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetYearlyUpgradeEligibilityResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "eligible", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new mR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mR, t, e)
    }
  },
  $Lt = class hR extends d {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpgradeToYearlyRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new hR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hR, t, e)
    }
  },
  xLt = class fR extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpgradeToYearlyResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new fR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fR, t, e)
    }
  },
  JLt = class pR extends d {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetUsageBasedPremiumRequestsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new pR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pR, t, e)
    }
  },
  CLt = class gR extends d {
    constructor(t) {
      super(),
        (this.usageBasedPremiumRequests = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetUsageBasedPremiumRequestsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "usage_based_premium_requests", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new gR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gR, t, e)
    }
  },
  LLt = class vR extends d {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.usageBasedPremiumRequests = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SetUsageBasedPremiumRequestsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "usage_based_premium_requests", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new vR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vR, t, e)
    }
  },
  RLt = class wR extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SetUsageBasedPremiumRequestsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new wR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wR, t, e)
    }
  },
  DLt = class yR extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetReferralsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new yR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yR, t, e)
    }
  },
  FLt = class TR extends d {
    constructor(t) {
      super(),
        (this.numReferrals = 0),
        (this.referralCode = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetReferralsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "num_referrals", kind: "scalar", T: 5 },
        { no: 2, name: "referral_code", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new TR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TR, t, e)
    }
  },
  _Lt = class kR extends d {
    constructor(t) {
      super(),
        (this.referralCode = ""),
        (this.authId = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckReferralCodeRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "referral_code", kind: "scalar", T: 9 },
        { no: 2, name: "auth_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new kR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kR, t, e)
    }
  },
  ALt = class SR extends d {
    constructor(t) {
      super(),
        (this.isValid = !1),
        (this.userIsEligible = !1),
        (this.maxRedemptions = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CheckReferralCodeResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "is_valid", kind: "scalar", T: 8 },
        { no: 2, name: "user_is_eligible", kind: "scalar", T: 8 },
        { no: 3, name: "max_redemptions", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new SR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SR, t, e)
    }
  },
  BLt = class bR extends d {
    constructor(t) {
      super(), (this.teamId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamReposRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new bR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bR, t, e)
    }
  },
  OLt = class ER extends d {
    constructor(t) {
      super(), (this.repos = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamReposResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repos", kind: "message", T: qLt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ER().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ER().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ER().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ER, t, e)
    }
  },
  qLt = class IR extends d {
    constructor(t) {
      super(),
        (this.id = 0),
        (this.url = ""),
        (this.patterns = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamReposResponse.Repo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 5 },
        { no: 2, name: "url", kind: "scalar", T: 9 },
        { no: 3, name: "patterns", kind: "message", T: ULt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new IR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IR, t, e)
    }
  },
  ULt = class PR extends d {
    constructor(t) {
      super(), (this.id = 0), (this.pattern = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetTeamReposResponse.Pattern"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 5 },
        { no: 2, name: "pattern", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new PR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PR, t, e)
    }
  },
  MLt = class NR extends d {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.repoUrl = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateTeamRepoRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "repo_url", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new NR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NR, t, e)
    }
  },
  HLt = class $R extends d {
    constructor(t) {
      super(), (this.repoId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CreateTeamRepoResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "repo_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new $R().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $R().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $R().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($R, t, e)
    }
  },
  WLt = class xR extends d {
    constructor(t) {
      super(), (this.teamId = 0), (this.repoId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteTeamRepoRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "repo_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new xR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xR, t, e)
    }
  },
  jLt = class JR extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteTeamRepoResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new JR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JR, t, e)
    }
  },
  VLt = class CR extends d {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.repoId = 0),
        (this.pattern = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddRepoPatternRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "repo_id", kind: "scalar", T: 5 },
        { no: 3, name: "pattern", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new CR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CR, t, e)
    }
  },
  GLt = class LR extends d {
    constructor(t) {
      super(), (this.patternId = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddRepoPatternResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "pattern_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new LR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LR, t, e)
    }
  },
  zLt = class RR extends d {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.repoId = 0),
        (this.patternId = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RemoveRepoPatternRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "repo_id", kind: "scalar", T: 5 },
        { no: 3, name: "pattern_id", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new RR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RR, t, e)
    }
  },
  YLt = class DR extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RemoveRepoPatternResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new DR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DR, t, e)
    }
  },
  vet = {
    typeName: "aiserver.v1.DashboardService",
    methods: {
      getTeams: { name: "GetTeams", I: B4t, O: O4t, kind: E.Unary },
      getActivationCheckoutUrl: {
        name: "GetActivationCheckoutUrl",
        I: q4t,
        O: U4t,
        kind: E.Unary,
      },
      getTeamCustomerPortalUrl: {
        name: "GetTeamCustomerPortalUrl",
        I: M4t,
        O: H4t,
        kind: E.Unary,
      },
      getTeamMembers: { name: "GetTeamMembers", I: W4t, O: V4t, kind: E.Unary },
      sendTeamInvite: { name: "SendTeamInvite", I: Y4t, O: Q4t, kind: E.Unary },
      getTeamInviteLink: {
        name: "GetTeamInviteLink",
        I: G4t,
        O: z4t,
        kind: E.Unary,
      },
      acceptInvite: { name: "AcceptInvite", I: X4t, O: K4t, kind: E.Unary },
      createTeam: { name: "CreateTeam", I: Z4t, O: tLt, kind: E.Unary },
      changeSeat: { name: "ChangeSeat", I: sLt, O: aLt, kind: E.Unary },
      changeTeamSubscription: {
        name: "ChangeTeamSubscription",
        I: oLt,
        O: cLt,
        kind: E.Unary,
      },
      updateRole: { name: "UpdateRole", I: eLt, O: iLt, kind: E.Unary },
      removeMember: { name: "RemoveMember", I: rLt, O: nLt, kind: E.Unary },
      getTeamUsage: { name: "GetTeamUsage", I: uLt, O: lLt, kind: E.Unary },
      getDailyTeamUsage: {
        name: "GetDailyTeamUsage",
        I: pLt,
        O: gLt,
        kind: E.Unary,
      },
      getSignUpType: { name: "GetSignUpType", I: hLt, O: fLt, kind: E.Unary },
      getHardLimit: { name: "GetHardLimit", I: R4t, O: D4t, kind: E.Unary },
      setHardLimit: { name: "SetHardLimit", I: F4t, O: _4t, kind: E.Unary },
      deleteAccount: { name: "DeleteAccount", I: g4t, O: v4t, kind: E.Unary },
      getMonthlyInvoice: {
        name: "GetMonthlyInvoice",
        I: x4t,
        O: J4t,
        kind: E.Unary,
      },
      getPricingHistory: {
        name: "GetPricingHistory",
        I: P4t,
        O: N4t,
        kind: E.Unary,
      },
      createTeamWithFreeTrial: {
        name: "CreateTeamWithFreeTrial",
        I: E4t,
        O: I4t,
        kind: E.Unary,
      },
      getTeamHasValidPaymentMethod: {
        name: "GetTeamHasValidPaymentMethod",
        I: S4t,
        O: b4t,
        kind: E.Unary,
      },
      getTeamPrivacyModeForced: {
        name: "GetTeamPrivacyModeForced",
        I: T4t,
        O: k4t,
        kind: E.Unary,
      },
      switchTeamPrivacyMode: {
        name: "SwitchTeamPrivacyMode",
        I: w4t,
        O: y4t,
        kind: E.Unary,
      },
      updateFastRequests: {
        name: "UpdateFastRequests",
        I: m4t,
        O: h4t,
        kind: E.Unary,
      },
      getFastRequests: {
        name: "GetFastRequests",
        I: f4t,
        O: p4t,
        kind: E.Unary,
      },
      getDownloadLink: {
        name: "GetDownloadLink",
        I: TLt,
        O: kLt,
        kind: E.Unary,
      },
      getSsoConfigurationLinks: {
        name: "GetSsoConfigurationLinks",
        I: SLt,
        O: bLt,
        kind: E.Unary,
      },
      setAdminOnlyUsagePricing: {
        name: "SetAdminOnlyUsagePricing",
        I: ELt,
        O: ILt,
        kind: E.Unary,
      },
      getYearlyUpgradeEligibility: {
        name: "GetYearlyUpgradeEligibility",
        I: PLt,
        O: NLt,
        kind: E.Unary,
      },
      upgradeToYearly: {
        name: "UpgradeToYearly",
        I: $Lt,
        O: xLt,
        kind: E.Unary,
      },
      getUsageBasedPremiumRequests: {
        name: "GetUsageBasedPremiumRequests",
        I: JLt,
        O: CLt,
        kind: E.Unary,
      },
      setUsageBasedPremiumRequests: {
        name: "SetUsageBasedPremiumRequests",
        I: LLt,
        O: RLt,
        kind: E.Unary,
      },
      getReferrals: { name: "GetReferrals", I: DLt, O: FLt, kind: E.Unary },
      checkReferralCode: {
        name: "CheckReferralCode",
        I: _Lt,
        O: ALt,
        kind: E.Unary,
      },
      getTeamRepos: { name: "GetTeamRepos", I: BLt, O: OLt, kind: E.Unary },
      createTeamRepo: { name: "CreateTeamRepo", I: MLt, O: HLt, kind: E.Unary },
      deleteTeamRepo: { name: "DeleteTeamRepo", I: WLt, O: jLt, kind: E.Unary },
      addRepoPattern: { name: "AddRepoPattern", I: VLt, O: GLt, kind: E.Unary },
      removeRepoPattern: {
        name: "RemoveRepoPattern",
        I: zLt,
        O: YLt,
        kind: E.Unary,
      },
    },
  },
  QLt = class FR extends d {
    constructor(t) {
      super(), (this.files = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileFilterRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: Lm, repeated: !0 },
        { no: 2, name: "bug_description", kind: "message", T: se },
      ])
    }
    static fromBinary(t, e) {
      return new FR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FR, t, e)
    }
  },
  XLt = class _R extends d {
    constructor(t) {
      super(),
        (this.filePath = ""),
        (this.fileScore = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FileFilterResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new _R().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _R().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _R().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_R, t, e)
    }
  },
  KLt = class AR extends d {
    constructor(t) {
      super(), (this.commits = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GitFilterRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "commits", kind: "message", T: Os, repeated: !0 },
        { no: 2, name: "bug_description", kind: "message", T: se },
      ])
    }
    static fromBinary(t, e) {
      return new AR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AR, t, e)
    }
  },
  ZLt = class BR extends d {
    constructor(t) {
      super(),
        (this.relevantCommit = ""),
        (this.commitScore = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GitFilterResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relevant_commit", kind: "scalar", T: 9 },
        { no: 2, name: "commit_score", kind: "scalar", T: 2 },
      ])
    }
    static fromBinary(t, e) {
      return new BR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BR, t, e)
    }
  },
  tRt = class OR extends d {
    constructor(t) {
      super(), (this.relevantCommits = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugAnalysisRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "relevant_commits",
          kind: "message",
          T: Os,
          repeated: !0,
        },
        {
          no: 2,
          name: "bug_description_and_file_attachments",
          kind: "message",
          T: se,
        },
        { no: 3, name: "model_details", kind: "message", T: vt },
      ])
    }
    static fromBinary(t, e) {
      return new OR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OR, t, e)
    }
  },
  eRt = class qR extends d {
    constructor(t) {
      super(),
        (this.reasoning = ""),
        (this.bugDescription = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugAnalysisResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "reasoning", kind: "scalar", T: 9 },
        { no: 2, name: "bug_description", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new qR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qR, t, e)
    }
  },
  wet = {
    typeName: "aiserver.v1.DebuggerService",
    methods: {
      gitFilter: { name: "GitFilter", I: KLt, O: ZLt, kind: E.ServerStreaming },
      fileFilter: {
        name: "FileFilter",
        I: QLt,
        O: XLt,
        kind: E.ServerStreaming,
      },
      bugAnalysis: {
        name: "BugAnalysis",
        I: tRt,
        O: eRt,
        kind: E.ServerStreaming,
      },
    },
  },
  yet = class UR extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.hash = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MinimalFileHash"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "hash", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new UR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UR, t, e)
    }
  },
  iRt = class MR extends d {
    constructor(t) {
      super(),
        (this.uuid = ""),
        (this.openTabs = []),
        (this.contextGraphFiles = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StartFastSearchRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "cursor_position", kind: "message", T: $s },
        { no: 3, name: "open_tabs", kind: "message", T: yet, repeated: !0 },
        {
          no: 4,
          name: "context_graph_files",
          kind: "message",
          T: yet,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new MR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MR, t, e)
    }
  },
  rRt = class HR extends d {
    constructor(t) {
      super(), (this.response = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StartFastSearchResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ready", kind: "message", T: nRt, oneof: "response" },
        {
          no: 2,
          name: "missing_files",
          kind: "message",
          T: sRt,
          oneof: "response",
        },
      ])
    }
    static fromBinary(t, e) {
      return new HR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HR, t, e)
    }
  },
  nRt = class WR extends d {
    constructor(t) {
      super(), (this.ready = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StartFastSearchResponse.Ready"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "ready", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new WR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WR, t, e)
    }
  },
  sRt = class jR extends d {
    constructor(t) {
      super(), (this.file = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StartFastSearchResponse.MissingFiles"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new jR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jR, t, e)
    }
  },
  aRt = class VR extends d {
    constructor(t) {
      super(), (this.uuid = ""), (this.query = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastSearchRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "uuid", kind: "scalar", T: 9 },
        { no: 2, name: "query", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new VR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VR, t, e)
    }
  },
  oRt = class GR extends d {
    constructor(t) {
      super(), (this.fileChunks = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastSearchResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_chunks", kind: "message", T: cRt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new GR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GR, t, e)
    }
  },
  cRt = class zR extends d {
    constructor(t) {
      super(),
        (this.chunkScore = 0),
        (this.contents = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.FastSearchResponse.Chunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "chunk", kind: "message", T: yft },
        { no: 2, name: "chunk_score", kind: "scalar", T: 2 },
        { no: 3, name: "contents", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new zR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zR, t, e)
    }
  },
  Tet = {
    typeName: "aiserver.v1.FastSearchService",
    methods: {
      startFastSearch: {
        name: "StartFastSearch",
        I: iRt,
        O: rRt,
        kind: E.Unary,
      },
      fastSearch: { name: "FastSearch", I: aRt, O: oRt, kind: E.Unary },
    },
  },
  GU = class YR extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLine = 0),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UsefulType"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "text", kind: "scalar", T: 9 },
        { no: 4, name: "score", kind: "scalar", T: 1, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new YR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YR, t, e)
    }
  },
  uRt = class QR extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.fileContents = ""),
        (this.implementationStartLineInclusive = 0),
        (this.implementationEndLineInclusive = 0),
        (this.applyPlan = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainApplyPlanRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_contents", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "implementation_start_line_inclusive",
          kind: "scalar",
          T: 5,
        },
        {
          no: 4,
          name: "implementation_end_line_inclusive",
          kind: "scalar",
          T: 5,
        },
        { no: 5, name: "apply_plan", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new QR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QR, t, e)
    }
  },
  lRt = class XR extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainApplyPlanResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new XR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XR, t, e)
    }
  },
  dRt = class KR extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.fileContents = ""),
        (this.usefulTypes = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SortUsefulTypesNaiveRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_contents", kind: "scalar", T: 9 },
        { no: 3, name: "query_range", kind: "message", T: mRt },
        { no: 4, name: "useful_types", kind: "message", T: GU, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new KR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KR, t, e)
    }
  },
  mRt = class ZR extends d {
    constructor(t) {
      super(),
        (this.startLineNumber = 0),
        (this.startColumn = 0),
        (this.endLineNumber = 0),
        (this.endColumn = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SortUsefulTypesNaiveRequest.IRange"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "start_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "start_column", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_number", kind: "scalar", T: 5 },
        { no: 4, name: "end_column", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new ZR().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZR().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZR().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZR, t, e)
    }
  },
  hRt = class tD extends d {
    constructor(t) {
      super(), (this.usefulTypes = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.SortUsefulTypesNaiveResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "useful_types", kind: "message", T: GU, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new tD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tD, t, e)
    }
  },
  fRt = class eD extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.oldFileContents = ""),
        (this.implementationStartLineInclusive = 0),
        (this.implementationEndLineInclusive = 0),
        (this.newImplementationLines = []),
        (this.callSiteLines = []),
        (this.functionName = ""),
        (this.branchNotes = ""),
        (this.branchName = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainReflectRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "old_file_contents", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "implementation_start_line_inclusive",
          kind: "scalar",
          T: 5,
        },
        {
          no: 4,
          name: "implementation_end_line_inclusive",
          kind: "scalar",
          T: 5,
        },
        {
          no: 5,
          name: "new_implementation_lines",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 6, name: "call_site_lines", kind: "scalar", T: 5, repeated: !0 },
        { no: 7, name: "function_name", kind: "scalar", T: 9 },
        { no: 8, name: "branch_notes", kind: "scalar", T: 9 },
        { no: 9, name: "branch_name", kind: "scalar", T: 9 },
        { no: 10, name: "lints", kind: "message", T: _7 },
      ])
    }
    static fromBinary(t, e) {
      return new eD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eD, t, e)
    }
  },
  pRt = class iD extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainReflectResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "decision", kind: "message", T: yRt },
      ])
    }
    static fromBinary(t, e) {
      return new iD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iD, t, e)
    }
  },
  gRt = class rD extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainReflectResponse.AcceptDecision"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new rD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rD, t, e)
    }
  },
  vRt = class nD extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.Opus2ChainReflectResponse.RetryWithoutMoreInformationDecision"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new nD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nD, t, e)
    }
  },
  wRt = class sD extends d {
    constructor(t) {
      super(), (this.codebaseQuestions = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.Opus2ChainReflectResponse.RetryWithCodebaseQuestionDecision"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "codebase_questions",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new sD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sD, t, e)
    }
  },
  yRt = class aD extends d {
    constructor(t) {
      super(), (this.decision = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainReflectResponse.Decision"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "accept", kind: "message", T: gRt, oneof: "decision" },
        {
          no: 2,
          name: "retry_without_more_information",
          kind: "message",
          T: vRt,
          oneof: "decision",
        },
        {
          no: 3,
          name: "retry_with_codebase_question",
          kind: "message",
          T: wRt,
          oneof: "decision",
        },
      ])
    }
    static fromBinary(t, e) {
      return new aD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aD, t, e)
    }
  },
  TRt = class oD extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.fileContents = ""),
        (this.implementationStartLineInclusive = 0),
        (this.implementationEndLineInclusive = 0),
        (this.diffHistory = []),
        (this.callSiteLines = []),
        (this.functionName = ""),
        (this.usefulTypes = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.V0ChainRunRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_contents", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "implementation_start_line_inclusive",
          kind: "scalar",
          T: 5,
        },
        {
          no: 4,
          name: "implementation_end_line_inclusive",
          kind: "scalar",
          T: 5,
        },
        { no: 5, name: "diff_history", kind: "message", T: Di, repeated: !0 },
        { no: 6, name: "call_site_lines", kind: "scalar", T: 5, repeated: !0 },
        { no: 7, name: "function_name", kind: "scalar", T: 9 },
        { no: 8, name: "useful_types", kind: "message", T: GU, repeated: !0 },
        { no: 10, name: "prompt", kind: "message", T: ket },
        { no: 9, name: "debug_info", kind: "message", T: hr },
      ])
    }
    static fromBinary(t, e) {
      return new oD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oD, t, e)
    }
  },
  kRt = class cD extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.V0ChainRunResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new cD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cD, t, e)
    }
  },
  ket = class uD extends d {
    constructor(t) {
      super(),
        (this.text = ""),
        (this.contextItems = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.HallucinatedFunctionsProtoPrompt"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
        { no: 2, name: "context_items", kind: "message", T: Ha, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new uD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uD, t, e)
    }
  },
  bet = class lD extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.fileContents = ""),
        (this.implementationStartLineInclusive = 0),
        (this.implementationEndLineInclusive = 0),
        (this.diffHistory = []),
        (this.callSiteLines = []),
        (this.functionName = ""),
        (this.branchNotes = ""),
        (this.branchName = ""),
        (this.scoredCodebaseContext = []),
        (this.branchDiffFiles = []),
        (this.diffHistoryFiles = []),
        (this.planVersion = ah.UNSPECIFIED),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainPlanRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "file_contents", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "implementation_start_line_inclusive",
          kind: "scalar",
          T: 5,
        },
        {
          no: 4,
          name: "implementation_end_line_inclusive",
          kind: "scalar",
          T: 5,
        },
        { no: 5, name: "diff_history", kind: "message", T: Di, repeated: !0 },
        { no: 6, name: "call_site_lines", kind: "scalar", T: 5, repeated: !0 },
        { no: 7, name: "function_name", kind: "scalar", T: 9 },
        { no: 9, name: "debug_info", kind: "message", T: hr },
        { no: 20, name: "prompt", kind: "message", T: ket },
        { no: 10, name: "branch_notes", kind: "scalar", T: 9 },
        { no: 11, name: "branch_name", kind: "scalar", T: 9 },
        {
          no: 12,
          name: "scored_codebase_context",
          kind: "message",
          T: fi,
          repeated: !0,
        },
        { no: 13, name: "diff_to_base_branch", kind: "message", T: SRt },
        {
          no: 16,
          name: "branch_diff_files",
          kind: "message",
          T: Eet,
          repeated: !0,
        },
        {
          no: 14,
          name: "diff_history_files",
          kind: "message",
          T: Eet,
          repeated: !0,
        },
        {
          no: 8,
          name: "codebase_information",
          kind: "message",
          T: ERt,
          opt: !0,
        },
        { no: 15, name: "plan_version", kind: "enum", T: n.getEnumType(ah) },
        { no: 17, name: "context_ast", kind: "message", T: Mtt },
      ])
    }
    static fromBinary(t, e) {
      return new lD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lD, t, e)
    }
  },
  ah
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.V0 = 1)] = "V0"),
    (i[(i.V1_MORE_CONTEXT_AND_GUIDELINES = 2)] =
      "V1_MORE_CONTEXT_AND_GUIDELINES")
})(ah || (ah = {})),
  n.util.setEnumType(ah, "aiserver.v1.Opus2ChainPlanRequest.OpusPlanVersion", [
    { no: 0, name: "OPUS_PLAN_VERSION_UNSPECIFIED" },
    { no: 1, name: "OPUS_PLAN_VERSION_V0" },
    { no: 2, name: "OPUS_PLAN_VERSION_V1_MORE_CONTEXT_AND_GUIDELINES" },
  ])
var SRt = class dD extends d {
    constructor(t) {
      super(),
        (this.fileDiffs = []),
        (this.commits = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainPlanRequest.BranchDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_diffs", kind: "message", T: bRt, repeated: !0 },
        { no: 2, name: "commits", kind: "message", T: Os, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new dD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dD, t, e)
    }
  },
  bRt = class mD extends d {
    constructor(t) {
      super(),
        (this.fileName = ""),
        (this.diff = ""),
        (this.tooBig = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainPlanRequest.BranchDiff.FileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_name", kind: "scalar", T: 9 },
        { no: 2, name: "diff", kind: "scalar", T: 9 },
        { no: 3, name: "too_big", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new mD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mD, t, e)
    }
  },
  Eet = class hD extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.text = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainPlanRequest.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new hD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hD, t, e)
    }
  },
  ERt = class fD extends d {
    constructor(t) {
      super(), (this.files = []), (this.qa = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainPlanRequest.CodebaseInformation"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "files", kind: "message", T: IRt, repeated: !0 },
        { no: 2, name: "qa", kind: "message", T: PRt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new fD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fD, t, e)
    }
  },
  IRt = class pD extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.contents = ""),
        (this.interestingLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.Opus2ChainPlanRequest.CodebaseInformation.File"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "contents", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "interesting_lines",
          kind: "scalar",
          T: 5,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new pD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pD, t, e)
    }
  },
  PRt = class gD extends d {
    constructor(t) {
      super(),
        (this.question = ""),
        (this.answer = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainPlanRequest.CodebaseInformation.QA"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "question", kind: "scalar", T: 9 },
        { no: 2, name: "answer", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new gD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gD, t, e)
    }
  },
  cUt = class vD extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.ExtractFunctionNameFromImplementationPromptProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new vD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vD, t, e)
    }
  },
  NRt = class wD extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainPlanResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new wD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wD, t, e)
    }
  },
  uUt = class yD extends d {
    constructor(t) {
      super(),
        (this.examples = []),
        (this.tokenLimit = 0),
        (this.tokenizer = ""),
        (this.chainOfThought = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.CodebaseKnowledgeCmdKInstructionFewShotPromptProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "examples", kind: "message", T: $Rt, repeated: !0 },
        { no: 2, name: "current", kind: "message", T: Iet },
        { no: 8, name: "token_limit", kind: "scalar", T: 5 },
        { no: 9, name: "tokenizer", kind: "scalar", T: 9 },
        { no: 10, name: "chain_of_thought", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new yD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yD, t, e)
    }
  },
  $Rt = class TD extends d {
    constructor(t) {
      super(),
        (this.instruction = ""),
        (this.reasoning = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName =
        "aiserver.v1.CodebaseKnowledgeCmdKInstructionFewShotPromptProps.Example"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "props", kind: "message", T: Iet },
        { no: 2, name: "instruction", kind: "scalar", T: 9 },
        { no: 3, name: "reasoning", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new TD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TD, t, e)
    }
  },
  Iet = class kD extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.currentFileLines = []),
        (this.startLineOneIndexedInclusive = 0),
        (this.endLineOneIndexedExclusive = 0),
        (this.groundTruthLines = []),
        (this.prHistory = []),
        (this.scoredCodebaseContext = []),
        (this.tokenLimit = 0),
        (this.tokenizer = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodebaseKnowledgeCmdKInstructionPromptProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "current_file_lines",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 3,
          name: "start_line_one_indexed_inclusive",
          kind: "scalar",
          T: 5,
        },
        { no: 4, name: "end_line_one_indexed_exclusive", kind: "scalar", T: 5 },
        {
          no: 5,
          name: "ground_truth_lines",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 6, name: "pr_history", kind: "message", T: Pet, repeated: !0 },
        {
          no: 7,
          name: "scored_codebase_context",
          kind: "message",
          T: fi,
          repeated: !0,
        },
        { no: 8, name: "token_limit", kind: "scalar", T: 5 },
        { no: 9, name: "tokenizer", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new kD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kD, t, e)
    }
  },
  lUt = class SD extends d {
    constructor(t) {
      super(), (this.codebaseContext = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ScoredCodebaseContext"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "codebase_context",
          kind: "message",
          T: fi,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new SD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SD, t, e)
    }
  },
  Pet = class bD extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.originalLines = []),
        (this.newLines = []),
        (this.startLineOneIndexed = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.PrHistoryItem"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "original_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "new_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "start_line_one_indexed", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new bD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bD, t, e)
    }
  },
  dUt = class ED extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.currentFileLines = []),
        (this.startLineOneIndexedInclusive = 0),
        (this.endLineOneIndexedExclusive = 0),
        (this.instruction = ""),
        (this.prHistory = []),
        (this.scoredCodebaseContext = []),
        (this.tokenLimit = 0),
        (this.tokenizer = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CodebaseKnowledgeCmdKPromptProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "current_file_lines",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        {
          no: 3,
          name: "start_line_one_indexed_inclusive",
          kind: "scalar",
          T: 5,
        },
        { no: 4, name: "end_line_one_indexed_exclusive", kind: "scalar", T: 5 },
        { no: 5, name: "instruction", kind: "scalar", T: 9 },
        { no: 6, name: "pr_history", kind: "message", T: Pet, repeated: !0 },
        {
          no: 7,
          name: "scored_codebase_context",
          kind: "message",
          T: fi,
          repeated: !0,
        },
        { no: 8, name: "token_limit", kind: "scalar", T: 5 },
        { no: 9, name: "tokenizer", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new ED().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ED().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ED().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ED, t, e)
    }
  },
  mUt = class ID extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Opus2ChainPlanPromptProps"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "request", kind: "message", T: bet },
        { no: 2, name: "plan", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ID().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ID().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ID().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ID, t, e)
    }
  },
  Net = {
    typeName: "aiserver.v1.HallucinatedFunctionsService",
    methods: {
      v0ChainRun: {
        name: "V0ChainRun",
        I: TRt,
        O: kRt,
        kind: E.ServerStreaming,
      },
      opus2ChainPlan: {
        name: "Opus2ChainPlan",
        I: bet,
        O: NRt,
        kind: E.ServerStreaming,
      },
      opus2ChainApplyPlan: {
        name: "Opus2ChainApplyPlan",
        I: uRt,
        O: lRt,
        kind: E.ServerStreaming,
      },
      opus2ChainReflect: {
        name: "Opus2ChainReflect",
        I: fRt,
        O: pRt,
        kind: E.ServerStreaming,
      },
      sortUsefulTypesNaive: {
        name: "SortUsefulTypesNaive",
        I: dRt,
        O: hRt,
        kind: E.Unary,
      },
    },
  },
  zU
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.PYTHON = 1)] = "PYTHON"),
    (i[(i.SHELL = 2)] = "SHELL")
})(zU || (zU = {})),
  n.util.setEnumType(zU, "aiserver.v1.InterpreterTool", [
    { no: 0, name: "INTERPRETER_TOOL_UNSPECIFIED" },
    { no: 1, name: "INTERPRETER_TOOL_PYTHON" },
    { no: 2, name: "INTERPRETER_TOOL_SHELL" },
  ])
var xRt = class PD extends d {
    constructor(t) {
      super(),
        (this.conversationUuid = ""),
        (this.userFeedback = oh.UNSPECIFIED),
        (this.userFeedbackDetails = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogInterpreterExplicitUserFeedbackRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "conversation_uuid", kind: "scalar", T: 9 },
        { no: 3, name: "user_feedback", kind: "enum", T: n.getEnumType(oh) },
        { no: 4, name: "user_feedback_details", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new PD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PD, t, e)
    }
  },
  oh
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.GOOD = 1)] = "GOOD"),
    (i[(i.OKAY = 2)] = "OKAY"),
    (i[(i.BAD = 3)] = "BAD")
})(oh || (oh = {})),
  n.util.setEnumType(
    oh,
    "aiserver.v1.LogInterpreterExplicitUserFeedbackRequest.Feedback",
    [
      { no: 0, name: "FEEDBACK_UNSPECIFIED" },
      { no: 1, name: "FEEDBACK_GOOD" },
      { no: 2, name: "FEEDBACK_OKAY" },
      { no: 3, name: "FEEDBACK_BAD" },
    ],
  )
var JRt = class ND extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogInterpreterExplicitUserFeedbackResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new ND().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ND().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ND().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ND, t, e)
    }
  },
  CRt = class $D extends d {
    constructor(t) {
      super(),
        (this.openFiles = []),
        (this.conversation = []),
        (this.documentationIdentifiers = []),
        (this.scoredCodebaseContext = []),
        (this.conversationUuid = ""),
        (this.quotes = []),
        (this.supportsShellTool = !1),
        (this.globalDescription = ""),
        (this.terminalCwd = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamInterpreterRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "open_files", kind: "message", T: LRt, repeated: !0 },
        { no: 2, name: "conversation", kind: "message", T: se, repeated: !0 },
        { no: 4, name: "explicit_context", kind: "message", T: Ne },
        { no: 7, name: "model_details", kind: "message", T: vt },
        {
          no: 8,
          name: "documentation_identifiers",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 11, name: "summary", kind: "scalar", T: 9, opt: !0 },
        {
          no: 12,
          name: "summary_up_until_index",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 13, name: "retry_instructions", kind: "scalar", T: 9, opt: !0 },
        {
          no: 14,
          name: "retry_previous_attempt",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        {
          no: 15,
          name: "scored_codebase_context",
          kind: "message",
          T: fi,
          repeated: !0,
        },
        {
          no: 16,
          name: "high_level_folder_description",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        { no: 17, name: "conversation_uuid", kind: "scalar", T: 9 },
        { no: 18, name: "cmd_k_debug_info", kind: "message", T: hr },
        { no: 19, name: "quotes", kind: "message", T: n7, repeated: !0 },
        { no: 20, name: "supports_shell_tool", kind: "scalar", T: 8 },
        { no: 21, name: "global_description", kind: "scalar", T: 9 },
        { no: 22, name: "terminal_cwd", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new $D().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $D().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $D().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($D, t, e)
    }
  },
  LRt = class xD extends d {
    constructor(t) {
      super(), (this.scrollTopLineNumber = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamInterpreterRequest.FileInfo"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "message", T: Ht },
        { no: 2, name: "scroll_top_line_number", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new xD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xD, t, e)
    }
  },
  RRt = class JD extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamInterpreterResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new JD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JD, t, e)
    }
  },
  $et = {
    typeName: "aiserver.v1.InterpreterService",
    methods: {
      streamInterpreter: {
        name: "StreamInterpreter",
        I: CRt,
        O: RRt,
        kind: E.ServerStreaming,
      },
      logInterpreterExplicitUserFeedback: {
        name: "LogInterpreterExplicitUserFeedback",
        I: xRt,
        O: JRt,
        kind: E.Unary,
      },
    },
  },
  xet = {
    typeName: "aiserver.v1.RepositoryService",
    methods: {
      fastRepoInitHandshake: {
        name: "FastRepoInitHandshake",
        I: rTt,
        O: nTt,
        kind: E.Unary,
      },
      syncMerkleSubtree: {
        name: "SyncMerkleSubtree",
        I: dTt,
        O: mTt,
        kind: E.Unary,
      },
      fastUpdateFile: { name: "FastUpdateFile", I: vTt, O: yTt, kind: E.Unary },
      searchRepositoryV2: {
        name: "SearchRepositoryV2",
        I: QZ,
        O: XZ,
        kind: E.Unary,
      },
      removeRepositoryV2: {
        name: "RemoveRepositoryV2",
        I: LTt,
        O: RTt,
        kind: E.Unary,
      },
      fastRepoInitHandshakeV2: {
        name: "FastRepoInitHandshakeV2",
        I: sTt,
        O: oTt,
        kind: E.Unary,
      },
      syncMerkleSubtreeV2: {
        name: "SyncMerkleSubtreeV2",
        I: fTt,
        O: pTt,
        kind: E.Unary,
      },
      fastUpdateFileV2: {
        name: "FastUpdateFileV2",
        I: TTt,
        O: STt,
        kind: E.Unary,
      },
      fastRepoSyncComplete: {
        name: "FastRepoSyncComplete",
        I: uTt,
        O: lTt,
        kind: E.Unary,
      },
      semSearchFast: {
        name: "SemSearchFast",
        I: KZ,
        O: ttt,
        kind: E.ServerStreaming,
      },
      semSearch: { name: "SemSearch", I: KZ, O: ttt, kind: E.ServerStreaming },
      ensureIndexCreated: {
        name: "EnsureIndexCreated",
        I: eTt,
        O: iTt,
        kind: E.Unary,
      },
      getHighLevelFolderDescription: {
        name: "GetHighLevelFolderDescription",
        I: K0t,
        O: tTt,
        kind: E.Unary,
      },
      getEmbeddings: { name: "GetEmbeddings", I: xTt, O: JTt, kind: E.Unary },
      getUploadLimits: {
        name: "GetUploadLimits",
        I: bTt,
        O: ETt,
        kind: E.Unary,
      },
      getNumFilesToSend: {
        name: "GetNumFilesToSend",
        I: ITt,
        O: PTt,
        kind: E.Unary,
      },
      getAvailableChunkingStrategies: {
        name: "GetAvailableChunkingStrategies",
        I: NTt,
        O: $Tt,
        kind: E.Unary,
      },
      getLineNumberClassifications: {
        name: "GetLineNumberClassifications",
        I: QTt,
        O: XTt,
        kind: E.ServerStreaming,
      },
    },
  },
  i8
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.IN_PROGRESS = 1)] = "IN_PROGRESS"),
    (i[(i.SUCCEEDED = 2)] = "SUCCEEDED"),
    (i[(i.FAILED = 3)] = "FAILED"),
    (i[(i.NOT_FOUND = 4)] = "NOT_FOUND")
})(i8 || (i8 = {})),
  n.util.setEnumType(i8, "aiserver.v1.UploadStatus", [
    { no: 0, name: "UPLOAD_STATUS_UNSPECIFIED" },
    { no: 1, name: "UPLOAD_STATUS_IN_PROGRESS" },
    { no: 2, name: "UPLOAD_STATUS_SUCCEEDED" },
    { no: 3, name: "UPLOAD_STATUS_FAILED" },
    { no: 4, name: "UPLOAD_STATUS_NOT_FOUND" },
  ])
var DRt = class CD extends d {
    constructor(t) {
      super(), (this.docIdentifier = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RescrapeDocsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
        { no: 2, name: "force_reupload", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new CD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CD, t, e)
    }
  },
  FRt = class LD extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RescrapeDocsRequestV2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "new_doc_req", kind: "message", T: Cet },
        { no: 2, name: "force_reupload", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new LD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LD, t, e)
    }
  },
  Jet = class RD extends d {
    constructor(t) {
      super(), (this.success = !1), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RescrapeDocsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "success", kind: "scalar", T: 8 },
        { no: 2, name: "new_doc_identifier", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new RD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new RD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new RD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(RD, t, e)
    }
  },
  _Rt = class DD extends d {
    constructor(t) {
      super(), (this.docIdentifier = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UploadedStatusRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new DD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new DD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new DD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(DD, t, e)
    }
  },
  ARt = class FD extends d {
    constructor(t) {
      super(), (this.docIdentifier = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UploadDocumentationRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new FD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new FD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new FD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(FD, t, e)
    }
  },
  BRt = class _D extends d {
    constructor(t) {
      super(), (this.docIdentifier = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetPagesRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new _D().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new _D().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new _D().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(_D, t, e)
    }
  },
  ORt = class AD extends d {
    constructor(t) {
      super(), (this.docIdentifier = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetDocRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new AD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new AD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new AD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(AD, t, e)
    }
  },
  qRt = class BD extends d {
    constructor(t) {
      super(),
        (this.id = 0),
        (this.uuid = ""),
        (this.docIdentifier = ""),
        (this.docName = ""),
        (this.docUrlRoot = ""),
        (this.docUrlPrefix = ""),
        (this.isDifferentPrefix = !1),
        (this.createdAt = ""),
        (this.updatedAt = ""),
        (this.lastUploadedAt = ""),
        (this.showToAllUsers = !1),
        (this.teamId = 0),
        (this.customInstructions = ""),
        (this.pages = []),
        (this.publishToTeam = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ProtoDoc"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 5 },
        { no: 2, name: "uuid", kind: "scalar", T: 9 },
        { no: 3, name: "doc_identifier", kind: "scalar", T: 9 },
        { no: 4, name: "doc_name", kind: "scalar", T: 9 },
        { no: 5, name: "doc_url_root", kind: "scalar", T: 9 },
        { no: 6, name: "doc_url_prefix", kind: "scalar", T: 9 },
        { no: 7, name: "is_different_prefix", kind: "scalar", T: 8 },
        { no: 8, name: "created_at", kind: "scalar", T: 9 },
        { no: 9, name: "updated_at", kind: "scalar", T: 9 },
        { no: 10, name: "last_uploaded_at", kind: "scalar", T: 9 },
        { no: 11, name: "upload_status", kind: "message", T: r8 },
        { no: 12, name: "show_to_all_users", kind: "scalar", T: 8 },
        { no: 13, name: "team_id", kind: "scalar", T: 5 },
        { no: 14, name: "custom_instructions", kind: "scalar", T: 9 },
        { no: 15, name: "pages", kind: "message", T: URt, repeated: !0 },
        { no: 16, name: "publish_to_team", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new BD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new BD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new BD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(BD, t, e)
    }
  },
  URt = class OD extends d {
    constructor(t) {
      super(), (this.url = ""), (this.title = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ProtoDocPage"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "url", kind: "scalar", T: 9 },
        { no: 2, name: "title", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new OD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new OD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new OD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(OD, t, e)
    }
  },
  MRt = class qD extends d {
    constructor(t) {
      super(),
        (this.pages = []),
        (this.pageUrls = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.Pages"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "pages", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "page_urls", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new qD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new qD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new qD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(qD, t, e)
    }
  },
  HRt = class UD extends d {
    constructor(t) {
      super(),
        (this.docIdentifier = ""),
        (this.password = ""),
        (this.docName = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.MarkAsPublicRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
        { no: 2, name: "password", kind: "scalar", T: 9 },
        { no: 3, name: "doc_name", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new UD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new UD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new UD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(UD, t, e)
    }
  },
  Cet = class MD extends d {
    constructor(t) {
      super(),
        (this.docIdentifier = ""),
        (this.ignorePrefixes = []),
        (this.ignoreUrls = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.NewDocumentationRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "doc_identifier", kind: "scalar", T: 9 },
        { no: 2, name: "metadata", kind: "message", T: ktt },
        { no: 4, name: "ignore_prefixes", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "ignore_urls", kind: "scalar", T: 9, repeated: !0 },
        { no: 6, name: "custom_instructions", kind: "scalar", T: 9, opt: !0 },
        { no: 7, name: "publish_to_team", kind: "scalar", T: 8, opt: !0 },
        { no: 8, name: "client_handles_uuid", kind: "scalar", T: 8, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new MD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new MD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new MD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(MD, t, e)
    }
  },
  Let = class HD extends d {
    constructor(t) {
      super(),
        (this.status = ch.UNSPECIFIED),
        (this.progress = 0),
        (this.similarDocIdentifier = ""),
        (this.uploadedPages = []),
        (this.docUuid = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UploadResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(ch) },
        { no: 2, name: "progress", kind: "scalar", T: 2 },
        { no: 3, name: "similar_doc_identifier", kind: "scalar", T: 9 },
        { no: 4, name: "uploaded_pages", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "doc_uuid", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new HD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new HD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new HD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(HD, t, e)
    }
  },
  ch
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.SUCCESS = 1)] = "SUCCESS"),
    (i[(i.FAILURE = 2)] = "FAILURE"),
    (i[(i.ALREADY_EXISTS = 3)] = "ALREADY_EXISTS"),
    (i[(i.SIMILAR_ALREADY_EXISTS = 4)] = "SIMILAR_ALREADY_EXISTS")
})(ch || (ch = {})),
  n.util.setEnumType(ch, "aiserver.v1.UploadResponse.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_SUCCESS" },
    { no: 2, name: "STATUS_FAILURE" },
    { no: 3, name: "STATUS_ALREADY_EXISTS" },
    { no: 4, name: "STATUS_SIMILAR_ALREADY_EXISTS" },
  ])
var r8 = class WD extends d {
    constructor(t) {
      super(),
        (this.status = uh.UNSPECIFIED),
        (this.uploadedPages = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UploadedStatus"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "status", kind: "enum", T: n.getEnumType(uh) },
        { no: 2, name: "uploaded_pages", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new WD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new WD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new WD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(WD, t, e)
    }
  },
  uh
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.IN_PROGRESS = 1)] = "IN_PROGRESS"),
    (i[(i.SUCCEEDED = 2)] = "SUCCEEDED"),
    (i[(i.FAILED = 3)] = "FAILED"),
    (i[(i.NOT_FOUND = 4)] = "NOT_FOUND")
})(uh || (uh = {})),
  n.util.setEnumType(uh, "aiserver.v1.UploadedStatus.Status", [
    { no: 0, name: "STATUS_UNSPECIFIED" },
    { no: 1, name: "STATUS_IN_PROGRESS" },
    { no: 2, name: "STATUS_SUCCEEDED" },
    { no: 3, name: "STATUS_FAILED" },
    { no: 4, name: "STATUS_NOT_FOUND" },
  ])
var WRt = class jD extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpsertDocsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        {
          no: 1,
          name: "upload_status",
          kind: "enum",
          T: n.getEnumType(i8),
          opt: !0,
        },
        { no: 2, name: "ignore_index_prefix", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "doc_id", kind: "scalar", T: 5, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new jD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new jD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new jD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(jD, t, e)
    }
  },
  jRt = class VD extends d {
    constructor(t) {
      super(), (this.responses = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.UpsertDocsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "responses", kind: "message", T: Let, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new VD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new VD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new VD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(VD, t, e)
    }
  },
  Ret = {
    typeName: "aiserver.v1.UploadService",
    methods: {
      uploadDocumentation: {
        name: "UploadDocumentation",
        I: Cet,
        O: Let,
        kind: E.Unary,
      },
      uploadDocumentationStatus: {
        name: "UploadDocumentationStatus",
        I: ARt,
        O: r8,
        kind: E.Unary,
      },
      markAsPublic: { name: "MarkAsPublic", I: HRt, O: r8, kind: E.Unary },
      uploadStatus: { name: "UploadStatus", I: _Rt, O: r8, kind: E.Unary },
      getPages: { name: "GetPages", I: BRt, O: MRt, kind: E.Unary },
      getDoc: { name: "GetDoc", I: ORt, O: qRt, kind: E.Unary },
      rescrapeDocs: { name: "RescrapeDocs", I: DRt, O: Jet, kind: E.Unary },
      rescrapeDocsV2: { name: "RescrapeDocsV2", I: FRt, O: Jet, kind: E.Unary },
      upsertAllDocs: { name: "UpsertAllDocs", I: WRt, O: jRt, kind: E.Unary },
    },
  },
  Det = {
    typeName: "aiserver.v1.MetricsService",
    methods: {
      reportIncrement: { name: "ReportIncrement", I: t8, O: e8, kind: E.Unary },
      reportDecrement: { name: "ReportDecrement", I: t8, O: e8, kind: E.Unary },
      reportDistribution: {
        name: "ReportDistribution",
        I: t8,
        O: e8,
        kind: E.Unary,
      },
      reportGauge: { name: "ReportGauge", I: t8, O: e8, kind: E.Unary },
    },
  },
  Fet = {
    typeName: "aiserver.v1.LinterService",
    methods: {
      lintFile: { name: "LintFile", I: tNt, O: iNt, kind: E.Unary },
      lintChunk: { name: "LintChunk", I: QPt, O: XPt, kind: E.Unary },
      lintFimChunk: { name: "LintFimChunk", I: KPt, O: ZPt, kind: E.Unary },
      lintExplanation: {
        name: "LintExplanation",
        I: Utt,
        O: zPt,
        kind: E.ServerStreaming,
      },
      lintExplanation2: {
        name: "LintExplanation2",
        I: Utt,
        O: YPt,
        kind: E.Unary,
      },
    },
  },
  _et = {
    typeName: "aiserver.v1.ExperimentService",
    methods: {
      specedits1: { name: "Specedits1", I: A5t, O: B5t, kind: E.Unary },
      simple: { name: "Simple", I: O5t, O: q5t, kind: E.Unary },
      streamHeadlessAgenticComposer: {
        name: "StreamHeadlessAgenticComposer",
        I: G5t,
        O: z5t,
        kind: E.ServerStreaming,
      },
    },
  },
  VRt = class GD extends d {
    constructor(t) {
      super(), (this.stackTrace = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogWhenTabTurnsOffRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "stack_trace", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new GD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new GD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new GD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(GD, t, e)
    }
  },
  GRt = class zD extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.LogWhenTabTurnsOffResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new zD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new zD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new zD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(zD, t, e)
    }
  },
  Aet = {
    typeName: "aiserver.v1.ClientLoggerService",
    methods: {
      logWhenTabTurnsOff: {
        name: "LogWhenTabTurnsOff",
        I: VRt,
        O: GRt,
        kind: E.Unary,
      },
    },
  },
  zRt = class YD extends d {
    constructor(t) {
      super(), (this.authId = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteUserRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "auth_id", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new YD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new YD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new YD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(YD, t, e)
    }
  },
  YRt = class QD extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.DeleteUserResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new QD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new QD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new QD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(QD, t, e)
    }
  },
  QRt = class XD extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTailscaleSSHRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new XD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new XD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new XD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(XD, t, e)
    }
  },
  XRt = class KD extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.RunTailscaleSSHResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new KD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new KD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new KD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(KD, t, e)
    }
  },
  KRt = class ZD extends d {
    constructor(t) {
      super(),
        (this.teamId = 0),
        (this.authIds = []),
        (this.workosIds = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddAuthIdsToTeamRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "team_id", kind: "scalar", T: 5 },
        { no: 2, name: "auth_ids", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "workos_ids", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new ZD().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new ZD().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new ZD().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(ZD, t, e)
    }
  },
  ZRt = class tF extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AddAuthIdsToTeamResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new tF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new tF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new tF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(tF, t, e)
    }
  },
  Bet = {
    typeName: "aiserver.v1.AdminService",
    methods: {
      deleteUser: { name: "DeleteUser", I: zRt, O: YRt, kind: E.Unary },
      runTailscaleSSH: {
        name: "RunTailscaleSSH",
        I: QRt,
        O: XRt,
        kind: E.Unary,
      },
      addAuthIdsToTeam: {
        name: "AddAuthIdsToTeam",
        I: KRt,
        O: ZRt,
        kind: E.Unary,
      },
    },
  },
  tDt = class eF extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CursorPredictionConfigRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new eF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new eF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new eF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(eF, t, e)
    }
  },
  eDt = class iF extends d {
    constructor(t) {
      super(), (this.name = ""), (this.radius = 0), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CursorPredictionModel"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "radius", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new iF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new iF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new iF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(iF, t, e)
    }
  },
  iDt = class rF extends d {
    constructor(t) {
      super(),
        (this.models = []),
        (this.defaultModel = ""),
        (this.heuristics = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.CursorPredictionConfigResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "models", kind: "message", T: eDt, repeated: !0 },
        { no: 2, name: "default_model", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "heuristics",
          kind: "enum",
          T: n.getEnumType(n8),
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new rF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new rF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new rF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(rF, t, e)
    }
  },
  n8
;(function (i) {
  ;(i[(i.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (i[(i.DISABLE_IN_LAST_CPP_SUGGESTION = 1)] =
      "DISABLE_IN_LAST_CPP_SUGGESTION")
})(n8 || (n8 = {})),
  n.util.setEnumType(
    n8,
    "aiserver.v1.CursorPredictionConfigResponse.Heuristic",
    [
      { no: 0, name: "HEURISTIC_UNSPECIFIED" },
      { no: 1, name: "HEURISTIC_DISABLE_IN_LAST_CPP_SUGGESTION" },
    ],
  )
var Oet = {
    typeName: "aiserver.v1.CursorPredictionService",
    methods: {
      cursorPredictionConfig: {
        name: "CursorPredictionConfig",
        I: tDt,
        O: iDt,
        kind: E.Unary,
      },
    },
  },
  rDt = class nF extends d {
    constructor(t) {
      super(),
        (this.telemEnabled = !1),
        (this.bugBotDismissedNotificationLast10TimesUnixMs = []),
        (this.bugBotViewedNotificationLast10TimesUnixMs = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugConfigRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "telem_enabled", kind: "scalar", T: 8 },
        {
          no: 2,
          name: "bug_bot_dismissed_notification_last_10_times_unix_ms",
          kind: "scalar",
          T: 1,
          repeated: !0,
        },
        {
          no: 3,
          name: "bug_bot_viewed_notification_last_10_times_unix_ms",
          kind: "scalar",
          T: 1,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new nF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new nF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new nF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(nF, t, e)
    }
  },
  qet = class sF extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugConfigResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "linter_strategy_v1", kind: "message", T: nDt },
        { no: 2, name: "bug_bot_v1", kind: "message", T: aDt },
        { no: 3, name: "linter_strategy_v2", kind: "message", T: sDt },
      ])
    }
    static fromBinary(t, e) {
      return new sF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new sF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new sF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(sF, t, e)
    }
  },
  nDt = class aF extends d {
    constructor(t) {
      super(),
        (this.enabled = !1),
        (this.tryTriggerOnSave = !1),
        (this.waitBetweenTriggersMs = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugConfigResponse.LinterStrategyV1"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "enabled", kind: "scalar", T: 8 },
        { no: 2, name: "try_trigger_on_save", kind: "scalar", T: 8 },
        { no: 3, name: "wait_between_triggers_ms", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new aF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new aF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new aF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(aF, t, e)
    }
  },
  sDt = class oF extends d {
    constructor(t) {
      super(),
        (this.enabled = !1),
        (this.waitBetweenTriggersMs = 0),
        (this.debounceTriggersMs = 0),
        (this.keepLinesAroundChunk = 0),
        (this.preventTriggeringForFilesWithThisManyLines = 0),
        (this.preventTriggeringWhenLints = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugConfigResponse.LinterStrategyV2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "enabled", kind: "scalar", T: 8 },
        { no: 2, name: "wait_between_triggers_ms", kind: "scalar", T: 1 },
        { no: 3, name: "debounce_triggers_ms", kind: "scalar", T: 1 },
        { no: 4, name: "keep_lines_around_chunk", kind: "scalar", T: 5 },
        {
          no: 5,
          name: "prevent_triggering_for_files_with_this_many_lines",
          kind: "scalar",
          T: 5,
        },
        { no: 6, name: "prevent_triggering_when_lints", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new oF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new oF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new oF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(oF, t, e)
    }
  },
  aDt = class cF extends d {
    constructor(t) {
      super(),
        (this.enabled = !1),
        (this.isSubsidized = !1),
        (this.backgroundCallFrequencyMs = 0),
        (this.killSwitch = !1),
        (this.showIntrusiveNotificationOnlyIfLastTimeWasMoreThanMsAgo = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.BugConfigResponse.BugBotV1"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "enabled", kind: "scalar", T: 8 },
        { no: 2, name: "is_subsidized", kind: "scalar", T: 8 },
        { no: 3, name: "background_call_frequency_ms", kind: "scalar", T: 5 },
        { no: 4, name: "kill_switch", kind: "scalar", T: 8 },
        {
          no: 5,
          name: "show_intrusive_notification_only_if_last_time_was_more_than_ms_ago",
          kind: "scalar",
          T: 1,
        },
        {
          no: 6,
          name: "background_diff_absolute_max_tokens",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 7,
          name: "background_diff_min_min_token_threshold",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 8,
          name: "background_diff_min_max_token_threshold",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 9,
          name: "background_diff_last_commit_less_than_this_many_ms_ago",
          kind: "scalar",
          T: 1,
          opt: !0,
        },
        {
          no: 15,
          name: "background_unified_context_lines",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 16,
          name: "background_diff_include_uncommitted",
          kind: "scalar",
          T: 8,
          opt: !0,
        },
        {
          no: 10,
          name: "default_diff_context_lines",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 11,
          name: "diff_absolute_max_tokens",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 12,
          name: "custom_instructions_max_char_length",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 13,
          name: "default_fallback_iterations",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 14,
          name: "threshold_for_expensive_run_modal_cents",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        { no: 17, name: "cheap_model_name", kind: "scalar", T: 9, opt: !0 },
        {
          no: 18,
          name: "cheap_absolute_max_tokens",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
        {
          no: 19,
          name: "expensive_absolute_max_tokens",
          kind: "scalar",
          T: 5,
          opt: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new cF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new cF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new cF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(cF, t, e)
    }
  },
  oDt = class uF extends d {
    constructor(t) {
      super(),
        (this.activeFile = ""),
        (this.cursorLineNumberOneIndexed = 0),
        (this.telemEnabled = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugBotLinterRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "git_diff", kind: "message", T: i7 },
        { no: 2, name: "active_file", kind: "scalar", T: 9 },
        { no: 3, name: "cursor_line_number_one_indexed", kind: "scalar", T: 5 },
        { no: 4, name: "session_id", kind: "scalar", T: 9, opt: !0 },
        { no: 5, name: "telem_enabled", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new uF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new uF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new uF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(uF, t, e)
    }
  },
  cDt = class lF extends d {
    constructor(t) {
      super(), (this.bugs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugBotLinterResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bugs", kind: "message", T: c7, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new lF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new lF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new lF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(lF, t, e)
    }
  },
  uDt = class dF extends d {
    constructor(t) {
      super(),
        (this.diffString = ""),
        (this.oldStart = 0),
        (this.newStart = 0),
        (this.oldLines = 0),
        (this.newLines = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChunkDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "diff_string", kind: "scalar", T: 9 },
        { no: 2, name: "old_start", kind: "scalar", T: 5 },
        { no: 3, name: "new_start", kind: "scalar", T: 5 },
        { no: 4, name: "old_lines", kind: "scalar", T: 5 },
        { no: 5, name: "new_lines", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new dF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new dF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new dF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(dF, t, e)
    }
  },
  Uet = class mF extends d {
    constructor(t) {
      super(), (this.fileDiffs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewRequestV2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_diffs", kind: "message", T: lDt, repeated: !0 },
        { no: 2, name: "linter_rules", kind: "scalar", T: 9, opt: !0 },
        { no: 3, name: "also_find_hard_bugs", kind: "scalar", T: 8, opt: !0 },
        { no: 4, name: "save_request_as", kind: "scalar", T: 9, opt: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new mF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new mF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new mF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(mF, t, e)
    }
  },
  lDt = class hF extends d {
    constructor(t) {
      super(), (this.chunkDiffs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewRequestV2.FileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "message", T: nr },
        { no: 2, name: "chunk_diffs", kind: "message", T: uDt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new hF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new hF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new hF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(hF, t, e)
    }
  },
  Met = class fF extends d {
    constructor(t) {
      super(),
        (this.id = ""),
        (this.chunkId = ""),
        (this.relativeWorkspacePath = ""),
        (this.startLine = 0),
        (this.endLine = 0),
        (this.description = ""),
        (this.severity = 0),
        (this.tldr = ""),
        (this.diff = ""),
        (this.fullChunkStartLine = 0),
        (this.fullChunkEndLine = 0),
        (this.fullChunkTotalLines = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewBugV2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 9 },
        { no: 2, name: "chunk_id", kind: "scalar", T: 9 },
        { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 4, name: "start_line", kind: "scalar", T: 5 },
        { no: 5, name: "end_line", kind: "scalar", T: 5 },
        { no: 6, name: "description", kind: "scalar", T: 9 },
        { no: 7, name: "severity", kind: "scalar", T: 5 },
        { no: 8, name: "tldr", kind: "scalar", T: 9 },
        { no: 9, name: "diff", kind: "scalar", T: 9 },
        { no: 10, name: "full_chunk_start_line", kind: "scalar", T: 5 },
        { no: 11, name: "full_chunk_end_line", kind: "scalar", T: 5 },
        { no: 12, name: "full_chunk_total_lines", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new fF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new fF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new fF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(fF, t, e)
    }
  },
  Het = class pF extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewResponseV2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug", kind: "message", T: Met },
      ])
    }
    static fromBinary(t, e) {
      return new pF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new pF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new pF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(pF, t, e)
    }
  },
  dDt = class gF extends d {
    constructor(t) {
      super(), (this.messages = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewChatRequestV2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file", kind: "message", T: nr },
        { no: 2, name: "bug", kind: "message", T: Met },
        { no: 3, name: "linter_rules", kind: "scalar", T: 9, opt: !0 },
        { no: 4, name: "messages", kind: "message", T: tet, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new gF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new gF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new gF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(gF, t, e)
    }
  },
  mDt = class vF extends d {
    constructor(t) {
      super(), (this.text = ""), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ReviewChatResponseV2"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new vF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new vF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new vF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(vF, t, e)
    }
  },
  hDt = class wF extends d {
    constructor(t) {
      super(), (this.bugs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugFindingResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bugs", kind: "message", T: fDt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new wF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new wF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new wF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(wF, t, e)
    }
  },
  fDt = class yF extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.startLine = 0),
        (this.endLineInclusive = 0),
        (this.codeLines = []),
        (this.severity = 0),
        (this.confidence = 0),
        (this.description = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugFindingResponse.Bug"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "start_line", kind: "scalar", T: 5 },
        { no: 3, name: "end_line_inclusive", kind: "scalar", T: 5 },
        { no: 4, name: "code_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 5, name: "severity", kind: "scalar", T: 1 },
        { no: 6, name: "confidence", kind: "scalar", T: 1 },
        { no: 7, name: "description", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new yF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new yF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new yF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(yF, t, e)
    }
  },
  pDt = class TF extends d {
    constructor(t) {
      super(), (this.fileDiffs = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugFindingRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "file_diffs", kind: "message", T: gDt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new TF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new TF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new TF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(TF, t, e)
    }
  },
  gDt = class kF extends d {
    constructor(t) {
      super(),
        (this.relativeWorkspacePath = ""),
        (this.lines = []),
        (this.hunks = []),
        (this.notTruncated = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugFindingRequest.FileDiff"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 },
        { no: 2, name: "lines", kind: "message", T: wDt, repeated: !0 },
        { no: 3, name: "hunks", kind: "message", T: vDt, repeated: !0 },
        {
          no: 4,
          name: "old_relative_workspace_path",
          kind: "scalar",
          T: 9,
          opt: !0,
        },
        { no: 5, name: "not_truncated", kind: "scalar", T: 8 },
      ])
    }
    static fromBinary(t, e) {
      return new kF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new kF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new kF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(kF, t, e)
    }
  },
  vDt = class SF extends d {
    constructor(t) {
      super(),
        (this.oldStartOneIndexed = 0),
        (this.newStartOneIndexed = 0),
        (this.oldLines = []),
        (this.newLines = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugFindingRequest.FileDiff.Hunk"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "old_start_one_indexed", kind: "scalar", T: 5 },
        { no: 2, name: "new_start_one_indexed", kind: "scalar", T: 5 },
        { no: 3, name: "old_lines", kind: "scalar", T: 9, repeated: !0 },
        { no: 4, name: "new_lines", kind: "scalar", T: 9, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new SF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new SF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new SF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(SF, t, e)
    }
  },
  wDt = class bF extends d {
    constructor(t) {
      super(),
        (this.oneIndexedLineNumber = 0),
        (this.line = ""),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.StreamBugFindingRequest.FileDiff.Line"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "one_indexed_line_number", kind: "scalar", T: 5 },
        { no: 2, name: "line", kind: "scalar", T: 9 },
      ])
    }
    static fromBinary(t, e) {
      return new bF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new bF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new bF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(bF, t, e)
    }
  },
  Wet = {
    typeName: "aiserver.v1.ReviewService",
    methods: {
      streamReview: {
        name: "StreamReview",
        I: Uet,
        O: Het,
        kind: E.ServerStreaming,
      },
      streamReviewChat: {
        name: "StreamReviewChat",
        I: dDt,
        O: mDt,
        kind: E.ServerStreaming,
      },
      streamSlowReview: {
        name: "StreamSlowReview",
        I: Uet,
        O: Het,
        kind: E.ServerStreaming,
      },
      bugConfig: { name: "BugConfig", I: rDt, O: qet, kind: E.Unary },
      streamBugBotLinter: {
        name: "StreamBugBotLinter",
        I: oDt,
        O: cDt,
        kind: E.ServerStreaming,
      },
      streamBugFinding: {
        name: "StreamBugFinding",
        I: pDt,
        O: hDt,
        kind: E.ServerStreaming,
      },
    },
  },
  jet = {
    typeName: "aiserver.v1.FastApplyService",
    methods: {
      reportEditFate: { name: "ReportEditFate", I: WPt, O: jPt, kind: E.Unary },
      warmApply: { name: "WarmApply", I: VPt, O: GPt, kind: E.Unary },
    },
  },
  yDt = class EF extends d {
    constructor(t) {
      super(),
        (this.maxConcurrentUploads = 0),
        (this.absoluteMaxNumberFiles = 0),
        (this.maxFileRetries = 0),
        (this.syncConcurrency = 0),
        (this.autoIndexingMaxNumFiles = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.IndexingConfig"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "max_concurrent_uploads", kind: "scalar", T: 5 },
        { no: 2, name: "absolute_max_number_files", kind: "scalar", T: 5 },
        { no: 3, name: "max_file_retries", kind: "scalar", T: 5 },
        { no: 4, name: "sync_concurrency", kind: "scalar", T: 5 },
        { no: 5, name: "auto_indexing_max_num_files", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new EF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new EF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new EF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(EF, t, e)
    }
  },
  TDt = class IF extends d {
    constructor(t) {
      super(),
        (this.globalSampleRate = 0),
        (this.tracesSampleRate = 0),
        (this.loggerSampleRate = 0),
        (this.minidumpSampleRate = 0),
        (this.errorRateLimit = 0),
        (this.performanceUnitRateLimit = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ClientTracingConfig"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "global_sample_rate", kind: "scalar", T: 1 },
        { no: 2, name: "traces_sample_rate", kind: "scalar", T: 1 },
        { no: 3, name: "logger_sample_rate", kind: "scalar", T: 1 },
        { no: 4, name: "minidump_sample_rate", kind: "scalar", T: 1 },
        { no: 5, name: "error_rate_limit", kind: "scalar", T: 1 },
        { no: 6, name: "performance_unit_rate_limit", kind: "scalar", T: 1 },
      ])
    }
    static fromBinary(t, e) {
      return new IF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new IF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new IF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(IF, t, e)
    }
  },
  kDt = class PF extends d {
    constructor(t) {
      super(),
        (this.disableUnification = !1),
        (this.fullContextTokenLimit = 0),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.ChatConfig"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "disable_unification", kind: "scalar", T: 8 },
        { no: 2, name: "full_context_token_limit", kind: "scalar", T: 5 },
      ])
    }
    static fromBinary(t, e) {
      return new PF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new PF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new PF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(PF, t, e)
    }
  },
  SDt = class NF extends d {
    constructor(t) {
      super(),
        (this.telemEnabled = !1),
        (this.bugBotDismissedNotificationLast10TimesUnixMs = []),
        (this.bugBotViewedNotificationLast10TimesUnixMs = []),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetServerConfigRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "telem_enabled", kind: "scalar", T: 8 },
        {
          no: 2,
          name: "bug_bot_dismissed_notification_last_10_times_unix_ms",
          kind: "scalar",
          T: 1,
          repeated: !0,
        },
        {
          no: 3,
          name: "bug_bot_viewed_notification_last_10_times_unix_ms",
          kind: "scalar",
          T: 1,
          repeated: !0,
        },
      ])
    }
    static fromBinary(t, e) {
      return new NF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new NF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new NF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(NF, t, e)
    }
  },
  bDt = class $F extends d {
    constructor(t) {
      super(),
        (this.isDevDoNotUseForSecretThingsBecauseCanBeSpoofedByUsers = !1),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.GetServerConfigResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "bug_config_response", kind: "message", T: qet },
        {
          no: 2,
          name: "is_dev_do_not_use_for_secret_things_because_can_be_spoofed_by_users",
          kind: "scalar",
          T: 8,
        },
        { no: 3, name: "indexing_config", kind: "message", T: yDt },
        { no: 4, name: "client_tracing_config", kind: "message", T: TDt },
        { no: 5, name: "chat_config", kind: "message", T: kDt },
      ])
    }
    static fromBinary(t, e) {
      return new $F().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new $F().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new $F().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals($F, t, e)
    }
  },
  Vet = {
    typeName: "aiserver.v1.ServerConfigService",
    methods: {
      getServerConfig: {
        name: "GetServerConfig",
        I: SDt,
        O: bDt,
        kind: E.Unary,
      },
    },
  },
  Get = {
    typeName: "aiserver.v1.ChatService",
    methods: {
      streamUnifiedChat: {
        name: "StreamUnifiedChat",
        I: OU,
        O: Ntt,
        kind: E.ServerStreaming,
      },
      streamUnifiedChatWithTools: {
        name: "StreamUnifiedChatWithTools",
        I: VEt,
        O: GEt,
        kind: E.BiDiStreaming,
      },
      streamParallelApply: {
        name: "StreamParallelApply",
        I: WEt,
        O: jEt,
        kind: E.ServerStreaming,
      },
      getConversationSummary: {
        name: "GetConversationSummary",
        I: OU,
        O: Mn,
        kind: E.Unary,
      },
    },
  },
  EDt = class xF extends d {
    constructor(t) {
      super(), (this.data = { case: void 0 }), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.EventData"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "string_value", kind: "scalar", T: 9, oneof: "data" },
        { no: 2, name: "int_value", kind: "scalar", T: 3, oneof: "data" },
        { no: 3, name: "bool_value", kind: "scalar", T: 8, oneof: "data" },
        { no: 4, name: "double_value", kind: "scalar", T: 1, oneof: "data" },
      ])
    }
    static fromBinary(t, e) {
      return new xF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new xF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new xF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(xF, t, e)
    }
  },
  IDt = class JF extends d {
    constructor(t) {
      super(),
        (this.eventName = ""),
        (this.eventData = {}),
        (this.timestamp = Pe.zero),
        n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.AnalyticsEvent"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "event_name", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "event_data",
          kind: "map",
          K: 9,
          V: { kind: "message", T: EDt },
        },
        { no: 3, name: "timestamp", kind: "scalar", T: 3 },
      ])
    }
    static fromBinary(t, e) {
      return new JF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new JF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new JF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(JF, t, e)
    }
  },
  PDt = class CF extends d {
    constructor(t) {
      super(), (this.events = []), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TrackEventsRequest"
    }
    static {
      this.fields = n.util.newFieldList(() => [
        { no: 1, name: "events", kind: "message", T: IDt, repeated: !0 },
      ])
    }
    static fromBinary(t, e) {
      return new CF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new CF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new CF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(CF, t, e)
    }
  },
  NDt = class LF extends d {
    constructor(t) {
      super(), n.util.initPartial(t, this)
    }
    static {
      this.runtime = n
    }
    static {
      this.typeName = "aiserver.v1.TrackEventsResponse"
    }
    static {
      this.fields = n.util.newFieldList(() => [])
    }
    static fromBinary(t, e) {
      return new LF().fromBinary(t, e)
    }
    static fromJson(t, e) {
      return new LF().fromJson(t, e)
    }
    static fromJsonString(t, e) {
      return new LF().fromJsonString(t, e)
    }
    static equals(t, e) {
      return n.util.equals(LF, t, e)
    }
  },
  zet = {
    typeName: "aiserver.v1.AnalyticsService",
    methods: {
      trackEvents: { name: "TrackEvents", I: PDt, O: NDt, kind: E.Unary },
    },
  },
  Yet = {
    [met.typeName]: met,
    [pet.typeName]: pet,
    [fet.typeName]: fet,
    [zet.typeName]: zet,
    [get.typeName]: get,
    [Get.typeName]: Get,
    [vet.typeName]: vet,
    [xet.typeName]: xet,
    [Bet.typeName]: Bet,
    [ytt.typeName]: ytt,
    [Ttt.typeName]: Ttt,
    [wet.typeName]: wet,
    [_et.typeName]: _et,
    [Tet.typeName]: Tet,
    [Net.typeName]: Net,
    [$et.typeName]: $et,
    [Fet.typeName]: Fet,
    [Kd.typeName]: Kd,
    [Det.typeName]: Det,
    [Ret.typeName]: Ret,
    [Oet.typeName]: Oet,
    [Wet.typeName]: Wet,
    [jet.typeName]: jet,
    [Aet.typeName]: Aet,
    [Vet.typeName]: Vet,
  },
  $Dt = class {
    constructor(i) {
      ;(this.g = i),
        (this.a = []),
        (this.c = void 0),
        (this.d = void 0),
        (this.f = !1),
        (this.h = void 0),
        (this.b = new Promise((t, e) => {
          ;(this.c = t), (this.d = e)
        }))
    }
    push(i) {
      this.a.push(i), this.c && this.c()
    }
    end() {
      this.c && this.c(), (this.f = !0)
    }
    error(i) {
      this.d && this.d(i), (this.h = i)
    }
    i() {
      const i = this
      this.b = new Promise((t, e) => {
        ;(this.c = t), (this.d = e)
      }).catch((t) => {
        i.h = t
      })
    }
    [Symbol.asyncIterator]() {
      const i = this.g
      return {
        next: async () => {
          try {
            if (this.h !== void 0) throw this.h
            if (this.a.length > 0) return { done: !1, value: this.a.shift() }
            if (this.f) return { done: !0, value: void 0 }
            const t = await Promise.race([
              this.b.then(() => !1),
              new Promise((e) => setTimeout(() => e(!0), i)),
            ])
            if (this.h !== void 0) throw this.h
            if (this.a.length > 0) return { done: !1, value: this.a.shift() }
            if (t || this.f) return { done: !0, value: void 0 }
            throw new Error("AsyncIterPushable: should not be here")
          } finally {
            this.i()
          }
        },
      }
    }
  },
  xDt = 1e6,
  hUt = Date.now(),
  YU =
    "src.vs.platform.reactivestorage.browser.reactiveStorageServiceImpl.persistentStorage",
  fUt = `${YU}.applicationUser`,
  pUt = `${YU}.workspaceUser`,
  gUt = `${YU}.applicationUser.subscription`,
  JDt = "workbench.panel.aichat.view",
  vUt = JDt + ".aichat.chatdata"
function Hn() {
  return globalThis._CURSOR_SENTRY
}
function CDt() {
  return {
    send: function (t) {
      const e = Hn().buffer
      return e.length < 64 && e.push(t), Promise.resolve({ statusCode: 200 })
    },
    flush: function (t) {
      return Promise.resolve(!0)
    },
  }
}
globalThis._CURSOR_SENTRY === void 0 &&
  (globalThis._CURSOR_SENTRY = {
    buffer: [],
    enabled: !0,
    loggerSampleRate: 1,
    sentry: void 0,
    tracesSampleRate: 0.01,
    transport: CDt(),
  })
var Qet = Object.prototype.toString
function _c(i) {
  switch (Qet.call(i)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
    case "[object WebAssembly.Exception]":
      return !0
    default:
      return Va(i, Error)
  }
}
function QU(i, t) {
  return Qet.call(i) === `[object ${t}]`
}
function lh(i) {
  return QU(i, "String")
}
function dh(i) {
  return QU(i, "Object")
}
function LDt(i) {
  return typeof Event < "u" && Va(i, Event)
}
function RDt(i) {
  return typeof Element < "u" && Va(i, Element)
}
function DDt(i) {
  return QU(i, "RegExp")
}
function XU(i) {
  return !!(i && i.then && typeof i.then == "function")
}
function FDt(i) {
  return (
    dh(i) &&
    "nativeEvent" in i &&
    "preventDefault" in i &&
    "stopPropagation" in i
  )
}
function Va(i, t) {
  try {
    return i instanceof t
  } catch {
    return !1
  }
}
function Xet(i) {
  return !!(typeof i == "object" && i !== null && (i.__isVue || i._isVue))
}
function KU(i, t = 0) {
  return typeof i != "string" || t === 0 || i.length <= t
    ? i
    : `${i.slice(0, t)}...`
}
function Ket(i, t) {
  if (!Array.isArray(i)) return ""
  const e = []
  for (let r = 0; r < i.length; r++) {
    const s = i[r]
    try {
      Xet(s) ? e.push("[VueViewModel]") : e.push(String(s))
    } catch {
      e.push("[value cannot be serialized]")
    }
  }
  return e.join(t)
}
function _Dt(i, t, e = !1) {
  return lh(i)
    ? DDt(t)
      ? t.test(i)
      : lh(t)
        ? e
          ? i === t
          : i.includes(t)
        : !1
    : !1
}
function s8(i, t = [], e = !1) {
  return t.some((r) => _Dt(i, r, e))
}
function ADt(i, t, e = 250, r, s, a, o) {
  if (
    !a.exception ||
    !a.exception.values ||
    !o ||
    !Va(o.originalException, Error)
  )
    return
  const c =
    a.exception.values.length > 0
      ? a.exception.values[a.exception.values.length - 1]
      : void 0
  c &&
    (a.exception.values = BDt(
      ZU(i, t, s, o.originalException, r, a.exception.values, c, 0),
      e,
    ))
}
function ZU(i, t, e, r, s, a, o, c) {
  if (a.length >= e + 1) return a
  let u = [...a]
  if (Va(r[s], Error)) {
    Zet(o, c)
    const l = i(t, r[s]),
      m = u.length
    tit(l, s, m, c), (u = ZU(i, t, e, r[s], s, [l, ...u], l, m))
  }
  return (
    Array.isArray(r.errors) &&
      r.errors.forEach((l, m) => {
        if (Va(l, Error)) {
          Zet(o, c)
          const h = i(t, l),
            p = u.length
          tit(h, `errors[${m}]`, p, c), (u = ZU(i, t, e, l, s, [h, ...u], h, p))
        }
      }),
    u
  )
}
function Zet(i, t) {
  ;(i.mechanism = i.mechanism || { type: "generic", handled: !0 }),
    (i.mechanism = {
      ...i.mechanism,
      ...(i.type === "AggregateError" && { is_exception_group: !0 }),
      exception_id: t,
    })
}
function tit(i, t, e, r) {
  ;(i.mechanism = i.mechanism || { type: "generic", handled: !0 }),
    (i.mechanism = {
      ...i.mechanism,
      type: "chained",
      source: t,
      exception_id: e,
      parent_id: r,
    })
}
function BDt(i, t) {
  return i.map((e) => (e.value && (e.value = KU(e.value, t)), e))
}
var mh = "8.35.0-cursor",
  Xe = globalThis
function tM(i, t, e) {
  const r = e || Xe,
    s = (r.__SENTRY__ = r.__SENTRY__ || {}),
    a = (s[mh] = s[mh] || {})
  return a[i] || (a[i] = t())
}
var ODt = Xe,
  qDt = 80
function UDt(i, t = {}) {
  if (!i) return "<unknown>"
  try {
    let e = i
    const r = 5,
      s = []
    let a = 0,
      o = 0
    const c = " > ",
      u = c.length
    let l
    const m = Array.isArray(t) ? t : t.keyAttrs,
      h = (!Array.isArray(t) && t.maxStringLength) || qDt
    for (
      ;
      e &&
      a++ < r &&
      ((l = MDt(e, m)),
      !(l === "html" || (a > 1 && o + s.length * u + l.length >= h)));

    )
      s.push(l), (o += l.length), (e = e.parentNode)
    return s.reverse().join(c)
  } catch {
    return "<unknown>"
  }
}
function MDt(i, t) {
  const e = i,
    r = []
  if (!e || !e.tagName) return ""
  if (ODt.HTMLElement && e instanceof HTMLElement && e.dataset) {
    if (e.dataset.sentryComponent) return e.dataset.sentryComponent
    if (e.dataset.sentryElement) return e.dataset.sentryElement
  }
  r.push(e.tagName.toLowerCase())
  const s =
    t && t.length
      ? t.filter((o) => e.getAttribute(o)).map((o) => [o, e.getAttribute(o)])
      : null
  if (s && s.length)
    s.forEach((o) => {
      r.push(`[${o[0]}="${o[1]}"]`)
    })
  else {
    e.id && r.push(`#${e.id}`)
    const o = e.className
    if (o && lh(o)) {
      const c = o.split(/\s+/)
      for (const u of c) r.push(`.${u}`)
    }
  }
  const a = ["aria-label", "type", "name", "title", "alt"]
  for (const o of a) {
    const c = e.getAttribute(o)
    c && r.push(`[${o}="${c}"]`)
  }
  return r.join("")
}
var eM = !1,
  HDt = "Sentry Logger ",
  a8 = ["debug", "info", "warn", "error", "log", "assert", "trace"],
  o8 = {}
function eit(i) {
  if (!("console" in Xe)) return i()
  const t = Xe.console,
    e = {},
    r = Object.keys(o8)
  r.forEach((s) => {
    const a = o8[s]
    ;(e[s] = t[s]), (t[s] = a)
  })
  try {
    return i()
  } finally {
    r.forEach((s) => {
      t[s] = e[s]
    })
  }
}
function WDt() {
  let i = !1
  const t = {
    enable: () => {
      i = !0
    },
    disable: () => {
      i = !1
    },
    isEnabled: () => i,
  }
  return (
    eM
      ? a8.forEach((e) => {
          t[e] = (...r) => {
            i &&
              eit(() => {
                Xe.console[e](`${HDt}[${e}]:`, ...r)
              })
          }
        })
      : a8.forEach((e) => {
          t[e] = () => {}
        }),
    t
  )
}
var ve = tM("logger", WDt)
function jDt(i, t = !1) {
  const {
    host: e,
    path: r,
    pass: s,
    port: a,
    projectId: o,
    protocol: c,
    publicKey: u,
  } = i
  return `${c}://${u}${t && s ? `:${s}` : ""}@${e}${a ? `:${a}` : ""}/${r && `${r}/`}${o}`
}
var iit = class extends Error {
  constructor(i, t = "warn") {
    super(i),
      (this.message = i),
      (this.name = new.target.prototype.constructor.name),
      Object.setPrototypeOf(this, new.target.prototype),
      (this.logLevel = t)
  }
}
function VDt(i, t, e) {
  if (!(t in i)) return
  const r = i[t],
    s = e(r)
  typeof s == "function" && GDt(s, r), (i[t] = s)
}
function Us(i, t, e) {
  try {
    Object.defineProperty(i, t, { value: e, writable: !0, configurable: !0 })
  } catch {
    eM && ve.log(`Failed to add non-enumerable property "${t}" to object`, i)
  }
}
function GDt(i, t) {
  try {
    const e = t.prototype || {}
    ;(i.prototype = t.prototype = e), Us(i, "__sentry_original__", t)
  } catch {}
}
function zDt(i) {
  return i.__sentry_original__
}
function YDt(i) {
  if (_c(i))
    return { message: i.message, name: i.name, stack: i.stack, ...nit(i) }
  if (LDt(i)) {
    const t = {
      type: i.type,
      target: rit(i.target),
      currentTarget: rit(i.currentTarget),
      ...nit(i),
    }
    return (
      typeof CustomEvent < "u" && Va(i, CustomEvent) && (t.detail = i.detail), t
    )
  } else return i
}
function rit(i) {
  try {
    return RDt(i) ? UDt(i) : Object.prototype.toString.call(i)
  } catch {
    return "<unknown>"
  }
}
function nit(i) {
  if (typeof i == "object" && i !== null) {
    const t = {}
    for (const e in i)
      Object.prototype.hasOwnProperty.call(i, e) && (t[e] = i[e])
    return t
  } else return {}
}
function Ac(i) {
  return iM(i, new Map())
}
function iM(i, t) {
  if (QDt(i)) {
    const e = t.get(i)
    if (e !== void 0) return e
    const r = {}
    t.set(i, r)
    for (const s of Object.getOwnPropertyNames(i))
      typeof i[s] < "u" && (r[s] = iM(i[s], t))
    return r
  }
  if (Array.isArray(i)) {
    const e = t.get(i)
    if (e !== void 0) return e
    const r = []
    return (
      t.set(i, r),
      i.forEach((s) => {
        r.push(iM(s, t))
      }),
      r
    )
  }
  return i
}
function QDt(i) {
  if (!dh(i)) return !1
  try {
    const t = Object.getPrototypeOf(i).constructor.name
    return !t || t === "Object"
  } catch {
    return !0
  }
}
var rM = "<anonymous>"
function sit(i) {
  try {
    return !i || typeof i != "function" ? rM : i.name || rM
  } catch {
    return rM
  }
}
function nM(i) {
  const t = i.exception
  if (t) {
    const e = []
    try {
      return (
        t.values.forEach((r) => {
          r.stacktrace.frames && e.push(...r.stacktrace.frames)
        }),
        e
      )
    } catch {
      return
    }
  }
}
var c8 = {},
  ait = {}
function XDt(i, t) {
  ;(c8[i] = c8[i] || []), c8[i].push(t)
}
function KDt(i, t) {
  ait[i] || (t(), (ait[i] = !0))
}
function ZDt(i, t) {
  const e = i && c8[i]
  if (e)
    for (const r of e)
      try {
        r(t)
      } catch (s) {
        eM &&
          ve.error(
            `Error while triggering instrumentation handler.
Type: ${i}
Name: ${sit(r)}
Error:`,
            s,
          )
      }
}
function tFt(i) {
  const t = "console"
  XDt(t, i), KDt(t, eFt)
}
function eFt() {
  "console" in Xe &&
    a8.forEach(function (i) {
      i in Xe.console &&
        VDt(Xe.console, i, function (t) {
          return (
            (o8[i] = t),
            function (...e) {
              ZDt("console", { args: e, level: i })
              const s = o8[i]
              s && s.apply(Xe.console, e)
            }
          )
        })
    })
}
var oit = 1e3
function cit() {
  return Date.now() / oit
}
function iFt() {
  const { performance: i } = Xe
  if (!i || !i.now) return cit
  const t = Date.now() - i.now(),
    e = i.timeOrigin == null ? t : i.timeOrigin
  return () => (e + i.now()) / oit
}
var Bc = iFt(),
  u8,
  wUt = (() => {
    const { performance: i } = Xe
    if (!i || !i.now) {
      u8 = "none"
      return
    }
    const t = 3600 * 1e3,
      e = i.now(),
      r = Date.now(),
      s = i.timeOrigin ? Math.abs(i.timeOrigin + e - r) : t,
      a = s < t,
      o = i.timing && i.timing.navigationStart,
      u = typeof o == "number" ? Math.abs(o + e - r) : t,
      l = u < t
    return a || l
      ? s <= u
        ? ((u8 = "timeOrigin"), i.timeOrigin)
        : ((u8 = "navigationStart"), o)
      : ((u8 = "dateNow"), r)
  })()
function rFt() {
  const i = typeof WeakSet == "function",
    t = i ? new WeakSet() : []
  function e(s) {
    if (i) return t.has(s) ? !0 : (t.add(s), !1)
    for (let a = 0; a < t.length; a++) if (t[a] === s) return !0
    return t.push(s), !1
  }
  function r(s) {
    if (i) t.delete(s)
    else
      for (let a = 0; a < t.length; a++)
        if (t[a] === s) {
          t.splice(a, 1)
          break
        }
  }
  return [e, r]
}
function Ur() {
  const i = Xe,
    t = i.crypto || i.msCrypto
  let e = () => Math.random() * 16
  try {
    if (t && t.randomUUID) return t.randomUUID().replace(/-/g, "")
    t &&
      t.getRandomValues &&
      (e = () => {
        const r = new Uint8Array(1)
        return t.getRandomValues(r), r[0]
      })
  } catch {}
  return ("10000000100040008000" + 1e11).replace(/[018]/g, (r) =>
    (r ^ ((e() & 15) >> (r / 4))).toString(16),
  )
}
function uit(i) {
  return i.exception && i.exception.values ? i.exception.values[0] : void 0
}
function Ga(i) {
  const { message: t, event_id: e } = i
  if (t) return t
  const r = uit(i)
  return r
    ? r.type && r.value
      ? `${r.type}: ${r.value}`
      : r.type || r.value || e || "<unknown>"
    : e || "<unknown>"
}
function nFt(i, t) {
  const e = uit(i)
  if (!e) return
  const r = { type: "generic", handled: !0 },
    s = e.mechanism
  if (((e.mechanism = { ...r, ...s, ...t }), t && "data" in t)) {
    const a = { ...(s && s.data), ...t.data }
    e.mechanism.data = a
  }
}
function lit(i, t = 100, e = 1 / 0) {
  try {
    return sM("", i, t, e)
  } catch (r) {
    return { ERROR: `**non-serializable** (${r})` }
  }
}
function sM(i, t, e = 1 / 0, r = 1 / 0, s = rFt()) {
  const [a, o] = s
  if (
    t == null ||
    ["boolean", "string"].includes(typeof t) ||
    (typeof t == "number" && Number.isFinite(t))
  )
    return t
  const c = sFt(i, t)
  if (!c.startsWith("[object ")) return c
  if (t.__sentry_skip_normalization__) return t
  const u =
    typeof t.__sentry_override_normalization_depth__ == "number"
      ? t.__sentry_override_normalization_depth__
      : e
  if (u === 0) return c.replace("object ", "")
  if (a(t)) return "[Circular ~]"
  const l = t
  if (l && typeof l.toJSON == "function")
    try {
      const g = l.toJSON()
      return sM("", g, u - 1, r, s)
    } catch {}
  const m = Array.isArray(t) ? [] : {}
  let h = 0
  const p = YDt(t)
  for (const g in p) {
    if (!Object.prototype.hasOwnProperty.call(p, g)) continue
    if (h >= r) {
      m[g] = "[MaxProperties ~]"
      break
    }
    const w = p[g]
    ;(m[g] = sM(g, w, u - 1, r, s)), h++
  }
  return o(t), m
}
function sFt(i, t) {
  try {
    if (i === "domain" && t && typeof t == "object" && t._events)
      return "[Domain]"
    if (i === "domainEmitter") return "[DomainEmitter]"
    if (typeof global < "u" && t === global) return "[Global]"
    if (typeof window < "u" && t === window) return "[Window]"
    if (typeof document < "u" && t === document) return "[Document]"
    if (Xet(t)) return "[VueViewModel]"
    if (FDt(t)) return "[SyntheticEvent]"
    if (typeof t == "number" && !Number.isFinite(t)) return `[${t}]`
    if (typeof t == "function") return `[Function: ${sit(t)}]`
    if (typeof t == "symbol") return `[${String(t)}]`
    if (typeof t == "bigint") return `[BigInt: ${String(t)}]`
    const e = aFt(t)
    return /^HTML(\w*)Element$/.test(e)
      ? `[HTMLElement: ${e}]`
      : `[object ${e}]`
  } catch (e) {
    return `**non-serializable** (${e})`
  }
}
function aFt(i) {
  const t = Object.getPrototypeOf(i)
  return t ? t.constructor.name : "null prototype"
}
function oFt(i, t) {
  let e = 0
  for (let r = i.length - 1; r >= 0; r--) {
    const s = i[r]
    s === "."
      ? i.splice(r, 1)
      : s === ".."
        ? (i.splice(r, 1), e++)
        : e && (i.splice(r, 1), e--)
  }
  if (t) for (; e--; e) i.unshift("..")
  return i
}
var cFt =
  /^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/
function uFt(i) {
  const t = i.length > 1024 ? `<truncated>${i.slice(-1024)}` : i,
    e = cFt.exec(t)
  return e ? e.slice(1) : []
}
function dit(...i) {
  let t = "",
    e = !1
  for (let r = i.length - 1; r >= -1 && !e; r--) {
    const s = r >= 0 ? i[r] : "/"
    s && ((t = `${s}/${t}`), (e = s.charAt(0) === "/"))
  }
  return (
    (t = oFt(
      t.split("/").filter((r) => !!r),
      !e,
    ).join("/")),
    (e ? "/" : "") + t || "."
  )
}
function mit(i) {
  let t = 0
  for (; t < i.length && i[t] === ""; t++);
  let e = i.length - 1
  for (; e >= 0 && i[e] === ""; e--);
  return t > e ? [] : i.slice(t, e - t + 1)
}
function lFt(i, t) {
  ;(i = dit(i).slice(1)), (t = dit(t).slice(1))
  const e = mit(i.split("/")),
    r = mit(t.split("/")),
    s = Math.min(e.length, r.length)
  let a = s
  for (let c = 0; c < s; c++)
    if (e[c] !== r[c]) {
      a = c
      break
    }
  let o = []
  for (let c = a; c < e.length; c++) o.push("..")
  return (o = o.concat(r.slice(a))), o.join("/")
}
function dFt(i, t) {
  let e = uFt(i)[2] || ""
  return (
    t && e.slice(t.length * -1) === t && (e = e.slice(0, e.length - t.length)),
    e
  )
}
var hit
;(function (i) {
  ;(i[(i.PENDING = 0)] = "PENDING"),
    (i[(i.RESOLVED = 1)] = "RESOLVED"),
    (i[(i.REJECTED = 2)] = "REJECTED")
})(hit || (hit = {}))
function mFt(i) {
  return new aM((t) => {
    t(i)
  })
}
function hFt(i) {
  return new aM((t, e) => {
    e(i)
  })
}
var aM = class SH {
  constructor(t) {
    ;(this._resolve = (e) => {
      this._setResult(1, e)
    }),
      (this._reject = (e) => {
        this._setResult(2, e)
      }),
      (this._setResult = (e, r) => {
        if (this._state === 0) {
          if (XU(r)) {
            r.then(this._resolve, this._reject)
            return
          }
          ;(this._state = e), (this._value = r), this._executeHandlers()
        }
      }),
      (this._executeHandlers = () => {
        if (this._state === 0) return
        const e = this._handlers.slice()
        ;(this._handlers = []),
          e.forEach((r) => {
            r[0] ||
              (this._state === 1 && r[1](this._value),
              this._state === 2 && r[2](this._value),
              (r[0] = !0))
          })
      }),
      (this._state = 0),
      (this._handlers = [])
    try {
      t(this._resolve, this._reject)
    } catch (e) {
      this._reject(e)
    }
  }
  then(t, e) {
    return new SH((r, s) => {
      this._handlers.push([
        !1,
        (a) => {
          if (!t) r(a)
          else
            try {
              r(t(a))
            } catch (o) {
              s(o)
            }
        },
        (a) => {
          if (!e) s(a)
          else
            try {
              r(e(a))
            } catch (o) {
              s(o)
            }
        },
      ]),
        this._executeHandlers()
    })
  }
  catch(t) {
    return this.then((e) => e, t)
  }
  finally(t) {
    return new SH((e, r) => {
      let s, a
      return this.then(
        (o) => {
          ;(a = !1), (s = o), t && t()
        },
        (o) => {
          ;(a = !0), (s = o), t && t()
        },
      ).then(() => {
        if (a) {
          r(s)
          return
        }
        e(s)
      })
    })
  }
}
function fFt(i) {
  const t = []
  function e() {
    return i === void 0 || t.length < i
  }
  function r(o) {
    return t.splice(t.indexOf(o), 1)[0] || Promise.resolve(void 0)
  }
  function s(o) {
    if (!e())
      return hFt(
        new iit("Not adding Promise because buffer limit was reached."),
      )
    const c = o()
    return (
      t.indexOf(c) === -1 && t.push(c),
      c.then(() => r(c)).then(null, () => r(c).then(null, () => {})),
      c
    )
  }
  function a(o) {
    return new aM((c, u) => {
      let l = t.length
      if (!l) return c(!0)
      const m = setTimeout(() => {
        o && o > 0 && c(!1)
      }, o)
      t.forEach((h) => {
        mFt(h).then(() => {
          --l || (clearTimeout(m), c(!0))
        }, u)
      })
    })
  }
  return { $: t, add: s, drain: a }
}
function pFt(i) {
  const t = {}
  let e = 0
  for (; e < i.length; ) {
    const r = i.indexOf("=", e)
    if (r === -1) break
    let s = i.indexOf(";", e)
    if (s === -1) s = i.length
    else if (s < r) {
      e = i.lastIndexOf(";", r - 1) + 1
      continue
    }
    const a = i.slice(e, r).trim()
    if (t[a] === void 0) {
      let o = i.slice(r + 1, s).trim()
      o.charCodeAt(0) === 34 && (o = o.slice(1, -1))
      try {
        t[a] = o.indexOf("%") !== -1 ? decodeURIComponent(o) : o
      } catch {
        t[a] = o
      }
    }
    e = s + 1
  }
  return t
}
function gFt(i) {
  return i.split(/[?#]/, 1)[0]
}
var fit = [
  "X-Client-IP",
  "X-Forwarded-For",
  "Fly-Client-IP",
  "CF-Connecting-IP",
  "Fastly-Client-Ip",
  "True-Client-Ip",
  "X-Real-IP",
  "X-Cluster-Client-IP",
  "X-Forwarded",
  "Forwarded-For",
  "Forwarded",
  "X-Vercel-Forwarded-For",
]
function vFt(i) {
  return (
    fit
      .map((s) => {
        const a = i[s],
          o = Array.isArray(a) ? a.join(";") : a
        return s === "Forwarded"
          ? wFt(o)
          : o && o.split(",").map((c) => c.trim())
      })
      .reduce((s, a) => (a ? s.concat(a) : s), [])
      .find((s) => s !== null && yFt(s)) || null
  )
}
function wFt(i) {
  if (!i) return null
  for (const t of i.split(";")) if (t.startsWith("for=")) return t.slice(4)
  return null
}
function yFt(i) {
  return /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-fA-F\d]{1,4}:){7}(?:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,2}|:)|(?:[a-fA-F\d]{1,4}:){4}(?:(?::[a-fA-F\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,3}|:)|(?:[a-fA-F\d]{1,4}:){3}(?:(?::[a-fA-F\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,4}|:)|(?:[a-fA-F\d]{1,4}:){2}(?:(?::[a-fA-F\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,5}|:)|(?:[a-fA-F\d]{1,4}:){1}(?:(?::[a-fA-F\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,6}|:)|(?::(?:(?::[a-fA-F\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,7}|:)))(?:%[0-9a-zA-Z]{1,})?$)/.test(
    i,
  )
}
var TFt = { ip: !1, request: !0, transaction: !0, user: !0 },
  pit = ["cookies", "data", "headers", "method", "query_string", "url"],
  kFt = ["id", "username", "email"]
function git(i, t = {}) {
  const e = i.method && i.method.toUpperCase()
  let r = "",
    s = "url"
  t.customRoute || i.route
    ? ((r = t.customRoute || `${i.baseUrl || ""}${i.route && i.route.path}`),
      (s = "route"))
    : (i.originalUrl || i.url) && (r = gFt(i.originalUrl || i.url || ""))
  let a = ""
  return (
    t.method && e && (a += e),
    t.method && t.path && (a += " "),
    t.path && r && (a += r),
    [a, s]
  )
}
function SFt(i, t) {
  switch (t) {
    case "path":
      return git(i, { path: !0 })[0]
    case "handler":
      return (
        (i.route &&
          i.route.stack &&
          i.route.stack[0] &&
          i.route.stack[0].name) ||
        "<anonymous>"
      )
    case "methodPath":
    default: {
      const e = i._reconstructedRoute ? i._reconstructedRoute : void 0
      return git(i, { path: !0, method: !0, customRoute: e })[0]
    }
  }
}
function bFt(i, t) {
  const e = {}
  return (
    (Array.isArray(t) ? t : kFt).forEach((s) => {
      i && s in i && (e[s] = i[s])
    }),
    e
  )
}
function EFt(i, t = {}) {
  const { include: e = pit } = t,
    r = {},
    s = i.headers || {},
    a = i.method,
    o = s.host || i.hostname || i.host || "<no host>",
    c =
      i.protocol === "https" || (i.socket && i.socket.encrypted)
        ? "https"
        : "http",
    u = i.originalUrl || i.url || "",
    l = u.startsWith(c) ? u : `${c}://${o}${u}`
  return (
    e.forEach((m) => {
      switch (m) {
        case "headers": {
          ;(r.headers = s),
            e.includes("cookies") || delete r.headers.cookie,
            e.includes("ip") ||
              fit.forEach((h) => {
                delete r.headers[h]
              })
          break
        }
        case "method": {
          r.method = a
          break
        }
        case "url": {
          r.url = l
          break
        }
        case "cookies": {
          r.cookies = i.cookies || (s.cookie && pFt(s.cookie)) || {}
          break
        }
        case "query_string": {
          r.query_string = PFt(i)
          break
        }
        case "data": {
          if (a === "GET" || a === "HEAD") break
          i.body !== void 0 &&
            (r.data = lh(i.body) ? i.body : JSON.stringify(lit(i.body)))
          break
        }
        default:
          ;({}).hasOwnProperty.call(i, m) && (r[m] = i[m])
      }
    }),
    r
  )
}
function IFt(i, t, e) {
  const r = { ...TFt, ...(e && e.include) }
  if (r.request) {
    const s = Array.isArray(r.request) ? [...r.request] : [...pit]
    r.ip && s.push("ip")
    const a = EFt(t, { include: s })
    i.request = { ...i.request, ...a }
  }
  if (r.user) {
    const s = t.user && dh(t.user) ? bFt(t.user, r.user) : {}
    Object.keys(s).length && (i.user = { ...i.user, ...s })
  }
  if (r.ip) {
    const s =
      (t.headers && vFt(t.headers)) ||
      t.ip ||
      (t.socket && t.socket.remoteAddress)
    s && (i.user = { ...i.user, ip_address: s })
  }
  return (
    r.transaction &&
      !i.transaction &&
      i.type === "transaction" &&
      (i.transaction = SFt(t, r.transaction)),
    i
  )
}
function PFt(i) {
  let t = i.originalUrl || i.url || ""
  if (t) {
    t.startsWith("/") && (t = `http://dogs.are.great${t}`)
    try {
      const e = i.query || new URL(t).search.slice(1)
      return e.length ? e : void 0
    } catch {
      return
    }
  }
}
var NFt = ["fatal", "error", "warning", "log", "info", "debug"]
function $Ft(i) {
  return i === "warn" ? "warning" : NFt.includes(i) ? i : "log"
}
var xFt = "sentry-",
  JFt = /^sentry-/
function CFt(i) {
  const t = LFt(i)
  if (!t) return
  const e = Object.entries(t).reduce((r, [s, a]) => {
    if (s.match(JFt)) {
      const o = s.slice(xFt.length)
      r[o] = a
    }
    return r
  }, {})
  if (Object.keys(e).length > 0) return e
}
function LFt(i) {
  if (!(!i || (!lh(i) && !Array.isArray(i))))
    return Array.isArray(i)
      ? i.reduce((t, e) => {
          const r = vit(e)
          return (
            Object.entries(r).forEach(([s, a]) => {
              t[s] = a
            }),
            t
          )
        }, {})
      : vit(i)
}
function vit(i) {
  return i
    .split(",")
    .map((t) => t.split("=").map((e) => decodeURIComponent(e.trim())))
    .reduce((t, [e, r]) => (e && r && (t[e] = r), t), {})
}
var yUt = new RegExp(
  "^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$",
)
function RFt(i, t = []) {
  return [i, t]
}
function wit(i, t) {
  const e = i[1]
  for (const r of e) {
    const s = r[0].type
    if (t(r, s)) return !0
  }
  return !1
}
function DFt(i) {
  return [{ type: "span" }, i]
}
var TUt = 60 * 1e3
function FFt(i, t) {
  return i(t.stack || "", 1)
}
function _Ft(i, t) {
  const e = { type: t.name || t.constructor.name, value: t.message },
    r = FFt(i, t)
  return r.length && (e.stacktrace = { frames: r }), e
}
function yit() {
  return { traceId: Ur(), spanId: Ur().substring(16) }
}
var Be = !1
function Oc() {
  return oM(Xe), Xe
}
function oM(i) {
  const t = (i.__SENTRY__ = i.__SENTRY__ || {})
  return (t.version = t.version || mh), (t[mh] = t[mh] || {})
}
function AFt(i, t = {}) {
  if (
    (t.user &&
      (!i.ipAddress && t.user.ip_address && (i.ipAddress = t.user.ip_address),
      !i.did &&
        !t.did &&
        (i.did = t.user.id || t.user.email || t.user.username)),
    (i.timestamp = t.timestamp || Bc()),
    t.abnormal_mechanism && (i.abnormal_mechanism = t.abnormal_mechanism),
    t.ignoreDuration && (i.ignoreDuration = t.ignoreDuration),
    t.sid && (i.sid = t.sid.length === 32 ? t.sid : Ur()),
    t.init !== void 0 && (i.init = t.init),
    !i.did && t.did && (i.did = `${t.did}`),
    typeof t.started == "number" && (i.started = t.started),
    i.ignoreDuration)
  )
    i.duration = void 0
  else if (typeof t.duration == "number") i.duration = t.duration
  else {
    const e = i.timestamp - i.started
    i.duration = e >= 0 ? e : 0
  }
  t.release && (i.release = t.release),
    t.environment && (i.environment = t.environment),
    !i.ipAddress && t.ipAddress && (i.ipAddress = t.ipAddress),
    !i.userAgent && t.userAgent && (i.userAgent = t.userAgent),
    typeof t.errors == "number" && (i.errors = t.errors),
    t.status && (i.status = t.status)
}
var cM = "_sentrySpan"
function l8(i, t) {
  t ? Us(i, cM, t) : delete i[cM]
}
function d8(i) {
  return i[cM]
}
var BFt = 100,
  OFt = class rst {
    constructor() {
      ;(this._notifyingListeners = !1),
        (this._scopeListeners = []),
        (this._eventProcessors = []),
        (this._breadcrumbs = []),
        (this._attachments = []),
        (this._user = {}),
        (this._tags = {}),
        (this._extra = {}),
        (this._contexts = {}),
        (this._sdkProcessingMetadata = {}),
        (this._propagationContext = yit())
    }
    clone() {
      const t = new rst()
      return (
        (t._breadcrumbs = [...this._breadcrumbs]),
        (t._tags = { ...this._tags }),
        (t._extra = { ...this._extra }),
        (t._contexts = { ...this._contexts }),
        (t._user = this._user),
        (t._level = this._level),
        (t._session = this._session),
        (t._transactionName = this._transactionName),
        (t._fingerprint = this._fingerprint),
        (t._eventProcessors = [...this._eventProcessors]),
        (t._requestSession = this._requestSession),
        (t._attachments = [...this._attachments]),
        (t._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }),
        (t._propagationContext = { ...this._propagationContext }),
        (t._client = this._client),
        (t._lastEventId = this._lastEventId),
        l8(t, d8(this)),
        t
      )
    }
    setClient(t) {
      this._client = t
    }
    setLastEventId(t) {
      this._lastEventId = t
    }
    getClient() {
      return this._client
    }
    lastEventId() {
      return this._lastEventId
    }
    addScopeListener(t) {
      this._scopeListeners.push(t)
    }
    addEventProcessor(t) {
      return this._eventProcessors.push(t), this
    }
    setUser(t) {
      return (
        (this._user = t || {
          email: void 0,
          id: void 0,
          ip_address: void 0,
          username: void 0,
        }),
        this._session && AFt(this._session, { user: t }),
        this._notifyScopeListeners(),
        this
      )
    }
    getUser() {
      return this._user
    }
    getRequestSession() {
      return this._requestSession
    }
    setRequestSession(t) {
      return (this._requestSession = t), this
    }
    setTags(t) {
      return (
        (this._tags = { ...this._tags, ...t }),
        this._notifyScopeListeners(),
        this
      )
    }
    setTag(t, e) {
      return (
        (this._tags = { ...this._tags, [t]: e }),
        this._notifyScopeListeners(),
        this
      )
    }
    setExtras(t) {
      return (
        (this._extra = { ...this._extra, ...t }),
        this._notifyScopeListeners(),
        this
      )
    }
    setExtra(t, e) {
      return (
        (this._extra = { ...this._extra, [t]: e }),
        this._notifyScopeListeners(),
        this
      )
    }
    setFingerprint(t) {
      return (this._fingerprint = t), this._notifyScopeListeners(), this
    }
    setLevel(t) {
      return (this._level = t), this._notifyScopeListeners(), this
    }
    setTransactionName(t) {
      return (this._transactionName = t), this._notifyScopeListeners(), this
    }
    setContext(t, e) {
      return (
        e === null ? delete this._contexts[t] : (this._contexts[t] = e),
        this._notifyScopeListeners(),
        this
      )
    }
    setSession(t) {
      return (
        t ? (this._session = t) : delete this._session,
        this._notifyScopeListeners(),
        this
      )
    }
    getSession() {
      return this._session
    }
    update(t) {
      if (!t) return this
      const e = typeof t == "function" ? t(this) : t,
        [r, s] =
          e instanceof qc
            ? [e.getScopeData(), e.getRequestSession()]
            : dh(e)
              ? [t, t.requestSession]
              : [],
        {
          tags: a,
          extra: o,
          user: c,
          contexts: u,
          level: l,
          fingerprint: m = [],
          propagationContext: h,
        } = r || {}
      return (
        (this._tags = { ...this._tags, ...a }),
        (this._extra = { ...this._extra, ...o }),
        (this._contexts = { ...this._contexts, ...u }),
        c && Object.keys(c).length && (this._user = c),
        l && (this._level = l),
        m.length && (this._fingerprint = m),
        h && (this._propagationContext = h),
        s && (this._requestSession = s),
        this
      )
    }
    clear() {
      return (
        (this._breadcrumbs = []),
        (this._tags = {}),
        (this._extra = {}),
        (this._user = {}),
        (this._contexts = {}),
        (this._level = void 0),
        (this._transactionName = void 0),
        (this._fingerprint = void 0),
        (this._requestSession = void 0),
        (this._session = void 0),
        l8(this, void 0),
        (this._attachments = []),
        (this._propagationContext = yit()),
        this._notifyScopeListeners(),
        this
      )
    }
    addBreadcrumb(t, e) {
      const r = typeof e == "number" ? e : BFt
      if (r <= 0) return this
      const s = { timestamp: cit(), ...t },
        a = this._breadcrumbs
      return (
        a.push(s),
        (this._breadcrumbs = a.length > r ? a.slice(-r) : a),
        this._notifyScopeListeners(),
        this
      )
    }
    getLastBreadcrumb() {
      return this._breadcrumbs[this._breadcrumbs.length - 1]
    }
    clearBreadcrumbs() {
      return (this._breadcrumbs = []), this._notifyScopeListeners(), this
    }
    addAttachment(t) {
      return this._attachments.push(t), this
    }
    clearAttachments() {
      return (this._attachments = []), this
    }
    getScopeData() {
      return {
        breadcrumbs: this._breadcrumbs,
        attachments: this._attachments,
        contexts: this._contexts,
        tags: this._tags,
        extra: this._extra,
        user: this._user,
        level: this._level,
        fingerprint: this._fingerprint || [],
        eventProcessors: this._eventProcessors,
        propagationContext: this._propagationContext,
        sdkProcessingMetadata: this._sdkProcessingMetadata,
        transactionName: this._transactionName,
        span: d8(this),
      }
    }
    setSDKProcessingMetadata(t) {
      return (
        (this._sdkProcessingMetadata = {
          ...this._sdkProcessingMetadata,
          ...t,
        }),
        this
      )
    }
    setPropagationContext(t) {
      return (this._propagationContext = t), this
    }
    getPropagationContext() {
      return this._propagationContext
    }
    captureException(t, e) {
      const r = e && e.event_id ? e.event_id : Ur()
      if (!this._client)
        return (
          ve.warn(
            "No client configured on scope - will not capture exception!",
          ),
          r
        )
      const s = new Error("Sentry syntheticException")
      return (
        this._client.captureException(
          t,
          { originalException: t, syntheticException: s, ...e, event_id: r },
          this,
        ),
        r
      )
    }
    captureMessage(t, e, r) {
      const s = r && r.event_id ? r.event_id : Ur()
      if (!this._client)
        return (
          ve.warn("No client configured on scope - will not capture message!"),
          s
        )
      const a = new Error(t)
      return (
        this._client.captureMessage(
          t,
          e,
          { originalException: t, syntheticException: a, ...r, event_id: s },
          this,
        ),
        s
      )
    }
    captureEvent(t, e) {
      const r = e && e.event_id ? e.event_id : Ur()
      return this._client
        ? (this._client.captureEvent(t, { ...e, event_id: r }, this), r)
        : (ve.warn("No client configured on scope - will not capture event!"),
          r)
    }
    _notifyScopeListeners() {
      this._notifyingListeners ||
        ((this._notifyingListeners = !0),
        this._scopeListeners.forEach((t) => {
          t(this)
        }),
        (this._notifyingListeners = !1))
    }
  },
  qc = OFt
function qFt() {
  return tM("defaultCurrentScope", () => new qc())
}
function UFt() {
  return tM("defaultIsolationScope", () => new qc())
}
var MFt = class {
  constructor(i, t) {
    let e
    i ? (e = i) : (e = new qc())
    let r
    t ? (r = t) : (r = new qc()),
      (this._stack = [{ scope: e }]),
      (this._isolationScope = r)
  }
  withScope(i) {
    const t = this._pushScope()
    let e
    try {
      e = i(t)
    } catch (r) {
      throw (this._popScope(), r)
    }
    return XU(e)
      ? e.then(
          (r) => (this._popScope(), r),
          (r) => {
            throw (this._popScope(), r)
          },
        )
      : (this._popScope(), e)
  }
  getClient() {
    return this.getStackTop().client
  }
  getScope() {
    return this.getStackTop().scope
  }
  getIsolationScope() {
    return this._isolationScope
  }
  getStackTop() {
    return this._stack[this._stack.length - 1]
  }
  _pushScope() {
    const i = this.getScope().clone()
    return this._stack.push({ client: this.getClient(), scope: i }), i
  }
  _popScope() {
    return this._stack.length <= 1 ? !1 : !!this._stack.pop()
  }
}
function Uc() {
  const i = Oc(),
    t = oM(i)
  return (t.stack = t.stack || new MFt(qFt(), UFt()))
}
function HFt(i) {
  return Uc().withScope(i)
}
function WFt(i, t) {
  const e = Uc()
  return e.withScope(() => ((e.getStackTop().scope = i), t(i)))
}
function Tit(i) {
  return Uc().withScope(() => i(Uc().getIsolationScope()))
}
function jFt() {
  return {
    withIsolationScope: Tit,
    withScope: HFt,
    withSetScope: WFt,
    withSetIsolationScope: (i, t) => Tit(t),
    getCurrentScope: () => Uc().getScope(),
    getIsolationScope: () => Uc().getIsolationScope(),
  }
}
function hh(i) {
  const t = oM(i)
  return t.acs ? t.acs : jFt()
}
function Wn() {
  const i = Oc()
  return hh(i).getCurrentScope()
}
function Mc() {
  const i = Oc()
  return hh(i).getIsolationScope()
}
function uM(...i) {
  const t = Oc(),
    e = hh(t)
  if (i.length === 2) {
    const [r, s] = i
    return r ? e.withSetScope(r, s) : e.withScope(s)
  }
  return e.withScope(i[0])
}
function ln() {
  return Wn().getClient()
}
var VFt = "_sentryMetrics"
function lM(i) {
  const t = i[VFt]
  if (!t) return
  const e = {}
  for (const [, [r, s]] of t) (e[r] || (e[r] = [])).push(Ac(s))
  return e
}
var dM = "sentry.source",
  mM = "sentry.sample_rate",
  hM = "sentry.op",
  fM = "sentry.origin",
  GFt = "sentry.measurement_unit",
  zFt = "sentry.measurement_value",
  YFt = "sentry.profile_id",
  QFt = "sentry.exclusive_time",
  XFt = 0,
  KFt = 1,
  kit = 2,
  Sit = 0,
  bit = 1
function ZFt(i) {
  const { spanId: t, traceId: e } = i.spanContext(),
    { data: r, op: s, parent_span_id: a, status: o, origin: c } = Mr(i)
  return Ac({
    parent_span_id: a,
    span_id: t,
    trace_id: e,
    data: r,
    op: s,
    status: o,
    origin: c,
  })
}
function Hc(i) {
  return typeof i == "number"
    ? Eit(i)
    : Array.isArray(i)
      ? i[0] + i[1] / 1e9
      : i instanceof Date
        ? Eit(i.getTime())
        : Bc()
}
function Eit(i) {
  return i > 9999999999 ? i / 1e3 : i
}
function Mr(i) {
  if (e_t(i)) return i.getSpanJSON()
  try {
    const { spanId: t, traceId: e } = i.spanContext()
    if (t_t(i)) {
      const {
        attributes: r,
        startTime: s,
        name: a,
        endTime: o,
        parentSpanId: c,
        status: u,
      } = i
      return Ac({
        span_id: t,
        trace_id: e,
        data: r,
        description: a,
        parent_span_id: c,
        start_timestamp: Hc(s),
        timestamp: Hc(o) || void 0,
        status: Iit(u),
        op: r[hM],
        origin: r[fM],
        _metrics_summary: lM(i),
      })
    }
    return { span_id: t, trace_id: e }
  } catch {
    return {}
  }
}
function t_t(i) {
  const t = i
  return (
    !!t.attributes && !!t.startTime && !!t.name && !!t.endTime && !!t.status
  )
}
function e_t(i) {
  return typeof i.getSpanJSON == "function"
}
function fh(i) {
  const { traceFlags: t } = i.spanContext()
  return t === bit
}
function Iit(i) {
  if (!(!i || i.code === XFt))
    return i.code === KFt ? "ok" : i.message || "unknown_error"
}
var ph = "_sentryChildSpans",
  pM = "_sentryRootSpan"
function Pit(i, t) {
  const e = i[pM] || i
  Us(t, pM, e), i[ph] ? i[ph].add(t) : Us(i, ph, new Set([t]))
}
function i_t(i) {
  const t = new Set()
  function e(r) {
    if (!t.has(r) && fh(r)) {
      t.add(r)
      const s = r[ph] ? Array.from(r[ph]) : []
      for (const a of s) e(a)
    }
  }
  return e(i), Array.from(t)
}
function Ms(i) {
  return i[pM] || i
}
function r_t() {
  const i = Oc(),
    t = hh(i)
  return t.getActiveSpan ? t.getActiveSpan() : d8(Wn())
}
function n_t() {
  const i = r_t(),
    t = i && Ms(i)
  if (t) {
    const e = "internal_error"
    Be && ve.log(`[Tracing] Root span: ${e} -> Global error occured`),
      t.setStatus({ code: kit, message: e })
  }
}
n_t.tag = "sentry_tracingErrorCallback"
var Nit = "_sentryScope",
  $it = "_sentryIsolationScope"
function s_t(i, t, e) {
  i && (Us(i, $it, e), Us(i, Nit, t))
}
function xit(i) {
  return { scope: i[Nit], isolationScope: i[$it] }
}
function gM(i) {
  if (typeof __SENTRY_TRACING__ == "boolean" && !__SENTRY_TRACING__) return !1
  const t = ln(),
    e = i || (t && t.getOptions())
  return (
    !!e && (e.enableTracing || "tracesSampleRate" in e || "tracesSampler" in e)
  )
}
var vM = class {
  constructor(i = {}) {
    ;(this._traceId = i.traceId || Ur()),
      (this._spanId = i.spanId || Ur().substring(16))
  }
  spanContext() {
    return { spanId: this._spanId, traceId: this._traceId, traceFlags: Sit }
  }
  end(i) {}
  setAttribute(i, t) {
    return this
  }
  setAttributes(i) {
    return this
  }
  setStatus(i) {
    return this
  }
  updateName(i) {
    return this
  }
  isRecording() {
    return !1
  }
  addEvent(i, t, e) {
    return this
  }
  addLink(i) {
    return this
  }
  addLinks(i) {
    return this
  }
  recordException(i, t) {}
}
function a_t(i, t, e = () => {}) {
  let r
  try {
    r = i()
  } catch (s) {
    throw (t(s), e(), s)
  }
  return o_t(r, t, e)
}
function o_t(i, t, e) {
  return XU(i)
    ? i.then(
        (r) => (e(), r),
        (r) => {
          throw (t(r), e(), r)
        },
      )
    : (e(), i)
}
var c_t = "production",
  Jit = "_frozenDsc"
function Cit(i, t) {
  Us(i, Jit, t)
}
function u_t(i, t) {
  const e = t.getOptions(),
    { publicKey: r } = t.getDsn() || {},
    s = Ac({
      environment: e.environment || c_t,
      release: e.release,
      public_key: r,
      trace_id: i,
    })
  return t.emit("createDsc", s), s
}
function wM(i) {
  const t = ln()
  if (!t) return {}
  const e = u_t(Mr(i).trace_id || "", t),
    r = Ms(i),
    s = r[Jit]
  if (s) return s
  const a = r.spanContext().traceState,
    o = a && a.get("sentry.dsc"),
    c = o && CFt(o)
  if (c) return c
  const u = Mr(r),
    l = u.data || {},
    m = l[mM]
  m != null && (e.sample_rate = `${m}`)
  const h = l[dM],
    p = u.description
  return (
    h !== "url" && p && (e.transaction = p),
    gM() && (e.sampled = String(fh(r))),
    t.emit("createDsc", e, r),
    e
  )
}
function l_t(i) {
  if (!Be) return
  const {
      description: t = "< unknown name >",
      op: e = "< unknown op >",
      parent_span_id: r,
    } = Mr(i),
    { spanId: s } = i.spanContext(),
    a = fh(i),
    o = Ms(i),
    c = o === i,
    u = `[Tracing] Starting ${a ? "sampled" : "unsampled"} ${c ? "root " : ""}span`,
    l = [`op: ${e}`, `name: ${t}`, `ID: ${s}`]
  if ((r && l.push(`parent ID: ${r}`), !c)) {
    const { op: m, description: h } = Mr(o)
    l.push(`root ID: ${o.spanContext().spanId}`),
      m && l.push(`root op: ${m}`),
      h && l.push(`root description: ${h}`)
  }
  ve.log(`${u}
  ${l.join(`
  `)}`)
}
function d_t(i) {
  if (!Be) return
  const { description: t = "< unknown name >", op: e = "< unknown op >" } =
      Mr(i),
    { spanId: r } = i.spanContext(),
    a = Ms(i) === i,
    o = `[Tracing] Finishing "${e}" ${a ? "root " : ""}span "${t}" with ID ${r}`
  ve.log(o)
}
function m_t(i) {
  if (typeof i == "boolean") return Number(i)
  const t = typeof i == "string" ? parseFloat(i) : i
  if (typeof t != "number" || isNaN(t) || t < 0 || t > 1) {
    Be &&
      ve.warn(
        `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(i)} of type ${JSON.stringify(typeof i)}.`,
      )
    return
  }
  return t
}
function h_t(i, t) {
  if (!gM(i)) return [!1]
  let e
  typeof i.tracesSampler == "function"
    ? (e = i.tracesSampler(t))
    : t.parentSampled !== void 0
      ? (e = t.parentSampled)
      : typeof i.tracesSampleRate < "u"
        ? (e = i.tracesSampleRate)
        : (e = 1)
  const r = m_t(e)
  return r === void 0
    ? (Be &&
        ve.warn(
          "[Tracing] Discarding transaction because of invalid sample rate.",
        ),
      [!1])
    : r
      ? Math.random() < r
        ? [!0, r]
        : (Be &&
            ve.log(
              `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(e)})`,
            ),
          [!1, r])
      : (Be &&
          ve.log(
            `[Tracing] Discarding transaction because ${typeof i.tracesSampler == "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`,
          ),
        [!1, r])
}
function f_t(i, t) {
  function e(m) {
    return !!m.trace_id && !!m.public_key
  }
  const r = wM(i[0]),
    s = t && t.getDsn(),
    a = t && t.getOptions().tunnel,
    o = {
      sent_at: new Date().toISOString(),
      ...(e(r) && { trace: r }),
      ...(!!a && s && { dsn: jDt(s) }),
    },
    c = t && t.getOptions().beforeSendSpan,
    u = c ? (m) => c(Mr(m)) : (m) => Mr(m),
    l = []
  for (const m of i) {
    const h = u(m)
    h && l.push(DFt(h))
  }
  return RFt(o, l)
}
function Lit(i) {
  if (!i || i.length === 0) return
  const t = {}
  return (
    i.forEach((e) => {
      const r = e.attributes || {},
        s = r[GFt],
        a = r[zFt]
      typeof s == "string" &&
        typeof a == "number" &&
        (t[e.name] = { value: a, unit: s })
    }),
    t
  )
}
var Rit = 1e3,
  yM = class {
    constructor(i = {}) {
      ;(this._traceId = i.traceId || Ur()),
        (this._spanId = i.spanId || Ur().substring(16)),
        (this._startTime = i.startTimestamp || Bc()),
        (this._attributes = {}),
        this.setAttributes({ [fM]: "manual", [hM]: i.op, ...i.attributes }),
        (this._name = i.name),
        i.parentSpanId && (this._parentSpanId = i.parentSpanId),
        "sampled" in i && (this._sampled = i.sampled),
        i.endTimestamp && (this._endTime = i.endTimestamp),
        (this._events = []),
        (this._isStandaloneSpan = i.isStandalone),
        this._endTime && this._onSpanEnded()
    }
    addLink(i) {
      return this
    }
    addLinks(i) {
      return this
    }
    recordException(i, t) {}
    spanContext() {
      const { _spanId: i, _traceId: t, _sampled: e } = this
      return { spanId: i, traceId: t, traceFlags: e ? bit : Sit }
    }
    setAttribute(i, t) {
      return (
        t === void 0 ? delete this._attributes[i] : (this._attributes[i] = t),
        this
      )
    }
    setAttributes(i) {
      return Object.keys(i).forEach((t) => this.setAttribute(t, i[t])), this
    }
    updateStartTime(i) {
      this._startTime = Hc(i)
    }
    setStatus(i) {
      return (this._status = i), this
    }
    updateName(i) {
      return (this._name = i), this
    }
    end(i) {
      this._endTime || ((this._endTime = Hc(i)), d_t(this), this._onSpanEnded())
    }
    getSpanJSON() {
      return Ac({
        data: this._attributes,
        description: this._name,
        op: this._attributes[hM],
        parent_span_id: this._parentSpanId,
        span_id: this._spanId,
        start_timestamp: this._startTime,
        status: Iit(this._status),
        timestamp: this._endTime,
        trace_id: this._traceId,
        origin: this._attributes[fM],
        _metrics_summary: lM(this),
        profile_id: this._attributes[YFt],
        exclusive_time: this._attributes[QFt],
        measurements: Lit(this._events),
        is_segment: (this._isStandaloneSpan && Ms(this) === this) || void 0,
        segment_id: this._isStandaloneSpan
          ? Ms(this).spanContext().spanId
          : void 0,
      })
    }
    isRecording() {
      return !this._endTime && !!this._sampled
    }
    addEvent(i, t, e) {
      Be && ve.log("[Tracing] Adding an event to span:", i)
      const r = Dit(t) ? t : e || Bc(),
        s = Dit(t) ? {} : t || {},
        a = { name: i, time: Hc(r), attributes: s }
      return this._events.push(a), this
    }
    isStandaloneSpan() {
      return !!this._isStandaloneSpan
    }
    _onSpanEnded() {
      const i = ln()
      if (
        (i && i.emit("spanEnd", this),
        !(this._isStandaloneSpan || this === Ms(this)))
      )
        return
      if (this._isStandaloneSpan) {
        this._sampled
          ? g_t(f_t([this], i))
          : (Be &&
              ve.log(
                "[Tracing] Discarding standalone span because its trace was not chosen to be sampled.",
              ),
            i && i.recordDroppedEvent("sample_rate", "span"))
        return
      }
      const e = this._convertSpanToTransaction()
      e && (xit(this).scope || Wn()).captureEvent(e)
    }
    _convertSpanToTransaction() {
      if (!Fit(Mr(this))) return
      this._name ||
        (Be &&
          ve.warn(
            "Transaction has no name, falling back to `<unlabeled transaction>`.",
          ),
        (this._name = "<unlabeled transaction>"))
      const { scope: i, isolationScope: t } = xit(this),
        r = (i || Wn()).getClient() || ln()
      if (this._sampled !== !0) {
        Be &&
          ve.log(
            "[Tracing] Discarding transaction because its trace was not chosen to be sampled.",
          ),
          r && r.recordDroppedEvent("sample_rate", "transaction")
        return
      }
      const a = i_t(this)
          .filter((m) => m !== this && !p_t(m))
          .map((m) => Mr(m))
          .filter(Fit),
        o = this._attributes[dM],
        c = {
          contexts: { trace: ZFt(this) },
          spans:
            a.length > Rit
              ? a
                  .sort((m, h) => m.start_timestamp - h.start_timestamp)
                  .slice(0, Rit)
              : a,
          start_timestamp: this._startTime,
          timestamp: this._endTime,
          transaction: this._name,
          type: "transaction",
          sdkProcessingMetadata: {
            capturedSpanScope: i,
            capturedSpanIsolationScope: t,
            ...Ac({ dynamicSamplingContext: wM(this) }),
          },
          _metrics_summary: lM(this),
          ...(o && { transaction_info: { source: o } }),
        },
        u = Lit(this._events)
      return (
        u &&
          Object.keys(u).length &&
          (Be &&
            ve.log(
              "[Measurements] Adding measurements to transaction event",
              JSON.stringify(u, void 0, 2),
            ),
          (c.measurements = u)),
        c
      )
    }
  }
function Dit(i) {
  return (i && typeof i == "number") || i instanceof Date || Array.isArray(i)
}
function Fit(i) {
  return !!i.start_timestamp && !!i.timestamp && !!i.span_id && !!i.trace_id
}
function p_t(i) {
  return i instanceof yM && i.isStandaloneSpan()
}
function g_t(i) {
  const t = ln()
  if (!t) return
  const e = i[1]
  if (!e || e.length === 0) {
    t.recordDroppedEvent("before_send", "span")
    return
  }
  const r = t.getTransport()
  r &&
    r.send(i).then(null, (s) => {
      Be && ve.error("Error while sending span:", s)
    })
}
var _it = "__SENTRY_SUPPRESS_TRACING__"
function v_t(i, t) {
  const e = Ait()
  if (e.startSpanManual) return e.startSpanManual(i, t)
  const r = T_t(i),
    { forceTransaction: s, parentSpan: a } = i
  return uM(i.scope, () =>
    b_t(a)(() => {
      const c = Wn(),
        u = S_t(c),
        m =
          i.onlyIfParent && !u
            ? new vM()
            : y_t({
                parentSpan: u,
                spanArguments: r,
                forceTransaction: s,
                scope: c,
              })
      l8(c, m)
      function h() {
        m.end()
      }
      return a_t(
        () => t(m, h),
        () => {
          const { status: p } = Mr(m)
          m.isRecording() &&
            (!p || p === "ok") &&
            m.setStatus({ code: kit, message: "internal_error" })
        },
      )
    }),
  )
}
function w_t(i, t) {
  const e = Ait()
  return e.withActiveSpan
    ? e.withActiveSpan(i, t)
    : uM((r) => (l8(r, i || void 0), t(r)))
}
function y_t({
  parentSpan: i,
  spanArguments: t,
  forceTransaction: e,
  scope: r,
}) {
  if (!gM()) return new vM()
  const s = Mc()
  let a
  if (i && !e) (a = k_t(i, r, t)), Pit(i, a)
  else if (i) {
    const o = wM(i),
      { traceId: c, spanId: u } = i.spanContext(),
      l = fh(i)
    ;(a = Bit({ traceId: c, parentSpanId: u, ...t }, r, l)), Cit(a, o)
  } else {
    const {
      traceId: o,
      dsc: c,
      parentSpanId: u,
      sampled: l,
    } = { ...s.getPropagationContext(), ...r.getPropagationContext() }
    ;(a = Bit({ traceId: o, parentSpanId: u, ...t }, r, l)), c && Cit(a, c)
  }
  return l_t(a), s_t(a, r, s), a
}
function T_t(i) {
  const e = { isStandalone: (i.experimental || {}).standalone, ...i }
  if (i.startTime) {
    const r = { ...e }
    return (r.startTimestamp = Hc(i.startTime)), delete r.startTime, r
  }
  return e
}
function Ait() {
  const i = Oc()
  return hh(i)
}
function Bit(i, t, e) {
  const r = ln(),
    s = (r && r.getOptions()) || {},
    { name: a = "", attributes: o } = i,
    [c, u] = t.getScopeData().sdkProcessingMetadata[_it]
      ? [!1]
      : h_t(s, {
          name: a,
          parentSampled: e,
          attributes: o,
          transactionContext: { name: a, parentSampled: e },
        }),
    l = new yM({
      ...i,
      attributes: { [dM]: "custom", ...i.attributes },
      sampled: c,
    })
  return u !== void 0 && l.setAttribute(mM, u), r && r.emit("spanStart", l), l
}
function k_t(i, t, e) {
  const { spanId: r, traceId: s } = i.spanContext(),
    a = t.getScopeData().sdkProcessingMetadata[_it] ? !1 : fh(i),
    o = a
      ? new yM({ ...e, parentSpanId: r, traceId: s, sampled: a })
      : new vM({ traceId: s })
  Pit(i, o)
  const c = ln()
  return (
    c && (c.emit("spanStart", o), e.endTimestamp && c.emit("spanEnd", o)), o
  )
}
function S_t(i) {
  const t = d8(i)
  if (!t) return
  const e = ln()
  return (e ? e.getOptions() : {}).parentSpanIsAlwaysRootSpan ? Ms(t) : t
}
function b_t(i) {
  return i !== void 0 ? (t) => w_t(i, t) : (t) => t()
}
function E_t(i) {
  if (i)
    return I_t(i) ? { captureContext: i } : N_t(i) ? { captureContext: i } : i
}
function I_t(i) {
  return i instanceof qc || typeof i == "function"
}
var P_t = [
  "user",
  "level",
  "extra",
  "contexts",
  "tags",
  "fingerprint",
  "requestSession",
  "propagationContext",
]
function N_t(i) {
  return Object.keys(i).some((t) => P_t.includes(t))
}
function $_t(i, t) {
  return Wn().captureException(i, E_t(t))
}
function Oit(i, t) {
  const e = typeof t == "string" ? t : void 0,
    r = typeof t != "string" ? { captureContext: t } : void 0
  return Wn().captureMessage(i, e, r)
}
function kUt(i) {
  return i
}
var qit,
  x_t = "FunctionToString",
  Uit = new WeakMap(),
  J_t = () => ({
    name: x_t,
    setupOnce() {
      qit = Function.prototype.toString
      try {
        Function.prototype.toString = function (...i) {
          const t = zDt(this),
            e = Uit.has(ln()) && t !== void 0 ? t : this
          return qit.apply(e, i)
        }
      } catch {}
    },
    setup(i) {
      Uit.set(i, !0)
    },
  }),
  SUt = J_t,
  C_t = [
    /^Script error\.?$/,
    /^Javascript error: Script error\.? on line 0$/,
    /^ResizeObserver loop completed with undelivered notifications.$/,
    /^Cannot redefine property: googletag$/,
    "undefined is not an object (evaluating 'a.L')",
    `can't redefine non-configurable property "solana"`,
    "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)",
    "Can't find variable: _AutofillCallbackHandler",
  ],
  L_t = "InboundFilters",
  R_t = (i = {}) => ({
    name: L_t,
    processEvent(t, e, r) {
      const s = r.getOptions(),
        a = D_t(i, s)
      return F_t(t, a) ? null : t
    },
  }),
  bUt = R_t
function D_t(i = {}, t = {}) {
  return {
    allowUrls: [...(i.allowUrls || []), ...(t.allowUrls || [])],
    denyUrls: [...(i.denyUrls || []), ...(t.denyUrls || [])],
    ignoreErrors: [
      ...(i.ignoreErrors || []),
      ...(t.ignoreErrors || []),
      ...(i.disableErrorDefaults ? [] : C_t),
    ],
    ignoreTransactions: [
      ...(i.ignoreTransactions || []),
      ...(t.ignoreTransactions || []),
    ],
    ignoreInternal: i.ignoreInternal !== void 0 ? i.ignoreInternal : !0,
  }
}
function F_t(i, t) {
  return t.ignoreInternal && U_t(i)
    ? (Be &&
        ve.warn(`Event dropped due to being internal Sentry Error.
Event: ${Ga(i)}`),
      !0)
    : __t(i, t.ignoreErrors)
      ? (Be &&
          ve.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${Ga(i)}`),
        !0)
      : H_t(i)
        ? (Be &&
            ve.warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${Ga(i)}`),
          !0)
        : A_t(i, t.ignoreTransactions)
          ? (Be &&
              ve.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${Ga(i)}`),
            !0)
          : B_t(i, t.denyUrls)
            ? (Be &&
                ve.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${Ga(i)}.
Url: ${m8(i)}`),
              !0)
            : O_t(i, t.allowUrls)
              ? !1
              : (Be &&
                  ve.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${Ga(i)}.
Url: ${m8(i)}`),
                !0)
}
function __t(i, t) {
  return i.type || !t || !t.length ? !1 : q_t(i).some((e) => s8(e, t))
}
function A_t(i, t) {
  if (i.type !== "transaction" || !t || !t.length) return !1
  const e = i.transaction
  return e ? s8(e, t) : !1
}
function B_t(i, t) {
  if (!t || !t.length) return !1
  const e = m8(i)
  return e ? s8(e, t) : !1
}
function O_t(i, t) {
  if (!t || !t.length) return !0
  const e = m8(i)
  return e ? s8(e, t) : !0
}
function q_t(i) {
  const t = []
  i.message && t.push(i.message)
  let e
  try {
    e = i.exception.values[i.exception.values.length - 1]
  } catch {}
  return (
    e &&
      e.value &&
      (t.push(e.value), e.type && t.push(`${e.type}: ${e.value}`)),
    t
  )
}
function U_t(i) {
  try {
    return i.exception.values[0].type === "SentryError"
  } catch {}
  return !1
}
function M_t(i = []) {
  for (let t = i.length - 1; t >= 0; t--) {
    const e = i[t]
    if (e && e.filename !== "<anonymous>" && e.filename !== "[native code]")
      return e.filename || null
  }
  return null
}
function m8(i) {
  try {
    let t
    try {
      t = i.exception.values[0].stacktrace.frames
    } catch {}
    return t ? M_t(t) : null
  } catch {
    return Be && ve.error(`Cannot extract url for event ${Ga(i)}`), null
  }
}
function H_t(i) {
  return i.type ||
    !i.exception ||
    !i.exception.values ||
    i.exception.values.length === 0
    ? !1
    : !i.message &&
        !i.exception.values.some(
          (t) => t.stacktrace || (t.type && t.type !== "Error") || t.value,
        )
}
var W_t = "cause",
  j_t = 5,
  V_t = "LinkedErrors",
  G_t = (i = {}) => {
    const t = i.limit || j_t,
      e = i.key || W_t
    return {
      name: V_t,
      preprocessEvent(r, s, a) {
        const o = a.getOptions()
        ADt(_Ft, o.stackParser, o.maxValueLength, e, t, r, s)
      },
    }
  },
  EUt = G_t,
  Mit = new Map(),
  Hit = new Set()
function z_t(i) {
  if (Xe._sentryModuleMetadata)
    for (const t of Object.keys(Xe._sentryModuleMetadata)) {
      const e = Xe._sentryModuleMetadata[t]
      if (Hit.has(t)) continue
      Hit.add(t)
      const r = i(t)
      for (const s of r.reverse())
        if (s.filename) {
          Mit.set(s.filename, e)
          break
        }
    }
}
function Y_t(i, t) {
  return z_t(i), Mit.get(t)
}
function Wit(i, t) {
  try {
    t.exception.values.forEach((e) => {
      if (e.stacktrace)
        for (const r of e.stacktrace.frames || []) {
          if (!r.filename || r.module_metadata) continue
          const s = Y_t(i, r.filename)
          s && (r.module_metadata = s)
        }
    })
  } catch {}
}
function jit(i) {
  try {
    i.exception.values.forEach((t) => {
      if (t.stacktrace)
        for (const e of t.stacktrace.frames || []) delete e.module_metadata
    })
  } catch {}
}
var IUt = () => ({
    name: "ModuleMetadata",
    setup(i) {
      i.on("beforeEnvelope", (t) => {
        wit(t, (e, r) => {
          if (r === "event") {
            const s = Array.isArray(e) ? e[1] : void 0
            s && (jit(s), (e[1] = s))
          }
        })
      }),
        i.on("applyFrameMetadata", (t) => {
          if (t.type) return
          const e = i.getOptions().stackParser
          Wit(e, t)
        })
    },
  }),
  TM = {
    include: {
      cookies: !0,
      data: !0,
      headers: !0,
      ip: !1,
      query_string: !0,
      url: !0,
      user: { id: !0, username: !0, email: !0 },
    },
    transactionNamingScheme: "methodPath",
  },
  Q_t = "RequestData",
  X_t = (i = {}) => {
    const t = {
      ...TM,
      ...i,
      include: {
        ...TM.include,
        ...i.include,
        user:
          i.include && typeof i.include.user == "boolean"
            ? i.include.user
            : { ...TM.include.user, ...(i.include || {}).user },
      },
    }
    return {
      name: Q_t,
      processEvent(e) {
        const { sdkProcessingMetadata: r = {} } = e,
          s = r.request
        if (!s) return e
        const a = K_t(t)
        return IFt(e, s, a)
      },
    }
  },
  PUt = X_t
function K_t(i) {
  const {
      transactionNamingScheme: t,
      include: { ip: e, user: r, ...s },
    } = i,
    a = ["method"]
  for (const [c, u] of Object.entries(s)) u && a.push(c)
  let o
  if (r === void 0) o = !0
  else if (typeof r == "boolean") o = r
  else {
    const c = []
    for (const [u, l] of Object.entries(r)) l && c.push(u)
    o = c
  }
  return {
    include: {
      ip: e,
      user: o,
      request: a.length !== 0 ? a : void 0,
      transaction: t,
    },
  }
}
var Z_t = "CaptureConsole",
  t6t = (i = {}) => {
    const t = i.levels || a8
    return {
      name: Z_t,
      setup(e) {
        "console" in Xe &&
          tFt(({ args: r, level: s }) => {
            ln() !== e || !t.includes(s) || e6t(r, s)
          })
      },
    }
  },
  NUt = t6t
function e6t(i, t) {
  const e = { level: $Ft(t), extra: { arguments: i } }
  uM((r) => {
    if (
      (r.addEventProcessor(
        (o) => (
          (o.logger = "console"), nFt(o, { handled: !1, type: "console" }), o
        ),
      ),
      t === "assert")
    ) {
      if (!i[0]) {
        const o = `Assertion failed: ${Ket(i.slice(1), " ") || "console.assert"}`
        r.setExtra("arguments", i.slice(1)), Oit(o, e)
      }
      return
    }
    const s = i.find((o) => o instanceof Error)
    if (s) {
      $_t(s, e)
      return
    }
    const a = Ket(i, " ")
    Oit(a, e)
  })
}
var i6t = "Debug",
  r6t = (i = {}) => {
    const t = { debugger: !1, stringify: !1, ...i }
    return {
      name: i6t,
      setup(e) {
        e.on("beforeSendEvent", (r, s) => {
          if (t.debugger) debugger
          eit(() => {
            t.stringify
              ? (console.log(JSON.stringify(r, null, 2)),
                s &&
                  Object.keys(s).length &&
                  console.log(JSON.stringify(s, null, 2)))
              : (console.log(r), s && Object.keys(s).length && console.log(s))
          })
        })
      },
    }
  },
  $Ut = r6t,
  n6t = "Dedupe",
  s6t = () => {
    let i
    return {
      name: n6t,
      processEvent(t) {
        if (t.type) return t
        try {
          if (a6t(t, i))
            return (
              Be &&
                ve.warn(
                  "Event dropped due to being a duplicate of previously captured event.",
                ),
              null
            )
        } catch {}
        return (i = t)
      },
    }
  },
  xUt = s6t
function a6t(i, t) {
  return t ? !!(o6t(i, t) || c6t(i, t)) : !1
}
function o6t(i, t) {
  const e = i.message,
    r = t.message
  return !(
    (!e && !r) ||
    (e && !r) ||
    (!e && r) ||
    e !== r ||
    !Git(i, t) ||
    !Vit(i, t)
  )
}
function c6t(i, t) {
  const e = zit(t),
    r = zit(i)
  return !(
    !e ||
    !r ||
    e.type !== r.type ||
    e.value !== r.value ||
    !Git(i, t) ||
    !Vit(i, t)
  )
}
function Vit(i, t) {
  let e = nM(i),
    r = nM(t)
  if (!e && !r) return !0
  if ((e && !r) || (!e && r) || ((e = e), (r = r), r.length !== e.length))
    return !1
  for (let s = 0; s < r.length; s++) {
    const a = r[s],
      o = e[s]
    if (
      a.filename !== o.filename ||
      a.lineno !== o.lineno ||
      a.colno !== o.colno ||
      a.function !== o.function
    )
      return !1
  }
  return !0
}
function Git(i, t) {
  let e = i.fingerprint,
    r = t.fingerprint
  if (!e && !r) return !0
  if ((e && !r) || (!e && r)) return !1
  ;(e = e), (r = r)
  try {
    return e.join("") === r.join("")
  } catch {
    return !1
  }
}
function zit(i) {
  return i.exception && i.exception.values && i.exception.values[0]
}
var u6t = "ExtraErrorData",
  l6t = (i = {}) => {
    const { depth: t = 3, captureErrorCause: e = !0 } = i
    return {
      name: u6t,
      processEvent(r, s, a) {
        const { maxValueLength: o = 250 } = a.getOptions()
        return d6t(r, s, t, e, o)
      },
    }
  },
  JUt = l6t
function d6t(i, t = {}, e, r, s) {
  if (!t.originalException || !_c(t.originalException)) return i
  const a = t.originalException.name || t.originalException.constructor.name,
    o = m6t(t.originalException, r, s)
  if (o) {
    const c = { ...i.contexts },
      u = lit(o, e)
    return (
      dh(u) && (Us(u, "__sentry_skip_normalization__", !0), (c[a] = u)),
      { ...i, contexts: c }
    )
  }
  return i
}
function m6t(i, t, e) {
  try {
    const r = [
        "name",
        "message",
        "stack",
        "line",
        "column",
        "fileName",
        "lineNumber",
        "columnNumber",
        "toJSON",
      ],
      s = {}
    for (const a of Object.keys(i)) {
      if (r.indexOf(a) !== -1) continue
      const o = i[a]
      s[a] = _c(o) || typeof o == "string" ? KU(`${o}`, e) : o
    }
    if (
      (t &&
        i.cause !== void 0 &&
        (s.cause = _c(i.cause) ? i.cause.toString() : i.cause),
      typeof i.toJSON == "function")
    ) {
      const a = i.toJSON()
      for (const o of Object.keys(a)) {
        const c = a[o]
        s[o] = _c(c) ? c.toString() : c
      }
    }
    return s
  } catch (r) {
    Be && ve.error("Unable to extract extra data from the Error object:", r)
  }
  return null
}
var h6t = "RewriteFrames",
  CUt = (i = {}) => {
    const t = i.root,
      e = i.prefix || "app:///",
      r = "window" in Xe && Xe.window !== void 0,
      s = i.iteratee || f6t({ isBrowser: r, root: t, prefix: e })
    function a(c) {
      try {
        return {
          ...c,
          exception: {
            ...c.exception,
            values: c.exception.values.map((u) => ({
              ...u,
              ...(u.stacktrace && { stacktrace: o(u.stacktrace) }),
            })),
          },
        }
      } catch {
        return c
      }
    }
    function o(c) {
      return { ...c, frames: c && c.frames && c.frames.map((u) => s(u)) }
    }
    return {
      name: h6t,
      processEvent(c) {
        let u = c
        return c.exception && Array.isArray(c.exception.values) && (u = a(u)), u
      },
    }
  }
function f6t({ isBrowser: i, root: t, prefix: e }) {
  return (r) => {
    if (!r.filename) return r
    const s =
        /^[a-zA-Z]:\\/.test(r.filename) ||
        (r.filename.includes("\\") && !r.filename.includes("/")),
      a = /^\//.test(r.filename)
    if (i) {
      if (t) {
        const o = r.filename
        o.indexOf(t) === 0 && (r.filename = o.replace(t, e))
      }
    } else if (s || a) {
      const o = s
          ? r.filename.replace(/^[a-zA-Z]:/, "").replace(/\\/g, "/")
          : r.filename,
        c = t ? lFt(t, o) : dFt(o)
      r.filename = `${e}${c}`
    }
    return r
  }
}
var p6t = "SessionTiming",
  g6t = () => {
    const i = Bc() * 1e3
    return {
      name: p6t,
      processEvent(t) {
        const e = Bc() * 1e3
        return {
          ...t,
          extra: {
            ...t.extra,
            "session:start": i,
            "session:duration": e - i,
            "session:end": e,
          },
        }
      },
    }
  },
  LUt = g6t,
  v6t = 10,
  w6t = "ZodErrors"
function y6t(i) {
  return _c(i) && i.name === "ZodError" && Array.isArray(i.errors)
}
function T6t(i) {
  return {
    ...i,
    path: "path" in i && Array.isArray(i.path) ? i.path.join(".") : void 0,
    keys: "keys" in i ? JSON.stringify(i.keys) : void 0,
    unionErrors: "unionErrors" in i ? JSON.stringify(i.unionErrors) : void 0,
  }
}
function k6t(i) {
  const t = new Set()
  for (const r of i.issues) r.path && r.path[0] && t.add(r.path[0])
  const e = Array.from(t)
  return `Failed to validate keys: ${KU(e.join(", "), 100)}`
}
function S6t(i, t, e) {
  return !t.exception ||
    !t.exception.values ||
    !e ||
    !e.originalException ||
    !y6t(e.originalException) ||
    e.originalException.issues.length === 0
    ? t
    : {
        ...t,
        exception: {
          ...t.exception,
          values: [
            { ...t.exception.values[0], value: k6t(e.originalException) },
            ...t.exception.values.slice(1),
          ],
        },
        extra: {
          ...t.extra,
          "zoderror.issues": e.originalException.errors.slice(0, i).map(T6t),
        },
      }
}
var b6t = (i = {}) => {
    const t = i.limit || v6t
    return {
      name: w6t,
      processEvent(e, r) {
        return S6t(t, e, r)
      },
    }
  },
  RUt = b6t,
  DUt = (i) => ({
    name: "ThirdPartyErrorsFilter",
    setup(t) {
      t.on("beforeEnvelope", (e) => {
        wit(e, (r, s) => {
          if (s === "event") {
            const a = Array.isArray(r) ? r[1] : void 0
            a && (jit(a), (r[1] = a))
          }
        })
      }),
        t.on("applyFrameMetadata", (e) => {
          if (e.type) return
          const r = t.getOptions().stackParser
          Wit(r, e)
        })
    },
    processEvent(t) {
      const e = E6t(t)
      if (e) {
        const r =
          i.behaviour === "drop-error-if-contains-third-party-frames" ||
          i.behaviour === "apply-tag-if-contains-third-party-frames"
            ? "some"
            : "every"
        if (e[r]((a) => !a.some((o) => i.filterKeys.includes(o)))) {
          if (
            i.behaviour === "drop-error-if-contains-third-party-frames" ||
            i.behaviour ===
              "drop-error-if-exclusively-contains-third-party-frames"
          )
            return null
          t.tags = { ...t.tags, third_party_code: !0 }
        }
      }
      return t
    },
  })
function E6t(i) {
  const t = nM(i)
  if (t)
    return t
      .filter((e) => !!e.filename)
      .map((e) =>
        e.module_metadata
          ? Object.keys(e.module_metadata)
              .filter((r) => r.startsWith(Yit))
              .map((r) => r.slice(Yit.length))
          : [],
      )
}
var Yit = "_sentryBundlerPluginAppKey:",
  I6t = "c",
  P6t = "g",
  N6t = "s",
  $6t = "d"
function x6t(i) {
  let t = 0
  for (let e = 0; e < i.length; e++) {
    const r = i.charCodeAt(e)
    ;(t = (t << 5) - t + r), (t &= t)
  }
  return t >>> 0
}
var J6t = class {
    constructor(i) {
      this._value = i
    }
    get weight() {
      return 1
    }
    add(i) {
      this._value += i
    }
    toString() {
      return `${this._value}`
    }
  },
  C6t = class {
    constructor(i) {
      ;(this._last = i),
        (this._min = i),
        (this._max = i),
        (this._sum = i),
        (this._count = 1)
    }
    get weight() {
      return 5
    }
    add(i) {
      ;(this._last = i),
        i < this._min && (this._min = i),
        i > this._max && (this._max = i),
        (this._sum += i),
        this._count++
    }
    toString() {
      return `${this._last}:${this._min}:${this._max}:${this._sum}:${this._count}`
    }
  },
  L6t = class {
    constructor(i) {
      this._value = [i]
    }
    get weight() {
      return this._value.length
    }
    add(i) {
      this._value.push(i)
    }
    toString() {
      return this._value.join(":")
    }
  },
  R6t = class {
    constructor(i) {
      ;(this.first = i), (this._value = new Set([i]))
    }
    get weight() {
      return this._value.size
    }
    add(i) {
      this._value.add(i)
    }
    toString() {
      return Array.from(this._value)
        .map((i) => (typeof i == "string" ? x6t(i) : i))
        .join(":")
    }
  },
  FUt = { [I6t]: J6t, [P6t]: C6t, [$6t]: L6t, [N6t]: R6t }
function D6t(i, t) {
  return t.onProcessConfigUpdate((e) => {
    ;(Hn().enabled = e.enabled),
      (Hn().loggerSampleRate = e.loggerSampleRate),
      (Hn().tracesSampleRate = e.tracesSampleRate)
  })
}
function F6t(i, t, e = fFt(64)) {
  const r = {
      flush: (a) => e.drain(a),
      send: (a) =>
        e
          .add(() => t.sendEnvelope(i, a))
          .then(
            (o) => ({ statusCode: 200 }),
            (o) => {
              if (o instanceof iit) return {}
              throw o
            },
          ),
    },
    s = Hn().buffer
  for (const a of s) r.send(a)
  return (Hn().buffer = []), (Hn().transport = r), dt.None
}
function _6t(i, t) {
  if (i === "main") return dt.None
  const e = (r) => {
    const s = {}
    r.breadcrumbs.length > 0 && (s.breadcrumbs = r.breadcrumbs),
      Object.keys(s).length > 0 && t.sendScopeUpdate(i, s)
  }
  return (
    Mc().addScopeListener((r) => {
      e(r.getScopeData()), Mc().clearBreadcrumbs()
    }),
    e(Mc().getScopeData()),
    Mc().clearBreadcrumbs(),
    dt.None
  )
}
function A6t(i, t) {
  const e = new bt()
  return e.add(D6t(i, t)), e.add(F6t(i, t)), e.add(_6t(i, t)), e
}
function h8(i) {
  const t = []
  for (const [r, s] of Object.entries(i)) t.push(new JQ({ key: r, value: s }))
  return new Hq({ headers: t })
}
var B6t = class {
    async $updateCppSessionId(i) {
      this.R = i
    }
    async $updateCppTelemEnabled(i) {
      this.S = i
    }
    async $changePreferredEmbeddingModel(i) {
      this.w = i
    }
    constructor(i, t, e) {
      ;(this.W = t),
        (this.X = e),
        (this.b = new C()),
        (this.onDidChangeCursorCreds = this.b.event),
        (this.c = new C()),
        (this.onDidChangePrivacyMode = this.c.event),
        (this.d = new C()),
        (this.onDidChangeCursorAuthToken = this.d.event),
        (this.f = new C()),
        (this.onDidRequestRepoIndex = this.f.event),
        (this.g = new C()),
        (this.onDidRequestRepoInterrupt = this.g.event),
        (this.h = new C()),
        (this.onDidChangeFileSyncClientEnabled = this.h.event),
        (this.i = new C()),
        (this.onDidChangeCppEnabled = this.i.event),
        (this.j = new C()),
        (this.onDidChangeCppConfig = this.j.event),
        (this.l = new C()),
        (this.onDidChangeMembershipType = this.l.event),
        (this.n = new C()),
        (this.onProcessConfigUpdate = this.n.event),
        (this.p = !0),
        (this.s = !0),
        (this.t = !0),
        (this.x = !0),
        (this.P = []),
        (this.Q = []),
        (this.Y = void 0),
        (this.bb = xDt),
        (this.cb = new Map()),
        (this.eb = void 0),
        (this.fb = void 0),
        (this.gb = void 0),
        (this.a = i.getProxy(z.MainThreadCursor)),
        A6t("extension", this.W),
        this.a.$getCursorCreds().then((r) => {
          ;(this.o = r), this.b.fire(r)
        }),
        this.a.$getPrivacyMode().then((r) => {
          ;(this.p = r), this.c.fire(r)
        }),
        this.a.$getCursorAuthToken().then((r) => {
          ;(this.r = r), this.d.fire(r)
        }),
        this.a.$isFileSyncClientEnabled().then((r) => {
          this.s = r
        }),
        this.a.$cppEnabled().then((r) => {
          this.t = r
        }),
        this.a.$cppConfig().then((r) => {
          ;(this.u = r), this.j.fire(r)
        }),
        this.a.$membershipType().then((r) => {
          ;(this.v = r), this.l.fire(r)
        }),
        this.a.$preferredEmbeddingModel().then((r) => {
          this.w = r
        }),
        this.a.$getMachineId().then((r) => {
          this.U = r
        }),
        this.a.$getMacMachineId().then((r) => {
          this.V = r
        })
    }
    getCursorCreds() {
      return this.o
    }
    getPrivacyMode() {
      return this.p
    }
    isFileSyncClientEnabled() {
      return this.s
    }
    cppEnabled() {
      return this.t
    }
    cppConfig() {
      return this.u
    }
    membershipType() {
      return this.v
    }
    preferredEmbeddingModel() {
      return this.w
    }
    shouldIndex() {
      return this.x
    }
    getCursorAuthToken() {
      return this.r
    }
    getSemanticSearchResultsFromServer(i) {
      return this.a.$getSemanticSearchResultsFromServer(i)
    }
    getMachineId() {
      return this.U
    }
    getMacMachineId() {
      return this.V
    }
    $shouldIgnoreUri(i) {
      return this.a.$shouldIgnoreUri(i)
    }
    $adminBlocklistPath() {
      return this.a.$adminBlocklistPath()
    }
    $changeCursorCreds(i) {
      return (this.o = i), this.b.fire(i), Promise.resolve()
    }
    $changePrivacyMode(i) {
      const t = this.p
      return (this.p = i), t !== i && this.c.fire(i), Promise.resolve()
    }
    $changeShouldIndex(i) {
      return (this.x = i), Promise.resolve()
    }
    $changeCursorAuthToken(i) {
      return (this.r = i), this.d.fire(i), Promise.resolve()
    }
    $triggerCursorIndex() {
      return this.f.fire(), Promise.resolve()
    }
    $triggerCursorInterrupt(i) {
      return this.g.fire(i), Promise.resolve()
    }
    $changeFileSyncClientEnabled(i) {
      return (this.s = i), this.h.fire(i), Promise.resolve()
    }
    $changeCppEnabled(i) {
      return (this.t = i), this.i.fire(i), Promise.resolve()
    }
    $changeCppConfig(i) {
      return (this.u = i), this.j.fire(i), Promise.resolve()
    }
    $changeMembershipType(i) {
      return (this.v = i), this.l.fire(i), Promise.resolve()
    }
    updateUploadProgress(i, t, e = !1) {
      this.a.$updateUploadProgress(i, t, e)
    }
    showWebCmdKInputBox(i) {
      return this.a.$showWebCmdKInputBox(i)
    }
    processAiReaderMessage(i) {
      return this.a.$processAiReaderMessage(i)
    }
    $getIndexProviderGetGlobalStatus() {
      const i = this.y
      return i ? i() : Promise.resolve(void 0)
    }
    $getIndexProviderGetStatus(i) {
      const t = this.z?.(i)
      return t || Promise.resolve(void 0)
    }
    $getIndexProviderGetRepoInfo() {
      return this.D ? this.D.getRepoInfo() : Promise.resolve(void 0)
    }
    $getIndexProviderGetPathEncryptionKey() {
      return this.D
        ? this.D.getPathEncryptionKey_ONLY_FOR_VM_AGENT()
        : Promise.resolve(void 0)
    }
    $getIndexProviderDecryptPaths(i) {
      return this.D ? this.D.decryptPaths(i) : Promise.resolve(i)
    }
    $getIndexProviderCompileGlobFilter(i) {
      return this.D
        ? this.D.compileGlobFilter(i)
        : Promise.resolve({ globFilter: void 0, notGlobFilter: void 0 })
    }
    $getIndexProviderGetCodebases() {
      return this.D ? this.D.getCodebases() : Promise.resolve(void 0)
    }
    $getIndexProviderGetIndexingProgress(i) {
      const t = this.A
      return t ? t(i) : Promise.resolve(void 0)
    }
    $getIndexProviderGetCurrentJobs(i) {
      const t = this.B
      return t ? t(i) : Promise.resolve(void 0)
    }
    $getIndexProviderGetHighLevelFolderDescription() {
      const i = this.C
      return i ? i() : Promise.resolve(void 0)
    }
    async $forceFlushExtHostEventLogger() {
      return this.Y?.forceFlush()
    }
    async $recordExtHostEvent(i) {
      return this.Y?.recordExtHostEvent(i)
    }
    $getMetricsProviderIncrement(i) {
      const t = this.E
      return t && t(i), Promise.resolve()
    }
    $getMetricsProviderDecrement(i) {
      const t = this.F
      return t && t(i), Promise.resolve()
    }
    $getMetricsProviderDistribution(i) {
      const t = this.G
      return t && t(i), Promise.resolve()
    }
    $getMetricsProviderGauge(i) {
      const t = this.H
      return t && t(i), Promise.resolve()
    }
    $request(i, t) {
      return this.J ? this.J(i, t) : Promise.resolve("")
    }
    $flush(i) {
      return this.L?.(i) ?? Promise.resolve([])
    }
    $cancel(i) {
      this.M?.(i)
    }
    $getDiffingProviderWordDiff(i, t) {
      const e = this.N
      return e
        ? e(i, t)
        : Promise.resolve({
            changes: [
              { value: t, added: !0 },
              { value: i, removed: !0 },
            ],
          })
    }
    async $getEverythingProviderRunCommand(i, t) {
      const e = this.P
      if (e.length > 0) {
        const r = []
        for (const a of e) r.push(a(i, t))
        const s = await Promise.allSettled(r)
        for (const a of s)
          if (a.status === "fulfilled" && a.value !== void 0) return a.value
      }
    }
    async $getEverythingAllLocalProviderRunCommand(i, t) {
      const e = this.Q
      if (e.length > 0) {
        const r = []
        for (const a of e) r.push(a(i, t))
        const s = await Promise.allSettled(r)
        for (const a of s)
          if (a.status === "fulfilled" && a.value !== void 0) return a.value
      }
    }
    getCppSessionId() {
      return this.R
    }
    getCppTelemEnabled() {
      return (this.S ?? !1) && this.getPrivacyMode() !== !0
    }
    onDidChangeIndexingStatus() {
      return (
        this.a.$onDidChangeIndexingStatus(),
        it(() => {
          this.a.$unregisterOnDidChangeIndexingStatus()
        })
      )
    }
    async triggerRefreshCursorAuthToken() {
      await this.a.$triggerRefreshCursorAuthToken(),
        (this.r = await this.a.$getCursorAuthToken())
    }
    registerExtHostEventLogger(i) {
      return (
        (this.Y = i),
        this.a.$registerExtHostEventLogger(),
        it(() => {
          this.a.$unregisterExtHostEventLogger(), (this.Y = void 0)
        })
      )
    }
    registerIndexProvider(i) {
      return (
        (this.B = i.getCurrentJobs),
        (this.A = i.getIndexingProgress),
        (this.z = i.getStatus),
        (this.C = i.getHighLevelFolderDescription),
        (this.y = i.getGlobalStatus),
        (this.D = i),
        this.a.$registerIndexProvider(),
        it(() => {
          this.a.$unregisterIndexProvider(),
            (this.B = void 0),
            (this.A = void 0),
            (this.z = void 0),
            (this.C = void 0),
            (this.y = void 0),
            (this.D = void 0)
        })
      )
    }
    registerRequesterProvider(i) {
      return (
        (this.J = i.request),
        (this.L = i.flush),
        (this.M = i.cancel),
        this.a.$registerRequesterProvider(),
        it(() => {
          this.a.$unregisterRequesterProvider()
        })
      )
    }
    registerShadowClientProvider(i) {
      return (
        (this.$ = i.get),
        this.a.$registerShadowClientProvider(),
        it(() => {
          this.a.$unregisterShadowClientProvider(), (this.$ = void 0)
        })
      )
    }
    registerShadowServerProvider(i) {
      return (
        (this.Z = i.start),
        this.a.$registerShadowServerProvider(),
        it(() => {
          this.a.$unregisterShadowServerProvider(), (this.Z = void 0)
        })
      )
    }
    $getShadowServerProviderStart(i) {
      return (
        this.Z &&
          this.Z(
            i,
            new Proxy(
              {},
              {
                get: (t, e, r) => {
                  if (typeof e == "string") {
                    const s = Kd.methods[e]?.I
                    if (s === void 0) return
                    const a = Kd.methods[e]?.O
                    if (a === void 0) return
                    const o = e
                    return async (c) => {
                      const u = new s(c),
                        l = await this.a.$callShadowServer(
                          o,
                          Et.wrap(u.toBinary()),
                        )
                      return a.fromBinary(l.buffer)
                    }
                  }
                },
              },
            ),
          ),
        Promise.resolve()
      )
    }
    async $createShadowClient(i) {
      this.$ && (this.ab = await this.$(i))
    }
    async $callShadowServer(i, t) {
      if (this.ab === void 0) throw new Error("Shadow client not initialized")
      const e = this.ab,
        s = e[i].bind(e),
        o = Kd.methods[i].I.fromBinary(t.buffer),
        c = await s(o)
      return Et.wrap(c.toBinary())
    }
    async $callAiConnectTransportProviderUnary(i, t, e, r, s, a) {
      if (this.gb) {
        const o = Yet[i],
          c = o.methods[t],
          u = new AbortController()
        a.onCancellationRequested(() => {
          u.abort()
        })
        const l = u.signal
        let m
        try {
          m = c.I.fromBinary(e.buffer)
        } catch (h) {
          throw (
            (console.error(
              "CONCERNING!!! PLEASE REPORT TO SUALEH",
              "ERROR IN THE EXTHOST",
              h,
            ),
            h)
          )
        }
        try {
          const h = await this.gb.unary(o, c, l, r, s, m),
            p = Object.fromEntries(h.header),
            g = Object.fromEntries(h.trailer),
            w = h8(p),
            T = h8(g),
            b = new s7({
              message: h.message.toBinary(),
              header: w,
              trailer: T,
              isError: !1,
            })
          return Et.wrap(b.toBinary())
        } catch (h) {
          const p = new s7({
            message: new Uint8Array(0),
            isError: !0,
            connectError: JSON.stringify(h),
          })
          return Et.wrap(p.toBinary())
        }
      }
      throw new Error(
        "BIG PROBLEM. BIG PROBLEM. BIG PROBLEM. BIG PROBLEM. BIG PROBLEM. BIG PROBLEM. Connect transport provider not initialized. BIG PROBLEM.",
      )
    }
    db(i) {
      const t = i ?? this.bb,
        e = new $Dt(t),
        r = new AbortController()
      return { promiseQueue: e, canceller: r }
    }
    async $callAiConnectTransportProviderStream(i, t, e, r, s, a, o) {
      if (this.gb) {
        const c = Yet[t],
          u = c.methods[e]
        if (!this.cb.get(i)) {
          const { promiseQueue: b, canceller: N } = this.db(r)
          this.cb.set(i, { promiseQueue: b, canceller: N })
        }
        const m = this.cb.get(i)
        if (m === void 0) throw new Error("Stream ID not found. BIG PROBLEM.")
        const h = m.canceller
        o.onCancellationRequested(() => {
          h.abort()
        })
        const p = h.signal,
          g = m.promiseQueue,
          w = this.cb,
          T = async function* () {
            try {
              for await (const b of g) {
                if (w.get(i)?.canceller.signal.aborted) break
                yield u.I.fromBinary(b.buffer)
              }
            } finally {
            }
          }
        try {
          const b = await this.gb.stream(c, u, p, r, s, T(), a)
          Promise.resolve()
            .then(async () => {
              for await (const V of b.message) {
                if (w.get(i)?.canceller.signal.aborted) break
                const lt = Et.wrap(V.toBinary())
                this.a.$pushAiConnectTransportStreamChunk(lt, i)
              }
              this.a.$endAiConnectTransportStreamChunk(i)
            })
            .catch((V) => {
              this.a.$endAiConnectTransportReportError(i, V)
            })
            .finally(() => {
              w.delete(i)
            })
          const N = Object.fromEntries(b.header),
            $ = Object.fromEntries(b.trailer),
            L = h8(N),
            U = h8($),
            q = new s7({
              message: new Uint8Array(0),
              header: L,
              trailer: U,
              isError: !1,
            })
          return Et.wrap(q.toBinary())
        } catch (b) {
          const N = new s7({
            message: new Uint8Array(0),
            isError: !0,
            connectError: JSON.stringify(b),
          })
          return Et.wrap(N.toBinary())
        }
      }
      throw new Error(
        "Connect transport provider not initialized. BIG PROBLEM.",
      )
    }
    async $pushAiConnectTransportStreamChunk(i, t, e) {
      const r = this.cb.get(t)
      if (r) return r.promiseQueue.push(i), { success: !0 }
      {
        const { promiseQueue: s, canceller: a } = this.db(e)
        return (
          this.cb.set(t, { promiseQueue: s, canceller: a }),
          s.push(i),
          { success: !0 }
        )
      }
    }
    $endAiConnectTransportStreamChunk(i) {
      const t = this.cb.get(i)
      if (t) t.promiseQueue.end()
      else {
        const { promiseQueue: e, canceller: r } = this.db(this.bb)
        this.cb.set(i, { promiseQueue: e, canceller: r }), e.end()
      }
    }
    $cancelAiConnectTransportStreamChunk(i) {
      const t = this.cb.get(i)
      if (t) t.canceller.abort()
      else {
        const { promiseQueue: e, canceller: r } = this.db(this.bb)
        this.cb.set(i, { promiseQueue: e, canceller: r }), r.abort()
      }
    }
    registerMetricsProvider(i) {
      return (
        (this.E = i.increment),
        (this.F = i.decrement),
        (this.G = i.distribution),
        (this.H = i.gauge),
        this.a.$registerMetricsProvider(),
        it(() => {
          this.a.$unregisterMetricsProvider(),
            (this.E = void 0),
            (this.F = void 0),
            (this.G = void 0),
            (this.H = void 0)
        })
      )
    }
    registerDiffingProvider(i) {
      return (
        (this.N = i.wordDiff),
        this.a.$registerDiffingProvider(),
        it(() => {
          this.a.$unregisterDiffingProvider()
        })
      )
    }
    registerEverythingProvider(i) {
      return (
        this.P.push(i.runCommand),
        this.a.$registerEverythingProvider(),
        it(() => {
          this.a.$unregisterEverythingProvider()
        })
      )
    }
    registerEverythingProviderAllLocal(i) {
      return (
        this.Q.push(i.runCommand),
        this.a.$registerEverythingProviderAllLocal(),
        it(() => {
          this.a.$unregisterEverythingProviderAllLocal()
        })
      )
    }
    registerEditHistoryProvider(i) {
      return (
        (this.eb = i),
        this.a.$registerEditHistoryProvider(),
        it(() => {
          this.a.$unregisterEditHistoryProvider(), (this.eb = void 0)
        })
      )
    }
    async $getEditHistoryProviderCompileGlobalDiffTrajectories(i) {
      const t = this.eb
      if (t) return t.compileGlobalDiffTrajectories(i)
    }
    async $getEditHistoryProviderHasProcessedTextModelUptilVersion(i) {
      const t = this.eb
      if (t) return t.hasProcessedTextModelUptilVersion(i)
    }
    async $getEditHistoryProviderInitModel(i) {
      const t = this.eb
      if (t) return t.initModel(i)
    }
    registerLspSubgraphProvider(i) {
      return (
        (this.fb = i),
        this.a.$registerLspSubgraphProvider(),
        it(() => {
          this.a.$unregisterLspSubgraphProvider(), (this.fb = void 0)
        })
      )
    }
    registerConnectTransportProvider(i) {
      ;(this.gb = i), this.a.$registerAiConnectTransportProvider()
    }
    $callLspSubgraphProviderActivate() {
      const i = this.fb
      i && i.activate()
    }
    $callLspSubgraphProviderDeactivate() {
      const i = this.fb
      i && i.deactivate()
    }
    $callLspSubgraphProviderDebouncedForceAbort() {
      const i = this.fb
      i && i.debouncedForceAbort()
    }
    $callLspSubgraphProviderRetrieve(i, t, e, r, s, a) {
      const o = this.fb
      return o ? o.retrieve(i, t, e, r, s, a) : Promise.resolve(void 0)
    }
    publicLogCapture(i) {
      this.a.$publicLogCapture(i)
    }
    async $processConfigUpdate(i) {
      await this.W.processConfigUpdate(i)
    }
  },
  f8 = {},
  qt = { exports: f8 }
;(function (i, t) {
  if (typeof f8 == "object" && typeof qt == "object") qt.exports = t()
  else if (typeof define == "function" && define.amd) define([], t)
  else {
    var e = t()
    for (var r in e) (typeof f8 == "object" ? f8 : i)[r] = e[r]
  }
})(typeof self < "u" ? self : void 0, function () {
  return (function (i) {
    var t = {}
    function e(r) {
      if (t[r]) return t[r].exports
      var s = (t[r] = { i: r, l: !1, exports: {} })
      return i[r].call(s.exports, s, s.exports, e), (s.l = !0), s.exports
    }
    return (
      (e.m = i),
      (e.c = t),
      (e.d = function (r, s, a) {
        e.o(r, s) || Object.defineProperty(r, s, { enumerable: !0, get: a })
      }),
      (e.r = function (r) {
        typeof Symbol < "u" &&
          Symbol.toStringTag &&
          Object.defineProperty(r, Symbol.toStringTag, { value: "Module" }),
          Object.defineProperty(r, "__esModule", { value: !0 })
      }),
      (e.t = function (r, s) {
        if (
          (1 & s && (r = e(r)),
          8 & s || (4 & s && typeof r == "object" && r && r.__esModule))
        )
          return r
        var a = Object.create(null)
        if (
          (e.r(a),
          Object.defineProperty(a, "default", { enumerable: !0, value: r }),
          2 & s && typeof r != "string")
        )
          for (var o in r)
            e.d(
              a,
              o,
              function (c) {
                return r[c]
              }.bind(null, o),
            )
        return a
      }),
      (e.n = function (r) {
        var s =
          r && r.__esModule
            ? function () {
                return r.default
              }
            : function () {
                return r
              }
        return e.d(s, "a", s), s
      }),
      (e.o = function (r, s) {
        return Object.prototype.hasOwnProperty.call(r, s)
      }),
      (e.p = ""),
      e((e.s = 0))
    )
  })([
    function (i, t, e) {
      ;(function (r) {
        var s
        ;(t = i.exports = Qt),
          (s =
            typeof r == "object" &&
            r.env &&
            r.env.NODE_DEBUG &&
            /\bsemver\b/i.test(r.env.NODE_DEBUG)
              ? function () {
                  var x = Array.prototype.slice.call(arguments, 0)
                  x.unshift("SEMVER"), console.log.apply(console, x)
                }
              : function () {}),
          (t.SEMVER_SPEC_VERSION = "2.0.0")
        var a = 256,
          o = Number.MAX_SAFE_INTEGER || 9007199254740991,
          c = (t.re = []),
          u = (t.src = []),
          l = 0,
          m = l++
        u[m] = "0|[1-9]\\d*"
        var h = l++
        u[h] = "[0-9]+"
        var p = l++
        u[p] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*"
        var g = l++
        u[g] = "(" + u[m] + ")\\.(" + u[m] + ")\\.(" + u[m] + ")"
        var w = l++
        u[w] = "(" + u[h] + ")\\.(" + u[h] + ")\\.(" + u[h] + ")"
        var T = l++
        u[T] = "(?:" + u[m] + "|" + u[p] + ")"
        var b = l++
        u[b] = "(?:" + u[h] + "|" + u[p] + ")"
        var N = l++
        u[N] = "(?:-(" + u[T] + "(?:\\." + u[T] + ")*))"
        var $ = l++
        u[$] = "(?:-?(" + u[b] + "(?:\\." + u[b] + ")*))"
        var L = l++
        u[L] = "[0-9A-Za-z-]+"
        var U = l++
        u[U] = "(?:\\+(" + u[L] + "(?:\\." + u[L] + ")*))"
        var q = l++,
          V = "v?" + u[g] + u[N] + "?" + u[U] + "?"
        u[q] = "^" + V + "$"
        var lt = "[v=\\s]*" + u[w] + u[$] + "?" + u[U] + "?",
          at = l++
        u[at] = "^" + lt + "$"
        var et = l++
        u[et] = "((?:<|>)?=?)"
        var wt = l++
        u[wt] = u[h] + "|x|X|\\*"
        var zt = l++
        u[zt] = u[m] + "|x|X|\\*"
        var Ct = l++
        u[Ct] =
          "[v=\\s]*(" +
          u[zt] +
          ")(?:\\.(" +
          u[zt] +
          ")(?:\\.(" +
          u[zt] +
          ")(?:" +
          u[N] +
          ")?" +
          u[U] +
          "?)?)?"
        var be = l++
        u[be] =
          "[v=\\s]*(" +
          u[wt] +
          ")(?:\\.(" +
          u[wt] +
          ")(?:\\.(" +
          u[wt] +
          ")(?:" +
          u[$] +
          ")?" +
          u[U] +
          "?)?)?"
        var G = l++
        u[G] = "^" + u[et] + "\\s*" + u[Ct] + "$"
        var W = l++
        u[W] = "^" + u[et] + "\\s*" + u[be] + "$"
        var tt = l++
        u[tt] =
          "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])"
        var X = l++
        u[X] = "(?:~>?)"
        var Z = l++
        ;(u[Z] = "(\\s*)" + u[X] + "\\s+"), (c[Z] = new RegExp(u[Z], "g"))
        var St = l++
        u[St] = "^" + u[X] + u[Ct] + "$"
        var Dt = l++
        u[Dt] = "^" + u[X] + u[be] + "$"
        var Pt = l++
        u[Pt] = "(?:\\^)"
        var ie = l++
        ;(u[ie] = "(\\s*)" + u[Pt] + "\\s+"), (c[ie] = new RegExp(u[ie], "g"))
        var Ze = l++
        u[Ze] = "^" + u[Pt] + u[Ct] + "$"
        var Te = l++
        u[Te] = "^" + u[Pt] + u[be] + "$"
        var si = l++
        u[si] = "^" + u[et] + "\\s*(" + lt + ")$|^$"
        var wi = l++
        u[wi] = "^" + u[et] + "\\s*(" + V + ")$|^$"
        var le = l++
        ;(u[le] = "(\\s*)" + u[et] + "\\s*(" + lt + "|" + u[Ct] + ")"),
          (c[le] = new RegExp(u[le], "g"))
        var mn = l++
        u[mn] = "^\\s*(" + u[Ct] + ")\\s+-\\s+(" + u[Ct] + ")\\s*$"
        var eo = l++
        u[eo] = "^\\s*(" + u[be] + ")\\s+-\\s+(" + u[be] + ")\\s*$"
        var Ws = l++
        u[Ws] = "(<|>)?=?\\s*\\*"
        for (var or = 0; or < 35; or++)
          s(or, u[or]), c[or] || (c[or] = new RegExp(u[or]))
        function $t(x, D) {
          if (x instanceof Qt) return x
          if (
            typeof x != "string" ||
            x.length > a ||
            !(D ? c[at] : c[q]).test(x)
          )
            return null
          try {
            return new Qt(x, D)
          } catch {
            return null
          }
        }
        function Qt(x, D) {
          if (x instanceof Qt) {
            if (x.loose === D) return x
            x = x.version
          } else if (typeof x != "string")
            throw new TypeError("Invalid Version: " + x)
          if (x.length > a)
            throw new TypeError("version is longer than " + a + " characters")
          if (!(this instanceof Qt)) return new Qt(x, D)
          s("SemVer", x, D), (this.loose = D)
          var B = x.trim().match(D ? c[at] : c[q])
          if (!B) throw new TypeError("Invalid Version: " + x)
          if (
            ((this.raw = x),
            (this.major = +B[1]),
            (this.minor = +B[2]),
            (this.patch = +B[3]),
            this.major > o || this.major < 0)
          )
            throw new TypeError("Invalid major version")
          if (this.minor > o || this.minor < 0)
            throw new TypeError("Invalid minor version")
          if (this.patch > o || this.patch < 0)
            throw new TypeError("Invalid patch version")
          B[4]
            ? (this.prerelease = B[4].split(".").map(function (ot) {
                if (/^[0-9]+$/.test(ot)) {
                  var Tt = +ot
                  if (Tt >= 0 && Tt < o) return Tt
                }
                return ot
              }))
            : (this.prerelease = []),
            (this.build = B[5] ? B[5].split(".") : []),
            this.format()
        }
        ;(t.parse = $t),
          (t.valid = function (x, D) {
            var B = $t(x, D)
            return B ? B.version : null
          }),
          (t.clean = function (x, D) {
            var B = $t(x.trim().replace(/^[=v]+/, ""), D)
            return B ? B.version : null
          }),
          (t.SemVer = Qt),
          (Qt.prototype.format = function () {
            return (
              (this.version = this.major + "." + this.minor + "." + this.patch),
              this.prerelease.length &&
                (this.version += "-" + this.prerelease.join(".")),
              this.version
            )
          }),
          (Qt.prototype.toString = function () {
            return this.version
          }),
          (Qt.prototype.compare = function (x) {
            return (
              s("SemVer.compare", this.version, this.loose, x),
              x instanceof Qt || (x = new Qt(x, this.loose)),
              this.compareMain(x) || this.comparePre(x)
            )
          }),
          (Qt.prototype.compareMain = function (x) {
            return (
              x instanceof Qt || (x = new Qt(x, this.loose)),
              Oi(this.major, x.major) ||
                Oi(this.minor, x.minor) ||
                Oi(this.patch, x.patch)
            )
          }),
          (Qt.prototype.comparePre = function (x) {
            if (
              (x instanceof Qt || (x = new Qt(x, this.loose)),
              this.prerelease.length && !x.prerelease.length)
            )
              return -1
            if (!this.prerelease.length && x.prerelease.length) return 1
            if (!this.prerelease.length && !x.prerelease.length) return 0
            var D = 0
            do {
              var B = this.prerelease[D],
                ot = x.prerelease[D]
              if (
                (s("prerelease compare", D, B, ot),
                B === void 0 && ot === void 0)
              )
                return 0
              if (ot === void 0) return 1
              if (B === void 0) return -1
              if (B !== ot) return Oi(B, ot)
            } while (++D)
          }),
          (Qt.prototype.inc = function (x, D) {
            switch (x) {
              case "premajor":
                ;(this.prerelease.length = 0),
                  (this.patch = 0),
                  (this.minor = 0),
                  this.major++,
                  this.inc("pre", D)
                break
              case "preminor":
                ;(this.prerelease.length = 0),
                  (this.patch = 0),
                  this.minor++,
                  this.inc("pre", D)
                break
              case "prepatch":
                ;(this.prerelease.length = 0),
                  this.inc("patch", D),
                  this.inc("pre", D)
                break
              case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", D),
                  this.inc("pre", D)
                break
              case "major":
                ;(this.minor === 0 &&
                  this.patch === 0 &&
                  this.prerelease.length !== 0) ||
                  this.major++,
                  (this.minor = 0),
                  (this.patch = 0),
                  (this.prerelease = [])
                break
              case "minor":
                ;(this.patch === 0 && this.prerelease.length !== 0) ||
                  this.minor++,
                  (this.patch = 0),
                  (this.prerelease = [])
                break
              case "patch":
                this.prerelease.length === 0 && this.patch++,
                  (this.prerelease = [])
                break
              case "pre":
                if (this.prerelease.length === 0) this.prerelease = [0]
                else {
                  for (var B = this.prerelease.length; --B >= 0; )
                    typeof this.prerelease[B] == "number" &&
                      (this.prerelease[B]++, (B = -2))
                  B === -1 && this.prerelease.push(0)
                }
                D &&
                  (this.prerelease[0] === D
                    ? isNaN(this.prerelease[1]) && (this.prerelease = [D, 0])
                    : (this.prerelease = [D, 0]))
                break
              default:
                throw new Error("invalid increment argument: " + x)
            }
            return this.format(), (this.raw = this.version), this
          }),
          (t.inc = function (x, D, B, ot) {
            typeof B == "string" && ((ot = B), (B = void 0))
            try {
              return new Qt(x, B).inc(D, ot).version
            } catch {
              return null
            }
          }),
          (t.diff = function (x, D) {
            if (vu(x, D)) return null
            var B = $t(x),
              ot = $t(D)
            if (B.prerelease.length || ot.prerelease.length) {
              for (var Tt in B)
                if (
                  (Tt === "major" || Tt === "minor" || Tt === "patch") &&
                  B[Tt] !== ot[Tt]
                )
                  return "pre" + Tt
              return "prerelease"
            }
            for (var Tt in B)
              if (
                (Tt === "major" || Tt === "minor" || Tt === "patch") &&
                B[Tt] !== ot[Tt]
              )
                return Tt
          }),
          (t.compareIdentifiers = Oi)
        var FF = /^[0-9]+$/
        function Oi(x, D) {
          var B = FF.test(x),
            ot = FF.test(D)
          return (
            B && ot && ((x = +x), (D = +D)),
            B && !ot ? -1 : ot && !B ? 1 : x < D ? -1 : x > D ? 1 : 0
          )
        }
        function Ii(x, D, B) {
          return new Qt(x, B).compare(new Qt(D, B))
        }
        function hn(x, D, B) {
          return Ii(x, D, B) > 0
        }
        function io(x, D, B) {
          return Ii(x, D, B) < 0
        }
        function vu(x, D, B) {
          return Ii(x, D, B) === 0
        }
        function _F(x, D, B) {
          return Ii(x, D, B) !== 0
        }
        function ro(x, D, B) {
          return Ii(x, D, B) >= 0
        }
        function wu(x, D, B) {
          return Ii(x, D, B) <= 0
        }
        function js(x, D, B, ot) {
          var Tt
          switch (D) {
            case "===":
              typeof x == "object" && (x = x.version),
                typeof B == "object" && (B = B.version),
                (Tt = x === B)
              break
            case "!==":
              typeof x == "object" && (x = x.version),
                typeof B == "object" && (B = B.version),
                (Tt = x !== B)
              break
            case "":
            case "=":
            case "==":
              Tt = vu(x, B, ot)
              break
            case "!=":
              Tt = _F(x, B, ot)
              break
            case ">":
              Tt = hn(x, B, ot)
              break
            case ">=":
              Tt = ro(x, B, ot)
              break
            case "<":
              Tt = io(x, B, ot)
              break
            case "<=":
              Tt = wu(x, B, ot)
              break
            default:
              throw new TypeError("Invalid operator: " + D)
          }
          return Tt
        }
        function ft(x, D) {
          if (x instanceof ft) {
            if (x.loose === D) return x
            x = x.value
          }
          if (!(this instanceof ft)) return new ft(x, D)
          s("comparator", x, D),
            (this.loose = D),
            this.parse(x),
            this.semver === Vs
              ? (this.value = "")
              : (this.value = this.operator + this.semver.version),
            s("comp", this)
        }
        ;(t.rcompareIdentifiers = function (x, D) {
          return Oi(D, x)
        }),
          (t.major = function (x, D) {
            return new Qt(x, D).major
          }),
          (t.minor = function (x, D) {
            return new Qt(x, D).minor
          }),
          (t.patch = function (x, D) {
            return new Qt(x, D).patch
          }),
          (t.compare = Ii),
          (t.compareLoose = function (x, D) {
            return Ii(x, D, !0)
          }),
          (t.rcompare = function (x, D, B) {
            return Ii(D, x, B)
          }),
          (t.sort = function (x, D) {
            return x.sort(function (B, ot) {
              return t.compare(B, ot, D)
            })
          }),
          (t.rsort = function (x, D) {
            return x.sort(function (B, ot) {
              return t.rcompare(B, ot, D)
            })
          }),
          (t.gt = hn),
          (t.lt = io),
          (t.eq = vu),
          (t.neq = _F),
          (t.gte = ro),
          (t.lte = wu),
          (t.cmp = js),
          (t.Comparator = ft)
        var Vs = {}
        function we(x, D) {
          if (x instanceof we) return x.loose === D ? x : new we(x.raw, D)
          if (x instanceof ft) return new we(x.value, D)
          if (!(this instanceof we)) return new we(x, D)
          if (
            ((this.loose = D),
            (this.raw = x),
            (this.set = x
              .split(/\s*\|\|\s*/)
              .map(function (B) {
                return this.parseRange(B.trim())
              }, this)
              .filter(function (B) {
                return B.length
              })),
            !this.set.length)
          )
            throw new TypeError("Invalid SemVer Range: " + x)
          this.format()
        }
        function ti(x) {
          return !x || x.toLowerCase() === "x" || x === "*"
        }
        function X8(x, D, B, ot, Tt, Ve, Yt, yi, me, ai, cr, $e, Oe) {
          return (
            (D = ti(B)
              ? ""
              : ti(ot)
                ? ">=" + B + ".0.0"
                : ti(Tt)
                  ? ">=" + B + "." + ot + ".0"
                  : ">=" + D) +
            " " +
            (yi = ti(me)
              ? ""
              : ti(ai)
                ? "<" + (+me + 1) + ".0.0"
                : ti(cr)
                  ? "<" + me + "." + (+ai + 1) + ".0"
                  : $e
                    ? "<=" + me + "." + ai + "." + cr + "-" + $e
                    : "<=" + yi)
          ).trim()
        }
        function K8(x, D) {
          for (var B = 0; B < x.length; B++) if (!x[B].test(D)) return !1
          if (D.prerelease.length) {
            for (B = 0; B < x.length; B++)
              if (
                (s(x[B].semver),
                x[B].semver !== Vs && x[B].semver.prerelease.length > 0)
              ) {
                var ot = x[B].semver
                if (
                  ot.major === D.major &&
                  ot.minor === D.minor &&
                  ot.patch === D.patch
                )
                  return !0
              }
            return !1
          }
          return !0
        }
        function yr(x, D, B) {
          try {
            D = new we(D, B)
          } catch {
            return !1
          }
          return D.test(x)
        }
        function yu(x, D, B, ot) {
          var Tt, Ve, Yt, yi, me
          switch (((x = new Qt(x, ot)), (D = new we(D, ot)), B)) {
            case ">":
              ;(Tt = hn), (Ve = wu), (Yt = io), (yi = ">"), (me = ">=")
              break
            case "<":
              ;(Tt = io), (Ve = ro), (Yt = hn), (yi = "<"), (me = "<=")
              break
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"')
          }
          if (yr(x, D, ot)) return !1
          for (var ai = 0; ai < D.set.length; ++ai) {
            var cr = D.set[ai],
              $e = null,
              Oe = null
            if (
              (cr.forEach(function (pi) {
                pi.semver === Vs && (pi = new ft(">=0.0.0")),
                  ($e = $e || pi),
                  (Oe = Oe || pi),
                  Tt(pi.semver, $e.semver, ot)
                    ? ($e = pi)
                    : Yt(pi.semver, Oe.semver, ot) && (Oe = pi)
              }),
              $e.operator === yi ||
                $e.operator === me ||
                ((!Oe.operator || Oe.operator === yi) && Ve(x, Oe.semver)) ||
                (Oe.operator === me && Yt(x, Oe.semver)))
            )
              return !1
          }
          return !0
        }
        ;(ft.prototype.parse = function (x) {
          var D = this.loose ? c[si] : c[wi],
            B = x.match(D)
          if (!B) throw new TypeError("Invalid comparator: " + x)
          ;(this.operator = B[1]),
            this.operator === "=" && (this.operator = ""),
            B[2] ? (this.semver = new Qt(B[2], this.loose)) : (this.semver = Vs)
        }),
          (ft.prototype.toString = function () {
            return this.value
          }),
          (ft.prototype.test = function (x) {
            return (
              s("Comparator.test", x, this.loose),
              this.semver === Vs ||
                (typeof x == "string" && (x = new Qt(x, this.loose)),
                js(x, this.operator, this.semver, this.loose))
            )
          }),
          (ft.prototype.intersects = function (x, D) {
            if (!(x instanceof ft))
              throw new TypeError("a Comparator is required")
            var B
            if (this.operator === "")
              return (B = new we(x.value, D)), yr(this.value, B, D)
            if (x.operator === "")
              return (B = new we(this.value, D)), yr(x.semver, B, D)
            var ot = !(
                (this.operator !== ">=" && this.operator !== ">") ||
                (x.operator !== ">=" && x.operator !== ">")
              ),
              Tt = !(
                (this.operator !== "<=" && this.operator !== "<") ||
                (x.operator !== "<=" && x.operator !== "<")
              ),
              Ve = this.semver.version === x.semver.version,
              Yt = !(
                (this.operator !== ">=" && this.operator !== "<=") ||
                (x.operator !== ">=" && x.operator !== "<=")
              ),
              yi =
                js(this.semver, "<", x.semver, D) &&
                (this.operator === ">=" || this.operator === ">") &&
                (x.operator === "<=" || x.operator === "<"),
              me =
                js(this.semver, ">", x.semver, D) &&
                (this.operator === "<=" || this.operator === "<") &&
                (x.operator === ">=" || x.operator === ">")
            return ot || Tt || (Ve && Yt) || yi || me
          }),
          (t.Range = we),
          (we.prototype.format = function () {
            return (
              (this.range = this.set
                .map(function (x) {
                  return x.join(" ").trim()
                })
                .join("||")
                .trim()),
              this.range
            )
          }),
          (we.prototype.toString = function () {
            return this.range
          }),
          (we.prototype.parseRange = function (x) {
            var D = this.loose
            ;(x = x.trim()), s("range", x, D)
            var B = D ? c[eo] : c[mn]
            ;(x = x.replace(B, X8)),
              s("hyphen replace", x),
              (x = x.replace(c[le], "$1$2$3")),
              s("comparator trim", x, c[le]),
              (x = (x = (x = x.replace(c[Z], "$1~")).replace(c[ie], "$1^"))
                .split(/\s+/)
                .join(" "))
            var ot = D ? c[si] : c[wi],
              Tt = x
                .split(" ")
                .map(function (Ve) {
                  return (function (Yt, yi) {
                    return (
                      s("comp", Yt),
                      (Yt = (function (me, ai) {
                        return me
                          .trim()
                          .split(/\s+/)
                          .map(function (cr) {
                            return (function ($e, Oe) {
                              s("caret", $e, Oe)
                              var pi = Oe ? c[Te] : c[Ze]
                              return $e.replace(
                                pi,
                                function (I, yt, Rt, j, gt) {
                                  var qe
                                  return (
                                    s("caret", $e, I, yt, Rt, j, gt),
                                    ti(yt)
                                      ? (qe = "")
                                      : ti(Rt)
                                        ? (qe =
                                            ">=" +
                                            yt +
                                            ".0.0 <" +
                                            (+yt + 1) +
                                            ".0.0")
                                        : ti(j)
                                          ? (qe =
                                              yt === "0"
                                                ? ">=" +
                                                  yt +
                                                  "." +
                                                  Rt +
                                                  ".0 <" +
                                                  yt +
                                                  "." +
                                                  (+Rt + 1) +
                                                  ".0"
                                                : ">=" +
                                                  yt +
                                                  "." +
                                                  Rt +
                                                  ".0 <" +
                                                  (+yt + 1) +
                                                  ".0.0")
                                          : gt
                                            ? (s("replaceCaret pr", gt),
                                              gt.charAt(0) !== "-" &&
                                                (gt = "-" + gt),
                                              (qe =
                                                yt === "0"
                                                  ? Rt === "0"
                                                    ? ">=" +
                                                      yt +
                                                      "." +
                                                      Rt +
                                                      "." +
                                                      j +
                                                      gt +
                                                      " <" +
                                                      yt +
                                                      "." +
                                                      Rt +
                                                      "." +
                                                      (+j + 1)
                                                    : ">=" +
                                                      yt +
                                                      "." +
                                                      Rt +
                                                      "." +
                                                      j +
                                                      gt +
                                                      " <" +
                                                      yt +
                                                      "." +
                                                      (+Rt + 1) +
                                                      ".0"
                                                  : ">=" +
                                                    yt +
                                                    "." +
                                                    Rt +
                                                    "." +
                                                    j +
                                                    gt +
                                                    " <" +
                                                    (+yt + 1) +
                                                    ".0.0"))
                                            : (s("no pr"),
                                              (qe =
                                                yt === "0"
                                                  ? Rt === "0"
                                                    ? ">=" +
                                                      yt +
                                                      "." +
                                                      Rt +
                                                      "." +
                                                      j +
                                                      " <" +
                                                      yt +
                                                      "." +
                                                      Rt +
                                                      "." +
                                                      (+j + 1)
                                                    : ">=" +
                                                      yt +
                                                      "." +
                                                      Rt +
                                                      "." +
                                                      j +
                                                      " <" +
                                                      yt +
                                                      "." +
                                                      (+Rt + 1) +
                                                      ".0"
                                                  : ">=" +
                                                    yt +
                                                    "." +
                                                    Rt +
                                                    "." +
                                                    j +
                                                    " <" +
                                                    (+yt + 1) +
                                                    ".0.0")),
                                    s("caret return", qe),
                                    qe
                                  )
                                },
                              )
                            })(cr, ai)
                          })
                          .join(" ")
                      })(Yt, yi)),
                      s("caret", Yt),
                      (Yt = (function (me, ai) {
                        return me
                          .trim()
                          .split(/\s+/)
                          .map(function (cr) {
                            return (function ($e, Oe) {
                              var pi = Oe ? c[Dt] : c[St]
                              return $e.replace(
                                pi,
                                function (I, yt, Rt, j, gt) {
                                  var qe
                                  return (
                                    s("tilde", $e, I, yt, Rt, j, gt),
                                    ti(yt)
                                      ? (qe = "")
                                      : ti(Rt)
                                        ? (qe =
                                            ">=" +
                                            yt +
                                            ".0.0 <" +
                                            (+yt + 1) +
                                            ".0.0")
                                        : ti(j)
                                          ? (qe =
                                              ">=" +
                                              yt +
                                              "." +
                                              Rt +
                                              ".0 <" +
                                              yt +
                                              "." +
                                              (+Rt + 1) +
                                              ".0")
                                          : gt
                                            ? (s("replaceTilde pr", gt),
                                              gt.charAt(0) !== "-" &&
                                                (gt = "-" + gt),
                                              (qe =
                                                ">=" +
                                                yt +
                                                "." +
                                                Rt +
                                                "." +
                                                j +
                                                gt +
                                                " <" +
                                                yt +
                                                "." +
                                                (+Rt + 1) +
                                                ".0"))
                                            : (qe =
                                                ">=" +
                                                yt +
                                                "." +
                                                Rt +
                                                "." +
                                                j +
                                                " <" +
                                                yt +
                                                "." +
                                                (+Rt + 1) +
                                                ".0"),
                                    s("tilde return", qe),
                                    qe
                                  )
                                },
                              )
                            })(cr, ai)
                          })
                          .join(" ")
                      })(Yt, yi)),
                      s("tildes", Yt),
                      (Yt = (function (me, ai) {
                        return (
                          s("replaceXRanges", me, ai),
                          me
                            .split(/\s+/)
                            .map(function (cr) {
                              return (function ($e, Oe) {
                                $e = $e.trim()
                                var pi = Oe ? c[W] : c[G]
                                return $e.replace(
                                  pi,
                                  function (I, yt, Rt, j, gt, qe) {
                                    s("xRange", $e, I, yt, Rt, j, gt, qe)
                                    var ur = ti(Rt),
                                      Gr = ur || ti(j),
                                      Gs = Gr || ti(gt)
                                    return (
                                      yt === "=" && Gs && (yt = ""),
                                      ur
                                        ? (I =
                                            yt === ">" || yt === "<"
                                              ? "<0.0.0"
                                              : "*")
                                        : yt && Gs
                                          ? (Gr && (j = 0),
                                            Gs && (gt = 0),
                                            yt === ">"
                                              ? ((yt = ">="),
                                                Gr
                                                  ? ((Rt = +Rt + 1),
                                                    (j = 0),
                                                    (gt = 0))
                                                  : Gs &&
                                                    ((j = +j + 1), (gt = 0)))
                                              : yt === "<=" &&
                                                ((yt = "<"),
                                                Gr
                                                  ? (Rt = +Rt + 1)
                                                  : (j = +j + 1)),
                                            (I = yt + Rt + "." + j + "." + gt))
                                          : Gr
                                            ? (I =
                                                ">=" +
                                                Rt +
                                                ".0.0 <" +
                                                (+Rt + 1) +
                                                ".0.0")
                                            : Gs &&
                                              (I =
                                                ">=" +
                                                Rt +
                                                "." +
                                                j +
                                                ".0 <" +
                                                Rt +
                                                "." +
                                                (+j + 1) +
                                                ".0"),
                                      s("xRange return", I),
                                      I
                                    )
                                  },
                                )
                              })(cr, ai)
                            })
                            .join(" ")
                        )
                      })(Yt, yi)),
                      s("xrange", Yt),
                      (Yt = (function (me, ai) {
                        return (
                          s("replaceStars", me, ai),
                          me.trim().replace(c[Ws], "")
                        )
                      })(Yt, yi)),
                      s("stars", Yt),
                      Yt
                    )
                  })(Ve, D)
                })
                .join(" ")
                .split(/\s+/)
            return (
              this.loose &&
                (Tt = Tt.filter(function (Ve) {
                  return !!Ve.match(ot)
                })),
              (Tt = Tt.map(function (Ve) {
                return new ft(Ve, D)
              }))
            )
          }),
          (we.prototype.intersects = function (x, D) {
            if (!(x instanceof we)) throw new TypeError("a Range is required")
            return this.set.some(function (B) {
              return B.every(function (ot) {
                return x.set.some(function (Tt) {
                  return Tt.every(function (Ve) {
                    return ot.intersects(Ve, D)
                  })
                })
              })
            })
          }),
          (t.toComparators = function (x, D) {
            return new we(x, D).set.map(function (B) {
              return B.map(function (ot) {
                return ot.value
              })
                .join(" ")
                .trim()
                .split(" ")
            })
          }),
          (we.prototype.test = function (x) {
            if (!x) return !1
            typeof x == "string" && (x = new Qt(x, this.loose))
            for (var D = 0; D < this.set.length; D++)
              if (K8(this.set[D], x)) return !0
            return !1
          }),
          (t.satisfies = yr),
          (t.maxSatisfying = function (x, D, B) {
            var ot = null,
              Tt = null
            try {
              var Ve = new we(D, B)
            } catch {
              return null
            }
            return (
              x.forEach(function (Yt) {
                Ve.test(Yt) &&
                  ((ot && Tt.compare(Yt) !== -1) || (Tt = new Qt((ot = Yt), B)))
              }),
              ot
            )
          }),
          (t.minSatisfying = function (x, D, B) {
            var ot = null,
              Tt = null
            try {
              var Ve = new we(D, B)
            } catch {
              return null
            }
            return (
              x.forEach(function (Yt) {
                Ve.test(Yt) &&
                  ((ot && Tt.compare(Yt) !== 1) || (Tt = new Qt((ot = Yt), B)))
              }),
              ot
            )
          }),
          (t.validRange = function (x, D) {
            try {
              return new we(x, D).range || "*"
            } catch {
              return null
            }
          }),
          (t.ltr = function (x, D, B) {
            return yu(x, D, "<", B)
          }),
          (t.gtr = function (x, D, B) {
            return yu(x, D, ">", B)
          }),
          (t.outside = yu),
          (t.prerelease = function (x, D) {
            var B = $t(x, D)
            return B && B.prerelease.length ? B.prerelease : null
          }),
          (t.intersects = function (x, D, B) {
            return (x = new we(x, B)), (D = new we(D, B)), x.intersects(D)
          }),
          (t.coerce = function (x) {
            if (x instanceof Qt) return x
            if (typeof x != "string") return null
            var D = x.match(c[tt])
            return D == null
              ? null
              : $t((D[1] || "0") + "." + (D[2] || "0") + "." + (D[3] || "0"))
          })
      }).call(this, e(1))
    },
    function (i, t) {
      var e,
        r,
        s = (i.exports = {})
      function a() {
        throw new Error("setTimeout has not been defined")
      }
      function o() {
        throw new Error("clearTimeout has not been defined")
      }
      function c(b) {
        if (e === setTimeout) return setTimeout(b, 0)
        if ((e === a || !e) && setTimeout)
          return (e = setTimeout), setTimeout(b, 0)
        try {
          return e(b, 0)
        } catch {
          try {
            return e.call(null, b, 0)
          } catch {
            return e.call(this, b, 0)
          }
        }
      }
      ;(function () {
        try {
          e = typeof setTimeout == "function" ? setTimeout : a
        } catch {
          e = a
        }
        try {
          r = typeof clearTimeout == "function" ? clearTimeout : o
        } catch {
          r = o
        }
      })()
      var u,
        l = [],
        m = !1,
        h = -1
      function p() {
        m &&
          u &&
          ((m = !1), u.length ? (l = u.concat(l)) : (h = -1), l.length && g())
      }
      function g() {
        if (!m) {
          var b = c(p)
          m = !0
          for (var N = l.length; N; ) {
            for (u = l, l = []; ++h < N; ) u && u[h].run()
            ;(h = -1), (N = l.length)
          }
          ;(u = null),
            (m = !1),
            (function ($) {
              if (r === clearTimeout) return clearTimeout($)
              if ((r === o || !r) && clearTimeout)
                return (r = clearTimeout), clearTimeout($)
              try {
                r($)
              } catch {
                try {
                  return r.call(null, $)
                } catch {
                  return r.call(this, $)
                }
              }
            })(b)
        }
      }
      function w(b, N) {
        ;(this.fun = b), (this.array = N)
      }
      function T() {}
      ;(s.nextTick = function (b) {
        var N = new Array(arguments.length - 1)
        if (arguments.length > 1)
          for (var $ = 1; $ < arguments.length; $++) N[$ - 1] = arguments[$]
        l.push(new w(b, N)), l.length !== 1 || m || c(g)
      }),
        (w.prototype.run = function () {
          this.fun.apply(null, this.array)
        }),
        (s.title = "browser"),
        (s.browser = !0),
        (s.env = {}),
        (s.argv = []),
        (s.version = ""),
        (s.versions = {}),
        (s.on = T),
        (s.addListener = T),
        (s.once = T),
        (s.off = T),
        (s.removeListener = T),
        (s.removeAllListeners = T),
        (s.emit = T),
        (s.prependListener = T),
        (s.prependOnceListener = T),
        (s.listeners = function (b) {
          return []
        }),
        (s.binding = function (b) {
          throw new Error("process.binding is not supported")
        }),
        (s.cwd = function () {
          return "/"
        }),
        (s.chdir = function (b) {
          throw new Error("process.chdir is not supported")
        }),
        (s.umask = function () {
          return 0
        })
    },
  ])
})
var _Ut = qt.exports.SEMVER_SPEC_VERSION,
  AUt = qt.exports.parse,
  BUt = qt.exports.valid,
  OUt = qt.exports.coerce,
  qUt = qt.exports.clean,
  UUt = qt.exports.inc,
  MUt = qt.exports.major,
  HUt = qt.exports.minor,
  WUt = qt.exports.patch,
  jUt = qt.exports.prerelease,
  VUt = qt.exports.gt,
  GUt = qt.exports.gte,
  zUt = qt.exports.lt,
  YUt = qt.exports.lte,
  QUt = qt.exports.eq,
  XUt = qt.exports.neq,
  KUt = qt.exports.cmp,
  ZUt = qt.exports.compare,
  tMt = qt.exports.rcompare,
  eMt = qt.exports.compareIdentifiers,
  iMt = qt.exports.rcompareIdentifiers,
  rMt = qt.exports.compareBuild,
  nMt = qt.exports.sort,
  sMt = qt.exports.rsort,
  aMt = qt.exports.diff,
  oMt = qt.exports.validRange,
  cMt = qt.exports.satisfies,
  uMt = qt.exports.maxSatisfying,
  lMt = qt.exports.minSatisfying,
  dMt = qt.exports.minVersion,
  mMt = qt.exports.gtr,
  hMt = qt.exports.ltr,
  fMt = qt.exports.outside,
  pMt = qt.exports.intersects,
  gMt = qt.exports.SemVer,
  vMt = qt.exports.Comparator,
  wMt = qt.exports.Range,
  Qit = /^(\^|>=)?((\d+)|x)\.((\d+)|x)\.((\d+)|x)(\-.*)?$/,
  O6t = /^-(\d{4})(\d{2})(\d{2})$/
function q6t(i) {
  return (i = i.trim()), i === "*" || Qit.test(i)
}
function Xit(i) {
  if (!q6t(i)) return null
  if (((i = i.trim()), i === "*"))
    return {
      hasCaret: !1,
      hasGreaterEquals: !1,
      majorBase: 0,
      majorMustEqual: !1,
      minorBase: 0,
      minorMustEqual: !1,
      patchBase: 0,
      patchMustEqual: !1,
      preRelease: null,
    }
  const t = i.match(Qit)
  return t
    ? {
        hasCaret: t[1] === "^",
        hasGreaterEquals: t[1] === ">=",
        majorBase: t[2] === "x" ? 0 : parseInt(t[2], 10),
        majorMustEqual: t[2] !== "x",
        minorBase: t[4] === "x" ? 0 : parseInt(t[4], 10),
        minorMustEqual: t[4] !== "x",
        patchBase: t[6] === "x" ? 0 : parseInt(t[6], 10),
        patchMustEqual: t[6] !== "x",
        preRelease: t[8] || null,
      }
    : null
}
function Kit(i) {
  if (!i) return null
  const t = i.majorBase,
    e = i.majorMustEqual,
    r = i.minorBase
  let s = i.minorMustEqual
  const a = i.patchBase
  let o = i.patchMustEqual
  i.hasCaret && (t === 0 || (s = !1), (o = !1))
  let c = 0
  if (i.preRelease) {
    const u = O6t.exec(i.preRelease)
    if (u) {
      const [, l, m, h] = u
      c = Date.UTC(Number(l), Number(m) - 1, Number(h))
    }
  }
  return {
    majorBase: t,
    majorMustEqual: e,
    minorBase: r,
    minorMustEqual: s,
    patchBase: a,
    patchMustEqual: o,
    isMinimum: i.hasGreaterEquals,
    notBefore: c,
  }
}
var U6t = class {
  constructor() {
    this.buffers = []
  }
  add(i) {
    let t = this.buffers.indexOf(i)
    return t < 0 && ((t = this.buffers.length), this.buffers.push(i)), t
  }
}
function M6t(i, t) {
  if (t.serializeBuffersForPostMessage) {
    const e = new U6t(),
      s = JSON.stringify(i, (o, c) => {
        if (c instanceof ArrayBuffer)
          return { $$vscode_array_buffer_reference$$: !0, index: e.add(c) }
        if (ArrayBuffer.isView(c)) {
          const u = H6t(c)
          if (u)
            return {
              $$vscode_array_buffer_reference$$: !0,
              index: e.add(c.buffer),
              view: {
                type: u,
                byteLength: c.byteLength,
                byteOffset: c.byteOffset,
              },
            }
        }
        return c
      }),
      a = e.buffers.map((o) => {
        const c = new Uint8Array(o)
        return Et.wrap(c)
      })
    return { message: s, buffers: a }
  } else return { message: JSON.stringify(i), buffers: [] }
}
function H6t(i) {
  switch (i.constructor.name) {
    case "Int8Array":
      return 1
    case "Uint8Array":
      return 2
    case "Uint8ClampedArray":
      return 3
    case "Int16Array":
      return 4
    case "Uint16Array":
      return 5
    case "Int32Array":
      return 6
    case "Uint32Array":
      return 7
    case "Float32Array":
      return 8
    case "Float64Array":
      return 9
    case "BigInt64Array":
      return 10
    case "BigUint64Array":
      return 11
  }
}
function W6t(i, t) {
  const e = t.map((a) => {
      const o = new ArrayBuffer(a.byteLength)
      return new Uint8Array(o).set(a.buffer), o
    }),
    r = t.length
      ? (a, o) => {
          if (
            o &&
            typeof o == "object" &&
            o.$$vscode_array_buffer_reference$$
          ) {
            const c = o,
              { index: u } = c,
              l = e[u]
            if (c.view)
              switch (c.view.type) {
                case 1:
                  return new Int8Array(
                    l,
                    c.view.byteOffset,
                    c.view.byteLength / Int8Array.BYTES_PER_ELEMENT,
                  )
                case 2:
                  return new Uint8Array(
                    l,
                    c.view.byteOffset,
                    c.view.byteLength / Uint8Array.BYTES_PER_ELEMENT,
                  )
                case 3:
                  return new Uint8ClampedArray(
                    l,
                    c.view.byteOffset,
                    c.view.byteLength / Uint8ClampedArray.BYTES_PER_ELEMENT,
                  )
                case 4:
                  return new Int16Array(
                    l,
                    c.view.byteOffset,
                    c.view.byteLength / Int16Array.BYTES_PER_ELEMENT,
                  )
                case 5:
                  return new Uint16Array(
                    l,
                    c.view.byteOffset,
                    c.view.byteLength / Uint16Array.BYTES_PER_ELEMENT,
                  )
                case 6:
                  return new Int32Array(
                    l,
                    c.view.byteOffset,
                    c.view.byteLength / Int32Array.BYTES_PER_ELEMENT,
                  )
                case 7:
                  return new Uint32Array(
                    l,
                    c.view.byteOffset,
                    c.view.byteLength / Uint32Array.BYTES_PER_ELEMENT,
                  )
                case 8:
                  return new Float32Array(
                    l,
                    c.view.byteOffset,
                    c.view.byteLength / Float32Array.BYTES_PER_ELEMENT,
                  )
                case 9:
                  return new Float64Array(
                    l,
                    c.view.byteOffset,
                    c.view.byteLength / Float64Array.BYTES_PER_ELEMENT,
                  )
                case 10:
                  return new BigInt64Array(
                    l,
                    c.view.byteOffset,
                    c.view.byteLength / BigInt64Array.BYTES_PER_ELEMENT,
                  )
                case 11:
                  return new BigUint64Array(
                    l,
                    c.view.byteOffset,
                    c.view.byteLength / BigUint64Array.BYTES_PER_ELEMENT,
                  )
                default:
                  throw new Error("Unknown array buffer view type")
              }
            return l
          }
          return o
        }
      : void 0
  return { message: JSON.parse(i, r), arrayBuffers: e }
}
var j6t = class {
  #t
  #e
  #i
  #r
  #s
  #n
  #o
  #a
  #c
  #u
  #l
  #m
  constructor(i, t, e, r, s, a, o) {
    ;(this.#o = ""),
      (this.#c = !1),
      (this.#u = !1),
      (this._onMessageEmitter = new C()),
      (this.onDidReceiveMessage = this._onMessageEmitter.event),
      (this.#d = new C()),
      (this._onDidDispose = this.#d.event),
      (this.#t = i),
      (this.#e = t),
      (this.#a = e),
      (this.#r = r),
      (this.#s = s),
      (this.#n = a),
      (this.#l = Wc(a)),
      (this.#m = V6t(a)),
      (this.#i = o)
  }
  #d
  dispose() {
    ;(this.#c = !0),
      this.#d.fire(),
      this.#d.dispose(),
      this._onMessageEmitter.dispose()
  }
  asWebviewUri(i) {
    return (this.#u = !0), Xd(i, this.#r)
  }
  get cspSource() {
    const i = this.#n.extensionLocation
    if (i.scheme === Q.https || i.scheme === Q.http) {
      let t = i.toString()
      return t.endsWith("/") || (t += "/"), t + " " + IU
    }
    return IU
  }
  get html() {
    return this.a(), this.#o
  }
  set html(i) {
    this.a(),
      this.#o !== i &&
        ((this.#o = i),
        this.#m &&
          !this.#u &&
          /(["'])vscode-resource:([^\s'"]+?)(["'])/i.test(i) &&
          ((this.#u = !0),
          this.#i.report(
            "Webview vscode-resource: uris",
            this.#n,
            "Please migrate to use the 'webview.asWebviewUri' api instead: https://aka.ms/vscode-webview-use-aswebviewuri",
          )),
        this.#e.$setHtml(this.#t, this.b(i)))
  }
  get options() {
    return this.a(), this.#a
  }
  set options(i) {
    this.a(),
      Ir(this.#a, i) || this.#e.$setOptions(this.#t, Zit(this.#n, this.#s, i)),
      (this.#a = i)
  }
  async postMessage(i) {
    if (this.#c) return !1
    const t = M6t(i, { serializeBuffersForPostMessage: this.#l })
    return this.#e.$postMessage(this.#t, t.message, ...t.buffers)
  }
  a() {
    if (this.#c) throw new Error("Webview is disposed")
  }
  b(i) {
    if (!this.#m) return i
    const t = this.#n.extensionLocation?.scheme === Q.vscodeRemote,
      e =
        this.#n.extensionLocation.scheme === Q.vscodeRemote
          ? this.#n.extensionLocation.authority
          : void 0
    return i
      .replace(
        /(["'])(?:vscode-resource):(\/\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi,
        (r, s, a, o, c, u) => {
          const l = S.from({
              scheme: o || "file",
              path: decodeURIComponent(c),
            }),
            m = Xd(l, { isRemote: t, authority: e }).toString()
          return `${s}${m}${u}`
        },
      )
      .replace(
        /(["'])(?:vscode-webview-resource):(\/\/[^\s\/'"]+\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi,
        (r, s, a, o, c, u) => {
          const l = S.from({
              scheme: o || "file",
              path: decodeURIComponent(c),
            }),
            m = Xd(l, { isRemote: t, authority: e }).toString()
          return `${s}${m}${u}`
        },
      )
  }
}
function Wc(i) {
  try {
    const t = Kit(Xit(i.engines.vscode))
    return !!t && t.majorBase >= 1 && t.minorBase >= 57
  } catch {
    return !1
  }
}
function V6t(i) {
  try {
    const t = Kit(Xit(i.engines.vscode))
    return t ? t.majorBase < 1 || (t.majorBase === 1 && t.minorBase < 60) : !1
  } catch {
    return !1
  }
}
var G6t = class extends dt {
  constructor(i, t, e, r, s) {
    super(),
      (this.c = t),
      (this.f = e),
      (this.g = r),
      (this.h = s),
      (this.b = new Map()),
      (this.a = i.getProxy(z.MainThreadWebviews))
  }
  dispose() {
    super.dispose()
    for (const i of this.b.values()) i.dispose()
    this.b.clear()
  }
  $onMessage(i, t, e) {
    const r = this.j(i)
    if (r) {
      const { message: s } = W6t(t, e.value)
      r._onMessageEmitter.fire(s)
    }
  }
  $onMissingCsp(i, t) {
    this.g.warn(
      `${t} created a webview without a content security policy: https://aka.ms/vscode-webview-missing-csp`,
    )
  }
  createNewWebview(i, t, e) {
    const r = new j6t(i, this.a, z6t(t), this.c, this.f, e, this.h)
    this.b.set(i, r)
    const s = r._onDidDispose(() => {
      s.dispose(), this.deleteWebview(i)
    })
    return r
  }
  deleteWebview(i) {
    this.b.delete(i)
  }
  j(i) {
    return this.b.get(i)
  }
}
function p8(i) {
  return { id: i.identifier, location: i.extensionLocation }
}
function Zit(i, t, e) {
  return {
    enableCommandUris: e.enableCommandUris,
    enableScripts: e.enableScripts,
    enableForms: e.enableForms,
    portMapping: e.portMapping,
    localResourceRoots: e.localResourceRoots || Y6t(i, t),
  }
}
function z6t(i) {
  return {
    enableCommandUris: i.enableCommandUris,
    enableScripts: i.enableScripts,
    enableForms: i.enableForms,
    portMapping: i.portMapping,
    localResourceRoots: i.localResourceRoots?.map((t) => S.from(t)),
  }
}
function Y6t(i, t) {
  return [
    ...(t?.getWorkspaceFolders() || []).map((e) => e.uri),
    i.extensionLocation,
  ]
}
var Hr = class nst {
    static {
      this.a = !1
    }
    constructor(t) {
      ;(this.d = t), (this.b = new Map()), (this.c = 1)
    }
    add(t) {
      const e = this.c++
      return this.b.set(e, t), this.e(), e
    }
    get(t, e) {
      return this.b.has(t) ? this.b.get(t)[e] : void 0
    }
    delete(t) {
      this.b.delete(t), this.e()
    }
    e() {
      nst.a && console.log(`${this.d} cache size - ${this.b.size}`)
    }
  },
  Q6t = class {
    constructor(i, t) {
      ;(this.document = i),
        (this.b = t),
        (this.a = 1),
        (this.c = new Hr("custom documents"))
    }
    addEdit(i) {
      return this.c.add([i])
    }
    async undo(i, t) {
      await this.f(i).undo(), t || this.disposeBackup()
    }
    async redo(i, t) {
      await this.f(i).redo(), t || this.disposeBackup()
    }
    disposeEdits(i) {
      for (const t of i) this.c.delete(t)
    }
    getNewBackupUri() {
      if (!this.b) throw new Error("Backup requires a valid storage path")
      const i = iAt(this.document.uri) + this.a++
      return Ti(this.b, i)
    }
    updateBackup(i) {
      this.d?.delete(), (this.d = i)
    }
    disposeBackup() {
      this.d?.delete(), (this.d = void 0)
    }
    f(i) {
      const t = this.c.get(i, 0)
      if (!t) throw new Error("No edit found")
      return t
    }
  },
  X6t = class {
    constructor() {
      this.a = new Map()
    }
    get(i, t) {
      return this.a.get(this.b(i, t))
    }
    add(i, t, e) {
      const r = this.b(i, t.uri)
      if (this.a.has(r))
        throw new Error(
          `Document already exists for viewType:${i} resource:${t.uri}`,
        )
      const s = new Q6t(t, e)
      return this.a.set(r, s), s
    }
    delete(i, t) {
      const e = this.b(i, t.uri)
      this.a.delete(e)
    }
    b(i, t) {
      return `${i}@@@${t}`
    }
  },
  trt
;(function (i) {
  ;(i[(i.Text = 0)] = "Text"), (i[(i.Custom = 1)] = "Custom")
})(trt || (trt = {}))
var K6t = class {
    constructor() {
      this.a = new Map()
    }
    addTextProvider(i, t, e) {
      return this.b(i, { type: 0, extension: t, provider: e })
    }
    addCustomProvider(i, t, e) {
      return this.b(i, { type: 1, extension: t, provider: e })
    }
    get(i) {
      return this.a.get(i)
    }
    b(i, t) {
      if (this.a.has(i))
        throw new Error(`Provider for viewType:${i} already registered`)
      return this.a.set(i, t), new At(() => this.a.delete(i))
    }
  },
  Z6t = class {
    constructor(i, t, e, r, s) {
      ;(this.d = t),
        (this.f = e),
        (this.g = r),
        (this.h = s),
        (this.b = new K6t()),
        (this.c = new X6t()),
        (this.a = i.getProxy(z.MainThreadCustomEditors))
    }
    registerCustomEditorProvider(i, t, e, r) {
      const s = new bt()
      return (
        tAt(e)
          ? (s.add(this.b.addTextProvider(t, i, e)),
            this.a.$registerTextEditorProvider(
              p8(i),
              t,
              r.webviewOptions || {},
              { supportsMove: !!e.moveCustomTextEditor },
              Wc(i),
            ))
          : (s.add(this.b.addCustomProvider(t, i, e)),
            g8(e) &&
              s.add(
                e.onDidChangeCustomDocument((a) => {
                  const o = this.i(t, a.document.uri)
                  if (eAt(a)) {
                    const c = o.addEdit(a)
                    this.a.$onDidEdit(a.document.uri, t, c, a.label)
                  } else this.a.$onContentChange(a.document.uri, t)
                }),
              ),
            this.a.$registerCustomEditorProvider(
              p8(i),
              t,
              r.webviewOptions || {},
              !!r.supportsMultipleEditorsPerDocument,
              Wc(i),
            )),
        At.from(
          s,
          new At(() => {
            this.a.$unregisterEditorProvider(t)
          }),
        )
      )
    }
    async $createCustomDocument(i, t, e, r, s) {
      const a = this.b.get(t)
      if (!a) throw new Error(`No provider found for '${t}'`)
      if (a.type !== 1) throw new Error(`Invalid provide type for '${t}'`)
      const o = S.revive(i),
        c = await a.provider.openCustomDocument(
          o,
          { backupId: e, untitledDocumentData: r?.buffer },
          s,
        )
      let u
      return (
        g8(a.provider) &&
          this.f &&
          (u =
            this.f.workspaceValue(a.extension) ??
            this.f.globalValue(a.extension)),
        this.c.add(t, c, u),
        { editable: g8(a.provider) }
      )
    }
    async $disposeCustomDocument(i, t) {
      const e = this.b.get(t)
      if (!e) throw new Error(`No provider found for '${t}'`)
      if (e.type !== 1) throw new Error(`Invalid provider type for '${t}'`)
      const r = S.revive(i),
        { document: s } = this.i(t, r)
      this.c.delete(t, s), s.dispose()
    }
    async $resolveCustomEditor(i, t, e, r, s, a) {
      const o = this.b.get(e)
      if (!o) throw new Error(`No provider found for '${e}'`)
      const c = Me.to(s),
        u = this.g.createNewWebview(t, r.contentOptions, o.extension),
        l = this.h.createNewWebviewPanel(
          t,
          e,
          r.title,
          c,
          r.options,
          u,
          r.active,
        ),
        m = S.revive(i)
      switch (o.type) {
        case 1: {
          const { document: h } = this.i(e, m)
          return o.provider.resolveCustomEditor(h, l, a)
        }
        case 0: {
          const h = this.d.getDocument(m)
          return o.provider.resolveCustomTextEditor(h, l, a)
        }
        default:
          throw new Error("Unknown webview provider type")
      }
    }
    $disposeEdits(i, t, e) {
      this.i(t, i).disposeEdits(e)
    }
    async $onMoveCustomEditor(i, t, e) {
      const r = this.b.get(e)
      if (!r) throw new Error(`No provider found for '${e}'`)
      if (!r.provider.moveCustomTextEditor)
        throw new Error(`Provider does not implement move '${e}'`)
      const s = this.h.getWebviewPanel(i)
      if (!s) throw new Error("No webview found")
      const a = S.revive(t),
        o = this.d.getDocument(a)
      await r.provider.moveCustomTextEditor(o, s, fe.None)
    }
    async $undo(i, t, e, r) {
      return this.i(t, i).undo(e, r)
    }
    async $redo(i, t, e, r) {
      return this.i(t, i).redo(e, r)
    }
    async $revert(i, t, e) {
      const r = this.i(t, i)
      await this.j(t).revertCustomDocument(r.document, e), r.disposeBackup()
    }
    async $onSave(i, t, e) {
      const r = this.i(t, i)
      await this.j(t).saveCustomDocument(r.document, e), r.disposeBackup()
    }
    async $onSaveAs(i, t, e, r) {
      const s = this.i(t, i)
      return this.j(t).saveCustomDocumentAs(s.document, S.revive(e), r)
    }
    async $backup(i, t, e) {
      const r = this.i(t, i),
        a = await this.j(t).backupCustomDocument(
          r.document,
          { destination: r.getNewBackupUri() },
          e,
        )
      return r.updateBackup(a), a.id
    }
    i(i, t) {
      const e = this.c.get(i, S.revive(t))
      if (!e) throw new Error("No custom document found")
      return e
    }
    j(i) {
      const e = this.b.get(i)?.provider
      if (!e || !g8(e)) throw new Error("Custom document is not editable")
      return e
    }
  }
function g8(i) {
  return !!i.onDidChangeCustomDocument
}
function tAt(i) {
  return typeof i.resolveCustomTextEditor == "function"
}
function eAt(i) {
  return typeof i.undo == "function" && typeof i.redo == "function"
}
function iAt(i) {
  const t =
    i.scheme === Q.file || i.scheme === Q.untitled ? i.fsPath : i.toString()
  return Au(t) + ""
}
var za,
  ert = class sst {
    #t
    #e
    #i
    constructor(t, e, r, s, a, o, c, u) {
      ;(this.d = t),
        (this.e = e),
        (this.f = r),
        (this.g = s),
        (this.h = a),
        (this.c = !1),
        (this.f = Math.max(s, r)),
        (this.#i = new ei((l) => o.getComparisonKey(l))),
        (this.#t = c),
        (this.#e = u)
    }
    dispose() {
      this.c ||
        (this.#e.fire([...this.#i.keys()]),
        this.#t?.$clear(this.e),
        this.#i.clear(),
        (this.c = !0))
    }
    get name() {
      return this.j(), this.d
    }
    set(t, e) {
      if (!t) {
        this.clear()
        return
      }
      this.j()
      let r = []
      if (S.isUri(t)) {
        if (!e) {
          this.delete(t)
          return
        }
        this.#i.set(t, e.slice()), (r = [t])
      } else if (Array.isArray(t)) {
        r = []
        let o
        t = [...t].sort(sst.k)
        for (const c of t) {
          const [u, l] = c
          if (
            ((!o || u.toString() !== o.toString()) &&
              (o && this.#i.get(o).length === 0 && this.#i.delete(o),
              (o = u),
              r.push(u),
              this.#i.set(u, [])),
            l)
          )
            this.#i.get(u)?.push(...l)
          else {
            const m = this.#i.get(u)
            m && (m.length = 0)
          }
        }
      }
      if ((this.#e.fire(r), !this.#t)) return
      const s = []
      let a = 0
      for (const o of r) {
        let c = []
        const u = this.#i.get(o)
        if (u)
          if (u.length > this.g) {
            c = []
            const l = [di.Error, di.Warning, di.Information, di.Hint]
            t: for (let m = 0; m < 4; m++)
              for (const h of u)
                if (
                  h.severity === l[m] &&
                  c.push({ ...ic.from(h), modelVersionId: this.h(o) }) ===
                    this.g
                )
                  break t
            c.push({
              severity: xi.Info,
              message: f(2757, null, u.length - this.g),
              startLineNumber: c[c.length - 1].startLineNumber,
              startColumn: c[c.length - 1].startColumn,
              endLineNumber: c[c.length - 1].endLineNumber,
              endColumn: c[c.length - 1].endColumn,
            })
          } else
            c = u.map((l) => ({ ...ic.from(l), modelVersionId: this.h(o) }))
        if ((s.push([o, c]), (a += c.length), a > this.f)) break
      }
      this.#t.$changeMany(this.e, s)
    }
    delete(t) {
      this.j(),
        this.#e.fire([t]),
        this.#i.delete(t),
        this.#t?.$changeMany(this.e, [[t, void 0]])
    }
    clear() {
      this.j(),
        this.#e.fire([...this.#i.keys()]),
        this.#i.clear(),
        this.#t?.$clear(this.e)
    }
    forEach(t, e) {
      this.j()
      for (const [r, s] of this) t.call(e, r, s, this)
    }
    *[Symbol.iterator]() {
      this.j()
      for (const t of this.#i.keys()) yield [t, this.get(t)]
    }
    get(t) {
      this.j()
      const e = this.#i.get(t)
      return Array.isArray(e) ? Object.freeze(e.slice(0)) : []
    }
    has(t) {
      return this.j(), Array.isArray(this.#i.get(t))
    }
    j() {
      if (this.c) throw new Error("illegal state - object is disposed")
    }
    static k(t, e) {
      return t[0].toString() < e[0].toString()
        ? -1
        : t[0].toString() > e[0].toString()
          ? 1
          : 0
    }
  },
  kM = class {
    static {
      za = this
    }
    static {
      this.c = 0
    }
    static {
      this.d = 1e3
    }
    static {
      this.e = 1.1 * this.d
    }
    static _mapper(t) {
      const e = new ei()
      for (const r of t) e.set(r, r)
      return { uris: Object.freeze(Array.from(e.values())) }
    }
    constructor(t, e, r, s) {
      ;(this.j = e),
        (this.k = r),
        (this.l = s),
        (this.g = new Map()),
        (this.h = new Fat({ merge: (a) => a.flat(), delay: 50 })),
        (this.onDidChangeDiagnostics = Ee.map(this.h.event, za._mapper)),
        (this.f = t.getProxy(z.MainThreadDiagnostics))
    }
    createDiagnosticCollection(t, e) {
      const { g: r, f: s, h: a, j: o, k: c, l: u } = this,
        l = new (class {
          $changeMany(p, g) {
            s.$changeMany(p, g),
              o.trace(
                "[DiagnosticCollection] change many (extension, owner, uris)",
                t.value,
                p,
                g.length === 0 ? "CLEARING" : g,
              )
          }
          $clear(p) {
            s.$clear(p),
              o.trace(
                "[DiagnosticCollection] remove all (extension, owner)",
                t.value,
                p,
              )
          }
          dispose() {
            s.dispose()
          }
        })()
      let m
      if (!e) (e = "_generated_diagnostic_collection_name_#" + za.c++), (m = e)
      else if (!r.has(e)) m = e
      else {
        this.j.warn(`DiagnosticCollection with name '${e}' does already exist.`)
        do m = e + za.c++
        while (r.has(m))
      }
      return new (class extends ert {
        constructor() {
          super(
            e,
            m,
            za.e,
            za.d,
            (p) => u.getDocument(p)?.version,
            c.extUri,
            l,
            a,
          ),
            r.set(m, this)
        }
        dispose() {
          super.dispose(), r.delete(m)
        }
      })()
    }
    getDiagnostics(t) {
      if (t) return this.m(t)
      {
        const e = new Map(),
          r = []
        for (const s of this.g.values())
          s.forEach((a, o) => {
            let c = e.get(a.toString())
            typeof c > "u" &&
              ((c = r.length), e.set(a.toString(), c), r.push([a, []])),
              (r[c][1] = r[c][1].concat(...o))
          })
        return r
      }
    }
    m(t) {
      let e = []
      for (const r of this.g.values()) r.has(t) && (e = e.concat(r.get(t)))
      return e
    }
    $acceptMarkersChange(t) {
      if (!this.n) {
        const e = "_generated_mirror",
          r = new ert(
            e,
            e,
            Number.MAX_SAFE_INTEGER,
            Number.MAX_SAFE_INTEGER,
            (s) => {},
            this.k.extUri,
            void 0,
            this.h,
          )
        this.g.set(e, r), (this.n = r)
      }
      for (const [e, r] of t) this.n.set(S.revive(e), r.map(ic.to))
    }
  }
kM = za = __decorate([__param(1, Kt), __param(2, To)], kM)
var rAt = class {
    constructor(i) {
      this.a = i.getProxy(z.MainThreadDialogs)
    }
    showOpenDialog(i, t) {
      return (
        t?.allowUIResources && F(i, "showLocal"),
        this.a
          .$showOpenDialog(t)
          .then((e) => (e ? e.map((r) => S.revive(r)) : void 0))
      )
    }
    showSaveDialog(i) {
      return this.a.$showSaveDialog(i).then((t) => (t ? S.revive(t) : void 0))
    }
  },
  nAt = class ast {
    static {
      this.a = 0
    }
    constructor(t, e, r) {
      ;(this.d = e),
        (this.e = r),
        (this.b = new Map()),
        (this.c = t.getProxy(z.MainThreadDocumentContentProviders))
    }
    registerTextDocumentContentProvider(t, e) {
      if (Object.keys(Q).indexOf(t) >= 0)
        throw new Error(`scheme '${t}' already registered`)
      const r = ast.a++
      this.b.set(r, e), this.c.$registerTextContentProvider(r, t)
      let s
      if (typeof e.onDidChange == "function") {
        let a
        s = e.onDidChange(async (o) => {
          if (o.scheme !== t) {
            this.e.warn(
              `Provider for scheme '${t}' is firing event for schema '${o.scheme}' which will be IGNORED`,
            )
            return
          }
          if (!this.d.getDocument(o)) return
          a && (await a)
          const c = this.$provideTextDocumentContent(r, o)
            .then(async (u) => {
              if (!u && typeof u != "string") return
              const l = this.d.getDocument(o)
              if (!l) return
              const m = DW(u)
              if (!l.equalLines(m)) return this.c.$onVirtualDocumentChange(o, u)
            })
            .catch(Ui)
            .finally(() => {
              a === c && (a = void 0)
            })
          a = c
        })
      }
      return new At(() => {
        this.b.delete(r) && this.c.$unregisterTextContentProvider(r),
          s && (s.dispose(), (s = void 0))
      })
    }
    $provideTextDocumentContent(t, e) {
      const r = this.b.get(t)
      return r
        ? Promise.resolve(r.provideTextDocumentContent(S.revive(e), fe.None))
        : Promise.reject(new Error(`unsupported uri-scheme: ${e.scheme}`))
    }
  },
  sAt = class {
    constructor(i, t, e, r = { timeout: 1500, errors: 3 }) {
      ;(this.c = i),
        (this.d = t),
        (this.f = e),
        (this.g = r),
        (this.a = new Eu()),
        (this.b = new WeakMap())
    }
    dispose() {
      this.a.clear()
    }
    getOnWillSaveTextDocumentEvent(i) {
      return (t, e, r) => {
        const a = { dispose: this.a.push([t, e, i]) }
        return Array.isArray(r) && r.push(a), a
      }
    }
    async $participateInSave(i, t) {
      const e = S.revive(i)
      let r = !1
      const s = setTimeout(() => (r = !0), this.g.timeout),
        a = []
      try {
        for (const o of [...this.a]) {
          if (r) break
          const c = this.d.getDocument(e),
            u = await this.h(o, { document: c, reason: hA.to(t) })
          a.push(u)
        }
      } finally {
        clearTimeout(s)
      }
      return a
    }
    h([i, t, e], r) {
      const s = this.b.get(i)
      return typeof s == "number" && s > this.g.errors
        ? Promise.resolve(!1)
        : this.i(e, i, t, r).then(
            () => !0,
            (a) => {
              if (
                (this.c.error(
                  `onWillSaveTextDocument-listener from extension '${e.identifier.value}' threw ERROR`,
                ),
                this.c.error(a),
                !(a instanceof Error) || a.message !== "concurrent_edits")
              ) {
                const o = this.b.get(i)
                this.b.set(i, o ? o + 1 : 1),
                  typeof o == "number" &&
                    o > this.g.errors &&
                    this.c.info(
                      `onWillSaveTextDocument-listener from extension '${e.identifier.value}' will now be IGNORED because of timeouts and/or errors`,
                    )
              }
              return !1
            },
          )
    }
    i(i, t, e, r) {
      const s = [],
        a = Date.now(),
        { document: o, reason: c } = r,
        { version: u } = o,
        l = Object.freeze({
          document: o,
          reason: c,
          waitUntil(m) {
            if (Object.isFrozen(s))
              throw iB("waitUntil can not be called async")
            s.push(Promise.resolve(m))
          },
        })
      try {
        t.apply(e, [l])
      } catch (m) {
        return Promise.reject(m)
      }
      return (
        Object.freeze(s),
        new Promise((m, h) => {
          const p = setTimeout(() => h(new Error("timeout")), this.g.timeout)
          return Promise.all(s)
            .then((g) => {
              this.c.debug(
                `onWillSaveTextDocument-listener from extension '${i.identifier.value}' finished after ${Date.now() - a}ms`,
              ),
                clearTimeout(p),
                m(g)
            })
            .catch((g) => {
              clearTimeout(p), h(g)
            })
        }).then((m) => {
          const h = { edits: [] }
          for (const p of m)
            if (Array.isArray(p) && p.every((g) => g instanceof fs))
              for (const { newText: g, newEol: w, range: T } of p)
                h.edits.push({
                  resource: o.uri,
                  versionId: void 0,
                  textEdit: {
                    range: T && O.from(T),
                    text: g,
                    eol: w && oc.from(w),
                  },
                })
          if (h.edits.length !== 0)
            return u === o.version
              ? this.f.$tryApplyWorkspaceEdit(new Xi(h))
              : Promise.reject(new Error("concurrent_edits"))
        })
      )
    }
  },
  aAt = class {
    constructor(i, t) {
      ;(this.a = new C()),
        (this.b = new C()),
        (this.c = new C()),
        (this.d = new C()),
        (this.onDidAddDocument = this.a.event),
        (this.onDidRemoveDocument = this.b.event),
        (this.onDidChangeDocument = this.c.event),
        (this.onDidSaveDocument = this.d.event),
        (this.e = new bt()),
        (this.h = new Map()),
        (this.f = i.getProxy(z.MainThreadDocuments)),
        (this.g = t),
        this.g.onDidRemoveDocuments(
          (e) => {
            for (const r of e) this.b.fire(r.document)
          },
          void 0,
          this.e,
        ),
        this.g.onDidAddDocuments(
          (e) => {
            for (const r of e) this.a.fire(r.document)
          },
          void 0,
          this.e,
        )
    }
    dispose() {
      this.e.dispose()
    }
    getAllDocumentData() {
      return [...this.g.allDocuments()]
    }
    getDocumentData(i) {
      if (!i) return
      const t = this.g.getDocument(i)
      if (t) return t
    }
    getDocument(i) {
      const t = this.getDocumentData(i)
      if (!t?.document)
        throw new Error(`Unable to retrieve document from URI '${i}'`)
      return t.document
    }
    ensureDocumentData(i) {
      const t = this.g.getDocument(i)
      if (t) return Promise.resolve(t)
      let e = this.h.get(i.toString())
      return (
        e ||
          ((e = this.f.$tryOpenDocument(i).then(
            (r) => {
              this.h.delete(i.toString())
              const s = S.revive(r)
              return fo(this.g.getDocument(s))
            },
            (r) => (this.h.delete(i.toString()), Promise.reject(r)),
          )),
          this.h.set(i.toString(), e)),
        e
      )
    }
    createDocumentData(i) {
      return this.f.$tryCreateDocument(i).then((t) => S.revive(t))
    }
    $acceptModelLanguageChanged(i, t) {
      const e = S.revive(i),
        r = this.g.getDocument(e)
      if (!r) throw new Error("unknown document")
      this.b.fire(r.document), r._acceptLanguageId(t), this.a.fire(r.document)
    }
    $acceptModelSaved(i) {
      const t = S.revive(i),
        e = this.g.getDocument(t)
      if (!e) throw new Error("unknown document")
      this.$acceptDirtyStateChanged(i, !1), this.d.fire(e.document)
    }
    $acceptDirtyStateChanged(i, t) {
      const e = S.revive(i),
        r = this.g.getDocument(e)
      if (!r) throw new Error("unknown document")
      r._acceptIsDirty(t),
        this.c.fire({
          document: r.document,
          contentChanges: [],
          reason: void 0,
        })
    }
    $acceptModelChanged(i, t, e) {
      const r = S.revive(i),
        s = this.g.getDocument(r)
      if (!s) throw new Error("unknown document")
      s._acceptIsDirty(e), s.onEvents(t)
      let a
      t.isUndoing ? (a = kl.Undo) : t.isRedoing && (a = kl.Redo),
        this.c.fire(
          Hj({
            document: s.document,
            contentChanges: t.changes.map((o) => ({
              range: O.to(o.range),
              rangeOffset: o.rangeOffset,
              rangeLength: o.rangeLength,
              text: o.text,
            })),
            reason: a,
          }),
        )
    }
    setWordDefinitionFor(i, t) {
      D1t(i, t)
    }
  },
  oAt = class {
    constructor(i) {
      ;(this.b = new Map()),
        (this.c = new C()),
        (this.onDidChange = this.c.event),
        (this.d = new Set()),
        (this.e = 0),
        (this.a = i.getProxy(z.MainThreadEmbeddings))
    }
    registerEmbeddingsProvider(i, t, e) {
      if (this.d.has(t))
        throw new Error(
          "An embeddings provider for this model is already registered",
        )
      const r = this.e++
      return (
        this.a.$registerEmbeddingProvider(r, t),
        this.b.set(r, { id: t, provider: e }),
        it(() => {
          this.d.delete(t),
            this.a.$unregisterEmbeddingProvider(r),
            this.b.delete(r)
        })
      )
    }
    async computeEmbeddings(i, t, e) {
      e ??= fe.None
      let r = !1
      typeof t == "string" && ((t = [t]), (r = !0))
      const s = await this.a.$computeEmbeddings(i, t, e)
      if (s.length !== t.length) throw new Error()
      if (r) {
        if (s.length !== 1) throw new Error()
        return s[0]
      }
      return s
    }
    async $provideEmbeddings(i, t, e) {
      const r = this.b.get(i)
      if (!r) return []
      const s = await r.provider.provideEmbeddings(t, e)
      return s || []
    }
    get embeddingsModels() {
      return Array.from(this.d)
    }
    $acceptEmbeddingModels(i) {
      ;(this.d = new Set(i)), this.c.fire()
    }
  },
  cAt = class {
    constructor(i) {
      ;(this.a = new Map()),
        (this.b = 0),
        (this.c = i.getProxy(z.MainThreadAiEmbeddingVector))
    }
    async $provideAiEmbeddingVector(i, t, e) {
      if (this.a.size === 0)
        throw new Error("No embedding vector providers registered")
      const r = this.a.get(i)
      if (!r) throw new Error("Embedding vector provider not found")
      const s = await r.provideEmbeddingVector(t, e)
      if (!s) throw new Error("Embedding vector provider returned undefined")
      return s
    }
    registerEmbeddingVectorProvider(i, t, e) {
      const r = this.b
      return (
        this.b++,
        this.a.set(r, e),
        this.c.$registerAiEmbeddingVectorProvider(t, r),
        new At(() => {
          this.c.$unregisterAiEmbeddingVectorProvider(r), this.a.delete(r)
        })
      )
    }
  },
  irt
;(function (i) {
  ;(i[(i.Invalid = 0)] = "Invalid"),
    (i[(i.Start = 1)] = "Start"),
    (i[(i.H = 2)] = "H"),
    (i[(i.HT = 3)] = "HT"),
    (i[(i.HTT = 4)] = "HTT"),
    (i[(i.HTTP = 5)] = "HTTP"),
    (i[(i.F = 6)] = "F"),
    (i[(i.FI = 7)] = "FI"),
    (i[(i.FIL = 8)] = "FIL"),
    (i[(i.BeforeColon = 9)] = "BeforeColon"),
    (i[(i.AfterColon = 10)] = "AfterColon"),
    (i[(i.AlmostThere = 11)] = "AlmostThere"),
    (i[(i.End = 12)] = "End"),
    (i[(i.Accept = 13)] = "Accept"),
    (i[(i.LastKnownState = 14)] = "LastKnownState")
})(irt || (irt = {}))
var uAt = class {
    constructor(i, t, e) {
      const r = new Uint8Array(i * t)
      for (let s = 0, a = i * t; s < a; s++) r[s] = e
      ;(this.a = r), (this.rows = i), (this.cols = t)
    }
    get(i, t) {
      return this.a[i * this.cols + t]
    }
    set(i, t, e) {
      this.a[i * this.cols + t] = e
    }
  },
  rrt = class {
    constructor(i) {
      let t = 0,
        e = 0
      for (let s = 0, a = i.length; s < a; s++) {
        const [o, c, u] = i[s]
        c > t && (t = c), o > e && (e = o), u > e && (e = u)
      }
      t++, e++
      const r = new uAt(e, t, 0)
      for (let s = 0, a = i.length; s < a; s++) {
        const [o, c, u] = i[s]
        r.set(o, c, u)
      }
      ;(this.a = r), (this.b = t)
    }
    nextState(i, t) {
      return t < 0 || t >= this.b ? 0 : this.a.get(i, t)
    }
  },
  SM = null
function lAt() {
  return (
    SM === null &&
      (SM = new rrt([
        [1, 104, 2],
        [1, 72, 2],
        [1, 102, 6],
        [1, 70, 6],
        [2, 116, 3],
        [2, 84, 3],
        [3, 116, 4],
        [3, 84, 4],
        [4, 112, 5],
        [4, 80, 5],
        [5, 115, 9],
        [5, 83, 9],
        [5, 58, 10],
        [6, 105, 7],
        [6, 73, 7],
        [7, 108, 8],
        [7, 76, 8],
        [8, 101, 9],
        [8, 69, 9],
        [9, 58, 10],
        [10, 47, 11],
        [11, 47, 12],
      ])),
    SM
  )
}
var nrt
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.ForceTermination = 1)] = "ForceTermination"),
    (i[(i.CannotEndIn = 2)] = "CannotEndIn")
})(nrt || (nrt = {}))
var gh = null
function dAt() {
  if (gh === null) {
    gh = new FX(0)
    const i = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u3008\u300C\u300E\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u300F\u300D\u3009\u2019\uFF40\uFF5E\u2026`
    for (let e = 0; e < i.length; e++) gh.set(i.charCodeAt(e), 1)
    const t = ".,;:"
    for (let e = 0; e < t.length; e++) gh.set(t.charCodeAt(e), 2)
  }
  return gh
}
var mAt = class bH {
    static a(t, e, r, s, a) {
      let o = a - 1
      do {
        const c = e.charCodeAt(o)
        if (t.get(c) !== 2) break
        o--
      } while (o > s)
      if (s > 0) {
        const c = e.charCodeAt(s - 1),
          u = e.charCodeAt(o)
        ;((c === 40 && u === 41) ||
          (c === 91 && u === 93) ||
          (c === 123 && u === 125)) &&
          o--
      }
      return {
        range: {
          startLineNumber: r,
          startColumn: s + 1,
          endLineNumber: r,
          endColumn: o + 2,
        },
        url: e.substring(s, o + 1),
      }
    }
    static computeLinks(t, e = lAt()) {
      const r = dAt(),
        s = []
      for (let a = 1, o = t.getLineCount(); a <= o; a++) {
        const c = t.getLineContent(a),
          u = c.length
        let l = 0,
          m = 0,
          h = 0,
          p = 1,
          g = !1,
          w = !1,
          T = !1,
          b = !1
        for (; l < u; ) {
          let N = !1
          const $ = c.charCodeAt(l)
          if (p === 13) {
            let L
            switch ($) {
              case 40:
                ;(g = !0), (L = 0)
                break
              case 41:
                L = g ? 0 : 1
                break
              case 91:
                ;(T = !0), (w = !0), (L = 0)
                break
              case 93:
                ;(T = !1), (L = w ? 0 : 1)
                break
              case 123:
                ;(b = !0), (L = 0)
                break
              case 125:
                L = b ? 0 : 1
                break
              case 39:
              case 34:
              case 96:
                h === $
                  ? (L = 1)
                  : h === 39 || h === 34 || h === 96
                    ? (L = 0)
                    : (L = 1)
                break
              case 42:
                L = h === 42 ? 1 : 0
                break
              case 124:
                L = h === 124 ? 1 : 0
                break
              case 32:
                L = T ? 0 : 1
                break
              default:
                L = r.get($)
            }
            L === 1 && (s.push(bH.a(r, c, a, m, l)), (N = !0))
          } else if (p === 12) {
            let L
            $ === 91 ? ((w = !0), (L = 0)) : (L = r.get($)),
              L === 1 ? (N = !0) : (p = 13)
          } else (p = e.nextState(p, $)), p === 0 && (N = !0)
          N && ((p = 1), (g = !1), (w = !1), (b = !1), (m = l + 1), (h = $)),
            l++
        }
        p === 13 && s.push(bH.a(r, c, a, m, u))
      }
      return s
    }
  },
  hAt = class {
    constructor() {
      this.a = []
    }
    add(i) {
      ;(this.b = void 0), this.a.push(i)
    }
    delete(i) {
      const t = this.a.indexOf(i)
      t >= 0 && (this.a.splice(t, 1), (this.b = void 0))
    }
    c() {
      if (!this.b) {
        const i = this.a.sort(),
          t = []
        let e,
          r,
          s = 14,
          a = 14
        for (const o of i) {
          let c = e ? Pot(e, o) : 0
          for (c === 0 ? (r = 1) : (r = a); c < o.length; c++)
            c + 1 === o.length ? ((s = a), (a = 9)) : (a += 1),
              t.push([r, o.toUpperCase().charCodeAt(c), a]),
              t.push([r, o.toLowerCase().charCodeAt(c), a]),
              (r = a)
          ;(e = o), (a = s)
        }
        t.push([9, 58, 10]), t.push([10, 47, 12]), (this.b = new rrt(t))
      }
    }
    provideDocumentLinks(i) {
      this.c()
      const t = [],
        e = mAt.computeLinks(
          {
            getLineContent(r) {
              return i.lineAt(r - 1).text
            },
            getLineCount() {
              return i.lineCount
            },
          },
          this.b,
        )
      for (const r of e) {
        const s = La.to(r)
        s.target && t.push(s)
      }
      return t
    }
  },
  fAt = class EH {
    constructor(t, e) {
      ;(this.i = e),
        (this.b = new hAt()),
        (this.c = new Map()),
        (this.d = new Set()),
        (this.f = new Map()),
        (this.h = 0),
        (this.a = t.getProxy(z.MainThreadFileSystem))
    }
    dispose() {
      this.g?.dispose()
    }
    registerFileSystemProvider(t, e, r, s = {}) {
      if ((EH.j(r), this.d.has(e)))
        throw new Error(
          `a provider for the scheme '${e}' is already registered`,
        )
      this.g || (this.g = this.i.registerDocumentLinkProvider(t, "*", this.b))
      const a = this.h++
      this.b.add(e), this.d.add(e), this.c.set(a, r)
      let o = 2
      s.isCaseSensitive && (o += 1024),
        s.isReadonly && (o += 2048),
        typeof r.copy == "function" && (o += 8),
        typeof r.open == "function" &&
          typeof r.close == "function" &&
          typeof r.read == "function" &&
          typeof r.write == "function" &&
          (F(t, "fsChunks"), (o += 4))
      let c
      s.isReadonly &&
        na(s.isReadonly) &&
        s.isReadonly.value !== "" &&
        (c = {
          value: s.isReadonly.value,
          isTrusted: s.isReadonly.isTrusted,
          supportThemeIcons: s.isReadonly.supportThemeIcons,
          supportHtml: s.isReadonly.supportHtml,
          baseUri: s.isReadonly.baseUri,
          uris: s.isReadonly.uris,
        }),
        this.a.$registerFileSystemProvider(a, e, o, c).catch((l) => {
          console.error(
            `FAILED to register filesystem provider of ${t.identifier.value}-extension for the scheme ${e}`,
          ),
            console.error(l)
        })
      const u = r.onDidChangeFile((l) => {
        const m = []
        for (const h of l) {
          const { uri: p, type: g } = h
          if (p.scheme !== e) continue
          let w
          switch (g) {
            case zo.Changed:
              w = 0
              break
            case zo.Created:
              w = 1
              break
            case zo.Deleted:
              w = 2
              break
            default:
              throw new Error("Unknown FileChangeType")
          }
          m.push({ resource: p, type: w })
        }
        this.a.$onFileSystemChange(a, m)
      })
      return it(() => {
        u.dispose(),
          this.b.delete(e),
          this.d.delete(e),
          this.c.delete(a),
          this.a.$unregisterProvider(a)
      })
    }
    static j(t) {
      if (!t) throw new Error("MISSING provider")
      if (typeof t.watch != "function")
        throw new Error("Provider does NOT implement watch")
      if (typeof t.stat != "function")
        throw new Error("Provider does NOT implement stat")
      if (typeof t.readDirectory != "function")
        throw new Error("Provider does NOT implement readDirectory")
      if (typeof t.createDirectory != "function")
        throw new Error("Provider does NOT implement createDirectory")
      if (typeof t.readFile != "function")
        throw new Error("Provider does NOT implement readFile")
      if (typeof t.writeFile != "function")
        throw new Error("Provider does NOT implement writeFile")
      if (typeof t.delete != "function")
        throw new Error("Provider does NOT implement delete")
      if (typeof t.rename != "function")
        throw new Error("Provider does NOT implement rename")
    }
    static k(t) {
      const { type: e, ctime: r, mtime: s, size: a, permissions: o } = t
      return { type: e, ctime: r, mtime: s, size: a, permissions: o }
    }
    $stat(t, e) {
      return Promise.resolve(this.l(t).stat(S.revive(e))).then((r) => EH.k(r))
    }
    $readdir(t, e) {
      return Promise.resolve(this.l(t).readDirectory(S.revive(e)))
    }
    $readFile(t, e) {
      return Promise.resolve(this.l(t).readFile(S.revive(e))).then((r) =>
        Et.wrap(r),
      )
    }
    $writeFile(t, e, r, s) {
      return Promise.resolve(this.l(t).writeFile(S.revive(e), r.buffer, s))
    }
    $delete(t, e, r) {
      return Promise.resolve(this.l(t).delete(S.revive(e), r))
    }
    $rename(t, e, r, s) {
      return Promise.resolve(this.l(t).rename(S.revive(e), S.revive(r), s))
    }
    $copy(t, e, r, s) {
      const a = this.l(t)
      if (!a.copy)
        throw new Error('FileSystemProvider does not implement "copy"')
      return Promise.resolve(a.copy(S.revive(e), S.revive(r), s))
    }
    $mkdir(t, e) {
      return Promise.resolve(this.l(t).createDirectory(S.revive(e)))
    }
    $watch(t, e, r, s) {
      const a = this.l(t).watch(S.revive(r), s)
      this.f.set(e, a)
    }
    $unwatch(t, e) {
      const r = this.f.get(e)
      r && (r.dispose(), this.f.delete(e))
    }
    $open(t, e, r) {
      const s = this.l(t)
      if (!s.open)
        throw new Error('FileSystemProvider does not implement "open"')
      return Promise.resolve(s.open(S.revive(e), r))
    }
    $close(t, e) {
      const r = this.l(t)
      if (!r.close)
        throw new Error('FileSystemProvider does not implement "close"')
      return Promise.resolve(r.close(e))
    }
    $read(t, e, r, s) {
      const a = this.l(t)
      if (!a.read)
        throw new Error('FileSystemProvider does not implement "read"')
      const o = Et.alloc(s)
      return Promise.resolve(a.read(e, r, o.buffer, 0, s)).then((c) =>
        o.slice(0, c),
      )
    }
    $write(t, e, r, s) {
      const a = this.l(t)
      if (!a.write)
        throw new Error('FileSystemProvider does not implement "write"')
      return Promise.resolve(a.write(e, r, s.buffer, 0, s.byteLength))
    }
    l(t) {
      const e = this.c.get(t)
      if (!e) {
        const r = new Error()
        throw ((r.name = "ENOPRO"), (r.message = "no provider"), r)
      }
      return e
    }
  },
  TMt = class ost extends dt {
    static {
      this.a = 5
    }
    constructor(t, e, r, s) {
      super(),
        (this.h = t),
        (this.j = e),
        (this.m = r),
        (this.n = s),
        (this.c = this.D(new Zn())),
        (this.f = void 0),
        (this.g = 0)
    }
    r() {
      const t = new bt()
      ;(this.c.value = t),
        (this.b = this.q(t)),
        this.b.setVerboseLogging(this.m),
        t.add(this.b.onDidChangeFile((e) => this.h(e))),
        t.add(this.b.onDidLogMessage((e) => this.j(e))),
        t.add(this.b.onDidError((e) => this.s(e.error, e.request)))
    }
    s(t, e) {
      this.t(t, e)
        ? this.g < ost.a && this.f
          ? (this.w(`restarting watcher after unexpected error: ${t}`),
            this.u(this.f))
          : this.w(
              `gave up attempting to restart watcher after unexpected error: ${t}`,
            )
        : this.w(t)
    }
    t(t, e) {
      return !(
        !this.n.restartOnError ||
        e ||
        t.indexOf("No space left on device") !== -1 ||
        t.indexOf("EMFILE") !== -1
      )
    }
    u(t) {
      this.g++, this.r(), this.watch(t)
    }
    async watch(t) {
      ;(this.f = t), await this.b?.watch(t)
    }
    async setVerboseLogging(t) {
      ;(this.m = t), await this.b?.setVerboseLogging(t)
    }
    w(t) {
      this.j({ type: "error", message: `[File Watcher (${this.n.type})] ${t}` })
    }
    y(t) {
      this.j({ type: "trace", message: `[File Watcher (${this.n.type})] ${t}` })
    }
    dispose() {
      return (this.b = void 0), super.dispose()
    }
  }
function pAt(i, t) {
  return typeof t == "string" && !t.startsWith(ha) && !t_(t)
    ? { base: i, pattern: t }
    : t
}
var gAt = class {
    get ignoreCreateEvents() {
      return !!(this.h & 1)
    }
    get ignoreChangeEvents() {
      return !!(this.h & 2)
    }
    get ignoreDeleteEvents() {
      return !!(this.h & 4)
    }
    constructor(i, t, e, r, s, a, o) {
      ;(this.a = Math.random()),
        (this.b = new C()),
        (this.c = new C()),
        (this.d = new C()),
        (this.h = 0),
        o.ignoreCreateEvents && (this.h += 1),
        o.ignoreChangeEvents && (this.h += 2),
        o.ignoreDeleteEvents && (this.h += 4)
      const c = Jo(a),
        u = typeof a == "string",
        l = o.correlate,
        m = s((h) => {
          if (
            !(typeof h.session == "number" && h.session !== this.a) &&
            !(l && typeof h.session > "u")
          ) {
            if (!o.ignoreCreateEvents)
              for (const p of h.created) {
                const g = S.revive(p)
                c(g.fsPath) && (!u || e.getWorkspaceFolder(g)) && this.b.fire(g)
              }
            if (!o.ignoreChangeEvents)
              for (const p of h.changed) {
                const g = S.revive(p)
                c(g.fsPath) && (!u || e.getWorkspaceFolder(g)) && this.c.fire(g)
              }
            if (!o.ignoreDeleteEvents)
              for (const p of h.deleted) {
                const g = S.revive(p)
                c(g.fsPath) && (!u || e.getWorkspaceFolder(g)) && this.d.fire(g)
              }
          }
        })
      this.g = At.from(
        this.i(i, e, t, r, a, o, o.correlate),
        this.b,
        this.c,
        this.d,
        m,
      )
    }
    i(i, t, e, r, s, a, o) {
      const c = At.from()
      if (
        typeof s == "string" ||
        (a.ignoreChangeEvents && a.ignoreCreateEvents && a.ignoreDeleteEvents)
      )
        return c
      const u = i.getProxy(z.MainThreadFileSystemEventService)
      let l = !1
      ;(s.pattern.includes(ha) || s.pattern.includes(J3)) && (l = !0)
      const m = a.excludes ?? []
      let h, p
      if (o)
        (a.ignoreChangeEvents ||
          a.ignoreCreateEvents ||
          a.ignoreDeleteEvents) &&
          ((p = 14),
          a.ignoreChangeEvents && (p &= -3),
          a.ignoreCreateEvents && (p &= -5),
          a.ignoreDeleteEvents && (p &= -9))
      else if (l && m.length === 0) {
        const g = t.getWorkspaceFolder(S.revive(s.baseUri)),
          w = e.getConfiguration("files", g).get("watcherExclude")
        if (w) for (const T in w) T && w[T] === !0 && m.push(T)
      } else if (!l) {
        const g = t.getWorkspaceFolder(S.revive(s.baseUri))
        if (g) {
          const w = e.getConfiguration("files", g).get("watcherExclude")
          if (w) {
            for (const T in w)
              if (T && w[T] === !0) {
                const b = `${IB(T, "/")}/${ha}`
                h || (h = []), h.push(pAt(g.uri.fsPath, b))
              }
          }
          if (!h || h.length === 0) return c
        }
      }
      return (
        u.$watch(
          r.identifier.value,
          this.a,
          s.baseUri,
          { recursive: l, excludes: m, includes: h, filter: p },
          !!o,
        ),
        At.from({ dispose: () => u.$unwatch(this.a) })
      )
    }
    dispose() {
      this.g.dispose()
    }
    get onDidCreate() {
      return this.b.event
    }
    get onDidChange() {
      return this.c.event
    }
    get onDidDelete() {
      return this.d.event
    }
  },
  vAt = class {
    constructor(i) {
      ;(this.a = i),
        (this.session = this.a.session),
        (this.b = new qi(() => this.a.created.map(S.revive))),
        (this.c = new qi(() => this.a.changed.map(S.revive))),
        (this.d = new qi(() => this.a.deleted.map(S.revive)))
    }
    get created() {
      return this.b.value
    }
    get changed() {
      return this.c.value
    }
    get deleted() {
      return this.d.value
    }
  },
  wAt = class {
    constructor(i, t, e) {
      ;(this.j = i),
        (this.k = t),
        (this.l = e),
        (this.a = new C()),
        (this.b = new C()),
        (this.c = new C()),
        (this.d = new C()),
        (this.g = new Iu()),
        (this.h = new Iu()),
        (this.i = new Iu()),
        (this.onDidRenameFile = this.b.event),
        (this.onDidCreateFile = this.c.event),
        (this.onDidDeleteFile = this.d.event)
    }
    createFileSystemWatcher(i, t, e, r, s) {
      return new gAt(this.j, t, i, e, this.a.event, zi.from(r), s)
    }
    $onFileEvent(i) {
      this.a.fire(new vAt(i))
    }
    $onDidRunFileOperation(i, t) {
      switch (i) {
        case 2:
          this.b.fire(
            Object.freeze({
              files: t.map((e) => ({
                oldUri: S.revive(e.source),
                newUri: S.revive(e.target),
              })),
            }),
          )
          break
        case 1:
          this.d.fire(
            Object.freeze({ files: t.map((e) => S.revive(e.target)) }),
          )
          break
        case 0:
        case 3:
          this.c.fire(
            Object.freeze({ files: t.map((e) => S.revive(e.target)) }),
          )
          break
        default:
      }
    }
    getOnWillRenameFileEvent(i) {
      return this.m(i, this.g)
    }
    getOnWillCreateFileEvent(i) {
      return this.m(i, this.h)
    }
    getOnWillDeleteFileEvent(i) {
      return this.m(i, this.i)
    }
    m(i, t) {
      return (e, r, s) => {
        const a = function (c) {
          e.call(r, c)
        }
        return (a.extension = i), t.event(a, void 0, s)
      }
    }
    async $onWillRunFileOperation(i, t, e, r) {
      switch (i) {
        case 2:
          return await this.n(
            this.g,
            {
              files: t.map((s) => ({
                oldUri: S.revive(s.source),
                newUri: S.revive(s.target),
              })),
            },
            e,
            r,
          )
        case 1:
          return await this.n(
            this.i,
            { files: t.map((s) => S.revive(s.target)) },
            e,
            r,
          )
        case 0:
        case 3:
          return await this.n(
            this.h,
            { files: t.map((s) => S.revive(s.target)) },
            e,
            r,
          )
      }
    }
    async n(i, t, e, r) {
      const s = new Set(),
        a = []
      if (
        (await i.fireAsync(t, r, async (c, u) => {
          const l = Date.now(),
            m = await Promise.resolve(c)
          m instanceof va &&
            (a.push([u.extension, m]),
            s.add(u.extension.displayName ?? u.extension.identifier.value)),
            Date.now() - l > e &&
              this.k.warn("SLOW file-participant", u.extension.identifier)
        }),
        r.isCancellationRequested || a.length === 0)
      )
        return
      const o = { edits: [] }
      for (const [, c] of a) {
        const { edits: u } = bi.from(c, {
          getTextDocumentVersion: (l) => this.l.getDocument(l)?.version,
          getNotebookDocumentVersion: () => {},
        })
        o.edits = o.edits.concat(u)
      }
      return { edit: o, extensionNames: Array.from(s) }
    }
  },
  yAt = class {
    constructor(i, t, e, r, s) {
      ;(this.a = t), (this.b = e), (this.c = r)
      const a = new pt(
        "interactive.open",
        "_interactive.open",
        "Open interactive window and return notebook editor and input URI",
        [
          new M(
            "showOptions",
            "Show Options",
            (o) => !0,
            (o) => o,
          ),
          new M(
            "resource",
            "Interactive resource Uri",
            (o) => !0,
            (o) => o,
          ),
          new M(
            "controllerId",
            "Notebook controller Id",
            (o) => !0,
            (o) => o,
          ),
          new M(
            "title",
            "Interactive editor title",
            (o) => !0,
            (o) => o,
          ),
        ],
        new ht("Notebook and input URI", (o) => {
          if (
            (s.debug(
              "[ExtHostInteractive] open iw with notebook editor id",
              o.notebookEditorId,
            ),
            o.notebookEditorId !== void 0)
          ) {
            const c = this.a.getEditorById(o.notebookEditorId)
            return (
              s.debug("[ExtHostInteractive] notebook editor found", c.id),
              {
                notebookUri: S.revive(o.notebookUri),
                inputUri: S.revive(o.inputUri),
                notebookEditor: c.apiEditor,
              }
            )
          }
          return (
            s.debug(
              "[ExtHostInteractive] notebook editor not found, uris for the interactive document",
              o.notebookUri,
              o.inputUri,
            ),
            {
              notebookUri: S.revive(o.notebookUri),
              inputUri: S.revive(o.inputUri),
            }
          )
        }),
      )
      this.c.registerApiCommand(a)
    }
    $willAddInteractiveDocument(i, t, e, r) {
      this.b.acceptDocumentsAndEditorsDelta({
        addedDocuments: [
          {
            EOL: t,
            lines: [""],
            languageId: e,
            uri: i,
            isDirty: !1,
            versionId: 1,
          },
        ],
      })
    }
    $willRemoveInteractiveDocument(i, t) {
      this.b.acceptDocumentsAndEditorsDelta({ removedDocuments: [i] })
    }
  },
  TAt = class {
    constructor(i) {
      ;(this.b = 0), (this.a = i.getProxy(z.MainThreadLabelService))
    }
    $registerResourceLabelFormatter(i) {
      const t = this.b++
      return (
        this.a.$registerResourceLabelFormatter(t, i),
        it(() => {
          this.a.$unregisterResourceLabelFormatter(t)
        })
      )
    }
  },
  srt
;(function (i) {
  ;(i[(i.LTR = 0)] = "LTR"), (i[(i.RTL = 1)] = "RTL")
})(srt || (srt = {}))
var kAt = class wr extends re {
    constructor(t, e, r, s) {
      super(t, e, r, s),
        (this.selectionStartLineNumber = t),
        (this.selectionStartColumn = e),
        (this.positionLineNumber = r),
        (this.positionColumn = s)
    }
    toString() {
      return (
        "[" +
        this.selectionStartLineNumber +
        "," +
        this.selectionStartColumn +
        " -> " +
        this.positionLineNumber +
        "," +
        this.positionColumn +
        "]"
      )
    }
    equalsSelection(t) {
      return wr.selectionsEqual(this, t)
    }
    static selectionsEqual(t, e) {
      return (
        t.selectionStartLineNumber === e.selectionStartLineNumber &&
        t.selectionStartColumn === e.selectionStartColumn &&
        t.positionLineNumber === e.positionLineNumber &&
        t.positionColumn === e.positionColumn
      )
    }
    getDirection() {
      return this.selectionStartLineNumber === this.startLineNumber &&
        this.selectionStartColumn === this.startColumn
        ? 0
        : 1
    }
    setEndPosition(t, e) {
      return this.getDirection() === 0
        ? new wr(this.startLineNumber, this.startColumn, t, e)
        : new wr(t, e, this.startLineNumber, this.startColumn)
    }
    getPosition() {
      return new tr(this.positionLineNumber, this.positionColumn)
    }
    getSelectionStart() {
      return new tr(this.selectionStartLineNumber, this.selectionStartColumn)
    }
    setStartPosition(t, e) {
      return this.getDirection() === 0
        ? new wr(t, e, this.endLineNumber, this.endColumn)
        : new wr(this.endLineNumber, this.endColumn, t, e)
    }
    static fromPositions(t, e = t) {
      return new wr(t.lineNumber, t.column, e.lineNumber, e.column)
    }
    static fromRange(t, e) {
      return e === 0
        ? new wr(t.startLineNumber, t.startColumn, t.endLineNumber, t.endColumn)
        : new wr(t.endLineNumber, t.endColumn, t.startLineNumber, t.startColumn)
    }
    static liftSelection(t) {
      return new wr(
        t.selectionStartLineNumber,
        t.selectionStartColumn,
        t.positionLineNumber,
        t.positionColumn,
      )
    }
    static selectionsArrEqual(t, e) {
      if ((t && !e) || (!t && e)) return !1
      if (!t && !e) return !0
      if (t.length !== e.length) return !1
      for (let r = 0, s = t.length; r < s; r++)
        if (!this.selectionsEqual(t[r], e[r])) return !1
      return !0
    }
    static isISelection(t) {
      return (
        t &&
        typeof t.selectionStartLineNumber == "number" &&
        typeof t.selectionStartColumn == "number" &&
        typeof t.positionLineNumber == "number" &&
        typeof t.positionColumn == "number"
      )
    }
    static createWithDirection(t, e, r, s, a) {
      return a === 0 ? new wr(t, e, r, s) : new wr(r, s, t, e)
    }
  },
  art = class cst {
    constructor(t, e) {
      ;(this.d = t), (this.e = e)
    }
    async provideDocumentSymbols(t, e) {
      const r = this.d.getDocument(t),
        s = await this.e.provideDocumentSymbols(r, e)
      if (!nB(s)) return s[0] instanceof gl ? s.map(YO.from) : cst.f(s)
    }
    static f(t) {
      t = t.slice(0).sort((s, a) => {
        let o = s.location.range.start.compareTo(a.location.range.start)
        return (
          o === 0 && (o = a.location.range.end.compareTo(s.location.range.end)),
          o
        )
      })
      const e = [],
        r = []
      for (const s of t) {
        const a = {
          name: s.name || "!!MISSING: name!!",
          kind: mr.from(s.kind),
          tags: s.tags?.map(Cn.from) || [],
          detail: "",
          containerName: s.containerName,
          range: O.from(s.location.range),
          selectionRange: O.from(s.location.range),
          children: [],
        }
        for (;;) {
          if (r.length === 0) {
            r.push(a), e.push(a)
            break
          }
          const o = r[r.length - 1]
          if (
            re.containsRange(o.range, a.range) &&
            !re.equalsRange(o.range, a.range)
          ) {
            o.children?.push(a), r.push(a)
            break
          }
          r.pop()
        }
      }
      return e
    }
  },
  v8 = class {
    constructor(i, t, e, r, s, a) {
      ;(this.f = i),
        (this.g = t),
        (this.h = e),
        (this.j = r),
        (this.k = s),
        (this.l = a),
        (this.d = new Hr("CodeLens")),
        (this.e = new Map())
    }
    async provideCodeLenses(i, t) {
      const e = this.f.getDocument(i),
        r = await this.h.provideCodeLenses(e, t)
      if (!r || t.isCancellationRequested) return
      const s = this.d.add(r),
        a = new bt()
      this.e.set(s, a)
      const o = { cacheId: s, lenses: [] }
      for (let c = 0; c < r.length; c++)
        o.lenses.push({
          cacheId: [s, c],
          range: O.from(r[c].range),
          command: this.g.toInternal(r[c].command, a),
        })
      return o
    }
    async resolveCodeLens(i, t) {
      const e = i.cacheId && this.d.get(...i.cacheId)
      if (!e) return
      let r
      if (
        (typeof this.h.resolveCodeLens != "function" || e.isResolved
          ? (r = e)
          : (r = await this.h.resolveCodeLens(e, t)),
        r || (r = e),
        t.isCancellationRequested)
      )
        return
      const s = i.cacheId && this.e.get(i.cacheId[0])
      if (s) {
        if (!r.command) {
          const a = new Error(
            "INVALID code lens resolved, lacks command: " +
              this.j.identifier.value,
          )
          this.k.onExtensionError(this.j.identifier, a), this.l.error(a)
          return
        }
        return (i.command = this.g.toInternal(r.command, s)), i
      }
    }
    releaseCodeLenses(i) {
      this.e.get(i)?.dispose(), this.e.delete(i), this.d.delete(i)
    }
  }
function w8(i) {
  return Array.isArray(i) ? i.map(Vl.from) : i ? [Vl.from(i)] : []
}
var ort = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideDefinition(i, t, e) {
      const r = this.d.getDocument(i),
        s = Gt.to(t),
        a = await this.e.provideDefinition(r, s, e)
      return w8(a)
    }
  },
  crt = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideDeclaration(i, t, e) {
      const r = this.d.getDocument(i),
        s = Gt.to(t),
        a = await this.e.provideDeclaration(r, s, e)
      return w8(a)
    }
  },
  urt = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideImplementation(i, t, e) {
      const r = this.d.getDocument(i),
        s = Gt.to(t),
        a = await this.e.provideImplementation(r, s, e)
      return w8(a)
    }
  },
  lrt = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideTypeDefinition(i, t, e) {
      const r = this.d.getDocument(i),
        s = Gt.to(t),
        a = await this.e.provideTypeDefinition(r, s, e)
      return w8(a)
    }
  },
  bM = class ust {
    static {
      this.f = 10
    }
    constructor(t, e) {
      ;(this.g = t), (this.h = e), (this.d = 0), (this.e = new Map())
    }
    async provideHover(t, e, r, s) {
      const a = this.g.getDocument(t),
        o = Gt.to(e)
      let c
      if (r && r.verbosityRequest) {
        const h = r.verbosityRequest.previousHover.id,
          p = this.e.get(h)
        if (!p) throw new Error(`Hover with id ${h} not found`)
        const g = {
          verbosityDelta: r.verbosityRequest.verbosityDelta,
          previousHover: p,
        }
        c = await this.h.provideHover(a, o, s, g)
      } else c = await this.h.provideHover(a, o, s)
      if (!c || nB(c.contents)) return
      c.range || (c.range = a.getWordRangeAtPosition(o)),
        c.range || (c.range = new Nt(o, o))
      const u = Gl.from(c),
        l = this.d
      if (this.e.size === ust.f) {
        const h = Math.min(...this.e.keys())
        this.e.delete(h)
      }
      return this.e.set(l, c), (this.d += 1), { ...u, id: l }
    }
    releaseHover(t) {
      this.e.delete(t)
    }
  },
  drt = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideEvaluatableExpression(i, t, e) {
      const r = this.d.getDocument(i),
        s = Gt.to(t),
        a = await this.e.provideEvaluatableExpression(r, s, e)
      if (a) return KO.from(a)
    }
  },
  mrt = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideInlineValues(i, t, e, r) {
      const s = this.d.getDocument(i),
        a = await this.e.provideInlineValues(s, O.to(t), aA.to(e), r)
      if (Array.isArray(a)) return a.map((o) => sA.from(o))
    }
  },
  hrt = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideDocumentHighlights(i, t, e) {
      const r = this.d.getDocument(i),
        s = Gt.to(t),
        a = await this.e.provideDocumentHighlights(r, s, e)
      if (Array.isArray(a)) return a.map(nc.from)
    }
  },
  frt = class {
    constructor(i, t, e) {
      ;(this.d = i), (this.e = t), (this.f = e)
    }
    async provideMultiDocumentHighlights(i, t, e, r) {
      const s = this.d.getDocument(i),
        a = e
          .map((u) => {
            try {
              return this.d.getDocument(u)
            } catch (l) {
              this.f.error(
                "Error: Unable to retrieve document from URI: " +
                  u +
                  ". Error message: " +
                  l,
              )
              return
            }
          })
          .filter((u) => u !== void 0),
        o = Gt.to(t),
        c = await this.e.provideMultiDocumentHighlights(s, o, a, r)
      if (Array.isArray(c)) return c.map(ZO.from)
    }
  },
  prt = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideLinkedEditingRanges(i, t, e) {
      const r = this.d.getDocument(i),
        s = Gt.to(t),
        a = await this.e.provideLinkedEditingRanges(r, s, e)
      if (a && Array.isArray(a.ranges))
        return { ranges: Ge(a.ranges.map(O.from)), wordPattern: a.wordPattern }
    }
  },
  grt = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideReferences(i, t, e, r) {
      const s = this.d.getDocument(i),
        a = Gt.to(t),
        o = await this.e.provideReferences(s, a, e, r)
      if (Array.isArray(o)) return o.map(Ri.from)
    }
  },
  y8 = class z8 {
    static {
      this.d = 1e3
    }
    constructor(t, e, r, s, a, o, c) {
      ;(this.g = t),
        (this.h = e),
        (this.j = r),
        (this.k = s),
        (this.l = a),
        (this.m = o),
        (this.n = c),
        (this.e = new Hr("CodeAction")),
        (this.f = new Map())
    }
    async provideCodeActions(t, e, r, s) {
      const a = this.g.getDocument(t),
        o = kAt.isISelection(e) ? Cr.to(e) : O.to(e),
        c = []
      for (const g of this.j.getDiagnostics(t))
        if (o.intersection(g.range) && c.push(g) > z8.d) break
      const u = {
          diagnostics: c,
          only: r.only ? new ge(r.only) : void 0,
          triggerKind: fq.to(r.trigger),
        },
        l = await this.k.provideCodeActions(a, o, u, s)
      if (!Su(l) || s.isCancellationRequested) return
      const m = this.e.add(l),
        h = new bt()
      this.f.set(m, h)
      const p = []
      for (let g = 0; g < l.length; g++) {
        const w = l[g]
        if (w)
          if (z8.o(w))
            this.n.report(
              "CodeActionProvider.provideCodeActions - return commands",
              this.m,
              "Return 'CodeAction' instances instead.",
            ),
              p.push({
                _isSynthetic: !0,
                title: w.title,
                command: this.h.toInternal(w, h),
              })
          else {
            u.only &&
              (w.kind
                ? u.only.contains(w.kind) ||
                  this.l.warn(
                    `${this.m.identifier.value} - Code actions of kind '${u.only.value}' requested but returned code action is of kind '${w.kind.value}'. Code action will be dropped. Please check 'CodeActionContext.only' to only return requested code actions.`,
                  )
                : this.l.warn(
                    `${this.m.identifier.value} - Code actions of kind '${u.only.value}' requested but returned code action does not have a 'kind'. Code action will be dropped. Please set 'CodeAction.kind'.`,
                  ))
            const T = w.ranges ?? []
            p.push({
              cacheId: [m, g],
              title: w.title,
              command: w.command && this.h.toInternal(w.command, h),
              diagnostics: w.diagnostics && w.diagnostics.map(ic.from),
              edit: w.edit && bi.from(w.edit, void 0),
              kind: w.kind && w.kind.value,
              isPreferred: w.isPreferred,
              isAI: Qe(this.m, "codeActionAI") ? w.isAI : !1,
              ranges: Qe(this.m, "codeActionRanges")
                ? Ge(T.map(O.from))
                : void 0,
              disabled: w.disabled?.reason,
            })
          }
      }
      return { cacheId: m, actions: p }
    }
    async resolveCodeAction(t, e) {
      const [r, s] = t,
        a = this.e.get(r, s)
      if (!a || z8.o(a)) return {}
      if (!this.k.resolveCodeAction) return {}
      const o = (await this.k.resolveCodeAction(a, e)) ?? a
      let c
      o.edit && (c = bi.from(o.edit, void 0))
      let u
      if (o.command) {
        const l = this.f.get(r)
        l && (u = this.h.toInternal(o.command, l))
      }
      return { edit: c, command: u }
    }
    releaseCodeActions(t) {
      this.f.get(t)?.dispose(), this.f.delete(t), this.e.delete(t)
    }
    static o(t) {
      return typeof t.command == "string" && typeof t.title == "string"
    }
  },
  vh = class {
    constructor(i, t, e, r, s) {
      ;(this.e = i),
        (this.f = t),
        (this.g = e),
        (this.h = r),
        (this.j = s),
        (this.d = new Hr("DocumentPasteEdit"))
    }
    async prepareDocumentPaste(i, t, e, r) {
      if (!this.g.prepareDocumentPaste) return
      const s = this.f.getDocument(i),
        a = t.map((u) => O.to(u)),
        o = bs.toDataTransfer(e, () => {
          throw new Gst()
        })
      if (
        (await this.g.prepareDocumentPaste(s, a, o, r),
        r.isCancellationRequested)
      )
        return
      const c = Array.from(o).filter(([, u]) => !(u instanceof b6))
      return bs.from(c)
    }
    async providePasteEdits(i, t, e, r, s, a) {
      if (!this.g.provideDocumentPasteEdits) return []
      const o = this.f.getDocument(t),
        c = e.map((h) => O.to(h)),
        u = bs.toDataTransfer(
          r,
          async (h) =>
            (await this.e.$resolvePasteFileData(this.h, i, h)).buffer,
        ),
        l = await this.g.provideDocumentPasteEdits(
          o,
          c,
          u,
          {
            only: s.only ? new Wo(s.only) : void 0,
            triggerKind: s.triggerKind,
          },
          a,
        )
      if (!l || a.isCancellationRequested) return []
      const m = this.d.add(l)
      return l.map((h, p) => ({
        _cacheId: [m, p],
        title: h.title ?? f(2760, null, this.j.displayName || this.j.name),
        kind: h.kind,
        yieldTo: h.yieldTo?.map((g) => g.value),
        insertText:
          typeof h.insertText == "string"
            ? h.insertText
            : { snippet: h.insertText.value },
        additionalEdit: h.additionalEdit
          ? bi.from(h.additionalEdit, void 0)
          : void 0,
      }))
    }
    async resolvePasteEdit(i, t) {
      const [e, r] = i,
        s = this.d.get(e, r)
      if (!s || !this.g.resolveDocumentPasteEdit) return {}
      const a = (await this.g.resolveDocumentPasteEdit(s, t)) ?? s
      return {
        additionalEdit: a.additionalEdit
          ? bi.from(a.additionalEdit, void 0)
          : void 0,
      }
    }
    releasePasteEdits(i) {
      this.d.delete(i)
    }
  },
  vrt = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideDocumentFormattingEdits(i, t, e) {
      const r = this.d.getDocument(i),
        s = await this.e.provideDocumentFormattingEdits(r, t, e)
      if (Array.isArray(s)) return s.map(He.from)
    }
  },
  EM = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideDocumentRangeFormattingEdits(i, t, e, r) {
      const s = this.d.getDocument(i),
        a = O.to(t),
        o = await this.e.provideDocumentRangeFormattingEdits(s, a, e, r)
      if (Array.isArray(o)) return o.map(He.from)
    }
    async provideDocumentRangesFormattingEdits(i, t, e, r) {
      VW(
        typeof this.e.provideDocumentRangesFormattingEdits == "function",
        "INVALID invocation of `provideDocumentRangesFormattingEdits`",
      )
      const s = this.d.getDocument(i),
        a = t.map(O.to),
        o = await this.e.provideDocumentRangesFormattingEdits(s, a, e, r)
      if (Array.isArray(o)) return o.map(He.from)
    }
  },
  wrt = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t), (this.autoFormatTriggerCharacters = [])
    }
    async provideOnTypeFormattingEdits(i, t, e, r, s) {
      const a = this.d.getDocument(i),
        o = Gt.to(t),
        c = await this.e.provideOnTypeFormattingEdits(a, o, e, r, s)
      if (Array.isArray(c)) return c.map(He.from)
    }
  },
  T8 = class {
    constructor(i, t) {
      ;(this.e = i), (this.f = t), (this.d = new Hr("WorkspaceSymbols"))
    }
    async provideWorkspaceSymbols(i, t) {
      const e = await this.e.provideWorkspaceSymbols(i, t)
      if (!Su(e)) return { symbols: [] }
      const r = this.d.add(e),
        s = { cacheId: r, symbols: [] }
      for (let a = 0; a < e.length; a++) {
        const o = e[a]
        if (!o || !o.name) {
          this.f.warn("INVALID SymbolInformation", o)
          continue
        }
        s.symbols.push({ ...Ja.from(o), cacheId: [r, a] })
      }
      return s
    }
    async resolveWorkspaceSymbol(i, t) {
      if (typeof this.e.resolveWorkspaceSymbol != "function" || !i.cacheId)
        return i
      const e = this.d.get(...i.cacheId)
      if (e) {
        const r = await this.e.resolveWorkspaceSymbol(e, t)
        return r && ra(i, Ja.from(r), !0)
      }
    }
    releaseWorkspaceSymbols(i) {
      this.d.delete(i)
    }
  },
  k8 = class IH {
    static supportsResolving(t) {
      return typeof t.prepareRename == "function"
    }
    constructor(t, e, r) {
      ;(this.d = t), (this.e = e), (this.f = r)
    }
    async provideRenameEdits(t, e, r, s) {
      const a = this.d.getDocument(t),
        o = Gt.to(e)
      try {
        const c = await this.e.provideRenameEdits(a, o, r, s)
        return c ? bi.from(c) : void 0
      } catch (c) {
        const u = IH.g(c)
        return u ? { rejectReason: u, edits: void 0 } : Promise.reject(c)
      }
    }
    async resolveRenameLocation(t, e, r) {
      if (typeof this.e.prepareRename != "function")
        return Promise.resolve(void 0)
      const s = this.d.getDocument(t),
        a = Gt.to(e)
      try {
        const o = await this.e.prepareRename(s, a, r)
        let c, u
        if (
          (Nt.isRange(o)
            ? ((c = o), (u = s.getText(o)))
            : Ce(o) && ((c = o.range), (u = o.placeholder)),
          !c || !u)
        )
          return
        if (c.start.line > a.line || c.end.line < a.line) {
          this.f.warn(
            "INVALID rename location: position line must be within range start/end lines",
          )
          return
        }
        return { range: O.from(c), text: u }
      } catch (o) {
        const c = IH.g(o)
        return c
          ? { rejectReason: c, range: void 0, text: void 0 }
          : Promise.reject(o)
      }
    }
    static g(t) {
      return typeof t == "string"
        ? t
        : t instanceof Error && typeof t.message == "string"
          ? t.message
          : void 0
    }
  },
  IM = class PH {
    static {
      this.d = { [b_.Invoke]: $l.Invoke, [b_.Automatic]: $l.Automatic }
    }
    constructor(t, e, r) {
      ;(this.e = t), (this.f = e), (this.g = r)
    }
    async supportsAutomaticNewSymbolNamesTriggerKind() {
      return this.f.supportsAutomaticTriggerKind
    }
    async provideNewSymbolNames(t, e, r, s) {
      const a = this.e.getDocument(t),
        o = O.to(e)
      try {
        const c = PH.d[r],
          u = await this.f.provideNewSymbolNames(a, o, c, s)
        return u
          ? u.map((l) =>
              typeof l == "string"
                ? { newSymbolName: l }
                : { newSymbolName: l.newSymbolName, tags: l.tags },
            )
          : void 0
      } catch (c) {
        this.g.error(PH.h(c) ?? JSON.stringify(c, null, "	"))
        return
      }
    }
    static h(t) {
      return typeof t == "string"
        ? t
        : t instanceof Error && typeof t.message == "string"
          ? t.message
          : void 0
    }
  },
  PM = class {
    constructor(i, t) {
      ;(this.resultId = i), (this.tokens = t)
    }
  },
  NM = class jr {
    constructor(t, e) {
      ;(this.f = t), (this.g = e), (this.e = 1), (this.d = new Map())
    }
    async provideDocumentSemanticTokens(t, e, r) {
      const s = this.f.getDocument(t),
        a = e !== 0 ? this.d.get(e) : null
      let o =
        typeof a?.resultId == "string" &&
        typeof this.g.provideDocumentSemanticTokensEdits == "function"
          ? await this.g.provideDocumentSemanticTokensEdits(s, a.resultId, r)
          : await this.g.provideDocumentSemanticTokens(s, r)
      return (
        a && this.d.delete(e), o ? ((o = jr.h(o)), this.o(jr.n(a, o), o)) : null
      )
    }
    async releaseDocumentSemanticColoring(t) {
      this.d.delete(t)
    }
    static h(t) {
      return jr.j(t)
        ? jr.k(t)
          ? t
          : new Yo(new Uint32Array(t.data), t.resultId)
        : jr.l(t)
          ? jr.m(t)
            ? t
            : new C6(
                t.edits.map(
                  (e) =>
                    new iY(
                      e.start,
                      e.deleteCount,
                      e.data ? new Uint32Array(e.data) : e.data,
                    ),
                ),
                t.resultId,
              )
          : t
    }
    static j(t) {
      return t && !!t.data
    }
    static k(t) {
      return t.data instanceof Uint32Array
    }
    static l(t) {
      return t && Array.isArray(t.edits)
    }
    static m(t) {
      for (const e of t.edits) if (!(e.data instanceof Uint32Array)) return !1
      return !0
    }
    static n(t, e) {
      if (!jr.j(e) || !t || !t.tokens) return e
      const r = t.tokens,
        s = r.length,
        a = e.data,
        o = a.length
      let c = 0
      const u = Math.min(s, o)
      for (; c < u && r[c] === a[c]; ) c++
      if (c === s && c === o) return new C6([], e.resultId)
      let l = 0
      const m = u - c
      for (; l < m && r[s - l - 1] === a[o - l - 1]; ) l++
      return new C6(
        [{ start: c, deleteCount: s - c - l, data: a.subarray(c, o - l) }],
        e.resultId,
      )
    }
    o(t, e) {
      if (jr.j(t)) {
        const r = this.e++
        return (
          this.d.set(r, new PM(t.resultId, t.data)),
          bU({ id: r, type: "full", data: t.data })
        )
      }
      if (jr.l(t)) {
        const r = this.e++
        return (
          jr.j(e)
            ? this.d.set(r, new PM(e.resultId, e.data))
            : this.d.set(r, new PM(t.resultId)),
          bU({
            id: r,
            type: "delta",
            deltas: (t.edits || []).map((s) => ({
              start: s.start,
              deleteCount: s.deleteCount,
              data: s.data,
            })),
          })
        )
      }
      return null
    }
  },
  yrt = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideDocumentRangeSemanticTokens(i, t, e) {
      const r = this.d.getDocument(i),
        s = await this.e.provideDocumentRangeSemanticTokens(r, O.to(t), e)
      return s ? this.f(s) : null
    }
    f(i) {
      return bU({ id: 0, type: "full", data: i.data })
    }
  },
  wh = class lst {
    static supportsResolving(t) {
      return typeof t.resolveCompletionItem == "function"
    }
    constructor(t, e, r, s, a) {
      ;(this.f = t),
        (this.g = e),
        (this.h = r),
        (this.j = s),
        (this.k = a),
        (this.d = new Hr("CompletionItem")),
        (this.e = new Map())
    }
    async provideCompletionItems(t, e, r, s) {
      const a = this.f.getDocument(t),
        o = Gt.to(e),
        c = a.getWordRangeAtPosition(o) || new Nt(o, o),
        u = c.with({ end: o }),
        l = new Ys(),
        m = await this.h.provideCompletionItems(a, o, s, eq.to(r))
      if (!m || s.isCancellationRequested) return
      const h = Array.isArray(m) ? new Ao(m) : m,
        p = lst.supportsResolving(this.h)
          ? this.d.add(h.items)
          : this.d.add([]),
        g = new bt()
      this.e.set(p, g)
      const w = [],
        T = {
          x: p,
          b: w,
          a: { replace: O.from(c), insert: O.from(u) },
          c: h.isIncomplete || void 0,
          d: l.elapsed(),
        }
      for (let b = 0; b < h.items.length; b++) {
        const N = h.items[b],
          $ = this.l(N, [p, b], u, c)
        w.push($)
      }
      return T
    }
    async resolveCompletionItem(t, e) {
      if (typeof this.h.resolveCompletionItem != "function") return
      const r = this.d.get(...t)
      if (!r) return
      const s = this.l(r, t),
        a = await this.h.resolveCompletionItem(r, e)
      if (!a) return
      const o = this.l(a, t)
      return (
        (s.h !== o.h || s.i !== o.i) &&
          this.j.report(
            "CompletionItem.insertText",
            this.k,
            "extension MAY NOT change 'insertText' of a CompletionItem during resolve",
          ),
        (s.n !== o.n || s.o !== o.o || !Ir(s.p, o.p)) &&
          this.j.report(
            "CompletionItem.command",
            this.k,
            "extension MAY NOT change 'command' of a CompletionItem during resolve",
          ),
        { ...s, d: o.d, c: o.c, l: o.l, h: o.h, i: o.i, n: o.n, o: o.o, p: o.p }
      )
    }
    releaseCompletionItems(t) {
      this.e.get(t)?.dispose(), this.e.delete(t), this.d.delete(t)
    }
    l(t, e, r, s) {
      const a = this.e.get(e[0])
      if (!a) throw Error("DisposableStore is missing...")
      const o = this.g.toInternal(t.command, a),
        c = {
          x: e,
          a: t.label,
          b: t.kind !== void 0 ? cA.from(t.kind) : void 0,
          m: t.tags && t.tags.map(oA.from),
          c: t.detail,
          d:
            typeof t.documentation > "u"
              ? void 0
              : Jt.fromStrict(t.documentation),
          e: t.sortText !== t.label ? t.sortText : void 0,
          f: t.filterText !== t.label ? t.filterText : void 0,
          g: t.preselect || void 0,
          i: t.keepWhitespace ? 1 : 0,
          k: t.commitCharacters?.join(""),
          l: t.additionalTextEdits && t.additionalTextEdits.map(He.from),
          n: o?.$ident,
          o: o?.id,
          p: o?.$ident ? void 0 : o?.arguments,
        }
      t.textEdit
        ? (this.j.report(
            "CompletionItem.textEdit",
            this.k,
            "Use 'CompletionItem.insertText' and 'CompletionItem.range' instead.",
          ),
          (c.h = t.textEdit.newText))
        : typeof t.insertText == "string"
          ? (c.h = t.insertText)
          : t.insertText instanceof wa &&
            ((c.h = t.insertText.value), (c.i |= 4))
      let u
      return (
        t.textEdit ? (u = t.textEdit.range) : t.range && (u = t.range),
        Nt.isRange(u)
          ? (c.j = O.from(u))
          : u &&
            (!r?.isEqual(u.inserting) || !s?.isEqual(u.replacing)) &&
            (c.j = {
              insert: O.from(u.inserting),
              replace: O.from(u.replacing),
            }),
        c
      )
    }
  },
  jc = class {
    async provideInlineCompletions(i, t, e, r) {}
    async provideInlineEditsForRange(i, t, e, r) {}
    disposeCompletions(i) {}
    handleDidShowCompletionItem(i, t, e) {}
    handlePartialAccept(i, t, e, r) {}
  },
  SAt = class extends jc {
    constructor(i, t, e, r) {
      super(),
        (this.f = i),
        (this.g = t),
        (this.h = e),
        (this.j = r),
        (this.d = new Trt()),
        (this.e = Qe(this.f, "inlineCompletionsAdditions")),
        (this.k = { [S_.Automatic]: Nl.Automatic, [S_.Explicit]: Nl.Invoke })
    }
    get supportsHandleEvents() {
      return (
        Qe(this.f, "inlineCompletionsAdditions") &&
        (typeof this.h.handleDidShowCompletionItem == "function" ||
          typeof this.h.handleDidPartiallyAcceptCompletionItem == "function")
      )
    }
    async provideInlineCompletions(i, t, e, r) {
      const s = this.g.getDocument(i),
        a = Gt.to(t),
        o = await this.h.provideInlineCompletionItems(
          s,
          a,
          {
            selectedCompletionInfo: e.selectedSuggestionInfo
              ? {
                  range: O.to(e.selectedSuggestionInfo.range),
                  text: e.selectedSuggestionInfo.text,
                }
              : void 0,
            triggerKind: this.k[e.triggerKind],
          },
          r,
        )
      if (!o || r.isCancellationRequested) return
      const c = Array.isArray(o) ? o : o.items,
        u = this.e ? (Array.isArray(o) ? [] : o.commands || []) : [],
        l = this.e && !Array.isArray(o) ? o.enableForwardStability : void 0
      let m
      return {
        pid: this.d.createReferenceId({
          dispose() {
            m?.dispose()
          },
          items: c,
        }),
        items: c.map((p, g) => {
          let w
          p.command &&
            (m || (m = new bt()), (w = this.j.toInternal(p.command, m)))
          const T = p.insertText
          return {
            insertText: typeof T == "string" ? T : { snippet: T.value },
            filterText: p.filterText,
            range: p.range ? O.from(p.range) : void 0,
            command: w,
            idx: g,
            completeBracketPairs: this.e ? p.completeBracketPairs : !1,
          }
        }),
        commands: u.map((p) => (m || (m = new bt()), this.j.toInternal(p, m))),
        suppressSuggestions: !1,
        enableForwardStability: l,
      }
    }
    async provideInlineEditsForRange(i, t, e, r) {
      if (!this.h.provideInlineEditsForRange) return
      F(this.f, "inlineCompletionsAdditions")
      const s = this.g.getDocument(i),
        a = O.to(t),
        o = await this.h.provideInlineEditsForRange(
          s,
          a,
          {
            selectedCompletionInfo: e.selectedSuggestionInfo
              ? {
                  range: O.to(e.selectedSuggestionInfo.range),
                  text: e.selectedSuggestionInfo.text,
                }
              : void 0,
            triggerKind: this.k[e.triggerKind],
            userPrompt: e.userPrompt,
          },
          r,
        )
      if (!o || r.isCancellationRequested) return
      const c = Array.isArray(o) ? o : o.items,
        u = this.e ? (Array.isArray(o) ? [] : o.commands || []) : [],
        l = this.e && !Array.isArray(o) ? o.enableForwardStability : void 0
      let m
      return {
        pid: this.d.createReferenceId({
          dispose() {
            m?.dispose()
          },
          items: c,
        }),
        items: c.map((p, g) => {
          let w
          p.command &&
            (m || (m = new bt()), (w = this.j.toInternal(p.command, m)))
          const T = p.insertText
          return {
            insertText: typeof T == "string" ? T : { snippet: T.value },
            filterText: p.filterText,
            range: p.range ? O.from(p.range) : void 0,
            command: w,
            idx: g,
            completeBracketPairs: this.e ? p.completeBracketPairs : !1,
          }
        }),
        commands: u.map((p) => (m || (m = new bt()), this.j.toInternal(p, m))),
        suppressSuggestions: !1,
        enableForwardStability: l,
      }
    }
    disposeCompletions(i) {
      this.d.disposeReferenceId(i)?.dispose()
    }
    handleDidShowCompletionItem(i, t, e) {
      const r = this.d.get(i)?.items[t]
      r &&
        this.h.handleDidShowCompletionItem &&
        this.e &&
        this.h.handleDidShowCompletionItem(r, e)
    }
    handlePartialAccept(i, t, e, r) {
      const s = this.d.get(i)?.items[t]
      s &&
        this.h.handleDidPartiallyAcceptCompletionItem &&
        this.e &&
        (this.h.handleDidPartiallyAcceptCompletionItem(s, e),
        this.h.handleDidPartiallyAcceptCompletionItem(s, Tq.to(r)))
    }
  },
  $M = class {
    async provideInlineEdits(i, t, e) {
      const r = this.f.getDocument(i),
        s = await this.g.provideInlineEdit(
          r,
          { triggerKind: this.e[t.triggerKind] },
          e,
        )
      if (!s || e.isCancellationRequested) return
      let a
      const o = this.d.createReferenceId({
        dispose() {
          a?.dispose()
        },
        item: s,
      })
      let c
      s.accepted &&
        (a || (a = new bt()), (c = this.h.toInternal(s.accepted, a)))
      let u
      s.rejected &&
        (a || (a = new bt()), (u = this.h.toInternal(s.rejected, a)))
      let l
      return (
        s.shown && (a || (a = new bt()), (l = this.h.toInternal(s.shown, a))),
        a || (a = new bt()),
        {
          pid: o,
          text: s.text,
          range: O.from(s.range),
          accepted: c,
          rejected: u,
          shown: l,
          commands: s.commands?.map((h) => this.h.toInternal(h, a)),
        }
      )
    }
    disposeEdit(i) {
      this.d.disposeReferenceId(i)?.dispose()
    }
    constructor(i, t, e, r) {
      ;(this.f = t),
        (this.g = e),
        (this.h = r),
        (this.d = new Trt()),
        (this.e = { [E_.Automatic]: jl.Automatic, [E_.Invoke]: jl.Invoke })
    }
  },
  Trt = class {
    constructor() {
      ;(this.d = new Map()), (this.e = 1)
    }
    createReferenceId(i) {
      const t = this.e++
      return this.d.set(t, i), t
    }
    disposeReferenceId(i) {
      const t = this.d.get(i)
      return this.d.delete(i), t
    }
    get(i) {
      return this.d.get(i)
    }
  },
  xM = class {
    constructor(i, t) {
      ;(this.e = i), (this.f = t), (this.d = new Hr("SignatureHelp"))
    }
    async provideSignatureHelp(i, t, e, r) {
      const s = this.e.getDocument(i),
        a = Gt.to(t),
        o = this.g(e),
        c = await this.f.provideSignatureHelp(s, a, r, o)
      if (c) {
        const u = this.d.add([c])
        return { ...zl.from(c), id: u }
      }
    }
    g(i) {
      let t
      if (i.activeSignatureHelp) {
        const e = zl.to(i.activeSignatureHelp),
          r = this.d.get(i.activeSignatureHelp.id, 0)
        r
          ? ((t = r),
            (t.activeSignature = e.activeSignature),
            (t.activeParameter = e.activeParameter))
          : (t = e)
      }
      return { ...i, activeSignatureHelp: t }
    }
    releaseSignatureHelp(i) {
      this.d.delete(i)
    }
  },
  S8 = class {
    constructor(i, t, e, r, s) {
      ;(this.f = i),
        (this.g = t),
        (this.h = e),
        (this.j = r),
        (this.k = s),
        (this.d = new Hr("InlayHints")),
        (this.e = new Map())
    }
    async provideInlayHints(i, t, e) {
      const r = this.f.getDocument(i),
        s = O.to(t),
        a = await this.h.provideInlayHints(r, s, e)
      if (!Array.isArray(a) || a.length === 0) {
        this.j.trace(
          `[InlayHints] NO inlay hints from '${this.k.identifier.value}' for range ${JSON.stringify(t)}`,
        )
        return
      }
      if (e.isCancellationRequested) return
      const o = this.d.add(a)
      this.e.set(o, new bt())
      const c = { hints: [], cacheId: o }
      for (let u = 0; u < a.length; u++)
        this.l(a[u], s) && c.hints.push(this.m(a[u], [o, u]))
      return (
        this.j.trace(
          `[InlayHints] ${c.hints.length} inlay hints from '${this.k.identifier.value}' for range ${JSON.stringify(t)}`,
        ),
        c
      )
    }
    async resolveInlayHint(i, t) {
      if (typeof this.h.resolveInlayHint != "function") return
      const e = this.d.get(...i)
      if (!e) return
      const r = await this.h.resolveInlayHint(e, t)
      if (r && this.l(r)) return this.m(r, i)
    }
    releaseHints(i) {
      this.e.get(i)?.dispose(), this.e.delete(i), this.d.delete(i)
    }
    l(i, t) {
      return i.label.length === 0 ||
        (Array.isArray(i.label) && i.label.every((e) => e.value.length === 0))
        ? (console.log("INVALID inlay hint, empty label", i), !1)
        : !(t && !t.contains(i.position))
    }
    m(i, t) {
      const e = this.e.get(t[0])
      if (!e) throw Error("DisposableStore is missing...")
      const r = {
        label: "",
        cacheId: t,
        tooltip: Jt.fromStrict(i.tooltip),
        position: Gt.from(i.position),
        textEdits: i.textEdits && i.textEdits.map(He.from),
        kind: i.kind && dA.from(i.kind),
        paddingLeft: i.paddingLeft,
        paddingRight: i.paddingRight,
      }
      if (typeof i.label == "string") r.label = i.label
      else {
        const s = []
        r.label = s
        for (const a of i.label) {
          if (!a.value) {
            console.warn(
              "INVALID inlay hint, empty label part",
              this.k.identifier.value,
            )
            continue
          }
          const o = { label: a.value, tooltip: Jt.fromStrict(a.tooltip) }
          er.isLocation(a.location) && (o.location = Ri.from(a.location)),
            a.command && (o.command = this.g.toInternal(a.command, e)),
            s.push(o)
        }
      }
      return r
    }
  },
  b8 = class Y8 {
    constructor(t, e) {
      ;(this.e = t), (this.f = e), (this.d = new Hr("DocumentLink"))
    }
    async provideLinks(t, e) {
      const r = this.e.getDocument(t),
        s = await this.f.provideDocumentLinks(r, e)
      if (
        !(!Array.isArray(s) || s.length === 0) &&
        !e.isCancellationRequested
      ) {
        if (typeof this.f.resolveDocumentLink != "function")
          return { links: s.filter(Y8.g).map(La.from) }
        {
          const a = this.d.add(s),
            o = { links: [], cacheId: a }
          for (let c = 0; c < s.length; c++) {
            if (!Y8.g(s[c])) continue
            const u = La.from(s[c])
            ;(u.cacheId = [a, c]), o.links.push(u)
          }
          return o
        }
      }
    }
    static g(t) {
      return t.target && t.target.path.length > 5e4
        ? (console.warn("DROPPING link because it is too long"), !1)
        : !0
    }
    async resolveLink(t, e) {
      if (typeof this.f.resolveDocumentLink != "function") return
      const r = this.d.get(...t)
      if (!r) return
      const s = await this.f.resolveDocumentLink(r, e)
      if (!(!s || !Y8.g(s))) return La.from(s)
    }
    releaseLinks(t) {
      this.d.delete(t)
    }
  },
  JM = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideColors(i, t) {
      const e = this.d.getDocument(i),
        r = await this.e.provideDocumentColors(e, t)
      return Array.isArray(r)
        ? r.map((a) => ({ color: sc.from(a.color), range: O.from(a.range) }))
        : []
    }
    async provideColorPresentations(i, t, e) {
      const r = this.d.getDocument(i),
        s = O.to(t.range),
        a = sc.to(t.color),
        o = await this.e.provideColorPresentations(
          a,
          { document: r, range: s },
          e,
        )
      if (Array.isArray(o)) return o.map(mA.from)
    }
  },
  krt = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideFoldingRanges(i, t, e) {
      const r = this.d.getDocument(i),
        s = await this.e.provideFoldingRanges(r, t, e)
      if (Array.isArray(s)) return s.map(fA.from)
    }
  },
  Srt = class {
    constructor(i, t, e) {
      ;(this.d = i), (this.e = t), (this.f = e)
    }
    async provideSelectionRanges(i, t, e) {
      const r = this.d.getDocument(i),
        s = t.map(Gt.to),
        a = await this.e.provideSelectionRanges(r, s, e)
      if (!Su(a)) return []
      if (a.length !== s.length)
        return (
          this.f.warn(
            "BAD selection ranges, provider must return ranges for each position",
          ),
          []
        )
      const o = []
      for (let c = 0; c < s.length; c++) {
        const u = []
        o.push(u)
        let l = s[c],
          m = a[c]
        for (;;) {
          if (!m.range.contains(l))
            throw new Error(
              "INVALID selection range, must contain the previous range",
            )
          if ((u.push(sq.from(m)), !m.parent)) break
          ;(l = m.range), (m = m.parent)
        }
      }
      return o
    }
  },
  yh = class {
    constructor(i, t) {
      ;(this.f = i), (this.g = t), (this.d = new b7("")), (this.e = new Map())
    }
    async prepareSession(i, t, e) {
      const r = this.f.getDocument(i),
        s = Gt.to(t),
        a = await this.g.prepareCallHierarchy(r, s, e)
      if (!a) return
      const o = this.d.nextId()
      return (
        this.e.set(o, new Map()),
        Array.isArray(a) ? a.map((c) => this.h(o, c)) : [this.h(o, a)]
      )
    }
    async provideCallsTo(i, t, e) {
      const r = this.j(i, t)
      if (!r) throw new Error("missing call hierarchy item")
      const s = await this.g.provideCallHierarchyIncomingCalls(r, e)
      if (s)
        return s.map((a) => ({
          from: this.h(i, a.from),
          fromRanges: a.fromRanges.map((o) => O.from(o)),
        }))
    }
    async provideCallsFrom(i, t, e) {
      const r = this.j(i, t)
      if (!r) throw new Error("missing call hierarchy item")
      const s = await this.g.provideCallHierarchyOutgoingCalls(r, e)
      if (s)
        return s.map((a) => ({
          to: this.h(i, a.to),
          fromRanges: a.fromRanges.map((o) => O.from(o)),
        }))
    }
    releaseSession(i) {
      this.e.delete(i)
    }
    h(i, t) {
      const e = this.e.get(i),
        r = Ca.from(t, i, e.size.toString(36))
      return e.set(r._itemId, t), r
    }
    j(i, t) {
      return this.e.get(i)?.get(t)
    }
  },
  Th = class {
    constructor(i, t) {
      ;(this.f = i), (this.g = t), (this.d = new b7("")), (this.e = new Map())
    }
    async prepareSession(i, t, e) {
      const r = this.f.getDocument(i),
        s = Gt.to(t),
        a = await this.g.prepareTypeHierarchy(r, s, e)
      if (!a) return
      const o = this.d.nextId()
      return (
        this.e.set(o, new Map()),
        Array.isArray(a) ? a.map((c) => this.h(o, c)) : [this.h(o, a)]
      )
    }
    async provideSupertypes(i, t, e) {
      const r = this.j(i, t)
      if (!r) throw new Error("missing type hierarchy item")
      const s = await this.g.provideTypeHierarchySupertypes(r, e)
      if (s) return s.map((a) => this.h(i, a))
    }
    async provideSubtypes(i, t, e) {
      const r = this.j(i, t)
      if (!r) throw new Error("missing type hierarchy item")
      const s = await this.g.provideTypeHierarchySubtypes(r, e)
      if (s) return s.map((a) => this.h(i, a))
    }
    releaseSession(i) {
      this.e.delete(i)
    }
    h(i, t) {
      const e = this.e.get(i),
        r = Ra.from(t, i, e.size.toString(36))
      return e.set(r._itemId, t), r
    }
    j(i, t) {
      return this.e.get(i)?.get(t)
    }
  },
  E8 = class {
    constructor(i, t, e, r, s) {
      ;(this.e = i),
        (this.f = t),
        (this.g = e),
        (this.h = r),
        (this.j = s),
        (this.d = new Hr("DocumentDropEdit"))
    }
    async provideDocumentOnDropEdits(i, t, e, r, s) {
      const a = this.f.getDocument(t),
        o = Gt.to(e),
        c = bs.toDataTransfer(
          r,
          async (h) =>
            (await this.e.$resolveDocumentOnDropFileData(this.h, i, h)).buffer,
        ),
        u = await this.g.provideDocumentDropEdits(a, o, c, s)
      if (!u) return
      const l = Yr(u),
        m = this.d.add(l)
      return l.map((h, p) => ({
        _cacheId: [m, p],
        title: h.title ?? f(2761, null, this.j.displayName || this.j.name),
        kind: h.kind?.value,
        yieldTo: h.yieldTo?.map((g) => g.value),
        insertText:
          typeof h.insertText == "string"
            ? h.insertText
            : { snippet: h.insertText.value },
        additionalEdit: h.additionalEdit
          ? bi.from(h.additionalEdit, void 0)
          : void 0,
      }))
    }
    async resolveDropEdit(i, t) {
      const [e, r] = i,
        s = this.d.get(e, r)
      if (!s || !this.g.resolveDocumentDropEdit) return {}
      const a = (await this.g.resolveDocumentDropEdit(s, t)) ?? s
      return {
        additionalEdit: a.additionalEdit
          ? bi.from(a.additionalEdit, void 0)
          : void 0,
      }
    }
    releaseDropEdits(i) {
      this.d.delete(i)
    }
  },
  brt = class {
    constructor(i, t) {
      ;(this.d = i), (this.e = t)
    }
    async provideMappedEdits(i, t, e, r) {
      const s = S.revive(i),
        a = this.d.getDocument(s),
        o = (m) => ({
          uri: S.revive(m.uri),
          version: m.version,
          ranges: m.ranges.map((h) => O.to(h)),
        }),
        c = e.documents.map((m) => m.map(o)),
        u = {
          documents: c,
          selections: c[0]?.[0]?.ranges ?? [],
          conversation: e.conversation?.map((m) =>
            m.type === "response"
              ? {
                  type: "response",
                  message: m.message,
                  references: m.references?.map(o),
                }
              : { type: "request", message: m.message },
          ),
        },
        l = await this.e.provideMappedEdits(a, t, u, r)
      return l ? bi.from(l) : null
    }
  },
  kh = class {
    constructor(i, t) {
      ;(this.adapter = i), (this.extension = t)
    }
  },
  bAt = class Ke {
    static {
      this.d = 0
    }
    constructor(t, e, r, s, a, o, c, u) {
      ;(this.g = e),
        (this.h = r),
        (this.j = s),
        (this.k = a),
        (this.l = o),
        (this.m = c),
        (this.n = u),
        (this.f = new Map()),
        (this.e = t.getProxy(z.MainThreadLanguageFeatures))
    }
    o(t, e) {
      return ec.from(t, this.g, e)
    }
    p(t) {
      return new At(() => {
        this.f.delete(t), this.e.$unregister(t)
      })
    }
    q() {
      return Ke.d++
    }
    async s(t, e, r, s, a, o = !1) {
      const c = this.f.get(t)
      if (!c || !(c.adapter instanceof e)) return s
      const u = Date.now()
      o ||
        this.l.trace(
          `[${c.extension.identifier.value}] INVOKE provider '${r.toString().replace(/[\r\n]/g, "")}'`,
        )
      const l = r(c.adapter, c.extension)
      return (
        Promise.resolve(l)
          .catch((m) => {
            Xn(m) ||
              (this.l.error(
                `[${c.extension.identifier.value}] provider FAILED`,
              ),
              this.l.error(m),
              this.n.onExtensionError(c.extension.identifier, m))
          })
          .finally(() => {
            o ||
              this.l.trace(
                `[${c.extension.identifier.value}] provider DONE after ${Date.now() - u}ms`,
              )
          }),
        fe.isCancellationToken(a) ? cct(l, a) : l
      )
    }
    t(t, e) {
      const r = this.q()
      return this.f.set(r, new kh(t, e)), r
    }
    static u(t) {
      return t.displayName || t.name
    }
    static w(t) {
      return t.identifier.value
    }
    registerDocumentSymbolProvider(t, e, r, s) {
      const a = this.t(new art(this.h, r), t),
        o = (s && s.label) || Ke.u(t)
      return (
        this.e.$registerDocumentSymbolProvider(a, this.o(e, t), o), this.p(a)
      )
    }
    $provideDocumentSymbols(t, e, r) {
      return this.s(
        t,
        art,
        (s) => s.provideDocumentSymbols(S.revive(e), r),
        void 0,
        r,
      )
    }
    registerCodeLensProvider(t, e, r) {
      const s = this.q(),
        a = typeof r.onDidChangeCodeLenses == "function" ? this.q() : void 0
      this.f.set(
        s,
        new kh(new v8(this.h, this.j.converter, r, t, this.n, this.l), t),
      ),
        this.e.$registerCodeLensSupport(s, this.o(e, t), a)
      let o = this.p(s)
      if (a !== void 0) {
        const c = r.onDidChangeCodeLenses((u) => this.e.$emitCodeLensEvent(a))
        o = At.from(o, c)
      }
      return o
    }
    $provideCodeLenses(t, e, r) {
      return this.s(
        t,
        v8,
        (s) => s.provideCodeLenses(S.revive(e), r),
        void 0,
        r,
        e.scheme === "output",
      )
    }
    $resolveCodeLens(t, e, r) {
      return this.s(t, v8, (s) => s.resolveCodeLens(e, r), void 0, void 0, !0)
    }
    $releaseCodeLenses(t, e) {
      this.s(
        t,
        v8,
        (r) => Promise.resolve(r.releaseCodeLenses(e)),
        void 0,
        void 0,
        !0,
      )
    }
    registerDefinitionProvider(t, e, r) {
      const s = this.t(new ort(this.h, r), t)
      return this.e.$registerDefinitionSupport(s, this.o(e, t)), this.p(s)
    }
    $provideDefinition(t, e, r, s) {
      return this.s(
        t,
        ort,
        (a) => a.provideDefinition(S.revive(e), r, s),
        [],
        s,
      )
    }
    registerDeclarationProvider(t, e, r) {
      const s = this.t(new crt(this.h, r), t)
      return this.e.$registerDeclarationSupport(s, this.o(e, t)), this.p(s)
    }
    $provideDeclaration(t, e, r, s) {
      return this.s(
        t,
        crt,
        (a) => a.provideDeclaration(S.revive(e), r, s),
        [],
        s,
      )
    }
    registerImplementationProvider(t, e, r) {
      const s = this.t(new urt(this.h, r), t)
      return this.e.$registerImplementationSupport(s, this.o(e, t)), this.p(s)
    }
    $provideImplementation(t, e, r, s) {
      return this.s(
        t,
        urt,
        (a) => a.provideImplementation(S.revive(e), r, s),
        [],
        s,
      )
    }
    registerTypeDefinitionProvider(t, e, r) {
      const s = this.t(new lrt(this.h, r), t)
      return this.e.$registerTypeDefinitionSupport(s, this.o(e, t)), this.p(s)
    }
    $provideTypeDefinition(t, e, r, s) {
      return this.s(
        t,
        lrt,
        (a) => a.provideTypeDefinition(S.revive(e), r, s),
        [],
        s,
      )
    }
    registerHoverProvider(t, e, r, s) {
      const a = this.t(new bM(this.h, r), t)
      return this.e.$registerHoverProvider(a, this.o(e, t)), this.p(a)
    }
    $provideHover(t, e, r, s, a) {
      return this.s(
        t,
        bM,
        (o) => o.provideHover(S.revive(e), r, s, a),
        void 0,
        a,
      )
    }
    $releaseHover(t, e) {
      this.s(t, bM, (r) => Promise.resolve(r.releaseHover(e)), void 0, void 0)
    }
    registerEvaluatableExpressionProvider(t, e, r, s) {
      const a = this.t(new drt(this.h, r), t)
      return (
        this.e.$registerEvaluatableExpressionProvider(a, this.o(e, t)),
        this.p(a)
      )
    }
    $provideEvaluatableExpression(t, e, r, s) {
      return this.s(
        t,
        drt,
        (a) => a.provideEvaluatableExpression(S.revive(e), r, s),
        void 0,
        s,
      )
    }
    registerInlineValuesProvider(t, e, r, s) {
      const a =
          typeof r.onDidChangeInlineValues == "function" ? this.q() : void 0,
        o = this.t(new mrt(this.h, r), t)
      this.e.$registerInlineValuesProvider(o, this.o(e, t), a)
      let c = this.p(o)
      if (a !== void 0) {
        const u = r.onDidChangeInlineValues((l) =>
          this.e.$emitInlineValuesEvent(a),
        )
        c = At.from(c, u)
      }
      return c
    }
    $provideInlineValues(t, e, r, s, a) {
      return this.s(
        t,
        mrt,
        (o) => o.provideInlineValues(S.revive(e), r, s, a),
        void 0,
        a,
      )
    }
    registerDocumentHighlightProvider(t, e, r) {
      const s = this.t(new hrt(this.h, r), t)
      return (
        this.e.$registerDocumentHighlightProvider(s, this.o(e, t)), this.p(s)
      )
    }
    registerMultiDocumentHighlightProvider(t, e, r) {
      const s = this.t(new frt(this.h, r, this.l), t)
      return (
        this.e.$registerMultiDocumentHighlightProvider(s, this.o(e, t)),
        this.p(s)
      )
    }
    $provideDocumentHighlights(t, e, r, s) {
      return this.s(
        t,
        hrt,
        (a) => a.provideDocumentHighlights(S.revive(e), r, s),
        void 0,
        s,
      )
    }
    $provideMultiDocumentHighlights(t, e, r, s, a) {
      return this.s(
        t,
        frt,
        (o) =>
          o.provideMultiDocumentHighlights(
            S.revive(e),
            r,
            s.map((c) => S.revive(c)),
            a,
          ),
        void 0,
        a,
      )
    }
    registerLinkedEditingRangeProvider(t, e, r) {
      const s = this.t(new prt(this.h, r), t)
      return (
        this.e.$registerLinkedEditingRangeProvider(s, this.o(e, t)), this.p(s)
      )
    }
    $provideLinkedEditingRanges(t, e, r, s) {
      return this.s(
        t,
        prt,
        async (a) => {
          const o = await a.provideLinkedEditingRanges(S.revive(e), r, s)
          if (o)
            return {
              ranges: o.ranges,
              wordPattern: o.wordPattern ? Ke.y(o.wordPattern) : void 0,
            }
        },
        void 0,
        s,
      )
    }
    registerReferenceProvider(t, e, r) {
      const s = this.t(new grt(this.h, r), t)
      return this.e.$registerReferenceSupport(s, this.o(e, t)), this.p(s)
    }
    $provideReferences(t, e, r, s, a) {
      return this.s(
        t,
        grt,
        (o) => o.provideReferences(S.revive(e), r, s, a),
        void 0,
        a,
      )
    }
    registerCodeActionProvider(t, e, r, s) {
      const a = new bt(),
        o = this.t(
          new y8(this.h, this.j.converter, this.k, r, this.l, t, this.m),
          t,
        )
      return (
        this.e.$registerCodeActionSupport(
          o,
          this.o(e, t),
          {
            providedKinds: s?.providedCodeActionKinds?.map((c) => c.value),
            documentation: s?.documentation?.map((c) => ({
              kind: c.kind.value,
              command: this.j.converter.toInternal(c.command, a),
            })),
          },
          Ke.u(t),
          Ke.w(t),
          !!r.resolveCodeAction,
        ),
        a.add(this.p(o)),
        a
      )
    }
    $provideCodeActions(t, e, r, s, a) {
      return this.s(
        t,
        y8,
        (o) => o.provideCodeActions(S.revive(e), r, s, a),
        void 0,
        a,
      )
    }
    $resolveCodeAction(t, e, r) {
      return this.s(t, y8, (s) => s.resolveCodeAction(e, r), {}, void 0)
    }
    $releaseCodeActions(t, e) {
      this.s(
        t,
        y8,
        (r) => Promise.resolve(r.releaseCodeActions(e)),
        void 0,
        void 0,
      )
    }
    registerDocumentFormattingEditProvider(t, e, r) {
      const s = this.t(new vrt(this.h, r), t)
      return (
        this.e.$registerDocumentFormattingSupport(
          s,
          this.o(e, t),
          t.identifier,
          t.displayName || t.name,
        ),
        this.p(s)
      )
    }
    $provideDocumentFormattingEdits(t, e, r, s) {
      return this.s(
        t,
        vrt,
        (a) => a.provideDocumentFormattingEdits(S.revive(e), r, s),
        void 0,
        s,
      )
    }
    registerDocumentRangeFormattingEditProvider(t, e, r) {
      const s = typeof r.provideDocumentRangesFormattingEdits == "function",
        a = this.t(new EM(this.h, r), t)
      return (
        this.e.$registerRangeFormattingSupport(
          a,
          this.o(e, t),
          t.identifier,
          t.displayName || t.name,
          s,
        ),
        this.p(a)
      )
    }
    $provideDocumentRangeFormattingEdits(t, e, r, s, a) {
      return this.s(
        t,
        EM,
        (o) => o.provideDocumentRangeFormattingEdits(S.revive(e), r, s, a),
        void 0,
        a,
      )
    }
    $provideDocumentRangesFormattingEdits(t, e, r, s, a) {
      return this.s(
        t,
        EM,
        (o) => o.provideDocumentRangesFormattingEdits(S.revive(e), r, s, a),
        void 0,
        a,
      )
    }
    registerOnTypeFormattingEditProvider(t, e, r, s) {
      const a = this.t(new wrt(this.h, r), t)
      return (
        this.e.$registerOnTypeFormattingSupport(
          a,
          this.o(e, t),
          s,
          t.identifier,
        ),
        this.p(a)
      )
    }
    $provideOnTypeFormattingEdits(t, e, r, s, a, o) {
      return this.s(
        t,
        wrt,
        (c) => c.provideOnTypeFormattingEdits(S.revive(e), r, s, a, o),
        void 0,
        o,
      )
    }
    registerWorkspaceSymbolProvider(t, e) {
      const r = this.t(new T8(e, this.l), t)
      return (
        this.e.$registerNavigateTypeSupport(
          r,
          typeof e.resolveWorkspaceSymbol == "function",
        ),
        this.p(r)
      )
    }
    $provideWorkspaceSymbols(t, e, r) {
      return this.s(
        t,
        T8,
        (s) => s.provideWorkspaceSymbols(e, r),
        { symbols: [] },
        r,
      )
    }
    $resolveWorkspaceSymbol(t, e, r) {
      return this.s(
        t,
        T8,
        (s) => s.resolveWorkspaceSymbol(e, r),
        void 0,
        void 0,
      )
    }
    $releaseWorkspaceSymbols(t, e) {
      this.s(t, T8, (r) => r.releaseWorkspaceSymbols(e), void 0, void 0)
    }
    registerRenameProvider(t, e, r) {
      const s = this.t(new k8(this.h, r, this.l), t)
      return (
        this.e.$registerRenameSupport(s, this.o(e, t), k8.supportsResolving(r)),
        this.p(s)
      )
    }
    $provideRenameEdits(t, e, r, s, a) {
      return this.s(
        t,
        k8,
        (o) => o.provideRenameEdits(S.revive(e), r, s, a),
        void 0,
        a,
      )
    }
    $resolveRenameLocation(t, e, r, s) {
      return this.s(
        t,
        k8,
        (a) => a.resolveRenameLocation(S.revive(e), r, s),
        void 0,
        s,
      )
    }
    registerNewSymbolNamesProvider(t, e, r) {
      const s = this.t(new IM(this.h, r, this.l), t)
      return this.e.$registerNewSymbolNamesProvider(s, this.o(e, t)), this.p(s)
    }
    $supportsAutomaticNewSymbolNamesTriggerKind(t) {
      return this.s(
        t,
        IM,
        (e) => e.supportsAutomaticNewSymbolNamesTriggerKind(),
        !1,
        void 0,
      )
    }
    $provideNewSymbolNames(t, e, r, s, a) {
      return this.s(
        t,
        IM,
        (o) => o.provideNewSymbolNames(S.revive(e), r, s, a),
        void 0,
        a,
      )
    }
    registerDocumentSemanticTokensProvider(t, e, r, s) {
      const a = this.t(new NM(this.h, r), t),
        o = typeof r.onDidChangeSemanticTokens == "function" ? this.q() : void 0
      this.e.$registerDocumentSemanticTokensProvider(a, this.o(e, t), s, o)
      let c = this.p(a)
      if (o) {
        const u = r.onDidChangeSemanticTokens((l) =>
          this.e.$emitDocumentSemanticTokensEvent(o),
        )
        c = At.from(c, u)
      }
      return c
    }
    $provideDocumentSemanticTokens(t, e, r, s) {
      return this.s(
        t,
        NM,
        (a) => a.provideDocumentSemanticTokens(S.revive(e), r, s),
        null,
        s,
      )
    }
    $releaseDocumentSemanticTokens(t, e) {
      this.s(t, NM, (r) => r.releaseDocumentSemanticColoring(e), void 0, void 0)
    }
    registerDocumentRangeSemanticTokensProvider(t, e, r, s) {
      const a = this.t(new yrt(this.h, r), t)
      return (
        this.e.$registerDocumentRangeSemanticTokensProvider(a, this.o(e, t), s),
        this.p(a)
      )
    }
    $provideDocumentRangeSemanticTokens(t, e, r, s) {
      return this.s(
        t,
        yrt,
        (a) => a.provideDocumentRangeSemanticTokens(S.revive(e), r, s),
        null,
        s,
      )
    }
    registerCompletionItemProvider(t, e, r, s) {
      const a = this.t(new wh(this.h, this.j.converter, r, this.m, t), t)
      return (
        this.e.$registerCompletionsProvider(
          a,
          this.o(e, t),
          s,
          wh.supportsResolving(r),
          t.identifier,
        ),
        this.p(a)
      )
    }
    $provideCompletionItems(t, e, r, s, a) {
      return this.s(
        t,
        wh,
        (o) => o.provideCompletionItems(S.revive(e), r, s, a),
        void 0,
        a,
      )
    }
    $resolveCompletionItem(t, e, r) {
      return this.s(t, wh, (s) => s.resolveCompletionItem(e, r), void 0, r)
    }
    $releaseCompletionItems(t, e) {
      this.s(t, wh, (r) => r.releaseCompletionItems(e), void 0, void 0)
    }
    registerInlineCompletionsProvider(t, e, r, s) {
      const a = new SAt(t, this.h, r, this.j.converter),
        o = this.t(a, t)
      return (
        this.e.$registerInlineCompletionsSupport(
          o,
          this.o(e, t),
          a.supportsHandleEvents,
          te.toKey(t.identifier.value),
          s?.yieldTo?.map((c) => te.toKey(c)) || [],
        ),
        this.p(o)
      )
    }
    $provideInlineCompletions(t, e, r, s, a) {
      return this.s(
        t,
        jc,
        (o) => o.provideInlineCompletions(S.revive(e), r, s, a),
        void 0,
        a,
      )
    }
    $provideInlineEditsForRange(t, e, r, s, a) {
      return this.s(
        t,
        jc,
        (o) => o.provideInlineEditsForRange(S.revive(e), r, s, a),
        void 0,
        a,
      )
    }
    $handleInlineCompletionDidShow(t, e, r, s) {
      this.s(
        t,
        jc,
        async (a) => {
          a.handleDidShowCompletionItem(e, r, s)
        },
        void 0,
        void 0,
      )
    }
    $handleInlineCompletionPartialAccept(t, e, r, s, a) {
      this.s(
        t,
        jc,
        async (o) => {
          o.handlePartialAccept(e, r, s, a)
        },
        void 0,
        void 0,
      )
    }
    $freeInlineCompletionsList(t, e) {
      this.s(
        t,
        jc,
        async (r) => {
          r.disposeCompletions(e)
        },
        void 0,
        void 0,
      )
    }
    registerInlineEditProvider(t, e, r) {
      const s = new $M(t, this.h, r, this.j.converter),
        a = this.t(s, t)
      return (
        this.e.$registerInlineEditProvider(a, this.o(e, t), t.identifier),
        this.p(a)
      )
    }
    $provideInlineEdit(t, e, r, s) {
      return this.s(
        t,
        $M,
        (a) => a.provideInlineEdits(S.revive(e), r, s),
        void 0,
        s,
      )
    }
    $freeInlineEdit(t, e) {
      this.s(
        t,
        $M,
        async (r) => {
          r.disposeEdit(e)
        },
        void 0,
        void 0,
      )
    }
    registerSignatureHelpProvider(t, e, r, s) {
      const a = Array.isArray(s)
          ? { triggerCharacters: s, retriggerCharacters: [] }
          : s,
        o = this.t(new xM(this.h, r), t)
      return (
        this.e.$registerSignatureHelpProvider(o, this.o(e, t), a), this.p(o)
      )
    }
    $provideSignatureHelp(t, e, r, s, a) {
      return this.s(
        t,
        xM,
        (o) => o.provideSignatureHelp(S.revive(e), r, s, a),
        void 0,
        a,
      )
    }
    $releaseSignatureHelp(t, e) {
      this.s(t, xM, (r) => r.releaseSignatureHelp(e), void 0, void 0)
    }
    registerInlayHintsProvider(t, e, r) {
      const s =
          typeof r.onDidChangeInlayHints == "function" ? this.q() : void 0,
        a = this.t(new S8(this.h, this.j.converter, r, this.l, t), t)
      this.e.$registerInlayHintsProvider(
        a,
        this.o(e, t),
        typeof r.resolveInlayHint == "function",
        s,
        Ke.u(t),
      )
      let o = this.p(a)
      if (s !== void 0) {
        const c = r.onDidChangeInlayHints((u) => this.e.$emitInlayHintsEvent(s))
        o = At.from(o, c)
      }
      return o
    }
    $provideInlayHints(t, e, r, s) {
      return this.s(
        t,
        S8,
        (a) => a.provideInlayHints(S.revive(e), r, s),
        void 0,
        s,
      )
    }
    $resolveInlayHint(t, e, r) {
      return this.s(t, S8, (s) => s.resolveInlayHint(e, r), void 0, r)
    }
    $releaseInlayHints(t, e) {
      this.s(t, S8, (r) => r.releaseHints(e), void 0, void 0)
    }
    registerDocumentLinkProvider(t, e, r) {
      const s = this.t(new b8(this.h, r), t)
      return (
        this.e.$registerDocumentLinkProvider(
          s,
          this.o(e, t),
          typeof r.resolveDocumentLink == "function",
        ),
        this.p(s)
      )
    }
    $provideDocumentLinks(t, e, r) {
      return this.s(
        t,
        b8,
        (s) => s.provideLinks(S.revive(e), r),
        void 0,
        r,
        e.scheme === "output",
      )
    }
    $resolveDocumentLink(t, e, r) {
      return this.s(t, b8, (s) => s.resolveLink(e, r), void 0, void 0, !0)
    }
    $releaseDocumentLinks(t, e) {
      this.s(t, b8, (r) => r.releaseLinks(e), void 0, void 0, !0)
    }
    registerColorProvider(t, e, r) {
      const s = this.t(new JM(this.h, r), t)
      return this.e.$registerDocumentColorProvider(s, this.o(e, t)), this.p(s)
    }
    $provideDocumentColors(t, e, r) {
      return this.s(t, JM, (s) => s.provideColors(S.revive(e), r), [], r)
    }
    $provideColorPresentations(t, e, r, s) {
      return this.s(
        t,
        JM,
        (a) => a.provideColorPresentations(S.revive(e), r, s),
        void 0,
        s,
      )
    }
    registerFoldingRangeProvider(t, e, r) {
      const s = this.q(),
        a = typeof r.onDidChangeFoldingRanges == "function" ? this.q() : void 0
      this.f.set(s, new kh(new krt(this.h, r), t)),
        this.e.$registerFoldingRangeProvider(s, this.o(e, t), t.identifier, a)
      let o = this.p(s)
      if (a !== void 0) {
        const c = r.onDidChangeFoldingRanges(() =>
          this.e.$emitFoldingRangeEvent(a),
        )
        o = At.from(o, c)
      }
      return o
    }
    $provideFoldingRanges(t, e, r, s) {
      return this.s(
        t,
        krt,
        (a) => a.provideFoldingRanges(S.revive(e), r, s),
        void 0,
        s,
      )
    }
    registerSelectionRangeProvider(t, e, r) {
      const s = this.t(new Srt(this.h, r, this.l), t)
      return this.e.$registerSelectionRangeProvider(s, this.o(e, t)), this.p(s)
    }
    $provideSelectionRanges(t, e, r, s) {
      return this.s(
        t,
        Srt,
        (a) => a.provideSelectionRanges(S.revive(e), r, s),
        [],
        s,
      )
    }
    registerCallHierarchyProvider(t, e, r) {
      const s = this.t(new yh(this.h, r), t)
      return this.e.$registerCallHierarchyProvider(s, this.o(e, t)), this.p(s)
    }
    $prepareCallHierarchy(t, e, r, s) {
      return this.s(
        t,
        yh,
        (a) => Promise.resolve(a.prepareSession(S.revive(e), r, s)),
        void 0,
        s,
      )
    }
    $provideCallHierarchyIncomingCalls(t, e, r, s) {
      return this.s(t, yh, (a) => a.provideCallsTo(e, r, s), void 0, s)
    }
    $provideCallHierarchyOutgoingCalls(t, e, r, s) {
      return this.s(t, yh, (a) => a.provideCallsFrom(e, r, s), void 0, s)
    }
    $releaseCallHierarchy(t, e) {
      this.s(t, yh, (r) => Promise.resolve(r.releaseSession(e)), void 0, void 0)
    }
    registerTypeHierarchyProvider(t, e, r) {
      const s = this.t(new Th(this.h, r), t)
      return this.e.$registerTypeHierarchyProvider(s, this.o(e, t)), this.p(s)
    }
    $prepareTypeHierarchy(t, e, r, s) {
      return this.s(
        t,
        Th,
        (a) => Promise.resolve(a.prepareSession(S.revive(e), r, s)),
        void 0,
        s,
      )
    }
    $provideTypeHierarchySupertypes(t, e, r, s) {
      return this.s(t, Th, (a) => a.provideSupertypes(e, r, s), void 0, s)
    }
    $provideTypeHierarchySubtypes(t, e, r, s) {
      return this.s(t, Th, (a) => a.provideSubtypes(e, r, s), void 0, s)
    }
    $releaseTypeHierarchy(t, e) {
      this.s(t, Th, (r) => Promise.resolve(r.releaseSession(e)), void 0, void 0)
    }
    registerDocumentOnDropEditProvider(t, e, r, s) {
      const a = this.q()
      return (
        this.f.set(a, new kh(new E8(this.e, this.h, r, a, t), t)),
        this.e.$registerDocumentOnDropEditProvider(
          a,
          this.o(e, t),
          Qe(t, "documentPaste") && s
            ? {
                supportsResolve: !!r.resolveDocumentDropEdit,
                dropMimeTypes: s.dropMimeTypes,
                providedDropKinds: s.providedDropEditKinds?.map((o) => o.value),
              }
            : void 0,
        ),
        this.p(a)
      )
    }
    $provideDocumentOnDropEdits(t, e, r, s, a, o) {
      return this.s(
        t,
        E8,
        (c) =>
          Promise.resolve(
            c.provideDocumentOnDropEdits(e, S.revive(r), s, a, o),
          ),
        void 0,
        void 0,
      )
    }
    $resolveDropEdit(t, e, r) {
      return this.s(t, E8, (s) => s.resolveDropEdit(e, r), {}, void 0)
    }
    $releaseDocumentOnDropEdits(t, e) {
      this.s(
        t,
        E8,
        (r) => Promise.resolve(r.releaseDropEdits(e)),
        void 0,
        void 0,
      )
    }
    registerMappedEditsProvider(t, e, r) {
      const s = this.t(new brt(this.h, r), t)
      return (
        this.e.$registerMappedEditsProvider(
          s,
          this.o(e, t),
          t.displayName ?? t.name,
        ),
        this.p(s)
      )
    }
    $provideMappedEdits(t, e, r, s, a) {
      return this.s(
        t,
        brt,
        (o) => Promise.resolve(o.provideMappedEdits(e, r, s, a)),
        null,
        a,
      )
    }
    registerDocumentPasteEditProvider(t, e, r, s) {
      const a = this.q()
      return (
        this.f.set(a, new kh(new vh(this.e, this.h, r, a, t), t)),
        this.e.$registerPasteEditProvider(a, this.o(e, t), {
          supportsCopy: !!r.prepareDocumentPaste,
          supportsPaste: !!r.provideDocumentPasteEdits,
          supportsResolve: !!r.resolveDocumentPasteEdit,
          providedPasteEditKinds: s.providedPasteEditKinds?.map((o) => o.value),
          copyMimeTypes: s.copyMimeTypes,
          pasteMimeTypes: s.pasteMimeTypes,
        }),
        this.p(a)
      )
    }
    $prepareDocumentPaste(t, e, r, s, a) {
      return this.s(
        t,
        vh,
        (o) => o.prepareDocumentPaste(S.revive(e), r, s, a),
        void 0,
        a,
      )
    }
    $providePasteEdits(t, e, r, s, a, o, c) {
      return this.s(
        t,
        vh,
        (u) => u.providePasteEdits(e, S.revive(r), s, a, o, c),
        void 0,
        c,
      )
    }
    $resolvePasteEdit(t, e, r) {
      return this.s(t, vh, (s) => s.resolvePasteEdit(e, r), {}, void 0)
    }
    $releasePasteEdits(t, e) {
      this.s(
        t,
        vh,
        (r) => Promise.resolve(r.releasePasteEdits(e)),
        void 0,
        void 0,
      )
    }
    static y(t) {
      return { pattern: t.source, flags: t.flags }
    }
    static z(t) {
      return {
        decreaseIndentPattern: Ke.y(t.decreaseIndentPattern),
        increaseIndentPattern: Ke.y(t.increaseIndentPattern),
        indentNextLinePattern: t.indentNextLinePattern
          ? Ke.y(t.indentNextLinePattern)
          : void 0,
        unIndentedLinePattern: t.unIndentedLinePattern
          ? Ke.y(t.unIndentedLinePattern)
          : void 0,
      }
    }
    static B(t) {
      return {
        beforeText: Ke.y(t.beforeText),
        afterText: t.afterText ? Ke.y(t.afterText) : void 0,
        previousLineText: t.previousLineText
          ? Ke.y(t.previousLineText)
          : void 0,
        action: t.action,
      }
    }
    static C(t) {
      return t.map(Ke.B)
    }
    static D(t) {
      return {
        open: t.open,
        close: t.close,
        notIn: t.notIn ? t.notIn.map((e) => Uo.toString(e)) : void 0,
      }
    }
    static E(t) {
      return t.map(Ke.D)
    }
    setLanguageConfiguration(t, e, r) {
      const { wordPattern: s } = r
      if (s && RW(s))
        throw new Error(
          `Invalid language configuration: wordPattern '${s}' is not allowed to match the empty string.`,
        )
      s
        ? this.h.setWordDefinitionFor(e, s)
        : this.h.setWordDefinitionFor(e, void 0),
        r.__electricCharacterSupport &&
          this.m.report(
            "LanguageConfiguration.__electricCharacterSupport",
            t,
            "Do not use.",
          ),
        r.__characterPairSupport &&
          this.m.report(
            "LanguageConfiguration.__characterPairSupport",
            t,
            "Do not use.",
          )
      const a = this.q(),
        o = {
          comments: r.comments,
          brackets: r.brackets,
          wordPattern: r.wordPattern ? Ke.y(r.wordPattern) : void 0,
          indentationRules: r.indentationRules
            ? Ke.z(r.indentationRules)
            : void 0,
          onEnterRules: r.onEnterRules ? Ke.C(r.onEnterRules) : void 0,
          __electricCharacterSupport: r.__electricCharacterSupport,
          __characterPairSupport: r.__characterPairSupport,
          autoClosingPairs: r.autoClosingPairs
            ? Ke.E(r.autoClosingPairs)
            : void 0,
        }
      return this.e.$setLanguageConfiguration(a, e, o), this.p(a)
    }
    $setWordDefinitions(t) {
      for (const e of t)
        this.h.setWordDefinitionFor(
          e.languageId,
          new RegExp(e.regexSource, e.regexFlags),
        )
    }
  }
function EAt(i) {
  return typeof i == "object" && typeof i.sessionId == "string"
}
var kMt = Y("ILanguageModelToolsService"),
  IAt = class {
    constructor(i) {
      ;(this.a = new Map()),
        (this.c = new Map()),
        (this.d = new Map()),
        (this.b = i.getProxy(z.MainThreadLanguageModelTools)),
        this.b.$getTools().then((t) => {
          for (const e of t) this.d.set(e.id, $i(e))
        })
    }
    async $countTokensForInvocation(i, t, e) {
      const r = this.c.get(i)
      if (!r) throw new Error(`Tool invocation call ${i} not found`)
      return await r(t, e)
    }
    async invokeTool(i, t, e) {
      const r = Ki()
      if (
        (t.tokenizationOptions &&
          this.c.set(r, t.tokenizationOptions.countTokens),
        t.toolInvocationToken && !EAt(t.toolInvocationToken))
      )
        throw new Error("Invalid tool invocation token")
      try {
        return await this.b.$invokeTool(
          {
            toolId: i,
            callId: r,
            parameters: t.input,
            tokenBudget: t.tokenizationOptions?.tokenBudget,
            context: t.toolInvocationToken,
          },
          e,
        )
      } finally {
        this.c.delete(r)
      }
    }
    $onDidChangeTools(i) {
      this.d.clear()
      for (const t of i) this.d.set(t.id, t)
    }
    get tools() {
      return Array.from(this.d.values()).map((i) => bq.to(i))
    }
    async $invokeTool(i, t) {
      const e = this.a.get(i.toolId)
      if (!e) throw new Error(`Unknown tool ${i.toolId}`)
      const r = { input: i.parameters, toolInvocationToken: i.context }
      i.tokenBudget !== void 0 &&
        (r.tokenizationOptions = {
          tokenBudget: i.tokenBudget,
          countTokens:
            this.c.get(i.callId) ||
            ((a, o = fe.None) =>
              this.b.$countTokensForInvocation(i.callId, a, o)),
        })
      const s = await rj(Promise.resolve(e.tool.invoke(r, t)), t)
      if (!s) throw new zr()
      return Eq.from(s)
    }
    async $prepareToolInvocation(i, t, e) {
      const r = this.a.get(i)
      if (!r) throw new Error(`Unknown tool ${i}`)
      if (!r.tool.prepareInvocation) return
      const s = { input: t },
        a = await r.tool.prepareInvocation(s, e)
      if (a)
        return {
          confirmationMessages: a.confirmationMessages
            ? {
                title: a.confirmationMessages.title,
                message:
                  typeof a.confirmationMessages.message == "string"
                    ? a.confirmationMessages.message
                    : Jt.from(a.confirmationMessages.message),
              }
            : void 0,
          invocationMessage:
            typeof a.invocationMessage == "string"
              ? a.invocationMessage
              : a.invocationMessage
                ? Jt.from(a.invocationMessage)
                : void 0,
        }
    }
    registerTool(i, t, e) {
      return (
        this.a.set(t, { extension: i, tool: e }),
        this.b.$registerTool(t),
        it(() => {
          this.a.delete(t), this.b.$unregisterTool(t)
        })
      )
    }
  },
  PAt = class {
    constructor(i, t, e, r) {
      ;(this.c = t),
        (this.d = e),
        (this.e = r),
        (this.b = []),
        (this.f = 0),
        (this.g = new Set()),
        (this.a = i.getProxy(z.MainThreadLanguages))
    }
    $acceptLanguageIds(i) {
      this.b = i
    }
    async getLanguages() {
      return this.b.slice(0)
    }
    async changeLanguage(i, t) {
      await this.a.$changeLanguage(i, t)
      const e = this.c.getDocumentData(i)
      if (!e) throw new Error(`document '${i.toString()}' NOT found`)
      return e.document
    }
    async tokenAtPosition(i, t) {
      const e = i.version,
        r = Gt.from(t),
        s = await this.a.$tokensAtPosition(i.uri, r),
        a = {
          type: ws.Other,
          range:
            i.getWordRangeAtPosition(t) ??
            new Nt(t.line, t.character, t.line, t.character),
        }
      if (!s) return a
      const o = { range: O.to(s.range), type: VO.to(s.type) }
      return !o.range.contains(t) || e !== i.version ? a : o
    }
    createLanguageStatusItem(i, t, e) {
      const r = this.f++,
        s = this.a,
        a = this.g,
        o = `${i.identifier.value}/${t}`
      if (a.has(o))
        throw new Error(`LanguageStatusItem with id '${t}' ALREADY exists`)
      a.add(o)
      const c = {
        selector: e,
        id: t,
        name: i.displayName ?? i.name,
        severity: Fo.Information,
        command: void 0,
        text: "",
        detail: "",
        busy: !1,
      }
      let u
      const l = new bt(),
        m = () => {
          if ((u?.dispose(), !a.has(o))) {
            console.warn(
              `LanguageStatusItem (${t}) from ${i.identifier.value} has been disposed and CANNOT be updated anymore`,
            )
            return
          }
          u = pct(() => {
            l.clear(),
              this.a.$setLanguageStatus(r, {
                id: o,
                name: c.name ?? i.displayName ?? i.name,
                source: i.displayName ?? i.name,
                selector: ec.from(c.selector, this.e),
                label: c.text,
                detail: c.detail ?? "",
                severity:
                  c.severity === Fo.Error
                    ? ke.Error
                    : c.severity === Fo.Warning
                      ? ke.Warning
                      : ke.Info,
                command: c.command && this.d.toInternal(c.command, l),
                accessibilityInfo: c.accessibilityInformation,
                busy: c.busy,
              })
          }, 0)
        },
        h = {
          dispose() {
            l.dispose(), u?.dispose(), s.$removeLanguageStatus(r), a.delete(o)
          },
          get id() {
            return c.id
          },
          get name() {
            return c.name
          },
          set name(p) {
            ;(c.name = p), m()
          },
          get selector() {
            return c.selector
          },
          set selector(p) {
            ;(c.selector = p), m()
          },
          get text() {
            return c.text
          },
          set text(p) {
            ;(c.text = p), m()
          },
          set text2(p) {
            F(i, "languageStatusText"), (c.text = p), m()
          },
          get text2() {
            return F(i, "languageStatusText"), c.text
          },
          get detail() {
            return c.detail
          },
          set detail(p) {
            ;(c.detail = p), m()
          },
          get severity() {
            return c.severity
          },
          set severity(p) {
            ;(c.severity = p), m()
          },
          get accessibilityInformation() {
            return c.accessibilityInformation
          },
          set accessibilityInformation(p) {
            ;(c.accessibilityInformation = p), m()
          },
          get command() {
            return c.command
          },
          set command(p) {
            ;(c.command = p), m()
          },
          get busy() {
            return c.busy
          },
          set busy(p) {
            ;(c.busy = p), m()
          },
        }
      return m(), h
    }
  }
function NAt(i) {
  return i && i.title
}
var CM = class {
  constructor(t, e) {
    ;(this.b = e), (this.a = t.getProxy(z.MainThreadMessageService))
  }
  showMessage(t, e, r, s, a) {
    const o = {
      source: { identifier: t.identifier, label: t.displayName || t.name },
    }
    let c
    typeof s == "string" || NAt(s)
      ? (c = [s, ...a])
      : ((o.modal = s?.modal),
        (o.useCustom = s?.useCustom),
        (o.detail = s?.detail),
        (c = a)),
      o.useCustom && F(t, "resolvers")
    const u = []
    let l = !1
    for (let m = 0; m < c.length; m++) {
      const h = c[m]
      if (typeof h == "string")
        u.push({ title: h, handle: m, isCloseAffordance: !1 })
      else if (typeof h == "object") {
        const { title: p, isCloseAffordance: g } = h
        u.push({ title: p, isCloseAffordance: !!g, handle: m }),
          g &&
            (l
              ? this.b.warn(
                  `[${t.identifier}] Only one message item can have 'isCloseAffordance':`,
                  h,
                )
              : (l = !0))
      } else this.b.warn(`[${t.identifier}] Invalid message item:`, h)
    }
    return this.a.$showMessage(e, r, o, u).then((m) => {
      if (typeof m == "number") return c[m]
    })
  }
}
CM = __decorate([__param(1, Kt)], CM)
var LM = class {
    constructor(i, t, e, r) {
      ;(this.start = i),
        (this.deletedCount = t),
        (this.deletedItems = e),
        (this.items = r)
    }
    asApiEvent() {
      return {
        range: new $n(this.start, this.start + this.deletedCount),
        addedCells: this.items.map((i) => i.apiCell),
        removedCells: this.deletedItems,
      }
    }
  },
  RM = class {
    static asModelAddData(i) {
      return {
        EOL: i.eol,
        lines: i.source,
        languageId: i.language,
        uri: i.uri,
        isDirty: !1,
        versionId: 1,
      }
    }
    constructor(i, t, e) {
      ;(this.notebook = i),
        (this.h = t),
        (this.j = e),
        (this.handle = e.handle),
        (this.uri = S.revive(e.uri)),
        (this.cellKind = e.cellKind),
        (this.a = e.outputs.map(ks.to)),
        (this.e = e.internalMetadata ?? {}),
        (this.b = Object.freeze(e.metadata ?? {})),
        (this.d = Object.freeze(uc.to(e.internalMetadata ?? {})))
    }
    get internalMetadata() {
      return this.e
    }
    get apiCell() {
      if (!this.f) {
        const i = this,
          t = this.h.getDocument(this.uri)
        if (!t)
          throw new Error(
            `MISSING extHostDocument for notebook cell: ${this.uri}`,
          )
        const e = {
          get index() {
            return i.notebook.getCellIndex(i)
          },
          notebook: i.notebook.apiNotebook,
          kind: Ql.to(this.j.cellKind),
          document: t.document,
          get mime() {
            return i.g
          },
          set mime(r) {
            i.g = r
          },
          get outputs() {
            return i.a.slice(0)
          },
          get metadata() {
            return i.b
          },
          get executionSummary() {
            return i.d
          },
        }
        this.f = Object.freeze(e)
      }
      return this.f
    }
    setOutputs(i) {
      this.a = i.map(ks.to)
    }
    setOutputItems(i, t, e) {
      const r = e.map(lc.to),
        s = this.a.find((a) => a.id === i)
      if (
        s &&
        (t || (s.items.length = 0),
        s.items.push(...r),
        s.items.length > 1 && s.items.every((a) => wz(a.mime)))
      ) {
        const a = new Map(),
          o = []
        s.items.forEach((c) => {
          let u
          a.has(c.mime)
            ? (u = a.get(c.mime))
            : ((u = []), a.set(c.mime, u), o.push(c.mime)),
            u.push(c.data)
        }),
          (s.items.length = 0),
          o.forEach((c) => {
            const u = Qdt(a.get(c))
            s.items.push({ mime: c, data: u.data.buffer })
          })
      }
    }
    setMetadata(i) {
      this.b = Object.freeze(i)
    }
    setInternalMetadata(i) {
      ;(this.e = i), (this.d = Object.freeze(uc.to(i)))
    }
    setMime(i) {}
  },
  $At = class dst {
    static {
      this.a = 0
    }
    constructor(t, e, r, s, a) {
      ;(this.k = t),
        (this.l = e),
        (this.m = r),
        (this.uri = s),
        (this.handle = dst.a++),
        (this.b = []),
        (this.g = 0),
        (this.h = !1),
        (this.j = !1),
        (this.d = a.viewType),
        (this.f = Object.freeze(a.metadata ?? Object.create(null))),
        this.r([[0, 0, a.cells]], !0, void 0),
        (this.g = a.versionId)
    }
    dispose() {
      this.j = !0
    }
    get versionId() {
      return this.g
    }
    get apiNotebook() {
      if (!this.e) {
        const t = this,
          e = {
            get uri() {
              return t.uri
            },
            get version() {
              return t.g
            },
            get notebookType() {
              return t.d
            },
            get isDirty() {
              return t.h
            },
            get isUntitled() {
              return t.uri.scheme === Q.untitled
            },
            get isClosed() {
              return t.j
            },
            get metadata() {
              return t.f
            },
            get cellCount() {
              return t.b.length
            },
            cellAt(r) {
              return (r = t.n(r)), t.b[r].apiCell
            },
            getCells(r) {
              return (r ? t.p(r) : t.b).map((a) => a.apiCell)
            },
            save() {
              return t.q()
            },
            [Symbol.for("debug.description")]() {
              return `NotebookDocument(${this.uri.toString()})`
            },
          }
        this.e = Object.freeze(e)
      }
      return this.e
    }
    acceptDocumentPropertiesChanged(t) {
      t.metadata && (this.f = Object.freeze({ ...this.f, ...t.metadata }))
    }
    acceptDirty(t) {
      this.h = t
    }
    acceptModelChanged(t, e, r) {
      ;(this.g = t.versionId),
        (this.h = e),
        this.acceptDocumentPropertiesChanged({ metadata: r })
      const s = {
          notebook: this.apiNotebook,
          metadata: r,
          cellChanges: [],
          contentChanges: [],
        },
        a = []
      for (const c of t.rawEvents)
        c.kind === $r.ModelChange
          ? this.r(c.changes, !1, s.contentChanges)
          : c.kind === $r.Move
            ? this.s(c.index, c.length, c.newIdx, s.contentChanges)
            : c.kind === $r.Output
              ? (this.t(c.index, c.outputs),
                a.push({
                  cell: this.b[c.index].apiCell,
                  outputs: this.b[c.index].apiCell.outputs,
                }))
              : c.kind === $r.OutputItem
                ? (this.u(c.index, c.outputId, c.append, c.outputItems),
                  a.push({
                    cell: this.b[c.index].apiCell,
                    outputs: this.b[c.index].apiCell.outputs,
                  }))
                : c.kind === $r.ChangeCellLanguage
                  ? (this.v(c.index, c.language),
                    a.push({
                      cell: this.b[c.index].apiCell,
                      document: this.b[c.index].apiCell.document,
                    }))
                  : c.kind === $r.ChangeCellContent
                    ? a.push({
                        cell: this.b[c.index].apiCell,
                        document: this.b[c.index].apiCell.document,
                      })
                    : c.kind === $r.ChangeCellMime
                      ? this.w(c.index, c.mime)
                      : c.kind === $r.ChangeCellMetadata
                        ? (this.x(c.index, c.metadata),
                          a.push({
                            cell: this.b[c.index].apiCell,
                            metadata: this.b[c.index].apiCell.metadata,
                          }))
                        : c.kind === $r.ChangeCellInternalMetadata &&
                          (this.y(c.index, c.internalMetadata),
                          a.push({
                            cell: this.b[c.index].apiCell,
                            executionSummary:
                              this.b[c.index].apiCell.executionSummary,
                          }))
      const o = new Map()
      for (let c = 0; c < a.length; c++) {
        const u = a[c],
          l = o.get(u.cell)
        if (l === void 0) {
          const m = s.cellChanges.push({
            document: void 0,
            executionSummary: void 0,
            metadata: void 0,
            outputs: void 0,
            ...u,
          })
          o.set(u.cell, m - 1)
        } else s.cellChanges[l] = { ...s.cellChanges[l], ...u }
      }
      return (
        Object.freeze(s),
        Object.freeze(s.cellChanges),
        Object.freeze(s.contentChanges),
        s
      )
    }
    n(t) {
      return (t = t | 0), t < 0 ? 0 : t >= this.b.length ? this.b.length - 1 : t
    }
    o(t) {
      let e = t.start | 0,
        r = t.end | 0
      return (
        e < 0 && (e = 0),
        r > this.b.length && (r = this.b.length),
        t.with({ start: e, end: r })
      )
    }
    p(t) {
      t = this.o(t)
      const e = []
      for (let r = t.start; r < t.end; r++) e.push(this.b[r])
      return e
    }
    async q() {
      return this.j
        ? Promise.reject(new Error("Notebook has been closed"))
        : this.k.$trySaveNotebook(this.uri)
    }
    r(t, e, r) {
      if (this.j) return
      const s = [],
        a = [],
        o = []
      if (
        (t.reverse().forEach((c) => {
          const l = c[2].map((p) => {
              const g = new RM(this, this.l, p)
              return e || a.push(RM.asModelAddData(p)), g
            }),
            m = new LM(c[0], c[1], [], l),
            h = this.b.splice(c[0], c[1], ...l)
          for (const p of h) o.push(p.uri), m.deletedItems.push(p.apiCell)
          s.push(m)
        }),
        this.l.acceptDocumentsAndEditorsDelta({
          addedDocuments: a,
          removedDocuments: o,
        }),
        r)
      )
        for (const c of s) r.push(c.asApiEvent())
    }
    s(t, e, r, s) {
      const a = this.b.splice(t, e)
      this.b.splice(r, 0, ...a)
      const o = [
        new LM(
          t,
          e,
          a.map((c) => c.apiCell),
          [],
        ),
        new LM(r, 0, [], a),
      ]
      for (const c of o) s.push(c.asApiEvent())
    }
    t(t, e) {
      this.b[t].setOutputs(e)
    }
    u(t, e, r, s) {
      this.b[t].setOutputItems(e, r, s)
    }
    v(t, e) {
      const r = this.b[t]
      r.apiCell.document.languageId !== e &&
        this.m.$acceptModelLanguageChanged(r.uri, e)
    }
    w(t, e) {
      const r = this.b[t]
      r.apiCell.mime = e
    }
    x(t, e) {
      this.b[t].setMetadata(e)
    }
    y(t, e) {
      this.b[t].setInternalMetadata(e)
    }
    getCellFromApiCell(t) {
      return this.b.find((e) => e.apiCell === t)
    }
    getCellFromIndex(t) {
      return this.b[t]
    }
    getCell(t) {
      return this.b.find((e) => e.handle === t)
    }
    getCellIndex(t) {
      return this.b.indexOf(t)
    }
  },
  DM = class mst {
    static {
      this.apiEditorsToExtHost = new WeakMap()
    }
    constructor(t, e, r, s, a, o, c) {
      ;(this.id = t),
        (this.c = e),
        (this.notebookData = r),
        (this.d = s),
        (this.e = a),
        (this.f = o),
        (this.g = c),
        (this.a = !1)
    }
    get apiEditor() {
      if (!this.b) {
        const t = this
        ;(this.b = {
          get notebook() {
            return t.notebookData.apiNotebook
          },
          get selection() {
            return t.e[0]
          },
          set selection(e) {
            this.selections = [e]
          },
          get selections() {
            return t.e
          },
          set selections(e) {
            if (!Array.isArray(e) || !e.every($n.isNotebookRange))
              throw xt("selections")
            ;(t.e = e), t.h(e)
          },
          get visibleRanges() {
            return t.d
          },
          revealRange(e, r) {
            t.c.$tryRevealRange(t.id, an.from(e), r ?? A6.Default)
          },
          get viewColumn() {
            return t.f
          },
          get replOptions() {
            if (t.g === "repl")
              return { appendIndex: this.notebook.cellCount - 1 }
          },
          [Symbol.for("debug.description")]() {
            return `NotebookEditor(${this.notebook.uri.toString()})`
          },
        }),
          mst.apiEditorsToExtHost.set(this.b, this)
      }
      return this.b
    }
    get visible() {
      return this.a
    }
    _acceptVisibility(t) {
      this.a = t
    }
    _acceptVisibleRanges(t) {
      this.d = t
    }
    _acceptSelections(t) {
      this.e = t
    }
    h(t) {
      this.c.$trySetSelections(this.id, t.map(an.from))
    }
    _acceptViewColumn(t) {
      this.f = t
    }
  },
  FM = class {
    constructor(i, t) {
      ;(this.piece = i),
        (this.color = t),
        (this.size_left = 0),
        (this.lf_left = 0),
        (this.parent = this),
        (this.left = this),
        (this.right = this)
    }
    next() {
      if (this.right !== nt) return _M(this.right)
      let i = this
      for (; i.parent !== nt && i.parent.left !== i; ) i = i.parent
      return i.parent === nt ? nt : i.parent
    }
    prev() {
      if (this.left !== nt) return Irt(this.left)
      let i = this
      for (; i.parent !== nt && i.parent.right !== i; ) i = i.parent
      return i.parent === nt ? nt : i.parent
    }
    detach() {
      ;(this.parent = null), (this.left = null), (this.right = null)
    }
  },
  Ert
;(function (i) {
  ;(i[(i.Black = 0)] = "Black"), (i[(i.Red = 1)] = "Red")
})(Ert || (Ert = {}))
var nt = new FM(null, 0)
;(nt.parent = nt), (nt.left = nt), (nt.right = nt), (nt.color = 0)
function _M(i) {
  for (; i.left !== nt; ) i = i.left
  return i
}
function Irt(i) {
  for (; i.right !== nt; ) i = i.right
  return i
}
function AM(i) {
  return i === nt ? 0 : i.size_left + i.piece.length + AM(i.right)
}
function BM(i) {
  return i === nt ? 0 : i.lf_left + i.piece.lineFeedCnt + BM(i.right)
}
function OM() {
  nt.parent = nt
}
function Sh(i, t) {
  const e = t.right
  ;(e.size_left += t.size_left + (t.piece ? t.piece.length : 0)),
    (e.lf_left += t.lf_left + (t.piece ? t.piece.lineFeedCnt : 0)),
    (t.right = e.left),
    e.left !== nt && (e.left.parent = t),
    (e.parent = t.parent),
    t.parent === nt
      ? (i.root = e)
      : t.parent.left === t
        ? (t.parent.left = e)
        : (t.parent.right = e),
    (e.left = t),
    (t.parent = e)
}
function bh(i, t) {
  const e = t.left
  ;(t.left = e.right),
    e.right !== nt && (e.right.parent = t),
    (e.parent = t.parent),
    (t.size_left -= e.size_left + (e.piece ? e.piece.length : 0)),
    (t.lf_left -= e.lf_left + (e.piece ? e.piece.lineFeedCnt : 0)),
    t.parent === nt
      ? (i.root = e)
      : t === t.parent.right
        ? (t.parent.right = e)
        : (t.parent.left = e),
    (e.right = t),
    (t.parent = e)
}
function I8(i, t) {
  let e, r
  if (
    (t.left === nt
      ? ((r = t), (e = r.right))
      : t.right === nt
        ? ((r = t), (e = r.left))
        : ((r = _M(t.right)), (e = r.right)),
    r === i.root)
  ) {
    ;(i.root = e), (e.color = 0), t.detach(), OM(), (i.root.parent = nt)
    return
  }
  const s = r.color === 1
  if (
    (r === r.parent.left ? (r.parent.left = e) : (r.parent.right = e),
    r === t
      ? ((e.parent = r.parent), Eh(i, e))
      : (r.parent === t ? (e.parent = r) : (e.parent = r.parent),
        Eh(i, e),
        (r.left = t.left),
        (r.right = t.right),
        (r.parent = t.parent),
        (r.color = t.color),
        t === i.root
          ? (i.root = r)
          : t === t.parent.left
            ? (t.parent.left = r)
            : (t.parent.right = r),
        r.left !== nt && (r.left.parent = r),
        r.right !== nt && (r.right.parent = r),
        (r.size_left = t.size_left),
        (r.lf_left = t.lf_left),
        Eh(i, r)),
    t.detach(),
    e.parent.left === e)
  ) {
    const o = AM(e),
      c = BM(e)
    if (o !== e.parent.size_left || c !== e.parent.lf_left) {
      const u = o - e.parent.size_left,
        l = c - e.parent.lf_left
      ;(e.parent.size_left = o), (e.parent.lf_left = c), jn(i, e.parent, u, l)
    }
  }
  if ((Eh(i, e.parent), s)) {
    OM()
    return
  }
  let a
  for (; e !== i.root && e.color === 0; )
    e === e.parent.left
      ? ((a = e.parent.right),
        a.color === 1 &&
          ((a.color = 0),
          (e.parent.color = 1),
          Sh(i, e.parent),
          (a = e.parent.right)),
        a.left.color === 0 && a.right.color === 0
          ? ((a.color = 1), (e = e.parent))
          : (a.right.color === 0 &&
              ((a.left.color = 0),
              (a.color = 1),
              bh(i, a),
              (a = e.parent.right)),
            (a.color = e.parent.color),
            (e.parent.color = 0),
            (a.right.color = 0),
            Sh(i, e.parent),
            (e = i.root)))
      : ((a = e.parent.left),
        a.color === 1 &&
          ((a.color = 0),
          (e.parent.color = 1),
          bh(i, e.parent),
          (a = e.parent.left)),
        a.left.color === 0 && a.right.color === 0
          ? ((a.color = 1), (e = e.parent))
          : (a.left.color === 0 &&
              ((a.right.color = 0),
              (a.color = 1),
              Sh(i, a),
              (a = e.parent.left)),
            (a.color = e.parent.color),
            (e.parent.color = 0),
            (a.left.color = 0),
            bh(i, e.parent),
            (e = i.root)))
  ;(e.color = 0), OM()
}
function Prt(i, t) {
  for (Eh(i, t); t !== i.root && t.parent.color === 1; )
    if (t.parent === t.parent.parent.left) {
      const e = t.parent.parent.right
      e.color === 1
        ? ((t.parent.color = 0),
          (e.color = 0),
          (t.parent.parent.color = 1),
          (t = t.parent.parent))
        : (t === t.parent.right && ((t = t.parent), Sh(i, t)),
          (t.parent.color = 0),
          (t.parent.parent.color = 1),
          bh(i, t.parent.parent))
    } else {
      const e = t.parent.parent.left
      e.color === 1
        ? ((t.parent.color = 0),
          (e.color = 0),
          (t.parent.parent.color = 1),
          (t = t.parent.parent))
        : (t === t.parent.left && ((t = t.parent), bh(i, t)),
          (t.parent.color = 0),
          (t.parent.parent.color = 1),
          Sh(i, t.parent.parent))
    }
  i.root.color = 0
}
function jn(i, t, e, r) {
  for (; t !== i.root && t !== nt; )
    t.parent.left === t && ((t.parent.size_left += e), (t.parent.lf_left += r)),
      (t = t.parent)
}
function Eh(i, t) {
  let e = 0,
    r = 0
  if (t !== i.root) {
    for (; t !== i.root && t === t.parent.right; ) t = t.parent
    if (t !== i.root)
      for (
        t = t.parent,
          e = AM(t.left) - t.size_left,
          r = BM(t.left) - t.lf_left,
          t.size_left += e,
          t.lf_left += r;
        t !== i.root && (e !== 0 || r !== 0);

      )
        t.parent.left === t &&
          ((t.parent.size_left += e), (t.parent.lf_left += r)),
          (t = t.parent)
  }
}
var Vn = 65535
function Nrt(i) {
  let t
  return (
    i[i.length - 1] < 65536
      ? (t = new Uint16Array(i.length))
      : (t = new Uint32Array(i.length)),
    t.set(i, 0),
    t
  )
}
var xAt = class {
  constructor(i, t, e, r, s) {
    ;(this.lineStarts = i),
      (this.cr = t),
      (this.lf = e),
      (this.crlf = r),
      (this.isBasicASCII = s)
  }
}
function Gn(i, t = !0) {
  const e = [0]
  let r = 1
  for (let s = 0, a = i.length; s < a; s++) {
    const o = i.charCodeAt(s)
    o === 13
      ? s + 1 < a && i.charCodeAt(s + 1) === 10
        ? ((e[r++] = s + 2), s++)
        : (e[r++] = s + 1)
      : o === 10 && (e[r++] = s + 1)
  }
  return t ? Nrt(e) : e
}
function JAt(i, t) {
  ;(i.length = 0), (i[0] = 0)
  let e = 1,
    r = 0,
    s = 0,
    a = 0,
    o = !0
  for (let u = 0, l = t.length; u < l; u++) {
    const m = t.charCodeAt(u)
    m === 13
      ? u + 1 < l && t.charCodeAt(u + 1) === 10
        ? (a++, (i[e++] = u + 2), u++)
        : (r++, (i[e++] = u + 1))
      : m === 10
        ? (s++, (i[e++] = u + 1))
        : o && m !== 9 && (m < 32 || m > 126) && (o = !1)
  }
  const c = new xAt(Nrt(i), r, s, a, o)
  return (i.length = 0), c
}
var Ai = class {
    constructor(i, t, e, r, s) {
      ;(this.bufferIndex = i),
        (this.start = t),
        (this.end = e),
        (this.lineFeedCnt = r),
        (this.length = s)
    }
  },
  Ya = class {
    constructor(i, t) {
      ;(this.buffer = i), (this.lineStarts = t)
    }
  },
  CAt = class {
    constructor(i, t) {
      ;(this.a = []),
        (this.c = i),
        (this.d = t),
        (this.b = 0),
        i.root !== nt &&
          i.iterate(i.root, (e) => (e !== nt && this.a.push(e.piece), !0))
    }
    read() {
      return this.a.length === 0
        ? this.b === 0
          ? (this.b++, this.d)
          : null
        : this.b > this.a.length - 1
          ? null
          : this.b === 0
            ? this.d + this.c.getPieceContent(this.a[this.b++])
            : this.c.getPieceContent(this.a[this.b++])
    }
  },
  LAt = class {
    constructor(i) {
      ;(this.a = i), (this.b = [])
    }
    get(i) {
      for (let t = this.b.length - 1; t >= 0; t--) {
        const e = this.b[t]
        if (
          e.nodeStartOffset <= i &&
          e.nodeStartOffset + e.node.piece.length >= i
        )
          return e
      }
      return null
    }
    get2(i) {
      for (let t = this.b.length - 1; t >= 0; t--) {
        const e = this.b[t]
        if (
          e.nodeStartLineNumber &&
          e.nodeStartLineNumber < i &&
          e.nodeStartLineNumber + e.node.piece.lineFeedCnt >= i
        )
          return e
      }
      return null
    }
    set(i) {
      this.b.length >= this.a && this.b.shift(), this.b.push(i)
    }
    validate(i) {
      let t = !1
      const e = this.b
      for (let r = 0; r < e.length; r++) {
        const s = e[r]
        if (s.node.parent === null || s.nodeStartOffset >= i) {
          ;(e[r] = null), (t = !0)
          continue
        }
      }
      if (t) {
        const r = []
        for (const s of e) s !== null && r.push(s)
        this.b = r
      }
    }
  },
  RAt = class {
    constructor(i, t, e) {
      this.create(i, t, e)
    }
    create(i, t, e) {
      ;(this.a = [new Ya("", [0])]),
        (this.g = { line: 0, column: 0 }),
        (this.root = nt),
        (this.b = 1),
        (this.c = 0),
        (this.d = t),
        (this.e = t.length),
        (this.f = e)
      let r = null
      for (let s = 0, a = i.length; s < a; s++)
        if (i[s].buffer.length > 0) {
          i[s].lineStarts || (i[s].lineStarts = Gn(i[s].buffer))
          const o = new Ai(
            s + 1,
            { line: 0, column: 0 },
            {
              line: i[s].lineStarts.length - 1,
              column:
                i[s].buffer.length -
                i[s].lineStarts[i[s].lineStarts.length - 1],
            },
            i[s].lineStarts.length - 1,
            i[s].buffer.length,
          )
          this.a.push(i[s]), (r = this.S(r, o))
        }
      ;(this.h = new LAt(1)), (this.j = { lineNumber: 0, value: "" }), this.y()
    }
    normalizeEOL(i) {
      const t = Vn,
        e = t - Math.floor(t / 3),
        r = e * 2
      let s = "",
        a = 0
      const o = []
      if (
        (this.iterate(this.root, (c) => {
          const u = this.R(c),
            l = u.length
          if (a <= e || a + l < r) return (s += u), (a += l), !0
          const m = s.replace(/\r\n|\r|\n/g, i)
          return o.push(new Ya(m, Gn(m))), (s = u), (a = l), !0
        }),
        a > 0)
      ) {
        const c = s.replace(/\r\n|\r|\n/g, i)
        o.push(new Ya(c, Gn(c)))
      }
      this.create(o, i, !0)
    }
    getEOL() {
      return this.d
    }
    setEOL(i) {
      ;(this.d = i), (this.e = this.d.length), this.normalizeEOL(i)
    }
    createSnapshot(i) {
      return new CAt(this, i)
    }
    equal(i) {
      if (
        this.getLength() !== i.getLength() ||
        this.getLineCount() !== i.getLineCount()
      )
        return !1
      let t = 0
      return this.iterate(this.root, (r) => {
        if (r === nt) return !0
        const s = this.R(r),
          a = s.length,
          o = i.G(t),
          c = i.G(t + a),
          u = i.getValueInRange2(o, c)
        return (t += a), s === u
      })
    }
    getOffsetAt(i, t) {
      let e = 0,
        r = this.root
      for (; r !== nt; )
        if (r.left !== nt && r.lf_left + 1 >= i) r = r.left
        else if (r.lf_left + r.piece.lineFeedCnt + 1 >= i) {
          e += r.size_left
          const s = this.B(r, i - r.lf_left - 2)
          return (e += s + t - 1)
        } else
          (i -= r.lf_left + r.piece.lineFeedCnt),
            (e += r.size_left + r.piece.length),
            (r = r.right)
      return e
    }
    getPositionAt(i) {
      ;(i = Math.floor(i)), (i = Math.max(0, i))
      let t = this.root,
        e = 0
      const r = i
      for (; t !== nt; )
        if (t.size_left !== 0 && t.size_left >= i) t = t.left
        else if (t.size_left + t.piece.length >= i) {
          const s = this.A(t, i - t.size_left)
          if (((e += t.lf_left + s.index), s.index === 0)) {
            const a = this.getOffsetAt(e + 1, 1),
              o = r - a
            return new tr(e + 1, o + 1)
          }
          return new tr(e + 1, s.remainder + 1)
        } else if (
          ((i -= t.size_left + t.piece.length),
          (e += t.lf_left + t.piece.lineFeedCnt),
          t.right === nt)
        ) {
          const s = this.getOffsetAt(e + 1, 1),
            a = r - i - s
          return new tr(e + 1, a + 1)
        } else t = t.right
      return new tr(1, 1)
    }
    getValueInRange(i, t) {
      if (
        i.startLineNumber === i.endLineNumber &&
        i.startColumn === i.endColumn
      )
        return ""
      const e = this.H(i.startLineNumber, i.startColumn),
        r = this.H(i.endLineNumber, i.endColumn),
        s = this.getValueInRange2(e, r)
      return t
        ? t !== this.d || !this.f
          ? s.replace(/\r\n|\r|\n/g, t)
          : t === this.getEOL() && this.f
            ? s
            : s.replace(/\r\n|\r|\n/g, t)
        : s
    }
    getValueInRange2(i, t) {
      if (i.node === t.node) {
        const o = i.node,
          c = this.a[o.piece.bufferIndex].buffer,
          u = this.u(o.piece.bufferIndex, o.piece.start)
        return c.substring(u + i.remainder, u + t.remainder)
      }
      let e = i.node
      const r = this.a[e.piece.bufferIndex].buffer,
        s = this.u(e.piece.bufferIndex, e.piece.start)
      let a = r.substring(s + i.remainder, s + e.piece.length)
      for (e = e.next(); e !== nt; ) {
        const o = this.a[e.piece.bufferIndex].buffer,
          c = this.u(e.piece.bufferIndex, e.piece.start)
        if (e === t.node) {
          a += o.substring(c, c + t.remainder)
          break
        } else a += o.substr(c, e.piece.length)
        e = e.next()
      }
      return a
    }
    getLinesContent() {
      const i = []
      let t = 0,
        e = "",
        r = !1
      return (
        this.iterate(this.root, (s) => {
          if (s === nt) return !0
          const a = s.piece
          let o = a.length
          if (o === 0) return !0
          const c = this.a[a.bufferIndex].buffer,
            u = this.a[a.bufferIndex].lineStarts,
            l = a.start.line,
            m = a.end.line
          let h = u[l] + a.start.column
          if (
            r &&
            (c.charCodeAt(h) === 10 && (h++, o--),
            (i[t++] = e),
            (e = ""),
            (r = !1),
            o === 0)
          )
            return !0
          if (l === m)
            return (
              !this.f && c.charCodeAt(h + o - 1) === 13
                ? ((r = !0), (e += c.substr(h, o - 1)))
                : (e += c.substr(h, o)),
              !0
            )
          ;(e += this.f
            ? c.substring(h, Math.max(h, u[l + 1] - this.e))
            : c.substring(h, u[l + 1]).replace(/(\r\n|\r|\n)$/, "")),
            (i[t++] = e)
          for (let p = l + 1; p < m; p++)
            (e = this.f
              ? c.substring(u[p], u[p + 1] - this.e)
              : c.substring(u[p], u[p + 1]).replace(/(\r\n|\r|\n)$/, "")),
              (i[t++] = e)
          return (
            !this.f && c.charCodeAt(u[m] + a.end.column - 1) === 13
              ? ((r = !0),
                a.end.column === 0
                  ? t--
                  : (e = c.substr(u[m], a.end.column - 1)))
              : (e = c.substr(u[m], a.end.column)),
            !0
          )
        }),
        r && ((i[t++] = e), (e = "")),
        (i[t++] = e),
        i
      )
    }
    getLength() {
      return this.c
    }
    getLineCount() {
      return this.b
    }
    getLineContent(i) {
      return this.j.lineNumber === i
        ? this.j.value
        : ((this.j.lineNumber = i),
          i === this.b
            ? (this.j.value = this.getLineRawContent(i))
            : this.f
              ? (this.j.value = this.getLineRawContent(i, this.e))
              : (this.j.value = this.getLineRawContent(i).replace(
                  /(\r\n|\r|\n)$/,
                  "",
                )),
          this.j.value)
    }
    l(i) {
      if (i.remainder === i.node.piece.length) {
        const t = i.node.next()
        if (!t) return 0
        const e = this.a[t.piece.bufferIndex],
          r = this.u(t.piece.bufferIndex, t.piece.start)
        return e.buffer.charCodeAt(r)
      } else {
        const t = this.a[i.node.piece.bufferIndex],
          r = this.u(i.node.piece.bufferIndex, i.node.piece.start) + i.remainder
        return t.buffer.charCodeAt(r)
      }
    }
    getLineCharCode(i, t) {
      const e = this.H(i, t + 1)
      return this.l(e)
    }
    getLineLength(i) {
      if (i === this.getLineCount()) {
        const t = this.getOffsetAt(i, 1)
        return this.getLength() - t
      }
      return this.getOffsetAt(i + 1, 1) - this.getOffsetAt(i, 1) - this.e
    }
    getCharCode(i) {
      const t = this.G(i)
      return this.l(t)
    }
    getNearestChunk(i) {
      const t = this.G(i)
      if (t.remainder === t.node.piece.length) {
        const e = t.node.next()
        if (!e || e === nt) return ""
        const r = this.a[e.piece.bufferIndex],
          s = this.u(e.piece.bufferIndex, e.piece.start)
        return r.buffer.substring(s, s + e.piece.length)
      } else {
        const e = this.a[t.node.piece.bufferIndex],
          r = this.u(t.node.piece.bufferIndex, t.node.piece.start),
          s = r + t.remainder,
          a = r + t.node.piece.length
        return e.buffer.substring(s, a)
      }
    }
    findMatchesInNode(i, t, e, r, s, a, o, c, u, l, m) {
      const h = this.a[i.piece.bufferIndex],
        p = this.u(i.piece.bufferIndex, i.piece.start),
        g = this.u(i.piece.bufferIndex, s),
        w = this.u(i.piece.bufferIndex, a)
      let T
      const b = { line: 0, column: 0 }
      let N, $
      t._wordSeparators
        ? ((N = h.buffer.substring(g, w)), ($ = (L) => L + g), t.reset(0))
        : ((N = h.buffer), ($ = (L) => L), t.reset(g))
      do
        if (((T = t.next(N)), T)) {
          if ($(T.index) >= w) return l
          this.s(i, $(T.index) - p, b)
          const L = this.t(i.piece.bufferIndex, s, b),
            U = b.line === s.line ? b.column - s.column + r : b.column + 1,
            q = U + T[0].length
          if (
            ((m[l++] = XX(new re(e + L, U, e + L, q), T, c)),
            $(T.index) + T[0].length >= w || l >= u)
          )
            return l
        }
      while (T)
      return l
    }
    findMatchesLineByLine(i, t, e, r) {
      const s = []
      let a = 0
      const o = new n1t(t.wordSeparators, t.regex)
      let c = this.H(i.startLineNumber, i.startColumn)
      if (c === null) return []
      const u = this.H(i.endLineNumber, i.endColumn)
      if (u === null) return []
      let l = this.s(c.node, c.remainder)
      const m = this.s(u.node, u.remainder)
      if (c.node === u.node)
        return (
          this.findMatchesInNode(
            c.node,
            o,
            i.startLineNumber,
            i.startColumn,
            l,
            m,
            t,
            e,
            r,
            a,
            s,
          ),
          s
        )
      let h = i.startLineNumber,
        p = c.node
      for (; p !== u.node; ) {
        const w = this.t(p.piece.bufferIndex, l, p.piece.end)
        if (w >= 1) {
          const b = this.a[p.piece.bufferIndex].lineStarts,
            N = this.u(p.piece.bufferIndex, p.piece.start),
            $ = b[l.line + w],
            L = h === i.startLineNumber ? i.startColumn : 1
          if (
            ((a = this.findMatchesInNode(
              p,
              o,
              h,
              L,
              l,
              this.s(p, $ - N),
              t,
              e,
              r,
              a,
              s,
            )),
            a >= r)
          )
            return s
          h += w
        }
        const T = h === i.startLineNumber ? i.startColumn - 1 : 0
        if (h === i.endLineNumber) {
          const b = this.getLineContent(h).substring(T, i.endColumn - 1)
          return (a = this.n(t, o, b, i.endLineNumber, T, a, s, e, r)), s
        }
        if (
          ((a = this.n(
            t,
            o,
            this.getLineContent(h).substr(T),
            h,
            T,
            a,
            s,
            e,
            r,
          )),
          a >= r)
        )
          return s
        h++, (c = this.H(h, 1)), (p = c.node), (l = this.s(c.node, c.remainder))
      }
      if (h === i.endLineNumber) {
        const w = h === i.startLineNumber ? i.startColumn - 1 : 0,
          T = this.getLineContent(h).substring(w, i.endColumn - 1)
        return (a = this.n(t, o, T, i.endLineNumber, w, a, s, e, r)), s
      }
      const g = h === i.startLineNumber ? i.startColumn : 1
      return (
        (a = this.findMatchesInNode(u.node, o, h, g, l, m, t, e, r, a, s)), s
      )
    }
    n(i, t, e, r, s, a, o, c, u) {
      const l = i.wordSeparators
      if (!c && i.simpleSearch) {
        const h = i.simpleSearch,
          p = h.length,
          g = e.length
        let w = -p
        for (; (w = e.indexOf(h, w + p)) !== -1; )
          if (
            (!l || KX(l, e, g, w, p)) &&
            ((o[a++] = new R2(new re(r, w + 1 + s, r, w + 1 + p + s), null)),
            a >= u)
          )
            return a
        return a
      }
      let m
      t.reset(0)
      do
        if (
          ((m = t.next(e)),
          m &&
            ((o[a++] = XX(
              new re(r, m.index + 1 + s, r, m.index + 1 + m[0].length + s),
              m,
              c,
            )),
            a >= u))
        )
          return a
      while (m)
      return a
    }
    insert(i, t, e = !1) {
      if (
        ((this.f = this.f && e),
        (this.j.lineNumber = 0),
        (this.j.value = ""),
        this.root !== nt)
      ) {
        const { node: r, remainder: s, nodeStartOffset: a } = this.G(i),
          o = r.piece,
          c = o.bufferIndex,
          u = this.s(r, s)
        if (
          r.piece.bufferIndex === 0 &&
          o.end.line === this.g.line &&
          o.end.column === this.g.column &&
          a + o.length === i &&
          t.length < Vn
        ) {
          this.F(r, t), this.y()
          return
        }
        if (a === i) this.o(t, r), this.h.validate(i)
        else if (a + r.piece.length > i) {
          const l = []
          let m = new Ai(
            o.bufferIndex,
            u,
            o.end,
            this.t(o.bufferIndex, u, o.end),
            this.u(c, o.end) - this.u(c, u),
          )
          if (this.K() && this.M(t) && this.I(r, s) === 10) {
            const w = { line: m.start.line + 1, column: 0 }
            ;(m = new Ai(
              m.bufferIndex,
              w,
              m.end,
              this.t(m.bufferIndex, w, m.end),
              m.length - 1,
            )),
              (t += `
`)
          }
          if (this.K() && this.L(t))
            if (this.I(r, s - 1) === 13) {
              const w = this.s(r, s - 1)
              this.C(r, w), (t = "\r" + t), r.piece.length === 0 && l.push(r)
            } else this.C(r, u)
          else this.C(r, u)
          const h = this.w(t)
          m.length > 0 && this.S(r, m)
          let p = r
          for (let g = 0; g < h.length; g++) p = this.S(p, h[g])
          this.v(l)
        } else this.q(t, r)
      } else {
        const r = this.w(t)
        let s = this.T(null, r[0])
        for (let a = 1; a < r.length; a++) s = this.S(s, r[a])
      }
      this.y()
    }
    delete(i, t) {
      if (
        ((this.j.lineNumber = 0),
        (this.j.value = ""),
        t <= 0 || this.root === nt)
      )
        return
      const e = this.G(i),
        r = this.G(i + t),
        s = e.node,
        a = r.node
      if (s === a) {
        const h = this.s(s, e.remainder),
          p = this.s(s, r.remainder)
        if (e.nodeStartOffset === i) {
          if (t === s.piece.length) {
            const g = s.next()
            I8(this, s), this.N(g), this.y()
            return
          }
          this.D(s, p), this.h.validate(i), this.N(s), this.y()
          return
        }
        if (e.nodeStartOffset + s.piece.length === i + t) {
          this.C(s, h), this.O(s), this.y()
          return
        }
        this.E(s, h, p), this.y()
        return
      }
      const o = [],
        c = this.s(s, e.remainder)
      this.C(s, c), this.h.validate(i), s.piece.length === 0 && o.push(s)
      const u = this.s(a, r.remainder)
      this.D(a, u), a.piece.length === 0 && o.push(a)
      const l = s.next()
      for (let h = l; h !== nt && h !== a; h = h.next()) o.push(h)
      const m = s.piece.length === 0 ? s.prev() : s
      this.v(o), this.O(m), this.y()
    }
    o(i, t) {
      const e = []
      if (this.K() && this.M(i) && this.L(t)) {
        const a = t.piece,
          o = { line: a.start.line + 1, column: 0 },
          c = new Ai(
            a.bufferIndex,
            o,
            a.end,
            this.t(a.bufferIndex, o, a.end),
            a.length - 1,
          )
        ;(t.piece = c),
          (i += `
`),
          jn(this, t, -1, -1),
          t.piece.length === 0 && e.push(t)
      }
      const r = this.w(i)
      let s = this.T(t, r[r.length - 1])
      for (let a = r.length - 2; a >= 0; a--) s = this.T(s, r[a])
      this.N(s), this.v(e)
    }
    q(i, t) {
      this.Q(i, t) &&
        (i += `
`)
      const e = this.w(i),
        r = this.S(t, e[0])
      let s = r
      for (let a = 1; a < e.length; a++) s = this.S(s, e[a])
      this.N(r)
    }
    s(i, t, e) {
      const r = i.piece,
        s = i.piece.bufferIndex,
        a = this.a[s].lineStarts,
        c = a[r.start.line] + r.start.column + t
      let u = r.start.line,
        l = r.end.line,
        m = 0,
        h = 0,
        p = 0
      for (; u <= l && ((m = (u + (l - u) / 2) | 0), (p = a[m]), m !== l); )
        if (((h = a[m + 1]), c < p)) l = m - 1
        else if (c >= h) u = m + 1
        else break
      return e
        ? ((e.line = m), (e.column = c - p), null)
        : { line: m, column: c - p }
    }
    t(i, t, e) {
      if (e.column === 0) return e.line - t.line
      const r = this.a[i].lineStarts
      if (e.line === r.length - 1) return e.line - t.line
      const s = r[e.line + 1],
        a = r[e.line] + e.column
      if (s > a + 1) return e.line - t.line
      const o = a - 1
      return this.a[i].buffer.charCodeAt(o) === 13
        ? e.line - t.line + 1
        : e.line - t.line
    }
    u(i, t) {
      return this.a[i].lineStarts[t.line] + t.column
    }
    v(i) {
      for (let t = 0; t < i.length; t++) I8(this, i[t])
    }
    w(i) {
      if (i.length > Vn) {
        const l = []
        for (; i.length > Vn; ) {
          const h = i.charCodeAt(Vn - 1)
          let p
          h === 13 || (h >= 55296 && h <= 56319)
            ? ((p = i.substring(0, Vn - 1)), (i = i.substring(Vn - 1)))
            : ((p = i.substring(0, Vn)), (i = i.substring(Vn)))
          const g = Gn(p)
          l.push(
            new Ai(
              this.a.length,
              { line: 0, column: 0 },
              { line: g.length - 1, column: p.length - g[g.length - 1] },
              g.length - 1,
              p.length,
            ),
          ),
            this.a.push(new Ya(p, g))
        }
        const m = Gn(i)
        return (
          l.push(
            new Ai(
              this.a.length,
              { line: 0, column: 0 },
              { line: m.length - 1, column: i.length - m[m.length - 1] },
              m.length - 1,
              i.length,
            ),
          ),
          this.a.push(new Ya(i, m)),
          l
        )
      }
      let t = this.a[0].buffer.length
      const e = Gn(i, !1)
      let r = this.g
      if (
        this.a[0].lineStarts[this.a[0].lineStarts.length - 1] === t &&
        t !== 0 &&
        this.L(i) &&
        this.M(this.a[0].buffer)
      ) {
        ;(this.g = { line: this.g.line, column: this.g.column + 1 }),
          (r = this.g)
        for (let l = 0; l < e.length; l++) e[l] += t + 1
        ;(this.a[0].lineStarts = this.a[0].lineStarts.concat(e.slice(1))),
          (this.a[0].buffer += "_" + i),
          (t += 1)
      } else {
        if (t !== 0) for (let l = 0; l < e.length; l++) e[l] += t
        ;(this.a[0].lineStarts = this.a[0].lineStarts.concat(e.slice(1))),
          (this.a[0].buffer += i)
      }
      const s = this.a[0].buffer.length,
        a = this.a[0].lineStarts.length - 1,
        o = s - this.a[0].lineStarts[a],
        c = { line: a, column: o },
        u = new Ai(0, r, c, this.t(0, r, c), s - t)
      return (this.g = c), [u]
    }
    getLinesRawContent() {
      return this.U(this.root)
    }
    getLineRawContent(i, t = 0) {
      let e = this.root,
        r = ""
      const s = this.h.get2(i)
      if (s) {
        e = s.node
        const a = this.B(e, i - s.nodeStartLineNumber - 1),
          o = this.a[e.piece.bufferIndex].buffer,
          c = this.u(e.piece.bufferIndex, e.piece.start)
        if (s.nodeStartLineNumber + e.piece.lineFeedCnt === i)
          r = o.substring(c + a, c + e.piece.length)
        else {
          const u = this.B(e, i - s.nodeStartLineNumber)
          return o.substring(c + a, c + u - t)
        }
      } else {
        let a = 0
        const o = i
        for (; e !== nt; )
          if (e.left !== nt && e.lf_left >= i - 1) e = e.left
          else if (e.lf_left + e.piece.lineFeedCnt > i - 1) {
            const c = this.B(e, i - e.lf_left - 2),
              u = this.B(e, i - e.lf_left - 1),
              l = this.a[e.piece.bufferIndex].buffer,
              m = this.u(e.piece.bufferIndex, e.piece.start)
            return (
              (a += e.size_left),
              this.h.set({
                node: e,
                nodeStartOffset: a,
                nodeStartLineNumber: o - (i - 1 - e.lf_left),
              }),
              l.substring(m + c, m + u - t)
            )
          } else if (e.lf_left + e.piece.lineFeedCnt === i - 1) {
            const c = this.B(e, i - e.lf_left - 2),
              u = this.a[e.piece.bufferIndex].buffer,
              l = this.u(e.piece.bufferIndex, e.piece.start)
            r = u.substring(l + c, l + e.piece.length)
            break
          } else
            (i -= e.lf_left + e.piece.lineFeedCnt),
              (a += e.size_left + e.piece.length),
              (e = e.right)
      }
      for (e = e.next(); e !== nt; ) {
        const a = this.a[e.piece.bufferIndex].buffer
        if (e.piece.lineFeedCnt > 0) {
          const o = this.B(e, 0),
            c = this.u(e.piece.bufferIndex, e.piece.start)
          return (r += a.substring(c, c + o - t)), r
        } else {
          const o = this.u(e.piece.bufferIndex, e.piece.start)
          r += a.substr(o, e.piece.length)
        }
        e = e.next()
      }
      return r
    }
    y() {
      let i = this.root,
        t = 1,
        e = 0
      for (; i !== nt; )
        (t += i.lf_left + i.piece.lineFeedCnt),
          (e += i.size_left + i.piece.length),
          (i = i.right)
      ;(this.b = t), (this.c = e), this.h.validate(this.c)
    }
    A(i, t) {
      const e = i.piece,
        r = this.s(i, t),
        s = r.line - e.start.line
      if (this.u(e.bufferIndex, e.end) - this.u(e.bufferIndex, e.start) === t) {
        const a = this.t(i.piece.bufferIndex, e.start, r)
        if (a !== s) return { index: a, remainder: 0 }
      }
      return { index: s, remainder: r.column }
    }
    B(i, t) {
      if (t < 0) return 0
      const e = i.piece,
        r = this.a[e.bufferIndex].lineStarts,
        s = e.start.line + t + 1
      return s > e.end.line
        ? r[e.end.line] + e.end.column - r[e.start.line] - e.start.column
        : r[s] - r[e.start.line] - e.start.column
    }
    C(i, t) {
      const e = i.piece,
        r = e.lineFeedCnt,
        s = this.u(e.bufferIndex, e.end),
        a = t,
        o = this.u(e.bufferIndex, a),
        c = this.t(e.bufferIndex, e.start, a),
        u = c - r,
        l = o - s,
        m = e.length + l
      ;(i.piece = new Ai(e.bufferIndex, e.start, a, c, m)), jn(this, i, l, u)
    }
    D(i, t) {
      const e = i.piece,
        r = e.lineFeedCnt,
        s = this.u(e.bufferIndex, e.start),
        a = t,
        o = this.t(e.bufferIndex, a, e.end),
        c = this.u(e.bufferIndex, a),
        u = o - r,
        l = s - c,
        m = e.length + l
      ;(i.piece = new Ai(e.bufferIndex, a, e.end, o, m)), jn(this, i, l, u)
    }
    E(i, t, e) {
      const r = i.piece,
        s = r.start,
        a = r.end,
        o = r.length,
        c = r.lineFeedCnt,
        u = t,
        l = this.t(r.bufferIndex, r.start, u),
        m = this.u(r.bufferIndex, t) - this.u(r.bufferIndex, s)
      ;(i.piece = new Ai(r.bufferIndex, r.start, u, l, m)),
        jn(this, i, m - o, l - c)
      const h = new Ai(
          r.bufferIndex,
          e,
          a,
          this.t(r.bufferIndex, e, a),
          this.u(r.bufferIndex, a) - this.u(r.bufferIndex, e),
        ),
        p = this.S(i, h)
      this.N(p)
    }
    F(i, t) {
      this.Q(t, i) &&
        (t += `
`)
      const e = this.K() && this.L(t) && this.M(i),
        r = this.a[0].buffer.length
      this.a[0].buffer += t
      const s = Gn(t, !1)
      for (let p = 0; p < s.length; p++) s[p] += r
      if (e) {
        const p = this.a[0].lineStarts[this.a[0].lineStarts.length - 2]
        this.a[0].lineStarts.pop(),
          (this.g = { line: this.g.line - 1, column: r - p })
      }
      this.a[0].lineStarts = this.a[0].lineStarts.concat(s.slice(1))
      const a = this.a[0].lineStarts.length - 1,
        o = this.a[0].buffer.length - this.a[0].lineStarts[a],
        c = { line: a, column: o },
        u = i.piece.length + t.length,
        l = i.piece.lineFeedCnt,
        m = this.t(0, i.piece.start, c),
        h = m - l
      ;(i.piece = new Ai(i.piece.bufferIndex, i.piece.start, c, m, u)),
        (this.g = c),
        jn(this, i, t.length, h)
    }
    G(i) {
      let t = this.root
      const e = this.h.get(i)
      if (e)
        return {
          node: e.node,
          nodeStartOffset: e.nodeStartOffset,
          remainder: i - e.nodeStartOffset,
        }
      let r = 0
      for (; t !== nt; )
        if (t.size_left > i) t = t.left
        else if (t.size_left + t.piece.length >= i) {
          r += t.size_left
          const s = { node: t, remainder: i - t.size_left, nodeStartOffset: r }
          return this.h.set(s), s
        } else
          (i -= t.size_left + t.piece.length),
            (r += t.size_left + t.piece.length),
            (t = t.right)
      return null
    }
    H(i, t) {
      let e = this.root,
        r = 0
      for (; e !== nt; )
        if (e.left !== nt && e.lf_left >= i - 1) e = e.left
        else if (e.lf_left + e.piece.lineFeedCnt > i - 1) {
          const s = this.B(e, i - e.lf_left - 2),
            a = this.B(e, i - e.lf_left - 1)
          return (
            (r += e.size_left),
            { node: e, remainder: Math.min(s + t - 1, a), nodeStartOffset: r }
          )
        } else if (e.lf_left + e.piece.lineFeedCnt === i - 1) {
          const s = this.B(e, i - e.lf_left - 2)
          if (s + t - 1 <= e.piece.length)
            return { node: e, remainder: s + t - 1, nodeStartOffset: r }
          t -= e.piece.length - s
          break
        } else
          (i -= e.lf_left + e.piece.lineFeedCnt),
            (r += e.size_left + e.piece.length),
            (e = e.right)
      for (e = e.next(); e !== nt; ) {
        if (e.piece.lineFeedCnt > 0) {
          const s = this.B(e, 0),
            a = this.J(e)
          return { node: e, remainder: Math.min(t - 1, s), nodeStartOffset: a }
        } else if (e.piece.length >= t - 1) {
          const s = this.J(e)
          return { node: e, remainder: t - 1, nodeStartOffset: s }
        } else t -= e.piece.length
        e = e.next()
      }
      return null
    }
    I(i, t) {
      if (i.piece.lineFeedCnt < 1) return -1
      const e = this.a[i.piece.bufferIndex],
        r = this.u(i.piece.bufferIndex, i.piece.start) + t
      return e.buffer.charCodeAt(r)
    }
    J(i) {
      if (!i) return 0
      let t = i.size_left
      for (; i !== this.root; )
        i.parent.right === i &&
          (t += i.parent.size_left + i.parent.piece.length),
          (i = i.parent)
      return t
    }
    K() {
      return !(
        this.f &&
        this.d ===
          `
`
      )
    }
    L(i) {
      if (typeof i == "string") return i.charCodeAt(0) === 10
      if (i === nt || i.piece.lineFeedCnt === 0) return !1
      const t = i.piece,
        e = this.a[t.bufferIndex].lineStarts,
        r = t.start.line,
        s = e[r] + t.start.column
      return r === e.length - 1 || e[r + 1] > s + 1
        ? !1
        : this.a[t.bufferIndex].buffer.charCodeAt(s) === 10
    }
    M(i) {
      return typeof i == "string"
        ? i.charCodeAt(i.length - 1) === 13
        : i === nt || i.piece.lineFeedCnt === 0
          ? !1
          : this.I(i, i.piece.length - 1) === 13
    }
    N(i) {
      if (this.K() && this.L(i)) {
        const t = i.prev()
        this.M(t) && this.P(t, i)
      }
    }
    O(i) {
      if (this.K() && this.M(i)) {
        const t = i.next()
        this.L(t) && this.P(i, t)
      }
    }
    P(i, t) {
      const e = [],
        r = this.a[i.piece.bufferIndex].lineStarts
      let s
      i.piece.end.column === 0
        ? (s = {
            line: i.piece.end.line - 1,
            column: r[i.piece.end.line] - r[i.piece.end.line - 1] - 1,
          })
        : (s = { line: i.piece.end.line, column: i.piece.end.column - 1 })
      const a = i.piece.length - 1,
        o = i.piece.lineFeedCnt - 1
      ;(i.piece = new Ai(i.piece.bufferIndex, i.piece.start, s, o, a)),
        jn(this, i, -1, -1),
        i.piece.length === 0 && e.push(i)
      const c = { line: t.piece.start.line + 1, column: 0 },
        u = t.piece.length - 1,
        l = this.t(t.piece.bufferIndex, c, t.piece.end)
      ;(t.piece = new Ai(t.piece.bufferIndex, c, t.piece.end, l, u)),
        jn(this, t, -1, -1),
        t.piece.length === 0 && e.push(t)
      const m = this.w(`\r
`)
      this.S(i, m[0])
      for (let h = 0; h < e.length; h++) I8(this, e[h])
    }
    Q(i, t) {
      if (this.K() && this.M(i)) {
        const e = t.next()
        if (this.L(e)) {
          if (
            ((i += `
`),
            e.piece.length === 1)
          )
            I8(this, e)
          else {
            const r = e.piece,
              s = { line: r.start.line + 1, column: 0 },
              a = r.length - 1,
              o = this.t(r.bufferIndex, s, r.end)
            ;(e.piece = new Ai(r.bufferIndex, s, r.end, o, a)),
              jn(this, e, -1, -1)
          }
          return !0
        }
      }
      return !1
    }
    iterate(i, t) {
      if (i === nt) return t(nt)
      const e = this.iterate(i.left, t)
      return e && t(i) && this.iterate(i.right, t)
    }
    R(i) {
      if (i === nt) return ""
      const t = this.a[i.piece.bufferIndex],
        e = i.piece,
        r = this.u(e.bufferIndex, e.start),
        s = this.u(e.bufferIndex, e.end)
      return t.buffer.substring(r, s)
    }
    getPieceContent(i) {
      const t = this.a[i.bufferIndex],
        e = this.u(i.bufferIndex, i.start),
        r = this.u(i.bufferIndex, i.end)
      return t.buffer.substring(e, r)
    }
    S(i, t) {
      const e = new FM(t, 1)
      if (
        ((e.left = nt),
        (e.right = nt),
        (e.parent = nt),
        (e.size_left = 0),
        (e.lf_left = 0),
        this.root === nt)
      )
        (this.root = e), (e.color = 0)
      else if (i.right === nt) (i.right = e), (e.parent = i)
      else {
        const s = _M(i.right)
        ;(s.left = e), (e.parent = s)
      }
      return Prt(this, e), e
    }
    T(i, t) {
      const e = new FM(t, 1)
      if (
        ((e.left = nt),
        (e.right = nt),
        (e.parent = nt),
        (e.size_left = 0),
        (e.lf_left = 0),
        this.root === nt)
      )
        (this.root = e), (e.color = 0)
      else if (i.left === nt) (i.left = e), (e.parent = i)
      else {
        const r = Irt(i.left)
        ;(r.right = e), (e.parent = r)
      }
      return Prt(this, e), e
    }
    U(i) {
      let t = ""
      return this.iterate(i, (e) => ((t += this.R(e)), !0)), t
    }
  },
  $rt
;(function (i) {
  ;(i[(i.Unknown = 0)] = "Unknown"),
    (i[(i.Invalid = 3)] = "Invalid"),
    (i[(i.LF = 1)] = "LF"),
    (i[(i.CRLF = 2)] = "CRLF")
})($rt || ($rt = {}))
function qM(i) {
  let t = 0,
    e = 0,
    r = 0,
    s = 0
  for (let a = 0, o = i.length; a < o; a++) {
    const c = i.charCodeAt(a)
    c === 13
      ? (t === 0 && (e = a),
        t++,
        a + 1 < o && i.charCodeAt(a + 1) === 10 ? ((s |= 2), a++) : (s |= 3),
        (r = a + 1))
      : c === 10 && ((s |= 1), t === 0 && (e = a), t++, (r = a + 1))
  }
  return t === 0 && (e = i.length), [t, e, i.length - r, s]
}
var UM
function DAt() {
  return UM || (UM = new TextDecoder("UTF-16LE")), UM
}
function FAt(i, t, e) {
  const r = new Uint16Array(i.buffer, t, e)
  return e > 0 && (r[0] === 65279 || r[0] === 65534)
    ? _At(i, t, e)
    : DAt().decode(r)
}
function _At(i, t, e) {
  const r = []
  let s = 0
  for (let a = 0; a < e; a++) {
    const o = gat(i, t)
    ;(t += 2), (r[s++] = String.fromCharCode(o))
  }
  return r.join("")
}
function P8(i) {
  return i.replace(/\n/g, "\\n").replace(/\r/g, "\\r")
}
var AAt = class Vr {
    get oldLength() {
      return this.oldText.length
    }
    get oldEnd() {
      return this.oldPosition + this.oldText.length
    }
    get newLength() {
      return this.newText.length
    }
    get newEnd() {
      return this.newPosition + this.newText.length
    }
    constructor(t, e, r, s) {
      ;(this.oldPosition = t),
        (this.oldText = e),
        (this.newPosition = r),
        (this.newText = s)
    }
    shift(t) {
      return new Vr(
        this.oldPosition + t,
        this.oldText,
        this.newPosition + t,
        this.newText,
      )
    }
    toString() {
      return this.oldText.length === 0
        ? `(insert@${this.oldPosition} "${P8(this.newText)}")`
        : this.newText.length === 0
          ? `(delete@${this.oldPosition} "${P8(this.oldText)}")`
          : `(replace@${this.oldPosition} "${P8(this.oldText)}" with "${P8(this.newText)}")`
    }
    static a(t) {
      return 4 + 2 * t.length
    }
    static c(t, e, r) {
      const s = e.length
      WF(t, s, r), (r += 4)
      for (let a = 0; a < s; a++) vat(t, e.charCodeAt(a), r), (r += 2)
      return r
    }
    static d(t, e) {
      const r = HF(t, e)
      return (e += 4), FAt(t, e, r)
    }
    writeSize() {
      return 8 + Vr.a(this.oldText) + Vr.a(this.newText)
    }
    write(t, e) {
      return (
        WF(t, this.oldPosition, e),
        (e += 4),
        WF(t, this.newPosition, e),
        (e += 4),
        (e = Vr.c(t, this.oldText, e)),
        (e = Vr.c(t, this.newText, e)),
        e
      )
    }
    static read(t, e, r) {
      const s = HF(t, e)
      e += 4
      const a = HF(t, e)
      e += 4
      const o = Vr.d(t, e)
      e += Vr.a(o)
      const c = Vr.d(t, e)
      return (e += Vr.a(c)), r.push(new Vr(s, o, a, c)), e
    }
  },
  BAt = class RF extends dt {
    constructor(t, e, r, s, a, o, c) {
      super(),
        (this.m = this.D(new C())),
        (this.onDidChangeContent = this.m.event),
        (this.f = e),
        (this.j = !o),
        (this.g = s),
        (this.h = a),
        (this.c = new RAt(t, r, c))
    }
    equals(t) {
      return !(t instanceof RF) ||
        this.f !== t.f ||
        this.getEOL() !== t.getEOL()
        ? !1
        : this.c.equal(t.c)
    }
    mightContainRTL() {
      return this.g
    }
    mightContainUnusualLineTerminators() {
      return this.h
    }
    resetMightContainUnusualLineTerminators() {
      this.h = !1
    }
    mightContainNonBasicASCII() {
      return this.j
    }
    getBOM() {
      return this.f
    }
    getEOL() {
      return this.c.getEOL()
    }
    createSnapshot(t) {
      return this.c.createSnapshot(t ? this.f : "")
    }
    getOffsetAt(t, e) {
      return this.c.getOffsetAt(t, e)
    }
    getPositionAt(t) {
      return this.c.getPositionAt(t)
    }
    getRangeAt(t, e) {
      const r = t + e,
        s = this.getPositionAt(t),
        a = this.getPositionAt(r)
      return new re(s.lineNumber, s.column, a.lineNumber, a.column)
    }
    getValueInRange(t, e = 0) {
      if (t.isEmpty()) return ""
      const r = this.n(e)
      return this.c.getValueInRange(t, r)
    }
    getValueLengthInRange(t, e = 0) {
      if (t.isEmpty()) return 0
      if (t.startLineNumber === t.endLineNumber)
        return t.endColumn - t.startColumn
      const r = this.getOffsetAt(t.startLineNumber, t.startColumn),
        s = this.getOffsetAt(t.endLineNumber, t.endColumn)
      let a = 0
      const o = this.n(e),
        c = this.getEOL()
      if (o.length !== c.length) {
        const u = o.length - c.length,
          l = t.endLineNumber - t.startLineNumber
        a = u * l
      }
      return s - r + a
    }
    getCharacterCountInRange(t, e = 0) {
      if (this.j) {
        let r = 0
        const s = t.startLineNumber,
          a = t.endLineNumber
        for (let o = s; o <= a; o++) {
          const c = this.getLineContent(o),
            u = o === s ? t.startColumn - 1 : 0,
            l = o === a ? t.endColumn - 1 : c.length
          for (let m = u; m < l; m++)
            a_(c.charCodeAt(m)) ? ((r = r + 1), (m = m + 1)) : (r = r + 1)
        }
        return (r += this.n(e).length * (a - s)), r
      }
      return this.getValueLengthInRange(t, e)
    }
    getNearestChunk(t) {
      return this.c.getNearestChunk(t)
    }
    getLength() {
      return this.c.getLength()
    }
    getLineCount() {
      return this.c.getLineCount()
    }
    getLinesContent() {
      return this.c.getLinesContent()
    }
    getLineContent(t) {
      return this.c.getLineContent(t)
    }
    getLineCharCode(t, e) {
      return this.c.getLineCharCode(t, e)
    }
    getCharCode(t) {
      return this.c.getCharCode(t)
    }
    getLineLength(t) {
      return this.c.getLineLength(t)
    }
    getLineMinColumn(t) {
      return 1
    }
    getLineMaxColumn(t) {
      return this.getLineLength(t) + 1
    }
    getLineFirstNonWhitespaceColumn(t) {
      const e = PB(this.getLineContent(t))
      return e === -1 ? 0 : e + 1
    }
    getLineLastNonWhitespaceColumn(t) {
      const e = Eot(this.getLineContent(t))
      return e === -1 ? 0 : e + 2
    }
    n(t) {
      switch (t) {
        case 1:
          return `
`
        case 2:
          return `\r
`
        case 0:
          return this.getEOL()
        default:
          throw new Error("Unknown EOL preference")
      }
    }
    setEOL(t) {
      this.c.setEOL(t)
    }
    applyEdits(t, e, r) {
      let s = this.g,
        a = this.h,
        o = this.j,
        c = !0,
        u = []
      for (let T = 0; T < t.length; T++) {
        const b = t[T]
        c && b._isTracked && (c = !1)
        const N = b.range
        if (b.text) {
          let V = !0
          o || ((V = !Lot(b.text)), (o = V)),
            !s && V && (s = OW(b.text)),
            !a && V && (a = qW(b.text))
        }
        let $ = "",
          L = 0,
          U = 0,
          q = 0
        if (b.text) {
          let V
          ;[L, U, q, V] = qM(b.text)
          const lt = this.getEOL()
          V === 0 ||
          V ===
            (lt ===
            `\r
`
              ? 2
              : 1)
            ? ($ = b.text)
            : ($ = b.text.replace(/\r\n|\r|\n/g, lt))
        }
        u[T] = {
          sortIndex: T,
          identifier: b.identifier || null,
          range: N,
          rangeOffset: this.getOffsetAt(N.startLineNumber, N.startColumn),
          rangeLength: this.getValueLengthInRange(N),
          text: $,
          eolCount: L,
          firstLineLength: U,
          lastLineLength: q,
          forceMoveMarkers: !!b.forceMoveMarkers,
          isAutoWhitespaceEdit: b.isAutoWhitespaceEdit || !1,
        }
      }
      u.sort(RF.t)
      let l = !1
      for (let T = 0, b = u.length - 1; T < b; T++) {
        const N = u[T].range.getEndPosition(),
          $ = u[T + 1].range.getStartPosition()
        if ($.isBeforeOrEqual(N)) {
          if ($.isBefore(N))
            throw new Error("Overlapping ranges are not allowed!")
          l = !0
        }
      }
      c && (u = this.q(u))
      const m = r || e ? RF._getInverseEditRanges(u) : [],
        h = []
      if (e)
        for (let T = 0; T < u.length; T++) {
          const b = u[T],
            N = m[T]
          if (b.isAutoWhitespaceEdit && b.range.isEmpty())
            for (let $ = N.startLineNumber; $ <= N.endLineNumber; $++) {
              let L = ""
              ;($ === N.startLineNumber &&
                ((L = this.getLineContent(b.range.startLineNumber)),
                PB(L) !== -1)) ||
                h.push({ lineNumber: $, oldContent: L })
            }
        }
      let p = null
      if (r) {
        let T = 0
        p = []
        for (let b = 0; b < u.length; b++) {
          const N = u[b],
            $ = m[b],
            L = this.getValueInRange(N.range),
            U = N.rangeOffset + T
          ;(T += N.text.length - L.length),
            (p[b] = {
              sortIndex: N.sortIndex,
              identifier: N.identifier,
              range: $,
              text: L,
              textChange: new AAt(N.rangeOffset, L, U, N.text),
            })
        }
        l || p.sort((b, N) => b.sortIndex - N.sortIndex)
      }
      ;(this.g = s), (this.h = a), (this.j = o)
      const g = this.s(u)
      let w = null
      if (e && h.length > 0) {
        h.sort((T, b) => b.lineNumber - T.lineNumber), (w = [])
        for (let T = 0, b = h.length; T < b; T++) {
          const N = h[T].lineNumber
          if (T > 0 && h[T - 1].lineNumber === N) continue
          const $ = h[T].oldContent,
            L = this.getLineContent(N)
          L.length === 0 || L === $ || PB(L) !== -1 || w.push(N)
        }
      }
      return this.m.fire(), new e1t(p, g, w)
    }
    q(t) {
      return t.length < 1e3 ? t : [this._toSingleEditOperation(t)]
    }
    _toSingleEditOperation(t) {
      let e = !1
      const r = t[0].range,
        s = t[t.length - 1].range,
        a = new re(
          r.startLineNumber,
          r.startColumn,
          s.endLineNumber,
          s.endColumn,
        )
      let o = r.startLineNumber,
        c = r.startColumn
      const u = []
      for (let g = 0, w = t.length; g < w; g++) {
        const T = t[g],
          b = T.range
        ;(e = e || T.forceMoveMarkers),
          u.push(
            this.getValueInRange(
              new re(o, c, b.startLineNumber, b.startColumn),
            ),
          ),
          T.text.length > 0 && u.push(T.text),
          (o = b.endLineNumber),
          (c = b.endColumn)
      }
      const l = u.join(""),
        [m, h, p] = qM(l)
      return {
        sortIndex: 0,
        identifier: t[0].identifier,
        range: a,
        rangeOffset: this.getOffsetAt(a.startLineNumber, a.startColumn),
        rangeLength: this.getValueLengthInRange(a, 0),
        text: l,
        eolCount: m,
        firstLineLength: h,
        lastLineLength: p,
        forceMoveMarkers: e,
        isAutoWhitespaceEdit: !1,
      }
    }
    s(t) {
      t.sort(RF.u)
      const e = []
      for (let r = 0; r < t.length; r++) {
        const s = t[r],
          a = s.range.startLineNumber,
          o = s.range.startColumn,
          c = s.range.endLineNumber,
          u = s.range.endColumn
        if (a === c && o === u && s.text.length === 0) continue
        s.text
          ? (this.c.delete(s.rangeOffset, s.rangeLength),
            this.c.insert(s.rangeOffset, s.text, !0))
          : this.c.delete(s.rangeOffset, s.rangeLength)
        const l = new re(a, o, c, u)
        e.push({
          range: l,
          rangeLength: s.rangeLength,
          text: s.text,
          rangeOffset: s.rangeOffset,
          forceMoveMarkers: s.forceMoveMarkers,
        })
      }
      return e
    }
    findMatchesLineByLine(t, e, r, s) {
      return this.c.findMatchesLineByLine(t, e, r, s)
    }
    getPieceTree() {
      return this.c
    }
    static _getInverseEditRange(t, e) {
      const r = t.startLineNumber,
        s = t.startColumn,
        [a, o, c] = qM(e)
      let u
      if (e.length > 0) {
        const l = a + 1
        l === 1
          ? (u = new re(r, s, r, s + o))
          : (u = new re(r, s, r + l - 1, c + 1))
      } else u = new re(r, s, r, s)
      return u
    }
    static _getInverseEditRanges(t) {
      const e = []
      let r = 0,
        s = 0,
        a = null
      for (let o = 0, c = t.length; o < c; o++) {
        const u = t[o]
        let l, m
        a
          ? a.range.endLineNumber === u.range.startLineNumber
            ? ((l = r), (m = s + (u.range.startColumn - a.range.endColumn)))
            : ((l = r + (u.range.startLineNumber - a.range.endLineNumber)),
              (m = u.range.startColumn))
          : ((l = u.range.startLineNumber), (m = u.range.startColumn))
        let h
        if (u.text.length > 0) {
          const p = u.eolCount + 1
          p === 1
            ? (h = new re(l, m, l, m + u.firstLineLength))
            : (h = new re(l, m, l + p - 1, u.lastLineLength + 1))
        } else h = new re(l, m, l, m)
        ;(r = h.endLineNumber), (s = h.endColumn), e.push(h), (a = u)
      }
      return e
    }
    static t(t, e) {
      const r = re.compareRangesUsingEnds(t.range, e.range)
      return r === 0 ? t.sortIndex - e.sortIndex : r
    }
    static u(t, e) {
      const r = re.compareRangesUsingEnds(t.range, e.range)
      return r === 0 ? e.sortIndex - t.sortIndex : -r
    }
  },
  OAt = class {
    constructor(i, t, e, r, s, a, o, c, u) {
      ;(this.a = i),
        (this.b = t),
        (this.c = e),
        (this.d = r),
        (this.e = s),
        (this.f = a),
        (this.g = o),
        (this.h = c),
        (this.j = u)
    }
    k(i) {
      const t = this.c + this.d + this.e,
        e = this.c + this.e
      return t === 0
        ? i === 1
          ? `
`
          : `\r
`
        : e > t / 2
          ? `\r
`
          : `
`
    }
    create(i) {
      const t = this.k(i),
        e = this.a
      if (
        this.j &&
        ((t ===
          `\r
` &&
          (this.c > 0 || this.d > 0)) ||
          (t ===
            `
` &&
            (this.c > 0 || this.e > 0)))
      )
        for (let s = 0, a = e.length; s < a; s++) {
          const o = e[s].buffer.replace(/\r\n|\r|\n/g, t),
            c = Gn(o)
          e[s] = new Ya(o, c)
        }
      const r = new BAt(e, this.b, t, this.f, this.g, this.h, this.j)
      return { textBuffer: r, disposable: r }
    }
    getFirstLineText(i) {
      return this.a[0].buffer.substr(0, i).split(/\r\n|\r|\n/)[0]
    }
  },
  xrt = class {
    constructor() {
      ;(this.a = []),
        (this.b = ""),
        (this.c = !1),
        (this.d = 0),
        (this.e = []),
        (this.f = 0),
        (this.g = 0),
        (this.h = 0),
        (this.j = !1),
        (this.k = !1),
        (this.l = !0)
    }
    acceptChunk(i) {
      if (i.length === 0) return
      this.a.length === 0 && Fot(i) && ((this.b = Dot), (i = i.substr(1)))
      const t = i.charCodeAt(i.length - 1)
      t === 13 || (t >= 55296 && t <= 56319)
        ? (this.m(i.substr(0, i.length - 1), !1), (this.c = !0), (this.d = t))
        : (this.m(i, !1), (this.c = !1), (this.d = t))
    }
    m(i, t) {
      ;(!t && i.length === 0) ||
        (this.c ? this.n(String.fromCharCode(this.d) + i) : this.n(i))
    }
    n(i) {
      const t = JAt(this.e, i)
      this.a.push(new Ya(i, t.lineStarts)),
        (this.f += t.cr),
        (this.g += t.lf),
        (this.h += t.crlf),
        t.isBasicASCII ||
          ((this.l = !1),
          this.j || (this.j = OW(i)),
          this.k || (this.k = qW(i)))
    }
    finish(i = !0) {
      return (
        this.o(),
        new OAt(
          this.a,
          this.b,
          this.f,
          this.g,
          this.h,
          this.j,
          this.k,
          this.l,
          i,
        )
      )
    }
    o() {
      if ((this.a.length === 0 && this.m("", !0), this.c)) {
        this.c = !1
        const i = this.a[this.a.length - 1]
        i.buffer += String.fromCharCode(this.d)
        const t = Gn(i.buffer)
        ;(i.lineStarts = t), this.d === 13 && this.f++
      }
    }
  },
  qAt = class extends dt {
    constructor(i, t, e) {
      super(), (this._source = i), (this.b = t), (this.c = e), (this.a = void 0)
    }
    f(i) {
      const t = i.getLineCount()
      return new re(1, 1, t, this.g(i, t))
    }
    g(i, t) {
      if (t < 1 || t > i.getLineCount())
        throw new Error("Illegal value for lineNumber")
      return i.getLineLength(t) + 1
    }
    get inputTextBuffer() {
      if (!this.b) {
        const i = new xrt()
        i.acceptChunk(this._source)
        const t = i.finish(!0),
          { textBuffer: e, disposable: r } = t.create(1)
        ;(this.b = e), this.D(r)
      }
      return this.b
    }
    get outputTextBuffers() {
      return (
        this.a ||
          (this.a = this.c.map((i) => {
            const t = new xrt()
            t.acceptChunk(i)
            const e = t.finish(!0),
              { textBuffer: r, disposable: s } = e.create(1)
            return this.D(s), r
          })),
        this.a
      )
    }
    findInInputs(i) {
      const e = new YX(i, !1, !1, null).parseSearchRequest()
      if (!e) return []
      const r = this.f(this.inputTextBuffer)
      return this.inputTextBuffer.findMatchesLineByLine(r, e, !0, 5e3)
    }
    findInOutputs(i) {
      const e = new YX(i, !1, !1, null).parseSearchRequest()
      return e
        ? this.outputTextBuffers
            .map((r) => {
              const s = r.findMatchesLineByLine(this.f(r), e, !0, 5e3)
              if (s.length !== 0) return { textBuffer: r, matches: s }
            })
            .filter((r) => !!r)
        : []
    }
  }
function Jrt(i, t) {
  let e = -1
  const r = []
  let s = []
  return (
    i.forEach((o) => {
      o.range.startLineNumber !== e &&
        s.length > 0 &&
        (r.push([...s]), (s = [])),
        s.push(o),
        (e = o.range.endLineNumber)
    }),
    s.length > 0 && r.push([...s]),
    r.map((o) => {
      const c = [],
        u = o[0].range.startLineNumber,
        l = o[o.length - 1].range.endLineNumber
      for (let m = u; m <= l; m++) c.push(t.getLineContent(m))
      return new Gmt(
        c.join(`
`) +
          `
`,
        o.map(
          (m) =>
            new re(
              m.range.startLineNumber - 1,
              m.range.startColumn - 1,
              m.range.endLineNumber - 1,
              m.range.endColumn - 1,
            ),
        ),
      )
    })
  )
}
var bMt = Object.freeze({
    id: "application",
    order: 100,
    title: f(4069, null),
    type: "object",
  }),
  UAt = Object.freeze({
    id: "workbench",
    order: 7,
    title: f(4070, null),
    type: "object",
  }),
  MAt = Object.freeze({
    id: "security",
    scope: 1,
    title: f(4071, null),
    type: "object",
    order: 7,
  }),
  EMt = Object.freeze({
    id: "problems",
    title: f(4072, null),
    type: "object",
    order: 101,
  }),
  HAt = Object.freeze({
    id: "window",
    order: 8,
    title: f(4073, null),
    type: "object",
  }),
  WAt = {
    ConfigurationMigration: "base.contributions.configuration.migration",
  },
  jAt = class {
    constructor() {
      ;(this.migrations = []),
        (this.a = new C()),
        (this.onDidRegisterConfigurationMigration = this.a.event)
    }
    registerConfigurationMigrations(i) {
      this.migrations.push(...i)
    }
  },
  N8 = new jAt()
ui.add(WAt.ConfigurationMigration, N8)
var Crt = class extends dt {
  static {
    this.ID = "workbench.contrib.configurationMigration"
  }
  constructor(t, e) {
    super(),
      (this.a = t),
      (this.b = e),
      this.D(
        this.b.onDidChangeWorkspaceFolders(async (r) => {
          for (const s of r.added) await this.f(s, N8.migrations)
        }),
      ),
      this.c(N8.migrations),
      this.D(N8.onDidRegisterConfigurationMigration((r) => this.c(r)))
  }
  async c(t) {
    await this.f(void 0, t)
    for (const e of this.b.getWorkspace().folders) await this.f(e, t)
  }
  async f(t, e) {
    await Promise.all([e.map((r) => this.g(r, t?.uri))])
  }
  async g(t, e) {
    const r = this.a.inspect(t.key, { resource: e }),
      s =
        this.b.getWorkbenchState() === 3
          ? [
              ["user", 2],
              ["userLocal", 3],
              ["userRemote", 4],
              ["workspace", 5],
              ["workspaceFolder", 6],
            ]
          : [
              ["user", 2],
              ["userLocal", 3],
              ["userRemote", 4],
              ["workspace", 5],
            ]
    for (const [a, o] of s) {
      const c = r[a]
      if (!c) continue
      const u = []
      if (c.value !== void 0) {
        const l = await this.h(t, a, c.value, e, void 0)
        for (const m of l ?? []) u.push([m, []])
      }
      for (const { identifiers: l, value: m } of c.overrides ?? [])
        if (m !== void 0) {
          const h = await this.h(t, a, m, e, l)
          for (const p of h ?? []) u.push([p, l])
        }
      u.length &&
        (await Promise.allSettled(
          u.map(async ([[l, m], h]) =>
            this.a.updateValue(
              l,
              m.value,
              { resource: e, overrideIdentifiers: h },
              o,
            ),
          ),
        ))
    }
  }
  async h(t, e, r, s, a) {
    const o = (u) => {
        const m = this.a.inspect(u, { resource: s })[e]
        if (m)
          return a
            ? m.overrides?.find(({ identifiers: h }) => Ir(h, a))?.value
            : m.value
      },
      c = await t.migrateFn(r, o)
    return Array.isArray(c) ? c : [[t.key, c]]
  }
}
Crt = __decorate([__param(0, $_), __param(1, KB)], Crt)
var Lrt = class extends dt {
  static {
    this.ID = "workbench.contrib.dynamicWorkbenchSecurityConfiguration"
  }
  constructor(t) {
    super(),
      (this.b = t),
      (this.a = new go()),
      (this.ready = this.a.p),
      this.c()
  }
  async c() {
    try {
      await this.f()
    } finally {
      this.a.complete()
    }
  }
  async f() {
    if (!Mi && (await this.b.getEnvironment())?.os !== 1) return
    ui.as($o.Configuration).registerConfiguration({
      ...MAt,
      properties: {
        "security.allowedUNCHosts": {
          type: "array",
          items: {
            type: "string",
            pattern: "^[^\\\\]+$",
            patternErrorMessage: f(4074, null),
          },
          default: [],
          markdownDescription: f(4075, null),
          scope: 2,
        },
        "security.restrictUNCAccess": {
          type: "boolean",
          default: !0,
          markdownDescription: f(4076, null),
          scope: 2,
        },
      },
    })
  }
}
Lrt = __decorate([__param(0, tK)], Lrt)
var Ih = "window.newWindowProfile",
  Rrt = class extends dt {
    static {
      this.ID = "workbench.contrib.dynamicWindowConfiguration"
    }
    constructor(t, e) {
      super(),
        (this.c = t),
        (this.f = e),
        this.g(),
        this.D(this.c.onDidChangeProfiles((r) => this.g())),
        this.h(),
        this.j(),
        this.D(
          e.onDidChangeConfiguration((r) => {
            r.source !== 7 && r.affectsConfiguration(Ih) && this.h()
          }),
        ),
        this.D(this.c.onDidChangeProfiles(() => this.j()))
    }
    g() {
      const t = ui.as($o.Configuration),
        e = {
          ...HAt,
          properties: {
            [Ih]: {
              type: ["string", "null"],
              default: null,
              enum: [...this.c.profiles.map((r) => r.name), null],
              enumItemLabels: [
                ...this.c.profiles.map((r) => ""),
                f(4077, null),
              ],
              description: f(4078, null),
              scope: 1,
            },
          },
        }
      this.a
        ? t.updateConfigurations({ add: [e], remove: [this.a] })
        : t.registerConfiguration(e),
        (this.a = e)
    }
    h() {
      const t = this.f.getValue(Ih)
      this.b = t ? this.c.profiles.find((e) => e.name === t) : void 0
    }
    j() {
      const t = this.f.getValue(Ih)
      if (!t) return
      const e = this.b
        ? this.c.profiles.find((r) => r.id === this.b.id)
        : void 0
      t !== e?.name && this.f.updateValue(Ih, e?.name)
    }
  }
Rrt = __decorate([__param(0, bdt), __param(1, $_)], Rrt)
var $Mt = Y("editorResolverService"),
  VAt = ui.as($o.Configuration),
  GAt = {
    ...UAt,
    properties: {
      "workbench.editorAssociations": {
        type: "object",
        markdownDescription: f(12787, null),
        additionalProperties: { type: "string" },
      },
    },
  }
VAt.registerConfiguration(GAt)
var MM
;(function (i) {
  ;(i.builtin = "builtin"),
    (i.option = "option"),
    (i.exclusive = "exclusive"),
    (i.default = "default")
})(MM || (MM = {}))
var Drt
;(function (i) {
  ;(i[(i.ABORT = 1)] = "ABORT"), (i[(i.NONE = 2)] = "NONE")
})(Drt || (Drt = {}))
function zAt(i, t) {
  if (
    new Set([
      Q.extension,
      Q.webviewPanel,
      Q.vscodeWorkspaceTrust,
      Q.walkThrough,
      Q.vscodeSettings,
      Q.aiSettings,
      Q.aiChat,
    ]).has(t.scheme)
  )
    return !1
  const s =
    typeof i == "string" && i.indexOf(Ut.sep) >= 0
      ? `${t.scheme}:${t.path}`
      : us(t)
  return al(typeof i == "string" ? i.toLowerCase() : i, s.toLowerCase())
}
var YAt = class DF {
    static {
      this.a = 0
    }
    get activeNotebookEditor() {
      return this.k?.apiEditor
    }
    get visibleNotebookEditors() {
      return this.l.map((t) => t.apiEditor)
    }
    constructor(t, e, r, s, a, o, c) {
      ;(this.q = r),
        (this.r = s),
        (this.s = a),
        (this.t = o),
        (this.u = c),
        (this.f = new Map()),
        (this.g = new ei()),
        (this.h = new Map()),
        (this.j = new C()),
        (this.onDidChangeActiveNotebookEditor = this.j.event),
        (this.l = []),
        (this.m = new C()),
        (this.onDidOpenNotebookDocument = this.m.event),
        (this.n = new C()),
        (this.onDidCloseNotebookDocument = this.n.event),
        (this.o = new C()),
        (this.onDidChangeVisibleNotebookEditors = this.o.event),
        (this.p = new Hr("NotebookCellStatusBarCache")),
        (this.x = 0),
        (this.y = new Map()),
        (this.b = t.getProxy(z.MainThreadNotebook)),
        (this.c = t.getProxy(z.MainThreadNotebookDocuments)),
        (this.d = t.getProxy(z.MainThreadNotebookEditors)),
        (this.i = e.converter),
        e.registerArgumentProcessor({
          processArgument: (u) => {
            if (u && u.$mid === 13) {
              const l = u.notebookEditor?.notebookUri,
                m = u.cell.handle,
                p = this.g.get(l)?.getCell(m)
              if (p) return p.apiCell
            }
            if (u && u.$mid === 14) {
              const l = u.uri,
                m = this.g.get(l)
              if (m) return m.apiNotebook
            }
            return u
          },
        }),
        DF.C(e)
    }
    getEditorById(t) {
      const e = this.h.get(t)
      if (!e)
        throw new Error(
          `unknown text editor: ${t}. known editors: ${[...this.h.keys()]} `,
        )
      return e
    }
    getIdByEditor(t) {
      for (const [e, r] of this.h) if (r.apiEditor === t) return e
    }
    get notebookDocuments() {
      return [...this.g.values()]
    }
    getNotebookDocument(t, e) {
      const r = this.g.get(t)
      if (!r && !e) throw new Error(`NO notebook document for '${t}'`)
      return r
    }
    static w(t, e) {
      if (!e) return
      const r = e.filenamePattern
        .map((s) => vA.from(s))
        .filter((s) => s !== void 0)
      if (e.filenamePattern && !r) {
        console.warn(
          `Notebook content provider view options file name pattern is invalid ${e.filenamePattern}`,
        )
        return
      }
      return {
        extension: t.identifier,
        providerDisplayName: t.displayName || t.name,
        displayName: e.displayName,
        filenamePattern: r,
        priority: e.exclusive ? MM.exclusive : void 0,
      }
    }
    registerNotebookCellStatusBarItemProvider(t, e, r) {
      const s = DF.a++,
        a =
          typeof r.onDidChangeCellStatusBarItems == "function" ? DF.a++ : void 0
      this.f.set(s, r),
        this.b.$registerNotebookCellStatusBarItemProvider(s, a, e)
      let o
      return (
        a !== void 0 &&
          (o = r.onDidChangeCellStatusBarItems((c) =>
            this.b.$emitCellStatusBarEvent(a),
          )),
        new At(() => {
          this.f.delete(s),
            this.b.$unregisterNotebookCellStatusBarItemProvider(s, a),
            o?.dispose()
        })
      )
    }
    async createNotebookDocument(t) {
      const e = await this.c.$tryCreateNotebook({
        viewType: t.viewType,
        content: t.content && Ts.from(t.content),
      })
      return S.revive(e)
    }
    async openNotebookDocument(t) {
      const e = this.g.get(t)
      if (e) return e.apiNotebook
      const r = await this.c.$tryOpenNotebook(t),
        s = this.g.get(S.revive(r))
      return fo(s?.apiNotebook)
    }
    async showNotebookDocument(t, e) {
      let r
      typeof e == "object"
        ? (r = {
            position: Me.from(e.viewColumn),
            preserveFocus: e.preserveFocus,
            selections: e.selections && e.selections.map(an.from),
            pinned: typeof e.preview == "boolean" ? !e.preview : void 0,
            label:
              typeof e.asRepl == "string"
                ? e.asRepl
                : typeof e.asRepl == "object"
                  ? e.asRepl.label
                  : void 0,
          })
        : (r = { preserveFocus: !1, pinned: !0 })
      const s = e?.asRepl ? "repl" : t.notebookType,
        a = await this.d.$tryShowNotebookDocument(t.uri, s, r),
        o = a && this.h.get(a)?.apiEditor
      if (o) return o
      throw a
        ? new Error(
            `Could NOT open editor for "${t.uri.toString()}" because another editor opened in the meantime.`,
          )
        : new Error(`Could NOT open editor for "${t.uri.toString()}".`)
    }
    async $provideNotebookCellStatusBarItems(t, e, r, s) {
      const a = this.f.get(t),
        o = S.revive(e),
        c = this.g.get(o)
      if (!c || !a) return
      const u = c.getCellFromIndex(r)
      if (!u) return
      const l = await a.provideCellStatusBarItems(u.apiCell, s)
      if (!l) return
      const m = new bt(),
        h = this.p.add([m]),
        g = (Array.isArray(l) ? l : [l]).map((w) => uq.from(w, this.i, m))
      return { cacheId: h, items: g }
    }
    $releaseNotebookCellStatusBarItems(t) {
      this.p.delete(t)
    }
    registerNotebookSerializer(t, e, r, s, a) {
      if (s_(e)) throw new Error("viewType cannot be empty or just whitespace")
      const o = this.x++
      return (
        this.y.set(o, { viewType: e, serializer: r, options: s }),
        this.b.$registerNotebookSerializer(
          o,
          { id: t.identifier, location: t.extensionLocation },
          e,
          dq.from(s),
          DF.w(t, a),
        ),
        it(() => {
          this.b.$unregisterNotebookSerializer(o)
        })
      )
    }
    async $dataToNotebook(t, e, r) {
      const s = this.y.get(t)
      if (!s) throw new Error("NO serializer found")
      const a = await s.serializer.deserializeNotebook(e.buffer, r)
      return new Xi(Ts.from(a))
    }
    async $notebookToData(t, e, r) {
      const s = this.y.get(t)
      if (!s) throw new Error("NO serializer found")
      const a = await s.serializer.serializeNotebook(Ts.to(e.value), r)
      return Et.wrap(a)
    }
    async $saveNotebook(t, e, r, s, a) {
      const o = S.revive(e),
        c = this.y.get(t)
      if ((this.D(`enter saveNotebook(versionId: ${r}, ${o.toString()})`), !c))
        throw new Error("NO serializer found")
      const u = this.g.get(o)
      if (!u) throw new Error("Document NOT found")
      if (u.versionId !== r) throw new Error("Document version mismatch")
      if (!this.s.value.isWritableFileSystem(o.scheme))
        throw new w3(f(2766, null, this.A(o)), 6)
      const l = {
        metadata: jj(
          u.apiNotebook.metadata,
          (w) => !(c.options?.transientDocumentMetadata ?? {})[w],
        ),
        cells: [],
      }
      for (const w of u.apiNotebook.getCells()) {
        const T = new D6(
          w.kind,
          w.document.getText(),
          w.document.languageId,
          w.mime,
          c.options?.transientOutputs ? [] : [...w.outputs],
          w.metadata,
          w.executionSummary,
        )
        ;(T.metadata = jj(
          w.metadata,
          (b) => !(c.options?.transientCellMetadata ?? {})[b],
        )),
          l.cells.push(T)
      }
      if ((await this.z(o, s), a.isCancellationRequested))
        throw new Error("canceled")
      const m = await c.serializer.serializeNotebook(l, a)
      if (a.isCancellationRequested) throw new Error("canceled")
      this.D(`serialized versionId: ${r} ${o.toString()}`),
        await this.s.value.writeFile(o, m),
        this.D(`Finished write versionId: ${r} ${o.toString()}`)
      const h = this.s.getFileSystemProviderExtUri(o.scheme),
        p = await this.s.value.stat(o),
        g = {
          name: h.basename(o),
          isFile: (p.type & ua.File) !== 0,
          isDirectory: (p.type & ua.Directory) !== 0,
          isSymbolicLink: (p.type & ua.SymbolicLink) !== 0,
          mtime: p.mtime,
          ctime: p.ctime,
          size: p.size,
          readonly:
            !!((p.permissions ?? 0) & Eo.Readonly) ||
            !this.s.value.isWritableFileSystem(o.scheme),
          locked: !!((p.permissions ?? 0) & Eo.Locked),
          etag: cG({ mtime: p.mtime, size: p.size }),
          children: void 0,
        }
      return this.D(`exit saveNotebook(versionId: ${r}, ${o.toString()})`), g
    }
    async $searchInNotebooks(t, e, r, s, a) {
      const o = this.y.get(t)?.serializer
      if (!o) return { limitHit: !1, results: [] }
      const c = new AH()
      await (async (p, g, w) => {
        await Promise.all(
          p.map(
            async (T) =>
              await Promise.all(
                T.filenamePatterns.map((b) => {
                  const N = {
                    _reason: w._reason,
                    folderQueries: w.folderQueries,
                    includePattern: w.includePattern,
                    excludePattern: w.excludePattern,
                    maxResults: w.maxResults,
                    type: 1,
                    filePattern: b,
                  }
                  return this.t
                    .doInternalFileSearchWithCustomCallback(N, g, ($) => {
                      $.forEach((L) => {
                        c.has(L) ||
                          s.some((q) =>
                            T.isFromSettings && !q.isFromSettings
                              ? !1
                              : q.filenamePatterns.some((V) => zAt(V, L)),
                          ) ||
                          c.add(L)
                      })
                    })
                    .catch(($) => {
                      if ($.code === "ENOENT")
                        return (
                          console.warn(
                            "Could not find notebook search results, ignoring notebook results.",
                          ),
                          { limitHit: !1, messages: [] }
                        )
                      throw $
                    })
                }),
              ),
          ),
        )
      })(r, a, e)
      const l = new ei()
      let m = !1
      const h = Array.from(c).map(async (p) => {
        const g = []
        try {
          if (a.isCancellationRequested) return
          if (
            e.maxResults &&
            [...l.values()].reduce((N, $) => N + $.cellResults.length, 0) >
              e.maxResults
          ) {
            m = !0
            return
          }
          const w = [],
            T = this.g.get(p)
          if (T)
            T.apiNotebook
              .getCells()
              .forEach(($) =>
                w.push({
                  input: $.document.getText(),
                  outputs: $.outputs.flatMap((L) =>
                    L.items.map((U) => U.data.toString()),
                  ),
                }),
              )
          else {
            const N = await this.s.value.readFile(p),
              $ = Et.fromString(N.toString()),
              L = await o.deserializeNotebook($.buffer, a)
            if (a.isCancellationRequested) return
            Ts.from(L).cells.forEach((q) =>
              w.push({
                input: q.source,
                outputs: q.outputs.flatMap((V) =>
                  V.items.map((lt) => lt.valueBytes.toString()),
                ),
              }),
            )
          }
          if (a.isCancellationRequested) return
          w.forEach((N, $) => {
            const L = e.contentPattern.pattern,
              U = new qAt(N.input, void 0, N.outputs),
              q = U.findInInputs(L),
              V = U.findInOutputs(L),
              lt = V.flatMap((at) => Jrt(at.matches, at.textBuffer)).map(
                (at, et) => ((at.webviewIndex = et), at),
              )
            if (q.length > 0 || V.length > 0) {
              const at = {
                index: $,
                contentResults: Jrt(q, U.inputTextBuffer),
                webviewResults: lt,
              }
              g.push(at)
            }
          })
          const b = { resource: p, cellResults: g }
          l.set(p, b)
          return
        } catch {
          return
        }
      })
      return await Promise.all(h), { limitHit: m, results: [...l.values()] }
    }
    async z(t, e) {
      const r = await this.s.value.stat(t)
      if (
        typeof e?.mtime == "number" &&
        typeof e.etag == "string" &&
        e.etag !== Slt &&
        typeof r.mtime == "number" &&
        typeof r.size == "number" &&
        e.mtime < r.mtime &&
        e.etag !== cG({ mtime: e.mtime, size: r.size })
      )
        throw new w3(f(2767, null), 3, e)
    }
    A(t) {
      return t.scheme === Q.file ? t.fsPath : t.toString()
    }
    B(t, e, r) {
      if (this.h.has(e)) throw new Error(`editor with id ALREADY EXSIST: ${e}`)
      const s = new DM(
        e,
        this.d,
        t,
        r.visibleRanges.map(an.to),
        r.selections.map(an.to),
        typeof r.viewColumn == "number" ? Me.to(r.viewColumn) : void 0,
        r.viewType,
      )
      this.h.set(e, s)
    }
    $acceptDocumentAndEditorsDelta(t) {
      if (t.value.removedDocuments)
        for (const r of t.value.removedDocuments) {
          const s = S.revive(r),
            a = this.g.get(s)
          a &&
            (a.dispose(),
            this.g.delete(s),
            this.q.$acceptDocumentsAndEditorsDelta({
              removedDocuments: a.apiNotebook
                .getCells()
                .map((o) => o.document.uri),
            }),
            this.n.fire(a.apiNotebook))
          for (const o of this.h.values())
            o.notebookData.uri.toString() === s.toString() &&
              this.h.delete(o.id)
        }
      if (t.value.addedDocuments) {
        const r = []
        for (const s of t.value.addedDocuments) {
          const a = S.revive(s.uri)
          if (this.g.has(a)) throw new Error(`adding EXISTING notebook ${a} `)
          const o = new $At(this.c, this.q, this.r, a, s)
          r.push(...s.cells.map((c) => RM.asModelAddData(c))),
            this.g.get(a)?.dispose(),
            this.g.set(a, o),
            this.q.$acceptDocumentsAndEditorsDelta({ addedDocuments: r }),
            this.m.fire(o.apiNotebook)
        }
      }
      if (t.value.addedEditors)
        for (const r of t.value.addedEditors) {
          if (this.h.has(r.id)) return
          const s = S.revive(r.documentUri),
            a = this.g.get(s)
          a && this.B(a, r.id, r)
        }
      const e = []
      if (t.value.removedEditors)
        for (const r of t.value.removedEditors) {
          const s = this.h.get(r)
          s &&
            (this.h.delete(r),
            this.k?.id === s.id && (this.k = void 0),
            e.push(s))
        }
      if (t.value.visibleEditors) {
        this.l = t.value.visibleEditors
          .map((s) => this.h.get(s))
          .filter((s) => !!s)
        const r = new Set()
        this.l.forEach((s) => r.add(s.id))
        for (const s of this.h.values()) {
          const a = r.has(s.id)
          s._acceptVisibility(a)
        }
        ;(this.l = [...this.h.values()].map((s) => s).filter((s) => s.visible)),
          this.o.fire(this.visibleNotebookEditors)
      }
      t.value.newActiveEditor === null
        ? (this.k = void 0)
        : t.value.newActiveEditor &&
          (this.h.get(t.value.newActiveEditor) ||
            console.error(
              `FAILED to find active notebook editor ${t.value.newActiveEditor}`,
            ),
          (this.k = this.h.get(t.value.newActiveEditor))),
        t.value.newActiveEditor !== void 0 && this.j.fire(this.k?.apiEditor)
    }
    static C(t) {
      const e = M.String.with("notebookType", "A notebook type"),
        r = new pt(
          "vscode.executeDataToNotebook",
          "_executeDataToNotebook",
          "Invoke notebook serializer",
          [
            e,
            new M(
              "data",
              "Bytes to convert to data",
              (a) => a instanceof Uint8Array,
              (a) => Et.wrap(a),
            ),
          ],
          new ht("Notebook Data", (a) => Ts.to(a.value)),
        ),
        s = new pt(
          "vscode.executeNotebookToData",
          "_executeNotebookToData",
          "Invoke notebook serializer",
          [
            e,
            new M(
              "NotebookData",
              "Notebook data to convert to bytes",
              (a) => !0,
              (a) => new Xi(Ts.from(a)),
            ),
          ],
          new ht("Bytes", (a) => a.buffer),
        )
      t.registerApiCommand(r), t.registerApiCommand(s)
    }
    D(t) {
      this.u.trace(`[Extension Host Notebook] ${t}`)
    }
  },
  QAt = class {
    constructor(i, t, e, r = { timeout: 1500, errors: 3 }) {
      ;(this.b = i),
        (this.c = t),
        (this.d = e),
        (this.f = r),
        (this.a = new Iu())
    }
    dispose() {}
    getOnWillSaveNotebookDocumentEvent(i) {
      return (t, e, r) => {
        const s = function (o) {
          t.call(e, o)
        }
        return (s.extension = i), this.a.event(s, void 0, r)
      }
    }
    async $participateInSave(i, t, e) {
      const r = S.revive(i),
        s = this.c.getNotebookDocument(r)
      if (!s) throw new Error("Unable to resolve notebook document")
      const a = []
      if (
        (await this.a.fireAsync(
          { notebook: s.apiNotebook, reason: hA.to(t) },
          e,
          async (c, u) => {
            const l = Date.now(),
              m = await await Promise.resolve(c)
            Date.now() - l > this.f.timeout &&
              this.b.warn(
                "onWillSaveNotebookDocument-listener from extension",
                u.extension.identifier,
              ),
              !e.isCancellationRequested &&
                m &&
                (m instanceof va
                  ? a.push(m)
                  : this.b.warn(
                      "onWillSaveNotebookDocument-listener from extension",
                      u.extension.identifier,
                      "ignored due to invalid data",
                    ))
          },
        ),
        e.isCancellationRequested)
      )
        return !1
      if (a.length === 0) return !0
      const o = { edits: [] }
      for (const c of a) {
        const { edits: u } = bi.from(c)
        o.edits = o.edits.concat(u)
      }
      return this.d.$tryApplyWorkspaceEdit(new Xi(o))
    }
  },
  XAt = class {
    constructor(i) {
      ;(this.c = i),
        (this.a = new C()),
        (this.onDidSaveNotebookDocument = this.a.event),
        (this.b = new C()),
        (this.onDidChangeNotebookDocument = this.b.event)
    }
    $acceptModelChanged(i, t, e, r) {
      const a = this.c
        .getNotebookDocument(S.revive(i))
        .acceptModelChanged(t.value, e, r)
      this.b.fire(a)
    }
    $acceptDirtyStateChanged(i, t) {
      this.c.getNotebookDocument(S.revive(i)).acceptDirty(t)
    }
    $acceptModelSaved(i) {
      const t = this.c.getNotebookDocument(S.revive(i))
      this.a.fire(t.apiNotebook)
    }
  },
  HM = class {
    constructor(t, e) {
      ;(this.c = t),
        (this.d = e),
        (this.a = new C()),
        (this.b = new C()),
        (this.onDidChangeNotebookEditorSelection = this.a.event),
        (this.onDidChangeNotebookEditorVisibleRanges = this.b.event)
    }
    $acceptEditorPropertiesChanged(t, e) {
      this.c.debug("ExtHostNotebook#$acceptEditorPropertiesChanged", t, e)
      const r = this.d.getEditorById(t)
      e.visibleRanges &&
        r._acceptVisibleRanges(e.visibleRanges.ranges.map(an.to)),
        e.selections && r._acceptSelections(e.selections.selections.map(an.to)),
        e.visibleRanges &&
          this.b.fire({
            notebookEditor: r.apiEditor,
            visibleRanges: r.apiEditor.visibleRanges,
          }),
        e.selections &&
          this.a.fire(
            Object.freeze({
              notebookEditor: r.apiEditor,
              selections: r.apiEditor.selections,
            }),
          )
    }
    $acceptEditorViewColumns(t) {
      for (const e in t) this.d.getEditorById(e)._acceptViewColumn(Me.to(t[e]))
    }
  }
HM = __decorate([__param(0, Kt)], HM)
var Vc
;(function (i) {
  ;(i[(i.Output = 1)] = "Output"),
    (i[(i.OutputItems = 2)] = "OutputItems"),
    (i[(i.ExecutionState = 3)] = "ExecutionState")
})(Vc || (Vc = {}))
var JMt = Y("INotebookExecutionService"),
  KAt = 100,
  Frt
;(function (i) {
  ;(i[(i.Disconnected = 1)] = "Disconnected"),
    (i[(i.Connected = 2)] = "Connected"),
    (i[(i.Initializing = 3)] = "Initializing")
})(Frt || (Frt = {}))
var CMt = Y("INotebookKernelService"),
  LMt = Y("INotebookKernelHistoryService"),
  WM = class {
    constructor(t, e, r, s, a) {
      ;(this.m = e),
        (this.n = r),
        (this.o = s),
        (this.q = a),
        (this.b = new ei()),
        (this.c = new ei()),
        (this.f = new Map()),
        (this.g = 0),
        (this.h = new Map()),
        (this.i = 0),
        (this.j = new Map()),
        (this.k = 0),
        (this.l = new C()),
        (this.onDidChangeNotebookCellExecutionState = this.l.event),
        (this.r = 0),
        (this.s = {}),
        (this.a = t.getProxy(z.MainThreadNotebookKernels))
      const o = new pt(
          "notebook.selectKernel",
          "_notebook.selectKernel",
          "Trigger kernel picker for specified notebook editor widget",
          [
            new M(
              "options",
              "Select kernel options",
              (u) => !0,
              (u) => {
                if (u && "notebookEditor" in u && "id" in u) {
                  const l = this.n.getIdByEditor(u.notebookEditor)
                  return {
                    id: u.id,
                    extension: u.extension,
                    notebookEditorId: l,
                  }
                } else if (u && "notebookEditor" in u) {
                  const l = this.n.getIdByEditor(u.notebookEditor)
                  if (l === void 0)
                    throw new Error(
                      `Cannot invoke 'notebook.selectKernel' for unrecognized notebook editor ${u.notebookEditor.notebook.uri.toString()}`,
                    )
                  return { notebookEditorId: l }
                }
                return u
              },
            ),
          ],
          ht.Void,
        ),
        c = new pt(
          "vscode.executeNotebookVariableProvider",
          "_executeNotebookVariableProvider",
          "Execute notebook variable provider",
          [M.Uri],
          new ht("A promise that resolves to an array of variables", (u, l) =>
            u.map((m) => ({
              variable: {
                name: m.name,
                value: m.value,
                expression: m.expression,
                type: m.type,
                language: m.language,
              },
              hasNamedChildren: m.hasNamedChildren,
              indexedChildrenCount: m.indexedChildrenCount,
            })),
          ),
        )
      this.o.registerApiCommand(o), this.o.registerApiCommand(c)
    }
    createNotebookController(t, e, r, s, a, o) {
      for (const q of this.j.values())
        if (q.controller.id === e && te.equals(t.identifier, q.extensionId))
          throw new Error(`notebook controller with id '${e}' ALREADY exist`)
      const c = this.k++,
        u = this
      this.q.trace(
        `NotebookController[${c}], CREATED by ${t.identifier.value}, ${e}`,
      )
      const l = () =>
        console.warn(
          `NO execute handler from notebook controller '${g.id}' of extension: '${t.identifier}'`,
        )
      let m = !1
      const h = new C(),
        p = new C(),
        g = {
          id: $8(t.identifier, e),
          notebookType: r,
          extensionId: t.identifier,
          extensionLocation: t.extensionLocation,
          label: s || t.identifier.value,
          preloads: o ? o.map(wA.from) : [],
        }
      let w = a ?? l,
        T,
        b
      this.a.$addKernel(c, g).catch((q) => {
        console.log(q), (m = !0)
      })
      let N = 0
      const $ = () => {
          if (m) return
          const q = ++N
          Promise.resolve().then(() => {
            q === N && this.a.$updateKernel(c, g)
          })
        },
        L = new ei(),
        U = {
          get id() {
            return e
          },
          get notebookType() {
            return g.notebookType
          },
          onDidChangeSelectedNotebooks: h.event,
          get label() {
            return g.label
          },
          set label(q) {
            ;(g.label = q ?? t.displayName ?? t.name), $()
          },
          get detail() {
            return g.detail ?? ""
          },
          set detail(q) {
            ;(g.detail = q), $()
          },
          get description() {
            return g.description ?? ""
          },
          set description(q) {
            ;(g.description = q), $()
          },
          get supportedLanguages() {
            return g.supportedLanguages
          },
          set supportedLanguages(q) {
            ;(g.supportedLanguages = q), $()
          },
          get supportsExecutionOrder() {
            return g.supportsExecutionOrder ?? !1
          },
          set supportsExecutionOrder(q) {
            ;(g.supportsExecutionOrder = q), $()
          },
          get rendererScripts() {
            return g.preloads ? g.preloads.map(wA.to) : []
          },
          get executeHandler() {
            return w
          },
          set executeHandler(q) {
            w = q ?? l
          },
          get interruptHandler() {
            return T
          },
          set interruptHandler(q) {
            ;(T = q), (g.supportsInterrupt = !!q), $()
          },
          set variableProvider(q) {
            F(t, "notebookVariableProvider"),
              (b = q),
              (g.hasVariableProvider = !!q),
              q?.onDidChangeVariables((V) => u.a.$variablesUpdated(V.uri)),
              $()
          },
          get variableProvider() {
            return b
          },
          createNotebookCellExecution(q) {
            if (m) throw new Error("notebook controller is DISPOSED")
            if (!L.has(q.notebook.uri))
              throw (
                (u.q.trace(
                  `NotebookController[${c}] NOT associated to notebook, associated to THESE notebooks:`,
                  Array.from(L.keys()).map((V) => V.toString()),
                ),
                new Error(
                  `notebook controller is NOT associated to notebook: ${q.notebook.uri.toString()}`,
                ))
              )
            return u._createNotebookCellExecution(q, $8(t.identifier, this.id))
          },
          createNotebookExecution(q) {
            if ((F(t, "notebookExecution"), m))
              throw new Error("notebook controller is DISPOSED")
            if (!L.has(q.uri))
              throw (
                (u.q.trace(
                  `NotebookController[${c}] NOT associated to notebook, associated to THESE notebooks:`,
                  Array.from(L.keys()).map((V) => V.toString()),
                ),
                new Error(
                  `notebook controller is NOT associated to notebook: ${q.uri.toString()}`,
                ))
              )
            return u._createNotebookExecution(q, $8(t.identifier, this.id))
          },
          dispose: () => {
            m ||
              (this.q.trace(`NotebookController[${c}], DISPOSED`),
              (m = !0),
              this.j.delete(c),
              h.dispose(),
              p.dispose(),
              this.a.$removeKernel(c))
          },
          updateNotebookAffinity(q, V) {
            V === B6.Hidden && F(t, "notebookControllerAffinityHidden"),
              u.a.$updateNotebookPriority(c, q.uri, V)
          },
          onDidReceiveMessage: p.event,
          postMessage(q, V) {
            return (
              F(t, "notebookMessaging"),
              u.a.$postMessage(c, V && u.n.getIdByEditor(V), q)
            )
          },
          asWebviewUri(q) {
            return F(t, "notebookMessaging"), Xd(q, u.m.remote)
          },
        }
      return (
        this.j.set(c, {
          extensionId: t.identifier,
          controller: U,
          onDidReceiveMessage: p,
          onDidChangeSelection: h,
          associatedNotebooks: L,
        }),
        U
      )
    }
    getIdByController(t) {
      for (const [e, r] of this.j)
        if (r.controller === t) return $8(r.extensionId, t.id)
      return null
    }
    createNotebookControllerDetectionTask(t, e) {
      const r = this.g++,
        s = this
      this.q.trace(
        `NotebookControllerDetectionTask[${r}], CREATED by ${t.identifier.value}`,
      ),
        this.a.$addKernelDetectionTask(r, e)
      const a = {
        dispose: () => {
          this.f.delete(r), s.a.$removeKernelDetectionTask(r)
        },
      }
      return this.f.set(r, a), a
    }
    registerKernelSourceActionProvider(t, e, r) {
      const s = this.i++,
        a =
          typeof r.onDidChangeNotebookKernelSourceActions == "function"
            ? s
            : void 0,
        o = this
      this.h.set(s, r),
        this.q.trace(
          `NotebookKernelSourceActionProvider[${s}], CREATED by ${t.identifier.value}`,
        ),
        this.a.$addKernelSourceActionProvider(s, s, e)
      let c
      return (
        a !== void 0 &&
          (c = r.onDidChangeNotebookKernelSourceActions((u) =>
            this.a.$emitNotebookKernelSourceActionsChangeEvent(a),
          )),
        {
          dispose: () => {
            this.h.delete(s),
              o.a.$removeKernelSourceActionProvider(s, s),
              c?.dispose()
          },
        }
      )
    }
    async $provideKernelSourceActions(t, e) {
      const r = this.h.get(t)
      if (r) {
        const s = new bt()
        return ((await r.provideNotebookKernelSourceActions(e)) ?? []).map(
          (o) => lq.from(o, this.o.converter, s),
        )
      }
      return []
    }
    $acceptNotebookAssociation(t, e, r) {
      const s = this.j.get(t)
      if (s) {
        const a = this.n.getNotebookDocument(S.revive(e))
        r
          ? s.associatedNotebooks.set(a.uri, !0)
          : s.associatedNotebooks.delete(a.uri),
          this.q.trace(
            `NotebookController[${t}] ASSOCIATE notebook`,
            a.uri.toString(),
            r,
          ),
          s.onDidChangeSelection.fire({ selected: r, notebook: a.apiNotebook })
      }
    }
    async $executeCells(t, e, r) {
      const s = this.j.get(t)
      if (!s) return
      const a = this.n.getNotebookDocument(S.revive(e)),
        o = []
      for (const c of r) {
        const u = a.getCell(c)
        u && o.push(u.apiCell)
      }
      try {
        this.q.trace(
          `NotebookController[${t}] EXECUTE cells`,
          a.uri.toString(),
          o.length,
        ),
          await s.controller.executeHandler.call(
            s.controller,
            o,
            a.apiNotebook,
            s.controller,
          )
      } catch (c) {
        this.q.error(`NotebookController[${t}] execute cells FAILED`, c),
          console.error(c)
      }
    }
    async $cancelCells(t, e, r) {
      const s = this.j.get(t)
      if (!s) return
      const a = this.n.getNotebookDocument(S.revive(e))
      if (s.controller.interruptHandler)
        await s.controller.interruptHandler.call(s.controller, a.apiNotebook)
      else
        for (const o of r) {
          const c = a.getCell(o)
          c && this.b.get(c.uri)?.cancel()
        }
      if (s.controller.interruptHandler) {
        const o = this.c.get(a.uri)
        this.c.delete(a.uri),
          r.length &&
            Array.isArray(o) &&
            o.length &&
            o.forEach((c) => c.dispose())
      }
    }
    async $provideVariables(t, e, r, s, a, o, c) {
      const u = this.j.get(t)
      if (!u) return
      const l = this.n.getNotebookDocument(S.revive(r)),
        m = u.controller.variableProvider
      if (!m) return
      let h
      if (s !== void 0) {
        if (((h = this.s[s]), !h)) return
      } else this.s = {}
      const p = a === "named" ? Fl.Named : Fl.Indexed,
        g = m.provideVariables(l.apiNotebook, h, p, o, c)
      let w = 0
      for await (const T of g) {
        if (c.isCancellationRequested) return
        const b = {
          id: this.r++,
          name: T.variable.name,
          value: T.variable.value,
          type: T.variable.type,
          interfaces: T.variable.interfaces,
          language: T.variable.language,
          expression: T.variable.expression,
          hasNamedChildren: T.hasNamedChildren,
          indexedChildrenCount: T.indexedChildrenCount,
          extensionId: u.extensionId.value,
        }
        if (
          ((this.s[b.id] = T.variable),
          this.a.$receiveVariable(e, b),
          w++ >= KAt)
        )
          return
      }
    }
    $acceptKernelMessageFromRenderer(t, e, r) {
      const s = this.j.get(t)
      if (!s) return
      const a = this.n.getEditorById(e)
      s.onDidReceiveMessage.fire(
        Object.freeze({ editor: a.apiEditor, message: r }),
      )
    }
    $cellExecutionChanged(t, e, r) {
      const a = this.n.getNotebookDocument(S.revive(t)).getCell(e)
      if (a) {
        const o = r ? cq.to(r) : Xo.Idle
        o !== void 0 && this.l.fire({ cell: a.apiCell, state: o })
      }
    }
    _createNotebookCellExecution(t, e) {
      if (t.index < 0)
        throw new Error(
          "CANNOT execute cell that has been REMOVED from notebook",
        )
      const s = this.n.getNotebookDocument(t.notebook.uri).getCellFromApiCell(t)
      if (!s) throw new Error("invalid cell")
      if (this.b.has(s.uri)) throw new Error(`duplicate execution for ${s.uri}`)
      const a = new ZAt(e, s, this.a)
      this.b.set(s.uri, a)
      const o = a.onDidChangeState(() => {
        a.state === Wr.Resolved &&
          (a.dispose(), o.dispose(), this.b.delete(s.uri))
      })
      return a.asApiObject()
    }
    _createNotebookExecution(t, e) {
      const r = this.n.getNotebookDocument(t.uri),
        s = t.getCells().find((c) => {
          const u = r.getCellFromApiCell(c)
          return u && this.b.has(u.uri)
        })
      if (s) throw new Error(`duplicate cell execution for ${s.document.uri}`)
      if (this.c.has(r.uri))
        throw new Error(`duplicate notebook execution for ${r.uri}`)
      const a = new e7t(e, r, this.a),
        o = a.onDidChangeState(() => {
          a.state === zn.Resolved &&
            (a.dispose(), o.dispose(), this.c.delete(r.uri))
        })
      return this.c.set(r.uri, [a, o]), a.asApiObject()
    }
  }
WM = __decorate([__param(4, Kt)], WM)
var Wr
;(function (i) {
  ;(i[(i.Init = 0)] = "Init"),
    (i[(i.Started = 1)] = "Started"),
    (i[(i.Resolved = 2)] = "Resolved")
})(Wr || (Wr = {}))
var ZAt = class hst extends dt {
  static {
    this.a = 0
  }
  get state() {
    return this.f
  }
  constructor(t, e, r) {
    super(),
      (this.m = e),
      (this.n = r),
      (this.b = hst.a++),
      (this.c = new C()),
      (this.onDidChangeState = this.c.event),
      (this.f = Wr.Init),
      (this.g = this.D(new Ie())),
      (this.h = new i7t(10, (s) => this.r(s))),
      (this.j = e.internalMetadata.executionOrder),
      this.n.$createExecution(this.b, t, this.m.notebook.uri, this.m.handle)
  }
  cancel() {
    this.g.cancel()
  }
  async q(t) {
    await this.h.addItem(t)
  }
  async r(t) {
    const e = Array.isArray(t) ? t : [t]
    return this.n.$updateExecution(this.b, new Xi(e))
  }
  s() {
    if (this.f === Wr.Init)
      throw new Error("Must call start before modifying cell output")
    if (this.f === Wr.Resolved)
      throw new Error("Cannot modify cell output after calling resolve")
  }
  t(t) {
    let e = this.m
    if ((t && (e = this.m.notebook.getCellFromApiCell(t)), !e))
      throw new Error("INVALID cell")
    return e.handle
  }
  w(t) {
    return t.map((e) => {
      const r = F6.ensureUniqueMimeTypes(e.items, !0)
      return r === e.items
        ? ks.from(e)
        : ks.from({ items: r, id: e.id, metadata: e.metadata })
    })
  }
  async y(t, e, r) {
    const s = this.t(e),
      a = this.w(Yr(t))
    return this.q({ editType: Vc.Output, cellHandle: s, append: r, outputs: a })
  }
  async z(t, e, r) {
    return (
      (t = F6.ensureUniqueMimeTypes(Yr(t), !0)),
      this.q({
        editType: Vc.OutputItems,
        items: t.map(lc.from),
        outputId: e.id,
        append: r,
      })
    )
  }
  asApiObject() {
    const t = this
    return Object.freeze({
      get token() {
        return t.g.token
      },
      get cell() {
        return t.m.apiCell
      },
      get executionOrder() {
        return t.j
      },
      set executionOrder(r) {
        ;(t.j = r), t.r([{ editType: Vc.ExecutionState, executionOrder: t.j }])
      },
      start(r) {
        if (t.f === Wr.Resolved || t.f === Wr.Started)
          throw new Error("Cannot call start again")
        ;(t.f = Wr.Started),
          t.c.fire(),
          t.r({ editType: Vc.ExecutionState, runStartTime: r })
      },
      end(r, s, a) {
        if (t.f === Wr.Resolved) throw new Error("Cannot call resolve twice")
        ;(t.f = Wr.Resolved), t.c.fire(), t.h.flush()
        const o = t7t(a)
        t.n.$completeExecution(
          t.b,
          new Xi({ runEndTime: s, lastRunSuccess: r, error: o }),
        )
      },
      clearOutput(r) {
        return t.s(), t.y([], r, !1)
      },
      appendOutput(r, s) {
        return t.s(), t.y(r, s, !0)
      },
      replaceOutput(r, s) {
        return t.s(), t.y(r, s, !1)
      },
      appendOutputItems(r, s) {
        return t.s(), t.z(r, s, !0)
      },
      replaceOutputItems(r, s) {
        return t.s(), t.z(r, s, !1)
      },
    })
  }
}
function t7t(i) {
  const t = (s) =>
      s
        ? {
            startLineNumber: s.start.line,
            startColumn: s.start.character,
            endLineNumber: s.end.line,
            endColumn: s.end.character,
          }
        : void 0,
    e = (s) => ({ uri: s.uri, position: s.position, label: s.label })
  return i
    ? {
        name: i.name,
        message: i.message,
        stack: i.stack instanceof Array ? i.stack.map((s) => e(s)) : i.stack,
        location: t(i.location),
        uri: i.uri,
      }
    : void 0
}
var zn
;(function (i) {
  ;(i[(i.Init = 0)] = "Init"),
    (i[(i.Started = 1)] = "Started"),
    (i[(i.Resolved = 2)] = "Resolved")
})(zn || (zn = {}))
var e7t = class fst extends dt {
    static {
      this.a = 0
    }
    get state() {
      return this.f
    }
    constructor(t, e, r) {
      super(),
        (this.h = e),
        (this.j = r),
        (this.b = fst.a++),
        (this.c = new C()),
        (this.onDidChangeState = this.c.event),
        (this.f = zn.Init),
        (this.g = this.D(new Ie())),
        this.j.$createNotebookExecution(this.b, t, this.h.uri)
    }
    cancel() {
      this.g.cancel()
    }
    asApiObject() {
      return Object.freeze({
        start: () => {
          if (this.f === zn.Resolved || this.f === zn.Started)
            throw new Error("Cannot call start again")
          ;(this.f = zn.Started),
            this.c.fire(),
            this.j.$beginNotebookExecution(this.b)
        },
        end: () => {
          if (this.f === zn.Resolved)
            throw new Error("Cannot call resolve twice")
          ;(this.f = zn.Resolved),
            this.c.fire(),
            this.j.$completeNotebookExecution(this.b)
        },
      })
    }
  },
  i7t = class {
    constructor(i, t) {
      ;(this.f = i), (this.g = t), (this.a = []), (this.b = Date.now())
    }
    addItem(i) {
      return (
        this.a.push(i),
        this.c ||
          ((this.c = new go()),
          (this.b = Date.now()),
          Kr(this.f).then(() => this.flush())),
        Date.now() - this.b > this.f ? this.flush() : this.c.p
      )
    }
    flush() {
      if (this.a.length === 0 || !this.c) return Promise.resolve()
      const i = this.c
      this.c = void 0
      const t = this.a
      return (this.a = []), this.g(t).finally(() => i.complete())
    }
  }
function $8(i, t) {
  return `${i.value}/${t}`
}
var r7t = class {
    constructor(i, t) {
      ;(this.c = t),
        (this.a = new Map()),
        (this.b = i.getProxy(z.MainThreadNotebookRenderers))
    }
    $postRendererMessage(i, t, e) {
      const r = this.c.getEditorById(i)
      this.a.get(t)?.fire({ editor: r.apiEditor, message: e })
    }
    createRendererMessaging(i, t) {
      if (!i.contributes?.notebookRenderer?.some((r) => r.id === t))
        throw new Error(
          `Extensions may only call createRendererMessaging() for renderers they contribute (got ${t})`,
        )
      return {
        onDidReceiveMessage: (r, s, a) => this.d(t).event(r, s, a),
        postMessage: (r, s) => {
          DM.apiEditorsToExtHost.has(r) && ([r, s] = [s, r])
          const a = s && DM.apiEditorsToExtHost.get(s)
          return this.b.$postMessage(a?.id, t, r)
        },
      }
    }
    d(i) {
      let t = this.a.get(i)
      return (
        t ||
        ((t = new C({
          onDidRemoveLastListener: () => {
            t?.dispose(), this.a.delete(i)
          },
        })),
        this.a.set(i, t),
        t)
      )
    }
  },
  n7t = class {
    constructor(i) {
      ;(this.b = new Map()),
        (this.a = i.getProxy(z.MainThreadProfileContentHandlers))
    }
    registerProfileContentHandler(i, t, e) {
      if ((F(i, "profileContentHandlers"), this.b.has(t)))
        throw new Error(`Handler with id '${t}' already registered`)
      return (
        this.b.set(t, e),
        this.a.$registerProfileContentHandler(
          t,
          e.name,
          e.description,
          i.identifier.value,
        ),
        it(() => {
          this.b.delete(t), this.a.$unregisterProfileContentHandler(t)
        })
      )
    }
    async $saveProfile(i, t, e, r) {
      const s = this.b.get(i)
      if (!s) throw new Error(`Unknown handler with id: ${i}`)
      return s.saveProfile(t, e, r)
    }
    async $readProfile(i, t, e) {
      const r = this.b.get(i)
      if (!r) throw new Error(`Unknown handler with id: ${i}`)
      return r.readProfile(Bt(t) ? t : S.revive(t), e)
    }
  },
  s7t = class {
    constructor(i) {
      ;(this.b = 0), (this.c = new Map()), (this.a = i)
    }
    async withProgress(i, t, e) {
      const r = this.b++,
        { title: s, location: a, cancellable: o } = t,
        c = { label: i.displayName || i.name, id: i.identifier.value }
      return (
        this.a
          .$startProgress(
            r,
            { location: aq.from(a), title: s, source: c, cancellable: o },
            i.isUnderDevelopment ? void 0 : i.identifier.value,
          )
          .catch(eB),
        this.d(r, e, !!o)
      )
    }
    d(i, t, e) {
      let r
      e && ((r = new Ie()), this.c.set(i, r))
      const s = (o) => {
        this.a.$progressEnd(o), this.c.delete(o), r?.dispose()
      }
      let a
      try {
        a = t(new _rt(this.a, i), e && r ? r.token : fe.None)
      } catch (o) {
        throw (s(i), o)
      }
      return (
        a.then(
          (o) => s(i),
          (o) => s(i),
        ),
        a
      )
    }
    $acceptProgressCanceled(i) {
      const t = this.c.get(i)
      t && (t.cancel(), this.c.delete(i))
    }
  }
function a7t(i, t) {
  return (
    (i.message = t.message),
    typeof t.increment == "number" &&
      (typeof i.increment == "number"
        ? (i.increment += t.increment)
        : (i.increment = t.increment)),
    i
  )
}
var _rt = class extends $X {
  constructor(i, t) {
    super((e) => this.throttledReport(e)), (this.c = i), (this.d = t)
  }
  throttledReport(i) {
    this.c.$progressReport(this.d, i)
  }
}
__decorate(
  [
    u0t(
      100,
      (i, t) => a7t(i, t),
      () => Object.create(null),
    ),
  ],
  _rt.prototype,
  "throttledReport",
  null,
)
var o7t = class pst {
  static {
    this.a = 0
  }
  constructor(t, e) {
    ;(this.d = e),
      (this.c = new Map()),
      (this.b = t.getProxy(z.MainThreadQuickDiff))
  }
  $provideOriginalResource(t, e, r) {
    const s = S.revive(e),
      a = this.c.get(t)
    return a
      ? gi(() => a.provideOriginalResource(s, r)).then((o) => o || null)
      : Promise.resolve(null)
  }
  registerQuickDiffProvider(t, e, r, s) {
    const a = pst.a++
    return (
      this.c.set(a, e),
      this.b.$registerQuickDiffProvider(
        a,
        ec.from(t, this.d),
        r,
        s,
        e.visible ?? !0,
      ),
      {
        dispose: () => {
          this.b.$unregisterQuickDiffProvider(a), this.c.delete(a)
        },
      }
    )
  }
}
function c7t(i, t, e) {
  const r = i.getProxy(z.MainThreadQuickOpen)
  class s {
    constructor(g, w) {
      ;(this.e = new Map()), (this.f = 0), (this.a = g), (this.b = w)
    }
    showQuickPick(g, w, T, b = fe.None) {
      this.c = void 0
      const N = Promise.resolve(w),
        $ = ++this.f,
        L = r.$show(
          $,
          {
            title: T?.title,
            placeHolder: T?.placeHolder,
            matchOnDescription: T?.matchOnDescription,
            matchOnDetail: T?.matchOnDetail,
            ignoreFocusLost: T?.ignoreFocusOut,
            canPickMany: T?.canPickMany,
          },
          b,
        ),
        U = {},
        q = L.then(() => U)
      return Promise.race([q, N])
        .then((V) => {
          if (V === U) return
          const lt = Qe(g, "quickPickItemTooltip")
          return N.then((at) => {
            const et = []
            for (let wt = 0; wt < at.length; wt++) {
              const zt = at[wt]
              if (typeof zt == "string") et.push({ label: zt, handle: wt })
              else if (zt.kind === Dl.Separator)
                et.push({ type: "separator", label: zt.label })
              else {
                zt.tooltip &&
                  !lt &&
                  console.warn(
                    `Extension '${g.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${g.identifier.value}`,
                  )
                const Ct = zt.iconPath ? l(zt.iconPath) : void 0
                et.push({
                  label: zt.label,
                  iconPath: Ct?.iconPath,
                  iconClass: Ct?.iconClass,
                  description: zt.description,
                  detail: zt.detail,
                  picked: zt.picked,
                  alwaysShow: zt.alwaysShow,
                  tooltip: lt ? Jt.fromStrict(zt.tooltip) : void 0,
                  handle: wt,
                })
              }
            }
            return (
              T &&
                typeof T.onDidSelectItem == "function" &&
                (this.c = (wt) => {
                  T.onDidSelectItem(at[wt])
                }),
              r.$setItems($, et),
              L.then((wt) => {
                if (typeof wt == "number") return at[wt]
                if (Array.isArray(wt)) return wt.map((zt) => at[zt])
              })
            )
          })
        })
        .then(void 0, (V) => {
          if (!Xn(V)) return r.$setError($, V), Promise.reject(V)
        })
    }
    $onItemSelected(g) {
      this.c?.(g)
    }
    showInput(g, w = fe.None) {
      return (
        (this.d = g?.validateInput),
        r.$input(g, typeof this.d == "function", w).then(void 0, (T) => {
          if (!Xn(T)) return Promise.reject(T)
        })
      )
    }
    async $validateInput(g) {
      if (!this.d) return
      const w = await this.d(g)
      if (!w || typeof w == "string") return w
      let T
      switch (w.severity) {
        case Qo.Info:
          T = ke.Info
          break
        case Qo.Warning:
          T = ke.Warning
          break
        case Qo.Error:
          T = ke.Error
          break
        default:
          T = w.message ? ke.Error : ke.Ignore
          break
      }
      return { content: w.message, severity: T }
    }
    async showWorkspaceFolderPick(g, w = fe.None) {
      const T = await this.b.executeCommand("_workbench.pickWorkspaceFolder", [
        g,
      ])
      if (!T) return
      const b = await this.a.getWorkspaceFolders2()
      if (b) return b.find((N) => N.uri.toString() === T.uri.toString())
    }
    createQuickPick(g) {
      const w = new m(g, () => this.e.delete(w._id))
      return this.e.set(w._id, w), w
    }
    createInputBox(g) {
      const w = new h(g, () => this.e.delete(w._id))
      return this.e.set(w._id, w), w
    }
    $onDidChangeValue(g, w) {
      this.e.get(g)?._fireDidChangeValue(w)
    }
    $onDidAccept(g) {
      this.e.get(g)?._fireDidAccept()
    }
    $onDidChangeActive(g, w) {
      const T = this.e.get(g)
      T instanceof m && T._fireDidChangeActive(w)
    }
    $onDidChangeSelection(g, w) {
      const T = this.e.get(g)
      T instanceof m && T._fireDidChangeSelection(w)
    }
    $onDidTriggerButton(g, w) {
      this.e.get(g)?._fireDidTriggerButton(w)
    }
    $onDidTriggerItemButton(g, w, T) {
      const b = this.e.get(g)
      b instanceof m && b._fireDidTriggerItemButton(w, T)
    }
    $onDidHide(g) {
      this.e.get(g)?._fireDidHide()
    }
  }
  class a {
    static {
      this.a = 1
    }
    constructor(g, w) {
      ;(this.y = g),
        (this.z = w),
        (this._id = m.a++),
        (this.e = !1),
        (this.f = !1),
        (this.g = !0),
        (this.j = !1),
        (this.k = !0),
        (this.l = ""),
        (this.m = void 0),
        (this.o = []),
        (this.p = new Map()),
        (this.q = new C()),
        (this.r = new C()),
        (this.s = new C()),
        (this.t = new C()),
        (this.v = { id: this._id }),
        (this.w = !1),
        (this.x = [this.s, this.t, this.q, this.r]),
        (this.onDidChangeValue = this.r.event),
        (this.onDidAccept = this.q.event),
        (this.onDidTriggerButton = this.s.event),
        (this.onDidHide = this.t.event)
    }
    get title() {
      return this.b
    }
    set title(g) {
      ;(this.b = g), this.A({ title: g })
    }
    get step() {
      return this.c
    }
    set step(g) {
      ;(this.c = g), this.A({ step: g })
    }
    get totalSteps() {
      return this.d
    }
    set totalSteps(g) {
      ;(this.d = g), this.A({ totalSteps: g })
    }
    get enabled() {
      return this.g
    }
    set enabled(g) {
      ;(this.g = g), this.A({ enabled: g })
    }
    get busy() {
      return this.j
    }
    set busy(g) {
      ;(this.j = g), this.A({ busy: g })
    }
    get ignoreFocusOut() {
      return this.k
    }
    set ignoreFocusOut(g) {
      ;(this.k = g), this.A({ ignoreFocusOut: g })
    }
    get value() {
      return this.l
    }
    set value(g) {
      ;(this.l = g), this.A({ value: g })
    }
    get valueSelection() {
      return this.m
    }
    set valueSelection(g) {
      ;(this.m = g), this.A({ valueSelection: g })
    }
    get placeholder() {
      return this.n
    }
    set placeholder(g) {
      ;(this.n = g), this.A({ placeholder: g })
    }
    get buttons() {
      return this.o
    }
    set buttons(g) {
      const w = Qe(this.y, "quickInputButtonLocation")
      !w &&
        g.some((T) => T.location) &&
        console.warn(
          `Extension '${this.y.identifier.value}' uses a button location which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${this.y.identifier.value}`,
        ),
        (this.o = g.slice()),
        this.p.clear(),
        g.forEach((T, b) => {
          const N = T === Rl.Back ? -1 : b
          this.p.set(N, T)
        }),
        this.A({
          buttons: g.map((T, b) => ({
            ...l(T.iconPath),
            tooltip: T.tooltip,
            handle: T === Rl.Back ? -1 : b,
            location: w ? T.location : void 0,
          })),
        })
    }
    show() {
      ;(this.e = !0), (this.f = !0), this.A({ visible: !0 })
    }
    hide() {
      ;(this.e = !1), this.A({ visible: !1 })
    }
    _fireDidAccept() {
      this.q.fire()
    }
    _fireDidChangeValue(g) {
      ;(this.l = g), this.r.fire(g)
    }
    _fireDidTriggerButton(g) {
      const w = this.p.get(g)
      w && this.s.fire(w)
    }
    _fireDidHide() {
      this.f && ((this.f = this.e), this.t.fire())
    }
    dispose() {
      this.w ||
        ((this.w = !0),
        this._fireDidHide(),
        (this.x = pn(this.x)),
        this.u && (clearTimeout(this.u), (this.u = void 0)),
        this.z(),
        r.$dispose(this._id))
    }
    A(g) {
      if (!this.w) {
        for (const w of Object.keys(g)) {
          const T = g[w]
          this.v[w] = T === void 0 ? null : T
        }
        "visible" in this.v
          ? (this.u && (clearTimeout(this.u), (this.u = void 0)), this.B())
          : this.e &&
            !this.u &&
            (this.u = setTimeout(() => {
              ;(this.u = void 0), this.B()
            }, 0))
      }
    }
    B() {
      r.$createOrUpdate(this.v), (this.v = { id: this._id })
    }
  }
  function o(p) {
    if (p instanceof Si) return { id: p.id }
    const g = u(p),
      w = c(p)
    return {
      dark: typeof g == "string" ? S.file(g) : g,
      light: typeof w == "string" ? S.file(w) : w,
    }
  }
  function c(p) {
    return typeof p == "object" && "light" in p ? p.light : p
  }
  function u(p) {
    return typeof p == "object" && "dark" in p ? p.dark : p
  }
  function l(p) {
    const g = o(p)
    let w, T
    return (
      "id" in g ? (T = ri.asClassName(g)) : (w = g),
      { iconPath: w, iconClass: T }
    )
  }
  class m extends a {
    constructor(g, w) {
      super(g, w),
        (this.C = []),
        (this.D = new Map()),
        (this.E = new Map()),
        (this.F = !1),
        (this.G = !0),
        (this.H = !0),
        (this.I = !0),
        (this.J = !1),
        (this.K = []),
        (this.L = new C()),
        (this.M = []),
        (this.N = new C()),
        (this.O = new C()),
        (this.onDidChangeActive = this.L.event),
        (this.onDidChangeSelection = this.N.event),
        (this.onDidTriggerItemButton = this.O.event),
        this.x.push(this.L, this.N, this.O),
        this.A({ type: "quickPick" })
    }
    get items() {
      return this.C
    }
    set items(g) {
      ;(this.C = g.slice()),
        this.D.clear(),
        this.E.clear(),
        g.forEach((b, N) => {
          this.D.set(N, b), this.E.set(b, N)
        })
      const w = Qe(this.y, "quickPickItemTooltip"),
        T = []
      for (let b = 0; b < g.length; b++) {
        const N = g[b]
        if (N.kind === Dl.Separator)
          T.push({ type: "separator", label: N.label })
        else {
          N.tooltip &&
            !w &&
            console.warn(
              `Extension '${this.y.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${this.y.identifier.value}`,
            )
          const $ = N.iconPath ? l(N.iconPath) : void 0
          T.push({
            handle: b,
            label: N.label,
            iconPath: $?.iconPath,
            iconClass: $?.iconClass,
            description: N.description,
            detail: N.detail,
            picked: N.picked,
            alwaysShow: N.alwaysShow,
            tooltip: w ? Jt.fromStrict(N.tooltip) : void 0,
            buttons: N.buttons?.map((L, U) => ({
              ...l(L.iconPath),
              tooltip: L.tooltip,
              handle: U,
            })),
          })
        }
      }
      this.A({ items: T })
    }
    get canSelectMany() {
      return this.F
    }
    set canSelectMany(g) {
      ;(this.F = g), this.A({ canSelectMany: g })
    }
    get matchOnDescription() {
      return this.G
    }
    set matchOnDescription(g) {
      ;(this.G = g), this.A({ matchOnDescription: g })
    }
    get matchOnDetail() {
      return this.H
    }
    set matchOnDetail(g) {
      ;(this.H = g), this.A({ matchOnDetail: g })
    }
    get sortByLabel() {
      return this.I
    }
    set sortByLabel(g) {
      ;(this.I = g), this.A({ sortByLabel: g })
    }
    get keepScrollPosition() {
      return this.J
    }
    set keepScrollPosition(g) {
      ;(this.J = g), this.A({ keepScrollPosition: g })
    }
    get activeItems() {
      return this.K
    }
    set activeItems(g) {
      ;(this.K = g.filter((w) => this.E.has(w))),
        this.A({ activeItems: this.K.map((w) => this.E.get(w)) })
    }
    get selectedItems() {
      return this.M
    }
    set selectedItems(g) {
      ;(this.M = g.filter((w) => this.E.has(w))),
        this.A({ selectedItems: this.M.map((w) => this.E.get(w)) })
    }
    _fireDidChangeActive(g) {
      const w = Ge(g.map((T) => this.D.get(T)))
      ;(this.K = w), this.L.fire(w)
    }
    _fireDidChangeSelection(g) {
      const w = Ge(g.map((T) => this.D.get(T)))
      ;(this.M = w), this.N.fire(w)
    }
    _fireDidTriggerItemButton(g, w) {
      const T = this.D.get(g)
      if (!T || !T.buttons || !T.buttons.length) return
      const b = T.buttons[w]
      b && this.O.fire({ button: b, item: T })
    }
  }
  class h extends a {
    constructor(g, w) {
      super(g, w), (this.C = !1), this.A({ type: "inputBox" })
    }
    get password() {
      return this.C
    }
    set password(g) {
      ;(this.C = g), this.A({ password: g })
    }
    get prompt() {
      return this.D
    }
    set prompt(g) {
      ;(this.D = g), this.A({ prompt: g })
    }
    get validationMessage() {
      return this.E
    }
    set validationMessage(g) {
      ;(this.E = g),
        g
          ? typeof g == "string"
            ? this.A({ validationMessage: g, severity: ke.Error })
            : this.A({
                validationMessage: g.message,
                severity: g.severity ?? ke.Error,
              })
          : this.A({ validationMessage: void 0, severity: ke.Ignore })
    }
  }
  return new s(t, e)
}
var Art = new qi(() => {
    const i = new Intl.Collator(void 0, { numeric: !0, sensitivity: "base" })
    return { collator: i, collatorIsNumeric: i.resolvedOptions().numeric }
  }),
  DMt = new qi(() => ({
    collator: new Intl.Collator(void 0, { numeric: !0 }),
  })),
  FMt = new qi(() => ({
    collator: new Intl.Collator(void 0, { numeric: !0, sensitivity: "accent" }),
  }))
function u7t(i, t, e = !1) {
  const r = i || "",
    s = t || "",
    a = Art.value.collator.compare(r, s)
  return Art.value.collatorIsNumeric && a === 0 && r !== s
    ? r < s
      ? -1
      : 1
    : a
}
function l7t(i, t, e = !1) {
  return (
    e || ((i = i && i.toLowerCase()), (t = t && t.toLowerCase())),
    i === t ? 0 : i < t ? -1 : 1
  )
}
function x8(i, t, e = !1) {
  const r = i.split(kr),
    s = t.split(kr),
    a = r.length - 1,
    o = s.length - 1
  let c, u
  for (let l = 0; ; l++) {
    if (((c = a === l), (u = o === l), c && u)) return u7t(r[l], s[l], e)
    if (c) return -1
    if (u) return 1
    const m = l7t(r[l], s[l], e)
    if (m !== 0) return m
  }
}
var jM
function Brt(i) {
  return i instanceof S
}
function d7t(i, t) {
  return i.scheme === Q.file && t.scheme === Q.file && es
    ? i.toString() === t.toString()
    : i.toString().toLowerCase() === t.toString().toLowerCase()
}
function VM(i) {
  if (i)
    return typeof i.iconPath == "string"
      ? S.file(i.iconPath)
      : S.isUri(i.iconPath) || ri.isThemeIcon(i.iconPath)
        ? i.iconPath
        : void 0
}
function Gc(i) {
  if (i) {
    if (S.isUri(i)) return i
    if (ri.isThemeIcon(i)) return i
    {
      const t = i
      return { light: t.light, dark: t.dark }
    }
  } else return
}
function m7t(i) {
  const t = i.references?.map((e) => ({ ...e, icon: Gc(e.icon) }))
  return { ...i, references: t }
}
function GM(i) {
  return i ? { ...i, icon: Gc(i.icon) } : void 0
}
function zM(i, t) {
  if (!i.iconPath && !t.iconPath) return 0
  if (i.iconPath) {
    if (!t.iconPath) return 1
  } else return -1
  const e =
      typeof i.iconPath == "string"
        ? i.iconPath
        : S.isUri(i.iconPath)
          ? i.iconPath.fsPath
          : i.iconPath.id,
    r =
      typeof t.iconPath == "string"
        ? t.iconPath
        : S.isUri(t.iconPath)
          ? t.iconPath.fsPath
          : t.iconPath.id
  return x8(e, r)
}
function h7t(i, t) {
  let e = 0
  if (i.strikeThrough !== t.strikeThrough) return i.strikeThrough ? 1 : -1
  if (i.faded !== t.faded) return i.faded ? 1 : -1
  if (i.tooltip !== t.tooltip)
    return (i.tooltip || "").localeCompare(t.tooltip || "")
  if (((e = zM(i, t)), e !== 0)) return e
  if (i.light && t.light) e = zM(i.light, t.light)
  else {
    if (i.light) return 1
    if (t.light) return -1
  }
  if (e !== 0) return e
  if (i.dark && t.dark) e = zM(i.dark, t.dark)
  else {
    if (i.dark) return 1
    if (t.dark) return -1
  }
  return e
}
function f7t(i, t) {
  if (i.command !== t.command) return i.command < t.command ? -1 : 1
  if (i.title !== t.title) return i.title < t.title ? -1 : 1
  if (i.tooltip !== t.tooltip) {
    if (i.tooltip !== void 0 && t.tooltip !== void 0)
      return i.tooltip < t.tooltip ? -1 : 1
    if (i.tooltip !== void 0) return 1
    if (t.tooltip !== void 0) return -1
  }
  if (i.arguments === t.arguments) return 0
  if (i.arguments)
    if (t.arguments) {
      if (i.arguments.length !== t.arguments.length)
        return i.arguments.length - t.arguments.length
    } else return 1
  else return -1
  for (let e = 0; e < i.arguments.length; e++) {
    const r = i.arguments[e],
      s = t.arguments[e]
    if (r !== s && !(Brt(r) && Brt(s) && d7t(r, s))) return r < s ? -1 : 1
  }
  return 0
}
function Ort(i, t) {
  let e = x8(i.resourceUri.fsPath, t.resourceUri.fsPath, !0)
  if (e !== 0) return e
  if (i.command && t.command) e = f7t(i.command, t.command)
  else {
    if (i.command) return 1
    if (t.command) return -1
  }
  if (e !== 0) return e
  if (i.decorations && t.decorations) e = h7t(i.decorations, t.decorations)
  else {
    if (i.decorations) return 1
    if (t.decorations) return -1
  }
  if (e !== 0) return e
  if (i.multiFileDiffEditorModifiedUri && t.multiFileDiffEditorModifiedUri)
    e = x8(
      i.multiFileDiffEditorModifiedUri.fsPath,
      t.multiFileDiffEditorModifiedUri.fsPath,
      !0,
    )
  else {
    if (i.multiFileDiffEditorModifiedUri) return 1
    if (t.multiFileDiffEditorModifiedUri) return -1
  }
  if (e !== 0) return e
  if (i.multiDiffEditorOriginalUri && t.multiDiffEditorOriginalUri)
    e = x8(
      i.multiDiffEditorOriginalUri.fsPath,
      t.multiDiffEditorOriginalUri.fsPath,
      !0,
    )
  else {
    if (i.multiDiffEditorOriginalUri) return 1
    if (t.multiDiffEditorOriginalUri) return -1
  }
  return e
}
function p7t(i, t) {
  for (let e = 0; e < i.length; e++) if (i[e] !== t[e]) return !1
  return !0
}
function g7t(i, t) {
  return (
    i.command === t.command &&
    i.title === t.title &&
    i.tooltip === t.tooltip &&
    (i.arguments && t.arguments
      ? p7t(i.arguments, t.arguments)
      : i.arguments === t.arguments)
  )
}
function v7t(i, t) {
  return fn(i, t, g7t)
}
var w7t = class {
    #t
    #e
    get value() {
      return this.d
    }
    set value(i) {
      ;(i = i ?? ""), this.#t.$setInputBoxValue(this.m, i), this.o(i)
    }
    get onDidChange() {
      return this.f.event
    }
    get placeholder() {
      return this.g
    }
    set placeholder(i) {
      this.#t.$setInputBoxPlaceholder(this.m, i), (this.g = i)
    }
    get validateInput() {
      return F(this.l, "scmValidation"), this.h
    }
    set validateInput(i) {
      if ((F(this.l, "scmValidation"), i && typeof i != "function"))
        throw new Error(
          `[${this.l.identifier.value}]: Invalid SCM input box validation function`,
        )
      ;(this.h = i), this.#t.$setValidationProviderIsEnabled(this.m, !!i)
    }
    get enabled() {
      return this.j
    }
    set enabled(i) {
      ;(i = !!i),
        this.j !== i &&
          ((this.j = i), this.#t.$setInputBoxEnablement(this.m, i))
    }
    get visible() {
      return this.k
    }
    set visible(i) {
      ;(i = !!i),
        this.k !== i &&
          ((this.k = i), this.#t.$setInputBoxVisibility(this.m, i))
    }
    get document() {
      return F(this.l, "scmTextDocument"), this.#e.getDocument(this.n)
    }
    constructor(i, t, e, r, s) {
      ;(this.l = i),
        (this.m = r),
        (this.n = s),
        (this.d = ""),
        (this.f = new C()),
        (this.g = ""),
        (this.j = !0),
        (this.k = !0),
        (this.#e = t),
        (this.#t = e)
    }
    showValidationMessage(i, t) {
      F(this.l, "scmValidation"), this.#t.$showValidationMessage(this.m, i, t)
    }
    $onInputBoxValueChange(i) {
      this.o(i)
    }
    o(i) {
      ;(this.d = i), this.f.fire(i)
    }
  },
  y7t = class gst {
    static {
      this.d = 0
    }
    get disposed() {
      return this.m
    }
    get id() {
      return this.v
    }
    get label() {
      return this.w
    }
    set label(t) {
      ;(this.w = t), this.s.$updateGroupLabel(this.u, this.handle, t)
    }
    get hideWhenEmpty() {
      return this.q
    }
    set hideWhenEmpty(t) {
      ;(this.q = t), this.s.$updateGroup(this.u, this.handle, this.features)
    }
    get features() {
      return { hideWhenEmpty: this.hideWhenEmpty }
    }
    get resourceStates() {
      return [...this.g]
    }
    set resourceStates(t) {
      ;(this.g = [...t]), this.l.fire()
    }
    constructor(t, e, r, s, a, o, c) {
      ;(this.s = t),
        (this.t = e),
        (this.u = r),
        (this.v = s),
        (this.w = a),
        (this.multiDiffEditorEnableViewChanges = o),
        (this.x = c),
        (this.f = 0),
        (this.g = []),
        (this.h = new Map()),
        (this.j = new Map()),
        (this.k = new Map()),
        (this.l = new C()),
        (this.onDidUpdateResourceStates = this.l.event),
        (this.m = !1),
        (this.n = new C()),
        (this.onDidDispose = this.n.event),
        (this.o = []),
        (this.p = []),
        (this.q = void 0),
        (this.handle = gst.d++)
    }
    getResourceState(t) {
      return this.h.get(t)
    }
    $executeResourceCommand(t, e) {
      const r = this.j.get(t)
      return r
        ? gi(() => this.t.executeCommand(r.command, ...(r.arguments || []), e))
        : Promise.resolve(void 0)
    }
    _takeResourceStateSnapshot() {
      const t = [...this.g].sort(Ort),
        r = JH(this.p, t, Ort).map((o) => {
          const c = o.toInsert.map((u) => {
            const l = this.f++
            this.h.set(l, u)
            const m = u.resourceUri
            let h
            if (u.command)
              if (
                u.command.command === "vscode.open" ||
                u.command.command === "vscode.diff" ||
                u.command.command === "vscode.changes"
              ) {
                const at = new bt()
                ;(h = this.t.converter.toInternal(u.command, at)),
                  this.k.set(l, at)
              } else this.j.set(l, u.command)
            const p = Qe(this.x, "scmMultiDiffEditor"),
              g = p ? u.multiDiffEditorOriginalUri : void 0,
              w = p ? u.multiFileDiffEditorModifiedUri : void 0,
              T = VM(u.decorations),
              b = (u.decorations && VM(u.decorations.light)) || T,
              N = (u.decorations && VM(u.decorations.dark)) || T,
              $ = [b, N],
              L = (u.decorations && u.decorations.tooltip) || "",
              U = u.decorations && !!u.decorations.strikeThrough,
              q = u.decorations && !!u.decorations.faded,
              V = u.contextValue || ""
            return { rawResource: [l, m, $, L, U, q, V, h, g, w], handle: l }
          })
          return { start: o.start, deleteCount: o.deleteCount, toInsert: c }
        }),
        s = r.map(({ start: o, deleteCount: c, toInsert: u }) => [
          o,
          c,
          u.map((l) => l.rawResource),
        ]),
        a = r.reverse()
      for (const { start: o, deleteCount: c, toInsert: u } of a) {
        const l = u.map((h) => h.handle),
          m = this.o.splice(o, c, ...l)
        for (const h of m)
          this.h.delete(h),
            this.j.delete(h),
            this.k.get(h)?.dispose(),
            this.k.delete(h)
      }
      return (this.p = t), s
    }
    dispose() {
      ;(this.m = !0), this.n.fire()
    }
  },
  YM = class vst {
    static {
      this.d = 0
    }
    #t
    get id() {
      return this.A
    }
    get label() {
      return this.B
    }
    get rootUri() {
      return this.C
    }
    get inputBox() {
      return this.g
    }
    get count() {
      return this.h
    }
    set count(t) {
      this.h !== t &&
        ((this.h = t), this.#t.$updateSourceControl(this.x, { count: t }))
    }
    get remotes() {
      return this.j
    }
    set remotes(t) {
      ;(this.j = t), this.#t.$updateSourceControl(this.x, { remotes: t })
    }
    get quickDiffProvider() {
      return this.k
    }
    set quickDiffProvider(t) {
      this.k = t
      let e
      Qe(this.y, "quickDiffProvider") && (e = t?.label),
        this.#t.$updateSourceControl(this.x, {
          hasQuickDiffProvider: !!t,
          quickDiffLabel: e,
        })
    }
    get historyProvider() {
      return F(this.y, "scmHistoryProvider"), this.l
    }
    set historyProvider(t) {
      F(this.y, "scmHistoryProvider"),
        (this.l = t),
        (this.m.value = new bt()),
        this.#t.$updateSourceControl(this.x, { hasHistoryProvider: !!t }),
        t &&
          (this.m.value.add(
            t.onDidChangeCurrentHistoryItemRefs(() => {
              const e = GM(t?.currentHistoryItemRef),
                r = GM(t?.currentHistoryItemRemoteRef),
                s = GM(t?.currentHistoryItemBaseRef)
              this.#t.$onDidChangeHistoryProviderCurrentHistoryItemRefs(
                this.x,
                e,
                r,
                s,
              )
            }),
          ),
          this.m.value.add(
            t.onDidChangeHistoryItemRefs((e) => {
              if (
                e.added.length === 0 &&
                e.modified.length === 0 &&
                e.removed.length === 0
              )
                return
              const r = e.added.map((o) => ({ ...o, icon: Gc(o.icon) })),
                s = e.modified.map((o) => ({ ...o, icon: Gc(o.icon) })),
                a = e.removed.map((o) => ({ ...o, icon: Gc(o.icon) }))
              this.#t.$onDidChangeHistoryProviderHistoryItemRefs(this.x, {
                added: r,
                modified: s,
                removed: a,
                silent: e.silent,
              })
            }),
          ))
    }
    get commitTemplate() {
      return this.n
    }
    set commitTemplate(t) {
      t !== this.n &&
        ((this.n = t),
        this.#t.$updateSourceControl(this.x, { commitTemplate: t }))
    }
    get acceptInputCommand() {
      return this.p
    }
    set acceptInputCommand(t) {
      ;(this.o.value = new bt()), (this.p = t)
      const e = this.z.converter.toInternal(t, this.o.value)
      this.#t.$updateSourceControl(this.x, { acceptInputCommand: e })
    }
    get actionButton() {
      return F(this.y, "scmActionButton"), this.s
    }
    set actionButton(t) {
      if ((F(this.y, "scmActionButton"), b3(this.s, t))) return
      ;(this.s = t), (this.q.value = new bt())
      const e =
        t !== void 0
          ? {
              command: {
                ...this.z.converter.toInternal(t.command, this.q.value),
                shortTitle: t.command.shortTitle,
              },
              secondaryCommands: t.secondaryCommands?.map((r) =>
                r.map((s) => this.z.converter.toInternal(s, this.q.value)),
              ),
              enabled: t.enabled,
            }
          : void 0
      this.#t.$updateSourceControl(this.x, { actionButton: e ?? null })
    }
    get statusBarCommands() {
      return this.u
    }
    set statusBarCommands(t) {
      if (this.u && t && v7t(this.u, t)) return
      ;(this.t.value = new bt()), (this.u = t)
      const e = (t || []).map((r) =>
        this.z.converter.toInternal(r, this.t.value),
      )
      this.#t.$updateSourceControl(this.x, { statusBarCommands: e })
    }
    get selected() {
      return this.v
    }
    constructor(t, e, r, s, a, o, c) {
      ;(this.y = t),
        (this.z = s),
        (this.A = a),
        (this.B = o),
        (this.C = c),
        (this.f = new Map()),
        (this.h = void 0),
        (this.j = void 0),
        (this.k = void 0),
        (this.m = new Zn()),
        (this.n = void 0),
        (this.o = new Zn()),
        (this.p = void 0),
        (this.q = new Zn()),
        (this.t = new Zn()),
        (this.u = void 0),
        (this.v = !1),
        (this.w = new C()),
        (this.onDidChangeSelection = this.w.event),
        (this.x = vst.d++),
        (this.D = new Map()),
        (this.E = new Set()),
        (this.#t = r)
      const u = S.from({
        scheme: Q.vscodeSourceControl,
        path: `${a}/scm${this.x}/input`,
        query: c ? `rootUri=${encodeURIComponent(c.toString())}` : void 0,
      })
      ;(this.g = new w7t(t, e, this.#t, this.x, u)),
        this.#t.$registerSourceControl(this.x, a, o, c, u)
    }
    createResourceGroup(t, e, r) {
      const s =
          Qe(this.y, "scmMultiDiffEditor") &&
          r?.multiDiffEditorEnableViewChanges === !0,
        a = new y7t(this.#t, this.z, this.x, t, e, s, this.y),
        o = Ee.once(a.onDidDispose)(() => this.D.delete(a))
      return this.D.set(a, o), this.eventuallyAddResourceGroups(), a
    }
    eventuallyAddResourceGroups() {
      const t = [],
        e = []
      for (const [r, s] of this.D) {
        s.dispose()
        const a = r.onDidUpdateResourceStates(() => {
          this.E.add(r), this.eventuallyUpdateResourceStates()
        })
        Ee.once(r.onDidDispose)(() => {
          this.E.delete(r),
            a.dispose(),
            this.f.delete(r.handle),
            this.#t.$unregisterGroup(this.x, r.handle)
        }),
          t.push([
            r.handle,
            r.id,
            r.label,
            r.features,
            r.multiDiffEditorEnableViewChanges,
          ])
        const o = r._takeResourceStateSnapshot()
        o.length > 0 && e.push([r.handle, o]), this.f.set(r.handle, r)
      }
      this.#t.$registerGroups(this.x, t, e), this.D.clear()
    }
    eventuallyUpdateResourceStates() {
      const t = []
      this.E.forEach((e) => {
        const r = e._takeResourceStateSnapshot()
        r.length !== 0 && t.push([e.handle, r])
      }),
        t.length > 0 && this.#t.$spliceResourceStates(this.x, t),
        this.E.clear()
    }
    getResourceGroup(t) {
      return this.f.get(t)
    }
    setSelectionState(t) {
      ;(this.v = t), this.w.fire(t)
    }
    dispose() {
      this.o.dispose(),
        this.q.dispose(),
        this.t.dispose(),
        this.f.forEach((t) => t.dispose()),
        this.#t.$unregisterSourceControl(this.x)
    }
  }
__decorate([PU(100)], YM.prototype, "eventuallyAddResourceGroups", null),
  __decorate([PU(100)], YM.prototype, "eventuallyUpdateResourceStates", null)
var QM = class {
  static {
    jM = this
  }
  static {
    this.d = 0
  }
  get onDidChangeActiveProvider() {
    return this.l.event
  }
  constructor(t, e, r, s) {
    ;(this.n = e),
      (this.o = r),
      (this.p = s),
      (this.h = new Map()),
      (this.j = new bn()),
      (this.k = void 0),
      (this.l = new C()),
      (this.f = t.getProxy(z.MainThreadSCM)),
      (this.g = t.getProxy(z.MainThreadTelemetry)),
      e.registerArgumentProcessor({
        processArgument: (a) => {
          if (a && a.$mid === 3) {
            const o = this.h.get(a.sourceControlHandle)
            if (!o) return a
            const c = o.getResourceGroup(a.groupHandle)
            return c ? c.getResourceState(a.handle) : a
          } else if (a && a.$mid === 4) {
            const o = this.h.get(a.sourceControlHandle)
            return o ? o.getResourceGroup(a.groupHandle) : a
          } else if (a && a.$mid === 5) {
            const o = this.h.get(a.handle)
            return o || a
          }
          return a
        },
      })
  }
  registerGitContextProvider(t) {
    return (
      (this.k = t),
      this.f.$registerGitContextProvider(),
      it(() => {
        this.f.$unregisterGitContextProvider(), (this.k = void 0)
      })
    )
  }
  gitStatusWasRun(t) {
    this.f.$gitStatusWasRun(t)
  }
  async $getFullCommit(t) {
    return this.k && (await this.k.getFullCommit(t))
  }
  async $searchAllCommits(t) {
    return this.k && (await this.k.getCommits(t))
  }
  async $searchPRs(t) {
    return this.k && (await this.k.getPullRequests(t))
  }
  async $getFullPR(t) {
    return this.k && (await this.k.getFullPullRequest(t))
  }
  async $getCurrentDiff() {
    return this.k && (await this.k.getCurrentDiff())
  }
  async $getDiffToMain(t) {
    return this.k && (await this.k.getBranchDiff(t))
  }
  async $getDiffRaw() {
    return this.k && (await this.k.getDiffRaw())
  }
  async $getGitRoot(t) {
    return this.k && (await this.k.getGitRoot(t))
  }
  async $getLastCommit() {
    return this.k && (await this.k.getLastCommit())
  }
  async $getLastCommits(t, e) {
    const r = this.k && (await this.k.getLastCommits(t, e))
    return r === void 0 ? [] : r
  }
  async $getFilenamesInCommit(t) {
    return (this.k && (await this.k.getFilenamesInCommit(t))) || []
  }
  async $getGitLineBlame(t, e, r) {
    return this.k && this.k.getGitLineBlame(t, e, r)
  }
  async $getGitFileBlame(t, e) {
    return this.k && this.k.getGitFileBlame(t, e)
  }
  async $getGitUpstreamURL() {
    return this.k && (await this.k.getGitUpstreamURL())
  }
  async $getCommitRawByCommitHash(t, e) {
    return this.k && (await this.k.getCommitRawByCommitHash(t, e))
  }
  async $getFileContentAtRef(t, e, r) {
    return this.k && (await this.k.getFileContentAtRef(t, e, r))
  }
  async $createWorktree(t) {
    return this.k && (await this.k.createWorktree(t))
  }
  async $syncWorktreeToBranch(t, e) {
    return this.k && (await this.k.syncWorktreeToBranch(t, e))
  }
  async $syncBranchToWorktree(t, e) {
    return this.k && (await this.k.syncBranchToWorktree(t, e))
  }
  async $resetWorktreeToDefaultBranch(t) {
    return this.k && (await this.k.resetWorktreeToDefaultBranch(t))
  }
  async $removeWorktree(t) {
    return this.k && (await this.k.removeWorktree(t))
  }
  async $listAllWorktrees() {
    return this.k && (await this.k.listAllWorktrees())
  }
  async $cleanupOldWorktrees() {
    return this.k && (await this.k.cleanupOldWorktrees())
  }
  async $getCurrentBranch() {
    return this.k && (await this.k.getCurrentBranch())
  }
  async $getDefaultBranch() {
    return this.k && (await this.k.getDefaultBranch())
  }
  async $getGitUser() {
    return this.k && (await this.k.getGitUser())
  }
  createSourceControl(t, e, r, s) {
    this.p.trace("ExtHostSCM#createSourceControl", t.identifier.value, e, r, s),
      this.g.$publicLog2("api/scm/createSourceControl", {
        extensionId: t.identifier.value,
      })
    const a = jM.d++,
      o = new YM(t, this.o, this.f, this.n, e, r, s)
    this.h.set(a, o)
    const c = this.j.get(t.identifier) || []
    return c.push(o), this.j.set(t.identifier, c), o
  }
  getLastInputBox(t) {
    this.p.trace("ExtHostSCM#getLastInputBox", t.identifier.value)
    const e = this.j.get(t.identifier),
      r = e && e[e.length - 1]
    return r && r.inputBox
  }
  $provideOriginalResource(t, e, r) {
    const s = S.revive(e)
    this.p.trace("ExtHostSCM#$provideOriginalResource", t, s.toString())
    const a = this.h.get(t)
    return !a ||
      !a.quickDiffProvider ||
      !a.quickDiffProvider.provideOriginalResource
      ? Promise.resolve(null)
      : gi(() => a.quickDiffProvider.provideOriginalResource(s, r)).then(
          (o) => o || null,
        )
  }
  $onInputBoxValueChange(t, e) {
    this.p.trace("ExtHostSCM#$onInputBoxValueChange", t)
    const r = this.h.get(t)
    return r && r.inputBox.$onInputBoxValueChange(e), Promise.resolve(void 0)
  }
  $executeResourceCommand(t, e, r, s) {
    this.p.trace("ExtHostSCM#$executeResourceCommand", t, e, r)
    const a = this.h.get(t)
    if (!a) return Promise.resolve(void 0)
    const o = a.getResourceGroup(e)
    return o ? o.$executeResourceCommand(r, s) : Promise.resolve(void 0)
  }
  $validateInput(t, e, r) {
    this.p.trace("ExtHostSCM#$validateInput", t)
    const s = this.h.get(t)
    return !s || !s.inputBox.validateInput
      ? Promise.resolve(void 0)
      : gi(() => s.inputBox.validateInput(e, r)).then((a) => {
          if (!a) return Promise.resolve(void 0)
          const o = Jt.fromStrict(a.message)
          return o ? Promise.resolve([o, a.type]) : Promise.resolve(void 0)
        })
  }
  $setSelectedSourceControl(t) {
    return (
      this.p.trace("ExtHostSCM#$setSelectedSourceControl", t),
      t !== void 0 && this.h.get(t)?.setSelectionState(!0),
      this.m !== void 0 && this.h.get(this.m)?.setSelectionState(!1),
      (this.m = t),
      Promise.resolve(void 0)
    )
  }
  async $resolveHistoryItemRefsCommonAncestor(t, e, r) {
    try {
      return (
        (await this.h
          .get(t)
          ?.historyProvider?.resolveHistoryItemRefsCommonAncestor(e, r)) ??
        void 0
      )
    } catch (s) {
      this.p.error("ExtHostSCM#$resolveHistoryItemRefsCommonAncestor", s)
      return
    }
  }
  async $provideHistoryItemRefs(t, e, r) {
    try {
      return (
        (
          await this.h.get(t)?.historyProvider?.provideHistoryItemRefs(e, r)
        )?.map((o) => ({ ...o, icon: Gc(o.icon) })) ?? void 0
      )
    } catch (s) {
      this.p.error("ExtHostSCM#$provideHistoryItemRefs", s)
      return
    }
  }
  async $provideHistoryItems(t, e, r) {
    try {
      return (
        (await this.h.get(t)?.historyProvider?.provideHistoryItems(e, r))?.map(
          (o) => m7t(o),
        ) ?? void 0
      )
    } catch (s) {
      this.p.error("ExtHostSCM#$provideHistoryItems", s)
      return
    }
  }
  async $provideHistoryItemChanges(t, e, r, s) {
    try {
      return (
        (await this.h
          .get(t)
          ?.historyProvider?.provideHistoryItemChanges(e, r, s)) ?? void 0
      )
    } catch (a) {
      this.p.error("ExtHostSCM#$provideHistoryItemChanges", a)
      return
    }
  }
}
QM = jM = __decorate([__param(3, Kt)], QM)
var T7t = class wst {
    static {
      this.a = 0
    }
    constructor(t, e) {
      ;(this.d = e),
        (this.c = new Map()),
        (this.b = t.getProxy(z.MainThreadShare))
    }
    async $provideShare(t, e, r) {
      return (
        (await this.c
          .get(t)
          ?.provideShare(
            {
              selection: O.to(e.selection),
              resourceUri: S.revive(e.resourceUri),
            },
            r,
          )) ?? void 0
      )
    }
    registerShareProvider(t, e) {
      const r = wst.a++
      return (
        this.c.set(r, e),
        this.b.$registerShareProvider(
          r,
          ec.from(t, this.d),
          e.id,
          e.label,
          e.priority,
        ),
        {
          dispose: () => {
            this.b.$unregisterShareProvider(r), this.c.delete(r)
          },
        }
      )
    }
  },
  k7t = class yst {
    static {
      this.a = 1
    }
    constructor(t) {
      ;(this.c = new Map()),
        (this.d = new Map()),
        (this.f = new Map()),
        (this.b = t.getProxy(z.MainThreadSpeech))
    }
    async $createSpeechToTextSession(t, e, r) {
      const s = this.c.get(t)
      if (!s) return
      const a = new bt(),
        o = new Ie()
      this.d.set(e, o)
      const c = await s.provideSpeechToTextSession(
        o.token,
        r ? { language: r } : void 0,
      )
      c &&
        (a.add(
          c.onDidChange((u) => {
            o.token.isCancellationRequested ||
              this.b.$emitSpeechToTextEvent(e, u)
          }),
        ),
        a.add(o.token.onCancellationRequested(() => a.dispose())))
    }
    async $cancelSpeechToTextSession(t) {
      this.d.get(t)?.dispose(!0), this.d.delete(t)
    }
    async $createTextToSpeechSession(t, e, r) {
      const s = this.c.get(t)
      if (!s) return
      const a = new bt(),
        o = new Ie()
      this.d.set(e, o)
      const c = await s.provideTextToSpeechSession(
        o.token,
        r ? { language: r } : void 0,
      )
      c &&
        (this.f.set(e, c),
        a.add(
          c.onDidChange((u) => {
            o.token.isCancellationRequested ||
              this.b.$emitTextToSpeechEvent(e, u)
          }),
        ),
        a.add(o.token.onCancellationRequested(() => a.dispose())))
    }
    async $synthesizeSpeech(t, e) {
      this.f.get(t)?.synthesize(e)
    }
    async $cancelTextToSpeechSession(t) {
      this.d.get(t)?.dispose(!0), this.d.delete(t), this.f.delete(t)
    }
    async $createKeywordRecognitionSession(t, e) {
      const r = this.c.get(t)
      if (!r) return
      const s = new bt(),
        a = new Ie()
      this.d.set(e, a)
      const o = await r.provideKeywordRecognitionSession(a.token)
      o &&
        (s.add(
          o.onDidChange((c) => {
            a.token.isCancellationRequested ||
              this.b.$emitKeywordRecognitionEvent(e, c)
          }),
        ),
        s.add(a.token.onCancellationRequested(() => s.dispose())))
    }
    async $cancelKeywordRecognitionSession(t) {
      this.d.get(t)?.dispose(!0), this.d.delete(t)
    }
    registerProvider(t, e, r) {
      const s = yst.a++
      return (
        this.c.set(s, r),
        this.b.$registerProvider(s, e, { extension: t, displayName: t.value }),
        it(() => {
          this.b.$unregisterProvider(s), this.c.delete(s)
        })
      )
    }
  },
  S7t = class Q8 {
    static {
      this.a = 0
    }
    static {
      this.b = new Map([
        [
          "statusBarItem.errorBackground",
          new El("statusBarItem.errorForeground"),
        ],
        [
          "statusBarItem.warningBackground",
          new El("statusBarItem.warningForeground"),
        ],
      ])
    }
    #t
    #e
    constructor(t, e, r, s, a, o = ps.Left, c) {
      if (
        ((this.i = !1),
        (this.k = ""),
        (this.q = new bt()),
        (this.#t = t),
        (this.#e = e),
        a && s)
      ) {
        this.c = kmt(s.identifier, a)
        const u = r.get(this.c)
        u &&
          ((o = u.alignLeft ? ps.Left : ps.Right),
          (c = u.priority),
          (this.j = !0),
          (this.name = u.name),
          (this.text = u.text),
          (this.tooltip = u.tooltip),
          (this.command = u.command),
          (this.accessibilityInformation = u.accessibilityInformation))
      } else this.c = String(Q8.a++)
      ;(this.e = s), (this.f = a), (this.g = o), (this.h = this.u(c))
    }
    u(t) {
      if (os(t))
        return t === Number.POSITIVE_INFINITY
          ? Number.MAX_VALUE
          : t === Number.NEGATIVE_INFINITY
            ? -Number.MAX_VALUE
            : t
    }
    get id() {
      return this.f ?? this.e.identifier.value
    }
    get alignment() {
      return this.g
    }
    get priority() {
      return this.h
    }
    get text() {
      return this.k
    }
    get name() {
      return this.m
    }
    get tooltip() {
      return this.l
    }
    get color() {
      return this.n
    }
    get backgroundColor() {
      return this.o
    }
    get command() {
      return this.r?.fromApi
    }
    get accessibilityInformation() {
      return this.t
    }
    set text(t) {
      ;(this.k = t), this.v()
    }
    set name(t) {
      ;(this.m = t), this.v()
    }
    set tooltip(t) {
      ;(this.l = t), this.v()
    }
    set color(t) {
      ;(this.n = t), this.v()
    }
    set backgroundColor(t) {
      t && !Q8.b.has(t.id) && (t = void 0), (this.o = t), this.v()
    }
    set command(t) {
      this.r?.fromApi !== t &&
        (this.p && this.q.add(this.p),
        (this.p = new bt()),
        typeof t == "string"
          ? (this.r = {
              fromApi: t,
              internal: this.#e.toInternal({ title: "", command: t }, this.p),
            })
          : t
            ? (this.r = { fromApi: t, internal: this.#e.toInternal(t, this.p) })
            : (this.r = void 0),
        this.v())
    }
    set accessibilityInformation(t) {
      ;(this.t = t), this.v()
    }
    show() {
      ;(this.j = !0), this.v()
    }
    hide() {
      clearTimeout(this.s), (this.j = !1), this.#t.$disposeEntry(this.c)
    }
    v() {
      this.i ||
        !this.j ||
        (clearTimeout(this.s),
        (this.s = setTimeout(() => {
          this.s = void 0
          let t
          this.e
            ? this.f
              ? (t = `${this.e.identifier.value}.${this.f}`)
              : (t = this.e.identifier.value)
            : (t = this.f)
          let e
          this.m
            ? (e = this.m)
            : (e = f(2768, null, this.e.displayName || this.e.name))
          let r = this.n
          this.o && (r = Q8.b.get(this.o.id))
          const s = Jt.fromStrict(this.l)
          this.#t.$setEntry(
            this.c,
            t,
            this.e?.identifier.value,
            e,
            this.k,
            s,
            this.r?.internal,
            r,
            this.o,
            this.g === ps.Left,
            this.h,
            this.t,
          ),
            this.q.clear()
        }, 0)))
    }
    dispose() {
      this.hide(), (this.i = !0)
    }
  },
  b7t = class {
    constructor(i) {
      ;(this.b = []),
        (this.a = i.createStatusBarEntry(
          void 0,
          "status.extensionMessage",
          ps.Left,
          Number.MIN_VALUE,
        )),
        (this.a.name = f(2769, null))
    }
    dispose() {
      ;(this.b.length = 0), this.a.dispose()
    }
    setMessage(i) {
      const t = { message: i }
      return (
        this.b.unshift(t),
        this.c(),
        new At(() => {
          const e = this.b.indexOf(t)
          e >= 0 && (this.b.splice(e, 1), this.c())
        })
      )
    }
    c() {
      this.b.length > 0
        ? ((this.a.text = this.b[0].message), this.a.show())
        : this.a.hide()
    }
  },
  E7t = class {
    constructor(i, t) {
      ;(this.e = new Map()),
        (this.a = i.getProxy(z.MainThreadStatusBar)),
        (this.b = t),
        (this.c = new b7t(this))
    }
    $acceptStaticEntries(i) {
      for (const t of i) this.e.set(t.entryId, t)
    }
    createStatusBarEntry(i, t, e, r) {
      return new S7t(this.a, this.b, this.e, i, t, e, r)
    }
    setStatusBarMessage(i, t) {
      const e = this.c.setMessage(i)
      let r
      return (
        typeof t == "number"
          ? (r = setTimeout(() => e.dispose(), t))
          : typeof t < "u" &&
            t.then(
              () => e.dispose(),
              () => e.dispose(),
            ),
        new At(() => {
          e.dispose(), clearTimeout(r)
        })
      )
    }
  },
  I7t = class extends dt {
    constructor(i, t) {
      super(),
        (this.n = t),
        (this.a = new C()),
        (this.b = new C()),
        (this.c = new C()),
        (this.f = new C()),
        (this.g = new C()),
        (this.h = new C()),
        (this.j = new C()),
        (this.onDidChangeTextEditorSelection = this.a.event),
        (this.onDidChangeTextEditorOptions = this.b.event),
        (this.onDidChangeTextEditorVisibleRanges = this.c.event),
        (this.onDidChangeTextEditorViewColumn = this.f.event),
        (this.onDidChangeTextEditorDiffInformation = this.g.event),
        (this.onDidChangeActiveTextEditor = this.h.event),
        (this.onDidChangeVisibleTextEditors = this.j.event),
        (this.m = i.getProxy(z.MainThreadTextEditors)),
        this.D(this.n.onDidChangeVisibleTextEditors((e) => this.j.fire(e))),
        this.D(this.n.onDidChangeActiveTextEditor((e) => this.h.fire(e)))
    }
    getActiveTextEditor() {
      return this.n.activeEditor()
    }
    getVisibleTextEditors(i) {
      const t = this.n.allEditors()
      return i ? t : t.map((e) => e.value)
    }
    async showTextDocument(i, t, e) {
      let r
      typeof t == "number"
        ? (r = { position: Me.from(t), preserveFocus: e })
        : typeof t == "object"
          ? (r = {
              position: Me.from(t.viewColumn),
              preserveFocus: t.preserveFocus,
              selection:
                typeof t.selection == "object" ? O.from(t.selection) : void 0,
              pinned: typeof t.preview == "boolean" ? !t.preview : void 0,
            })
          : (r = { preserveFocus: !1 })
      const s = await this.m.$tryShowTextDocument(i.uri, r),
        a = s && this.n.getEditor(s)
      if (a) return a.value
      throw s
        ? new Error(
            `Could NOT open editor for "${i.uri.toString()}" because another editor opened in the meantime.`,
          )
        : new Error(`Could NOT open editor for "${i.uri.toString()}".`)
    }
    createTextEditorDecorationType(i, t) {
      return new B1t(this.m, i, t).value
    }
    $acceptEditorPropertiesChanged(i, t) {
      const e = this.n.getEditor(i)
      if (!e) throw new Error("unknown text editor")
      if ((t.options && e._acceptOptions(t.options), t.selections)) {
        const r = t.selections.selections.map(Cr.to)
        e._acceptSelections(r)
      }
      if (t.visibleRanges) {
        const r = Ge(t.visibleRanges.map(O.to))
        e._acceptVisibleRanges(r)
      }
      if (
        (t.options &&
          this.b.fire({
            textEditor: e.value,
            options: {
              ...t.options,
              lineNumbers: ac.to(t.options.lineNumbers),
            },
          }),
        t.selections)
      ) {
        const r = Oo.fromValue(t.selections.source),
          s = t.selections.selections.map(Cr.to)
        this.a.fire({ textEditor: e.value, selections: s, kind: r })
      }
      if (t.visibleRanges) {
        const r = Ge(t.visibleRanges.map(O.to))
        this.c.fire({ textEditor: e.value, visibleRanges: r })
      }
    }
    $acceptEditorPositionData(i) {
      for (const t in i) {
        const e = this.n.getEditor(t)
        if (!e) throw new Error("Unknown text editor")
        const r = Me.to(i[t])
        e.value.viewColumn !== r &&
          (e._acceptViewColumn(r),
          this.f.fire({ textEditor: e.value, viewColumn: r }))
      }
    }
    $acceptEditorDiffInformation(i, t) {
      const e = this.n.getEditor(i)
      if (!e) throw new Error("unknown text editor")
      if (!t) {
        e._acceptDiffInformation(void 0),
          this.g.fire({ textEditor: e.value, diffInformation: void 0 })
        return
      }
      const r = this,
        s = t.map((a) => {
          const o = S.revive(a.original),
            c = S.revive(a.modified),
            u = a.changes.map((l) => {
              const [m, h, p, g] = l
              let w
              return (
                m === h
                  ? (w = qo.Addition)
                  : p === g
                    ? (w = qo.Deletion)
                    : (w = qo.Modification),
                {
                  original: { startLineNumber: m, endLineNumberExclusive: h },
                  modified: { startLineNumber: p, endLineNumberExclusive: g },
                  kind: w,
                }
              )
            })
          return Object.freeze({
            documentVersion: a.documentVersion,
            original: o,
            modified: c,
            changes: u,
            get isStale() {
              return r.n.getDocument(c)?.version !== a.documentVersion
            },
          })
        })
      e._acceptDiffInformation(s),
        this.g.fire({ textEditor: e.value, diffInformation: s })
    }
    getDiffInformation(i) {
      return Promise.resolve(this.m.$getDiffInformation(i))
    }
  },
  XM = class {
    constructor(t) {
      ;(this.a = new R6(vs.Dark)), (this.b = new C())
    }
    get activeColorTheme() {
      return this.a
    }
    $onColorThemeChange(t) {
      let e
      switch (t) {
        case "light":
          e = vs.Light
          break
        case "hcDark":
          e = vs.HighContrast
          break
        case "hcLight":
          e = vs.HighContrastLight
          break
        default:
          e = vs.Dark
      }
      ;(this.a = new R6(e)), this.b.fire(this.a)
    }
    get onDidChangeActiveColorTheme() {
      return this.b.event
    }
  }
XM = __decorate([__param(0, Vt)], XM)
var BMt = Y("IExtHostTimeline"),
  P7t = class {
    constructor(i, t) {
      ;(this.b = new Map()),
        (this.c = new Map()),
        (this.a = i.getProxy(z.MainThreadTimeline)),
        t.registerArgumentProcessor({
          processArgument: (e, r) => {
            if (e && e.$mid === 12)
              if (
                this.b.get(e.source) &&
                te.equals(r, this.b.get(e.source)?.extension)
              ) {
                const s = e.uri === void 0 ? void 0 : S.revive(e.uri)
                return this.c.get(e.source)?.get(qrt(s))?.get(e.handle)
              } else return
            return e
          },
        })
    }
    async $getTimeline(i, t, e, r) {
      return this.b.get(i)?.provider.provideTimeline(S.revive(t), e, r)
    }
    registerTimelineProvider(i, t, e, r) {
      const s = new bt(),
        a = this.d(t.id, r, s).bind(this)
      let o
      t.onDidChange &&
        (o = t.onDidChange(
          (u) =>
            this.a.$emitTimelineChangeEvent({
              uri: void 0,
              reset: !0,
              ...u,
              id: t.id,
            }),
          this,
        ))
      const c = this.c
      return this.f(
        {
          ...t,
          scheme: i,
          onDidChange: void 0,
          async provideTimeline(u, l, m) {
            l?.resetCache && (s.clear(), c.get(t.id)?.clear())
            const h = await t.provideTimeline(u, l, m)
            if (h == null) return
            const p = a(u, l)
            return { ...h, source: t.id, items: h.items.map(p) }
          },
          dispose() {
            for (const u of c.values()) u.get(t.id)?.clear()
            o?.dispose(), s.dispose()
          },
        },
        e,
      )
    }
    d(i, t, e) {
      return (r, s) => {
        let a
        if (s?.cacheResults) {
          let o = this.c.get(i)
          o === void 0 && ((o = new Map()), this.c.set(i, o))
          const c = qrt(r)
          ;(a = o.get(c)), a === void 0 && ((a = new Map()), o.set(c, a))
        }
        return (o) => {
          const { iconPath: c, ...u } = o,
            l = `${i}|${o.id ?? o.timestamp}`
          a?.set(l, o)
          let m, h, p
          o.iconPath &&
            (c instanceof Si
              ? (p = { id: c.id, color: c.color })
              : S.isUri(c)
                ? ((m = c), (h = c))
                : ({ light: m, dark: h } = c))
          let g
          return (
            Gi.isMarkdownString(u.tooltip)
              ? (g = Jt.from(u.tooltip))
              : Bt(u.tooltip)
                ? (g = u.tooltip)
                : Gi.isMarkdownString(u.detail)
                  ? (console.warn(
                      "Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip",
                    ),
                    (g = Jt.from(u.detail)))
                  : Bt(u.detail) &&
                    (console.warn(
                      "Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip",
                    ),
                    (g = u.detail)),
            {
              ...u,
              id: u.id ?? void 0,
              handle: l,
              source: i,
              command: o.command ? t.toInternal(o.command, e) : void 0,
              icon: m,
              iconDark: h,
              themeIcon: p,
              tooltip: g,
              accessibilityInformation: o.accessibilityInformation,
            }
          )
        }
      }
    }
    f(i, t) {
      if (this.b.get(i.id))
        throw new Error(`Timeline Provider ${i.id} already exists.`)
      return (
        this.a.$registerTimelineProvider({
          id: i.id,
          label: i.label,
          scheme: i.scheme,
        }),
        this.b.set(i.id, { provider: i, extension: t }),
        it(() => {
          for (const r of this.c.values()) r.get(i.id)?.clear()
          this.b.delete(i.id),
            this.a.$unregisterTimelineProvider(i.id),
            i.dispose()
        })
      )
    }
  }
function qrt(i) {
  return i?.toString()
}
var N7t = { IconContribution: "base.contributions.icons" },
  Urt
;(function (i) {
  function t(e, r) {
    let s = e.defaults
    for (; ri.isThemeIcon(s); ) {
      const a = zc.getIcon(s.id)
      if (!a) return
      s = a.defaults
    }
    return s
  }
  i.getDefinition = t
})(Urt || (Urt = {}))
var Mrt
;(function (i) {
  function t(r) {
    return {
      weight: r.weight,
      style: r.style,
      src: r.src.map((s) => ({
        format: s.format,
        location: s.location.toString(),
      })),
    }
  }
  i.toJSONObject = t
  function e(r) {
    const s = (a) => (Bt(a) ? a : void 0)
    if (
      r &&
      Array.isArray(r.src) &&
      r.src.every((a) => Bt(a.format) && Bt(a.location))
    )
      return {
        weight: s(r.weight),
        style: s(r.style),
        src: r.src.map((a) => ({
          format: a.format,
          location: S.parse(a.location),
        })),
      }
  }
  i.fromJSONObject = e
})(Mrt || (Mrt = {}))
var $7t = class {
    constructor() {
      ;(this.a = new C()),
        (this.onDidChange = this.a.event),
        (this.d = {
          definitions: {
            icons: {
              type: "object",
              properties: {
                fontId: { type: "string", description: f(2415, null) },
                fontCharacter: { type: "string", description: f(2416, null) },
              },
              additionalProperties: !1,
              defaultSnippets: [{ body: { fontCharacter: "\\\\e030" } }],
            },
          },
          type: "object",
          properties: {},
        }),
        (this.e = {
          type: "string",
          pattern: `^${ri.iconNameExpression}$`,
          enum: [],
          enumDescriptions: [],
        }),
        (this.b = {}),
        (this.f = {})
    }
    registerIcon(i, t, e, r) {
      const s = this.b[i]
      if (s) {
        if (e && !s.description) {
          ;(s.description = e),
            (this.d.properties[i].markdownDescription = `${e} $(${i})`)
          const c = this.e.enum.indexOf(i)
          c !== -1 && (this.e.enumDescriptions[c] = e), this.a.fire()
        }
        return s
      }
      const a = { id: i, description: e, defaults: t, deprecationMessage: r }
      this.b[i] = a
      const o = { $ref: "#/definitions/icons" }
      return (
        r && (o.deprecationMessage = r),
        e && (o.markdownDescription = `${e}: $(${i})`),
        (this.d.properties[i] = o),
        this.e.enum.push(i),
        this.e.enumDescriptions.push(e || ""),
        this.a.fire(),
        { id: i }
      )
    }
    deregisterIcon(i) {
      delete this.b[i], delete this.d.properties[i]
      const t = this.e.enum.indexOf(i)
      t !== -1 &&
        (this.e.enum.splice(t, 1), this.e.enumDescriptions.splice(t, 1)),
        this.a.fire()
    }
    getIcons() {
      return Object.keys(this.b).map((i) => this.b[i])
    }
    getIcon(i) {
      return this.b[i]
    }
    getIconSchema() {
      return this.d
    }
    getIconReferenceSchema() {
      return this.e
    }
    registerIconFont(i, t) {
      const e = this.f[i]
      return e || ((this.f[i] = t), this.a.fire(), t)
    }
    deregisterIconFont(i) {
      delete this.f[i]
    }
    getIconFont(i) {
      return this.f[i]
    }
    toString() {
      const i = (s, a) => s.id.localeCompare(a.id),
        t = (s) => {
          for (; ri.isThemeIcon(s.defaults); ) s = this.b[s.defaults.id]
          return `codicon codicon-${s ? s.id : ""}`
        },
        e = []
      e.push(
        "| preview     | identifier                        | default codicon ID                | description",
      ),
        e.push(
          "| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |",
        )
      const r = Object.keys(this.b).map((s) => this.b[s])
      for (const s of r.filter((a) => !!a.description).sort(i))
        e.push(
          `|<i class="${t(s)}"></i>|${s.id}|${ri.isThemeIcon(s.defaults) ? s.defaults.id : s.id}|${s.description || ""}|`,
        )
      e.push("| preview     | identifier                        "),
        e.push("| ----------- | --------------------------------- |")
      for (const s of r.filter((a) => !ri.isThemeIcon(a.defaults)).sort(i))
        e.push(`|<i class="${t(s)}"></i>|${s.id}|`)
      return e.join(`
`)
    }
  },
  zc = new $7t()
ui.add(N7t.IconContribution, zc)
function J8(i, t, e, r) {
  return zc.registerIcon(i, t, e, r)
}
function x7t() {
  const i = Iut()
  for (const t in i) {
    const e = "\\" + i[t].toString(16)
    zc.registerIcon(t, { fontCharacter: e })
  }
}
x7t()
var Hrt = "vscode://schemas/icons",
  Wrt = ui.as(J_.JSONContribution)
Wrt.registerSchema(Hrt, zc.getIconSchema())
var jrt = new po(() => Wrt.notifySchemaChanged(Hrt), 200)
zc.onDidChange(() => {
  jrt.isScheduled() || jrt.schedule()
})
var OMt = J8("widget-close", ut.close, f(2417, null)),
  qMt = J8("goto-previous-location", ut.arrowUp, f(2418, null)),
  UMt = J8("goto-next-location", ut.arrowDown, f(2419, null)),
  MMt = ri.modify(ut.sync, "spin"),
  HMt = ri.modify(ut.loading, "spin"),
  WMt = f(4314, null),
  jMt = J8("default-view-icon", ut.window, f(4315, null)),
  C8
;(function (i) {
  ;(i.ViewContainersRegistry = "workbench.registry.view.containers"),
    (i.ViewsRegistry = "workbench.registry.view")
})(C8 || (C8 = {}))
var Vrt
;(function (i) {
  ;(i[(i.Sidebar = 0)] = "Sidebar"),
    (i[(i.Panel = 1)] = "Panel"),
    (i[(i.AuxiliaryBar = 2)] = "AuxiliaryBar")
})(Vrt || (Vrt = {}))
var J7t = class extends dt {
  constructor() {
    super(...arguments),
      (this.c = this.D(new C())),
      (this.onDidRegister = this.c.event),
      (this.f = this.D(new C())),
      (this.onDidDeregister = this.f.event),
      (this.g = new Map()),
      (this.h = [])
  }
  get all() {
    return [...this.g.values()].flat()
  }
  registerViewContainer(i, t, e) {
    const r = this.get(i.id)
    if (r) return r
    const s = i
    return (
      (s.openCommandActionDescriptor = e?.doNotRegisterOpenCommand
        ? void 0
        : (s.openCommandActionDescriptor ?? { id: s.id })),
      rat(this.g, t, []).push(s),
      e?.isDefault && this.h.push(s),
      this.c.fire({ viewContainer: s, viewContainerLocation: t }),
      s
    )
  }
  deregisterViewContainer(i) {
    for (const t of this.g.keys()) {
      const e = this.g.get(t),
        r = e?.indexOf(i)
      if (r !== -1) {
        e?.splice(r, 1),
          e.length === 0 && this.g.delete(t),
          this.f.fire({ viewContainer: i, viewContainerLocation: t })
        return
      }
    }
  }
  get(i) {
    return this.all.filter((t) => t.id === i)[0]
  }
  getViewContainers(i) {
    return [...(this.g.get(i) || [])]
  }
  getViewContainerLocation(i) {
    return [...this.g.keys()].filter(
      (t) => this.getViewContainers(t).filter((e) => e?.id === i.id).length > 0,
    )[0]
  }
  getDefaultViewContainer(i) {
    return this.h.find((t) => this.getViewContainerLocation(t) === i)
  }
}
ui.add(C8.ViewContainersRegistry, new J7t())
var L8
;(function (i) {
  ;(i.Open = "2_open"),
    (i.Debug = "4_debug"),
    (i.SCM = "5_scm"),
    (i.More = "9_more")
})(L8 || (L8 = {}))
function C7t(i, t) {
  const e = i.group ?? L8.More,
    r = t.group ?? L8.More
  return e !== r ? e.localeCompare(r) : (i.order ?? 5) - (t.order ?? 5)
}
var L7t = class extends dt {
  constructor() {
    super(...arguments),
      (this.c = this.D(new C())),
      (this.onViewsRegistered = this.c.event),
      (this.f = this.D(new C())),
      (this.onViewsDeregistered = this.f.event),
      (this.g = this.D(new C())),
      (this.onDidChangeContainer = this.g.event),
      (this.h = this.D(new C())),
      (this.onDidChangeViewWelcomeContent = this.h.event),
      (this.j = []),
      (this.m = new Map()),
      (this.n = new OH())
  }
  registerViews(i, t) {
    this.registerViews2([{ views: i, viewContainer: t }])
  }
  registerViews2(i) {
    i.forEach(({ views: t, viewContainer: e }) => this.q(t, e)), this.c.fire(i)
  }
  deregisterViews(i, t) {
    const e = this.r(i, t)
    e.length && this.f.fire({ views: e, viewContainer: t })
  }
  moveViews(i, t) {
    for (const e of this.m.keys())
      if (e !== t) {
        const r = this.r(i, e)
        r.length && (this.q(r, t), this.g.fire({ views: r, from: e, to: t }))
      }
  }
  getViews(i) {
    return this.m.get(i) || []
  }
  getView(i) {
    for (const t of this.j) {
      const e = (this.m.get(t) || []).filter((r) => r.id === i)[0]
      if (e) return e
    }
    return null
  }
  getViewContainer(i) {
    for (const t of this.j)
      if ((this.m.get(t) || []).filter((r) => r.id === i)[0]) return t
    return null
  }
  registerViewWelcomeContent(i, t) {
    return (
      this.n.add(i, t),
      this.h.fire(i),
      it(() => {
        this.n.delete(i, t), this.h.fire(i)
      })
    )
  }
  registerViewWelcomeContent2(i, t) {
    const e = new Map()
    for (const [r, s] of t)
      this.n.add(i, s),
        e.set(
          r,
          it(() => {
            this.n.delete(i, s), this.h.fire(i)
          }),
        )
    return this.h.fire(i), e
  }
  getViewWelcomeContent(i) {
    const t = []
    return this.n.forEach(i, (e) => t.push(e)), t.sort(C7t)
  }
  q(i, t) {
    let e = this.m.get(t)
    e || ((e = []), this.m.set(t, e), this.j.push(t))
    for (const r of i) {
      if (this.getView(r.id) !== null) throw new Error(f(4316, null, r.id))
      e.push(r)
    }
  }
  r(i, t) {
    const e = this.m.get(t)
    if (!e) return []
    const r = [],
      s = []
    for (const a of e) i.includes(a) ? r.push(a) : s.push(a)
    return (
      r.length &&
        (s.length
          ? this.m.set(t, s)
          : (this.m.delete(t), this.j.splice(this.j.indexOf(t), 1))),
      r
    )
  }
}
ui.add(C8.ViewsRegistry, new L7t())
var VMt = Y("viewDescriptorService"),
  Grt
;(function (i) {
  ;(i[(i.Default = 0)] = "Default"), (i[(i.Expand = 1)] = "Expand")
})(Grt || (Grt = {}))
var zrt
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Collapsed = 1)] = "Collapsed"),
    (i[(i.Expanded = 2)] = "Expanded")
})(zrt || (zrt = {}))
var Yn = class extends Error {
    constructor(i) {
      super(f(4317, null, i)), (this.name = "NoTreeViewError")
    }
    static is(i) {
      return !!i && i.name === "NoTreeViewError"
    }
  },
  R7t = class {
    constructor() {
      this.a = new Map()
    }
    removeDragOperationTransfer(i) {
      if (i && this.a.has(i)) {
        const t = this.a.get(i)
        return this.a.delete(i), t
      }
    }
    addDragOperationTransfer(i, t) {
      this.a.set(i, t)
    }
  }
function Yrt(i, t) {
  if (Bt(i)) return { label: i }
  if (i && typeof i == "object" && typeof i.label == "string") {
    let e
    return (
      Array.isArray(i.highlights) &&
        ((e = i.highlights.filter(
          (r) =>
            r.length === 2 &&
            typeof r[0] == "number" &&
            typeof r[1] == "number",
        )),
        (e = e.length ? e : void 0)),
      { label: i.label, highlights: e }
    )
  }
}
var D7t = class extends dt {
    constructor(i, t, e) {
      super(),
        (this.f = i),
        (this.g = t),
        (this.h = e),
        (this.a = new Map()),
        (this.b = new R7t())
      function r(s) {
        return (
          s &&
          s.$treeViewId &&
          (s.$treeItemHandle || s.$selectedTreeItems || s.$focusedTreeItem)
        )
      }
      t.registerArgumentProcessor({
        processArgument: (s) =>
          r(s)
            ? this.q(s)
            : Array.isArray(s) && s.length > 0
              ? s.map((a) => (r(a) ? this.q(a) : a))
              : s,
      })
    }
    registerTreeDataProvider(i, t, e) {
      const r = this.createTreeView(i, { treeDataProvider: t }, e)
      return { dispose: () => r.dispose() }
    }
    createTreeView(i, t, e) {
      if (!t || !t.treeDataProvider)
        throw new Error("Options with treeDataProvider is mandatory")
      const r = t.dragAndDropController?.dropMimeTypes ?? [],
        s = t.dragAndDropController?.dragMimeTypes ?? [],
        a = !!t.dragAndDropController?.handleDrag,
        o = !!t.dragAndDropController?.handleDrop,
        c = this.m(i, t, e),
        u = {
          showCollapseAll: !!t.showCollapseAll,
          canSelectMany: !!t.canSelectMany,
          dropMimeTypes: r,
          dragMimeTypes: s,
          hasHandleDrag: a,
          hasHandleDrop: o,
          manuallyManageCheckboxes: !!t.manageCheckboxStateManually,
        },
        l = this.f.$registerTreeViewDataProvider(i, u),
        m = {
          get onDidCollapseElement() {
            return c.onDidCollapseElement
          },
          get onDidExpandElement() {
            return c.onDidExpandElement
          },
          get selection() {
            return c.selectedElements
          },
          get onDidChangeSelection() {
            return c.onDidChangeSelection
          },
          get activeItem() {
            return F(e, "treeViewActiveItem"), c.focusedElement
          },
          get onDidChangeActiveItem() {
            return F(e, "treeViewActiveItem"), c.onDidChangeActiveItem
          },
          get visible() {
            return c.visible
          },
          get onDidChangeVisibility() {
            return c.onDidChangeVisibility
          },
          get onDidChangeCheckboxState() {
            return c.onDidChangeCheckboxState
          },
          get message() {
            return c.message
          },
          set message(h) {
            na(h) && F(e, "treeViewMarkdownMessage"), (c.message = h)
          },
          get title() {
            return c.title
          },
          set title(h) {
            c.title = h
          },
          get description() {
            return c.description
          },
          set description(h) {
            c.description = h
          },
          get badge() {
            return c.badge
          },
          set badge(h) {
            h !== void 0 && mO.isViewBadge(h)
              ? (c.badge = {
                  value: Math.floor(Math.abs(h.value)),
                  tooltip: h.tooltip,
                })
              : h === void 0 && (c.badge = void 0)
          },
          reveal: (h, p) => c.reveal(h, p),
          dispose: async () => {
            await l, this.a.delete(i), c.dispose()
          },
        }
      return this.D(m), m
    }
    async $getChildren(i, t) {
      const e = this.a.get(i)
      if (!e) return Promise.reject(new Yn(i))
      if (!t) {
        const s = await e.getChildren()
        return s ? [[0, ...s]] : void 0
      }
      const r = []
      for (let s = 0; s < t.length; s++) {
        const a = t[s],
          o = await e.getChildren(a)
        o && r.push([s, ...o])
      }
      return r
    }
    async $handleDrop(i, t, e, r, s, a, o, c) {
      const u = this.a.get(i)
      if (!u) return Promise.reject(new Yn(i))
      const l = bs.toDataTransfer(
        e,
        async (m) => (await this.f.$resolveDropFileData(i, t, m)).buffer,
      )
      return o === i && c && (await this.j(l, u, c, s, a)), u.onDrop(l, r, s)
    }
    async j(i, t, e, r, s) {
      const a = this.b.removeDragOperationTransfer(s)
      if (a)
        (await a)?.forEach((o, c) => {
          o && i.set(c, o)
        })
      else if (s && t.handleDrag) {
        const o = t.handleDrag(e, i, r)
        this.b.addDragOperationTransfer(s, o), await o
      }
      return i
    }
    async $handleDrag(i, t, e, r) {
      const s = this.a.get(i)
      if (!s) return Promise.reject(new Yn(i))
      const a = await this.j(new bl(), s, t, r, e)
      if (!(!a || r.isCancellationRequested)) return bs.from(a)
    }
    async $hasResolve(i) {
      const t = this.a.get(i)
      if (!t) throw new Yn(i)
      return t.hasResolve
    }
    $resolve(i, t, e) {
      const r = this.a.get(i)
      if (!r) throw new Yn(i)
      return r.resolveTreeItem(t, e)
    }
    $setExpanded(i, t, e) {
      const r = this.a.get(i)
      if (!r) throw new Yn(i)
      r.setExpanded(t, e)
    }
    $setSelectionAndFocus(i, t, e) {
      const r = this.a.get(i)
      if (!r) throw new Yn(i)
      r.setSelectionAndFocus(t, e)
    }
    $setVisible(i, t) {
      const e = this.a.get(i)
      if (!e) {
        if (!t) return
        throw new Yn(i)
      }
      e.setVisible(t)
    }
    $changeCheckboxState(i, t) {
      const e = this.a.get(i)
      if (!e) throw new Yn(i)
      e.setCheckboxState(t)
    }
    m(i, t, e) {
      const r = this.D(new F7t(i, t, this.f, this.g.converter, this.h, e))
      return this.a.set(i, r), r
    }
    q(i) {
      const t = this.a.get(i.$treeViewId)
      return t && "$treeItemHandle" in i
        ? t.getExtensionElement(i.$treeItemHandle)
        : t && "$focusedTreeItem" in i && i.$focusedTreeItem
          ? t.focusedElement
          : null
    }
  },
  F7t = class NH extends dt {
    static {
      this.a = "0"
    }
    static {
      this.b = "1"
    }
    get visible() {
      return this.q
    }
    get selectedElements() {
      return this.r
        .map((t) => this.getExtensionElement(t))
        .filter((t) => !Le(t))
    }
    get focusedElement() {
      return this.s ? this.getExtensionElement(this.s) : void 0
    }
    constructor(t, e, r, s, a, o) {
      if (
        (super(),
        (this.I = t),
        (this.J = r),
        (this.L = s),
        (this.M = a),
        (this.N = o),
        (this.h = void 0),
        (this.j = new Map()),
        (this.m = new Map()),
        (this.q = !1),
        (this.r = []),
        (this.s = void 0),
        (this.t = this.D(new C())),
        (this.onDidExpandElement = this.t.event),
        (this.u = this.D(new C())),
        (this.onDidCollapseElement = this.u.event),
        (this.w = this.D(new C())),
        (this.onDidChangeSelection = this.w.event),
        (this.y = this.D(new C())),
        (this.onDidChangeActiveItem = this.y.event),
        (this.z = this.D(new C())),
        (this.onDidChangeVisibility = this.z.event),
        (this.C = this.D(new C())),
        (this.onDidChangeCheckboxState = this.C.event),
        (this.F = this.D(new C())),
        (this.G = Promise.resolve()),
        (this.H = Promise.resolve()),
        (this.O = ""),
        (this.P = ""),
        (this.Z = new Ie()),
        o.contributes && o.contributes.views)
      )
        for (const m in o.contributes.views)
          for (const h of o.contributes.views[m])
            h.id === t && (this.P = h.name)
      ;(this.f = e.treeDataProvider),
        (this.g = e.dragAndDropController),
        this.f.onDidChangeTreeData &&
          this.D(
            this.f.onDidChangeTreeData((m) => {
              ;(Array.isArray(m) && m.length === 0) ||
                this.F.fire({ message: !1, element: m })
            }),
          )
      let c, u
      const l = Ee.debounce(
        this.F.event,
        (m, h) => (
          m || (m = { message: !1, elements: [] }),
          h.element !== !1 &&
            (c ||
              ((c = new Promise((p) => (u = p))),
              (this.G = this.G.then(() => c))),
            Array.isArray(h.element)
              ? m.elements.push(...h.element)
              : m.elements.push(h.element)),
          h.message && (m.message = !0),
          m
        ),
        200,
        !0,
      )
      this.D(
        l(({ message: m, elements: h }) => {
          h.length &&
            (this.H = this.H.then(() => {
              const p = u
              return (c = null), this.$(h).then(() => p())
            })),
            m && this.J.$setMessage(this.I, Jt.fromStrict(this.O) ?? "")
        }),
      )
    }
    async getChildren(t) {
      const e = t ? this.getExtensionElement(t) : void 0
      if (t && !e)
        return (
          this.M.error(`No tree item with id '${t}' found.`),
          Promise.resolve([])
        )
      let r = this.X(t)
      return r || (r = await this.Y(e)), r ? r.map((s) => s.item) : void 0
    }
    getExtensionElement(t) {
      return this.j.get(t)
    }
    reveal(t, e) {
      e = e || { select: !0, focus: !1 }
      const r = Le(e.select) ? !0 : e.select,
        s = Le(e.focus) ? !1 : e.focus,
        a = Le(e.expand) ? !1 : e.expand
      return typeof this.f.getParent != "function"
        ? Promise.reject(
            new Error(
              "Required registered TreeDataProvider to implement 'getParent' method to access 'reveal' method",
            ),
          )
        : t
          ? this.G.then(() => this.S(t)).then(
              (o) =>
                this.W(t, o[o.length - 1]).then((c) =>
                  this.J.$reveal(
                    this.I,
                    { item: c.item, parentChain: o.map((u) => u.item) },
                    { select: r, focus: s, expand: a },
                  ),
                ),
              (o) => this.M.error(o),
            )
          : this.J.$reveal(this.I, void 0, { select: r, focus: s, expand: a })
    }
    get message() {
      return this.O
    }
    set message(t) {
      ;(this.O = t), this.F.fire({ message: !0, element: !1 })
    }
    get title() {
      return this.P
    }
    set title(t) {
      ;(this.P = t), this.J.$setTitle(this.I, t, this.Q)
    }
    get description() {
      return this.Q
    }
    set description(t) {
      ;(this.Q = t), this.J.$setTitle(this.I, this.P, t)
    }
    get badge() {
      return this.R
    }
    set badge(t) {
      ;(this.R?.value === t?.value && this.R?.tooltip === t?.tooltip) ||
        ((this.R = yA.from(t)), this.J.$setBadge(this.I, t))
    }
    setExpanded(t, e) {
      const r = this.getExtensionElement(t)
      r &&
        (e
          ? this.t.fire(Object.freeze({ element: r }))
          : this.u.fire(Object.freeze({ element: r })))
    }
    setSelectionAndFocus(t, e) {
      const r = !fn(this.r, t)
      this.r = t
      const s = this.s !== e
      ;(this.s = e),
        r && this.w.fire(Object.freeze({ selection: this.selectedElements })),
        s && this.y.fire(Object.freeze({ activeItem: this.focusedElement }))
    }
    setVisible(t) {
      t !== this.q &&
        ((this.q = t), this.z.fire(Object.freeze({ visible: this.q })))
    }
    async setCheckboxState(t) {
      const e = (
        await Promise.all(
          t.map(async (r) => {
            const s = this.getExtensionElement(r.treeItemHandle)
            return s
              ? {
                  extensionItem: s,
                  treeItem: await this.f.getTreeItem(s),
                  newState: r.newState ? sn.Checked : sn.Unchecked,
                }
              : Promise.resolve(void 0)
          }),
        )
      ).filter((r) => r !== void 0)
      e.forEach((r) => {
        r.treeItem.checkboxState = r.newState ? sn.Checked : sn.Unchecked
      }),
        this.C.fire({ items: e.map((r) => [r.extensionItem, r.newState]) })
    }
    async handleDrag(t, e, r) {
      const s = []
      for (const a of t) {
        const o = this.getExtensionElement(a)
        o && s.push(o)
      }
      if (!(!this.g?.handleDrag || s.length === 0))
        return await this.g.handleDrag(s, e, r), e
    }
    get hasHandleDrag() {
      return !!this.g?.handleDrag
    }
    async onDrop(t, e, r) {
      const s = e ? this.getExtensionElement(e) : void 0
      if (!((!s && e) || !this.g?.handleDrop))
        return gi(() =>
          this.g?.handleDrop ? this.g.handleDrop(s, t, r) : void 0,
        )
    }
    get hasResolve() {
      return !!this.f.resolveTreeItem
    }
    async resolveTreeItem(t, e) {
      if (!this.f.resolveTreeItem) return
      const r = this.j.get(t)
      if (r) {
        const s = this.m.get(r)
        if (s) {
          const a =
            (await this.f.resolveTreeItem(s.extensionItem, r, e)) ??
            s.extensionItem
          return (
            this.hb(a),
            (s.item.tooltip = this.eb(a.tooltip)),
            (s.item.command = this.fb(s.disposableStore, a.command)),
            s.item
          )
        }
      }
    }
    S(t) {
      return this.U(t).then((e) =>
        e
          ? this.S(e).then((r) =>
              this.W(e, r[r.length - 1]).then((s) => (r.push(s), r)),
            )
          : Promise.resolve([]),
      )
    }
    U(t) {
      const e = this.m.get(t)
      return e
        ? Promise.resolve(e.parent ? this.j.get(e.parent.item.handle) : void 0)
        : gi(() => this.f.getParent(t))
    }
    W(t, e) {
      const r = this.m.get(t)
      return r
        ? Promise.resolve(r)
        : gi(() => this.f.getTreeItem(t))
            .then((s) => this.kb(t, s, e, !0))
            .then((s) =>
              this.getChildren(e ? e.item.handle : void 0).then(() => {
                const a = this.getExtensionElement(s)
                if (a) {
                  const o = this.m.get(a)
                  if (o) return Promise.resolve(o)
                }
                throw new Error(
                  `Cannot resolve tree item for element ${s} from extension ${this.N.identifier.value}`,
                )
              }),
            )
    }
    X(t) {
      if (t) {
        let e
        if (typeof t == "string") {
          const r = this.getExtensionElement(t)
          e = r ? this.m.get(r) : void 0
        } else e = t
        return (e && e.children) || void 0
      }
      return this.h
    }
    async Y(t) {
      this.rb(t)
      const e = new Ie(this.Z.token)
      try {
        const r = t ? this.m.get(t) : void 0,
          s = await this.f.getChildren(t)
        if (e.token.isCancellationRequested) return
        const a = Ge(s || []),
          o = await Promise.all(Ge(a).map((u) => this.f.getTreeItem(u)))
        if (e.token.isCancellationRequested) return
        const c = o.map((u, l) => (u ? this.db(a[l], u, r) : null))
        return Ge(c)
      } finally {
        e.dispose()
      }
    }
    $(t) {
      if (t.some((r) => !r))
        return (
          this.Z.dispose(!0),
          (this.Z = new Ie()),
          this.tb(),
          this.J.$refresh(this.I)
        )
      {
        const r = this.ab(t)
        if (r.length) return this.bb(r)
      }
      return Promise.resolve(void 0)
    }
    ab(t) {
      const e = new Set(),
        r = t.map((a) => this.m.get(a))
      for (const a of r)
        if (a && !e.has(a.item.handle)) {
          let o = a
          for (
            ;
            o &&
            o.parent &&
            r.findIndex(
              (c) =>
                o && o.parent && c && c.item.handle === o.parent.item.handle,
            ) === -1;

          ) {
            const c = this.j.get(o.parent.item.handle)
            o = c ? this.m.get(c) : void 0
          }
          o && !o.parent && e.add(a.item.handle)
        }
      const s = []
      return (
        e.forEach((a) => {
          const o = this.j.get(a)
          if (o) {
            const c = this.m.get(o)
            c && (!c.parent || !e.has(c.parent.item.handle)) && s.push(a)
          }
        }),
        s
      )
    }
    bb(t) {
      const e = {}
      return Promise.all(
        t.map((r) =>
          this.cb(r).then((s) => {
            s && (e[r] = s.item)
          }),
        ),
      ).then(() =>
        Object.keys(e).length ? this.J.$refresh(this.I, e) : void 0,
      )
    }
    cb(t) {
      const e = this.getExtensionElement(t)
      if (e) {
        const r = this.m.get(e)
        if (r)
          return (
            this.rb(e),
            gi(() => this.f.getTreeItem(e)).then((s) => {
              if (s) {
                const a = this.ib(e, s, r.parent)
                return this.pb(e, a, r, r.parent), r.dispose(), a
              }
              return null
            })
          )
      }
      return Promise.resolve(null)
    }
    db(t, e, r) {
      const s = this.ib(t, e, r)
      if (e.id && this.j.has(s.item.handle))
        throw new Error(f(2772, null, e.id))
      return this.ob(t, s), this.qb(s, r), s
    }
    eb(t) {
      return Gi.isMarkdownString(t) ? Jt.from(t) : t
    }
    fb(t, e) {
      return e ? { ...this.L.toInternal(e, t), originalId: e.command } : void 0
    }
    gb(t) {
      if (t.checkboxState === void 0) return
      let e, r, s
      return (
        typeof t.checkboxState == "number"
          ? (e = t.checkboxState)
          : ((e = t.checkboxState.state),
            (r = t.checkboxState.tooltip),
            (s = t.checkboxState.accessibilityInformation)),
        { isChecked: e === sn.Checked, tooltip: r, accessibilityInformation: s }
      )
    }
    hb(t) {
      if (!k6.isTreeItem(t, this.N))
        throw new Error(
          `Extension ${this.N.identifier.value} has provided an invalid tree item.`,
        )
    }
    ib(t, e, r) {
      this.hb(e)
      const s = this.D(new bt()),
        a = this.kb(t, e, r),
        o = this.lb(e)
      return {
        item: {
          handle: a,
          parentHandle: r ? r.item.handle : void 0,
          label: Yrt(e.label, this.N),
          description: e.description,
          resourceUri: e.resourceUri,
          tooltip: this.eb(e.tooltip),
          command: this.fb(s, e.command),
          contextValue: e.contextValue,
          icon: o,
          iconDark: this.mb(e) || o,
          themeIcon: this.jb(e),
          collapsibleState: Le(e.collapsibleState)
            ? Ea.None
            : e.collapsibleState,
          accessibilityInformation: e.accessibilityInformation,
          checkbox: this.gb(e),
        },
        extensionItem: e,
        parent: r,
        children: void 0,
        disposableStore: s,
        dispose() {
          s.dispose()
        },
      }
    }
    jb(t) {
      return t.iconPath instanceof Si ? t.iconPath : void 0
    }
    kb(t, { id: e, label: r, resourceUri: s }, a, o) {
      if (e) return `${NH.b}/${e}`
      const c = Yrt(r, this.N),
        u = a ? a.item.handle : NH.a
      let l = c ? c.label : s ? us(s) : ""
      l = l.indexOf("/") !== -1 ? l.replace("/", "//") : l
      const m = this.m.has(t) ? this.m.get(t).item.handle : void 0,
        h = this.X(a) || []
      let p,
        g = 0
      do {
        if (((p = `${u}/${g}:${l}`), o || !this.j.has(p) || m === p)) break
        g++
      } while (g <= h.length)
      return p
    }
    lb(t) {
      if (t.iconPath && !(t.iconPath instanceof Si))
        return typeof t.iconPath == "string" || S.isUri(t.iconPath)
          ? this.nb(t.iconPath)
          : this.nb(t.iconPath.light)
    }
    mb(t) {
      if (t.iconPath && !(t.iconPath instanceof Si) && t.iconPath.dark)
        return this.nb(t.iconPath.dark)
    }
    nb(t) {
      return S.isUri(t) ? t : S.file(t)
    }
    ob(t, e) {
      this.j.set(e.item.handle, t), this.m.set(t, e)
    }
    pb(t, e, r, s) {
      this.j.delete(e.item.handle),
        this.m.delete(t),
        e.item.handle !== r.item.handle && this.j.delete(r.item.handle),
        this.ob(t, e)
      const a = this.X(s) || [],
        o = a.filter((c) => c.item.handle === r.item.handle)[0]
      o && a.splice(a.indexOf(o), 1, e)
    }
    qb(t, e) {
      e
        ? (e.children || (e.children = []), e.children.push(t))
        : (this.h || (this.h = []), this.h.push(t))
    }
    rb(t) {
      if (t) {
        const e = this.m.get(t)
        if (e) {
          if (e.children)
            for (const r of e.children) {
              const s = this.j.get(r.item.handle)
              s && this.sb(s)
            }
          e.children = void 0
        }
      } else this.tb()
    }
    sb(t) {
      const e = this.m.get(t)
      if (e) {
        if (e.children)
          for (const r of e.children) {
            const s = this.j.get(r.item.handle)
            s && this.sb(s)
          }
        this.m.delete(t), this.j.delete(e.item.handle), e.dispose()
      }
    }
    tb() {
      ;(this.h = void 0),
        this.j.clear(),
        this.m.forEach((t) => t.dispose()),
        this.m.clear()
    }
    dispose() {
      super.dispose(), this.Z.dispose(), this.tb(), this.J.$disposeTree(this.I)
    }
  },
  _7t = class Tst {
    static {
      this.a = new Set([Q.http, Q.https])
    }
    constructor(t) {
      ;(this.c = new Map()), (this.b = t.getProxy(z.MainThreadUriOpeners))
    }
    registerExternalUriOpener(t, e, r, s) {
      if (this.c.has(e))
        throw new Error(`Opener with id '${e}' already registered`)
      const a = s.schemes.find((o) => !Tst.a.has(o))
      if (a)
        throw new Error(
          `Scheme '${a}' is not supported. Only http and https are currently supported.`,
        )
      return (
        this.c.set(e, r),
        this.b.$registerUriOpener(e, s.schemes, t, s.label),
        it(() => {
          this.c.delete(e), this.b.$unregisterUriOpener(e)
        })
      )
    }
    async $canOpenUri(t, e, r) {
      const s = this.c.get(t)
      if (!s) throw new Error(`Unknown opener with id: ${t}`)
      const a = S.revive(e)
      return s.canOpenExternalUri(a, r)
    }
    async $openUri(t, e, r) {
      const s = this.c.get(t)
      if (!s) throw new Error(`Unknown opener id: '${t}'`)
      return s.openExternalUri(
        S.revive(e.resolvedUri),
        { sourceUri: S.revive(e.sourceUri) },
        r,
      )
    }
  },
  A7t = class kst {
    static {
      this.a = 0
    }
    constructor(t) {
      ;(this.c = new la()),
        (this.d = new Map()),
        (this.b = t.getProxy(z.MainThreadUrls))
    }
    registerUriHandler(t, e) {
      const r = t.identifier
      if (this.c.has(r))
        throw new Error(
          `Protocol handler already registered for extension ${r}`,
        )
      const s = kst.a++
      return (
        this.c.add(r),
        this.d.set(s, e),
        this.b.$registerUriHandler(s, r, t.displayName || t.name),
        it(() => {
          this.c.delete(r), this.d.delete(s), this.b.$unregisterUriHandler(s)
        })
      )
    }
    $handleExternalUri(t, e) {
      const r = this.d.get(t)
      if (!r) return Promise.resolve(void 0)
      try {
        r.handleUri(S.revive(e))
      } catch (s) {
        Ui(s)
      }
      return Promise.resolve(void 0)
    }
    async createAppUri(t) {
      return S.revive(await this.b.$createAppUri(t))
    }
  },
  B7t = class extends dt {
    #t
    #e
    #i
    #r
    #s
    #n
    #o
    #a
    #c
    #u
    #l
    #m
    #d
    constructor(i, t, e, r) {
      super(),
        (this.#a = void 0),
        (this.#c = !0),
        (this.#l = !1),
        (this.#m = this.D(new C())),
        (this.onDidDispose = this.#m.event),
        (this.#d = this.D(new C())),
        (this.onDidChangeViewState = this.#d.event),
        (this.#t = i),
        (this.#e = t),
        (this.#r = e),
        (this.#i = r.viewType),
        (this.#s = r.panelOptions),
        (this.#a = r.viewColumn),
        (this.#n = r.title),
        (this.#u = r.active)
    }
    dispose() {
      this.#l ||
        ((this.#l = !0),
        this.#m.fire(),
        this.#e.$disposeWebview(this.#t),
        this.#r.dispose(),
        super.dispose())
    }
    get webview() {
      return this.c(), this.#r
    }
    get viewType() {
      return this.c(), this.#i
    }
    get title() {
      return this.c(), this.#n
    }
    set title(i) {
      this.c(), this.#n !== i && ((this.#n = i), this.#e.$setTitle(this.#t, i))
    }
    get iconPath() {
      return this.c(), this.#o
    }
    set iconPath(i) {
      this.c(),
        this.#o !== i &&
          ((this.#o = i),
          this.#e.$setIconPath(this.#t, S.isUri(i) ? { light: i, dark: i } : i))
    }
    get options() {
      return this.#s
    }
    get viewColumn() {
      if ((this.c(), !(typeof this.#a == "number" && this.#a < 0)))
        return this.#a
    }
    get active() {
      return this.c(), this.#u
    }
    get visible() {
      return this.c(), this.#c
    }
    _updateViewState(i) {
      this.#l ||
        ((this.active !== i.active ||
          this.visible !== i.visible ||
          this.viewColumn !== i.viewColumn) &&
          ((this.#u = i.active),
          (this.#c = i.visible),
          (this.#a = i.viewColumn),
          this.#d.fire({ webviewPanel: this })))
    }
    reveal(i, t) {
      this.c(),
        this.#e.$reveal(this.#t, {
          viewColumn: typeof i > "u" ? void 0 : Me.from(i),
          preserveFocus: !!t,
        })
    }
    c() {
      if (this.#l) throw new Error("Webview is disposed")
    }
  },
  O7t = class Sst extends dt {
    static c() {
      return Ki()
    }
    constructor(t, e, r) {
      super(),
        (this.j = e),
        (this.m = r),
        (this.g = new Map()),
        (this.h = new Map()),
        (this.f = t.getProxy(z.MainThreadWebviewPanels))
    }
    dispose() {
      super.dispose(), this.g.forEach((t) => t.dispose()), this.g.clear()
    }
    createWebviewPanel(t, e, r, s, a = {}) {
      const o = typeof s == "object" ? s.viewColumn : s,
        c = {
          viewColumn: Me.from(o),
          preserveFocus: typeof s == "object" && !!s.preserveFocus,
        },
        u = Wc(t),
        l = Sst.c()
      this.f.$createWebviewPanel(
        p8(t),
        l,
        e,
        {
          title: r,
          panelOptions: q7t(a),
          webviewOptions: Zit(t, this.m, a),
          serializeBuffersForPostMessage: u,
        },
        c,
      )
      const m = this.j.createNewWebview(l, a, t)
      return this.createNewWebviewPanel(l, e, r, o, a, m, !0)
    }
    $onDidChangeWebviewPanelViewStates(t) {
      const e = Object.keys(t)
      e.sort((r, s) => {
        const a = t[r],
          o = t[s]
        return a.active ? 1 : o.active ? -1 : +a.visible - +o.visible
      })
      for (const r of e) {
        const s = this.getWebviewPanel(r)
        if (!s) continue
        const a = t[r]
        s._updateViewState({
          active: a.active,
          visible: a.visible,
          viewColumn: Me.to(a.position),
        })
      }
    }
    async $onDidDisposeWebviewPanel(t) {
      this.getWebviewPanel(t)?.dispose(),
        this.g.delete(t),
        this.j.deleteWebview(t)
    }
    registerWebviewPanelSerializer(t, e, r) {
      if (this.h.has(e))
        throw new Error(`Serializer for '${e}' already registered`)
      return (
        this.h.set(e, { serializer: r, extension: t }),
        this.f.$registerSerializer(e, {
          serializeBuffersForPostMessage: Wc(t),
        }),
        new At(() => {
          this.h.delete(e), this.f.$unregisterSerializer(e)
        })
      )
    }
    async $deserializeWebviewPanel(t, e, r, s) {
      const a = this.h.get(e)
      if (!a) throw new Error(`No serializer found for '${e}'`)
      const { serializer: o, extension: c } = a,
        u = this.j.createNewWebview(t, r.webviewOptions, c),
        l = this.createNewWebviewPanel(
          t,
          e,
          r.title,
          s,
          r.panelOptions,
          u,
          r.active,
        )
      await o.deserializeWebviewPanel(l, r.state)
    }
    createNewWebviewPanel(t, e, r, s, a, o, c) {
      const u = new B7t(t, this.f, o, {
        viewType: e,
        title: r,
        viewColumn: s,
        panelOptions: a,
        active: c,
      })
      return this.g.set(t, u), u
    }
    getWebviewPanel(t) {
      return this.g.get(t)
    }
  }
function q7t(i) {
  return {
    enableFindWidget: i.enableFindWidget,
    retainContextWhenHidden: i.retainContextWhenHidden,
  }
}
var U7t = class extends dt {
    #t
    #e
    #i
    #r
    #s
    #n
    #o
    #a
    #c
    constructor(i, t, e, r, s, a) {
      super(),
        (this.#s = !1),
        (this.#u = this.D(new C())),
        (this.onDidChangeVisibility = this.#u.event),
        (this.#l = this.D(new C())),
        (this.onDidDispose = this.#l.event),
        (this.#i = e),
        (this.#o = r),
        (this.#t = i),
        (this.#e = t),
        (this.#r = s),
        (this.#n = a)
    }
    dispose() {
      this.#s ||
        ((this.#s = !0), this.#l.fire(), this.#r.dispose(), super.dispose())
    }
    #u
    #l
    get title() {
      return this.a(), this.#o
    }
    set title(i) {
      this.a(),
        this.#o !== i &&
          ((this.#o = i), this.#e.$setWebviewViewTitle(this.#t, i))
    }
    get description() {
      return this.a(), this.#a
    }
    set description(i) {
      this.a(),
        this.#a !== i &&
          ((this.#a = i), this.#e.$setWebviewViewDescription(this.#t, i))
    }
    get visible() {
      return this.#n
    }
    get webview() {
      return this.#r
    }
    get viewType() {
      return this.#i
    }
    _setVisible(i) {
      i === this.#n || this.#s || ((this.#n = i), this.#u.fire())
    }
    get badge() {
      return this.a(), this.#c
    }
    set badge(i) {
      this.a(),
        !(i?.value === this.#c?.value && i?.tooltip === this.#c?.tooltip) &&
          ((this.#c = yA.from(i)), this.#e.$setWebviewViewBadge(this.#t, i))
    }
    show(i) {
      this.a(), this.#e.$show(this.#t, !!i)
    }
    a() {
      if (this.#s) throw new Error("Webview is disposed")
    }
  },
  M7t = class {
    constructor(i, t) {
      ;(this.d = t),
        (this.b = new Map()),
        (this.c = new Map()),
        (this.a = i.getProxy(z.MainThreadWebviewViews))
    }
    registerWebviewViewProvider(i, t, e, r) {
      if (this.b.has(t))
        throw new Error(`View provider for '${t}' already registered`)
      return (
        this.b.set(t, { provider: e, extension: i }),
        this.a.$registerWebviewViewProvider(p8(i), t, {
          retainContextWhenHidden: r?.retainContextWhenHidden,
          serializeBuffersForPostMessage: Wc(i),
        }),
        new At(() => {
          this.b.delete(t), this.a.$unregisterWebviewViewProvider(t)
        })
      )
    }
    async $resolveWebviewView(i, t, e, r, s) {
      const a = this.b.get(t)
      if (!a) throw new Error(`No view provider found for '${t}'`)
      const { provider: o, extension: c } = a,
        u = this.d.createNewWebview(i, {}, c),
        l = new U7t(i, this.a, t, e, u, !0)
      this.c.set(i, l), await o.resolveWebviewView(l, { state: r }, s)
    }
    async $onDidChangeWebviewViewVisibility(i, t) {
      this.e(i)._setVisible(t)
    }
    async $disposeWebviewView(i) {
      const t = this.e(i)
      this.c.delete(i), t.dispose(), this.d.deleteWebview(i)
    }
    e(i) {
      const t = this.c.get(i)
      if (!t) throw new Error("No webview found")
      return t
    }
  },
  GMt = new H("debugType", void 0, {
    type: "string",
    description: f(6138, null),
  }),
  zMt = new H("debugConfigurationType", void 0, {
    type: "string",
    description: f(6139, null),
  }),
  YMt = new H("debugState", "inactive", {
    type: "string",
    description: f(6140, null),
  }),
  QMt = new H("debugRecordingState", !1, {
    type: "string",
    description: f(6141, null),
  }),
  H7t = "debugUx",
  XMt = new H(H7t, "default", { type: "string", description: f(6142, null) }),
  KMt = new H("hasDebugged", !1, {
    type: "boolean",
    description: f(6143, null),
  }),
  ZMt = new H("inDebugMode", !1, {
    type: "boolean",
    description: f(6144, null),
  }),
  tHt = new H("inDebugRepl", !1, {
    type: "boolean",
    description: f(6145, null),
  }),
  eHt = new H("breakpointWidgetVisible", !1, {
    type: "boolean",
    description: f(6146, null),
  }),
  iHt = new H("inBreakpointWidget", !1, {
    type: "boolean",
    description: f(6147, null),
  }),
  rHt = new H("breakpointsFocused", !0, {
    type: "boolean",
    description: f(6148, null),
  }),
  nHt = new H("watchExpressionsFocused", !0, {
    type: "boolean",
    description: f(6149, null),
  }),
  sHt = new H("watchExpressionsExist", !1, {
    type: "boolean",
    description: f(6150, null),
  }),
  aHt = new H("variablesFocused", !0, {
    type: "boolean",
    description: f(6151, null),
  }),
  oHt = new H("expressionSelected", !1, {
    type: "boolean",
    description: f(6152, null),
  }),
  cHt = new H("breakpointInputFocused", !1, {
    type: "boolean",
    description: f(6153, null),
  }),
  uHt = new H("callStackItemType", void 0, {
    type: "string",
    description: f(6154, null),
  }),
  lHt = new H("callStackSessionIsAttach", !1, {
    type: "boolean",
    description: f(6155, null),
  }),
  dHt = new H("callStackItemStopped", !1, {
    type: "boolean",
    description: f(6156, null),
  }),
  mHt = new H("callStackSessionHasOneThread", !1, {
    type: "boolean",
    description: f(6157, null),
  }),
  hHt = new H("callStackFocused", !0, {
    type: "boolean",
    description: f(6158, null),
  }),
  fHt = new H("watchItemType", void 0, {
    type: "string",
    description: f(6159, null),
  }),
  pHt = new H("canViewMemory", void 0, {
    type: "boolean",
    description: f(6160, null),
  }),
  gHt = new H("breakpointItemType", void 0, {
    type: "string",
    description: f(6161, null),
  }),
  vHt = new H("breakpointItemBytes", void 0, {
    type: "boolean",
    description: f(6162, null),
  }),
  wHt = new H("breakpointHasModes", !1, {
    type: "boolean",
    description: f(6163, null),
  }),
  yHt = new H("breakpointSupportsCondition", !1, {
    type: "boolean",
    description: f(6164, null),
  }),
  THt = new H("loadedScriptsSupported", !1, {
    type: "boolean",
    description: f(6165, null),
  }),
  kHt = new H("loadedScriptsItemType", void 0, {
    type: "string",
    description: f(6166, null),
  }),
  SHt = new H("focusedSessionIsAttach", !1, {
    type: "boolean",
    description: f(6167, null),
  }),
  bHt = new H("focusedSessionIsNoDebug", !1, {
    type: "boolean",
    description: f(6168, null),
  }),
  EHt = new H("stepBackSupported", !1, {
    type: "boolean",
    description: f(6169, null),
  }),
  IHt = new H("restartFrameSupported", !1, {
    type: "boolean",
    description: f(6170, null),
  }),
  PHt = new H("stackFrameSupportsRestart", !1, {
    type: "boolean",
    description: f(6171, null),
  }),
  NHt = new H("jumpToCursorSupported", !1, {
    type: "boolean",
    description: f(6172, null),
  }),
  $Ht = new H("stepIntoTargetsSupported", !1, {
    type: "boolean",
    description: f(6173, null),
  }),
  xHt = new H("breakpointsExist", !1, {
    type: "boolean",
    description: f(6174, null),
  }),
  JHt = new H("debuggersAvailable", !1, {
    type: "boolean",
    description: f(6175, null),
  }),
  CHt = new H("debugExtensionAvailable", !0, {
    type: "boolean",
    description: f(6176, null),
  }),
  LHt = new H("debugProtocolVariableMenuContext", void 0, {
    type: "string",
    description: f(6177, null),
  }),
  RHt = new H("debugSetVariableSupported", !1, {
    type: "boolean",
    description: f(6178, null),
  }),
  DHt = new H("debugSetDataBreakpointAddressSupported", !1, {
    type: "boolean",
    description: f(6179, null),
  }),
  FHt = new H("debugSetExpressionSupported", !1, {
    type: "boolean",
    description: f(6180, null),
  }),
  _Ht = new H("breakWhenValueChangesSupported", !1, {
    type: "boolean",
    description: f(6181, null),
  }),
  AHt = new H("breakWhenValueIsAccessedSupported", !1, {
    type: "boolean",
    description: f(6182, null),
  }),
  BHt = new H("breakWhenValueIsReadSupported", !1, {
    type: "boolean",
    description: f(6183, null),
  }),
  OHt = new H("terminateDebuggeeSupported", !1, {
    type: "boolean",
    description: f(6184, null),
  }),
  qHt = new H("suspendDebuggeeSupported", !1, {
    type: "boolean",
    description: f(6185, null),
  }),
  UHt = new H("variableEvaluateNamePresent", !1, {
    type: "boolean",
    description: f(6186, null),
  }),
  MHt = new H("variableIsReadonly", !1, {
    type: "boolean",
    description: f(6187, null),
  }),
  HHt = new H("variableValue", !1, {
    type: "string",
    description: f(6188, null),
  }),
  WHt = new H("variableType", !1, {
    type: "string",
    description: f(6189, null),
  }),
  jHt = new H("variableInterfaces", !1, {
    type: "array",
    description: f(6190, null),
  }),
  VHt = new H("variableName", !1, {
    type: "string",
    description: f(6191, null),
  }),
  GHt = new H("variableLanguage", !1, {
    type: "string",
    description: f(6192, null),
  }),
  zHt = new H("variableExtensionId", !1, {
    type: "string",
    description: f(6193, null),
  }),
  YHt = new H("exceptionWidgetVisible", !1, {
    type: "boolean",
    description: f(6194, null),
  }),
  QHt = new H("multiSessionRepl", !1, {
    type: "boolean",
    description: f(6195, null),
  }),
  XHt = new H("multiSessionDebug", !1, {
    type: "boolean",
    description: f(6196, null),
  }),
  KHt = new H("disassembleRequestSupported", !1, {
    type: "boolean",
    description: f(6197, null),
  }),
  ZHt = new H("disassemblyViewFocus", !1, {
    type: "boolean",
    description: f(6198, null),
  }),
  tWt = new H("languageSupportsDisassembleRequest", !1, {
    type: "boolean",
    description: f(6199, null),
  }),
  eWt = new H("focusedStackFrameHasInstructionReference", !1, {
    type: "boolean",
    description: f(6200, null),
  }),
  iWt = {
    enum: ["neverOpen", "openOnSessionStart", "openOnFirstSessionStart"],
    default: "openOnFirstSessionStart",
    description: f(6202, null),
  },
  Qrt
;(function (i) {
  ;(i[(i.Inactive = 0)] = "Inactive"),
    (i[(i.Initializing = 1)] = "Initializing"),
    (i[(i.Stopped = 2)] = "Stopped"),
    (i[(i.Running = 3)] = "Running")
})(Qrt || (Qrt = {}))
var Xrt
;(function (i) {
  ;(i[(i.Valid = 0)] = "Valid"),
    (i[(i.Unreadable = 1)] = "Unreadable"),
    (i[(i.Error = 2)] = "Error")
})(Xrt || (Xrt = {}))
var Krt
;(function (i) {
  ;(i[(i.Variable = 0)] = "Variable"), (i[(i.Address = 1)] = "Address")
})(Krt || (Krt = {}))
var R8
;(function (i) {
  ;(i[(i.Initial = 1)] = "Initial"), (i[(i.Dynamic = 2)] = "Dynamic")
})(R8 || (R8 = {}))
var Zrt
;(function (i) {
  i.UnverifiedBreakpoints = "unverifiedBreakpoints"
})(Zrt || (Zrt = {}))
var rWt = Y("debugService"),
  tnt
;(function (i) {
  ;(i[(i.CONDITION = 0)] = "CONDITION"),
    (i[(i.HIT_COUNT = 1)] = "HIT_COUNT"),
    (i[(i.LOG_MESSAGE = 2)] = "LOG_MESSAGE"),
    (i[(i.TRIGGER_POINT = 3)] = "TRIGGER_POINT")
})(tnt || (tnt = {}))
var ent
;(function (i) {
  ;(i[(i.Command = 0)] = "Command"), (i[(i.Tree = 1)] = "Tree")
})(ent || (ent = {}))
var int
;(function (i) {
  ;(i[(i.None = 0)] = "None"),
    (i[(i.Collapsed = 1)] = "Collapsed"),
    (i[(i.Expanded = 2)] = "Expanded")
})(int || (int = {}))
var rnt
;(function (i) {
  ;(i.deserialize = (t) => t), (i.serialize = (t) => t)
})(rnt || (rnt = {}))
var nnt
;(function (i) {
  ;(i.deserialize = (t) => ({
    id: t.id,
    name: t.name,
    iconPath: t.iconPath && {
      light: S.revive(t.iconPath.light),
      dark: S.revive(t.iconPath.dark),
    },
    iconClass: t.iconClass,
    visualization: t.visualization,
  })),
    (i.serialize = (t) => t)
})(nnt || (nnt = {}))
var W7t = class bst {
  static {
    this.a = 0
  }
  constructor(t) {
    ;(this.c = new Map()), (this.b = t.getProxy(z.MainThreadCodeMapper))
  }
  async $mapCode(t, e, r) {
    const s = this.c.get(t)
    if (!s)
      throw new Error(
        `Received request to map code for unknown provider handle ${t}`,
      )
    const a = {
        textEdit: (u, l) => {
          ;(l = Array.isArray(l) ? l : [l]),
            this.b.$handleProgress(e.requestId, {
              uri: u,
              edits: l.map(He.from),
            })
        },
      },
      o = {
        codeBlocks: e.codeBlocks.map((u) => ({
          code: u.code,
          resource: S.revive(u.resource),
          markdownBeforeBlock: u.markdownBeforeBlock,
        })),
        conversation: e.conversation.map((u) =>
          u.type === "request"
            ? { type: "request", message: u.message }
            : {
                type: "response",
                message: u.message,
                result: u.result ? Es.to(u.result) : void 0,
                references: u.references?.map(cc.to),
              },
        ),
      }
    return (await s.provideMappedEdits(o, a, r)) ?? null
  }
  registerMappedEditsProvider(t, e) {
    const r = bst.a++
    return (
      this.b.$registerCodeMapperProvider(r),
      this.c.set(r, e),
      { dispose: () => this.b.$unregisterCodeMapperProvider(r) }
    )
  }
}
typeof Symbol.dispose != "symbol" &&
  Object.defineProperty(Symbol, "dispose", { value: Symbol("Symbol.dispose") }),
  typeof Symbol.asyncDispose != "symbol" &&
    Object.defineProperty(Symbol, "asyncDispose", {
      value: Symbol("Symbol.asyncDispose"),
    })
var snt = "traceparent"
function KM() {
  return !Hn().enabled
}
function ant(i) {
  if (KM()) return new cnt(void 0)
  const t = Hn().tracesSampleRate,
    e = { [mM]: t }
  let r
  return (
    Math.random() < t &&
      v_t({ name: i, attributes: e, parentSpan: null }, (s) => {
        ;(r = s), r.setAttributes(e)
      }),
    new cnt(r)
  )
}
function ont(i, t) {
  const e = ant(i)
  try {
    const r = t(e)
    return wn(r)
      ? Promise.resolve(r)
          .catch((s) => {
            throw (e.setError(), s)
          })
          .finally(() => {
            e.end()
          })
      : (e.end(), r)
  } catch (r) {
    throw (e.setError(), e.end(), r)
  }
}
function j7t(i) {
  return function (t, e, r) {
    const s = r.value
    return (
      (r.value = function (...a) {
        return ont(i, () => s.apply(this, a))
      }),
      r
    )
  }
}
var cnt = class {
  constructor(i) {
    ;(this.a = !1), (this.b = i)
  }
  end() {
    this.a || (this.b?.end(), (this.a = !0))
  }
  spanContext() {
    return this.b?.spanContext()
  }
  setAttribute(i, t) {
    this.b?.setAttribute(i, t)
  }
  setError(i) {
    this.b?.setStatus({ code: 2, message: i ?? "internal_error" })
  }
  [Symbol.dispose]() {
    this.end()
  }
}
function V7t(i) {
  KM() || Mc().addBreadcrumb(i)
}
function G7t(i) {
  KM() || Xn(i) || Kn.isErrorNoTelemetry(i) || Wn().captureException(i)
}
function unt(i) {
  const t = i?.spanContext(),
    e = t?.traceId ?? Wn().getPropagationContext().traceId,
    r = t?.spanId ?? Ur().substring(16),
    s = t?.traceFlags === 1 ? "01" : "00"
  return `00-${e}-${r}-${s}`
}
function z7t(i) {
  const t = i.get(ci),
    e = i.get(To),
    r = i.get(y7),
    s = i.get(Fs),
    a = i.get(_n),
    o = i.get(T7),
    c = i.get(An),
    u = i.get(m_),
    l = i.get(Vt),
    m = i.get(m2),
    h = i.get(f2),
    p = i.get(Hu),
    g = i.get(Kt),
    w = i.get(y2),
    T = i.get(E7),
    b = i.get(QK),
    N = i.get(A2),
    $ = i.get(zd),
    L = i.get(q2),
    U = i.get(N2),
    q = i.get(x2),
    V = i.get(KK)
  l.set(rt.ExtHostFileSystemInfo, e),
    l.set(rt.ExtHostLogLevelServiceShape, p),
    l.set(rt.ExtHostWorkspace, a),
    l.set(rt.ExtHostConfiguration, c),
    l.set(rt.ExtHostExtensionService, s),
    l.set(rt.ExtHostStorage, m),
    l.set(rt.ExtHostTunnelService, w),
    l.set(rt.ExtHostWindow, b),
    l.set(rt.ExtHostSecretState, N),
    l.set(rt.ExtHostTelemetry, o),
    l.set(rt.ExtHostEditorTabs, $),
    l.set(rt.ExtHostManagedSockets, L),
    l.set(rt.ExtHostAuthentication, U),
    l.set(rt.ExtHostChatProvider, q)
  const lt = l.set(rt.ExtHostDecorations, i.get(dK)),
    at = l.set(rt.ExtHostDocumentsAndEditors, i.get(xc)),
    et = l.set(rt.ExtHostCommands, i.get(Ba)),
    wt = l.set(rt.ExtHostTerminalService, i.get(Pc)),
    zt = l.set(rt.ExtHostTerminalShellIntegration, i.get(XK)),
    Ct = l.set(rt.ExtHostDebugService, i.get(jK)),
    be = l.set(rt.ExtHostSearch, i.get(YK)),
    G = l.set(rt.ExtHostTask, i.get(FK)),
    W = l.set(rt.ExtHostOutputService, i.get(lK)),
    tt = l.set(rt.ExtHostLocalization, i.get(O2)),
    X = l.set(rt.ExtHostUrls, new A7t(l)),
    Z = l.set(rt.ExtHostDocuments, new aAt(l, at)),
    St = l.set(rt.ExtHostDocumentContentProviders, new nAt(l, at, g)),
    Dt = l.set(
      rt.ExtHostDocumentSaveParticipant,
      new sAt(g, Z, l.getProxy(z.MainThreadBulkEdits)),
    ),
    Pt = l.set(rt.ExtHostNotebook, new YAt(l, et, at, Z, r, be, g)),
    ie = l.set(rt.ExtHostNotebookDocuments, new XAt(Pt)),
    Ze = l.set(rt.ExtHostNotebookEditors, new HM(g, Pt)),
    Te = l.set(rt.ExtHostNotebookKernels, new WM(l, t, Pt, et, g)),
    si = l.set(rt.ExtHostNotebookRenderers, new r7t(l, Pt)),
    wi = l.set(
      rt.ExtHostNotebookDocumentSaveParticipant,
      new QAt(g, Pt, l.getProxy(z.MainThreadBulkEdits)),
    ),
    le = l.set(rt.ExtHostEditors, new I7t(l, at)),
    mn = l.set(
      rt.ExtHostTreeViews,
      new D7t(l.getProxy(z.MainThreadTreeViews), et, g),
    ),
    eo = l.set(
      rt.ExtHostEditorInsets,
      new c0t(l.getProxy(z.MainThreadEditorInsets), le, t.remote),
    ),
    Ws = l.set(rt.ExtHostDiagnostics, new kM(l, g, e, at)),
    or = l.set(rt.ExtHostLanguages, new PAt(l, Z, et.converter, u)),
    $t = l.set(rt.ExtHostLanguageFeatures, new bAt(l, u, Z, et, Ws, g, T, o)),
    Qt = l.set(rt.ExtHostCodeMapper, new W7t(l)),
    FF = l.set(rt.ExtHostFileSystem, new fAt(l, $t)),
    Oi = l.set(rt.ExtHostFileSystemEventService, new wAt(l, g, at)),
    Ii = l.set(rt.ExtHostQuickOpen, c7t(l, a, et)),
    hn = l.set(rt.ExtHostSCM, new QM(l, et, Z, g)),
    io = l.set(rt.ExtHostQuickDiff, new o7t(l, u)),
    vu = l.set(rt.ExtHostShare, new T7t(l, u)),
    _F = l.set(rt.ExtHostComments, l0t(l, et, Z)),
    ro = l.set(rt.ExtHostProgress, new s7t(l.getProxy(z.MainThreadProgress))),
    wu = l.set(rt.ExtHostLabelService, new TAt(l)),
    js = l.set(rt.ExtHostTheming, new XM(l)),
    ft = l.set(rt.ExtHostCursor, new B6t(l, V, g)),
    Vs = l.set(rt.ExtHostTimeline, new P7t(l, et)),
    we = l.set(rt.ExtHostWebviews, new G6t(l, t.remote, a, g, T)),
    ti = l.set(rt.ExtHostWebviewPanels, new O7t(l, we, a)),
    X8 = l.set(rt.ExtHostCustomEditors, new Z6t(l, Z, h, we, ti)),
    K8 = l.set(rt.ExtHostWebviewViews, new M7t(l, we)),
    yr = l.set(rt.ExtHostTesting, i.get(L7)),
    yu = l.set(rt.ExtHostUriOpeners, new _7t(l)),
    x = l.set(rt.ExtHostProfileContentHandlers, new n7t(l))
  l.set(rt.ExtHostInteractive, new yAt(l, Pt, at, et, g))
  const D = l.set(rt.ExtHostChatAgents2, new t0t(l, g, et, Z, q)),
    B = l.set(rt.ExtHostChatVariables, new r0t(l)),
    ot = l.set(rt.ExtHostLanguageModelTools, new IAt(l)),
    Tt = l.set(rt.ExtHostAiRelatedInformation, new Vyt(l)),
    Ve = l.set(rt.ExtHostAiEmbeddingVector, new cAt(l)),
    Yt = l.set(rt.ExtHostStatusBar, new E7t(l, et.converter)),
    yi = l.set(rt.ExtHostSpeech, new k7t(l)),
    me = l.set(rt.ExtHostEmbeddings, new oAt(l)),
    ai = Object.values(rt)
  l.assertRegistered(ai)
  const cr = new EU(l, at),
    $e = new s0t(l),
    Oe = new CM(l, g),
    pi = new rAt(l)
  return (
    Xyt.register(et),
    function (I, yt, Rt) {
      function j(y) {
        return (k, P, ct) => {
          const Xt = y((xe) => {
            try {
              k.call(P, xe)
            } catch (Tu) {
              eB(
                new Error(
                  `[ExtensionListenerError] Extension '${I.identifier.value}' FAILED to handle event: ${Tu.toString()}`,
                  { cause: Tu },
                ),
              ),
                o.onExtensionError(I.identifier, Tu)
            }
          })
          return ct?.push(Xt), Xt
        }
      }
      const gt = (function () {
        let y = !I.isUnderDevelopment
        function k() {
          y ||
            (g.info(
              `Extension '${I.identifier.value}' uses a document selector without scheme. Learn more about this: https://go.microsoft.com/fwlink/?linkid=872305`,
            ),
            (y = !0))
        }
        return function P(ct) {
          if (Array.isArray(ct)) ct.forEach(P)
          else if (typeof ct == "string") k()
          else {
            const Xt = ct
            typeof Xt.scheme > "u" && k(),
              typeof Xt.exclusive == "boolean" &&
                F(I, "documentFiltersExclusive")
          }
          return ct
        }
      })()
      function qe(y, k, ...P) {
        return F(I, y), k(...P)
      }
      const ur = {
        get onDidChangeCursorCreds() {
          return ft.onDidChangeCursorCreds
        },
        get productCommit() {
          return t.commit
        },
        get rendererPerformanceTimeOrigin() {
          return t.rendererPerformanceTimeOrigin
        },
        get onDidChangePrivacyMode() {
          return ft.onDidChangePrivacyMode
        },
        get onDidChangeCursorAuthToken() {
          return ft.onDidChangeCursorAuthToken
        },
        get onDidRequestRepoIndex() {
          return ft.onDidRequestRepoIndex
        },
        get onDidRequestRepoInterrupt() {
          return ft.onDidRequestRepoInterrupt
        },
        get onDidChangeFileSyncClientEnabled() {
          return ft.onDidChangeFileSyncClientEnabled
        },
        get onDidChangeCppEnabled() {
          return ft.onDidChangeCppEnabled
        },
        get onDidChangeCppConfig() {
          return ft.onDidChangeCppConfig
        },
        get onDidChangeMembershipType() {
          return ft.onDidChangeMembershipType
        },
        triggerRefreshCursorAuthToken: () => ft.triggerRefreshCursorAuthToken(),
        onDidChangeIndexingStatus: () => ft.onDidChangeIndexingStatus(),
        getCppSessionId: () => ft.getCppSessionId(),
        getCppTelemEnabled: () => ft.getCppTelemEnabled(),
        getCursorCreds: () => ft.getCursorCreds(),
        getPrivacyMode: () => ft.getPrivacyMode(),
        isFileSyncClientEnabled: () => ft.isFileSyncClientEnabled(),
        cppEnabled: () => ft.cppEnabled(),
        cppConfig: () => ft.cppConfig(),
        membershipType: () => ft.membershipType(),
        preferredEmbeddingModel: () => ft.preferredEmbeddingModel(),
        shouldIndexNewRepos: () => ft.shouldIndex(),
        getCursorAuthToken: () => ft.getCursorAuthToken(),
        updateUploadProgress(y, k, P = !1) {
          return ft.updateUploadProgress(y, k, P)
        },
        showWebCmdKInputBox(y) {
          return ft.showWebCmdKInputBox(y)
        },
        processAiReaderMessage(y) {
          return ft.processAiReaderMessage(y)
        },
        registerIndexProvider(y) {
          return ft.registerIndexProvider(y)
        },
        registerExtHostEventLogger(y) {
          return ft.registerExtHostEventLogger(y)
        },
        registerRequesterProvider(y) {
          return ft.registerRequesterProvider(y)
        },
        registerShadowClientProvider(y) {
          return ft.registerShadowClientProvider(y)
        },
        registerShadowServerProvider(y) {
          return ft.registerShadowServerProvider(y)
        },
        registerMetricsProvider(y) {
          return ft.registerMetricsProvider(y)
        },
        registerDiffingProvider(y) {
          return ft.registerDiffingProvider(y)
        },
        registerEverythingProvider(y) {
          return ft.registerEverythingProvider(y)
        },
        registerEverythingProviderAllLocal(y) {
          return ft.registerEverythingProviderAllLocal(y)
        },
        registerEditHistoryProvider(y) {
          return ft.registerEditHistoryProvider(y)
        },
        registerLspSubgraphProvider(y) {
          return ft.registerLspSubgraphProvider(y)
        },
        registerConnectTransportProvider: (y) =>
          ft.registerConnectTransportProvider(y),
        getAllRequestHeadersExceptAccessToken: (y) => {
          jyt({
            req: y.req,
            machineId: ft.getMachineId() ?? AF.machineId,
            macMachineId: ft.getMacMachineId() ?? AF.macMachineId,
            base64Fn: (k) => VF(Et.wrap(k), !1, !0),
            cursorVersion: t.version,
            privacyMode: ft.getPrivacyMode(),
            sessionId: ft.getCppSessionId(),
            backupRequestId: y.requestId,
            clientKey: y.clientKey,
          })
          try {
            y.req.header.has(snt) || y.req.header.set(snt, unt())
          } catch {}
        },
        publicLogCapture(y) {
          ft.publicLogCapture(y)
        },
        getSemanticSearchResultsFromServer: (y) =>
          ft.getSemanticSearchResultsFromServer(y),
        shouldIgnoreUri: (y) => ft.$shouldIgnoreUri(y),
        adminBlocklistPath: () =>
          ft.$adminBlocklistPath().then((y) => y.fsPath),
      }
      for (const y of Object.keys(ur)) {
        const k = y
        let P = Object.getOwnPropertyDescriptor(ur, k)
        if (P?.get) {
          let ct = P.get
          Object.defineProperty(ur, k, {
            get: () => qe("cursor", ct.bind(ur)),
            enumerable: !0,
            configurable: !0,
          })
        } else if (typeof ur[k] == "function") {
          let ct = ur[k]
          if (typeof ct == "function") {
            const Xt = ct
            Object.defineProperty(ur, k, {
              value: (...xe) => qe("cursor", Xt.bind(ur), ...xe),
              enumerable: !0,
              configurable: !0,
            })
          }
        }
      }
      const Gr = {
        addBreadcrumb: V7t,
        captureException: G7t,
        getTraceparent: unt,
        runInSpan: ont,
        span: ant,
        withSpan: j7t,
      }
      for (const y of Object.keys(Gr)) {
        const k = y,
          P = Gr[k]
        typeof P == "function" && (Gr[k] = (...ct) => qe("cursor", P, ...ct))
      }
      const Gs = {
          getSession(y, k, P) {
            return (
              typeof P?.forceNewSession == "object" &&
                P.forceNewSession.learnMore &&
                F(I, "authLearnMore"),
              U.getSession(I, y, k, P)
            )
          },
          getAccounts(y) {
            return U.getAccounts(y)
          },
          async hasSession(y, k) {
            return (
              F(I, "authSession"),
              !!(await U.getSession(I, y, k, { silent: !0 }))
            )
          },
          get onDidChangeSessions() {
            return j(U.getExtensionScopedSessionsEvent(I.identifier.value))
          },
          registerAuthenticationProvider(y, k, P, ct) {
            return U.registerAuthenticationProvider(y, k, P, ct)
          },
        },
        Est = {
          registerCommand(y, k, P) {
            return et.registerCommand(!0, y, k, P, void 0, I)
          },
          registerTextEditorCommand(y, k, P) {
            return et.registerCommand(
              !0,
              y,
              (...ct) => {
                const Xt = le.getActiveTextEditor()
                if (!Xt) {
                  g.warn(
                    "Cannot execute " +
                      y +
                      " because there is no active text editor.",
                  )
                  return
                }
                return Xt.edit((xe) => {
                  k.apply(P, [Xt, xe, ...ct])
                }).then(
                  (xe) => {
                    xe ||
                      g.warn("Edits from command " + y + " were not applied.")
                  },
                  (xe) => {
                    g.warn("An error occurred while running command " + y, xe)
                  },
                )
              },
              void 0,
              void 0,
              I,
            )
          },
          registerDiffInformationCommand: (y, k, P) => (
            F(I, "diffCommand"),
            et.registerCommand(
              !0,
              y,
              async (...ct) => {
                const Xt = at.activeEditor(!0)
                if (!Xt) {
                  g.warn(
                    "Cannot execute " +
                      y +
                      " because there is no active text editor.",
                  )
                  return
                }
                const xe = await le.getDiffInformation(Xt.id)
                k.apply(P, [xe, ...ct])
              },
              void 0,
              void 0,
              I,
            )
          ),
          executeCommand(y, ...k) {
            return et.executeCommand(y, ...k)
          },
          getCommands(y = !1) {
            return et.getCommands(y)
          },
        },
        Ist = I.identifier.value === "ms-python.python",
        Pst = I.identifier.value === "ms-python.vscode-pylance",
        AF = {
          get machineId() {
            return t.telemetryInfo.machineId
          },
          get macMachineId() {
            return t.telemetryInfo.macMachineId
          },
          get sessionId() {
            return t.telemetryInfo.sessionId
          },
          get language() {
            return t.environment.appLanguage
          },
          get appName() {
            return Pst || Ist ? "Visual Studio Code" : t.environment.appName
          },
          get appRoot() {
            return t.environment.appRoot?.fsPath ?? ""
          },
          get appHost() {
            return t.environment.appHost
          },
          get uriScheme() {
            return t.environment.appUriScheme
          },
          get clipboard() {
            return $e.value
          },
          get shell() {
            return wt.getDefaultShell(!1)
          },
          get onDidChangeShell() {
            return j(wt.onDidChangeShell)
          },
          get isTelemetryEnabled() {
            return o.getTelemetryConfiguration()
          },
          get onDidChangeTelemetryEnabled() {
            return j(o.onDidChangeTelemetryEnabled)
          },
          get telemetryConfiguration() {
            return F(I, "telemetry"), o.getTelemetryDetails()
          },
          get onDidChangeTelemetryConfiguration() {
            return F(I, "telemetry"), j(o.onDidChangeTelemetryConfiguration)
          },
          get isNewAppInstall() {
            return SX(t.telemetryInfo.firstSessionDate)
          },
          createTelemetryLogger(y, k) {
            return kX.validateSender(y), o.instantiateLogger(I, y, k)
          },
          openExternal(y, k) {
            return b.openUri(y, {
              allowTunneling: !!t.remote.authority,
              allowContributedOpeners: k?.allowContributedOpeners,
            })
          },
          async asExternalUri(y) {
            if (y.scheme === t.environment.appUriScheme)
              return X.createAppUri(y)
            try {
              return await b.asExternalUri(y, {
                allowTunneling: !!t.remote.authority,
              })
            } catch (k) {
              if (CB(y, Q.http) || CB(y, Q.https)) return y
              throw k
            }
          },
          get remoteName() {
            return P3(t.remote.authority)
          },
          get remoteAuthority() {
            return F(I, "resolvers"), t.remote.authority
          },
          get uiKind() {
            return t.uiKind
          },
          get logLevel() {
            return g.getLevel()
          },
          get onDidChangeLogLevel() {
            return j(g.onDidChangeLogLevel)
          },
          get appQuality() {
            return F(I, "resolvers"), t.quality
          },
          get appCommit() {
            return F(I, "resolvers"), t.commit
          },
        }
      t.environment.extensionTestsLocationURI || Object.freeze(AF)
      const Nst = {
          createTestController(y, k, P) {
            return yr.createTestController(I, y, k, P)
          },
          createTestObserver() {
            return F(I, "testObserver"), yr.createTestObserver()
          },
          runTests(y) {
            return F(I, "testObserver"), yr.runTests(y)
          },
          registerTestFollowupProvider(y) {
            return F(I, "testObserver"), yr.registerTestFollowupProvider(y)
          },
          get onDidChangeTestResults() {
            return F(I, "testObserver"), j(yr.onResultsChanged)
          },
          get testResults() {
            return F(I, "testObserver"), yr.results
          },
        },
        BF = t.remote.isRemote ? Na.Workspace : Na.UI,
        $st = {
          getExtension(y, k) {
            if (a2.modifiedExtensionDependencies?.[y]) {
              const ct = a2.modifiedExtensionDependencies[y]
              y !== ct && (y = ct)
            }
            Qe(I, "extensionsAny") || (k = !1)
            const P = yt.mine.getExtensionDescription(y)
            if (P) return new qd(s, I.identifier, P, BF, !1)
            if (k) {
              const ct = yt.all.getExtensionDescription(y)
              if (ct) return new qd(s, I.identifier, ct, BF, !0)
            }
          },
          get all() {
            I.identifier.value
            const y = []
            for (const k of yt.mine.getAllExtensionDescriptions())
              y.push(new qd(s, I.identifier, k, BF, !1))
            return y
          },
          get allAcrossExtensionHosts() {
            F(I, "extensionsAny")
            const y = new la(
                yt.mine.getAllExtensionDescriptions().map((P) => P.identifier),
              ),
              k = []
            for (const P of yt.all.getAllExtensionDescriptions()) {
              const ct = !y.has(P.identifier)
              k.push(new qd(s, I.identifier, P, BF, ct))
            }
            return k
          },
          get onDidChange() {
            return Qe(I, "extensionsAny")
              ? j(Ee.any(yt.mine.onDidChange, yt.all.onDidChange))
              : j(yt.mine.onDidChange)
          },
        },
        xst = {
          createDiagnosticCollection(y) {
            return Ws.createDiagnosticCollection(I.identifier, y)
          },
          get onDidChangeDiagnostics() {
            return j(Ws.onDidChangeDiagnostics)
          },
          getDiagnostics: (y) => Ws.getDiagnostics(y),
          getLanguages() {
            return or.getLanguages()
          },
          setTextDocumentLanguage(y, k) {
            return or.changeLanguage(y.uri, k)
          },
          match(y, k) {
            const P = oq.from(y)
            let ct
            return (
              uZ(P) &&
                (ct = Pt.notebookDocuments.find((Xt) =>
                  Xt.apiNotebook.getCells().find((xe) => xe.document === k),
                )?.apiNotebook),
              cZ(P, k.uri, k.languageId, !0, ct?.uri, ct?.notebookType)
            )
          },
          registerCodeActionsProvider(y, k, P) {
            return $t.registerCodeActionProvider(I, gt(y), k, P)
          },
          registerDocumentPasteEditProvider(y, k, P) {
            return (
              F(I, "documentPaste"),
              $t.registerDocumentPasteEditProvider(I, gt(y), k, P)
            )
          },
          registerCodeLensProvider(y, k) {
            return $t.registerCodeLensProvider(I, gt(y), k)
          },
          registerDefinitionProvider(y, k) {
            return $t.registerDefinitionProvider(I, gt(y), k)
          },
          registerDeclarationProvider(y, k) {
            return $t.registerDeclarationProvider(I, gt(y), k)
          },
          registerImplementationProvider(y, k) {
            return $t.registerImplementationProvider(I, gt(y), k)
          },
          registerTypeDefinitionProvider(y, k) {
            return $t.registerTypeDefinitionProvider(I, gt(y), k)
          },
          registerHoverProvider(y, k) {
            return $t.registerHoverProvider(I, gt(y), k, I.identifier)
          },
          registerEvaluatableExpressionProvider(y, k) {
            return $t.registerEvaluatableExpressionProvider(
              I,
              gt(y),
              k,
              I.identifier,
            )
          },
          registerInlineValuesProvider(y, k) {
            return $t.registerInlineValuesProvider(I, gt(y), k, I.identifier)
          },
          registerDocumentHighlightProvider(y, k) {
            return $t.registerDocumentHighlightProvider(I, gt(y), k)
          },
          registerMultiDocumentHighlightProvider(y, k) {
            return $t.registerMultiDocumentHighlightProvider(I, gt(y), k)
          },
          registerLinkedEditingRangeProvider(y, k) {
            return $t.registerLinkedEditingRangeProvider(I, gt(y), k)
          },
          registerReferenceProvider(y, k) {
            return $t.registerReferenceProvider(I, gt(y), k)
          },
          registerRenameProvider(y, k) {
            return $t.registerRenameProvider(I, gt(y), k)
          },
          registerNewSymbolNamesProvider(y, k) {
            return (
              F(I, "newSymbolNamesProvider"),
              $t.registerNewSymbolNamesProvider(I, gt(y), k)
            )
          },
          registerDocumentSymbolProvider(y, k, P) {
            return $t.registerDocumentSymbolProvider(I, gt(y), k, P)
          },
          registerWorkspaceSymbolProvider(y) {
            return $t.registerWorkspaceSymbolProvider(I, y)
          },
          registerDocumentFormattingEditProvider(y, k) {
            return $t.registerDocumentFormattingEditProvider(I, gt(y), k)
          },
          registerDocumentRangeFormattingEditProvider(y, k) {
            return $t.registerDocumentRangeFormattingEditProvider(I, gt(y), k)
          },
          registerOnTypeFormattingEditProvider(y, k, P, ...ct) {
            return $t.registerOnTypeFormattingEditProvider(
              I,
              gt(y),
              k,
              [P].concat(ct),
            )
          },
          registerDocumentSemanticTokensProvider(y, k, P) {
            return $t.registerDocumentSemanticTokensProvider(I, gt(y), k, P)
          },
          registerDocumentRangeSemanticTokensProvider(y, k, P) {
            return $t.registerDocumentRangeSemanticTokensProvider(
              I,
              gt(y),
              k,
              P,
            )
          },
          registerSignatureHelpProvider(y, k, P, ...ct) {
            return typeof P == "object"
              ? $t.registerSignatureHelpProvider(I, gt(y), k, P)
              : $t.registerSignatureHelpProvider(
                  I,
                  gt(y),
                  k,
                  typeof P > "u" ? [] : [P, ...ct],
                )
          },
          registerCompletionItemProvider(y, k, ...P) {
            return $t.registerCompletionItemProvider(I, gt(y), k, P)
          },
          registerInlineCompletionItemProvider(y, k, P) {
            return (
              k.handleDidShowCompletionItem &&
                F(I, "inlineCompletionsAdditions"),
              k.handleDidPartiallyAcceptCompletionItem &&
                F(I, "inlineCompletionsAdditions"),
              P && F(I, "inlineCompletionsAdditions"),
              $t.registerInlineCompletionsProvider(I, gt(y), k, P)
            )
          },
          registerInlineEditProvider(y, k) {
            return (
              F(I, "inlineEdit"), $t.registerInlineEditProvider(I, gt(y), k)
            )
          },
          registerDocumentLinkProvider(y, k) {
            return $t.registerDocumentLinkProvider(I, gt(y), k)
          },
          registerColorProvider(y, k) {
            return $t.registerColorProvider(I, gt(y), k)
          },
          registerFoldingRangeProvider(y, k) {
            return $t.registerFoldingRangeProvider(I, gt(y), k)
          },
          registerSelectionRangeProvider(y, k) {
            return $t.registerSelectionRangeProvider(I, y, k)
          },
          registerCallHierarchyProvider(y, k) {
            return $t.registerCallHierarchyProvider(I, y, k)
          },
          registerTypeHierarchyProvider(y, k) {
            return $t.registerTypeHierarchyProvider(I, y, k)
          },
          setLanguageConfiguration: (y, k) =>
            $t.setLanguageConfiguration(I, y, k),
          getTokenInformationAtPosition(y, k) {
            return F(I, "tokenInformation"), or.tokenAtPosition(y, k)
          },
          registerInlayHintsProvider(y, k) {
            return $t.registerInlayHintsProvider(I, y, k)
          },
          createLanguageStatusItem(y, k) {
            return or.createLanguageStatusItem(I, y, k)
          },
          registerDocumentDropEditProvider(y, k, P) {
            return $t.registerDocumentOnDropEditProvider(
              I,
              y,
              k,
              Qe(I, "documentPaste") ? P : void 0,
            )
          },
        },
        Jst = {
          get activeTextEditor() {
            return le.getActiveTextEditor()
          },
          get visibleTextEditors() {
            return le.getVisibleTextEditors()
          },
          get activeTerminal() {
            return wt.activeTerminal
          },
          get terminals() {
            return wt.terminals
          },
          async showTextDocument(y, k, P) {
            S.isUri(y) &&
              y.scheme === Q.vscodeRemote &&
              !y.authority &&
              T.report(
                "workspace.showTextDocument",
                I,
                "A URI of 'vscode-remote' scheme requires an authority.",
              )
            const ct = await (S.isUri(y)
              ? Promise.resolve($H.openTextDocument(y))
              : Promise.resolve(y))
            return le.showTextDocument(ct, k, P)
          },
          createTextEditorDecorationType(y) {
            return le.createTextEditorDecorationType(I, y)
          },
          onDidChangeActiveTextEditor(y, k, P) {
            return j(le.onDidChangeActiveTextEditor)(y, k, P)
          },
          onDidChangeVisibleTextEditors(y, k, P) {
            return j(le.onDidChangeVisibleTextEditors)(y, k, P)
          },
          onDidChangeTextEditorSelection(y, k, P) {
            return j(le.onDidChangeTextEditorSelection)(y, k, P)
          },
          onDidChangeTextEditorOptions(y, k, P) {
            return j(le.onDidChangeTextEditorOptions)(y, k, P)
          },
          onDidChangeTextEditorVisibleRanges(y, k, P) {
            return j(le.onDidChangeTextEditorVisibleRanges)(y, k, P)
          },
          onDidChangeTextEditorViewColumn(y, k, P) {
            return j(le.onDidChangeTextEditorViewColumn)(y, k, P)
          },
          onDidChangeTextEditorDiffInformation(y, k, P) {
            return (
              F(I, "textEditorDiffInformation"),
              j(le.onDidChangeTextEditorDiffInformation)(y, k, P)
            )
          },
          onDidCloseTerminal(y, k, P) {
            return j(wt.onDidCloseTerminal)(y, k, P)
          },
          onDidOpenTerminal(y, k, P) {
            return j(wt.onDidOpenTerminal)(y, k, P)
          },
          onDidChangeActiveTerminal(y, k, P) {
            return j(wt.onDidChangeActiveTerminal)(y, k, P)
          },
          onDidChangeTerminalDimensions(y, k, P) {
            return (
              F(I, "terminalDimensions"),
              j(wt.onDidChangeTerminalDimensions)(y, k, P)
            )
          },
          onDidChangeTerminalState(y, k, P) {
            return j(wt.onDidChangeTerminalState)(y, k, P)
          },
          onDidWriteTerminalData(y, k, P) {
            return (
              F(I, "terminalDataWriteEvent"),
              j(wt.onDidWriteTerminalData)(y, k, P)
            )
          },
          onDidExecuteTerminalCommand(y, k, P) {
            return (
              F(I, "terminalExecuteCommandEvent"),
              j(wt.onDidExecuteTerminalCommand)(y, k, P)
            )
          },
          onDidChangeTerminalShellIntegration(y, k, P) {
            return j(zt.onDidChangeTerminalShellIntegration)(y, k, P)
          },
          onDidStartTerminalShellExecution(y, k, P) {
            return j(zt.onDidStartTerminalShellExecution)(y, k, P)
          },
          onDidEndTerminalShellExecution(y, k, P) {
            return j(zt.onDidEndTerminalShellExecution)(y, k, P)
          },
          get state() {
            return b.getState()
          },
          onDidChangeWindowState(y, k, P) {
            return j(b.onDidChangeWindowState)(y, k, P)
          },
          showInformationMessage(y, ...k) {
            return Oe.showMessage(I, ke.Info, y, k[0], k.slice(1))
          },
          showWarningMessage(y, ...k) {
            return Oe.showMessage(I, ke.Warning, y, k[0], k.slice(1))
          },
          showErrorMessage(y, ...k) {
            return Oe.showMessage(I, ke.Error, y, k[0], k.slice(1))
          },
          showQuickPick(y, k, P) {
            return Ii.showQuickPick(I, y, k, P)
          },
          showWorkspaceFolderPick(y) {
            return Ii.showWorkspaceFolderPick(y)
          },
          showInputBox(y, k) {
            return Ii.showInput(y, k)
          },
          showOpenDialog(y) {
            return pi.showOpenDialog(I, y)
          },
          showSaveDialog(y) {
            return pi.showSaveDialog(y)
          },
          createStatusBarItem(y, k, P) {
            let ct, Xt, xe
            return (
              typeof y == "string"
                ? ((ct = y), (Xt = k), (xe = P))
                : ((Xt = y), (xe = k)),
              Yt.createStatusBarEntry(I, ct, Xt, xe)
            )
          },
          setStatusBarMessage(y, k) {
            return Yt.setStatusBarMessage(y, k)
          },
          withScmProgress(y) {
            return (
              T.report(
                "window.withScmProgress",
                I,
                "Use 'withProgress' instead.",
              ),
              ro.withProgress(I, { location: ba.SourceControl }, (k, P) =>
                y({ report(ct) {} }),
              )
            )
          },
          withProgress(y, k) {
            return ro.withProgress(I, y, k)
          },
          createOutputChannel(y, k) {
            return W.createOutputChannel(y, k, I)
          },
          createWebviewPanel(y, k, P, ct) {
            return ti.createWebviewPanel(I, y, k, P, ct)
          },
          createWebviewTextEditorInset(y, k, P, ct) {
            return (
              F(I, "editorInsets"), eo.createWebviewEditorInset(y, k, P, ct, I)
            )
          },
          createTerminal(y, k, P) {
            return typeof y == "object"
              ? "pty" in y
                ? wt.createExtensionTerminal(y)
                : wt.createTerminalFromOptions(y)
              : wt.createTerminal(y, k, P)
          },
          registerTerminalLinkProvider(y) {
            return wt.registerLinkProvider(y)
          },
          registerTerminalProfileProvider(y, k) {
            return wt.registerProfileProvider(I, y, k)
          },
          registerTerminalCompletionProvider(y, ...k) {
            return (
              F(I, "terminalCompletionProvider"),
              wt.registerTerminalCompletionProvider(I, y, ...k)
            )
          },
          registerTerminalQuickFixProvider(y, k) {
            return (
              F(I, "terminalQuickFixProvider"),
              wt.registerTerminalQuickFixProvider(y, I.identifier.value, k)
            )
          },
          registerTreeDataProvider(y, k) {
            return mn.registerTreeDataProvider(y, k, I)
          },
          createTreeView(y, k) {
            return mn.createTreeView(y, k, I)
          },
          registerWebviewPanelSerializer: (y, k) =>
            ti.registerWebviewPanelSerializer(I, y, k),
          registerCustomEditorProvider: (y, k, P = {}) =>
            X8.registerCustomEditorProvider(I, y, k, P),
          registerFileDecorationProvider(y) {
            return lt.registerFileDecorationProvider(y, I)
          },
          registerUriHandler(y) {
            return X.registerUriHandler(I, y)
          },
          createQuickPick() {
            return Ii.createQuickPick(I)
          },
          createInputBox() {
            return Ii.createInputBox(I)
          },
          get activeColorTheme() {
            return js.activeColorTheme
          },
          onDidChangeActiveColorTheme(y, k, P) {
            return j(js.onDidChangeActiveColorTheme)(y, k, P)
          },
          registerWebviewViewProvider(y, k, P) {
            return K8.registerWebviewViewProvider(I, y, k, P?.webviewOptions)
          },
          get activeNotebookEditor() {
            return Pt.activeNotebookEditor
          },
          onDidChangeActiveNotebookEditor(y, k, P) {
            return j(Pt.onDidChangeActiveNotebookEditor)(y, k, P)
          },
          get visibleNotebookEditors() {
            return Pt.visibleNotebookEditors
          },
          get onDidChangeVisibleNotebookEditors() {
            return j(Pt.onDidChangeVisibleNotebookEditors)
          },
          onDidChangeNotebookEditorSelection(y, k, P) {
            return j(Ze.onDidChangeNotebookEditorSelection)(y, k, P)
          },
          onDidChangeNotebookEditorVisibleRanges(y, k, P) {
            return j(Ze.onDidChangeNotebookEditorVisibleRanges)(y, k, P)
          },
          showNotebookDocument(y, k) {
            return Pt.showNotebookDocument(y, k)
          },
          registerExternalUriOpener(y, k, P) {
            return (
              F(I, "externalUriOpener"),
              yu.registerExternalUriOpener(I.identifier, y, k, P)
            )
          },
          registerProfileContentHandler(y, k) {
            return (
              F(I, "profileContentHandlers"),
              x.registerProfileContentHandler(I, y, k)
            )
          },
          registerQuickDiffProvider(y, k, P, ct) {
            return (
              F(I, "quickDiffProvider"),
              io.registerQuickDiffProvider(gt(y), k, P, ct)
            )
          },
          get tabGroups() {
            return $.tabGroups
          },
          registerShareProvider(y, k) {
            return F(I, "shareProvider"), vu.registerShareProvider(gt(y), k)
          },
          get nativeHandle() {
            return F(I, "nativeWindowHandle"), b.nativeHandle
          },
        },
        $H = {
          get rootPath() {
            return (
              T.report(
                "workspace.rootPath",
                I,
                "Please use 'workspace.workspaceFolders' instead. More details: https://aka.ms/vscode-eliminating-rootpath",
              ),
              a.getPath()
            )
          },
          set rootPath(y) {
            throw new zs("rootPath")
          },
          getWorkspaceFolder(y) {
            return a.getWorkspaceFolder(y)
          },
          get workspaceFolders() {
            return a.getWorkspaceFolders()
          },
          get name() {
            return a.name
          },
          set name(y) {
            throw new zs("name")
          },
          get workspaceFile() {
            return a.workspaceFile
          },
          set workspaceFile(y) {
            throw new zs("workspaceFile")
          },
          updateWorkspaceFolders: (y, k, ...P) =>
            a.updateWorkspaceFolders(I, y, k || 0, ...P),
          onDidChangeWorkspaceFolders: function (y, k, P) {
            return j(a.onDidChangeWorkspace)(y, k, P)
          },
          asRelativePath: (y, k) => a.getRelativePath(y, k),
          findFiles: (y, k, P, ct) => a.findFiles(y, k, P, I.identifier, ct),
          findFiles2: (y, k, P) => (
            F(I, "findFiles2"), a.findFiles2(y, k, I.identifier, P)
          ),
          findTextInFiles: (y, k, P, ct) => {
            F(I, "findTextInFiles")
            let Xt, xe
            return (
              typeof k == "object"
                ? ((Xt = k), (xe = P))
                : ((Xt = {}), (xe = k), (ct = P)),
              a.findTextInFiles(y, Xt || {}, xe, I.identifier, ct)
            )
          },
          findTextInFiles2: (y, k, P) => (
            F(I, "findTextInFiles2"),
            F(I, "textSearchProvider2"),
            a.findTextInFiles2(y, k, I.identifier, P)
          ),
          save: (y) => a.save(y),
          saveAs: (y) => a.saveAs(y),
          saveAll: (y) => a.saveAll(y),
          applyEdit(y, k) {
            return cr.applyWorkspaceEdit(y, I, k)
          },
          createFileSystemWatcher: (y, k, P, ct) => {
            let Xt
            return (
              k && typeof k != "boolean"
                ? (F(I, "createFileSystemWatcher"),
                  (Xt = { ...k, correlate: !0 }))
                : (Xt = {
                    ignoreCreateEvents: !!k,
                    ignoreChangeEvents: !!P,
                    ignoreDeleteEvents: !!ct,
                    correlate: !1,
                  }),
              Oi.createFileSystemWatcher(a, Rt, I, y, Xt)
            )
          },
          get textDocuments() {
            return Z.getAllDocumentData().map((y) => y.document)
          },
          set textDocuments(y) {
            throw new zs("textDocuments")
          },
          openTextDocument(y) {
            let k
            const P = y
            if (typeof y == "string") k = Promise.resolve(S.file(y))
            else if (S.isUri(y)) k = Promise.resolve(y)
            else if (!P || typeof P == "object") k = Z.createDocumentData(P)
            else throw new Error("illegal argument - uriOrFileNameOrOptions")
            return k.then(
              (ct) => (
                g.trace(`openTextDocument from ${I.identifier}`),
                ct.scheme === Q.vscodeRemote &&
                  !ct.authority &&
                  T.report(
                    "workspace.openTextDocument",
                    I,
                    "A URI of 'vscode-remote' scheme requires an authority.",
                  ),
                Z.ensureDocumentData(ct).then((Xt) => Xt.document)
              ),
            )
          },
          onDidOpenTextDocument: (y, k, P) => j(Z.onDidAddDocument)(y, k, P),
          onDidCloseTextDocument: (y, k, P) =>
            j(Z.onDidRemoveDocument)(y, k, P),
          onDidChangeTextDocument: (y, k, P) =>
            j(Z.onDidChangeDocument)(y, k, P),
          onDidSaveTextDocument: (y, k, P) => j(Z.onDidSaveDocument)(y, k, P),
          onWillSaveTextDocument: (y, k, P) =>
            j(Dt.getOnWillSaveTextDocumentEvent(I))(y, k, P),
          get notebookDocuments() {
            return Pt.notebookDocuments.map((y) => y.apiNotebook)
          },
          async openNotebookDocument(y, k) {
            let P
            if (S.isUri(y)) (P = y), await Pt.openNotebookDocument(y)
            else if (typeof y == "string")
              P = S.revive(
                await Pt.createNotebookDocument({ viewType: y, content: k }),
              )
            else throw new Error("Invalid arguments")
            return Pt.getNotebookDocument(P).apiNotebook
          },
          onDidSaveNotebookDocument(y, k, P) {
            return j(ie.onDidSaveNotebookDocument)(y, k, P)
          },
          onDidChangeNotebookDocument(y, k, P) {
            return j(ie.onDidChangeNotebookDocument)(y, k, P)
          },
          onWillSaveNotebookDocument(y, k, P) {
            return j(wi.getOnWillSaveNotebookDocumentEvent(I))(y, k, P)
          },
          get onDidOpenNotebookDocument() {
            return j(Pt.onDidOpenNotebookDocument)
          },
          get onDidCloseNotebookDocument() {
            return j(Pt.onDidCloseNotebookDocument)
          },
          registerNotebookSerializer(y, k, P, ct) {
            return Pt.registerNotebookSerializer(
              I,
              y,
              k,
              P,
              Qe(I, "notebookLiveShare") ? ct : void 0,
            )
          },
          onDidChangeConfiguration: (y, k, P) =>
            j(Rt.onDidChangeConfiguration)(y, k, P),
          getConfiguration(y, k) {
            return (
              (k = arguments.length === 1 ? void 0 : k),
              Rt.getConfiguration(y, k, I)
            )
          },
          registerTextDocumentContentProvider(y, k) {
            return St.registerTextDocumentContentProvider(y, k)
          },
          registerTaskProvider: (y, k) => (
            T.report(
              "window.registerTaskProvider",
              I,
              "Use the corresponding function on the 'tasks' namespace instead",
            ),
            G.registerTaskProvider(I, y, k)
          ),
          registerFileSystemProvider(y, k, P) {
            return qH(
              FF.registerFileSystemProvider(I, y, k, P),
              r.addFileSystemProvider(y, k, P),
            )
          },
          get fs() {
            return r.value
          },
          registerFileSearchProvider: (y, k) => (
            F(I, "fileSearchProvider"), be.registerFileSearchProviderOld(y, k)
          ),
          registerTextSearchProvider: (y, k) => (
            F(I, "textSearchProvider"), be.registerTextSearchProviderOld(y, k)
          ),
          registerAITextSearchProvider: (y, k) => (
            F(I, "aiTextSearchProvider"),
            F(I, "textSearchProvider2"),
            be.registerAITextSearchProvider(y, k)
          ),
          registerFileSearchProvider2: (y, k) => (
            F(I, "fileSearchProvider2"), be.registerFileSearchProvider(y, k)
          ),
          registerTextSearchProvider2: (y, k) => (
            F(I, "textSearchProvider2"), be.registerTextSearchProvider(y, k)
          ),
          registerRemoteAuthorityResolver: (y, k) => (
            F(I, "resolvers"), s.registerRemoteAuthorityResolver(y, k)
          ),
          registerResourceLabelFormatter: (y) => (
            F(I, "resolvers"), wu.$registerResourceLabelFormatter(y)
          ),
          getRemoteExecServer: (y) => (
            F(I, "resolvers"), s.getRemoteExecServer(y)
          ),
          onDidCreateFiles: (y, k, P) => j(Oi.onDidCreateFile)(y, k, P),
          onDidDeleteFiles: (y, k, P) => j(Oi.onDidDeleteFile)(y, k, P),
          onDidRenameFiles: (y, k, P) => j(Oi.onDidRenameFile)(y, k, P),
          onWillCreateFiles: (y, k, P) =>
            j(Oi.getOnWillCreateFileEvent(I))(y, k, P),
          onWillDeleteFiles: (y, k, P) =>
            j(Oi.getOnWillDeleteFileEvent(I))(y, k, P),
          onWillRenameFiles: (y, k, P) =>
            j(Oi.getOnWillRenameFileEvent(I))(y, k, P),
          openTunnel: (y) => (
            F(I, "tunnels"),
            w.openTunnel(I, y).then((k) => {
              if (!k) throw new Error("cannot open tunnel")
              return k
            })
          ),
          get tunnels() {
            return F(I, "tunnels"), w.getTunnels()
          },
          onDidChangeTunnels: (y, k, P) => (
            F(I, "tunnels"), j(w.onDidChangeTunnels)(y, k, P)
          ),
          registerPortAttributesProvider: (y, k) => (
            F(I, "portsAttributes"), w.registerPortsAttributesProvider(y, k)
          ),
          registerTunnelProvider: (y, k) => (
            F(I, "tunnelFactory"), w.registerTunnelProvider(y, k)
          ),
          registerTimelineProvider: (y, k) => (
            F(I, "timeline"),
            Vs.registerTimelineProvider(y, k, I.identifier, et.converter)
          ),
          get isTrusted() {
            return a.trusted
          },
          requestWorkspaceTrust: (y) => (
            F(I, "workspaceTrust"), a.requestWorkspaceTrust(y)
          ),
          onDidGrantWorkspaceTrust: (y, k, P) =>
            j(a.onDidGrantWorkspaceTrust)(y, k, P),
          registerEditSessionIdentityProvider: (y, k) => (
            F(I, "editSessionIdentityProvider"),
            a.registerEditSessionIdentityProvider(y, k)
          ),
          onWillCreateEditSessionIdentity: (y, k, P) => (
            F(I, "editSessionIdentityProvider"),
            j(a.getOnWillCreateEditSessionIdentityEvent(I))(y, k, P)
          ),
          registerControlProvider: (y, k) => (
            F(I, "control"), a.registerControlProvider(y, k)
          ),
          registerCanonicalUriProvider: (y, k) => (
            F(I, "canonicalUriProvider"), a.registerCanonicalUriProvider(y, k)
          ),
          getCanonicalUri: (y, k, P) => (
            F(I, "canonicalUriProvider"), a.provideCanonicalUri(y, k, P)
          ),
        },
        Cst = {
          get inputBox() {
            return (
              T.report(
                "scm.inputBox",
                I,
                "Use 'SourceControl.inputBox' instead",
              ),
              hn.getLastInputBox(I)
            )
          },
          createSourceControl(y, k, P) {
            return hn.createSourceControl(I, y, k, P)
          },
          registerGitContextProvider(y) {
            return F(I, "cursor"), hn.registerGitContextProvider(y)
          },
          gitStatusWasRun(y) {
            return F(I, "cursorNoDeps"), hn.gitStatusWasRun(y)
          },
        },
        Lst = {
          createCommentController(y, k) {
            return _F.createCommentController(I, y, k)
          },
        },
        Rst = {
          get activeDebugSession() {
            return Ct.activeDebugSession
          },
          get activeDebugConsole() {
            return Ct.activeDebugConsole
          },
          get breakpoints() {
            return Ct.breakpoints
          },
          get activeStackItem() {
            return Ct.activeStackItem
          },
          registerDebugVisualizationProvider(y, k) {
            return (
              F(I, "debugVisualization"),
              Ct.registerDebugVisualizationProvider(I, y, k)
            )
          },
          registerDebugVisualizationTreeProvider(y, k) {
            return (
              F(I, "debugVisualization"),
              Ct.registerDebugVisualizationTree(I, y, k)
            )
          },
          onDidStartDebugSession(y, k, P) {
            return j(Ct.onDidStartDebugSession)(y, k, P)
          },
          onDidTerminateDebugSession(y, k, P) {
            return j(Ct.onDidTerminateDebugSession)(y, k, P)
          },
          onDidChangeActiveDebugSession(y, k, P) {
            return j(Ct.onDidChangeActiveDebugSession)(y, k, P)
          },
          onDidReceiveDebugSessionCustomEvent(y, k, P) {
            return j(Ct.onDidReceiveDebugSessionCustomEvent)(y, k, P)
          },
          onDidChangeBreakpoints(y, k, P) {
            return j(Ct.onDidChangeBreakpoints)(y, k, P)
          },
          onDidChangeActiveStackItem(y, k, P) {
            return j(Ct.onDidChangeActiveStackItem)(y, k, P)
          },
          registerDebugConfigurationProvider(y, k, P) {
            return Ct.registerDebugConfigurationProvider(y, k, P || R8.Initial)
          },
          registerDebugAdapterDescriptorFactory(y, k) {
            return Ct.registerDebugAdapterDescriptorFactory(I, y, k)
          },
          registerDebugAdapterTrackerFactory(y, k) {
            return Ct.registerDebugAdapterTrackerFactory(y, k)
          },
          startDebugging(y, k, P) {
            return !P || (typeof P == "object" && "configuration" in P)
              ? Ct.startDebugging(y, k, { parentSession: P })
              : Ct.startDebugging(y, k, P || {})
          },
          stopDebugging(y) {
            return Ct.stopDebugging(y)
          },
          addBreakpoints(y) {
            return Ct.addBreakpoints(y)
          },
          removeBreakpoints(y) {
            return Ct.removeBreakpoints(y)
          },
          asDebugSourceUri(y, k) {
            return Ct.asDebugSourceUri(y, k)
          },
        },
        Dst = {
          registerTaskProvider: (y, k) => G.registerTaskProvider(I, y, k),
          fetchTasks: (y) => G.fetchTasks(y),
          executeTask: (y) => G.executeTask(I, y),
          get taskExecutions() {
            return G.taskExecutions
          },
          onDidStartTask: (y, k, P) => j(G.onDidStartTask)(y, k, P),
          onDidEndTask: (y, k, P) => j(G.onDidEndTask)(y, k, P),
          onDidStartTaskProcess: (y, k, P) =>
            j(G.onDidStartTaskProcess)(y, k, P),
          onDidEndTaskProcess: (y, k, P) => j(G.onDidEndTaskProcess)(y, k, P),
        },
        Fst = {
          createNotebookController(y, k, P, ct, Xt) {
            return Te.createNotebookController(
              I,
              y,
              k,
              P,
              ct,
              Qe(I, "notebookMessaging") ? Xt : void 0,
            )
          },
          registerNotebookCellStatusBarItemProvider: (y, k) =>
            Pt.registerNotebookCellStatusBarItemProvider(I, y, k),
          createRendererMessaging(y) {
            return si.createRendererMessaging(I, y)
          },
          createNotebookControllerDetectionTask(y) {
            return (
              F(I, "notebookKernelSource"),
              Te.createNotebookControllerDetectionTask(I, y)
            )
          },
          registerKernelSourceActionProvider(y, k) {
            return (
              F(I, "notebookKernelSource"),
              Te.registerKernelSourceActionProvider(I, y, k)
            )
          },
          onDidChangeNotebookCellExecutionState(y, k, P) {
            return (
              F(I, "notebookCellExecutionState"),
              j(Te.onDidChangeNotebookCellExecutionState)(y, k, P)
            )
          },
        },
        _st = {
          t(...y) {
            if (typeof y[0] == "string") {
              const k = y.shift(),
                P = !y || typeof y[0] != "object" ? y : y[0]
              return tt.getMessage(I.identifier.value, { message: k, args: P })
            }
            return tt.getMessage(I.identifier.value, y[0])
          },
          get bundle() {
            return tt.getBundle(I.identifier.value)
          },
          get uri() {
            return tt.getBundleUri(I.identifier.value)
          },
        },
        Ast = {
          transferActiveChat(y) {
            return F(I, "interactive"), D.transferActiveChat(y)
          },
        },
        Bst = {
          getRelatedInformation(y, k) {
            return (
              F(I, "aiRelatedInformation"), Tt.getRelatedInformation(I, y, k)
            )
          },
          registerRelatedInformationProvider(y, k) {
            return (
              F(I, "aiRelatedInformation"),
              Tt.registerRelatedInformationProvider(I, y, k)
            )
          },
          registerEmbeddingVectorProvider(y, k) {
            return (
              F(I, "aiRelatedInformation"),
              Ve.registerEmbeddingVectorProvider(I, y, k)
            )
          },
        },
        Ost = {
          registerChatResponseProvider(y, k, P) {
            return F(I, "chatProvider"), q.registerLanguageModel(I, y, k, P)
          },
          registerChatVariableResolver(y, k, P, ct, Xt, xe, Tu, Mst) {
            return (
              F(I, "chatVariableResolver"),
              B.registerVariableResolver(I, y, k, P, ct, Xt, xe, Tu, Mst?.id)
            )
          },
          registerMappedEditsProvider(y, k) {
            return (
              F(I, "mappedEditsProvider"),
              $t.registerMappedEditsProvider(I, y, k)
            )
          },
          registerMappedEditsProvider2(y) {
            return (
              F(I, "mappedEditsProvider"), Qt.registerMappedEditsProvider(I, y)
            )
          },
          createChatParticipant(y, k) {
            return D.createChatAgent(I, y, k)
          },
          createDynamicChatParticipant(y, k, P) {
            return (
              F(I, "chatParticipantPrivate"),
              D.createDynamicChatAgent(I, y, k, P)
            )
          },
          registerChatParticipantDetectionProvider(y) {
            return (
              F(I, "chatParticipantAdditions"),
              D.registerChatParticipantDetectionProvider(I, y)
            )
          },
          registerRelatedFilesProvider(y, k) {
            return F(I, "chatEditing"), D.registerRelatedFilesProvider(I, y, k)
          },
        },
        qst = {
          selectChatModels: (y) => q.selectLanguageModels(I, y ?? {}),
          onDidChangeChatModels: (y, k, P) => q.onDidChangeProviders(y, k, P),
          registerChatModelProvider: (y, k, P) => (
            F(I, "chatProvider"), q.registerLanguageModel(I, y, k, P)
          ),
          get embeddingModels() {
            return F(I, "embeddings"), me.embeddingsModels
          },
          onDidChangeEmbeddingModels: (y, k, P) => (
            F(I, "embeddings"), me.onDidChange(y, k, P)
          ),
          registerEmbeddingsProvider(y, k) {
            return F(I, "embeddings"), me.registerEmbeddingsProvider(I, y, k)
          },
          async computeEmbeddings(y, k, P) {
            return F(I, "embeddings"), me.computeEmbeddings(y, k, P)
          },
          registerTool(y, k) {
            return ot.registerTool(I, y, k)
          },
          invokeTool(y, k, P) {
            return ot.invokeTool(y, k, P)
          },
          get tools() {
            return ot.tools
          },
          fileIsIgnored(y, k) {
            return q.fileIsIgnored(I, y, k)
          },
          registerIgnoredFileProvider(y) {
            return q.registerIgnoredFileProvider(I, y)
          },
        },
        Ust = {
          registerSpeechProvider(y, k) {
            return F(I, "speech"), yi.registerProvider(I.identifier, y, k)
          },
        }
      return {
        version: t.vscodeVersion,
        cursorVersion: t.version,
        ai: Bst,
        authentication: Gs,
        commands: Est,
        comments: Lst,
        chat: Ost,
        debug: Rst,
        env: AF,
        extensions: $st,
        interactive: Ast,
        l10n: _st,
        languages: xst,
        lm: qst,
        notebooks: Fst,
        scm: Cst,
        speech: Ust,
        tasks: Dst,
        tests: Nst,
        tracing: Gr,
        window: Jst,
        workspace: $H,
        Breakpoint: Go,
        TerminalOutputAnchor: G3,
        ChatResultFeedbackKind: Al,
        ChatVariableLevel: _O,
        ChatCompletionItem: Mmt,
        CallHierarchyIncomingCall: Yz,
        CallHierarchyItem: Q3,
        CallHierarchyOutgoingCall: Qz,
        CancellationError: zr,
        CancellationTokenSource: Ie,
        CandidatePortSource: EB,
        CodeAction: l6,
        CodeActionKind: ge,
        CodeActionTriggerKind: vl,
        CodeLens: d6,
        Color: Mo,
        ColorInformation: v6,
        ColorPresentation: w6,
        ColorThemeKind: vs,
        CommentMode: wO,
        CommentState: yO,
        CommentThreadCollapsibleState: xl,
        CommentThreadState: Jl,
        CommentThreadApplicability: Cl,
        CommentThreadFocus: Ll,
        CompletionItem: f6,
        CompletionItemKind: mt,
        CompletionItemTag: yl,
        CompletionList: Ao,
        CompletionTriggerKind: _o,
        ConfigurationTarget: jo,
        CustomExecution: dO,
        DebugAdapterExecutable: I6,
        DebugAdapterInlineImplementation: Pl,
        DebugAdapterNamedPipeServer: P6,
        DebugAdapterServer: Il,
        DebugConfigurationProviderTriggerKind: R8,
        DebugConsoleMode: L6,
        DebugVisualization: Fmt,
        DecorationRangeBehavior: ka,
        Diagnostic: s6,
        DiagnosticRelatedInformation: ml,
        DiagnosticSeverity: di,
        DiagnosticTag: ya,
        Disposable: At,
        DocumentHighlight: c6,
        DocumentHighlightKind: hl,
        MultiDocumentHighlight: u6,
        DocumentLink: g6,
        DocumentSymbol: gl,
        EndOfLine: xr,
        EnvironmentVariableMutatorType: Do,
        EvaluatableExpression: N6,
        InlineValueText: $6,
        InlineValueVariableLookup: x6,
        InlineValueEvaluatableExpression: J6,
        InlineCompletionTriggerKind: Nl,
        EventEmitter: C,
        ExtensionKind: Na,
        ExtensionMode: Ko,
        ExternalUriOpenerPriority: PO,
        FileChangeType: zo,
        FileDecoration: SO,
        FileDecoration2: SO,
        FileSystemError: Ue,
        FileType: ua,
        FilePermission: Eo,
        FoldingRange: vO,
        FoldingRangeKind: Nn,
        FunctionBreakpoint: Pa,
        InlineCompletionItem: iO,
        InlineCompletionList: rO,
        Hover: a6,
        VerboseHover: o6,
        HoverVerbosityAction: Y3,
        IndentAction: TU,
        Location: er,
        MarkdownString: Gi,
        OverviewRulerLane: L2,
        ParameterInformation: X3,
        PortAutoForwardAction: $O,
        Position: Lt,
        ProcessExecution: Ho,
        ProgressLocation: ba,
        QuickInputButtonLocation: kO,
        QuickInputButtons: Rl,
        Range: Nt,
        RelativePattern: Vo,
        Selection: Pn,
        SelectionRange: wl,
        SemanticTokens: Yo,
        SemanticTokensBuilder: Dmt,
        SemanticTokensEdit: iY,
        SemanticTokensEdits: C6,
        SemanticTokensLegend: TO,
        ShellExecution: Sa,
        ShellQuoting: lO,
        SignatureHelp: Z3,
        SignatureHelpTriggerKind: tO,
        SignatureInformation: K3,
        SnippetString: wa,
        SourceBreakpoint: Ia,
        StandardTokenType: ws,
        StatusBarAlignment: ps,
        SymbolInformation: pl,
        SymbolKind: ae,
        SymbolTag: fl,
        Task: T6,
        TaskGroup: Sl,
        TaskPanelKind: uO,
        TaskRevealKind: cO,
        TaskScope: gs,
        TerminalLink: Smt,
        TerminalQuickFixTerminalCommand: Emt,
        TerminalQuickFixOpener: bmt,
        TerminalLocation: aO,
        TerminalProfile: Imt,
        TerminalExitReason: sO,
        TerminalShellExecutionCommandLineConfidence: y6,
        TerminalCompletionItem: Pmt,
        TerminalCompletionItemKind: oO,
        TerminalCompletionList: Nmt,
        TextDocumentSaveReason: Bo,
        TextEdit: fs,
        SnippetTextEdit: z3,
        TextEditorCursorStyle: _r,
        TextEditorChangeKind: qo,
        TextEditorLineNumbersStyle: Jr,
        TextEditorRevealType: p6,
        TextEditorSelectionChangeKind: Oo,
        SyntaxTokenType: Uo,
        TextDocumentChangeReason: kl,
        ThemeColor: El,
        ThemeIcon: Si,
        TreeItem: k6,
        TreeItemCheckboxState: sn,
        TreeItemCollapsibleState: Ea,
        TypeHierarchyItem: xO,
        UIKind: Pu,
        Uri: S,
        ViewColumn: Tl,
        WorkspaceEdit: va,
        DocumentPasteTriggerKind: fO,
        DocumentDropEdit: hO,
        DocumentDropOrPasteEditKind: Wo,
        DocumentPasteEdit: Jmt,
        InlayHint: h6,
        InlayHintLabelPart: m6,
        InlayHintKind: eO,
        RemoteAuthorityResolverError: Ro,
        ResolvedAuthority: Tmt,
        ManagedResolvedAuthority: r6,
        SourceControlInputBoxValidationType: nO,
        ExtensionRuntime: O6,
        TimelineItem: EO,
        NotebookRange: $n,
        NotebookCellKind: $a,
        NotebookCellExecutionState: Xo,
        NotebookCellData: D6,
        NotebookData: rY,
        NotebookRendererScript: sY,
        NotebookCellStatusBarAlignment: _6,
        NotebookEditorRevealType: A6,
        NotebookCellOutput: F6,
        NotebookCellOutputItem: nY,
        CellErrorStackFrame: _mt,
        NotebookCellStatusBarItem: Amt,
        NotebookControllerAffinity: bO,
        NotebookControllerAffinity2: B6,
        NotebookEdit: n6,
        NotebookKernelSourceAction: Bmt,
        NotebookVariablesRequestKind: Fl,
        PortAttributes: qmt,
        LinkedEditingRanges: Omt,
        TestResultState: IO,
        TestRunRequest: q6,
        TestMessage: U6,
        TestMessageStackFrame: Umt,
        TestTag: _l,
        TestRunProfileKind: Zo,
        TextSearchCompleteMessageType: DA,
        DataTransfer: bl,
        DataTransferItem: S6,
        TestCoverageCount: M6,
        FileCoverage: W6,
        StatementCoverage: oY,
        BranchCoverage: cY,
        DeclarationCoverage: uY,
        WorkspaceTrustState: NO,
        LanguageStatusSeverity: Fo,
        QuickPickItemKind: Dl,
        InputBoxValidationSeverity: Qo,
        TabInputText: JO,
        TabInputTextDiff: j6,
        TabInputTextMerge: lY,
        TabInputCustom: CO,
        TabInputNotebook: LO,
        TabInputNotebookDiff: RO,
        TabInputWebview: dY,
        TabInputTerminal: mY,
        TabInputInteractiveWindow: hY,
        TabInputChat: fY,
        TabInputTextMultiDiff: pY,
        TelemetryTrustedValue: u2,
        LogLevel: Mt,
        EditSessionIdentityMatch: SU,
        InteractiveSessionVoteDirection: DO,
        ChatCopyKind: FO,
        ChatEditingSessionActionOutcome: xa,
        InteractiveEditorResponseFeedbackKind: AO,
        cursor: ur,
        UploadType: kU,
        DebugStackFrame: tY,
        DebugThread: eY,
        RelatedInformationType: MO,
        SpeechToTextStatus: HO,
        TextToSpeechStatus: WO,
        PartialAcceptTriggerKind: Ta,
        KeywordRecognitionStatus: jO,
        ChatResponseMarkdownPart: V6,
        ChatResponseFileTreePart: z6,
        ChatResponseAnchorPart: ql,
        ChatResponseProgressPart: Ul,
        ChatResponseProgressPart2: Y6,
        ChatResponseReferencePart: xn,
        ChatResponseReferencePart2: xn,
        ChatResponseCodeCitationPart: K6,
        ChatResponseCodeblockUriPart: X6,
        ChatResponseWarningPart: Ml,
        ChatResponseTextEditPart: Hl,
        ChatResponseMarkdownWithVulnerabilitiesPart: Bl,
        ChatResponseCommandButtonPart: Q6,
        ChatResponseDetectedParticipantPart: Ol,
        ChatResponseConfirmationPart: G6,
        ChatResponseMovePart: Z6,
        ChatResponseReferencePartStatusKind: BO,
        ChatRequestTurn: gY,
        ChatResponseTurn: vY,
        ChatLocation: ir,
        ChatRequestEditorData: wY,
        ChatRequestNotebookData: yY,
        ChatReferenceBinaryData: TY,
        LanguageModelChatMessageRole: dr,
        LanguageModelChatMessage: kY,
        LanguageModelToolResultPart: OO,
        LanguageModelTextPart: Li,
        LanguageModelToolCallPart: Wl,
        LanguageModelError: Jn,
        LanguageModelToolResult: qO,
        LanguageModelChatToolMode: UO,
        LanguageModelPromptTsxPart: tc,
        NewSymbolName: Lmt,
        NewSymbolNameTag: gO,
        NewSymbolNameTriggerKind: $l,
        InlineEdit: Hmt,
        InlineEditTriggerKind: jl,
        ExcludeSettingOptions: Rn,
        TextSearchContext2: Iq,
        TextSearchMatch2: Is,
        TextSearchCompleteMessageTypeNew: DA,
      }
    }
  )
}
var D8,
  ZM = class {
    constructor(t, e, r, s, a, o, c) {
      ;(this.c = t),
        (this.d = e),
        (this.e = r),
        (this.f = s),
        (this.g = a),
        (this.h = o),
        (this.i = c),
        (this.a = new Map()),
        (this.b = [])
    }
    async install() {
      this.j(), Pi("code/extHost/willWaitForConfig")
      const t = await this.f.getConfigProvider()
      Pi("code/extHost/didWaitForConfig")
      const e = await this.g.getExtensionPathIndex()
      this.register(new Y7t(this.c, e, this.d, t, this.i)),
        this.register(this.e.createInstance(tH)),
        this.h.remote.isRemote &&
          this.register(
            this.e.createInstance(eH, e, this.h.environment.appUriScheme),
          )
    }
    register(t) {
      if ("nodeModuleName" in t)
        if (Array.isArray(t.nodeModuleName))
          for (const e of t.nodeModuleName) this.a.set(e, t)
        else this.a.set(t.nodeModuleName, t)
      typeof t.alternativeModuleName == "function" &&
        this.b.push((e) => t.alternativeModuleName(e))
    }
  }
ZM = __decorate(
  [
    __param(2, l_),
    __param(3, An),
    __param(4, Fs),
    __param(5, ci),
    __param(6, Kt),
  ],
  ZM,
)
var tH = class {
  static {
    D8 = this
  }
  static {
    this.a = new Map([
      ["vscode-ripgrep", "@vscode/ripgrep"],
      ["vscode-windows-registry", "@vscode/windows-registry"],
    ])
  }
  constructor(t) {
    if (t.environment.appRoot && D8.a.size) {
      const e = Ks(this.c(t.environment.appRoot.fsPath)),
        r = "[a-z0-9_.-]",
        s = `@${r}+\\/${r}+|${r}+`,
        a = "node_modules|node_modules\\.asar(?:\\.unpacked)?"
      this.b = new RegExp(`^(${e}/${a}\\/)(${s})(.*)$`, "i")
    }
  }
  alternativeModuleName(t) {
    if (!this.b) return
    const e = this.b.exec(this.c(t))
    if (!e) return
    const [, r, s, a] = e,
      o = D8.a.get(s)
    if (o !== void 0)
      return (
        console.warn(
          `${s} as been renamed to ${o}, please update your imports`,
        ),
        r + o + a
      )
  }
  c(t) {
    return t.replace(/\\/g, "/")
  }
}
tH = D8 = __decorate([__param(0, ci)], tH)
var Y7t = class {
    constructor(i, t, e, r, s) {
      ;(this.c = i),
        (this.d = t),
        (this.e = e),
        (this.f = r),
        (this.g = s),
        (this.nodeModuleName = "vscode"),
        (this.a = new bn())
    }
    load(i, t) {
      const e = this.d.findSubstr(t)
      if (e) {
        let r = this.a.get(e.identifier)
        return (
          r || ((r = this.c(e, this.e, this.f)), this.a.set(e.identifier, r)), r
        )
      }
      if (!this.b) {
        let r = ""
        this.d.forEach(
          (s, a) =>
            (r += `	${a} -> ${s.identifier.value}
`),
        ),
          this.g
            .warn(`Could not identify extension for 'vscode' require call from ${t}. These are the extension path mappings: 
${r}`),
          (this.b = this.c(Evt, this.e, this.f))
      }
      return this.b
    }
  },
  eH = class {
    constructor(t, e, r) {
      ;(this.e = t),
        (this.f = e),
        (this.nodeModuleName = ["open", "opn"]),
        (this.d = r.getProxy(z.MainThreadTelemetry))
      const s = r.getProxy(z.MainThreadWindow)
      this.c = (a, o) => {
        const c = S.parse(a)
        return o
          ? this.g(a, o)
          : c.scheme === "http" || c.scheme === "https"
            ? s.$openUri(c, a, { allowTunneling: !0 })
            : c.scheme === "mailto" || c.scheme === this.f
              ? s.$openUri(c, a, {})
              : this.g(a, o)
      }
    }
    load(t, e, r) {
      const s = this.e.findSubstr(e)
      return (
        s && ((this.a = s.identifier.value), this.h()), (this.b = r(t)), this.c
      )
    }
    g(t, e) {
      return this.i(), this.b(t, e)
    }
    h() {
      this.a && this.d.$publicLog2("shimming.open", { extension: this.a })
    }
    i() {
      this.a &&
        this.d.$publicLog2("shimming.open.call.noForward", {
          extension: this.a,
        })
    }
  }
eH = __decorate([__param(2, Vt)], eH)
var iH = class {
  constructor(t, e) {
    ;(this.a = t.getProxy(z.MainThreadConsole)),
      (this.b = e.consoleForward.includeStack),
      (this.c = e.consoleForward.logNative),
      this.d("info", "log"),
      this.d("log", "log"),
      this.d("warn", "warn"),
      this.d("debug", "debug"),
      this.d("error", "error")
  }
  d(t, e) {
    const r = this,
      s = console[t]
    Object.defineProperty(console, t, {
      set: () => {},
      get: () =>
        function () {
          r.e(t, e, s, arguments)
        },
    })
  }
  e(t, e, r, s) {
    this.a.$logExtensionHostMessage({
      type: "__$console",
      severity: e,
      arguments: X7t(s, this.b),
    }),
      this.c && this.f(t, r, s)
  }
}
iH = __decorate([__param(0, Vt), __param(1, ci)], iH)
var Q7t = 1e5
function X7t(i, t) {
  const e = []
  if (i.length)
    for (let r = 0; r < i.length; r++) {
      let s = i[r]
      if (typeof s > "u") s = "undefined"
      else if (s instanceof Error) {
        const a = s
        a.stack ? (s = a.stack) : (s = a.toString())
      }
      e.push(s)
    }
  if (t) {
    const r = new Error().stack
    r &&
      e.push({
        __$stack: r
          .split(
            `
`,
          )
          .slice(3).join(`
`),
      })
  }
  try {
    const r = lut(e)
    return r.length > Q7t
      ? "Output omitted for a large object that exceeds the limits"
      : r
  } catch (r) {
    return `Output omitted for an object that cannot be inspected ('${r.toString()}')`
  }
}
var rH = class extends iH {
  constructor(t, e) {
    super(t, e)
  }
  f(t, e, r) {
    e.apply(console, r)
  }
}
rH = __decorate([__param(0, Vt), __param(1, ci)], rH)
var K7t = class extends ZM {
    j() {}
    getModule(i, t) {
      for (const e of this.b) {
        const r = e(i)
        if (r) {
          i = r
          break
        }
      }
      if (this.a.has(i))
        return this.a.get(i).load(i, t, () => {
          throw new Error("CANNOT LOAD MODULE from here.")
        })
    }
  },
  Z7t = class extends H2 {
    constructor() {
      super(...arguments), (this.extensionRuntime = O6.Webworker)
    }
    async wb() {
      this.h.createInstance(rH)
      const i = this.h.invokeFunction(z7t)
      ;(this.r = this.h.createInstance(K7t, i, { mine: this.J, all: this.L })),
        await this.r.install(),
        performance.mark("code/extHost/didInitAPI"),
        await this.Cb()
    }
    xb(i) {
      return i.browser
    }
    async yb(i, t, e) {
      t = t.with({ path: t8t(t.path, ".js") })
      const r = i?.identifier.value
      r && performance.mark(`code/extHost/willFetchExtensionCode/${r}`)
      const s = S.revive(await this.z.$asBrowserUri(t)),
        a = await fetch(s.toString(!0))
      if (
        (r && performance.mark(`code/extHost/didFetchExtensionCode/${r}`),
        a.status !== 200)
      )
        throw new Error(a.statusText)
      const o = await a.text(),
        c = `${t.toString(!0)}#vscode-extension`,
        u = `${o}
//# sourceURL=${c}`
      let l
      try {
        l = new Function("module", "exports", "require", u)
      } catch (g) {
        throw (
          (console.error(
            r
              ? `Loading code for extension ${r} failed: ${g.message}`
              : `Loading code failed: ${g.message}`,
          ),
          console.error(
            `${t.toString(!0)}${typeof g.line == "number" ? ` line ${g.line}` : ""}${typeof g.column == "number" ? ` column ${g.column}` : ""}`,
          ),
          console.error(g),
          g)
        )
      }
      i && (await this.u.initializeLocalizedMessages(i))
      const m = {},
        h = { exports: m },
        p = (g) => {
          const w = this.r.getModule(g, t)
          if (w === void 0) throw new Error(`Cannot load module '${g}'`)
          return w
        }
      try {
        return (
          e.codeLoadingStart(),
          r && performance.mark(`code/extHost/willLoadExtensionCode/${r}`),
          l(h, m, p),
          h.exports !== m ? h.exports : m
        )
      } finally {
        r && performance.mark(`code/extHost/didLoadExtensionCode/${r}`),
          e.codeLoadingStop()
      }
    }
    async $setRemoteEnvironment(i) {}
    async Cb(i = 5e3) {
      if (!this.f.environment.isExtensionDevelopmentDebug) return
      const t = Date.now() + i
      for (; Date.now() < t && !("__jsDebugIsReady" in globalThis); )
        await Kr(10)
    }
  }
function t8t(i, t) {
  return i.endsWith(t) ? i : i + t
}
Zt(Kt, new Tn(yU, [!0], !0)), Zt(Fs, Z7t, 0), Zt(f2, p2, 0)
var lnt = self.close.bind(self)
self.close = () => console.trace("'close' has been blocked")
var dnt = postMessage.bind(self)
self.postMessage = () => console.trace("'postMessage' has been blocked")
function mnt(i) {
  return /^(file|vscode-remote):/i.test(i)
}
var hnt = fetch.bind(self)
function e8t(i) {
  ;(self.fetch = async function (t, e) {
    return (
      t instanceof Request ||
        (mnt(String(t)) && (t = (await i(S.parse(String(t)))).toString(!0))),
      hnt(t, e)
    )
  }),
    (self.XMLHttpRequest = class extends XMLHttpRequest {
      open(t, e, r, s, a) {
        ;(async () => (
          mnt(e.toString()) &&
            (e = (await i(S.parse(e.toString()))).toString(!0)),
          super.open(t, e, r ?? !0, s, a)
        ))()
      }
    })
}
if (
  ((self.importScripts = () => {
    throw new Error("'importScripts' has been blocked")
  }),
  (self.addEventListener = () =>
    console.trace("'addEventListener' has been blocked")),
  (self.AMDLoader = void 0),
  (self.NLSLoaderPlugin = void 0),
  (self.define = void 0),
  (self.require = void 0),
  (self.webkitRequestFileSystem = void 0),
  (self.webkitRequestFileSystemSync = void 0),
  (self.webkitResolveLocalFileSystemSyncURL = void 0),
  (self.webkitResolveLocalFileSystemURL = void 0),
  self.Worker)
) {
  const i = self.Worker
  Worker = function (t, e) {
    if (/^file:/i.test(t.toString()))
      t = ict.uriToBrowserUri(S.parse(t.toString())).toString(!0)
    else if (/^vscode-remote:/i.test(t.toString()))
      throw new Error(
        "Creating workers from remote extensions is currently not supported.",
      )
    const s = `(${function (u) {
      function l(p) {
        return typeof p == "string" || p instanceof URL
          ? String(p).replace(/^file:\/\//i, "vscode-file://vscode-app")
          : p
      }
      const m = fetch.bind(self)
      ;(self.fetch = function (p, g) {
        return p instanceof Request ? m(p, g) : m(l(p), g)
      }),
        (self.XMLHttpRequest = class extends XMLHttpRequest {
          open(p, g, w, T, b) {
            return super.open(p, l(g), w ?? !0, T, b)
          }
        })
      const h = importScripts.bind(self)
      ;(self.importScripts = (...p) => {
        h(...p.map(l))
      }),
        h(u)
    }.toString()}('${t}'))`
    ;(e = e || {}), (e.name = `${name} -> ${e.name || ji(t.toString())}`)
    const a = new Blob([s], { type: "application/javascript" }),
      o = URL.createObjectURL(a)
    return new i(o, e)
  }
} else
  self.Worker = class extends E1t {
    constructor(i, t) {
      super(dnt, i, { name: ji(i.toString()), ...t })
    }
  }
var i8t = new (class {
    constructor() {
      this.pid = void 0
    }
    exit(i) {
      lnt()
    }
  })(),
  r8t = class {
    constructor() {
      const i = new MessageChannel(),
        t = new C()
      let e = !1
      dnt(i.port2, [i.port2]),
        (i.port1.onmessage = (r) => {
          const { data: s } = r
          if (!(s instanceof ArrayBuffer)) {
            console.warn("UNKNOWN data received", s)
            return
          }
          const a = Et.wrap(new Uint8Array(s, 0, s.byteLength))
          if (_at(a, 2)) {
            ;(e = !0), fnt("received terminate message from renderer")
            return
          }
          t.fire(a)
        }),
        (this.protocol = {
          onMessage: t.event,
          send: (r) => {
            if (!e) {
              const s = r.buffer.buffer.slice(
                r.buffer.byteOffset,
                r.buffer.byteOffset + r.buffer.byteLength,
              )
              i.port1.postMessage(s, [s])
            }
          },
        })
    }
  }
function n8t(i) {
  return new Promise((t) => {
    const e = i.onMessage((r) => {
      e.dispose()
      const s = JSON.parse(r.toString())
      i.send(VH(0)), t({ protocol: i, initData: s })
    })
    i.send(VH(1))
  })
}
var fnt = (i) => lnt()
function s8t(i) {
  return (
    !!i &&
    typeof i == "object" &&
    i.type === "vscode.init" &&
    i.data instanceof Map
  )
}
function a8t() {
  Pi("code/extHost/willConnectToRenderer")
  const i = new r8t()
  return {
    onmessage(t) {
      s8t(t) &&
        n8t(i.protocol).then((e) => {
          Pi("code/extHost/didWaitForInitData")
          const r = new S1t(e.protocol, e.initData, i8t, null, t.data)
          e8t((s) => r.asBrowserUri(s)), (fnt = (s) => r.terminate(s))
        })
    },
  }
}
var o8t = a8t()
self.onmessage = (i) => o8t.onmessage(i.data)

//# sourceMappingURL=https://cursor-sourcemaps.s3.amazonaws.com/sourcemaps/f5f18731406b73244e0558ee7716d77c8096d150/core/vs/workbench/api/worker/extensionHostWorkerMain.js.map

//# debugId=818245f6-c3b4-5059-af60-f9a3ab1f3b3a
