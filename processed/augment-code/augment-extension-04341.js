"use strict"
var xFe = Object.create
var KS = Object.defineProperty
var wFe = Object.getOwnPropertyDescriptor
var SFe = Object.getOwnPropertyNames
var IFe = Object.getPrototypeOf,
  BFe = Object.prototype.hasOwnProperty
var RFe = (e, t) => () => (e && (t = e((e = 0))), t)
var _ = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
  lL = (e, t) => {
    for (var r in t) KS(e, r, { get: t[r], enumerable: true })
  },
  SY = (e, t, r, n) => {
    if ((t && typeof t == "object") || typeof t == "function")
      for (let i of SFe(t))
        !BFe.call(e, i) &&
          i !== r &&
          KS(e, i, {
            get: () => t[i],
            enumerable: !(n = wFe(t, i)) || n.enumerable,
          })
    return e
  }
var q = (e, t, r) => (
    (r = e != null ? xFe(IFe(e)) : {}),
    SY(
      t || !e || !e.__esModule
        ? KS(r, "default", { value: e, enumerable: true })
        : r,
      e,
    )
  ),
  cL = (e) => SY(KS({}, "__esModule", { value: true }), e)
var Bd = _((WEt, VY) => {
  "use strict"
  function OFe(e) {
    var t = typeof e
    return e != null && (t == "object" || t == "function")
  }
  VY.exports = OFe
})
var gL = _((GEt, HY) => {
  "use strict"
  var qFe =
    typeof global == "object" && global && global.Object === Object && global
  HY.exports = qFe
})
var Al = _(($Et, WY) => {
  "use strict"
  var VFe = gL(),
    HFe = typeof self == "object" && self && self.Object === Object && self,
    WFe = VFe || HFe || Function("return this")()
  WY.exports = WFe
})
var $Y = _((YEt, GY) => {
  "use strict"
  var GFe = Al(),
    $Fe = function () {
      return GFe.Date.now()
    }
  GY.exports = $Fe
})
var KY = _((KEt, YY) => {
  "use strict"
  var YFe = /\s/
  function KFe(e) {
    for (var t = e.length; t-- && YFe.test(e.charAt(t)); );
    return t
  }
  YY.exports = KFe
})
var JY = _((zEt, zY) => {
  "use strict"
  var zFe = KY(),
    JFe = /^\s+/
  function jFe(e) {
    return e && e.slice(0, zFe(e) + 1).replace(JFe, "")
  }
  zY.exports = jFe
})
var sb = _((JEt, jY) => {
  "use strict"
  var ZFe = Al(),
    XFe = ZFe.Symbol
  jY.exports = XFe
})
var tK = _((jEt, eK) => {
  "use strict"
  var ZY = sb(),
    XY = Object.prototype,
    e1e = XY.hasOwnProperty,
    t1e = XY.toString,
    ob = ZY ? ZY.toStringTag : undefined
  function r1e(e) {
    var t = e1e.call(e, ob),
      r = e[ob]
    try {
      e[ob] = undefined
      var n = true
    } catch {}
    var i = t1e.call(e)
    return n && (t ? (e[ob] = r) : delete e[ob]), i
  }
  eK.exports = r1e
})
var nK = _((ZEt, rK) => {
  "use strict"
  var n1e = Object.prototype,
    i1e = n1e.toString
  function s1e(e) {
    return i1e.call(e)
  }
  rK.exports = s1e
})
var BA = _((XEt, oK) => {
  "use strict"
  var iK = sb(),
    o1e = tK(),
    a1e = nK(),
    l1e = "[object Null]",
    c1e = "[object Undefined]",
    sK = iK ? iK.toStringTag : undefined
  function u1e(e) {
    return e == null
      ? e === undefined
        ? c1e
        : l1e
      : sK && sK in Object(e)
        ? o1e(e)
        : a1e(e)
  }
  oK.exports = u1e
})
var $f = _((e_t, aK) => {
  "use strict"
  function d1e(e) {
    return e != null && typeof e == "object"
  }
  aK.exports = d1e
})
var cK = _((t_t, lK) => {
  "use strict"
  var f1e = BA(),
    h1e = $f(),
    g1e = "[object Symbol]"
  function p1e(e) {
    return typeof e == "symbol" || (h1e(e) && f1e(e) == g1e)
  }
  lK.exports = p1e
})
var hK = _((r_t, fK) => {
  "use strict"
  var m1e = JY(),
    uK = Bd(),
    A1e = cK(),
    dK = NaN,
    y1e = /^[-+]0x[0-9a-f]+$/i,
    v1e = /^0b[01]+$/i,
    C1e = /^0o[0-7]+$/i,
    b1e = parseInt
  function E1e(e) {
    if (typeof e == "number") return e
    if (A1e(e)) return dK
    if (uK(e)) {
      var t = typeof e.valueOf == "function" ? e.valueOf() : e
      e = uK(t) ? t + "" : t
    }
    if (typeof e != "string") return e === 0 ? e : +e
    e = m1e(e)
    var r = v1e.test(e)
    return r || C1e.test(e) ? b1e(e.slice(2), r ? 2 : 8) : y1e.test(e) ? dK : +e
  }
  fK.exports = E1e
})
var RA = _((n_t, pK) => {
  "use strict"
  var _1e = Bd(),
    pL = $Y(),
    gK = hK(),
    x1e = "Expected a function",
    w1e = Math.max,
    S1e = Math.min
  function I1e(e, t, r) {
    var n,
      i,
      s,
      o,
      a,
      l,
      c = 0,
      u = false,
      f = false,
      p = true
    if (typeof e != "function") throw new TypeError(x1e)
    ;(t = gK(t) || 0),
      _1e(r) &&
        ((u = !!r.leading),
        (f = "maxWait" in r),
        (s = f ? w1e(gK(r.maxWait) || 0, t) : s),
        (p = "trailing" in r ? !!r.trailing : p))
    function g(N) {
      var W = n,
        Z = i
      return (n = i = undefined), (c = N), (o = e.apply(Z, W)), o
    }
    function m(N) {
      return (c = N), (a = setTimeout(C, t)), u ? g(N) : o
    }
    function y(N) {
      var W = N - l,
        Z = N - c,
        te = t - W
      return f ? S1e(te, s - Z) : te
    }
    function v(N) {
      var W = N - l,
        Z = N - c
      return l === undefined || W >= t || W < 0 || (f && Z >= s)
    }
    function C() {
      var N = pL()
      if (v(N)) return E(N)
      a = setTimeout(C, y(N))
    }
    function E(N) {
      return (a = undefined), p && n ? g(N) : ((n = i = undefined), o)
    }
    function w() {
      a !== undefined && clearTimeout(a), (c = 0), (n = l = i = a = undefined)
    }
    function B() {
      return a === undefined ? o : E(pL())
    }
    function T() {
      var N = pL(),
        W = v(N)
      if (((n = arguments), (i = this), (l = N), W)) {
        if (a === undefined) return m(l)
        if (f) return clearTimeout(a), (a = setTimeout(C, t)), g(l)
      }
      return a === undefined && (a = setTimeout(C, t)), o
    }
    return (T.cancel = w), (T.flush = B), T
  }
  pK.exports = I1e
})
var Yf = _((i_t, mK) => {
  "use strict"
  var B1e = RA(),
    R1e = Bd(),
    D1e = "Expected a function"
  function T1e(e, t, r) {
    var n = true,
      i = true
    if (typeof e != "function") throw new TypeError(D1e)
    return (
      R1e(r) &&
        ((n = "leading" in r ? !!r.leading : n),
        (i = "trailing" in r ? !!r.trailing : i)),
      B1e(e, t, { leading: n, maxWait: t, trailing: i })
    )
  }
  mK.exports = T1e
})
var _s = _((VA, bb) => {
  "use strict"
  ;(function () {
    var e,
      t = "4.17.21",
      r = 200,
      n = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
      i = "Expected a function",
      s = "Invalid `variable` option passed into `_.template`",
      o = "__lodash_hash_undefined__",
      a = 500,
      l = "__lodash_placeholder__",
      c = 1,
      u = 2,
      f = 4,
      p = 1,
      g = 2,
      m = 1,
      y = 2,
      v = 4,
      C = 8,
      E = 16,
      w = 32,
      B = 64,
      T = 128,
      N = 256,
      W = 512,
      Z = 30,
      te = "...",
      Y = 800,
      U = 16,
      ce = 1,
      Ie = 2,
      Q = 3,
      se = 1 / 0,
      J = 9007199254740991,
      ie = 17976931348623157e292,
      Ue = NaN,
      At = 4294967295,
      ve = At - 1,
      Mt = At >>> 1,
      Xt = [
        ["ary", T],
        ["bind", m],
        ["bindKey", y],
        ["curry", C],
        ["curryRight", E],
        ["flip", W],
        ["partial", w],
        ["partialRight", B],
        ["rearg", N],
      ],
      rr = "[object Arguments]",
      ue = "[object Array]",
      wr = "[object AsyncFunction]",
      or = "[object Boolean]",
      Wr = "[object Date]",
      Ge = "[object DOMException]",
      ln = "[object Error]",
      Gr = "[object Function]",
      pr = "[object GeneratorFunction]",
      Ee = "[object Map]",
      Or = "[object Number]",
      he = "[object Null]",
      be = "[object Object]",
      _t = "[object Promise]",
      hn = "[object Proxy]",
      Rn = "[object RegExp]",
      Ii = "[object Set]",
      so = "[object String]",
      cd = "[object Symbol]",
      nu = "[object Undefined]",
      ar = "[object WeakMap]",
      G2 = "[object WeakSet]",
      ji = "[object ArrayBuffer]",
      pa = "[object DataView]",
      ud = "[object Float32Array]",
      dd = "[object Float64Array]",
      vC = "[object Int8Array]",
      ma = "[object Int16Array]",
      CC = "[object Int32Array]",
      bC = "[object Uint8Array]",
      _r = "[object Uint8ClampedArray]",
      It = "[object Uint16Array]",
      Dn = "[object Uint32Array]",
      ol = /\b__p \+= '';/g,
      al = /\b(__p \+=) '' \+/g,
      Ig = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
      ic = /&(?:amp|lt|gt|quot|#39);/g,
      bt = /[&<>"']/g,
      eA = RegExp(ic.source),
      EC = RegExp(bt.source),
      Nw = /<%-([\s\S]+?)%>/g,
      tA = /<%([\s\S]+?)%>/g,
      Tf = /<%=([\s\S]+?)%>/g,
      rA = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      $2 = /^\w*$/,
      _C =
        /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
      Li = /[\\^$.*+?()[\]{}|]/g,
      nA = RegExp(Li.source),
      xC = /^\s+/,
      Y2 = /\s/,
      fd = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      je = /\{\n\/\* \[wrapped with (.+)\] \*/,
      er = /,? & /,
      iu = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
      Bg = /[()=,{}\[\]\/\s]/,
      su = /\\(\\)?/g,
      wC = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
      Pw = /\w*$/,
      K2 = /^[-+]0x[0-9a-f]+$/i,
      Lw = /^0b[01]+$/i,
      z2 = /^\[object .+?Constructor\]$/,
      J2 = /^0o[0-7]+$/i,
      j2 = /^(?:0|[1-9]\d*)$/,
      Z2 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
      iA = /($^)/,
      X2 = /['\n\r\u2028\u2029\\]/g,
      sA = "\\ud800-\\udfff",
      eP = "\\u0300-\\u036f",
      tP = "\\ufe20-\\ufe2f",
      rP = "\\u20d0-\\u20ff",
      Uw = eP + tP + rP,
      Aa = "\\u2700-\\u27bf",
      Ow = "a-z\\xdf-\\xf6\\xf8-\\xff",
      qw = "\\xac\\xb1\\xd7\\xf7",
      SC = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
      nP = "\\u2000-\\u206f",
      iP =
        " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
      Vw = "A-Z\\xc0-\\xd6\\xd8-\\xde",
      sc = "\\ufe0e\\ufe0f",
      Hw = qw + SC + nP + iP,
      IC = "['\u2019]",
      BC = "[" + sA + "]",
      Ww = "[" + Hw + "]",
      oo = "[" + Uw + "]",
      oA = "\\d+",
      sP = "[" + Aa + "]",
      RC = "[" + Ow + "]",
      Rg = "[^" + sA + Hw + oA + Aa + Ow + Vw + "]",
      kf = "\\ud83c[\\udffb-\\udfff]",
      aA = "(?:" + oo + "|" + kf + ")",
      lA = "[^" + sA + "]",
      ll = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      Mf = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      hd = "[" + Vw + "]",
      Gw = "\\u200d",
      $w = "(?:" + RC + "|" + Rg + ")",
      gd = "(?:" + hd + "|" + Rg + ")",
      Yw = "(?:" + IC + "(?:d|ll|m|re|s|t|ve))?",
      Kw = "(?:" + IC + "(?:D|LL|M|RE|S|T|VE))?",
      zw = aA + "?",
      Jw = "[" + sc + "]?",
      DC = "(?:" + Gw + "(?:" + [lA, ll, Mf].join("|") + ")" + Jw + zw + ")*",
      cA = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
      oP = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
      jw = Jw + zw + DC,
      Zw = "(?:" + [sP, ll, Mf].join("|") + ")" + jw,
      TC = "(?:" + [lA + oo + "?", oo, ll, Mf, BC].join("|") + ")",
      Xw = RegExp(IC, "g"),
      aP = RegExp(oo, "g"),
      kC = RegExp(kf + "(?=" + kf + ")|" + TC + jw, "g"),
      eS = RegExp(
        [
          hd + "?" + RC + "+" + Yw + "(?=" + [Ww, hd, "$"].join("|") + ")",
          gd + "+" + Kw + "(?=" + [Ww, hd + $w, "$"].join("|") + ")",
          hd + "?" + $w + "+" + Yw,
          hd + "+" + Kw,
          oP,
          cA,
          oA,
          Zw,
        ].join("|"),
        "g",
      ),
      tS = RegExp("[" + Gw + sA + Uw + sc + "]"),
      rS = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
      lP = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout",
      ],
      cP = -1,
      An = {}
    ;(An[ud] =
      An[dd] =
      An[vC] =
      An[ma] =
      An[CC] =
      An[bC] =
      An[_r] =
      An[It] =
      An[Dn] =
        true),
      (An[rr] =
        An[ue] =
        An[ji] =
        An[or] =
        An[pa] =
        An[Wr] =
        An[ln] =
        An[Gr] =
        An[Ee] =
        An[Or] =
        An[be] =
        An[Rn] =
        An[Ii] =
        An[so] =
        An[ar] =
          false)
    var $r = {}
    ;($r[rr] =
      $r[ue] =
      $r[ji] =
      $r[pa] =
      $r[or] =
      $r[Wr] =
      $r[ud] =
      $r[dd] =
      $r[vC] =
      $r[ma] =
      $r[CC] =
      $r[Ee] =
      $r[Or] =
      $r[be] =
      $r[Rn] =
      $r[Ii] =
      $r[so] =
      $r[cd] =
      $r[bC] =
      $r[_r] =
      $r[It] =
      $r[Dn] =
        true),
      ($r[ln] = $r[Gr] = $r[ar] = false)
    var uA = {
        À: "A",
        Á: "A",
        Â: "A",
        Ã: "A",
        Ä: "A",
        Å: "A",
        à: "a",
        á: "a",
        â: "a",
        ã: "a",
        ä: "a",
        å: "a",
        Ç: "C",
        ç: "c",
        Ð: "D",
        ð: "d",
        È: "E",
        É: "E",
        Ê: "E",
        Ë: "E",
        è: "e",
        é: "e",
        ê: "e",
        ë: "e",
        Ì: "I",
        Í: "I",
        Î: "I",
        Ï: "I",
        ì: "i",
        í: "i",
        î: "i",
        ï: "i",
        Ñ: "N",
        ñ: "n",
        Ò: "O",
        Ó: "O",
        Ô: "O",
        Õ: "O",
        Ö: "O",
        Ø: "O",
        ò: "o",
        ó: "o",
        ô: "o",
        õ: "o",
        ö: "o",
        ø: "o",
        Ù: "U",
        Ú: "U",
        Û: "U",
        Ü: "U",
        ù: "u",
        ú: "u",
        û: "u",
        ü: "u",
        Ý: "Y",
        ý: "y",
        ÿ: "y",
        Æ: "Ae",
        æ: "ae",
        Þ: "Th",
        þ: "th",
        ß: "ss",
        Ā: "A",
        Ă: "A",
        Ą: "A",
        ā: "a",
        ă: "a",
        ą: "a",
        Ć: "C",
        Ĉ: "C",
        Ċ: "C",
        Č: "C",
        ć: "c",
        ĉ: "c",
        ċ: "c",
        č: "c",
        Ď: "D",
        Đ: "D",
        ď: "d",
        đ: "d",
        Ē: "E",
        Ĕ: "E",
        Ė: "E",
        Ę: "E",
        Ě: "E",
        ē: "e",
        ĕ: "e",
        ė: "e",
        ę: "e",
        ě: "e",
        Ĝ: "G",
        Ğ: "G",
        Ġ: "G",
        Ģ: "G",
        ĝ: "g",
        ğ: "g",
        ġ: "g",
        ģ: "g",
        Ĥ: "H",
        Ħ: "H",
        ĥ: "h",
        ħ: "h",
        Ĩ: "I",
        Ī: "I",
        Ĭ: "I",
        Į: "I",
        İ: "I",
        ĩ: "i",
        ī: "i",
        ĭ: "i",
        į: "i",
        ı: "i",
        Ĵ: "J",
        ĵ: "j",
        Ķ: "K",
        ķ: "k",
        ĸ: "k",
        Ĺ: "L",
        Ļ: "L",
        Ľ: "L",
        Ŀ: "L",
        Ł: "L",
        ĺ: "l",
        ļ: "l",
        ľ: "l",
        ŀ: "l",
        ł: "l",
        Ń: "N",
        Ņ: "N",
        Ň: "N",
        Ŋ: "N",
        ń: "n",
        ņ: "n",
        ň: "n",
        ŋ: "n",
        Ō: "O",
        Ŏ: "O",
        Ő: "O",
        ō: "o",
        ŏ: "o",
        ő: "o",
        Ŕ: "R",
        Ŗ: "R",
        Ř: "R",
        ŕ: "r",
        ŗ: "r",
        ř: "r",
        Ś: "S",
        Ŝ: "S",
        Ş: "S",
        Š: "S",
        ś: "s",
        ŝ: "s",
        ş: "s",
        š: "s",
        Ţ: "T",
        Ť: "T",
        Ŧ: "T",
        ţ: "t",
        ť: "t",
        ŧ: "t",
        Ũ: "U",
        Ū: "U",
        Ŭ: "U",
        Ů: "U",
        Ű: "U",
        Ų: "U",
        ũ: "u",
        ū: "u",
        ŭ: "u",
        ů: "u",
        ű: "u",
        ų: "u",
        Ŵ: "W",
        ŵ: "w",
        Ŷ: "Y",
        ŷ: "y",
        Ÿ: "Y",
        Ź: "Z",
        Ż: "Z",
        Ž: "Z",
        ź: "z",
        ż: "z",
        ž: "z",
        Ĳ: "IJ",
        ĳ: "ij",
        Œ: "Oe",
        œ: "oe",
        ŉ: "'n",
        ſ: "s",
      },
      nS = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
      },
      ou = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'",
      },
      MC = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029",
      },
      uP = parseFloat,
      dP = parseInt,
      Ff =
        typeof global == "object" &&
        global &&
        global.Object === Object &&
        global,
      iS = typeof self == "object" && self && self.Object === Object && self,
      Bi = Ff || iS || Function("return this")(),
      FC = typeof VA == "object" && VA && !VA.nodeType && VA,
      pd = FC && typeof bb == "object" && bb && !bb.nodeType && bb,
      sS = pd && pd.exports === FC,
      QC = sS && Ff.process,
      ys = (function () {
        try {
          var K = pd && pd.require && pd.require("util").types
          return K || (QC && QC.binding && QC.binding("util"))
        } catch {}
      })(),
      au = ys && ys.isArrayBuffer,
      oS = ys && ys.isDate,
      NC = ys && ys.isMap,
      Dg = ys && ys.isRegExp,
      Tn = ys && ys.isSet,
      PC = ys && ys.isTypedArray
    function vs(K, le, ne) {
      switch (ne.length) {
        case 0:
          return K.call(le)
        case 1:
          return K.call(le, ne[0])
        case 2:
          return K.call(le, ne[0], ne[1])
        case 3:
          return K.call(le, ne[0], ne[1], ne[2])
      }
      return K.apply(le, ne)
    }
    function it(K, le, ne, Ve) {
      for (var Dt = -1, Yr = K == null ? 0 : K.length; ++Dt < Yr; ) {
        var Oi = K[Dt]
        le(Ve, Oi, ne(Oi), K)
      }
      return Ve
    }
    function Cs(K, le) {
      for (
        var ne = -1, Ve = K == null ? 0 : K.length;
        ++ne < Ve && le(K[ne], ne, K) !== false;

      );
      return K
    }
    function Po(K, le) {
      for (
        var ne = K == null ? 0 : K.length;
        ne-- && le(K[ne], ne, K) !== false;

      );
      return K
    }
    function aS(K, le) {
      for (var ne = -1, Ve = K == null ? 0 : K.length; ++ne < Ve; )
        if (!le(K[ne], ne, K)) return false
      return true
    }
    function cl(K, le) {
      for (
        var ne = -1, Ve = K == null ? 0 : K.length, Dt = 0, Yr = [];
        ++ne < Ve;

      ) {
        var Oi = K[ne]
        le(Oi, ne, K) && (Yr[Dt++] = Oi)
      }
      return Yr
    }
    function md(K, le) {
      var ne = K == null ? 0 : K.length
      return !!ne && Ad(K, le, 0) > -1
    }
    function oc(K, le, ne) {
      for (var Ve = -1, Dt = K == null ? 0 : K.length; ++Ve < Dt; )
        if (ne(le, K[Ve])) return true
      return false
    }
    function Zr(K, le) {
      for (
        var ne = -1, Ve = K == null ? 0 : K.length, Dt = Array(Ve);
        ++ne < Ve;

      )
        Dt[ne] = le(K[ne], ne, K)
      return Dt
    }
    function ao(K, le) {
      for (var ne = -1, Ve = le.length, Dt = K.length; ++ne < Ve; )
        K[Dt + ne] = le[ne]
      return K
    }
    function ya(K, le, ne, Ve) {
      var Dt = -1,
        Yr = K == null ? 0 : K.length
      for (Ve && Yr && (ne = K[++Dt]); ++Dt < Yr; ) ne = le(ne, K[Dt], Dt, K)
      return ne
    }
    function dA(K, le, ne, Ve) {
      var Dt = K == null ? 0 : K.length
      for (Ve && Dt && (ne = K[--Dt]); Dt--; ) ne = le(ne, K[Dt], Dt, K)
      return ne
    }
    function Tg(K, le) {
      for (var ne = -1, Ve = K == null ? 0 : K.length; ++ne < Ve; )
        if (le(K[ne], ne, K)) return true
      return false
    }
    var lS = re("length")
    function LC(K) {
      return K.split("")
    }
    function fP(K) {
      return K.match(iu) || []
    }
    function cS(K, le, ne) {
      var Ve
      return (
        ne(K, function (Dt, Yr, Oi) {
          if (le(Dt, Yr, Oi)) return (Ve = Yr), false
        }),
        Ve
      )
    }
    function fA(K, le, ne, Ve) {
      for (var Dt = K.length, Yr = ne + (Ve ? 1 : -1); Ve ? Yr-- : ++Yr < Dt; )
        if (le(K[Yr], Yr, K)) return Yr
      return -1
    }
    function Ad(K, le, ne) {
      return le === le ? uBe(K, le, ne) : fA(K, S, ne)
    }
    function x(K, le, ne, Ve) {
      for (var Dt = ne - 1, Yr = K.length; ++Dt < Yr; )
        if (Ve(K[Dt], le)) return Dt
      return -1
    }
    function S(K) {
      return K !== K
    }
    function L(K, le) {
      var ne = K == null ? 0 : K.length
      return ne ? $t(K, le) / ne : Ue
    }
    function re(K) {
      return function (le) {
        return le == null ? e : le[K]
      }
    }
    function oe(K) {
      return function (le) {
        return K == null ? e : K[le]
      }
    }
    function Re(K, le, ne, Ve, Dt) {
      return (
        Dt(K, function (Yr, Oi, vn) {
          ne = Ve ? ((Ve = false), Yr) : le(ne, Yr, Oi, vn)
        }),
        ne
      )
    }
    function st(K, le) {
      var ne = K.length
      for (K.sort(le); ne--; ) K[ne] = K[ne].value
      return K
    }
    function $t(K, le) {
      for (var ne, Ve = -1, Dt = K.length; ++Ve < Dt; ) {
        var Yr = le(K[Ve])
        Yr !== e && (ne = ne === e ? Yr : ne + Yr)
      }
      return ne
    }
    function yn(K, le) {
      for (var ne = -1, Ve = Array(K); ++ne < K; ) Ve[ne] = le(ne)
      return Ve
    }
    function Ui(K, le) {
      return Zr(le, function (ne) {
        return [ne, K[ne]]
      })
    }
    function lo(K) {
      return K && K.slice(0, N9(K) + 1).replace(xC, "")
    }
    function kn(K) {
      return function (le) {
        return K(le)
      }
    }
    function ac(K, le) {
      return Zr(le, function (ne) {
        return K[ne]
      })
    }
    function Lo(K, le) {
      return K.has(le)
    }
    function Qf(K, le) {
      for (var ne = -1, Ve = K.length; ++ne < Ve && Ad(le, K[ne], 0) > -1; );
      return ne
    }
    function uS(K, le) {
      for (var ne = K.length; ne-- && Ad(le, K[ne], 0) > -1; );
      return ne
    }
    function rBe(K, le) {
      for (var ne = K.length, Ve = 0; ne--; ) K[ne] === le && ++Ve
      return Ve
    }
    var nBe = oe(uA),
      iBe = oe(nS)
    function sBe(K) {
      return "\\" + MC[K]
    }
    function oBe(K, le) {
      return K == null ? e : K[le]
    }
    function hA(K) {
      return tS.test(K)
    }
    function aBe(K) {
      return rS.test(K)
    }
    function lBe(K) {
      for (var le, ne = []; !(le = K.next()).done; ) ne.push(le.value)
      return ne
    }
    function hP(K) {
      var le = -1,
        ne = Array(K.size)
      return (
        K.forEach(function (Ve, Dt) {
          ne[++le] = [Dt, Ve]
        }),
        ne
      )
    }
    function Q9(K, le) {
      return function (ne) {
        return K(le(ne))
      }
    }
    function Nf(K, le) {
      for (var ne = -1, Ve = K.length, Dt = 0, Yr = []; ++ne < Ve; ) {
        var Oi = K[ne]
        ;(Oi === le || Oi === l) && ((K[ne] = l), (Yr[Dt++] = ne))
      }
      return Yr
    }
    function dS(K) {
      var le = -1,
        ne = Array(K.size)
      return (
        K.forEach(function (Ve) {
          ne[++le] = Ve
        }),
        ne
      )
    }
    function cBe(K) {
      var le = -1,
        ne = Array(K.size)
      return (
        K.forEach(function (Ve) {
          ne[++le] = [Ve, Ve]
        }),
        ne
      )
    }
    function uBe(K, le, ne) {
      for (var Ve = ne - 1, Dt = K.length; ++Ve < Dt; )
        if (K[Ve] === le) return Ve
      return -1
    }
    function dBe(K, le, ne) {
      for (var Ve = ne + 1; Ve--; ) if (K[Ve] === le) return Ve
      return Ve
    }
    function gA(K) {
      return hA(K) ? hBe(K) : lS(K)
    }
    function lc(K) {
      return hA(K) ? gBe(K) : LC(K)
    }
    function N9(K) {
      for (var le = K.length; le-- && Y2.test(K.charAt(le)); );
      return le
    }
    var fBe = oe(ou)
    function hBe(K) {
      for (var le = (kC.lastIndex = 0); kC.test(K); ) ++le
      return le
    }
    function gBe(K) {
      return K.match(kC) || []
    }
    function pBe(K) {
      return K.match(eS) || []
    }
    var mBe = function K(le) {
        le = le == null ? Bi : Pf.defaults(Bi.Object(), le, Pf.pick(Bi, lP))
        var ne = le.Array,
          Ve = le.Date,
          Dt = le.Error,
          Yr = le.Function,
          Oi = le.Math,
          vn = le.Object,
          gP = le.RegExp,
          ABe = le.String,
          ul = le.TypeError,
          fS = ne.prototype,
          yBe = Yr.prototype,
          pA = vn.prototype,
          hS = le["__core-js_shared__"],
          gS = yBe.toString,
          cn = pA.hasOwnProperty,
          vBe = 0,
          P9 = (function () {
            var d = /[^.]+$/.exec((hS && hS.keys && hS.keys.IE_PROTO) || "")
            return d ? "Symbol(src)_1." + d : ""
          })(),
          pS = pA.toString,
          CBe = gS.call(vn),
          bBe = Bi._,
          EBe = gP(
            "^" +
              gS
                .call(cn)
                .replace(Li, "\\$&")
                .replace(
                  /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                  "$1.*?",
                ) +
              "$",
          ),
          mS = sS ? le.Buffer : e,
          Lf = le.Symbol,
          AS = le.Uint8Array,
          L9 = mS ? mS.allocUnsafe : e,
          yS = Q9(vn.getPrototypeOf, vn),
          U9 = vn.create,
          O9 = pA.propertyIsEnumerable,
          vS = fS.splice,
          q9 = Lf ? Lf.isConcatSpreadable : e,
          UC = Lf ? Lf.iterator : e,
          kg = Lf ? Lf.toStringTag : e,
          CS = (function () {
            try {
              var d = Pg(vn, "defineProperty")
              return d({}, "", {}), d
            } catch {}
          })(),
          _Be = le.clearTimeout !== Bi.clearTimeout && le.clearTimeout,
          xBe = Ve && Ve.now !== Bi.Date.now && Ve.now,
          wBe = le.setTimeout !== Bi.setTimeout && le.setTimeout,
          bS = Oi.ceil,
          ES = Oi.floor,
          pP = vn.getOwnPropertySymbols,
          SBe = mS ? mS.isBuffer : e,
          V9 = le.isFinite,
          IBe = fS.join,
          BBe = Q9(vn.keys, vn),
          qi = Oi.max,
          Os = Oi.min,
          RBe = Ve.now,
          DBe = le.parseInt,
          H9 = Oi.random,
          TBe = fS.reverse,
          mP = Pg(le, "DataView"),
          OC = Pg(le, "Map"),
          AP = Pg(le, "Promise"),
          mA = Pg(le, "Set"),
          qC = Pg(le, "WeakMap"),
          VC = Pg(vn, "create"),
          _S = qC && new qC(),
          AA = {},
          kBe = Lg(mP),
          MBe = Lg(OC),
          FBe = Lg(AP),
          QBe = Lg(mA),
          NBe = Lg(qC),
          xS = Lf ? Lf.prototype : e,
          HC = xS ? xS.valueOf : e,
          W9 = xS ? xS.toString : e
        function F(d) {
          if (ni(d) && !Ft(d) && !(d instanceof mr)) {
            if (d instanceof dl) return d
            if (cn.call(d, "__wrapped__")) return G$(d)
          }
          return new dl(d)
        }
        var yA = (function () {
          function d() {}
          return function (h) {
            if (!$n(h)) return {}
            if (U9) return U9(h)
            d.prototype = h
            var A = new d()
            return (d.prototype = e), A
          }
        })()
        function wS() {}
        function dl(d, h) {
          ;(this.__wrapped__ = d),
            (this.__actions__ = []),
            (this.__chain__ = !!h),
            (this.__index__ = 0),
            (this.__values__ = e)
        }
        ;(F.templateSettings = {
          escape: Nw,
          evaluate: tA,
          interpolate: Tf,
          variable: "",
          imports: { _: F },
        }),
          (F.prototype = wS.prototype),
          (F.prototype.constructor = F),
          (dl.prototype = yA(wS.prototype)),
          (dl.prototype.constructor = dl)
        function mr(d) {
          ;(this.__wrapped__ = d),
            (this.__actions__ = []),
            (this.__dir__ = 1),
            (this.__filtered__ = false),
            (this.__iteratees__ = []),
            (this.__takeCount__ = At),
            (this.__views__ = [])
        }
        function PBe() {
          var d = new mr(this.__wrapped__)
          return (
            (d.__actions__ = Uo(this.__actions__)),
            (d.__dir__ = this.__dir__),
            (d.__filtered__ = this.__filtered__),
            (d.__iteratees__ = Uo(this.__iteratees__)),
            (d.__takeCount__ = this.__takeCount__),
            (d.__views__ = Uo(this.__views__)),
            d
          )
        }
        function LBe() {
          if (this.__filtered__) {
            var d = new mr(this)
            ;(d.__dir__ = -1), (d.__filtered__ = true)
          } else (d = this.clone()), (d.__dir__ *= -1)
          return d
        }
        function UBe() {
          var d = this.__wrapped__.value(),
            h = this.__dir__,
            A = Ft(d),
            b = h < 0,
            I = A ? d.length : 0,
            P = jRe(0, I, this.__views__),
            O = P.start,
            H = P.end,
            j = H - O,
            de = b ? H : O - 1,
            fe = this.__iteratees__,
            Ae = fe.length,
            Te = 0,
            ze = Os(j, this.__takeCount__)
          if (!A || (!b && I == j && ze == j)) return g$(d, this.__actions__)
          var dt = []
          e: for (; j-- && Te < ze; ) {
            de += h
            for (var Jt = -1, ft = d[de]; ++Jt < Ae; ) {
              var lr = fe[Jt],
                xr = lr.iteratee,
                ba = lr.type,
                fo = xr(ft)
              if (ba == Ie) ft = fo
              else if (!fo) {
                if (ba == ce) continue e
                break e
              }
            }
            dt[Te++] = ft
          }
          return dt
        }
        ;(mr.prototype = yA(wS.prototype)), (mr.prototype.constructor = mr)
        function Mg(d) {
          var h = -1,
            A = d == null ? 0 : d.length
          for (this.clear(); ++h < A; ) {
            var b = d[h]
            this.set(b[0], b[1])
          }
        }
        function OBe() {
          ;(this.__data__ = VC ? VC(null) : {}), (this.size = 0)
        }
        function qBe(d) {
          var h = this.has(d) && delete this.__data__[d]
          return (this.size -= h ? 1 : 0), h
        }
        function VBe(d) {
          var h = this.__data__
          if (VC) {
            var A = h[d]
            return A === o ? e : A
          }
          return cn.call(h, d) ? h[d] : e
        }
        function HBe(d) {
          var h = this.__data__
          return VC ? h[d] !== e : cn.call(h, d)
        }
        function WBe(d, h) {
          var A = this.__data__
          return (
            (this.size += this.has(d) ? 0 : 1),
            (A[d] = VC && h === e ? o : h),
            this
          )
        }
        ;(Mg.prototype.clear = OBe),
          (Mg.prototype.delete = qBe),
          (Mg.prototype.get = VBe),
          (Mg.prototype.has = HBe),
          (Mg.prototype.set = WBe)
        function yd(d) {
          var h = -1,
            A = d == null ? 0 : d.length
          for (this.clear(); ++h < A; ) {
            var b = d[h]
            this.set(b[0], b[1])
          }
        }
        function GBe() {
          ;(this.__data__ = []), (this.size = 0)
        }
        function $Be(d) {
          var h = this.__data__,
            A = SS(h, d)
          if (A < 0) return false
          var b = h.length - 1
          return A == b ? h.pop() : vS.call(h, A, 1), --this.size, true
        }
        function YBe(d) {
          var h = this.__data__,
            A = SS(h, d)
          return A < 0 ? e : h[A][1]
        }
        function KBe(d) {
          return SS(this.__data__, d) > -1
        }
        function zBe(d, h) {
          var A = this.__data__,
            b = SS(A, d)
          return b < 0 ? (++this.size, A.push([d, h])) : (A[b][1] = h), this
        }
        ;(yd.prototype.clear = GBe),
          (yd.prototype.delete = $Be),
          (yd.prototype.get = YBe),
          (yd.prototype.has = KBe),
          (yd.prototype.set = zBe)
        function vd(d) {
          var h = -1,
            A = d == null ? 0 : d.length
          for (this.clear(); ++h < A; ) {
            var b = d[h]
            this.set(b[0], b[1])
          }
        }
        function JBe() {
          ;(this.size = 0),
            (this.__data__ = {
              hash: new Mg(),
              map: new (OC || yd)(),
              string: new Mg(),
            })
        }
        function jBe(d) {
          var h = LS(this, d).delete(d)
          return (this.size -= h ? 1 : 0), h
        }
        function ZBe(d) {
          return LS(this, d).get(d)
        }
        function XBe(d) {
          return LS(this, d).has(d)
        }
        function eRe(d, h) {
          var A = LS(this, d),
            b = A.size
          return A.set(d, h), (this.size += A.size == b ? 0 : 1), this
        }
        ;(vd.prototype.clear = JBe),
          (vd.prototype.delete = jBe),
          (vd.prototype.get = ZBe),
          (vd.prototype.has = XBe),
          (vd.prototype.set = eRe)
        function Fg(d) {
          var h = -1,
            A = d == null ? 0 : d.length
          for (this.__data__ = new vd(); ++h < A; ) this.add(d[h])
        }
        function tRe(d) {
          return this.__data__.set(d, o), this
        }
        function rRe(d) {
          return this.__data__.has(d)
        }
        ;(Fg.prototype.add = Fg.prototype.push = tRe), (Fg.prototype.has = rRe)
        function cc(d) {
          var h = (this.__data__ = new yd(d))
          this.size = h.size
        }
        function nRe() {
          ;(this.__data__ = new yd()), (this.size = 0)
        }
        function iRe(d) {
          var h = this.__data__,
            A = h.delete(d)
          return (this.size = h.size), A
        }
        function sRe(d) {
          return this.__data__.get(d)
        }
        function oRe(d) {
          return this.__data__.has(d)
        }
        function aRe(d, h) {
          var A = this.__data__
          if (A instanceof yd) {
            var b = A.__data__
            if (!OC || b.length < r - 1)
              return b.push([d, h]), (this.size = ++A.size), this
            A = this.__data__ = new vd(b)
          }
          return A.set(d, h), (this.size = A.size), this
        }
        ;(cc.prototype.clear = nRe),
          (cc.prototype.delete = iRe),
          (cc.prototype.get = sRe),
          (cc.prototype.has = oRe),
          (cc.prototype.set = aRe)
        function G9(d, h) {
          var A = Ft(d),
            b = !A && Ug(d),
            I = !A && !b && Hf(d),
            P = !A && !b && !I && EA(d),
            O = A || b || I || P,
            H = O ? yn(d.length, ABe) : [],
            j = H.length
          for (var de in d)
            (h || cn.call(d, de)) &&
              !(
                O &&
                (de == "length" ||
                  (I && (de == "offset" || de == "parent")) ||
                  (P &&
                    (de == "buffer" ||
                      de == "byteLength" ||
                      de == "byteOffset")) ||
                  _d(de, j))
              ) &&
              H.push(de)
          return H
        }
        function $9(d) {
          var h = d.length
          return h ? d[BP(0, h - 1)] : e
        }
        function lRe(d, h) {
          return US(Uo(d), Qg(h, 0, d.length))
        }
        function cRe(d) {
          return US(Uo(d))
        }
        function yP(d, h, A) {
          ;((A !== e && !uc(d[h], A)) || (A === e && !(h in d))) && Cd(d, h, A)
        }
        function WC(d, h, A) {
          var b = d[h]
          ;(!(cn.call(d, h) && uc(b, A)) || (A === e && !(h in d))) &&
            Cd(d, h, A)
        }
        function SS(d, h) {
          for (var A = d.length; A--; ) if (uc(d[A][0], h)) return A
          return -1
        }
        function uRe(d, h, A, b) {
          return (
            Uf(d, function (I, P, O) {
              h(b, I, A(I), O)
            }),
            b
          )
        }
        function Y9(d, h) {
          return d && cu(h, Zi(h), d)
        }
        function dRe(d, h) {
          return d && cu(h, qo(h), d)
        }
        function Cd(d, h, A) {
          h == "__proto__" && CS
            ? CS(d, h, {
                configurable: true,
                enumerable: true,
                value: A,
                writable: true,
              })
            : (d[h] = A)
        }
        function vP(d, h) {
          for (var A = -1, b = h.length, I = ne(b), P = d == null; ++A < b; )
            I[A] = P ? e : XP(d, h[A])
          return I
        }
        function Qg(d, h, A) {
          return (
            d === d &&
              (A !== e && (d = d <= A ? d : A),
              h !== e && (d = d >= h ? d : h)),
            d
          )
        }
        function fl(d, h, A, b, I, P) {
          var O,
            H = h & c,
            j = h & u,
            de = h & f
          if ((A && (O = I ? A(d, b, I, P) : A(d)), O !== e)) return O
          if (!$n(d)) return d
          var fe = Ft(d)
          if (fe) {
            if (((O = XRe(d)), !H)) return Uo(d, O)
          } else {
            var Ae = qs(d),
              Te = Ae == Gr || Ae == pr
            if (Hf(d)) return A$(d, H)
            if (Ae == be || Ae == rr || (Te && !I)) {
              if (((O = j || Te ? {} : N$(d)), !H))
                return j ? VRe(d, dRe(O, d)) : qRe(d, Y9(O, d))
            } else {
              if (!$r[Ae]) return I ? d : {}
              O = eDe(d, Ae, H)
            }
          }
          P || (P = new cc())
          var ze = P.get(d)
          if (ze) return ze
          P.set(d, O),
            dY(d)
              ? d.forEach(function (ft) {
                  O.add(fl(ft, h, A, ft, d, P))
                })
              : cY(d) &&
                d.forEach(function (ft, lr) {
                  O.set(lr, fl(ft, h, A, lr, d, P))
                })
          var dt = de ? (j ? UP : LP) : j ? qo : Zi,
            Jt = fe ? e : dt(d)
          return (
            Cs(Jt || d, function (ft, lr) {
              Jt && ((lr = ft), (ft = d[lr])), WC(O, lr, fl(ft, h, A, lr, d, P))
            }),
            O
          )
        }
        function fRe(d) {
          var h = Zi(d)
          return function (A) {
            return K9(A, d, h)
          }
        }
        function K9(d, h, A) {
          var b = A.length
          if (d == null) return !b
          for (d = vn(d); b--; ) {
            var I = A[b],
              P = h[I],
              O = d[I]
            if ((O === e && !(I in d)) || !P(O)) return false
          }
          return true
        }
        function z9(d, h, A) {
          if (typeof d != "function") throw new ul(i)
          return jC(function () {
            d.apply(e, A)
          }, h)
        }
        function GC(d, h, A, b) {
          var I = -1,
            P = md,
            O = true,
            H = d.length,
            j = [],
            de = h.length
          if (!H) return j
          A && (h = Zr(h, kn(A))),
            b
              ? ((P = oc), (O = false))
              : h.length >= r && ((P = Lo), (O = false), (h = new Fg(h)))
          e: for (; ++I < H; ) {
            var fe = d[I],
              Ae = A == null ? fe : A(fe)
            if (((fe = b || fe !== 0 ? fe : 0), O && Ae === Ae)) {
              for (var Te = de; Te--; ) if (h[Te] === Ae) continue e
              j.push(fe)
            } else P(h, Ae, b) || j.push(fe)
          }
          return j
        }
        var Uf = E$(lu),
          J9 = E$(bP, true)
        function hRe(d, h) {
          var A = true
          return (
            Uf(d, function (b, I, P) {
              return (A = !!h(b, I, P)), A
            }),
            A
          )
        }
        function IS(d, h, A) {
          for (var b = -1, I = d.length; ++b < I; ) {
            var P = d[b],
              O = h(P)
            if (O != null && (H === e ? O === O && !Ca(O) : A(O, H)))
              var H = O,
                j = P
          }
          return j
        }
        function gRe(d, h, A, b) {
          var I = d.length
          for (
            A = Yt(A),
              A < 0 && (A = -A > I ? 0 : I + A),
              b = b === e || b > I ? I : Yt(b),
              b < 0 && (b += I),
              b = A > b ? 0 : hY(b);
            A < b;

          )
            d[A++] = h
          return d
        }
        function j9(d, h) {
          var A = []
          return (
            Uf(d, function (b, I, P) {
              h(b, I, P) && A.push(b)
            }),
            A
          )
        }
        function bs(d, h, A, b, I) {
          var P = -1,
            O = d.length
          for (A || (A = rDe), I || (I = []); ++P < O; ) {
            var H = d[P]
            h > 0 && A(H)
              ? h > 1
                ? bs(H, h - 1, A, b, I)
                : ao(I, H)
              : b || (I[I.length] = H)
          }
          return I
        }
        var CP = _$(),
          Z9 = _$(true)
        function lu(d, h) {
          return d && CP(d, h, Zi)
        }
        function bP(d, h) {
          return d && Z9(d, h, Zi)
        }
        function BS(d, h) {
          return cl(h, function (A) {
            return xd(d[A])
          })
        }
        function Ng(d, h) {
          h = qf(h, d)
          for (var A = 0, b = h.length; d != null && A < b; ) d = d[uu(h[A++])]
          return A && A == b ? d : e
        }
        function X9(d, h, A) {
          var b = h(d)
          return Ft(d) ? b : ao(b, A(d))
        }
        function co(d) {
          return d == null
            ? d === e
              ? nu
              : he
            : kg && kg in vn(d)
              ? JRe(d)
              : cDe(d)
        }
        function EP(d, h) {
          return d > h
        }
        function pRe(d, h) {
          return d != null && cn.call(d, h)
        }
        function mRe(d, h) {
          return d != null && h in vn(d)
        }
        function ARe(d, h, A) {
          return d >= Os(h, A) && d < qi(h, A)
        }
        function _P(d, h, A) {
          for (
            var b = A ? oc : md,
              I = d[0].length,
              P = d.length,
              O = P,
              H = ne(P),
              j = 1 / 0,
              de = [];
            O--;

          ) {
            var fe = d[O]
            O && h && (fe = Zr(fe, kn(h))),
              (j = Os(fe.length, j)),
              (H[O] =
                !A && (h || (I >= 120 && fe.length >= 120))
                  ? new Fg(O && fe)
                  : e)
          }
          fe = d[0]
          var Ae = -1,
            Te = H[0]
          e: for (; ++Ae < I && de.length < j; ) {
            var ze = fe[Ae],
              dt = h ? h(ze) : ze
            if (
              ((ze = A || ze !== 0 ? ze : 0), !(Te ? Lo(Te, dt) : b(de, dt, A)))
            ) {
              for (O = P; --O; ) {
                var Jt = H[O]
                if (!(Jt ? Lo(Jt, dt) : b(d[O], dt, A))) continue e
              }
              Te && Te.push(dt), de.push(ze)
            }
          }
          return de
        }
        function yRe(d, h, A, b) {
          return (
            lu(d, function (I, P, O) {
              h(b, A(I), P, O)
            }),
            b
          )
        }
        function $C(d, h, A) {
          ;(h = qf(h, d)), (d = O$(d, h))
          var b = d == null ? d : d[uu(gl(h))]
          return b == null ? e : vs(b, d, A)
        }
        function e$(d) {
          return ni(d) && co(d) == rr
        }
        function vRe(d) {
          return ni(d) && co(d) == ji
        }
        function CRe(d) {
          return ni(d) && co(d) == Wr
        }
        function YC(d, h, A, b, I) {
          return d === h
            ? true
            : d == null || h == null || (!ni(d) && !ni(h))
              ? d !== d && h !== h
              : bRe(d, h, A, b, YC, I)
        }
        function bRe(d, h, A, b, I, P) {
          var O = Ft(d),
            H = Ft(h),
            j = O ? ue : qs(d),
            de = H ? ue : qs(h)
          ;(j = j == rr ? be : j), (de = de == rr ? be : de)
          var fe = j == be,
            Ae = de == be,
            Te = j == de
          if (Te && Hf(d)) {
            if (!Hf(h)) return false
            ;(O = true), (fe = false)
          }
          if (Te && !fe)
            return (
              P || (P = new cc()),
              O || EA(d) ? M$(d, h, A, b, I, P) : KRe(d, h, j, A, b, I, P)
            )
          if (!(A & p)) {
            var ze = fe && cn.call(d, "__wrapped__"),
              dt = Ae && cn.call(h, "__wrapped__")
            if (ze || dt) {
              var Jt = ze ? d.value() : d,
                ft = dt ? h.value() : h
              return P || (P = new cc()), I(Jt, ft, A, b, P)
            }
          }
          return Te ? (P || (P = new cc()), zRe(d, h, A, b, I, P)) : false
        }
        function ERe(d) {
          return ni(d) && qs(d) == Ee
        }
        function xP(d, h, A, b) {
          var I = A.length,
            P = I,
            O = !b
          if (d == null) return !P
          for (d = vn(d); I--; ) {
            var H = A[I]
            if (O && H[2] ? H[1] !== d[H[0]] : !(H[0] in d)) return false
          }
          for (; ++I < P; ) {
            H = A[I]
            var j = H[0],
              de = d[j],
              fe = H[1]
            if (O && H[2]) {
              if (de === e && !(j in d)) return false
            } else {
              var Ae = new cc()
              if (b) var Te = b(de, fe, j, d, h, Ae)
              if (!(Te === e ? YC(fe, de, p | g, b, Ae) : Te)) return false
            }
          }
          return true
        }
        function t$(d) {
          if (!$n(d) || iDe(d)) return false
          var h = xd(d) ? EBe : z2
          return h.test(Lg(d))
        }
        function _Re(d) {
          return ni(d) && co(d) == Rn
        }
        function xRe(d) {
          return ni(d) && qs(d) == Ii
        }
        function wRe(d) {
          return ni(d) && GS(d.length) && !!An[co(d)]
        }
        function r$(d) {
          return typeof d == "function"
            ? d
            : d == null
              ? Vo
              : typeof d == "object"
                ? Ft(d)
                  ? s$(d[0], d[1])
                  : i$(d)
                : xY(d)
        }
        function wP(d) {
          if (!JC(d)) return BBe(d)
          var h = []
          for (var A in vn(d)) cn.call(d, A) && A != "constructor" && h.push(A)
          return h
        }
        function SRe(d) {
          if (!$n(d)) return lDe(d)
          var h = JC(d),
            A = []
          for (var b in d)
            (b == "constructor" && (h || !cn.call(d, b))) || A.push(b)
          return A
        }
        function SP(d, h) {
          return d < h
        }
        function n$(d, h) {
          var A = -1,
            b = Oo(d) ? ne(d.length) : []
          return (
            Uf(d, function (I, P, O) {
              b[++A] = h(I, P, O)
            }),
            b
          )
        }
        function i$(d) {
          var h = qP(d)
          return h.length == 1 && h[0][2]
            ? L$(h[0][0], h[0][1])
            : function (A) {
                return A === d || xP(A, d, h)
              }
        }
        function s$(d, h) {
          return HP(d) && P$(h)
            ? L$(uu(d), h)
            : function (A) {
                var b = XP(A, d)
                return b === e && b === h ? eL(A, d) : YC(h, b, p | g)
              }
        }
        function RS(d, h, A, b, I) {
          d !== h &&
            CP(
              h,
              function (P, O) {
                if ((I || (I = new cc()), $n(P))) IRe(d, h, O, A, RS, b, I)
                else {
                  var H = b ? b(GP(d, O), P, O + "", d, h, I) : e
                  H === e && (H = P), yP(d, O, H)
                }
              },
              qo,
            )
        }
        function IRe(d, h, A, b, I, P, O) {
          var H = GP(d, A),
            j = GP(h, A),
            de = O.get(j)
          if (de) {
            yP(d, A, de)
            return
          }
          var fe = P ? P(H, j, A + "", d, h, O) : e,
            Ae = fe === e
          if (Ae) {
            var Te = Ft(j),
              ze = !Te && Hf(j),
              dt = !Te && !ze && EA(j)
            ;(fe = j),
              Te || ze || dt
                ? Ft(H)
                  ? (fe = H)
                  : vi(H)
                    ? (fe = Uo(H))
                    : ze
                      ? ((Ae = false), (fe = A$(j, true)))
                      : dt
                        ? ((Ae = false), (fe = y$(j, true)))
                        : (fe = [])
                : ZC(j) || Ug(j)
                  ? ((fe = H),
                    Ug(H) ? (fe = gY(H)) : (!$n(H) || xd(H)) && (fe = N$(j)))
                  : (Ae = false)
          }
          Ae && (O.set(j, fe), I(fe, j, b, P, O), O.delete(j)), yP(d, A, fe)
        }
        function o$(d, h) {
          var A = d.length
          if (A) return (h += h < 0 ? A : 0), _d(h, A) ? d[h] : e
        }
        function a$(d, h, A) {
          h.length
            ? (h = Zr(h, function (P) {
                return Ft(P)
                  ? function (O) {
                      return Ng(O, P.length === 1 ? P[0] : P)
                    }
                  : P
              }))
            : (h = [Vo])
          var b = -1
          h = Zr(h, kn(ut()))
          var I = n$(d, function (P, O, H) {
            var j = Zr(h, function (de) {
              return de(P)
            })
            return { criteria: j, index: ++b, value: P }
          })
          return st(I, function (P, O) {
            return ORe(P, O, A)
          })
        }
        function BRe(d, h) {
          return l$(d, h, function (A, b) {
            return eL(d, b)
          })
        }
        function l$(d, h, A) {
          for (var b = -1, I = h.length, P = {}; ++b < I; ) {
            var O = h[b],
              H = Ng(d, O)
            A(H, O) && KC(P, qf(O, d), H)
          }
          return P
        }
        function RRe(d) {
          return function (h) {
            return Ng(h, d)
          }
        }
        function IP(d, h, A, b) {
          var I = b ? x : Ad,
            P = -1,
            O = h.length,
            H = d
          for (d === h && (h = Uo(h)), A && (H = Zr(d, kn(A))); ++P < O; )
            for (
              var j = 0, de = h[P], fe = A ? A(de) : de;
              (j = I(H, fe, j, b)) > -1;

            )
              H !== d && vS.call(H, j, 1), vS.call(d, j, 1)
          return d
        }
        function c$(d, h) {
          for (var A = d ? h.length : 0, b = A - 1; A--; ) {
            var I = h[A]
            if (A == b || I !== P) {
              var P = I
              _d(I) ? vS.call(d, I, 1) : TP(d, I)
            }
          }
          return d
        }
        function BP(d, h) {
          return d + ES(H9() * (h - d + 1))
        }
        function DRe(d, h, A, b) {
          for (var I = -1, P = qi(bS((h - d) / (A || 1)), 0), O = ne(P); P--; )
            (O[b ? P : ++I] = d), (d += A)
          return O
        }
        function RP(d, h) {
          var A = ""
          if (!d || h < 1 || h > J) return A
          do h % 2 && (A += d), (h = ES(h / 2)), h && (d += d)
          while (h)
          return A
        }
        function tr(d, h) {
          return $P(U$(d, h, Vo), d + "")
        }
        function TRe(d) {
          return $9(_A(d))
        }
        function kRe(d, h) {
          var A = _A(d)
          return US(A, Qg(h, 0, A.length))
        }
        function KC(d, h, A, b) {
          if (!$n(d)) return d
          h = qf(h, d)
          for (
            var I = -1, P = h.length, O = P - 1, H = d;
            H != null && ++I < P;

          ) {
            var j = uu(h[I]),
              de = A
            if (j === "__proto__" || j === "constructor" || j === "prototype")
              return d
            if (I != O) {
              var fe = H[j]
              ;(de = b ? b(fe, j, H) : e),
                de === e && (de = $n(fe) ? fe : _d(h[I + 1]) ? [] : {})
            }
            WC(H, j, de), (H = H[j])
          }
          return d
        }
        var u$ = _S
            ? function (d, h) {
                return _S.set(d, h), d
              }
            : Vo,
          MRe = CS
            ? function (d, h) {
                return CS(d, "toString", {
                  configurable: true,
                  enumerable: false,
                  value: rL(h),
                  writable: true,
                })
              }
            : Vo
        function FRe(d) {
          return US(_A(d))
        }
        function hl(d, h, A) {
          var b = -1,
            I = d.length
          h < 0 && (h = -h > I ? 0 : I + h),
            (A = A > I ? I : A),
            A < 0 && (A += I),
            (I = h > A ? 0 : (A - h) >>> 0),
            (h >>>= 0)
          for (var P = ne(I); ++b < I; ) P[b] = d[b + h]
          return P
        }
        function QRe(d, h) {
          var A
          return (
            Uf(d, function (b, I, P) {
              return (A = h(b, I, P)), !A
            }),
            !!A
          )
        }
        function DS(d, h, A) {
          var b = 0,
            I = d == null ? b : d.length
          if (typeof h == "number" && h === h && I <= Mt) {
            for (; b < I; ) {
              var P = (b + I) >>> 1,
                O = d[P]
              O !== null && !Ca(O) && (A ? O <= h : O < h)
                ? (b = P + 1)
                : (I = P)
            }
            return I
          }
          return DP(d, h, Vo, A)
        }
        function DP(d, h, A, b) {
          var I = 0,
            P = d == null ? 0 : d.length
          if (P === 0) return 0
          h = A(h)
          for (
            var O = h !== h, H = h === null, j = Ca(h), de = h === e;
            I < P;

          ) {
            var fe = ES((I + P) / 2),
              Ae = A(d[fe]),
              Te = Ae !== e,
              ze = Ae === null,
              dt = Ae === Ae,
              Jt = Ca(Ae)
            if (O) var ft = b || dt
            else
              de
                ? (ft = dt && (b || Te))
                : H
                  ? (ft = dt && Te && (b || !ze))
                  : j
                    ? (ft = dt && Te && !ze && (b || !Jt))
                    : ze || Jt
                      ? (ft = false)
                      : (ft = b ? Ae <= h : Ae < h)
            ft ? (I = fe + 1) : (P = fe)
          }
          return Os(P, ve)
        }
        function d$(d, h) {
          for (var A = -1, b = d.length, I = 0, P = []; ++A < b; ) {
            var O = d[A],
              H = h ? h(O) : O
            if (!A || !uc(H, j)) {
              var j = H
              P[I++] = O === 0 ? 0 : O
            }
          }
          return P
        }
        function f$(d) {
          return typeof d == "number" ? d : Ca(d) ? Ue : +d
        }
        function va(d) {
          if (typeof d == "string") return d
          if (Ft(d)) return Zr(d, va) + ""
          if (Ca(d)) return W9 ? W9.call(d) : ""
          var h = d + ""
          return h == "0" && 1 / d == -se ? "-0" : h
        }
        function Of(d, h, A) {
          var b = -1,
            I = md,
            P = d.length,
            O = true,
            H = [],
            j = H
          if (A) (O = false), (I = oc)
          else if (P >= r) {
            var de = h ? null : $Re(d)
            if (de) return dS(de)
            ;(O = false), (I = Lo), (j = new Fg())
          } else j = h ? [] : H
          e: for (; ++b < P; ) {
            var fe = d[b],
              Ae = h ? h(fe) : fe
            if (((fe = A || fe !== 0 ? fe : 0), O && Ae === Ae)) {
              for (var Te = j.length; Te--; ) if (j[Te] === Ae) continue e
              h && j.push(Ae), H.push(fe)
            } else I(j, Ae, A) || (j !== H && j.push(Ae), H.push(fe))
          }
          return H
        }
        function TP(d, h) {
          return (
            (h = qf(h, d)), (d = O$(d, h)), d == null || delete d[uu(gl(h))]
          )
        }
        function h$(d, h, A, b) {
          return KC(d, h, A(Ng(d, h)), b)
        }
        function TS(d, h, A, b) {
          for (
            var I = d.length, P = b ? I : -1;
            (b ? P-- : ++P < I) && h(d[P], P, d);

          );
          return A
            ? hl(d, b ? 0 : P, b ? P + 1 : I)
            : hl(d, b ? P + 1 : 0, b ? I : P)
        }
        function g$(d, h) {
          var A = d
          return (
            A instanceof mr && (A = A.value()),
            ya(
              h,
              function (b, I) {
                return I.func.apply(I.thisArg, ao([b], I.args))
              },
              A,
            )
          )
        }
        function kP(d, h, A) {
          var b = d.length
          if (b < 2) return b ? Of(d[0]) : []
          for (var I = -1, P = ne(b); ++I < b; )
            for (var O = d[I], H = -1; ++H < b; )
              H != I && (P[I] = GC(P[I] || O, d[H], h, A))
          return Of(bs(P, 1), h, A)
        }
        function p$(d, h, A) {
          for (var b = -1, I = d.length, P = h.length, O = {}; ++b < I; ) {
            var H = b < P ? h[b] : e
            A(O, d[b], H)
          }
          return O
        }
        function MP(d) {
          return vi(d) ? d : []
        }
        function FP(d) {
          return typeof d == "function" ? d : Vo
        }
        function qf(d, h) {
          return Ft(d) ? d : HP(d, h) ? [d] : W$(Xr(d))
        }
        var NRe = tr
        function Vf(d, h, A) {
          var b = d.length
          return (A = A === e ? b : A), !h && A >= b ? d : hl(d, h, A)
        }
        var m$ =
          _Be ||
          function (d) {
            return Bi.clearTimeout(d)
          }
        function A$(d, h) {
          if (h) return d.slice()
          var A = d.length,
            b = L9 ? L9(A) : new d.constructor(A)
          return d.copy(b), b
        }
        function QP(d) {
          var h = new d.constructor(d.byteLength)
          return new AS(h).set(new AS(d)), h
        }
        function PRe(d, h) {
          var A = h ? QP(d.buffer) : d.buffer
          return new d.constructor(A, d.byteOffset, d.byteLength)
        }
        function LRe(d) {
          var h = new d.constructor(d.source, Pw.exec(d))
          return (h.lastIndex = d.lastIndex), h
        }
        function URe(d) {
          return HC ? vn(HC.call(d)) : {}
        }
        function y$(d, h) {
          var A = h ? QP(d.buffer) : d.buffer
          return new d.constructor(A, d.byteOffset, d.length)
        }
        function v$(d, h) {
          if (d !== h) {
            var A = d !== e,
              b = d === null,
              I = d === d,
              P = Ca(d),
              O = h !== e,
              H = h === null,
              j = h === h,
              de = Ca(h)
            if (
              (!H && !de && !P && d > h) ||
              (P && O && j && !H && !de) ||
              (b && O && j) ||
              (!A && j) ||
              !I
            )
              return 1
            if (
              (!b && !P && !de && d < h) ||
              (de && A && I && !b && !P) ||
              (H && A && I) ||
              (!O && I) ||
              !j
            )
              return -1
          }
          return 0
        }
        function ORe(d, h, A) {
          for (
            var b = -1,
              I = d.criteria,
              P = h.criteria,
              O = I.length,
              H = A.length;
            ++b < O;

          ) {
            var j = v$(I[b], P[b])
            if (j) {
              if (b >= H) return j
              var de = A[b]
              return j * (de == "desc" ? -1 : 1)
            }
          }
          return d.index - h.index
        }
        function C$(d, h, A, b) {
          for (
            var I = -1,
              P = d.length,
              O = A.length,
              H = -1,
              j = h.length,
              de = qi(P - O, 0),
              fe = ne(j + de),
              Ae = !b;
            ++H < j;

          )
            fe[H] = h[H]
          for (; ++I < O; ) (Ae || I < P) && (fe[A[I]] = d[I])
          for (; de--; ) fe[H++] = d[I++]
          return fe
        }
        function b$(d, h, A, b) {
          for (
            var I = -1,
              P = d.length,
              O = -1,
              H = A.length,
              j = -1,
              de = h.length,
              fe = qi(P - H, 0),
              Ae = ne(fe + de),
              Te = !b;
            ++I < fe;

          )
            Ae[I] = d[I]
          for (var ze = I; ++j < de; ) Ae[ze + j] = h[j]
          for (; ++O < H; ) (Te || I < P) && (Ae[ze + A[O]] = d[I++])
          return Ae
        }
        function Uo(d, h) {
          var A = -1,
            b = d.length
          for (h || (h = ne(b)); ++A < b; ) h[A] = d[A]
          return h
        }
        function cu(d, h, A, b) {
          var I = !A
          A || (A = {})
          for (var P = -1, O = h.length; ++P < O; ) {
            var H = h[P],
              j = b ? b(A[H], d[H], H, A, d) : e
            j === e && (j = d[H]), I ? Cd(A, H, j) : WC(A, H, j)
          }
          return A
        }
        function qRe(d, h) {
          return cu(d, VP(d), h)
        }
        function VRe(d, h) {
          return cu(d, F$(d), h)
        }
        function kS(d, h) {
          return function (A, b) {
            var I = Ft(A) ? it : uRe,
              P = h ? h() : {}
            return I(A, d, ut(b, 2), P)
          }
        }
        function vA(d) {
          return tr(function (h, A) {
            var b = -1,
              I = A.length,
              P = I > 1 ? A[I - 1] : e,
              O = I > 2 ? A[2] : e
            for (
              P = d.length > 3 && typeof P == "function" ? (I--, P) : e,
                O && uo(A[0], A[1], O) && ((P = I < 3 ? e : P), (I = 1)),
                h = vn(h);
              ++b < I;

            ) {
              var H = A[b]
              H && d(h, H, b, P)
            }
            return h
          })
        }
        function E$(d, h) {
          return function (A, b) {
            if (A == null) return A
            if (!Oo(A)) return d(A, b)
            for (
              var I = A.length, P = h ? I : -1, O = vn(A);
              (h ? P-- : ++P < I) && b(O[P], P, O) !== false;

            );
            return A
          }
        }
        function _$(d) {
          return function (h, A, b) {
            for (var I = -1, P = vn(h), O = b(h), H = O.length; H--; ) {
              var j = O[d ? H : ++I]
              if (A(P[j], j, P) === false) break
            }
            return h
          }
        }
        function HRe(d, h, A) {
          var b = h & m,
            I = zC(d)
          function P() {
            var O = this && this !== Bi && this instanceof P ? I : d
            return O.apply(b ? A : this, arguments)
          }
          return P
        }
        function x$(d) {
          return function (h) {
            h = Xr(h)
            var A = hA(h) ? lc(h) : e,
              b = A ? A[0] : h.charAt(0),
              I = A ? Vf(A, 1).join("") : h.slice(1)
            return b[d]() + I
          }
        }
        function CA(d) {
          return function (h) {
            return ya(EY(bY(h).replace(Xw, "")), d, "")
          }
        }
        function zC(d) {
          return function () {
            var h = arguments
            switch (h.length) {
              case 0:
                return new d()
              case 1:
                return new d(h[0])
              case 2:
                return new d(h[0], h[1])
              case 3:
                return new d(h[0], h[1], h[2])
              case 4:
                return new d(h[0], h[1], h[2], h[3])
              case 5:
                return new d(h[0], h[1], h[2], h[3], h[4])
              case 6:
                return new d(h[0], h[1], h[2], h[3], h[4], h[5])
              case 7:
                return new d(h[0], h[1], h[2], h[3], h[4], h[5], h[6])
            }
            var A = yA(d.prototype),
              b = d.apply(A, h)
            return $n(b) ? b : A
          }
        }
        function WRe(d, h, A) {
          var b = zC(d)
          function I() {
            for (var P = arguments.length, O = ne(P), H = P, j = bA(I); H--; )
              O[H] = arguments[H]
            var de = P < 3 && O[0] !== j && O[P - 1] !== j ? [] : Nf(O, j)
            if (((P -= de.length), P < A))
              return R$(d, h, MS, I.placeholder, e, O, de, e, e, A - P)
            var fe = this && this !== Bi && this instanceof I ? b : d
            return vs(fe, this, O)
          }
          return I
        }
        function w$(d) {
          return function (h, A, b) {
            var I = vn(h)
            if (!Oo(h)) {
              var P = ut(A, 3)
              ;(h = Zi(h)),
                (A = function (H) {
                  return P(I[H], H, I)
                })
            }
            var O = d(h, A, b)
            return O > -1 ? I[P ? h[O] : O] : e
          }
        }
        function S$(d) {
          return Ed(function (h) {
            var A = h.length,
              b = A,
              I = dl.prototype.thru
            for (d && h.reverse(); b--; ) {
              var P = h[b]
              if (typeof P != "function") throw new ul(i)
              if (I && !O && PS(P) == "wrapper") var O = new dl([], true)
            }
            for (b = O ? b : A; ++b < A; ) {
              P = h[b]
              var H = PS(P),
                j = H == "wrapper" ? OP(P) : e
              j &&
              WP(j[0]) &&
              j[1] == (T | C | w | N) &&
              !j[4].length &&
              j[9] == 1
                ? (O = O[PS(j[0])].apply(O, j[3]))
                : (O = P.length == 1 && WP(P) ? O[H]() : O.thru(P))
            }
            return function () {
              var de = arguments,
                fe = de[0]
              if (O && de.length == 1 && Ft(fe)) return O.plant(fe).value()
              for (var Ae = 0, Te = A ? h[Ae].apply(this, de) : fe; ++Ae < A; )
                Te = h[Ae].call(this, Te)
              return Te
            }
          })
        }
        function MS(d, h, A, b, I, P, O, H, j, de) {
          var fe = h & T,
            Ae = h & m,
            Te = h & y,
            ze = h & (C | E),
            dt = h & W,
            Jt = Te ? e : zC(d)
          function ft() {
            for (var lr = arguments.length, xr = ne(lr), ba = lr; ba--; )
              xr[ba] = arguments[ba]
            if (ze)
              var fo = bA(ft),
                Ea = rBe(xr, fo)
            if (
              (b && (xr = C$(xr, b, I, ze)),
              P && (xr = b$(xr, P, O, ze)),
              (lr -= Ea),
              ze && lr < de)
            ) {
              var Ci = Nf(xr, fo)
              return R$(d, h, MS, ft.placeholder, A, xr, Ci, H, j, de - lr)
            }
            var dc = Ae ? A : this,
              Sd = Te ? dc[d] : d
            return (
              (lr = xr.length),
              H ? (xr = uDe(xr, H)) : dt && lr > 1 && xr.reverse(),
              fe && j < lr && (xr.length = j),
              this && this !== Bi && this instanceof ft && (Sd = Jt || zC(Sd)),
              Sd.apply(dc, xr)
            )
          }
          return ft
        }
        function I$(d, h) {
          return function (A, b) {
            return yRe(A, d, h(b), {})
          }
        }
        function FS(d, h) {
          return function (A, b) {
            var I
            if (A === e && b === e) return h
            if ((A !== e && (I = A), b !== e)) {
              if (I === e) return b
              typeof A == "string" || typeof b == "string"
                ? ((A = va(A)), (b = va(b)))
                : ((A = f$(A)), (b = f$(b))),
                (I = d(A, b))
            }
            return I
          }
        }
        function NP(d) {
          return Ed(function (h) {
            return (
              (h = Zr(h, kn(ut()))),
              tr(function (A) {
                var b = this
                return d(h, function (I) {
                  return vs(I, b, A)
                })
              })
            )
          })
        }
        function QS(d, h) {
          h = h === e ? " " : va(h)
          var A = h.length
          if (A < 2) return A ? RP(h, d) : h
          var b = RP(h, bS(d / gA(h)))
          return hA(h) ? Vf(lc(b), 0, d).join("") : b.slice(0, d)
        }
        function GRe(d, h, A, b) {
          var I = h & m,
            P = zC(d)
          function O() {
            for (
              var H = -1,
                j = arguments.length,
                de = -1,
                fe = b.length,
                Ae = ne(fe + j),
                Te = this && this !== Bi && this instanceof O ? P : d;
              ++de < fe;

            )
              Ae[de] = b[de]
            for (; j--; ) Ae[de++] = arguments[++H]
            return vs(Te, I ? A : this, Ae)
          }
          return O
        }
        function B$(d) {
          return function (h, A, b) {
            return (
              b && typeof b != "number" && uo(h, A, b) && (A = b = e),
              (h = wd(h)),
              A === e ? ((A = h), (h = 0)) : (A = wd(A)),
              (b = b === e ? (h < A ? 1 : -1) : wd(b)),
              DRe(h, A, b, d)
            )
          }
        }
        function NS(d) {
          return function (h, A) {
            return (
              (typeof h == "string" && typeof A == "string") ||
                ((h = pl(h)), (A = pl(A))),
              d(h, A)
            )
          }
        }
        function R$(d, h, A, b, I, P, O, H, j, de) {
          var fe = h & C,
            Ae = fe ? O : e,
            Te = fe ? e : O,
            ze = fe ? P : e,
            dt = fe ? e : P
          ;(h |= fe ? w : B), (h &= ~(fe ? B : w)), h & v || (h &= ~(m | y))
          var Jt = [d, h, I, ze, Ae, dt, Te, H, j, de],
            ft = A.apply(e, Jt)
          return WP(d) && q$(ft, Jt), (ft.placeholder = b), V$(ft, d, h)
        }
        function PP(d) {
          var h = Oi[d]
          return function (A, b) {
            if (
              ((A = pl(A)), (b = b == null ? 0 : Os(Yt(b), 292)), b && V9(A))
            ) {
              var I = (Xr(A) + "e").split("e"),
                P = h(I[0] + "e" + (+I[1] + b))
              return (I = (Xr(P) + "e").split("e")), +(I[0] + "e" + (+I[1] - b))
            }
            return h(A)
          }
        }
        var $Re =
          mA && 1 / dS(new mA([, -0]))[1] == se
            ? function (d) {
                return new mA(d)
              }
            : sL
        function D$(d) {
          return function (h) {
            var A = qs(h)
            return A == Ee ? hP(h) : A == Ii ? cBe(h) : Ui(h, d(h))
          }
        }
        function bd(d, h, A, b, I, P, O, H) {
          var j = h & y
          if (!j && typeof d != "function") throw new ul(i)
          var de = b ? b.length : 0
          if (
            (de || ((h &= ~(w | B)), (b = I = e)),
            (O = O === e ? O : qi(Yt(O), 0)),
            (H = H === e ? H : Yt(H)),
            (de -= I ? I.length : 0),
            h & B)
          ) {
            var fe = b,
              Ae = I
            b = I = e
          }
          var Te = j ? e : OP(d),
            ze = [d, h, A, b, I, fe, Ae, P, O, H]
          if (
            (Te && aDe(ze, Te),
            (d = ze[0]),
            (h = ze[1]),
            (A = ze[2]),
            (b = ze[3]),
            (I = ze[4]),
            (H = ze[9] = ze[9] === e ? (j ? 0 : d.length) : qi(ze[9] - de, 0)),
            !H && h & (C | E) && (h &= ~(C | E)),
            !h || h == m)
          )
            var dt = HRe(d, h, A)
          else
            h == C || h == E
              ? (dt = WRe(d, h, H))
              : (h == w || h == (m | w)) && !I.length
                ? (dt = GRe(d, h, A, b))
                : (dt = MS.apply(e, ze))
          var Jt = Te ? u$ : q$
          return V$(Jt(dt, ze), d, h)
        }
        function T$(d, h, A, b) {
          return d === e || (uc(d, pA[A]) && !cn.call(b, A)) ? h : d
        }
        function k$(d, h, A, b, I, P) {
          return (
            $n(d) && $n(h) && (P.set(h, d), RS(d, h, e, k$, P), P.delete(h)), d
          )
        }
        function YRe(d) {
          return ZC(d) ? e : d
        }
        function M$(d, h, A, b, I, P) {
          var O = A & p,
            H = d.length,
            j = h.length
          if (H != j && !(O && j > H)) return false
          var de = P.get(d),
            fe = P.get(h)
          if (de && fe) return de == h && fe == d
          var Ae = -1,
            Te = true,
            ze = A & g ? new Fg() : e
          for (P.set(d, h), P.set(h, d); ++Ae < H; ) {
            var dt = d[Ae],
              Jt = h[Ae]
            if (b) var ft = O ? b(Jt, dt, Ae, h, d, P) : b(dt, Jt, Ae, d, h, P)
            if (ft !== e) {
              if (ft) continue
              Te = false
              break
            }
            if (ze) {
              if (
                !Tg(h, function (lr, xr) {
                  if (!Lo(ze, xr) && (dt === lr || I(dt, lr, A, b, P)))
                    return ze.push(xr)
                })
              ) {
                Te = false
                break
              }
            } else if (!(dt === Jt || I(dt, Jt, A, b, P))) {
              Te = false
              break
            }
          }
          return P.delete(d), P.delete(h), Te
        }
        function KRe(d, h, A, b, I, P, O) {
          switch (A) {
            case pa:
              if (d.byteLength != h.byteLength || d.byteOffset != h.byteOffset)
                return false
              ;(d = d.buffer), (h = h.buffer)
            case ji:
              return !(d.byteLength != h.byteLength || !P(new AS(d), new AS(h)))
            case or:
            case Wr:
            case Or:
              return uc(+d, +h)
            case ln:
              return d.name == h.name && d.message == h.message
            case Rn:
            case so:
              return d == h + ""
            case Ee:
              var H = hP
            case Ii:
              var j = b & p
              if ((H || (H = dS), d.size != h.size && !j)) return false
              var de = O.get(d)
              if (de) return de == h
              ;(b |= g), O.set(d, h)
              var fe = M$(H(d), H(h), b, I, P, O)
              return O.delete(d), fe
            case cd:
              if (HC) return HC.call(d) == HC.call(h)
          }
          return false
        }
        function zRe(d, h, A, b, I, P) {
          var O = A & p,
            H = LP(d),
            j = H.length,
            de = LP(h),
            fe = de.length
          if (j != fe && !O) return false
          for (var Ae = j; Ae--; ) {
            var Te = H[Ae]
            if (!(O ? Te in h : cn.call(h, Te))) return false
          }
          var ze = P.get(d),
            dt = P.get(h)
          if (ze && dt) return ze == h && dt == d
          var Jt = true
          P.set(d, h), P.set(h, d)
          for (var ft = O; ++Ae < j; ) {
            Te = H[Ae]
            var lr = d[Te],
              xr = h[Te]
            if (b) var ba = O ? b(xr, lr, Te, h, d, P) : b(lr, xr, Te, d, h, P)
            if (!(ba === e ? lr === xr || I(lr, xr, A, b, P) : ba)) {
              Jt = false
              break
            }
            ft || (ft = Te == "constructor")
          }
          if (Jt && !ft) {
            var fo = d.constructor,
              Ea = h.constructor
            fo != Ea &&
              "constructor" in d &&
              "constructor" in h &&
              !(
                typeof fo == "function" &&
                fo instanceof fo &&
                typeof Ea == "function" &&
                Ea instanceof Ea
              ) &&
              (Jt = false)
          }
          return P.delete(d), P.delete(h), Jt
        }
        function Ed(d) {
          return $P(U$(d, e, K$), d + "")
        }
        function LP(d) {
          return X9(d, Zi, VP)
        }
        function UP(d) {
          return X9(d, qo, F$)
        }
        var OP = _S
          ? function (d) {
              return _S.get(d)
            }
          : sL
        function PS(d) {
          for (
            var h = d.name + "", A = AA[h], b = cn.call(AA, h) ? A.length : 0;
            b--;

          ) {
            var I = A[b],
              P = I.func
            if (P == null || P == d) return I.name
          }
          return h
        }
        function bA(d) {
          var h = cn.call(F, "placeholder") ? F : d
          return h.placeholder
        }
        function ut() {
          var d = F.iteratee || nL
          return (
            (d = d === nL ? r$ : d),
            arguments.length ? d(arguments[0], arguments[1]) : d
          )
        }
        function LS(d, h) {
          var A = d.__data__
          return nDe(h) ? A[typeof h == "string" ? "string" : "hash"] : A.map
        }
        function qP(d) {
          for (var h = Zi(d), A = h.length; A--; ) {
            var b = h[A],
              I = d[b]
            h[A] = [b, I, P$(I)]
          }
          return h
        }
        function Pg(d, h) {
          var A = oBe(d, h)
          return t$(A) ? A : e
        }
        function JRe(d) {
          var h = cn.call(d, kg),
            A = d[kg]
          try {
            d[kg] = e
            var b = true
          } catch {}
          var I = pS.call(d)
          return b && (h ? (d[kg] = A) : delete d[kg]), I
        }
        var VP = pP
            ? function (d) {
                return d == null
                  ? []
                  : ((d = vn(d)),
                    cl(pP(d), function (h) {
                      return O9.call(d, h)
                    }))
              }
            : oL,
          F$ = pP
            ? function (d) {
                for (var h = []; d; ) ao(h, VP(d)), (d = yS(d))
                return h
              }
            : oL,
          qs = co
        ;((mP && qs(new mP(new ArrayBuffer(1))) != pa) ||
          (OC && qs(new OC()) != Ee) ||
          (AP && qs(AP.resolve()) != _t) ||
          (mA && qs(new mA()) != Ii) ||
          (qC && qs(new qC()) != ar)) &&
          (qs = function (d) {
            var h = co(d),
              A = h == be ? d.constructor : e,
              b = A ? Lg(A) : ""
            if (b)
              switch (b) {
                case kBe:
                  return pa
                case MBe:
                  return Ee
                case FBe:
                  return _t
                case QBe:
                  return Ii
                case NBe:
                  return ar
              }
            return h
          })
        function jRe(d, h, A) {
          for (var b = -1, I = A.length; ++b < I; ) {
            var P = A[b],
              O = P.size
            switch (P.type) {
              case "drop":
                d += O
                break
              case "dropRight":
                h -= O
                break
              case "take":
                h = Os(h, d + O)
                break
              case "takeRight":
                d = qi(d, h - O)
                break
            }
          }
          return { start: d, end: h }
        }
        function ZRe(d) {
          var h = d.match(je)
          return h ? h[1].split(er) : []
        }
        function Q$(d, h, A) {
          h = qf(h, d)
          for (var b = -1, I = h.length, P = false; ++b < I; ) {
            var O = uu(h[b])
            if (!(P = d != null && A(d, O))) break
            d = d[O]
          }
          return P || ++b != I
            ? P
            : ((I = d == null ? 0 : d.length),
              !!I && GS(I) && _d(O, I) && (Ft(d) || Ug(d)))
        }
        function XRe(d) {
          var h = d.length,
            A = new d.constructor(h)
          return (
            h &&
              typeof d[0] == "string" &&
              cn.call(d, "index") &&
              ((A.index = d.index), (A.input = d.input)),
            A
          )
        }
        function N$(d) {
          return typeof d.constructor == "function" && !JC(d) ? yA(yS(d)) : {}
        }
        function eDe(d, h, A) {
          var b = d.constructor
          switch (h) {
            case ji:
              return QP(d)
            case or:
            case Wr:
              return new b(+d)
            case pa:
              return PRe(d, A)
            case ud:
            case dd:
            case vC:
            case ma:
            case CC:
            case bC:
            case _r:
            case It:
            case Dn:
              return y$(d, A)
            case Ee:
              return new b()
            case Or:
            case so:
              return new b(d)
            case Rn:
              return LRe(d)
            case Ii:
              return new b()
            case cd:
              return URe(d)
          }
        }
        function tDe(d, h) {
          var A = h.length
          if (!A) return d
          var b = A - 1
          return (
            (h[b] = (A > 1 ? "& " : "") + h[b]),
            (h = h.join(A > 2 ? ", " : " ")),
            d.replace(
              fd,
              `{
/* [wrapped with ` +
                h +
                `] */
`,
            )
          )
        }
        function rDe(d) {
          return Ft(d) || Ug(d) || !!(q9 && d && d[q9])
        }
        function _d(d, h) {
          var A = typeof d
          return (
            (h = h ?? J),
            !!h &&
              (A == "number" || (A != "symbol" && j2.test(d))) &&
              d > -1 &&
              d % 1 == 0 &&
              d < h
          )
        }
        function uo(d, h, A) {
          if (!$n(A)) return false
          var b = typeof h
          return (
            b == "number" ? Oo(A) && _d(h, A.length) : b == "string" && h in A
          )
            ? uc(A[h], d)
            : false
        }
        function HP(d, h) {
          if (Ft(d)) return false
          var A = typeof d
          return A == "number" ||
            A == "symbol" ||
            A == "boolean" ||
            d == null ||
            Ca(d)
            ? true
            : $2.test(d) || !rA.test(d) || (h != null && d in vn(h))
        }
        function nDe(d) {
          var h = typeof d
          return h == "string" ||
            h == "number" ||
            h == "symbol" ||
            h == "boolean"
            ? d !== "__proto__"
            : d === null
        }
        function WP(d) {
          var h = PS(d),
            A = F[h]
          if (typeof A != "function" || !(h in mr.prototype)) return false
          if (d === A) return true
          var b = OP(A)
          return !!b && d === b[0]
        }
        function iDe(d) {
          return !!P9 && P9 in d
        }
        var sDe = hS ? xd : aL
        function JC(d) {
          var h = d && d.constructor,
            A = (typeof h == "function" && h.prototype) || pA
          return d === A
        }
        function P$(d) {
          return d === d && !$n(d)
        }
        function L$(d, h) {
          return function (A) {
            return A == null ? false : A[d] === h && (h !== e || d in vn(A))
          }
        }
        function oDe(d) {
          var h = HS(d, function (b) {
              return A.size === a && A.clear(), b
            }),
            A = h.cache
          return h
        }
        function aDe(d, h) {
          var A = d[1],
            b = h[1],
            I = A | b,
            P = I < (m | y | T),
            O =
              (b == T && A == C) ||
              (b == T && A == N && d[7].length <= h[8]) ||
              (b == (T | N) && h[7].length <= h[8] && A == C)
          if (!(P || O)) return d
          b & m && ((d[2] = h[2]), (I |= A & m ? 0 : v))
          var H = h[3]
          if (H) {
            var j = d[3]
            ;(d[3] = j ? C$(j, H, h[4]) : H), (d[4] = j ? Nf(d[3], l) : h[4])
          }
          return (
            (H = h[5]),
            H &&
              ((j = d[5]),
              (d[5] = j ? b$(j, H, h[6]) : H),
              (d[6] = j ? Nf(d[5], l) : h[6])),
            (H = h[7]),
            H && (d[7] = H),
            b & T && (d[8] = d[8] == null ? h[8] : Os(d[8], h[8])),
            d[9] == null && (d[9] = h[9]),
            (d[0] = h[0]),
            (d[1] = I),
            d
          )
        }
        function lDe(d) {
          var h = []
          if (d != null) for (var A in vn(d)) h.push(A)
          return h
        }
        function cDe(d) {
          return pS.call(d)
        }
        function U$(d, h, A) {
          return (
            (h = qi(h === e ? d.length - 1 : h, 0)),
            function () {
              for (
                var b = arguments, I = -1, P = qi(b.length - h, 0), O = ne(P);
                ++I < P;

              )
                O[I] = b[h + I]
              I = -1
              for (var H = ne(h + 1); ++I < h; ) H[I] = b[I]
              return (H[h] = A(O)), vs(d, this, H)
            }
          )
        }
        function O$(d, h) {
          return h.length < 2 ? d : Ng(d, hl(h, 0, -1))
        }
        function uDe(d, h) {
          for (var A = d.length, b = Os(h.length, A), I = Uo(d); b--; ) {
            var P = h[b]
            d[b] = _d(P, A) ? I[P] : e
          }
          return d
        }
        function GP(d, h) {
          if (
            !(h === "constructor" && typeof d[h] == "function") &&
            h != "__proto__"
          )
            return d[h]
        }
        var q$ = H$(u$),
          jC =
            wBe ||
            function (d, h) {
              return Bi.setTimeout(d, h)
            },
          $P = H$(MRe)
        function V$(d, h, A) {
          var b = h + ""
          return $P(d, tDe(b, dDe(ZRe(b), A)))
        }
        function H$(d) {
          var h = 0,
            A = 0
          return function () {
            var b = RBe(),
              I = U - (b - A)
            if (((A = b), I > 0)) {
              if (++h >= Y) return arguments[0]
            } else h = 0
            return d.apply(e, arguments)
          }
        }
        function US(d, h) {
          var A = -1,
            b = d.length,
            I = b - 1
          for (h = h === e ? b : h; ++A < h; ) {
            var P = BP(A, I),
              O = d[P]
            ;(d[P] = d[A]), (d[A] = O)
          }
          return (d.length = h), d
        }
        var W$ = oDe(function (d) {
          var h = []
          return (
            d.charCodeAt(0) === 46 && h.push(""),
            d.replace(_C, function (A, b, I, P) {
              h.push(I ? P.replace(su, "$1") : b || A)
            }),
            h
          )
        })
        function uu(d) {
          if (typeof d == "string" || Ca(d)) return d
          var h = d + ""
          return h == "0" && 1 / d == -se ? "-0" : h
        }
        function Lg(d) {
          if (d != null) {
            try {
              return gS.call(d)
            } catch {}
            try {
              return d + ""
            } catch {}
          }
          return ""
        }
        function dDe(d, h) {
          return (
            Cs(Xt, function (A) {
              var b = "_." + A[0]
              h & A[1] && !md(d, b) && d.push(b)
            }),
            d.sort()
          )
        }
        function G$(d) {
          if (d instanceof mr) return d.clone()
          var h = new dl(d.__wrapped__, d.__chain__)
          return (
            (h.__actions__ = Uo(d.__actions__)),
            (h.__index__ = d.__index__),
            (h.__values__ = d.__values__),
            h
          )
        }
        function fDe(d, h, A) {
          ;(A ? uo(d, h, A) : h === e) ? (h = 1) : (h = qi(Yt(h), 0))
          var b = d == null ? 0 : d.length
          if (!b || h < 1) return []
          for (var I = 0, P = 0, O = ne(bS(b / h)); I < b; )
            O[P++] = hl(d, I, (I += h))
          return O
        }
        function hDe(d) {
          for (
            var h = -1, A = d == null ? 0 : d.length, b = 0, I = [];
            ++h < A;

          ) {
            var P = d[h]
            P && (I[b++] = P)
          }
          return I
        }
        function gDe() {
          var d = arguments.length
          if (!d) return []
          for (var h = ne(d - 1), A = arguments[0], b = d; b--; )
            h[b - 1] = arguments[b]
          return ao(Ft(A) ? Uo(A) : [A], bs(h, 1))
        }
        var pDe = tr(function (d, h) {
            return vi(d) ? GC(d, bs(h, 1, vi, true)) : []
          }),
          mDe = tr(function (d, h) {
            var A = gl(h)
            return (
              vi(A) && (A = e), vi(d) ? GC(d, bs(h, 1, vi, true), ut(A, 2)) : []
            )
          }),
          ADe = tr(function (d, h) {
            var A = gl(h)
            return vi(A) && (A = e), vi(d) ? GC(d, bs(h, 1, vi, true), e, A) : []
          })
        function yDe(d, h, A) {
          var b = d == null ? 0 : d.length
          return b
            ? ((h = A || h === e ? 1 : Yt(h)), hl(d, h < 0 ? 0 : h, b))
            : []
        }
        function vDe(d, h, A) {
          var b = d == null ? 0 : d.length
          return b
            ? ((h = A || h === e ? 1 : Yt(h)),
              (h = b - h),
              hl(d, 0, h < 0 ? 0 : h))
            : []
        }
        function CDe(d, h) {
          return d && d.length ? TS(d, ut(h, 3), true, true) : []
        }
        function bDe(d, h) {
          return d && d.length ? TS(d, ut(h, 3), true) : []
        }
        function EDe(d, h, A, b) {
          var I = d == null ? 0 : d.length
          return I
            ? (A && typeof A != "number" && uo(d, h, A) && ((A = 0), (b = I)),
              gRe(d, h, A, b))
            : []
        }
        function $$(d, h, A) {
          var b = d == null ? 0 : d.length
          if (!b) return -1
          var I = A == null ? 0 : Yt(A)
          return I < 0 && (I = qi(b + I, 0)), fA(d, ut(h, 3), I)
        }
        function Y$(d, h, A) {
          var b = d == null ? 0 : d.length
          if (!b) return -1
          var I = b - 1
          return (
            A !== e && ((I = Yt(A)), (I = A < 0 ? qi(b + I, 0) : Os(I, b - 1))),
            fA(d, ut(h, 3), I, true)
          )
        }
        function K$(d) {
          var h = d == null ? 0 : d.length
          return h ? bs(d, 1) : []
        }
        function _De(d) {
          var h = d == null ? 0 : d.length
          return h ? bs(d, se) : []
        }
        function xDe(d, h) {
          var A = d == null ? 0 : d.length
          return A ? ((h = h === e ? 1 : Yt(h)), bs(d, h)) : []
        }
        function wDe(d) {
          for (var h = -1, A = d == null ? 0 : d.length, b = {}; ++h < A; ) {
            var I = d[h]
            b[I[0]] = I[1]
          }
          return b
        }
        function z$(d) {
          return d && d.length ? d[0] : e
        }
        function SDe(d, h, A) {
          var b = d == null ? 0 : d.length
          if (!b) return -1
          var I = A == null ? 0 : Yt(A)
          return I < 0 && (I = qi(b + I, 0)), Ad(d, h, I)
        }
        function IDe(d) {
          var h = d == null ? 0 : d.length
          return h ? hl(d, 0, -1) : []
        }
        var BDe = tr(function (d) {
            var h = Zr(d, MP)
            return h.length && h[0] === d[0] ? _P(h) : []
          }),
          RDe = tr(function (d) {
            var h = gl(d),
              A = Zr(d, MP)
            return (
              h === gl(A) ? (h = e) : A.pop(),
              A.length && A[0] === d[0] ? _P(A, ut(h, 2)) : []
            )
          }),
          DDe = tr(function (d) {
            var h = gl(d),
              A = Zr(d, MP)
            return (
              (h = typeof h == "function" ? h : e),
              h && A.pop(),
              A.length && A[0] === d[0] ? _P(A, e, h) : []
            )
          })
        function TDe(d, h) {
          return d == null ? "" : IBe.call(d, h)
        }
        function gl(d) {
          var h = d == null ? 0 : d.length
          return h ? d[h - 1] : e
        }
        function kDe(d, h, A) {
          var b = d == null ? 0 : d.length
          if (!b) return -1
          var I = b
          return (
            A !== e && ((I = Yt(A)), (I = I < 0 ? qi(b + I, 0) : Os(I, b - 1))),
            h === h ? dBe(d, h, I) : fA(d, S, I, true)
          )
        }
        function MDe(d, h) {
          return d && d.length ? o$(d, Yt(h)) : e
        }
        var FDe = tr(J$)
        function J$(d, h) {
          return d && d.length && h && h.length ? IP(d, h) : d
        }
        function QDe(d, h, A) {
          return d && d.length && h && h.length ? IP(d, h, ut(A, 2)) : d
        }
        function NDe(d, h, A) {
          return d && d.length && h && h.length ? IP(d, h, e, A) : d
        }
        var PDe = Ed(function (d, h) {
          var A = d == null ? 0 : d.length,
            b = vP(d, h)
          return (
            c$(
              d,
              Zr(h, function (I) {
                return _d(I, A) ? +I : I
              }).sort(v$),
            ),
            b
          )
        })
        function LDe(d, h) {
          var A = []
          if (!(d && d.length)) return A
          var b = -1,
            I = [],
            P = d.length
          for (h = ut(h, 3); ++b < P; ) {
            var O = d[b]
            h(O, b, d) && (A.push(O), I.push(b))
          }
          return c$(d, I), A
        }
        function YP(d) {
          return d == null ? d : TBe.call(d)
        }
        function UDe(d, h, A) {
          var b = d == null ? 0 : d.length
          return b
            ? (A && typeof A != "number" && uo(d, h, A)
                ? ((h = 0), (A = b))
                : ((h = h == null ? 0 : Yt(h)), (A = A === e ? b : Yt(A))),
              hl(d, h, A))
            : []
        }
        function ODe(d, h) {
          return DS(d, h)
        }
        function qDe(d, h, A) {
          return DP(d, h, ut(A, 2))
        }
        function VDe(d, h) {
          var A = d == null ? 0 : d.length
          if (A) {
            var b = DS(d, h)
            if (b < A && uc(d[b], h)) return b
          }
          return -1
        }
        function HDe(d, h) {
          return DS(d, h, true)
        }
        function WDe(d, h, A) {
          return DP(d, h, ut(A, 2), true)
        }
        function GDe(d, h) {
          var A = d == null ? 0 : d.length
          if (A) {
            var b = DS(d, h, true) - 1
            if (uc(d[b], h)) return b
          }
          return -1
        }
        function $De(d) {
          return d && d.length ? d$(d) : []
        }
        function YDe(d, h) {
          return d && d.length ? d$(d, ut(h, 2)) : []
        }
        function KDe(d) {
          var h = d == null ? 0 : d.length
          return h ? hl(d, 1, h) : []
        }
        function zDe(d, h, A) {
          return d && d.length
            ? ((h = A || h === e ? 1 : Yt(h)), hl(d, 0, h < 0 ? 0 : h))
            : []
        }
        function JDe(d, h, A) {
          var b = d == null ? 0 : d.length
          return b
            ? ((h = A || h === e ? 1 : Yt(h)),
              (h = b - h),
              hl(d, h < 0 ? 0 : h, b))
            : []
        }
        function jDe(d, h) {
          return d && d.length ? TS(d, ut(h, 3), false, true) : []
        }
        function ZDe(d, h) {
          return d && d.length ? TS(d, ut(h, 3)) : []
        }
        var XDe = tr(function (d) {
            return Of(bs(d, 1, vi, true))
          }),
          eTe = tr(function (d) {
            var h = gl(d)
            return vi(h) && (h = e), Of(bs(d, 1, vi, true), ut(h, 2))
          }),
          tTe = tr(function (d) {
            var h = gl(d)
            return (
              (h = typeof h == "function" ? h : e), Of(bs(d, 1, vi, true), e, h)
            )
          })
        function rTe(d) {
          return d && d.length ? Of(d) : []
        }
        function nTe(d, h) {
          return d && d.length ? Of(d, ut(h, 2)) : []
        }
        function iTe(d, h) {
          return (
            (h = typeof h == "function" ? h : e),
            d && d.length ? Of(d, e, h) : []
          )
        }
        function KP(d) {
          if (!(d && d.length)) return []
          var h = 0
          return (
            (d = cl(d, function (A) {
              if (vi(A)) return (h = qi(A.length, h)), true
            })),
            yn(h, function (A) {
              return Zr(d, re(A))
            })
          )
        }
        function j$(d, h) {
          if (!(d && d.length)) return []
          var A = KP(d)
          return h == null
            ? A
            : Zr(A, function (b) {
                return vs(h, e, b)
              })
        }
        var sTe = tr(function (d, h) {
            return vi(d) ? GC(d, h) : []
          }),
          oTe = tr(function (d) {
            return kP(cl(d, vi))
          }),
          aTe = tr(function (d) {
            var h = gl(d)
            return vi(h) && (h = e), kP(cl(d, vi), ut(h, 2))
          }),
          lTe = tr(function (d) {
            var h = gl(d)
            return (h = typeof h == "function" ? h : e), kP(cl(d, vi), e, h)
          }),
          cTe = tr(KP)
        function uTe(d, h) {
          return p$(d || [], h || [], WC)
        }
        function dTe(d, h) {
          return p$(d || [], h || [], KC)
        }
        var fTe = tr(function (d) {
          var h = d.length,
            A = h > 1 ? d[h - 1] : e
          return (A = typeof A == "function" ? (d.pop(), A) : e), j$(d, A)
        })
        function Z$(d) {
          var h = F(d)
          return (h.__chain__ = true), h
        }
        function hTe(d, h) {
          return h(d), d
        }
        function OS(d, h) {
          return h(d)
        }
        var gTe = Ed(function (d) {
          var h = d.length,
            A = h ? d[0] : 0,
            b = this.__wrapped__,
            I = function (P) {
              return vP(P, d)
            }
          return h > 1 ||
            this.__actions__.length ||
            !(b instanceof mr) ||
            !_d(A)
            ? this.thru(I)
            : ((b = b.slice(A, +A + (h ? 1 : 0))),
              b.__actions__.push({ func: OS, args: [I], thisArg: e }),
              new dl(b, this.__chain__).thru(function (P) {
                return h && !P.length && P.push(e), P
              }))
        })
        function pTe() {
          return Z$(this)
        }
        function mTe() {
          return new dl(this.value(), this.__chain__)
        }
        function ATe() {
          this.__values__ === e && (this.__values__ = fY(this.value()))
          var d = this.__index__ >= this.__values__.length,
            h = d ? e : this.__values__[this.__index__++]
          return { done: d, value: h }
        }
        function yTe() {
          return this
        }
        function vTe(d) {
          for (var h, A = this; A instanceof wS; ) {
            var b = G$(A)
            ;(b.__index__ = 0),
              (b.__values__ = e),
              h ? (I.__wrapped__ = b) : (h = b)
            var I = b
            A = A.__wrapped__
          }
          return (I.__wrapped__ = d), h
        }
        function CTe() {
          var d = this.__wrapped__
          if (d instanceof mr) {
            var h = d
            return (
              this.__actions__.length && (h = new mr(this)),
              (h = h.reverse()),
              h.__actions__.push({ func: OS, args: [YP], thisArg: e }),
              new dl(h, this.__chain__)
            )
          }
          return this.thru(YP)
        }
        function bTe() {
          return g$(this.__wrapped__, this.__actions__)
        }
        var ETe = kS(function (d, h, A) {
          cn.call(d, A) ? ++d[A] : Cd(d, A, 1)
        })
        function _Te(d, h, A) {
          var b = Ft(d) ? aS : hRe
          return A && uo(d, h, A) && (h = e), b(d, ut(h, 3))
        }
        function xTe(d, h) {
          var A = Ft(d) ? cl : j9
          return A(d, ut(h, 3))
        }
        var wTe = w$($$),
          STe = w$(Y$)
        function ITe(d, h) {
          return bs(qS(d, h), 1)
        }
        function BTe(d, h) {
          return bs(qS(d, h), se)
        }
        function RTe(d, h, A) {
          return (A = A === e ? 1 : Yt(A)), bs(qS(d, h), A)
        }
        function X$(d, h) {
          var A = Ft(d) ? Cs : Uf
          return A(d, ut(h, 3))
        }
        function eY(d, h) {
          var A = Ft(d) ? Po : J9
          return A(d, ut(h, 3))
        }
        var DTe = kS(function (d, h, A) {
          cn.call(d, A) ? d[A].push(h) : Cd(d, A, [h])
        })
        function TTe(d, h, A, b) {
          ;(d = Oo(d) ? d : _A(d)), (A = A && !b ? Yt(A) : 0)
          var I = d.length
          return (
            A < 0 && (A = qi(I + A, 0)),
            $S(d) ? A <= I && d.indexOf(h, A) > -1 : !!I && Ad(d, h, A) > -1
          )
        }
        var kTe = tr(function (d, h, A) {
            var b = -1,
              I = typeof h == "function",
              P = Oo(d) ? ne(d.length) : []
            return (
              Uf(d, function (O) {
                P[++b] = I ? vs(h, O, A) : $C(O, h, A)
              }),
              P
            )
          }),
          MTe = kS(function (d, h, A) {
            Cd(d, A, h)
          })
        function qS(d, h) {
          var A = Ft(d) ? Zr : n$
          return A(d, ut(h, 3))
        }
        function FTe(d, h, A, b) {
          return d == null
            ? []
            : (Ft(h) || (h = h == null ? [] : [h]),
              (A = b ? e : A),
              Ft(A) || (A = A == null ? [] : [A]),
              a$(d, h, A))
        }
        var QTe = kS(
          function (d, h, A) {
            d[A ? 0 : 1].push(h)
          },
          function () {
            return [[], []]
          },
        )
        function NTe(d, h, A) {
          var b = Ft(d) ? ya : Re,
            I = arguments.length < 3
          return b(d, ut(h, 4), A, I, Uf)
        }
        function PTe(d, h, A) {
          var b = Ft(d) ? dA : Re,
            I = arguments.length < 3
          return b(d, ut(h, 4), A, I, J9)
        }
        function LTe(d, h) {
          var A = Ft(d) ? cl : j9
          return A(d, WS(ut(h, 3)))
        }
        function UTe(d) {
          var h = Ft(d) ? $9 : TRe
          return h(d)
        }
        function OTe(d, h, A) {
          ;(A ? uo(d, h, A) : h === e) ? (h = 1) : (h = Yt(h))
          var b = Ft(d) ? lRe : kRe
          return b(d, h)
        }
        function qTe(d) {
          var h = Ft(d) ? cRe : FRe
          return h(d)
        }
        function VTe(d) {
          if (d == null) return 0
          if (Oo(d)) return $S(d) ? gA(d) : d.length
          var h = qs(d)
          return h == Ee || h == Ii ? d.size : wP(d).length
        }
        function HTe(d, h, A) {
          var b = Ft(d) ? Tg : QRe
          return A && uo(d, h, A) && (h = e), b(d, ut(h, 3))
        }
        var WTe = tr(function (d, h) {
            if (d == null) return []
            var A = h.length
            return (
              A > 1 && uo(d, h[0], h[1])
                ? (h = [])
                : A > 2 && uo(h[0], h[1], h[2]) && (h = [h[0]]),
              a$(d, bs(h, 1), [])
            )
          }),
          VS =
            xBe ||
            function () {
              return Bi.Date.now()
            }
        function GTe(d, h) {
          if (typeof h != "function") throw new ul(i)
          return (
            (d = Yt(d)),
            function () {
              if (--d < 1) return h.apply(this, arguments)
            }
          )
        }
        function tY(d, h, A) {
          return (
            (h = A ? e : h),
            (h = d && h == null ? d.length : h),
            bd(d, T, e, e, e, e, h)
          )
        }
        function rY(d, h) {
          var A
          if (typeof h != "function") throw new ul(i)
          return (
            (d = Yt(d)),
            function () {
              return (
                --d > 0 && (A = h.apply(this, arguments)), d <= 1 && (h = e), A
              )
            }
          )
        }
        var zP = tr(function (d, h, A) {
            var b = m
            if (A.length) {
              var I = Nf(A, bA(zP))
              b |= w
            }
            return bd(d, b, h, A, I)
          }),
          nY = tr(function (d, h, A) {
            var b = m | y
            if (A.length) {
              var I = Nf(A, bA(nY))
              b |= w
            }
            return bd(h, b, d, A, I)
          })
        function iY(d, h, A) {
          h = A ? e : h
          var b = bd(d, C, e, e, e, e, e, h)
          return (b.placeholder = iY.placeholder), b
        }
        function sY(d, h, A) {
          h = A ? e : h
          var b = bd(d, E, e, e, e, e, e, h)
          return (b.placeholder = sY.placeholder), b
        }
        function oY(d, h, A) {
          var b,
            I,
            P,
            O,
            H,
            j,
            de = 0,
            fe = false,
            Ae = false,
            Te = true
          if (typeof d != "function") throw new ul(i)
          ;(h = pl(h) || 0),
            $n(A) &&
              ((fe = !!A.leading),
              (Ae = "maxWait" in A),
              (P = Ae ? qi(pl(A.maxWait) || 0, h) : P),
              (Te = "trailing" in A ? !!A.trailing : Te))
          function ze(Ci) {
            var dc = b,
              Sd = I
            return (b = I = e), (de = Ci), (O = d.apply(Sd, dc)), O
          }
          function dt(Ci) {
            return (de = Ci), (H = jC(lr, h)), fe ? ze(Ci) : O
          }
          function Jt(Ci) {
            var dc = Ci - j,
              Sd = Ci - de,
              wY = h - dc
            return Ae ? Os(wY, P - Sd) : wY
          }
          function ft(Ci) {
            var dc = Ci - j,
              Sd = Ci - de
            return j === e || dc >= h || dc < 0 || (Ae && Sd >= P)
          }
          function lr() {
            var Ci = VS()
            if (ft(Ci)) return xr(Ci)
            H = jC(lr, Jt(Ci))
          }
          function xr(Ci) {
            return (H = e), Te && b ? ze(Ci) : ((b = I = e), O)
          }
          function ba() {
            H !== e && m$(H), (de = 0), (b = j = I = H = e)
          }
          function fo() {
            return H === e ? O : xr(VS())
          }
          function Ea() {
            var Ci = VS(),
              dc = ft(Ci)
            if (((b = arguments), (I = this), (j = Ci), dc)) {
              if (H === e) return dt(j)
              if (Ae) return m$(H), (H = jC(lr, h)), ze(j)
            }
            return H === e && (H = jC(lr, h)), O
          }
          return (Ea.cancel = ba), (Ea.flush = fo), Ea
        }
        var $Te = tr(function (d, h) {
            return z9(d, 1, h)
          }),
          YTe = tr(function (d, h, A) {
            return z9(d, pl(h) || 0, A)
          })
        function KTe(d) {
          return bd(d, W)
        }
        function HS(d, h) {
          if (typeof d != "function" || (h != null && typeof h != "function"))
            throw new ul(i)
          var A = function () {
            var b = arguments,
              I = h ? h.apply(this, b) : b[0],
              P = A.cache
            if (P.has(I)) return P.get(I)
            var O = d.apply(this, b)
            return (A.cache = P.set(I, O) || P), O
          }
          return (A.cache = new (HS.Cache || vd)()), A
        }
        HS.Cache = vd
        function WS(d) {
          if (typeof d != "function") throw new ul(i)
          return function () {
            var h = arguments
            switch (h.length) {
              case 0:
                return !d.call(this)
              case 1:
                return !d.call(this, h[0])
              case 2:
                return !d.call(this, h[0], h[1])
              case 3:
                return !d.call(this, h[0], h[1], h[2])
            }
            return !d.apply(this, h)
          }
        }
        function zTe(d) {
          return rY(2, d)
        }
        var JTe = NRe(function (d, h) {
            h =
              h.length == 1 && Ft(h[0])
                ? Zr(h[0], kn(ut()))
                : Zr(bs(h, 1), kn(ut()))
            var A = h.length
            return tr(function (b) {
              for (var I = -1, P = Os(b.length, A); ++I < P; )
                b[I] = h[I].call(this, b[I])
              return vs(d, this, b)
            })
          }),
          JP = tr(function (d, h) {
            var A = Nf(h, bA(JP))
            return bd(d, w, e, h, A)
          }),
          aY = tr(function (d, h) {
            var A = Nf(h, bA(aY))
            return bd(d, B, e, h, A)
          }),
          jTe = Ed(function (d, h) {
            return bd(d, N, e, e, e, h)
          })
        function ZTe(d, h) {
          if (typeof d != "function") throw new ul(i)
          return (h = h === e ? h : Yt(h)), tr(d, h)
        }
        function XTe(d, h) {
          if (typeof d != "function") throw new ul(i)
          return (
            (h = h == null ? 0 : qi(Yt(h), 0)),
            tr(function (A) {
              var b = A[h],
                I = Vf(A, 0, h)
              return b && ao(I, b), vs(d, this, I)
            })
          )
        }
        function eke(d, h, A) {
          var b = true,
            I = true
          if (typeof d != "function") throw new ul(i)
          return (
            $n(A) &&
              ((b = "leading" in A ? !!A.leading : b),
              (I = "trailing" in A ? !!A.trailing : I)),
            oY(d, h, { leading: b, maxWait: h, trailing: I })
          )
        }
        function tke(d) {
          return tY(d, 1)
        }
        function rke(d, h) {
          return JP(FP(h), d)
        }
        function nke() {
          if (!arguments.length) return []
          var d = arguments[0]
          return Ft(d) ? d : [d]
        }
        function ike(d) {
          return fl(d, f)
        }
        function ske(d, h) {
          return (h = typeof h == "function" ? h : e), fl(d, f, h)
        }
        function oke(d) {
          return fl(d, c | f)
        }
        function ake(d, h) {
          return (h = typeof h == "function" ? h : e), fl(d, c | f, h)
        }
        function lke(d, h) {
          return h == null || K9(d, h, Zi(h))
        }
        function uc(d, h) {
          return d === h || (d !== d && h !== h)
        }
        var cke = NS(EP),
          uke = NS(function (d, h) {
            return d >= h
          }),
          Ug = e$(
            (function () {
              return arguments
            })(),
          )
            ? e$
            : function (d) {
                return ni(d) && cn.call(d, "callee") && !O9.call(d, "callee")
              },
          Ft = ne.isArray,
          dke = au ? kn(au) : vRe
        function Oo(d) {
          return d != null && GS(d.length) && !xd(d)
        }
        function vi(d) {
          return ni(d) && Oo(d)
        }
        function fke(d) {
          return d === true || d === false || (ni(d) && co(d) == or)
        }
        var Hf = SBe || aL,
          hke = oS ? kn(oS) : CRe
        function gke(d) {
          return ni(d) && d.nodeType === 1 && !ZC(d)
        }
        function pke(d) {
          if (d == null) return true
          if (
            Oo(d) &&
            (Ft(d) ||
              typeof d == "string" ||
              typeof d.splice == "function" ||
              Hf(d) ||
              EA(d) ||
              Ug(d))
          )
            return !d.length
          var h = qs(d)
          if (h == Ee || h == Ii) return !d.size
          if (JC(d)) return !wP(d).length
          for (var A in d) if (cn.call(d, A)) return false
          return true
        }
        function mke(d, h) {
          return YC(d, h)
        }
        function Ake(d, h, A) {
          A = typeof A == "function" ? A : e
          var b = A ? A(d, h) : e
          return b === e ? YC(d, h, e, A) : !!b
        }
        function jP(d) {
          if (!ni(d)) return false
          var h = co(d)
          return (
            h == ln ||
            h == Ge ||
            (typeof d.message == "string" &&
              typeof d.name == "string" &&
              !ZC(d))
          )
        }
        function yke(d) {
          return typeof d == "number" && V9(d)
        }
        function xd(d) {
          if (!$n(d)) return false
          var h = co(d)
          return h == Gr || h == pr || h == wr || h == hn
        }
        function lY(d) {
          return typeof d == "number" && d == Yt(d)
        }
        function GS(d) {
          return typeof d == "number" && d > -1 && d % 1 == 0 && d <= J
        }
        function $n(d) {
          var h = typeof d
          return d != null && (h == "object" || h == "function")
        }
        function ni(d) {
          return d != null && typeof d == "object"
        }
        var cY = NC ? kn(NC) : ERe
        function vke(d, h) {
          return d === h || xP(d, h, qP(h))
        }
        function Cke(d, h, A) {
          return (A = typeof A == "function" ? A : e), xP(d, h, qP(h), A)
        }
        function bke(d) {
          return uY(d) && d != +d
        }
        function Eke(d) {
          if (sDe(d)) throw new Dt(n)
          return t$(d)
        }
        function _ke(d) {
          return d === null
        }
        function xke(d) {
          return d == null
        }
        function uY(d) {
          return typeof d == "number" || (ni(d) && co(d) == Or)
        }
        function ZC(d) {
          if (!ni(d) || co(d) != be) return false
          var h = yS(d)
          if (h === null) return true
          var A = cn.call(h, "constructor") && h.constructor
          return typeof A == "function" && A instanceof A && gS.call(A) == CBe
        }
        var ZP = Dg ? kn(Dg) : _Re
        function wke(d) {
          return lY(d) && d >= -J && d <= J
        }
        var dY = Tn ? kn(Tn) : xRe
        function $S(d) {
          return typeof d == "string" || (!Ft(d) && ni(d) && co(d) == so)
        }
        function Ca(d) {
          return typeof d == "symbol" || (ni(d) && co(d) == cd)
        }
        var EA = PC ? kn(PC) : wRe
        function Ske(d) {
          return d === e
        }
        function Ike(d) {
          return ni(d) && qs(d) == ar
        }
        function Bke(d) {
          return ni(d) && co(d) == G2
        }
        var Rke = NS(SP),
          Dke = NS(function (d, h) {
            return d <= h
          })
        function fY(d) {
          if (!d) return []
          if (Oo(d)) return $S(d) ? lc(d) : Uo(d)
          if (UC && d[UC]) return lBe(d[UC]())
          var h = qs(d),
            A = h == Ee ? hP : h == Ii ? dS : _A
          return A(d)
        }
        function wd(d) {
          if (!d) return d === 0 ? d : 0
          if (((d = pl(d)), d === se || d === -se)) {
            var h = d < 0 ? -1 : 1
            return h * ie
          }
          return d === d ? d : 0
        }
        function Yt(d) {
          var h = wd(d),
            A = h % 1
          return h === h ? (A ? h - A : h) : 0
        }
        function hY(d) {
          return d ? Qg(Yt(d), 0, At) : 0
        }
        function pl(d) {
          if (typeof d == "number") return d
          if (Ca(d)) return Ue
          if ($n(d)) {
            var h = typeof d.valueOf == "function" ? d.valueOf() : d
            d = $n(h) ? h + "" : h
          }
          if (typeof d != "string") return d === 0 ? d : +d
          d = lo(d)
          var A = Lw.test(d)
          return A || J2.test(d)
            ? dP(d.slice(2), A ? 2 : 8)
            : K2.test(d)
              ? Ue
              : +d
        }
        function gY(d) {
          return cu(d, qo(d))
        }
        function Tke(d) {
          return d ? Qg(Yt(d), -J, J) : d === 0 ? d : 0
        }
        function Xr(d) {
          return d == null ? "" : va(d)
        }
        var kke = vA(function (d, h) {
            if (JC(h) || Oo(h)) {
              cu(h, Zi(h), d)
              return
            }
            for (var A in h) cn.call(h, A) && WC(d, A, h[A])
          }),
          pY = vA(function (d, h) {
            cu(h, qo(h), d)
          }),
          YS = vA(function (d, h, A, b) {
            cu(h, qo(h), d, b)
          }),
          Mke = vA(function (d, h, A, b) {
            cu(h, Zi(h), d, b)
          }),
          Fke = Ed(vP)
        function Qke(d, h) {
          var A = yA(d)
          return h == null ? A : Y9(A, h)
        }
        var Nke = tr(function (d, h) {
            d = vn(d)
            var A = -1,
              b = h.length,
              I = b > 2 ? h[2] : e
            for (I && uo(h[0], h[1], I) && (b = 1); ++A < b; )
              for (var P = h[A], O = qo(P), H = -1, j = O.length; ++H < j; ) {
                var de = O[H],
                  fe = d[de]
                ;(fe === e || (uc(fe, pA[de]) && !cn.call(d, de))) &&
                  (d[de] = P[de])
              }
            return d
          }),
          Pke = tr(function (d) {
            return d.push(e, k$), vs(mY, e, d)
          })
        function Lke(d, h) {
          return cS(d, ut(h, 3), lu)
        }
        function Uke(d, h) {
          return cS(d, ut(h, 3), bP)
        }
        function Oke(d, h) {
          return d == null ? d : CP(d, ut(h, 3), qo)
        }
        function qke(d, h) {
          return d == null ? d : Z9(d, ut(h, 3), qo)
        }
        function Vke(d, h) {
          return d && lu(d, ut(h, 3))
        }
        function Hke(d, h) {
          return d && bP(d, ut(h, 3))
        }
        function Wke(d) {
          return d == null ? [] : BS(d, Zi(d))
        }
        function Gke(d) {
          return d == null ? [] : BS(d, qo(d))
        }
        function XP(d, h, A) {
          var b = d == null ? e : Ng(d, h)
          return b === e ? A : b
        }
        function $ke(d, h) {
          return d != null && Q$(d, h, pRe)
        }
        function eL(d, h) {
          return d != null && Q$(d, h, mRe)
        }
        var Yke = I$(function (d, h, A) {
            h != null && typeof h.toString != "function" && (h = pS.call(h)),
              (d[h] = A)
          }, rL(Vo)),
          Kke = I$(function (d, h, A) {
            h != null && typeof h.toString != "function" && (h = pS.call(h)),
              cn.call(d, h) ? d[h].push(A) : (d[h] = [A])
          }, ut),
          zke = tr($C)
        function Zi(d) {
          return Oo(d) ? G9(d) : wP(d)
        }
        function qo(d) {
          return Oo(d) ? G9(d, true) : SRe(d)
        }
        function Jke(d, h) {
          var A = {}
          return (
            (h = ut(h, 3)),
            lu(d, function (b, I, P) {
              Cd(A, h(b, I, P), b)
            }),
            A
          )
        }
        function jke(d, h) {
          var A = {}
          return (
            (h = ut(h, 3)),
            lu(d, function (b, I, P) {
              Cd(A, I, h(b, I, P))
            }),
            A
          )
        }
        var Zke = vA(function (d, h, A) {
            RS(d, h, A)
          }),
          mY = vA(function (d, h, A, b) {
            RS(d, h, A, b)
          }),
          Xke = Ed(function (d, h) {
            var A = {}
            if (d == null) return A
            var b = false
            ;(h = Zr(h, function (P) {
              return (P = qf(P, d)), b || (b = P.length > 1), P
            })),
              cu(d, UP(d), A),
              b && (A = fl(A, c | u | f, YRe))
            for (var I = h.length; I--; ) TP(A, h[I])
            return A
          })
        function eMe(d, h) {
          return AY(d, WS(ut(h)))
        }
        var tMe = Ed(function (d, h) {
          return d == null ? {} : BRe(d, h)
        })
        function AY(d, h) {
          if (d == null) return {}
          var A = Zr(UP(d), function (b) {
            return [b]
          })
          return (
            (h = ut(h)),
            l$(d, A, function (b, I) {
              return h(b, I[0])
            })
          )
        }
        function rMe(d, h, A) {
          h = qf(h, d)
          var b = -1,
            I = h.length
          for (I || ((I = 1), (d = e)); ++b < I; ) {
            var P = d == null ? e : d[uu(h[b])]
            P === e && ((b = I), (P = A)), (d = xd(P) ? P.call(d) : P)
          }
          return d
        }
        function nMe(d, h, A) {
          return d == null ? d : KC(d, h, A)
        }
        function iMe(d, h, A, b) {
          return (
            (b = typeof b == "function" ? b : e), d == null ? d : KC(d, h, A, b)
          )
        }
        var yY = D$(Zi),
          vY = D$(qo)
        function sMe(d, h, A) {
          var b = Ft(d),
            I = b || Hf(d) || EA(d)
          if (((h = ut(h, 4)), A == null)) {
            var P = d && d.constructor
            I
              ? (A = b ? new P() : [])
              : $n(d)
                ? (A = xd(P) ? yA(yS(d)) : {})
                : (A = {})
          }
          return (
            (I ? Cs : lu)(d, function (O, H, j) {
              return h(A, O, H, j)
            }),
            A
          )
        }
        function oMe(d, h) {
          return d == null ? true : TP(d, h)
        }
        function aMe(d, h, A) {
          return d == null ? d : h$(d, h, FP(A))
        }
        function lMe(d, h, A, b) {
          return (
            (b = typeof b == "function" ? b : e),
            d == null ? d : h$(d, h, FP(A), b)
          )
        }
        function _A(d) {
          return d == null ? [] : ac(d, Zi(d))
        }
        function cMe(d) {
          return d == null ? [] : ac(d, qo(d))
        }
        function uMe(d, h, A) {
          return (
            A === e && ((A = h), (h = e)),
            A !== e && ((A = pl(A)), (A = A === A ? A : 0)),
            h !== e && ((h = pl(h)), (h = h === h ? h : 0)),
            Qg(pl(d), h, A)
          )
        }
        function dMe(d, h, A) {
          return (
            (h = wd(h)),
            A === e ? ((A = h), (h = 0)) : (A = wd(A)),
            (d = pl(d)),
            ARe(d, h, A)
          )
        }
        function fMe(d, h, A) {
          if (
            (A && typeof A != "boolean" && uo(d, h, A) && (h = A = e),
            A === e &&
              (typeof h == "boolean"
                ? ((A = h), (h = e))
                : typeof d == "boolean" && ((A = d), (d = e))),
            d === e && h === e
              ? ((d = 0), (h = 1))
              : ((d = wd(d)), h === e ? ((h = d), (d = 0)) : (h = wd(h))),
            d > h)
          ) {
            var b = d
            ;(d = h), (h = b)
          }
          if (A || d % 1 || h % 1) {
            var I = H9()
            return Os(d + I * (h - d + uP("1e-" + ((I + "").length - 1))), h)
          }
          return BP(d, h)
        }
        var hMe = CA(function (d, h, A) {
          return (h = h.toLowerCase()), d + (A ? CY(h) : h)
        })
        function CY(d) {
          return tL(Xr(d).toLowerCase())
        }
        function bY(d) {
          return (d = Xr(d)), d && d.replace(Z2, nBe).replace(aP, "")
        }
        function gMe(d, h, A) {
          ;(d = Xr(d)), (h = va(h))
          var b = d.length
          A = A === e ? b : Qg(Yt(A), 0, b)
          var I = A
          return (A -= h.length), A >= 0 && d.slice(A, I) == h
        }
        function pMe(d) {
          return (d = Xr(d)), d && EC.test(d) ? d.replace(bt, iBe) : d
        }
        function mMe(d) {
          return (d = Xr(d)), d && nA.test(d) ? d.replace(Li, "\\$&") : d
        }
        var AMe = CA(function (d, h, A) {
            return d + (A ? "-" : "") + h.toLowerCase()
          }),
          yMe = CA(function (d, h, A) {
            return d + (A ? " " : "") + h.toLowerCase()
          }),
          vMe = x$("toLowerCase")
        function CMe(d, h, A) {
          ;(d = Xr(d)), (h = Yt(h))
          var b = h ? gA(d) : 0
          if (!h || b >= h) return d
          var I = (h - b) / 2
          return QS(ES(I), A) + d + QS(bS(I), A)
        }
        function bMe(d, h, A) {
          ;(d = Xr(d)), (h = Yt(h))
          var b = h ? gA(d) : 0
          return h && b < h ? d + QS(h - b, A) : d
        }
        function EMe(d, h, A) {
          ;(d = Xr(d)), (h = Yt(h))
          var b = h ? gA(d) : 0
          return h && b < h ? QS(h - b, A) + d : d
        }
        function _Me(d, h, A) {
          return (
            A || h == null ? (h = 0) : h && (h = +h),
            DBe(Xr(d).replace(xC, ""), h || 0)
          )
        }
        function xMe(d, h, A) {
          return (
            (A ? uo(d, h, A) : h === e) ? (h = 1) : (h = Yt(h)), RP(Xr(d), h)
          )
        }
        function wMe() {
          var d = arguments,
            h = Xr(d[0])
          return d.length < 3 ? h : h.replace(d[1], d[2])
        }
        var SMe = CA(function (d, h, A) {
          return d + (A ? "_" : "") + h.toLowerCase()
        })
        function IMe(d, h, A) {
          return (
            A && typeof A != "number" && uo(d, h, A) && (h = A = e),
            (A = A === e ? At : A >>> 0),
            A
              ? ((d = Xr(d)),
                d &&
                (typeof h == "string" || (h != null && !ZP(h))) &&
                ((h = va(h)), !h && hA(d))
                  ? Vf(lc(d), 0, A)
                  : d.split(h, A))
              : []
          )
        }
        var BMe = CA(function (d, h, A) {
          return d + (A ? " " : "") + tL(h)
        })
        function RMe(d, h, A) {
          return (
            (d = Xr(d)),
            (A = A == null ? 0 : Qg(Yt(A), 0, d.length)),
            (h = va(h)),
            d.slice(A, A + h.length) == h
          )
        }
        function DMe(d, h, A) {
          var b = F.templateSettings
          A && uo(d, h, A) && (h = e), (d = Xr(d)), (h = YS({}, h, b, T$))
          var I = YS({}, h.imports, b.imports, T$),
            P = Zi(I),
            O = ac(I, P),
            H,
            j,
            de = 0,
            fe = h.interpolate || iA,
            Ae = "__p += '",
            Te = gP(
              (h.escape || iA).source +
                "|" +
                fe.source +
                "|" +
                (fe === Tf ? wC : iA).source +
                "|" +
                (h.evaluate || iA).source +
                "|$",
              "g",
            ),
            ze =
              "//# sourceURL=" +
              (cn.call(h, "sourceURL")
                ? (h.sourceURL + "").replace(/\s/g, " ")
                : "lodash.templateSources[" + ++cP + "]") +
              `
`
          d.replace(Te, function (ft, lr, xr, ba, fo, Ea) {
            return (
              xr || (xr = ba),
              (Ae += d.slice(de, Ea).replace(X2, sBe)),
              lr &&
                ((H = true),
                (Ae +=
                  `' +
__e(` +
                  lr +
                  `) +
'`)),
              fo &&
                ((j = true),
                (Ae +=
                  `';
` +
                  fo +
                  `;
__p += '`)),
              xr &&
                (Ae +=
                  `' +
((__t = (` +
                  xr +
                  `)) == null ? '' : __t) +
'`),
              (de = Ea + ft.length),
              ft
            )
          }),
            (Ae += `';
`)
          var dt = cn.call(h, "variable") && h.variable
          if (!dt)
            Ae =
              `with (obj) {
` +
              Ae +
              `
}
`
          else if (Bg.test(dt)) throw new Dt(s)
          ;(Ae = (j ? Ae.replace(ol, "") : Ae)
            .replace(al, "$1")
            .replace(Ig, "$1;")),
            (Ae =
              "function(" +
              (dt || "obj") +
              `) {
` +
              (dt
                ? ""
                : `obj || (obj = {});
`) +
              "var __t, __p = ''" +
              (H ? ", __e = _.escape" : "") +
              (j
                ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
`
                : `;
`) +
              Ae +
              `return __p
}`)
          var Jt = _Y(function () {
            return Yr(P, ze + "return " + Ae).apply(e, O)
          })
          if (((Jt.source = Ae), jP(Jt))) throw Jt
          return Jt
        }
        function TMe(d) {
          return Xr(d).toLowerCase()
        }
        function kMe(d) {
          return Xr(d).toUpperCase()
        }
        function MMe(d, h, A) {
          if (((d = Xr(d)), d && (A || h === e))) return lo(d)
          if (!d || !(h = va(h))) return d
          var b = lc(d),
            I = lc(h),
            P = Qf(b, I),
            O = uS(b, I) + 1
          return Vf(b, P, O).join("")
        }
        function FMe(d, h, A) {
          if (((d = Xr(d)), d && (A || h === e))) return d.slice(0, N9(d) + 1)
          if (!d || !(h = va(h))) return d
          var b = lc(d),
            I = uS(b, lc(h)) + 1
          return Vf(b, 0, I).join("")
        }
        function QMe(d, h, A) {
          if (((d = Xr(d)), d && (A || h === e))) return d.replace(xC, "")
          if (!d || !(h = va(h))) return d
          var b = lc(d),
            I = Qf(b, lc(h))
          return Vf(b, I).join("")
        }
        function NMe(d, h) {
          var A = Z,
            b = te
          if ($n(h)) {
            var I = "separator" in h ? h.separator : I
            ;(A = "length" in h ? Yt(h.length) : A),
              (b = "omission" in h ? va(h.omission) : b)
          }
          d = Xr(d)
          var P = d.length
          if (hA(d)) {
            var O = lc(d)
            P = O.length
          }
          if (A >= P) return d
          var H = A - gA(b)
          if (H < 1) return b
          var j = O ? Vf(O, 0, H).join("") : d.slice(0, H)
          if (I === e) return j + b
          if ((O && (H += j.length - H), ZP(I))) {
            if (d.slice(H).search(I)) {
              var de,
                fe = j
              for (
                I.global || (I = gP(I.source, Xr(Pw.exec(I)) + "g")),
                  I.lastIndex = 0;
                (de = I.exec(fe));

              )
                var Ae = de.index
              j = j.slice(0, Ae === e ? H : Ae)
            }
          } else if (d.indexOf(va(I), H) != H) {
            var Te = j.lastIndexOf(I)
            Te > -1 && (j = j.slice(0, Te))
          }
          return j + b
        }
        function PMe(d) {
          return (d = Xr(d)), d && eA.test(d) ? d.replace(ic, fBe) : d
        }
        var LMe = CA(function (d, h, A) {
            return d + (A ? " " : "") + h.toUpperCase()
          }),
          tL = x$("toUpperCase")
        function EY(d, h, A) {
          return (
            (d = Xr(d)),
            (h = A ? e : h),
            h === e ? (aBe(d) ? pBe(d) : fP(d)) : d.match(h) || []
          )
        }
        var _Y = tr(function (d, h) {
            try {
              return vs(d, e, h)
            } catch (A) {
              return jP(A) ? A : new Dt(A)
            }
          }),
          UMe = Ed(function (d, h) {
            return (
              Cs(h, function (A) {
                ;(A = uu(A)), Cd(d, A, zP(d[A], d))
              }),
              d
            )
          })
        function OMe(d) {
          var h = d == null ? 0 : d.length,
            A = ut()
          return (
            (d = h
              ? Zr(d, function (b) {
                  if (typeof b[1] != "function") throw new ul(i)
                  return [A(b[0]), b[1]]
                })
              : []),
            tr(function (b) {
              for (var I = -1; ++I < h; ) {
                var P = d[I]
                if (vs(P[0], this, b)) return vs(P[1], this, b)
              }
            })
          )
        }
        function qMe(d) {
          return fRe(fl(d, c))
        }
        function rL(d) {
          return function () {
            return d
          }
        }
        function VMe(d, h) {
          return d == null || d !== d ? h : d
        }
        var HMe = S$(),
          WMe = S$(true)
        function Vo(d) {
          return d
        }
        function nL(d) {
          return r$(typeof d == "function" ? d : fl(d, c))
        }
        function GMe(d) {
          return i$(fl(d, c))
        }
        function $Me(d, h) {
          return s$(d, fl(h, c))
        }
        var YMe = tr(function (d, h) {
            return function (A) {
              return $C(A, d, h)
            }
          }),
          KMe = tr(function (d, h) {
            return function (A) {
              return $C(d, A, h)
            }
          })
        function iL(d, h, A) {
          var b = Zi(h),
            I = BS(h, b)
          A == null &&
            !($n(h) && (I.length || !b.length)) &&
            ((A = h), (h = d), (d = this), (I = BS(h, Zi(h))))
          var P = !($n(A) && "chain" in A) || !!A.chain,
            O = xd(d)
          return (
            Cs(I, function (H) {
              var j = h[H]
              ;(d[H] = j),
                O &&
                  (d.prototype[H] = function () {
                    var de = this.__chain__
                    if (P || de) {
                      var fe = d(this.__wrapped__),
                        Ae = (fe.__actions__ = Uo(this.__actions__))
                      return (
                        Ae.push({ func: j, args: arguments, thisArg: d }),
                        (fe.__chain__ = de),
                        fe
                      )
                    }
                    return j.apply(d, ao([this.value()], arguments))
                  })
            }),
            d
          )
        }
        function zMe() {
          return Bi._ === this && (Bi._ = bBe), this
        }
        function sL() {}
        function JMe(d) {
          return (
            (d = Yt(d)),
            tr(function (h) {
              return o$(h, d)
            })
          )
        }
        var jMe = NP(Zr),
          ZMe = NP(aS),
          XMe = NP(Tg)
        function xY(d) {
          return HP(d) ? re(uu(d)) : RRe(d)
        }
        function eFe(d) {
          return function (h) {
            return d == null ? e : Ng(d, h)
          }
        }
        var tFe = B$(),
          rFe = B$(true)
        function oL() {
          return []
        }
        function aL() {
          return false
        }
        function nFe() {
          return {}
        }
        function iFe() {
          return ""
        }
        function sFe() {
          return true
        }
        function oFe(d, h) {
          if (((d = Yt(d)), d < 1 || d > J)) return []
          var A = At,
            b = Os(d, At)
          ;(h = ut(h)), (d -= At)
          for (var I = yn(b, h); ++A < d; ) h(A)
          return I
        }
        function aFe(d) {
          return Ft(d) ? Zr(d, uu) : Ca(d) ? [d] : Uo(W$(Xr(d)))
        }
        function lFe(d) {
          var h = ++vBe
          return Xr(d) + h
        }
        var cFe = FS(function (d, h) {
            return d + h
          }, 0),
          uFe = PP("ceil"),
          dFe = FS(function (d, h) {
            return d / h
          }, 1),
          fFe = PP("floor")
        function hFe(d) {
          return d && d.length ? IS(d, Vo, EP) : e
        }
        function gFe(d, h) {
          return d && d.length ? IS(d, ut(h, 2), EP) : e
        }
        function pFe(d) {
          return L(d, Vo)
        }
        function mFe(d, h) {
          return L(d, ut(h, 2))
        }
        function AFe(d) {
          return d && d.length ? IS(d, Vo, SP) : e
        }
        function yFe(d, h) {
          return d && d.length ? IS(d, ut(h, 2), SP) : e
        }
        var vFe = FS(function (d, h) {
            return d * h
          }, 1),
          CFe = PP("round"),
          bFe = FS(function (d, h) {
            return d - h
          }, 0)
        function EFe(d) {
          return d && d.length ? $t(d, Vo) : 0
        }
        function _Fe(d, h) {
          return d && d.length ? $t(d, ut(h, 2)) : 0
        }
        return (
          (F.after = GTe),
          (F.ary = tY),
          (F.assign = kke),
          (F.assignIn = pY),
          (F.assignInWith = YS),
          (F.assignWith = Mke),
          (F.at = Fke),
          (F.before = rY),
          (F.bind = zP),
          (F.bindAll = UMe),
          (F.bindKey = nY),
          (F.castArray = nke),
          (F.chain = Z$),
          (F.chunk = fDe),
          (F.compact = hDe),
          (F.concat = gDe),
          (F.cond = OMe),
          (F.conforms = qMe),
          (F.constant = rL),
          (F.countBy = ETe),
          (F.create = Qke),
          (F.curry = iY),
          (F.curryRight = sY),
          (F.debounce = oY),
          (F.defaults = Nke),
          (F.defaultsDeep = Pke),
          (F.defer = $Te),
          (F.delay = YTe),
          (F.difference = pDe),
          (F.differenceBy = mDe),
          (F.differenceWith = ADe),
          (F.drop = yDe),
          (F.dropRight = vDe),
          (F.dropRightWhile = CDe),
          (F.dropWhile = bDe),
          (F.fill = EDe),
          (F.filter = xTe),
          (F.flatMap = ITe),
          (F.flatMapDeep = BTe),
          (F.flatMapDepth = RTe),
          (F.flatten = K$),
          (F.flattenDeep = _De),
          (F.flattenDepth = xDe),
          (F.flip = KTe),
          (F.flow = HMe),
          (F.flowRight = WMe),
          (F.fromPairs = wDe),
          (F.functions = Wke),
          (F.functionsIn = Gke),
          (F.groupBy = DTe),
          (F.initial = IDe),
          (F.intersection = BDe),
          (F.intersectionBy = RDe),
          (F.intersectionWith = DDe),
          (F.invert = Yke),
          (F.invertBy = Kke),
          (F.invokeMap = kTe),
          (F.iteratee = nL),
          (F.keyBy = MTe),
          (F.keys = Zi),
          (F.keysIn = qo),
          (F.map = qS),
          (F.mapKeys = Jke),
          (F.mapValues = jke),
          (F.matches = GMe),
          (F.matchesProperty = $Me),
          (F.memoize = HS),
          (F.merge = Zke),
          (F.mergeWith = mY),
          (F.method = YMe),
          (F.methodOf = KMe),
          (F.mixin = iL),
          (F.negate = WS),
          (F.nthArg = JMe),
          (F.omit = Xke),
          (F.omitBy = eMe),
          (F.once = zTe),
          (F.orderBy = FTe),
          (F.over = jMe),
          (F.overArgs = JTe),
          (F.overEvery = ZMe),
          (F.overSome = XMe),
          (F.partial = JP),
          (F.partialRight = aY),
          (F.partition = QTe),
          (F.pick = tMe),
          (F.pickBy = AY),
          (F.property = xY),
          (F.propertyOf = eFe),
          (F.pull = FDe),
          (F.pullAll = J$),
          (F.pullAllBy = QDe),
          (F.pullAllWith = NDe),
          (F.pullAt = PDe),
          (F.range = tFe),
          (F.rangeRight = rFe),
          (F.rearg = jTe),
          (F.reject = LTe),
          (F.remove = LDe),
          (F.rest = ZTe),
          (F.reverse = YP),
          (F.sampleSize = OTe),
          (F.set = nMe),
          (F.setWith = iMe),
          (F.shuffle = qTe),
          (F.slice = UDe),
          (F.sortBy = WTe),
          (F.sortedUniq = $De),
          (F.sortedUniqBy = YDe),
          (F.split = IMe),
          (F.spread = XTe),
          (F.tail = KDe),
          (F.take = zDe),
          (F.takeRight = JDe),
          (F.takeRightWhile = jDe),
          (F.takeWhile = ZDe),
          (F.tap = hTe),
          (F.throttle = eke),
          (F.thru = OS),
          (F.toArray = fY),
          (F.toPairs = yY),
          (F.toPairsIn = vY),
          (F.toPath = aFe),
          (F.toPlainObject = gY),
          (F.transform = sMe),
          (F.unary = tke),
          (F.union = XDe),
          (F.unionBy = eTe),
          (F.unionWith = tTe),
          (F.uniq = rTe),
          (F.uniqBy = nTe),
          (F.uniqWith = iTe),
          (F.unset = oMe),
          (F.unzip = KP),
          (F.unzipWith = j$),
          (F.update = aMe),
          (F.updateWith = lMe),
          (F.values = _A),
          (F.valuesIn = cMe),
          (F.without = sTe),
          (F.words = EY),
          (F.wrap = rke),
          (F.xor = oTe),
          (F.xorBy = aTe),
          (F.xorWith = lTe),
          (F.zip = cTe),
          (F.zipObject = uTe),
          (F.zipObjectDeep = dTe),
          (F.zipWith = fTe),
          (F.entries = yY),
          (F.entriesIn = vY),
          (F.extend = pY),
          (F.extendWith = YS),
          iL(F, F),
          (F.add = cFe),
          (F.attempt = _Y),
          (F.camelCase = hMe),
          (F.capitalize = CY),
          (F.ceil = uFe),
          (F.clamp = uMe),
          (F.clone = ike),
          (F.cloneDeep = oke),
          (F.cloneDeepWith = ake),
          (F.cloneWith = ske),
          (F.conformsTo = lke),
          (F.deburr = bY),
          (F.defaultTo = VMe),
          (F.divide = dFe),
          (F.endsWith = gMe),
          (F.eq = uc),
          (F.escape = pMe),
          (F.escapeRegExp = mMe),
          (F.every = _Te),
          (F.find = wTe),
          (F.findIndex = $$),
          (F.findKey = Lke),
          (F.findLast = STe),
          (F.findLastIndex = Y$),
          (F.findLastKey = Uke),
          (F.floor = fFe),
          (F.forEach = X$),
          (F.forEachRight = eY),
          (F.forIn = Oke),
          (F.forInRight = qke),
          (F.forOwn = Vke),
          (F.forOwnRight = Hke),
          (F.get = XP),
          (F.gt = cke),
          (F.gte = uke),
          (F.has = $ke),
          (F.hasIn = eL),
          (F.head = z$),
          (F.identity = Vo),
          (F.includes = TTe),
          (F.indexOf = SDe),
          (F.inRange = dMe),
          (F.invoke = zke),
          (F.isArguments = Ug),
          (F.isArray = Ft),
          (F.isArrayBuffer = dke),
          (F.isArrayLike = Oo),
          (F.isArrayLikeObject = vi),
          (F.isBoolean = fke),
          (F.isBuffer = Hf),
          (F.isDate = hke),
          (F.isElement = gke),
          (F.isEmpty = pke),
          (F.isEqual = mke),
          (F.isEqualWith = Ake),
          (F.isError = jP),
          (F.isFinite = yke),
          (F.isFunction = xd),
          (F.isInteger = lY),
          (F.isLength = GS),
          (F.isMap = cY),
          (F.isMatch = vke),
          (F.isMatchWith = Cke),
          (F.isNaN = bke),
          (F.isNative = Eke),
          (F.isNil = xke),
          (F.isNull = _ke),
          (F.isNumber = uY),
          (F.isObject = $n),
          (F.isObjectLike = ni),
          (F.isPlainObject = ZC),
          (F.isRegExp = ZP),
          (F.isSafeInteger = wke),
          (F.isSet = dY),
          (F.isString = $S),
          (F.isSymbol = Ca),
          (F.isTypedArray = EA),
          (F.isUndefined = Ske),
          (F.isWeakMap = Ike),
          (F.isWeakSet = Bke),
          (F.join = TDe),
          (F.kebabCase = AMe),
          (F.last = gl),
          (F.lastIndexOf = kDe),
          (F.lowerCase = yMe),
          (F.lowerFirst = vMe),
          (F.lt = Rke),
          (F.lte = Dke),
          (F.max = hFe),
          (F.maxBy = gFe),
          (F.mean = pFe),
          (F.meanBy = mFe),
          (F.min = AFe),
          (F.minBy = yFe),
          (F.stubArray = oL),
          (F.stubFalse = aL),
          (F.stubObject = nFe),
          (F.stubString = iFe),
          (F.stubTrue = sFe),
          (F.multiply = vFe),
          (F.nth = MDe),
          (F.noConflict = zMe),
          (F.noop = sL),
          (F.now = VS),
          (F.pad = CMe),
          (F.padEnd = bMe),
          (F.padStart = EMe),
          (F.parseInt = _Me),
          (F.random = fMe),
          (F.reduce = NTe),
          (F.reduceRight = PTe),
          (F.repeat = xMe),
          (F.replace = wMe),
          (F.result = rMe),
          (F.round = CFe),
          (F.runInContext = K),
          (F.sample = UTe),
          (F.size = VTe),
          (F.snakeCase = SMe),
          (F.some = HTe),
          (F.sortedIndex = ODe),
          (F.sortedIndexBy = qDe),
          (F.sortedIndexOf = VDe),
          (F.sortedLastIndex = HDe),
          (F.sortedLastIndexBy = WDe),
          (F.sortedLastIndexOf = GDe),
          (F.startCase = BMe),
          (F.startsWith = RMe),
          (F.subtract = bFe),
          (F.sum = EFe),
          (F.sumBy = _Fe),
          (F.template = DMe),
          (F.times = oFe),
          (F.toFinite = wd),
          (F.toInteger = Yt),
          (F.toLength = hY),
          (F.toLower = TMe),
          (F.toNumber = pl),
          (F.toSafeInteger = Tke),
          (F.toString = Xr),
          (F.toUpper = kMe),
          (F.trim = MMe),
          (F.trimEnd = FMe),
          (F.trimStart = QMe),
          (F.truncate = NMe),
          (F.unescape = PMe),
          (F.uniqueId = lFe),
          (F.upperCase = LMe),
          (F.upperFirst = tL),
          (F.each = X$),
          (F.eachRight = eY),
          (F.first = z$),
          iL(
            F,
            (function () {
              var d = {}
              return (
                lu(F, function (h, A) {
                  cn.call(F.prototype, A) || (d[A] = h)
                }),
                d
              )
            })(),
            { chain: false },
          ),
          (F.VERSION = t),
          Cs(
            [
              "bind",
              "bindKey",
              "curry",
              "curryRight",
              "partial",
              "partialRight",
            ],
            function (d) {
              F[d].placeholder = F
            },
          ),
          Cs(["drop", "take"], function (d, h) {
            ;(mr.prototype[d] = function (A) {
              A = A === e ? 1 : qi(Yt(A), 0)
              var b = this.__filtered__ && !h ? new mr(this) : this.clone()
              return (
                b.__filtered__
                  ? (b.__takeCount__ = Os(A, b.__takeCount__))
                  : b.__views__.push({
                      size: Os(A, At),
                      type: d + (b.__dir__ < 0 ? "Right" : ""),
                    }),
                b
              )
            }),
              (mr.prototype[d + "Right"] = function (A) {
                return this.reverse()[d](A).reverse()
              })
          }),
          Cs(["filter", "map", "takeWhile"], function (d, h) {
            var A = h + 1,
              b = A == ce || A == Q
            mr.prototype[d] = function (I) {
              var P = this.clone()
              return (
                P.__iteratees__.push({ iteratee: ut(I, 3), type: A }),
                (P.__filtered__ = P.__filtered__ || b),
                P
              )
            }
          }),
          Cs(["head", "last"], function (d, h) {
            var A = "take" + (h ? "Right" : "")
            mr.prototype[d] = function () {
              return this[A](1).value()[0]
            }
          }),
          Cs(["initial", "tail"], function (d, h) {
            var A = "drop" + (h ? "" : "Right")
            mr.prototype[d] = function () {
              return this.__filtered__ ? new mr(this) : this[A](1)
            }
          }),
          (mr.prototype.compact = function () {
            return this.filter(Vo)
          }),
          (mr.prototype.find = function (d) {
            return this.filter(d).head()
          }),
          (mr.prototype.findLast = function (d) {
            return this.reverse().find(d)
          }),
          (mr.prototype.invokeMap = tr(function (d, h) {
            return typeof d == "function"
              ? new mr(this)
              : this.map(function (A) {
                  return $C(A, d, h)
                })
          })),
          (mr.prototype.reject = function (d) {
            return this.filter(WS(ut(d)))
          }),
          (mr.prototype.slice = function (d, h) {
            d = Yt(d)
            var A = this
            return A.__filtered__ && (d > 0 || h < 0)
              ? new mr(A)
              : (d < 0 ? (A = A.takeRight(-d)) : d && (A = A.drop(d)),
                h !== e &&
                  ((h = Yt(h)), (A = h < 0 ? A.dropRight(-h) : A.take(h - d))),
                A)
          }),
          (mr.prototype.takeRightWhile = function (d) {
            return this.reverse().takeWhile(d).reverse()
          }),
          (mr.prototype.toArray = function () {
            return this.take(At)
          }),
          lu(mr.prototype, function (d, h) {
            var A = /^(?:filter|find|map|reject)|While$/.test(h),
              b = /^(?:head|last)$/.test(h),
              I = F[b ? "take" + (h == "last" ? "Right" : "") : h],
              P = b || /^find/.test(h)
            I &&
              (F.prototype[h] = function () {
                var O = this.__wrapped__,
                  H = b ? [1] : arguments,
                  j = O instanceof mr,
                  de = H[0],
                  fe = j || Ft(O),
                  Ae = function (lr) {
                    var xr = I.apply(F, ao([lr], H))
                    return b && Te ? xr[0] : xr
                  }
                fe &&
                  A &&
                  typeof de == "function" &&
                  de.length != 1 &&
                  (j = fe = false)
                var Te = this.__chain__,
                  ze = !!this.__actions__.length,
                  dt = P && !Te,
                  Jt = j && !ze
                if (!P && fe) {
                  O = Jt ? O : new mr(this)
                  var ft = d.apply(O, H)
                  return (
                    ft.__actions__.push({ func: OS, args: [Ae], thisArg: e }),
                    new dl(ft, Te)
                  )
                }
                return dt && Jt
                  ? d.apply(this, H)
                  : ((ft = this.thru(Ae)),
                    dt ? (b ? ft.value()[0] : ft.value()) : ft)
              })
          }),
          Cs(
            ["pop", "push", "shift", "sort", "splice", "unshift"],
            function (d) {
              var h = fS[d],
                A = /^(?:push|sort|unshift)$/.test(d) ? "tap" : "thru",
                b = /^(?:pop|shift)$/.test(d)
              F.prototype[d] = function () {
                var I = arguments
                if (b && !this.__chain__) {
                  var P = this.value()
                  return h.apply(Ft(P) ? P : [], I)
                }
                return this[A](function (O) {
                  return h.apply(Ft(O) ? O : [], I)
                })
              }
            },
          ),
          lu(mr.prototype, function (d, h) {
            var A = F[h]
            if (A) {
              var b = A.name + ""
              cn.call(AA, b) || (AA[b] = []), AA[b].push({ name: h, func: A })
            }
          }),
          (AA[MS(e, y).name] = [{ name: "wrapper", func: e }]),
          (mr.prototype.clone = PBe),
          (mr.prototype.reverse = LBe),
          (mr.prototype.value = UBe),
          (F.prototype.at = gTe),
          (F.prototype.chain = pTe),
          (F.prototype.commit = mTe),
          (F.prototype.next = ATe),
          (F.prototype.plant = vTe),
          (F.prototype.reverse = CTe),
          (F.prototype.toJSON = F.prototype.valueOf = F.prototype.value = bTe),
          (F.prototype.first = F.prototype.head),
          UC && (F.prototype[UC] = yTe),
          F
        )
      },
      Pf = mBe()
    typeof define == "function" && typeof define.amd == "object" && define.amd
      ? ((Bi._ = Pf),
        define(function () {
          return Pf
        }))
      : pd
        ? (((pd.exports = Pf)._ = Pf), (FC._ = Pf))
        : (Bi._ = Pf)
  }).call(VA)
})
var YA = _((Kwt, Nz) => {
  "use strict"
  Nz.exports = ap
  ap.CAPTURING_PHASE = 1
  ap.AT_TARGET = 2
  ap.BUBBLING_PHASE = 3
  function ap(e, t) {
    if (
      ((this.type = ""),
      (this.target = null),
      (this.currentTarget = null),
      (this.eventPhase = ap.AT_TARGET),
      (this.bubbles = false),
      (this.cancelable = false),
      (this.isTrusted = false),
      (this.defaultPrevented = false),
      (this.timeStamp = Date.now()),
      (this._propagationStopped = false),
      (this._immediatePropagationStopped = false),
      (this._initialized = true),
      (this._dispatching = false),
      e && (this.type = e),
      t)
    )
      for (var r in t) this[r] = t[r]
  }
  ap.prototype = Object.create(Object.prototype, {
    constructor: { value: ap },
    stopPropagation: {
      value: function () {
        this._propagationStopped = true
      },
    },
    stopImmediatePropagation: {
      value: function () {
        ;(this._propagationStopped = true),
          (this._immediatePropagationStopped = true)
      },
    },
    preventDefault: {
      value: function () {
        this.cancelable && (this.defaultPrevented = true)
      },
    },
    initEvent: {
      value: function (t, r, n) {
        ;(this._initialized = true),
          !this._dispatching &&
            ((this._propagationStopped = false),
            (this._immediatePropagationStopped = false),
            (this.defaultPrevented = false),
            (this.isTrusted = false),
            (this.target = null),
            (this.type = t),
            (this.bubbles = r),
            (this.cancelable = n))
      },
    },
  })
})
var jL = _((zwt, Lz) => {
  "use strict"
  var Pz = YA()
  Lz.exports = JL
  function JL() {
    Pz.call(this), (this.view = null), (this.detail = 0)
  }
  JL.prototype = Object.create(Pz.prototype, {
    constructor: { value: JL },
    initUIEvent: {
      value: function (e, t, r, n, i) {
        this.initEvent(e, t, r), (this.view = n), (this.detail = i)
      },
    },
  })
})
var XL = _((Jwt, Oz) => {
  "use strict"
  var Uz = jL()
  Oz.exports = ZL
  function ZL() {
    Uz.call(this),
      (this.screenX = this.screenY = this.clientX = this.clientY = 0),
      (this.ctrlKey = this.altKey = this.shiftKey = this.metaKey = false),
      (this.button = 0),
      (this.buttons = 1),
      (this.relatedTarget = null)
  }
  ZL.prototype = Object.create(Uz.prototype, {
    constructor: { value: ZL },
    initMouseEvent: {
      value: function (e, t, r, n, i, s, o, a, l, c, u, f, p, g, m) {
        switch (
          (this.initEvent(e, t, r, n, i),
          (this.screenX = s),
          (this.screenY = o),
          (this.clientX = a),
          (this.clientY = l),
          (this.ctrlKey = c),
          (this.altKey = u),
          (this.shiftKey = f),
          (this.metaKey = p),
          (this.button = g),
          g)
        ) {
          case 0:
            this.buttons = 1
            break
          case 1:
            this.buttons = 4
            break
          case 2:
            this.buttons = 2
            break
          default:
            this.buttons = 0
            break
        }
        this.relatedTarget = m
      },
    },
    getModifierState: {
      value: function (e) {
        switch (e) {
          case "Alt":
            return this.altKey
          case "Control":
            return this.ctrlKey
          case "Shift":
            return this.shiftKey
          case "Meta":
            return this.metaKey
          default:
            return false
        }
      },
    },
  })
})
var GI = _((jwt, Vz) => {
  "use strict"
  Vz.exports = WI
  var s2e = 1,
    o2e = 3,
    a2e = 4,
    l2e = 5,
    c2e = 7,
    u2e = 8,
    d2e = 9,
    f2e = 11,
    h2e = 12,
    g2e = 13,
    p2e = 14,
    m2e = 15,
    A2e = 17,
    y2e = 18,
    v2e = 19,
    C2e = 20,
    b2e = 21,
    E2e = 22,
    _2e = 23,
    x2e = 24,
    w2e = 25,
    S2e = [
      null,
      "INDEX_SIZE_ERR",
      null,
      "HIERARCHY_REQUEST_ERR",
      "WRONG_DOCUMENT_ERR",
      "INVALID_CHARACTER_ERR",
      null,
      "NO_MODIFICATION_ALLOWED_ERR",
      "NOT_FOUND_ERR",
      "NOT_SUPPORTED_ERR",
      "INUSE_ATTRIBUTE_ERR",
      "INVALID_STATE_ERR",
      "SYNTAX_ERR",
      "INVALID_MODIFICATION_ERR",
      "NAMESPACE_ERR",
      "INVALID_ACCESS_ERR",
      null,
      "TYPE_MISMATCH_ERR",
      "SECURITY_ERR",
      "NETWORK_ERR",
      "ABORT_ERR",
      "URL_MISMATCH_ERR",
      "QUOTA_EXCEEDED_ERR",
      "TIMEOUT_ERR",
      "INVALID_NODE_TYPE_ERR",
      "DATA_CLONE_ERR",
    ],
    I2e = [
      null,
      "INDEX_SIZE_ERR (1): the index is not in the allowed range",
      null,
      "HIERARCHY_REQUEST_ERR (3): the operation would yield an incorrect nodes model",
      "WRONG_DOCUMENT_ERR (4): the object is in the wrong Document, a call to importNode is required",
      "INVALID_CHARACTER_ERR (5): the string contains invalid characters",
      null,
      "NO_MODIFICATION_ALLOWED_ERR (7): the object can not be modified",
      "NOT_FOUND_ERR (8): the object can not be found here",
      "NOT_SUPPORTED_ERR (9): this operation is not supported",
      "INUSE_ATTRIBUTE_ERR (10): setAttributeNode called on owned Attribute",
      "INVALID_STATE_ERR (11): the object is in an invalid state",
      "SYNTAX_ERR (12): the string did not match the expected pattern",
      "INVALID_MODIFICATION_ERR (13): the object can not be modified in this way",
      "NAMESPACE_ERR (14): the operation is not allowed by Namespaces in XML",
      "INVALID_ACCESS_ERR (15): the object does not support the operation or argument",
      null,
      "TYPE_MISMATCH_ERR (17): the type of the object does not match the expected type",
      "SECURITY_ERR (18): the operation is insecure",
      "NETWORK_ERR (19): a network error occurred",
      "ABORT_ERR (20): the user aborted an operation",
      "URL_MISMATCH_ERR (21): the given URL does not match another URL",
      "QUOTA_EXCEEDED_ERR (22): the quota has been exceeded",
      "TIMEOUT_ERR (23): a timeout occurred",
      "INVALID_NODE_TYPE_ERR (24): the supplied node is invalid or has an invalid ancestor for this operation",
      "DATA_CLONE_ERR (25): the object can not be cloned.",
    ],
    qz = {
      INDEX_SIZE_ERR: s2e,
      DOMSTRING_SIZE_ERR: 2,
      HIERARCHY_REQUEST_ERR: o2e,
      WRONG_DOCUMENT_ERR: a2e,
      INVALID_CHARACTER_ERR: l2e,
      NO_DATA_ALLOWED_ERR: 6,
      NO_MODIFICATION_ALLOWED_ERR: c2e,
      NOT_FOUND_ERR: u2e,
      NOT_SUPPORTED_ERR: d2e,
      INUSE_ATTRIBUTE_ERR: 10,
      INVALID_STATE_ERR: f2e,
      SYNTAX_ERR: h2e,
      INVALID_MODIFICATION_ERR: g2e,
      NAMESPACE_ERR: p2e,
      INVALID_ACCESS_ERR: m2e,
      VALIDATION_ERR: 16,
      TYPE_MISMATCH_ERR: A2e,
      SECURITY_ERR: y2e,
      NETWORK_ERR: v2e,
      ABORT_ERR: C2e,
      URL_MISMATCH_ERR: b2e,
      QUOTA_EXCEEDED_ERR: E2e,
      TIMEOUT_ERR: _2e,
      INVALID_NODE_TYPE_ERR: x2e,
      DATA_CLONE_ERR: w2e,
    }
  function WI(e) {
    Error.call(this),
      Error.captureStackTrace(this, this.constructor),
      (this.code = e),
      (this.message = I2e[e]),
      (this.name = S2e[e])
  }
  WI.prototype.__proto__ = Error.prototype
  for (HI in qz)
    (eU = { value: qz[HI] }),
      Object.defineProperty(WI, HI, eU),
      Object.defineProperty(WI.prototype, HI, eU)
  var eU, HI
})
var $I = _((Hz) => {
  "use strict"
  Hz.isApiWritable = !globalThis.__domino_frozen__
})
var oi = _((Kr) => {
  "use strict"
  var si = GI(),
    bi = si,
    B2e = $I().isApiWritable
  Kr.NAMESPACE = {
    HTML: "http://www.w3.org/1999/xhtml",
    XML: "http://www.w3.org/XML/1998/namespace",
    XMLNS: "http://www.w3.org/2000/xmlns/",
    MATHML: "http://www.w3.org/1998/Math/MathML",
    SVG: "http://www.w3.org/2000/svg",
    XLINK: "http://www.w3.org/1999/xlink",
  }
  Kr.IndexSizeError = function () {
    throw new si(bi.INDEX_SIZE_ERR)
  }
  Kr.HierarchyRequestError = function () {
    throw new si(bi.HIERARCHY_REQUEST_ERR)
  }
  Kr.WrongDocumentError = function () {
    throw new si(bi.WRONG_DOCUMENT_ERR)
  }
  Kr.InvalidCharacterError = function () {
    throw new si(bi.INVALID_CHARACTER_ERR)
  }
  Kr.NoModificationAllowedError = function () {
    throw new si(bi.NO_MODIFICATION_ALLOWED_ERR)
  }
  Kr.NotFoundError = function () {
    throw new si(bi.NOT_FOUND_ERR)
  }
  Kr.NotSupportedError = function () {
    throw new si(bi.NOT_SUPPORTED_ERR)
  }
  Kr.InvalidStateError = function () {
    throw new si(bi.INVALID_STATE_ERR)
  }
  Kr.SyntaxError = function () {
    throw new si(bi.SYNTAX_ERR)
  }
  Kr.InvalidModificationError = function () {
    throw new si(bi.INVALID_MODIFICATION_ERR)
  }
  Kr.NamespaceError = function () {
    throw new si(bi.NAMESPACE_ERR)
  }
  Kr.InvalidAccessError = function () {
    throw new si(bi.INVALID_ACCESS_ERR)
  }
  Kr.TypeMismatchError = function () {
    throw new si(bi.TYPE_MISMATCH_ERR)
  }
  Kr.SecurityError = function () {
    throw new si(bi.SECURITY_ERR)
  }
  Kr.NetworkError = function () {
    throw new si(bi.NETWORK_ERR)
  }
  Kr.AbortError = function () {
    throw new si(bi.ABORT_ERR)
  }
  Kr.UrlMismatchError = function () {
    throw new si(bi.URL_MISMATCH_ERR)
  }
  Kr.QuotaExceededError = function () {
    throw new si(bi.QUOTA_EXCEEDED_ERR)
  }
  Kr.TimeoutError = function () {
    throw new si(bi.TIMEOUT_ERR)
  }
  Kr.InvalidNodeTypeError = function () {
    throw new si(bi.INVALID_NODE_TYPE_ERR)
  }
  Kr.DataCloneError = function () {
    throw new si(bi.DATA_CLONE_ERR)
  }
  Kr.nyi = function () {
    throw new Error("NotYetImplemented")
  }
  Kr.shouldOverride = function () {
    throw new Error("Abstract function; should be overriding in subclass.")
  }
  Kr.assert = function (e, t) {
    if (!e)
      throw new Error(
        "Assertion failed: " +
          (t || "") +
          `
` +
          new Error().stack,
      )
  }
  Kr.expose = function (e, t) {
    for (var r in e)
      Object.defineProperty(t.prototype, r, { value: e[r], writable: B2e })
  }
  Kr.merge = function (e, t) {
    for (var r in t) e[r] = t[r]
  }
  Kr.documentOrder = function (e, t) {
    return 3 - (e.compareDocumentPosition(t) & 6)
  }
  Kr.toASCIILowerCase = function (e) {
    return e.replace(/[A-Z]+/g, function (t) {
      return t.toLowerCase()
    })
  }
  Kr.toASCIIUpperCase = function (e) {
    return e.replace(/[a-z]+/g, function (t) {
      return t.toUpperCase()
    })
  }
})
var tU = _((eSt, Gz) => {
  "use strict"
  var lp = YA(),
    R2e = XL(),
    D2e = oi()
  Gz.exports = Wz
  function Wz() {}
  Wz.prototype = {
    addEventListener: function (t, r, n) {
      if (r) {
        n === undefined && (n = false),
          this._listeners || (this._listeners = Object.create(null)),
          this._listeners[t] || (this._listeners[t] = [])
        for (var i = this._listeners[t], s = 0, o = i.length; s < o; s++) {
          var a = i[s]
          if (a.listener === r && a.capture === n) return
        }
        var l = { listener: r, capture: n }
        typeof r == "function" && (l.f = r), i.push(l)
      }
    },
    removeEventListener: function (t, r, n) {
      if ((n === undefined && (n = false), this._listeners)) {
        var i = this._listeners[t]
        if (i)
          for (var s = 0, o = i.length; s < o; s++) {
            var a = i[s]
            if (a.listener === r && a.capture === n) {
              i.length === 1 ? (this._listeners[t] = undefined) : i.splice(s, 1)
              return
            }
          }
      }
    },
    dispatchEvent: function (t) {
      return this._dispatchEvent(t, false)
    },
    _dispatchEvent: function (t, r) {
      typeof r != "boolean" && (r = false)
      function n(c, u) {
        var f = u.type,
          p = u.eventPhase
        if (
          ((u.currentTarget = c),
          p !== lp.CAPTURING_PHASE && c._handlers && c._handlers[f])
        ) {
          var g = c._handlers[f],
            m
          if (typeof g == "function") m = g.call(u.currentTarget, u)
          else {
            var y = g.handleEvent
            if (typeof y != "function")
              throw new TypeError(
                "handleEvent property of event handler object isnot a function.",
              )
            m = y.call(g, u)
          }
          switch (u.type) {
            case "mouseover":
              m === true && u.preventDefault()
              break
            case "beforeunload":
            default:
              m === false && u.preventDefault()
              break
          }
        }
        var v = c._listeners && c._listeners[f]
        if (v) {
          v = v.slice()
          for (var C = 0, E = v.length; C < E; C++) {
            if (u._immediatePropagationStopped) return
            var w = v[C]
            if (
              !(
                (p === lp.CAPTURING_PHASE && !w.capture) ||
                (p === lp.BUBBLING_PHASE && w.capture)
              )
            )
              if (w.f) w.f.call(u.currentTarget, u)
              else {
                var B = w.listener.handleEvent
                if (typeof B != "function")
                  throw new TypeError(
                    "handleEvent property of event listener object is not a function.",
                  )
                B.call(w.listener, u)
              }
          }
        }
      }
      ;(!t._initialized || t._dispatching) && D2e.InvalidStateError(),
        (t.isTrusted = r),
        (t._dispatching = true),
        (t.target = this)
      for (var i = [], s = this.parentNode; s; s = s.parentNode) i.push(s)
      t.eventPhase = lp.CAPTURING_PHASE
      for (
        var o = i.length - 1;
        o >= 0 && (n(i[o], t), !t._propagationStopped);
        o--
      );
      if (
        (t._propagationStopped || ((t.eventPhase = lp.AT_TARGET), n(this, t)),
        t.bubbles && !t._propagationStopped)
      ) {
        t.eventPhase = lp.BUBBLING_PHASE
        for (
          var a = 0, l = i.length;
          a < l && (n(i[a], t), !t._propagationStopped);
          a++
        );
      }
      if (
        ((t._dispatching = false),
        (t.eventPhase = lp.AT_TARGET),
        (t.currentTarget = null),
        r && !t.defaultPrevented && t instanceof R2e)
      )
        switch (t.type) {
          case "mousedown":
            this._armed = { x: t.clientX, y: t.clientY, t: t.timeStamp }
            break
          case "mouseout":
          case "mouseover":
            this._armed = null
            break
          case "mouseup":
            this._isClick(t) && this._doClick(t), (this._armed = null)
            break
        }
      return !t.defaultPrevented
    },
    _isClick: function (e) {
      return (
        this._armed !== null &&
        e.type === "mouseup" &&
        e.isTrusted &&
        e.button === 0 &&
        e.timeStamp - this._armed.t < 1e3 &&
        Math.abs(e.clientX - this._armed.x) < 10 &&
        Math.abs(e.clientY - this._armed.Y) < 10
      )
    },
    _doClick: function (e) {
      if (!this._click_in_progress) {
        this._click_in_progress = true
        for (var t = this; t && !t._post_click_activation_steps; )
          t = t.parentNode
        t && t._pre_click_activation_steps && t._pre_click_activation_steps()
        var r = this.ownerDocument.createEvent("MouseEvent")
        r.initMouseEvent(
          "click",
          true,
          true,
          this.ownerDocument.defaultView,
          1,
          e.screenX,
          e.screenY,
          e.clientX,
          e.clientY,
          e.ctrlKey,
          e.altKey,
          e.shiftKey,
          e.metaKey,
          e.button,
          null,
        )
        var n = this._dispatchEvent(r, true)
        t &&
          (n
            ? t._post_click_activation_steps &&
              t._post_click_activation_steps(r)
            : t._cancelled_activation_steps && t._cancelled_activation_steps())
      }
    },
    _setEventHandler: function (t, r) {
      this._handlers || (this._handlers = Object.create(null)),
        (this._handlers[t] = r)
    },
    _getEventHandler: function (t) {
      return (this._handlers && this._handlers[t]) || null
    },
  }
})
var rU = _((tSt, $z) => {
  "use strict"
  var Fd = oi(),
    bl = ($z.exports = {
      valid: function (e) {
        return (
          Fd.assert(e, "list falsy"),
          Fd.assert(e._previousSibling, "previous falsy"),
          Fd.assert(e._nextSibling, "next falsy"),
          true
        )
      },
      insertBefore: function (e, t) {
        Fd.assert(bl.valid(e) && bl.valid(t))
        var r = e,
          n = e._previousSibling,
          i = t,
          s = t._previousSibling
        ;(r._previousSibling = s),
          (n._nextSibling = i),
          (s._nextSibling = r),
          (i._previousSibling = n),
          Fd.assert(bl.valid(e) && bl.valid(t))
      },
      replace: function (e, t) {
        Fd.assert(bl.valid(e) && (t === null || bl.valid(t))),
          t !== null && bl.insertBefore(t, e),
          bl.remove(e),
          Fd.assert(bl.valid(e) && (t === null || bl.valid(t)))
      },
      remove: function (e) {
        Fd.assert(bl.valid(e))
        var t = e._previousSibling
        if (t !== e) {
          var r = e._nextSibling
          ;(t._nextSibling = r),
            (r._previousSibling = t),
            (e._previousSibling = e._nextSibling = e),
            Fd.assert(bl.valid(e))
        }
      },
    })
})
var nU = _((rSt, eJ) => {
  "use strict"
  eJ.exports = {
    serializeOne: P2e,
    ɵescapeMatchingClosingTag: jz,
    ɵescapeClosingCommentTag: Zz,
    ɵescapeProcessingInstructionContent: Xz,
  }
  var Jz = oi(),
    cp = Jz.NAMESPACE,
    Yz = {
      STYLE: true,
      SCRIPT: true,
      XMP: true,
      IFRAME: true,
      NOEMBED: true,
      NOFRAMES: true,
      PLAINTEXT: true,
    },
    T2e = {
      area: true,
      base: true,
      basefont: true,
      bgsound: true,
      br: true,
      col: true,
      embed: true,
      frame: true,
      hr: true,
      img: true,
      input: true,
      keygen: true,
      link: true,
      meta: true,
      param: true,
      source: true,
      track: true,
      wbr: true,
    },
    k2e = {},
    Kz = /[&<>\u00A0]/g,
    zz = /[&"<>\u00A0]/g
  function M2e(e) {
    return Kz.test(e)
      ? e.replace(Kz, (t) => {
          switch (t) {
            case "&":
              return "&amp;"
            case "<":
              return "&lt;"
            case ">":
              return "&gt;"
            case "\xA0":
              return "&nbsp;"
          }
        })
      : e
  }
  function F2e(e) {
    return zz.test(e)
      ? e.replace(zz, (t) => {
          switch (t) {
            case "<":
              return "&lt;"
            case ">":
              return "&gt;"
            case "&":
              return "&amp;"
            case '"':
              return "&quot;"
            case "\xA0":
              return "&nbsp;"
          }
        })
      : e
  }
  function Q2e(e) {
    var t = e.namespaceURI
    return t
      ? t === cp.XML
        ? "xml:" + e.localName
        : t === cp.XLINK
          ? "xlink:" + e.localName
          : t === cp.XMLNS
            ? e.localName === "xmlns"
              ? "xmlns"
              : "xmlns:" + e.localName
            : e.name
      : e.localName
  }
  function jz(e, t) {
    let r = "</" + t
    if (!e.toLowerCase().includes(r)) return e
    let n = [...e],
      i = e.matchAll(new RegExp(r, "ig"))
    for (let s of i) n[s.index] = "&lt;"
    return n.join("")
  }
  var N2e = /--!?>/
  function Zz(e) {
    return N2e.test(e) ? e.replace(/(--\!?)>/g, "$1&gt;") : e
  }
  function Xz(e) {
    return e.includes(">") ? e.replaceAll(">", "&gt;") : e
  }
  function P2e(e, t) {
    var r = ""
    switch (e.nodeType) {
      case 1:
        var n = e.namespaceURI,
          i = n === cp.HTML,
          s = i || n === cp.SVG || n === cp.MATHML ? e.localName : e.tagName
        r += "<" + s
        for (var o = 0, a = e._numattrs; o < a; o++) {
          var l = e._attr(o)
          ;(r += " " + Q2e(l)),
            l.value !== undefined && (r += '="' + F2e(l.value) + '"')
        }
        if (((r += ">"), !(i && T2e[s]))) {
          var c = e.serialize()
          Yz[s.toUpperCase()] && (c = jz(c, s)),
            i &&
              k2e[s] &&
              c.charAt(0) ===
                `
` &&
              (r += `
`),
            (r += c),
            (r += "</" + s + ">")
        }
        break
      case 3:
      case 4:
        var u
        t.nodeType === 1 && t.namespaceURI === cp.HTML
          ? (u = t.tagName)
          : (u = ""),
          Yz[u] || (u === "NOSCRIPT" && t.ownerDocument._scripting_enabled)
            ? (r += e.data)
            : (r += M2e(e.data))
        break
      case 8:
        r += "<!--" + Zz(e.data) + "-->"
        break
      case 7:
        let f = Xz(e.data)
        r += "<?" + e.target + " " + f + "?>"
        break
      case 10:
        ;(r += "<!DOCTYPE " + e.name), (r += ">")
        break
      default:
        Jz.InvalidStateError()
    }
    return r
  }
})
var xs = _((nSt, oJ) => {
  "use strict"
  oJ.exports = Hn
  var sJ = tU(),
    YI = rU(),
    tJ = nU(),
    zr = oi()
  function Hn() {
    sJ.call(this),
      (this.parentNode = null),
      (this._nextSibling = this._previousSibling = this),
      (this._index = undefined)
  }
  var Wo = (Hn.ELEMENT_NODE = 1),
    iU = (Hn.ATTRIBUTE_NODE = 2),
    KI = (Hn.TEXT_NODE = 3),
    L2e = (Hn.CDATA_SECTION_NODE = 4),
    U2e = (Hn.ENTITY_REFERENCE_NODE = 5),
    sU = (Hn.ENTITY_NODE = 6),
    rJ = (Hn.PROCESSING_INSTRUCTION_NODE = 7),
    nJ = (Hn.COMMENT_NODE = 8),
    Sb = (Hn.DOCUMENT_NODE = 9),
    El = (Hn.DOCUMENT_TYPE_NODE = 10),
    Xf = (Hn.DOCUMENT_FRAGMENT_NODE = 11),
    oU = (Hn.NOTATION_NODE = 12),
    aU = (Hn.DOCUMENT_POSITION_DISCONNECTED = 1),
    lU = (Hn.DOCUMENT_POSITION_PRECEDING = 2),
    cU = (Hn.DOCUMENT_POSITION_FOLLOWING = 4),
    iJ = (Hn.DOCUMENT_POSITION_CONTAINS = 8),
    uU = (Hn.DOCUMENT_POSITION_CONTAINED_BY = 16),
    dU = (Hn.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32)
  Hn.prototype = Object.create(sJ.prototype, {
    baseURI: { get: zr.nyi },
    parentElement: {
      get: function () {
        return this.parentNode && this.parentNode.nodeType === Wo
          ? this.parentNode
          : null
      },
    },
    hasChildNodes: { value: zr.shouldOverride },
    firstChild: { get: zr.shouldOverride },
    lastChild: { get: zr.shouldOverride },
    isConnected: {
      get: function () {
        let e = this
        for (; e != null; ) {
          if (e.nodeType === Hn.DOCUMENT_NODE) return true
          ;(e = e.parentNode),
            e != null &&
              e.nodeType === Hn.DOCUMENT_FRAGMENT_NODE &&
              (e = e.host)
        }
        return false
      },
    },
    previousSibling: {
      get: function () {
        var e = this.parentNode
        return !e || this === e.firstChild ? null : this._previousSibling
      },
    },
    nextSibling: {
      get: function () {
        var e = this.parentNode,
          t = this._nextSibling
        return !e || t === e.firstChild ? null : t
      },
    },
    textContent: {
      get: function () {
        return null
      },
      set: function (e) {},
    },
    innerText: {
      get: function () {
        return null
      },
      set: function (e) {},
    },
    _countChildrenOfType: {
      value: function (e) {
        for (var t = 0, r = this.firstChild; r !== null; r = r.nextSibling)
          r.nodeType === e && t++
        return t
      },
    },
    _ensureInsertValid: {
      value: function (t, r, n) {
        var i = this,
          s,
          o
        if (!t.nodeType) throw new TypeError("not a node")
        switch (i.nodeType) {
          case Sb:
          case Xf:
          case Wo:
            break
          default:
            zr.HierarchyRequestError()
        }
        switch (
          (t.isAncestor(i) && zr.HierarchyRequestError(),
          (r !== null || !n) && r.parentNode !== i && zr.NotFoundError(),
          t.nodeType)
        ) {
          case Xf:
          case El:
          case Wo:
          case KI:
          case rJ:
          case nJ:
            break
          default:
            zr.HierarchyRequestError()
        }
        if (i.nodeType === Sb)
          switch (t.nodeType) {
            case KI:
              zr.HierarchyRequestError()
              break
            case Xf:
              switch (
                (t._countChildrenOfType(KI) > 0 && zr.HierarchyRequestError(),
                t._countChildrenOfType(Wo))
              ) {
                case 0:
                  break
                case 1:
                  if (r !== null)
                    for (
                      n && r.nodeType === El && zr.HierarchyRequestError(),
                        o = r.nextSibling;
                      o !== null;
                      o = o.nextSibling
                    )
                      o.nodeType === El && zr.HierarchyRequestError()
                  ;(s = i._countChildrenOfType(Wo)),
                    n
                      ? s > 0 && zr.HierarchyRequestError()
                      : (s > 1 || (s === 1 && r.nodeType !== Wo)) &&
                        zr.HierarchyRequestError()
                  break
                default:
                  zr.HierarchyRequestError()
              }
              break
            case Wo:
              if (r !== null)
                for (
                  n && r.nodeType === El && zr.HierarchyRequestError(),
                    o = r.nextSibling;
                  o !== null;
                  o = o.nextSibling
                )
                  o.nodeType === El && zr.HierarchyRequestError()
              ;(s = i._countChildrenOfType(Wo)),
                n
                  ? s > 0 && zr.HierarchyRequestError()
                  : (s > 1 || (s === 1 && r.nodeType !== Wo)) &&
                    zr.HierarchyRequestError()
              break
            case El:
              if (r === null)
                i._countChildrenOfType(Wo) && zr.HierarchyRequestError()
              else
                for (o = i.firstChild; o !== null && o !== r; o = o.nextSibling)
                  o.nodeType === Wo && zr.HierarchyRequestError()
              ;(s = i._countChildrenOfType(El)),
                n
                  ? s > 0 && zr.HierarchyRequestError()
                  : (s > 1 || (s === 1 && r.nodeType !== El)) &&
                    zr.HierarchyRequestError()
              break
          }
        else t.nodeType === El && zr.HierarchyRequestError()
      },
    },
    insertBefore: {
      value: function (t, r) {
        var n = this
        n._ensureInsertValid(t, r, true)
        var i = r
        return (
          i === t && (i = t.nextSibling),
          n.doc.adoptNode(t),
          t._insertOrReplace(n, i, false),
          t
        )
      },
    },
    appendChild: {
      value: function (e) {
        return this.insertBefore(e, null)
      },
    },
    _appendChild: {
      value: function (e) {
        e._insertOrReplace(this, null, false)
      },
    },
    removeChild: {
      value: function (t) {
        var r = this
        if (!t.nodeType) throw new TypeError("not a node")
        return t.parentNode !== r && zr.NotFoundError(), t.remove(), t
      },
    },
    replaceChild: {
      value: function (t, r) {
        var n = this
        return (
          n._ensureInsertValid(t, r, false),
          t.doc !== n.doc && n.doc.adoptNode(t),
          t._insertOrReplace(n, r, true),
          r
        )
      },
    },
    contains: {
      value: function (t) {
        return t === null
          ? false
          : this === t
            ? true
            : (this.compareDocumentPosition(t) & uU) !== 0
      },
    },
    compareDocumentPosition: {
      value: function (t) {
        if (this === t) return 0
        if (this.doc !== t.doc || this.rooted !== t.rooted) return aU + dU
        for (var r = [], n = [], i = this; i !== null; i = i.parentNode)
          r.push(i)
        for (i = t; i !== null; i = i.parentNode) n.push(i)
        if ((r.reverse(), n.reverse(), r[0] !== n[0])) return aU + dU
        i = Math.min(r.length, n.length)
        for (var s = 1; s < i; s++)
          if (r[s] !== n[s]) return r[s].index < n[s].index ? cU : lU
        return r.length < n.length ? cU + uU : lU + iJ
      },
    },
    isSameNode: {
      value: function (t) {
        return this === t
      },
    },
    isEqualNode: {
      value: function (t) {
        if (!t || t.nodeType !== this.nodeType || !this.isEqual(t)) return false
        for (
          var r = this.firstChild, n = t.firstChild;
          r && n;
          r = r.nextSibling, n = n.nextSibling
        )
          if (!r.isEqualNode(n)) return false
        return r === null && n === null
      },
    },
    cloneNode: {
      value: function (e) {
        var t = this.clone()
        if (e)
          for (var r = this.firstChild; r !== null; r = r.nextSibling)
            t._appendChild(r.cloneNode(true))
        return t
      },
    },
    lookupPrefix: {
      value: function (t) {
        var r
        if (t === "" || t === null || t === undefined) return null
        switch (this.nodeType) {
          case Wo:
            return this._lookupNamespacePrefix(t, this)
          case Sb:
            return (r = this.documentElement), r ? r.lookupPrefix(t) : null
          case sU:
          case oU:
          case Xf:
          case El:
            return null
          case iU:
            return (r = this.ownerElement), r ? r.lookupPrefix(t) : null
          default:
            return (r = this.parentElement), r ? r.lookupPrefix(t) : null
        }
      },
    },
    lookupNamespaceURI: {
      value: function (t) {
        ;(t === "" || t === undefined) && (t = null)
        var r
        switch (this.nodeType) {
          case Wo:
            return zr.shouldOverride()
          case Sb:
            return (
              (r = this.documentElement), r ? r.lookupNamespaceURI(t) : null
            )
          case sU:
          case oU:
          case El:
          case Xf:
            return null
          case iU:
            return (r = this.ownerElement), r ? r.lookupNamespaceURI(t) : null
          default:
            return (r = this.parentElement), r ? r.lookupNamespaceURI(t) : null
        }
      },
    },
    isDefaultNamespace: {
      value: function (t) {
        ;(t === "" || t === undefined) && (t = null)
        var r = this.lookupNamespaceURI(null)
        return r === t
      },
    },
    index: {
      get: function () {
        var e = this.parentNode
        if (this === e.firstChild) return 0
        var t = e.childNodes
        if (this._index === undefined || t[this._index] !== this) {
          for (var r = 0; r < t.length; r++) t[r]._index = r
          zr.assert(t[this._index] === this)
        }
        return this._index
      },
    },
    isAncestor: {
      value: function (e) {
        if (this.doc !== e.doc || this.rooted !== e.rooted) return false
        for (var t = e; t; t = t.parentNode) if (t === this) return true
        return false
      },
    },
    ensureSameDoc: {
      value: function (e) {
        e.ownerDocument === null
          ? (e.ownerDocument = this.doc)
          : e.ownerDocument !== this.doc && zr.WrongDocumentError()
      },
    },
    removeChildren: { value: zr.shouldOverride },
    _insertOrReplace: {
      value: function (t, r, n) {
        var i = this,
          s,
          o
        if (
          (i.nodeType === Xf && i.rooted && zr.HierarchyRequestError(),
          t._childNodes &&
            ((s = r === null ? t._childNodes.length : r.index),
            i.parentNode === t))
        ) {
          var a = i.index
          a < s && s--
        }
        n && (r.rooted && r.doc.mutateRemove(r), (r.parentNode = null))
        var l = r
        l === null && (l = t.firstChild)
        var c = i.rooted && t.rooted
        if (i.nodeType === Xf) {
          for (var u = [0, n ? 1 : 0], f, p = i.firstChild; p !== null; p = f)
            (f = p.nextSibling), u.push(p), (p.parentNode = t)
          var g = u.length
          if (
            (n
              ? YI.replace(l, g > 2 ? u[2] : null)
              : g > 2 && l !== null && YI.insertBefore(u[2], l),
            t._childNodes)
          )
            for (
              u[0] = r === null ? t._childNodes.length : r._index,
                t._childNodes.splice.apply(t._childNodes, u),
                o = 2;
              o < g;
              o++
            )
              u[o]._index = u[0] + (o - 2)
          else
            t._firstChild === r &&
              (g > 2 ? (t._firstChild = u[2]) : n && (t._firstChild = null))
          if (
            (i._childNodes
              ? (i._childNodes.length = 0)
              : (i._firstChild = null),
            t.rooted)
          )
            for (t.modify(), o = 2; o < g; o++) t.doc.mutateInsert(u[o])
        } else {
          if (r === i) return
          c ? i._remove() : i.parentNode && i.remove(),
            (i.parentNode = t),
            n
              ? (YI.replace(l, i),
                t._childNodes
                  ? ((i._index = s), (t._childNodes[s] = i))
                  : t._firstChild === r && (t._firstChild = i))
              : (l !== null && YI.insertBefore(i, l),
                t._childNodes
                  ? ((i._index = s), t._childNodes.splice(s, 0, i))
                  : t._firstChild === r && (t._firstChild = i)),
            c
              ? (t.modify(), t.doc.mutateMove(i))
              : t.rooted && (t.modify(), t.doc.mutateInsert(i))
        }
      },
    },
    lastModTime: {
      get: function () {
        return (
          this._lastModTime || (this._lastModTime = this.doc.modclock),
          this._lastModTime
        )
      },
    },
    modify: {
      value: function () {
        if (this.doc.modclock)
          for (var e = ++this.doc.modclock, t = this; t; t = t.parentElement)
            t._lastModTime && (t._lastModTime = e)
      },
    },
    doc: {
      get: function () {
        return this.ownerDocument || this
      },
    },
    rooted: {
      get: function () {
        return !!this._nid
      },
    },
    normalize: {
      value: function () {
        for (var e, t = this.firstChild; t !== null; t = e)
          if (
            ((e = t.nextSibling),
            t.normalize && t.normalize(),
            t.nodeType === Hn.TEXT_NODE)
          ) {
            if (t.nodeValue === "") {
              this.removeChild(t)
              continue
            }
            var r = t.previousSibling
            r !== null &&
              r.nodeType === Hn.TEXT_NODE &&
              (r.appendData(t.nodeValue), this.removeChild(t))
          }
      },
    },
    serialize: {
      value: function () {
        if (this._innerHTML) return this._innerHTML
        for (var e = "", t = this.firstChild; t !== null; t = t.nextSibling)
          e += tJ.serializeOne(t, this)
        return e
      },
    },
    outerHTML: {
      get: function () {
        return tJ.serializeOne(this, { nodeType: 0 })
      },
      set: zr.nyi,
    },
    ELEMENT_NODE: { value: Wo },
    ATTRIBUTE_NODE: { value: iU },
    TEXT_NODE: { value: KI },
    CDATA_SECTION_NODE: { value: L2e },
    ENTITY_REFERENCE_NODE: { value: U2e },
    ENTITY_NODE: { value: sU },
    PROCESSING_INSTRUCTION_NODE: { value: rJ },
    COMMENT_NODE: { value: nJ },
    DOCUMENT_NODE: { value: Sb },
    DOCUMENT_TYPE_NODE: { value: El },
    DOCUMENT_FRAGMENT_NODE: { value: Xf },
    NOTATION_NODE: { value: oU },
    DOCUMENT_POSITION_DISCONNECTED: { value: aU },
    DOCUMENT_POSITION_PRECEDING: { value: lU },
    DOCUMENT_POSITION_FOLLOWING: { value: cU },
    DOCUMENT_POSITION_CONTAINS: { value: iJ },
    DOCUMENT_POSITION_CONTAINED_BY: { value: uU },
    DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: { value: dU },
  })
})
var lJ = _((sSt, aJ) => {
  "use strict"
  aJ.exports = class extends Array {
    constructor(t) {
      if ((super((t && t.length) || 0), t)) for (var r in t) this[r] = t[r]
    }
    item(t) {
      return this[t] || null
    }
  }
})
var uJ = _((oSt, cJ) => {
  "use strict"
  function O2e(e) {
    return this[e] || null
  }
  function q2e(e) {
    return e || (e = []), (e.item = O2e), e
  }
  cJ.exports = q2e
})
var up = _((aSt, dJ) => {
  "use strict"
  var fU
  try {
    fU = lJ()
  } catch {
    fU = uJ()
  }
  dJ.exports = fU
})
var zI = _((lSt, gJ) => {
  "use strict"
  gJ.exports = hJ
  var fJ = xs(),
    V2e = up()
  function hJ() {
    fJ.call(this), (this._firstChild = this._childNodes = null)
  }
  hJ.prototype = Object.create(fJ.prototype, {
    hasChildNodes: {
      value: function () {
        return this._childNodes
          ? this._childNodes.length > 0
          : this._firstChild !== null
      },
    },
    childNodes: {
      get: function () {
        return this._ensureChildNodes(), this._childNodes
      },
    },
    firstChild: {
      get: function () {
        return this._childNodes
          ? this._childNodes.length === 0
            ? null
            : this._childNodes[0]
          : this._firstChild
      },
    },
    lastChild: {
      get: function () {
        var e = this._childNodes,
          t
        return e
          ? e.length === 0
            ? null
            : e[e.length - 1]
          : ((t = this._firstChild), t === null ? null : t._previousSibling)
      },
    },
    _ensureChildNodes: {
      value: function () {
        if (!this._childNodes) {
          var e = this._firstChild,
            t = e,
            r = (this._childNodes = new V2e())
          if (e)
            do r.push(t), (t = t._nextSibling)
            while (t !== e)
          this._firstChild = null
        }
      },
    },
    removeChildren: {
      value: function () {
        for (
          var t = this.rooted ? this.ownerDocument : null,
            r = this.firstChild,
            n;
          r !== null;

        )
          (n = r),
            (r = n.nextSibling),
            t && t.mutateRemove(n),
            (n.parentNode = null)
        this._childNodes
          ? (this._childNodes.length = 0)
          : (this._firstChild = null),
          this.modify()
      },
    },
  })
})
var JI = _((pU) => {
  "use strict"
  pU.isValidName = z2e
  pU.isValidQName = J2e
  var H2e = /^[_:A-Za-z][-.:\w]+$/,
    W2e = /^([_A-Za-z][-.\w]+|[_A-Za-z][-.\w]+:[_A-Za-z][-.\w]+)$/,
    Ib =
      "_A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD",
    Bb =
      "-._A-Za-z0-9\xB7\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0300-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD",
    dp = "[" + Ib + "][" + Bb + "]*",
    hU = Ib + ":",
    gU = Bb + ":",
    G2e = new RegExp("^[" + hU + "][" + gU + "]*$"),
    $2e = new RegExp("^(" + dp + "|" + dp + ":" + dp + ")$"),
    pJ = /[\uD800-\uDB7F\uDC00-\uDFFF]/,
    mJ = /[\uD800-\uDB7F\uDC00-\uDFFF]/g,
    AJ = /[\uD800-\uDB7F][\uDC00-\uDFFF]/g
  Ib += "\uD800-\u{EFC00}-\uDFFF"
  Bb += "\uD800-\u{EFC00}-\uDFFF"
  dp = "[" + Ib + "][" + Bb + "]*"
  hU = Ib + ":"
  gU = Bb + ":"
  var Y2e = new RegExp("^[" + hU + "][" + gU + "]*$"),
    K2e = new RegExp("^(" + dp + "|" + dp + ":" + dp + ")$")
  function z2e(e) {
    if (H2e.test(e) || G2e.test(e)) return true
    if (!pJ.test(e) || !Y2e.test(e)) return false
    var t = e.match(mJ),
      r = e.match(AJ)
    return r !== null && 2 * r.length === t.length
  }
  function J2e(e) {
    if (W2e.test(e) || $2e.test(e)) return true
    if (!pJ.test(e) || !K2e.test(e)) return false
    var t = e.match(mJ),
      r = e.match(AJ)
    return r !== null && 2 * r.length === t.length
  }
})
var AU = _((mU) => {
  "use strict"
  var yJ = oi()
  mU.property = function (e) {
    if (Array.isArray(e.type)) {
      var t = Object.create(null)
      e.type.forEach(function (i) {
        t[i.value || i] = i.alias || i
      })
      var r = e.missing
      r === undefined && (r = null)
      var n = e.invalid
      return (
        n === undefined && (n = r),
        {
          get: function () {
            var i = this._getattr(e.name)
            return i === null
              ? r
              : ((i = t[i.toLowerCase()]),
                i !== undefined ? i : n !== null ? n : i)
          },
          set: function (i) {
            this._setattr(e.name, i)
          },
        }
      )
    } else {
      if (e.type === Boolean)
        return {
          get: function () {
            return this.hasAttribute(e.name)
          },
          set: function (i) {
            i ? this._setattr(e.name, "") : this.removeAttribute(e.name)
          },
        }
      if (
        e.type === Number ||
        e.type === "long" ||
        e.type === "unsigned long" ||
        e.type === "limited unsigned long with fallback"
      )
        return j2e(e)
      if (!e.type || e.type === String)
        return {
          get: function () {
            return this._getattr(e.name) || ""
          },
          set: function (i) {
            e.treatNullAsEmptyString && i === null && (i = ""),
              this._setattr(e.name, i)
          },
        }
      if (typeof e.type == "function") return e.type(e.name, e)
    }
    throw new Error("Invalid attribute definition")
  }
  function j2e(e) {
    var t
    typeof e.default == "function"
      ? (t = e.default)
      : typeof e.default == "number"
        ? (t = function () {
            return e.default
          })
        : (t = function () {
            yJ.assert(false, typeof e.default)
          })
    var r = e.type === "unsigned long",
      n = e.type === "long",
      i = e.type === "limited unsigned long with fallback",
      s = e.min,
      o = e.max,
      a = e.setmin
    return (
      s === undefined && (r && (s = 0), n && (s = -2147483648), i && (s = 1)),
      o === undefined && (r || n || i) && (o = 2147483647),
      {
        get: function () {
          var l = this._getattr(e.name),
            c = e.float ? parseFloat(l) : parseInt(l, 10)
          if (
            l === null ||
            !isFinite(c) ||
            (s !== undefined && c < s) ||
            (o !== undefined && c > o)
          )
            return t.call(this)
          if (r || n || i) {
            if (!/^[ \t\n\f\r]*[-+]?[0-9]/.test(l)) return t.call(this)
            c = c | 0
          }
          return c
        },
        set: function (l) {
          e.float || (l = Math.floor(l)),
            a !== undefined && l < a && yJ.IndexSizeError(e.name + " set to " + l),
            r
              ? (l = l < 0 || l > 2147483647 ? t.call(this) : l | 0)
              : i
                ? (l = l < 1 || l > 2147483647 ? t.call(this) : l | 0)
                : n &&
                  (l =
                    l < -2147483648 || l > 2147483647 ? t.call(this) : l | 0),
            this._setattr(e.name, String(l))
        },
      }
    )
  }
  mU.registerChangeHandler = function (e, t, r) {
    var n = e.prototype
    Object.prototype.hasOwnProperty.call(n, "_attributeChangeHandlers") ||
      (n._attributeChangeHandlers = Object.create(
        n._attributeChangeHandlers || null,
      )),
      (n._attributeChangeHandlers[t] = r)
  }
})
var bJ = _((dSt, CJ) => {
  "use strict"
  CJ.exports = vJ
  var Z2e = xs()
  function vJ(e, t) {
    ;(this.root = e),
      (this.filter = t),
      (this.lastModTime = e.lastModTime),
      (this.done = false),
      (this.cache = []),
      this.traverse()
  }
  vJ.prototype = Object.create(Object.prototype, {
    length: {
      get: function () {
        return (
          this.checkcache(), this.done || this.traverse(), this.cache.length
        )
      },
    },
    item: {
      value: function (e) {
        return (
          this.checkcache(),
          !this.done && e >= this.cache.length && this.traverse(),
          this.cache[e]
        )
      },
    },
    checkcache: {
      value: function () {
        if (this.lastModTime !== this.root.lastModTime) {
          for (var e = this.cache.length - 1; e >= 0; e--) this[e] = undefined
          ;(this.cache.length = 0),
            (this.done = false),
            (this.lastModTime = this.root.lastModTime)
        }
      },
    },
    traverse: {
      value: function (e) {
        e !== undefined && e++
        for (var t; (t = this.next()) !== null; )
          if (
            ((this[this.cache.length] = t),
            this.cache.push(t),
            e && this.cache.length === e)
          )
            return
        this.done = true
      },
    },
    next: {
      value: function () {
        var e =
            this.cache.length === 0
              ? this.root
              : this.cache[this.cache.length - 1],
          t
        for (
          e.nodeType === Z2e.DOCUMENT_NODE
            ? (t = e.documentElement)
            : (t = e.nextElement(this.root));
          t;

        ) {
          if (this.filter(t)) return t
          t = t.nextElement(this.root)
        }
        return null
      },
    },
  })
})
var vU = _((fSt, xJ) => {
  "use strict"
  var yU = oi()
  xJ.exports = _J
  function _J(e, t) {
    ;(this._getString = e),
      (this._setString = t),
      (this._length = 0),
      (this._lastStringValue = ""),
      this._update()
  }
  Object.defineProperties(_J.prototype, {
    length: {
      get: function () {
        return this._length
      },
    },
    item: {
      value: function (e) {
        var t = KA(this)
        return e < 0 || e >= t.length ? null : t[e]
      },
    },
    contains: {
      value: function (e) {
        e = String(e)
        var t = KA(this)
        return t.indexOf(e) > -1
      },
    },
    add: {
      value: function () {
        for (var e = KA(this), t = 0, r = arguments.length; t < r; t++) {
          var n = Rb(arguments[t])
          e.indexOf(n) < 0 && e.push(n)
        }
        this._update(e)
      },
    },
    remove: {
      value: function () {
        for (var e = KA(this), t = 0, r = arguments.length; t < r; t++) {
          var n = Rb(arguments[t]),
            i = e.indexOf(n)
          i > -1 && e.splice(i, 1)
        }
        this._update(e)
      },
    },
    toggle: {
      value: function (t, r) {
        return (
          (t = Rb(t)),
          this.contains(t)
            ? r === undefined || r === false
              ? (this.remove(t), false)
              : true
            : r === undefined || r === true
              ? (this.add(t), true)
              : false
        )
      },
    },
    replace: {
      value: function (t, r) {
        String(r) === "" && yU.SyntaxError(), (t = Rb(t)), (r = Rb(r))
        var n = KA(this),
          i = n.indexOf(t)
        if (i < 0) return false
        var s = n.indexOf(r)
        return (
          s < 0
            ? (n[i] = r)
            : i < s
              ? ((n[i] = r), n.splice(s, 1))
              : n.splice(i, 1),
          this._update(n),
          true
        )
      },
    },
    toString: {
      value: function () {
        return this._getString()
      },
    },
    value: {
      get: function () {
        return this._getString()
      },
      set: function (e) {
        this._setString(e), this._update()
      },
    },
    _update: {
      value: function (e) {
        e
          ? (EJ(this, e), this._setString(e.join(" ").trim()))
          : EJ(this, KA(this)),
          (this._lastStringValue = this._getString())
      },
    },
  })
  function EJ(e, t) {
    var r = e._length,
      n
    for (e._length = t.length, n = 0; n < t.length; n++) e[n] = t[n]
    for (; n < r; n++) e[n] = undefined
  }
  function Rb(e) {
    return (
      (e = String(e)),
      e === "" && yU.SyntaxError(),
      /[ \t\r\n\f]/.test(e) && yU.InvalidCharacterError(),
      e
    )
  }
  function X2e(e) {
    for (var t = e._length, r = Array(t), n = 0; n < t; n++) r[n] = e[n]
    return r
  }
  function KA(e) {
    var t = e._getString()
    if (t === e._lastStringValue) return X2e(e)
    var r = t.replace(/(^[ \t\r\n\f]+)|([ \t\r\n\f]+$)/g, "")
    if (r === "") return []
    var n = Object.create(null)
    return r.split(/[ \t\r\n\f]+/g).filter(function (i) {
      var s = "$" + i
      return n[s] ? false : ((n[s] = true), true)
    })
  }
})
var eB = _((jA, DJ) => {
  "use strict"
  var jI = Object.create(null, {
      location: {
        get: function () {
          throw new Error("window.location is not supported.")
        },
      },
    }),
    ePe = function (e, t) {
      return e.compareDocumentPosition(t)
    },
    tPe = function (e, t) {
      return ePe(e, t) & 2 ? 1 : -1
    },
    XI = function (e) {
      for (; (e = e.nextSibling) && e.nodeType !== 1; );
      return e
    },
    JA = function (e) {
      for (; (e = e.previousSibling) && e.nodeType !== 1; );
      return e
    },
    rPe = function (e) {
      if ((e = e.firstChild)) for (; e.nodeType !== 1 && (e = e.nextSibling); );
      return e
    },
    nPe = function (e) {
      if ((e = e.lastChild))
        for (; e.nodeType !== 1 && (e = e.previousSibling); );
      return e
    },
    zA = function (e) {
      if (!e.parentNode) return false
      var t = e.parentNode.nodeType
      return t === 1 || t === 9
    },
    wJ = function (e) {
      if (!e) return e
      var t = e[0]
      return t === '"' || t === "'"
        ? (e[e.length - 1] === t ? (e = e.slice(1, -1)) : (e = e.slice(1)),
          e.replace(vt.str_escape, function (r) {
            var n = /^\\(?:([0-9A-Fa-f]+)|([\r\n\f]+))/.exec(r)
            if (!n) return r.slice(1)
            if (n[2]) return ""
            var i = parseInt(n[1], 16)
            return String.fromCodePoint
              ? String.fromCodePoint(i)
              : String.fromCharCode(i)
          }))
        : vt.ident.test(e)
          ? eh(e)
          : e
    },
    eh = function (e) {
      return e.replace(vt.escape, function (t) {
        var r = /^\\([0-9A-Fa-f]+)/.exec(t)
        if (!r) return t[1]
        var n = parseInt(r[1], 16)
        return String.fromCodePoint
          ? String.fromCodePoint(n)
          : String.fromCharCode(n)
      })
    },
    iPe = (function () {
      return Array.prototype.indexOf
        ? Array.prototype.indexOf
        : function (e, t) {
            for (var r = this.length; r--; ) if (this[r] === t) return r
            return -1
          }
    })(),
    IJ = function (e, t) {
      var r = vt.inside.source.replace(/</g, e).replace(/>/g, t)
      return new RegExp(r)
    },
    Go = function (e, t, r) {
      return (e = e.source), (e = e.replace(t, r.source || r)), new RegExp(e)
    },
    SJ = function (e, t) {
      return e
        .replace(/^(?:\w+:\/\/|\/+)/, "")
        .replace(/(?:\/+|\/*#.*?)$/, "")
        .split("/", t)
        .join("/")
    },
    sPe = function (e, t) {
      var r = e.replace(/\s+/g, ""),
        n
      return (
        r === "even"
          ? (r = "2n+0")
          : r === "odd"
            ? (r = "2n+1")
            : r.indexOf("n") === -1 && (r = "0n" + r),
        (n = /^([+-])?(\d+)?n([+-])?(\d+)?$/.exec(r)),
        {
          group: n[1] === "-" ? -(n[2] || 1) : +(n[2] || 1),
          offset: n[4] ? (n[3] === "-" ? -n[4] : +n[4]) : 0,
        }
      )
    },
    CU = function (e, t, r) {
      var n = sPe(e),
        i = n.group,
        s = n.offset,
        o = r ? nPe : rPe,
        a = r ? JA : XI
      return function (l) {
        if (zA(l))
          for (var c = o(l.parentNode), u = 0; c; ) {
            if ((t(c, l) && u++, c === l))
              return (u -= s), i && u ? u % i === 0 && u < 0 == i < 0 : !u
            c = a(c)
          }
      }
    },
    Xi = {
      "*": (function () {
        return function () {
          return true
        }
      })(),
      type: function (e) {
        return (
          (e = e.toLowerCase()),
          function (t) {
            return t.nodeName.toLowerCase() === e
          }
        )
      },
      attr: function (e, t, r, n) {
        return (
          (t = BJ[t]),
          function (i) {
            var s
            switch (e) {
              case "for":
                s = i.htmlFor
                break
              case "class":
                ;(s = i.className),
                  s === "" && i.getAttribute("class") == null && (s = null)
                break
              case "href":
              case "src":
                s = i.getAttribute(e, 2)
                break
              case "title":
                s = i.getAttribute("title") || null
                break
              case "id":
              case "lang":
              case "dir":
              case "accessKey":
              case "hidden":
              case "tabIndex":
              case "style":
                if (i.getAttribute) {
                  s = i.getAttribute(e)
                  break
                }
              default:
                if (i.hasAttribute && !i.hasAttribute(e)) break
                s = i[e] != null ? i[e] : i.getAttribute && i.getAttribute(e)
                break
            }
            if (s != null)
              return (
                (s = s + ""),
                n && ((s = s.toLowerCase()), (r = r.toLowerCase())),
                t(s, r)
              )
          }
        )
      },
      ":first-child": function (e) {
        return !JA(e) && zA(e)
      },
      ":last-child": function (e) {
        return !XI(e) && zA(e)
      },
      ":only-child": function (e) {
        return !JA(e) && !XI(e) && zA(e)
      },
      ":nth-child": function (e, t) {
        return CU(
          e,
          function () {
            return true
          },
          t,
        )
      },
      ":nth-last-child": function (e) {
        return Xi[":nth-child"](e, true)
      },
      ":root": function (e) {
        return e.ownerDocument.documentElement === e
      },
      ":empty": function (e) {
        return !e.firstChild
      },
      ":not": function (e) {
        var t = EU(e)
        return function (r) {
          return !t(r)
        }
      },
      ":first-of-type": function (e) {
        if (zA(e)) {
          for (var t = e.nodeName; (e = JA(e)); ) if (e.nodeName === t) return
          return true
        }
      },
      ":last-of-type": function (e) {
        if (zA(e)) {
          for (var t = e.nodeName; (e = XI(e)); ) if (e.nodeName === t) return
          return true
        }
      },
      ":only-of-type": function (e) {
        return Xi[":first-of-type"](e) && Xi[":last-of-type"](e)
      },
      ":nth-of-type": function (e, t) {
        return CU(
          e,
          function (r, n) {
            return r.nodeName === n.nodeName
          },
          t,
        )
      },
      ":nth-last-of-type": function (e) {
        return Xi[":nth-of-type"](e, true)
      },
      ":checked": function (e) {
        return !!(e.checked || e.selected)
      },
      ":indeterminate": function (e) {
        return !Xi[":checked"](e)
      },
      ":enabled": function (e) {
        return !e.disabled && e.type !== "hidden"
      },
      ":disabled": function (e) {
        return !!e.disabled
      },
      ":target": function (e) {
        return e.id === jI.location.hash.substring(1)
      },
      ":focus": function (e) {
        return e === e.ownerDocument.activeElement
      },
      ":is": function (e) {
        return EU(e)
      },
      ":matches": function (e) {
        return Xi[":is"](e)
      },
      ":nth-match": function (e, t) {
        var r = e.split(/\s*,\s*/),
          n = r.shift(),
          i = EU(r.join(","))
        return CU(n, i, t)
      },
      ":nth-last-match": function (e) {
        return Xi[":nth-match"](e, true)
      },
      ":links-here": function (e) {
        return e + "" == jI.location + ""
      },
      ":lang": function (e) {
        return function (t) {
          for (; t; ) {
            if (t.lang) return t.lang.indexOf(e) === 0
            t = t.parentNode
          }
        }
      },
      ":dir": function (e) {
        return function (t) {
          for (; t; ) {
            if (t.dir) return t.dir === e
            t = t.parentNode
          }
        }
      },
      ":scope": function (e, t) {
        var r = t || e.ownerDocument
        return r.nodeType === 9 ? e === r.documentElement : e === r
      },
      ":any-link": function (e) {
        return typeof e.href == "string"
      },
      ":local-link": function (e) {
        if (e.nodeName) return e.href && e.host === jI.location.host
        var t = +e + 1
        return function (r) {
          if (r.href) {
            var n = jI.location + "",
              i = r + ""
            return SJ(n, t) === SJ(i, t)
          }
        }
      },
      ":default": function (e) {
        return !!e.defaultSelected
      },
      ":valid": function (e) {
        return e.willValidate || (e.validity && e.validity.valid)
      },
      ":invalid": function (e) {
        return !Xi[":valid"](e)
      },
      ":in-range": function (e) {
        return e.value > e.min && e.value <= e.max
      },
      ":out-of-range": function (e) {
        return !Xi[":in-range"](e)
      },
      ":required": function (e) {
        return !!e.required
      },
      ":optional": function (e) {
        return !e.required
      },
      ":read-only": function (e) {
        if (e.readOnly) return true
        var t = e.getAttribute("contenteditable"),
          r = e.contentEditable,
          n = e.nodeName.toLowerCase()
        return (
          (n = n !== "input" && n !== "textarea"),
          (n || e.disabled) && t == null && r !== "true"
        )
      },
      ":read-write": function (e) {
        return !Xi[":read-only"](e)
      },
      ":hover": function () {
        throw new Error(":hover is not supported.")
      },
      ":active": function () {
        throw new Error(":active is not supported.")
      },
      ":link": function () {
        throw new Error(":link is not supported.")
      },
      ":visited": function () {
        throw new Error(":visited is not supported.")
      },
      ":column": function () {
        throw new Error(":column is not supported.")
      },
      ":nth-column": function () {
        throw new Error(":nth-column is not supported.")
      },
      ":nth-last-column": function () {
        throw new Error(":nth-last-column is not supported.")
      },
      ":current": function () {
        throw new Error(":current is not supported.")
      },
      ":past": function () {
        throw new Error(":past is not supported.")
      },
      ":future": function () {
        throw new Error(":future is not supported.")
      },
      ":contains": function (e) {
        return function (t) {
          var r = t.innerText || t.textContent || t.value || ""
          return r.indexOf(e) !== -1
        }
      },
      ":has": function (e) {
        return function (t) {
          return RJ(e, t).length > 0
        }
      },
    },
    BJ = {
      "-": function () {
        return true
      },
      "=": function (e, t) {
        return e === t
      },
      "*=": function (e, t) {
        return e.indexOf(t) !== -1
      },
      "~=": function (e, t) {
        var r, n, i, s
        for (n = 0; ; n = r + 1) {
          if (((r = e.indexOf(t, n)), r === -1)) return false
          if (
            ((i = e[r - 1]),
            (s = e[r + t.length]),
            (!i || i === " ") && (!s || s === " "))
          )
            return true
        }
      },
      "|=": function (e, t) {
        var r = e.indexOf(t),
          n
        if (r === 0) return (n = e[r + t.length]), n === "-" || !n
      },
      "^=": function (e, t) {
        return e.indexOf(t) === 0
      },
      "$=": function (e, t) {
        var r = e.lastIndexOf(t)
        return r !== -1 && r + t.length === e.length
      },
      "!=": function (e, t) {
        return e !== t
      },
    },
    Db = {
      " ": function (e) {
        return function (t) {
          for (; (t = t.parentNode); ) if (e(t)) return t
        }
      },
      ">": function (e) {
        return function (t) {
          if ((t = t.parentNode)) return e(t) && t
        }
      },
      "+": function (e) {
        return function (t) {
          if ((t = JA(t))) return e(t) && t
        }
      },
      "~": function (e) {
        return function (t) {
          for (; (t = JA(t)); ) if (e(t)) return t
        }
      },
      noop: function (e) {
        return function (t) {
          return e(t) && t
        }
      },
      ref: function (e, t) {
        var r
        function n(i) {
          for (
            var s = i.ownerDocument,
              o = s.getElementsByTagName("*"),
              a = o.length;
            a--;

          )
            if (((r = o[a]), n.test(i))) return (r = null), true
          r = null
        }
        return (
          (n.combinator = function (i) {
            if (!(!r || !r.getAttribute)) {
              var s = r.getAttribute(t) || ""
              if ((s[0] === "#" && (s = s.substring(1)), s === i.id && e(r)))
                return r
            }
          }),
          n
        )
      },
    },
    vt = {
      escape: /\\(?:[^0-9A-Fa-f\r\n]|[0-9A-Fa-f]{1,6}[\r\n\t ]?)/g,
      str_escape: /(escape)|\\(\n|\r\n?|\f)/g,
      nonascii: /[\u00A0-\uFFFF]/,
      cssid: /(?:(?!-?[0-9])(?:escape|nonascii|[-_a-zA-Z0-9])+)/,
      qname: /^ *(cssid|\*)/,
      simple: /^(?:([.#]cssid)|pseudo|attr)/,
      ref: /^ *\/(cssid)\/ */,
      combinator: /^(?: +([^ \w*.#\\]) +|( )+|([^ \w*.#\\]))(?! *$)/,
      attr: /^\[(cssid)(?:([^\w]?=)(inside))?\]/,
      pseudo: /^(:cssid)(?:\((inside)\))?/,
      inside: /(?:"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|<[^"'>]*>|\\["'>]|[^"'>])*/,
      ident: /^(cssid)$/,
    }
  vt.cssid = Go(vt.cssid, "nonascii", vt.nonascii)
  vt.cssid = Go(vt.cssid, "escape", vt.escape)
  vt.qname = Go(vt.qname, "cssid", vt.cssid)
  vt.simple = Go(vt.simple, "cssid", vt.cssid)
  vt.ref = Go(vt.ref, "cssid", vt.cssid)
  vt.attr = Go(vt.attr, "cssid", vt.cssid)
  vt.pseudo = Go(vt.pseudo, "cssid", vt.cssid)
  vt.inside = Go(vt.inside, `[^"'>]*`, vt.inside)
  vt.attr = Go(vt.attr, "inside", IJ("\\[", "\\]"))
  vt.pseudo = Go(vt.pseudo, "inside", IJ("\\(", "\\)"))
  vt.simple = Go(vt.simple, "pseudo", vt.pseudo)
  vt.simple = Go(vt.simple, "attr", vt.attr)
  vt.ident = Go(vt.ident, "cssid", vt.cssid)
  vt.str_escape = Go(vt.str_escape, "escape", vt.escape)
  var Tb = function (e) {
      for (
        var t = e.replace(/^\s+|\s+$/g, ""), r, n = [], i = [], s, o, a, l, c;
        t;

      ) {
        if ((a = vt.qname.exec(t)))
          (t = t.substring(a[0].length)), (o = eh(a[1])), i.push(ZI(o, true))
        else if ((a = vt.simple.exec(t)))
          (t = t.substring(a[0].length)),
            (o = "*"),
            i.push(ZI(o, true)),
            i.push(ZI(a))
        else throw new SyntaxError("Invalid selector.")
        for (; (a = vt.simple.exec(t)); )
          (t = t.substring(a[0].length)), i.push(ZI(a))
        if (
          (t[0] === "!" &&
            ((t = t.substring(1)),
            (s = aPe()),
            (s.qname = o),
            i.push(s.simple)),
          (a = vt.ref.exec(t)))
        ) {
          ;(t = t.substring(a[0].length)),
            (c = Db.ref(bU(i), eh(a[1]))),
            n.push(c.combinator),
            (i = [])
          continue
        }
        if ((a = vt.combinator.exec(t))) {
          if (
            ((t = t.substring(a[0].length)),
            (l = a[1] || a[2] || a[3]),
            l === ",")
          ) {
            n.push(Db.noop(bU(i)))
            break
          }
        } else l = "noop"
        if (!Db[l]) throw new SyntaxError("Bad combinator.")
        n.push(Db[l](bU(i))), (i = [])
      }
      return (
        (r = oPe(n)),
        (r.qname = o),
        (r.sel = t),
        s &&
          ((s.lname = r.qname),
          (s.test = r),
          (s.qname = s.qname),
          (s.sel = r.sel),
          (r = s)),
        c && ((c.test = r), (c.qname = r.qname), (c.sel = r.sel), (r = c)),
        r
      )
    },
    ZI = function (e, t) {
      if (t) return e === "*" ? Xi["*"] : Xi.type(e)
      if (e[1])
        return e[1][0] === "."
          ? Xi.attr("class", "~=", eh(e[1].substring(1)), false)
          : Xi.attr("id", "=", eh(e[1].substring(1)), false)
      if (e[2]) return e[3] ? Xi[eh(e[2])](wJ(e[3])) : Xi[eh(e[2])]
      if (e[4]) {
        var r = e[6],
          n = /["'\s]\s*I$/i.test(r)
        return (
          n && (r = r.replace(/\s*I$/i, "")),
          Xi.attr(eh(e[4]), e[5] || "-", wJ(r), n)
        )
      }
      throw new SyntaxError("Unknown Selector.")
    },
    bU = function (e) {
      var t = e.length,
        r
      return t < 2
        ? e[0]
        : function (n) {
            if (n) {
              for (r = 0; r < t; r++) if (!e[r](n)) return
              return true
            }
          }
    },
    oPe = function (e) {
      return e.length < 2
        ? function (t) {
            return !!e[0](t)
          }
        : function (t) {
            for (var r = e.length; r--; ) if (!(t = e[r](t))) return
            return true
          }
    },
    aPe = function () {
      var e
      function t(r) {
        for (
          var n = r.ownerDocument,
            i = n.getElementsByTagName(t.lname),
            s = i.length;
          s--;

        )
          if (t.test(i[s]) && e === r) return (e = null), true
        e = null
      }
      return (
        (t.simple = function (r) {
          return (e = r), true
        }),
        t
      )
    },
    EU = function (e) {
      for (var t = Tb(e), r = [t]; t.sel; ) (t = Tb(t.sel)), r.push(t)
      return r.length < 2
        ? t
        : function (n) {
            for (var i = r.length, s = 0; s < i; s++) if (r[s](n)) return true
          }
    },
    RJ = function (e, t) {
      for (
        var r = [], n = Tb(e), i = t.getElementsByTagName(n.qname), s = 0, o;
        (o = i[s++]);

      )
        n(o) && r.push(o)
      if (n.sel) {
        for (; n.sel; )
          for (
            n = Tb(n.sel), i = t.getElementsByTagName(n.qname), s = 0;
            (o = i[s++]);

          )
            n(o) && iPe.call(r, o) === -1 && r.push(o)
        r.sort(tPe)
      }
      return r
    }
  DJ.exports = jA = function (e, t) {
    var r, n
    if (t.nodeType !== 11 && e.indexOf(" ") === -1) {
      if (
        e[0] === "#" &&
        t.rooted &&
        /^#[A-Z_][-A-Z0-9_]*$/i.test(e) &&
        t.doc._hasMultipleElementsWithId &&
        ((r = e.substring(1)), !t.doc._hasMultipleElementsWithId(r))
      )
        return (n = t.doc.getElementById(r)), n ? [n] : []
      if (e[0] === "." && /^\.\w+$/.test(e))
        return t.getElementsByClassName(e.substring(1))
      if (/^\w+$/.test(e)) return t.getElementsByTagName(e)
    }
    return RJ(e, t)
  }
  jA.selectors = Xi
  jA.operators = BJ
  jA.combinators = Db
  jA.matches = function (e, t) {
    var r = { sel: t }
    do if (((r = Tb(r.sel)), r(e))) return true
    while (r.sel)
    return false
  }
})
var tB = _((hSt, TJ) => {
  "use strict"
  var lPe = xs(),
    cPe = rU(),
    _U = function (e, t) {
      for (var r = e.createDocumentFragment(), n = 0; n < t.length; n++) {
        var i = t[n],
          s = i instanceof lPe
        r.appendChild(s ? i : e.createTextNode(String(i)))
      }
      return r
    },
    uPe = {
      after: {
        value: function () {
          var t = Array.prototype.slice.call(arguments),
            r = this.parentNode,
            n = this.nextSibling
          if (r !== null) {
            for (
              ;
              n &&
              t.some(function (s) {
                return s === n
              });

            )
              n = n.nextSibling
            var i = _U(this.doc, t)
            r.insertBefore(i, n)
          }
        },
      },
      before: {
        value: function () {
          var t = Array.prototype.slice.call(arguments),
            r = this.parentNode,
            n = this.previousSibling
          if (r !== null) {
            for (
              ;
              n &&
              t.some(function (o) {
                return o === n
              });

            )
              n = n.previousSibling
            var i = _U(this.doc, t),
              s = n ? n.nextSibling : r.firstChild
            r.insertBefore(i, s)
          }
        },
      },
      remove: {
        value: function () {
          this.parentNode !== null &&
            (this.doc &&
              (this.doc._preremoveNodeIterators(this),
              this.rooted && this.doc.mutateRemove(this)),
            this._remove(),
            (this.parentNode = null))
        },
      },
      _remove: {
        value: function () {
          var t = this.parentNode
          t !== null &&
            (t._childNodes
              ? t._childNodes.splice(this.index, 1)
              : t._firstChild === this &&
                (this._nextSibling === this
                  ? (t._firstChild = null)
                  : (t._firstChild = this._nextSibling)),
            cPe.remove(this),
            t.modify())
        },
      },
      replaceWith: {
        value: function () {
          var t = Array.prototype.slice.call(arguments),
            r = this.parentNode,
            n = this.nextSibling
          if (r !== null) {
            for (
              ;
              n &&
              t.some(function (s) {
                return s === n
              });

            )
              n = n.nextSibling
            var i = _U(this.doc, t)
            this.parentNode === r
              ? r.replaceChild(i, this)
              : r.insertBefore(i, n)
          }
        },
      },
    }
  TJ.exports = uPe
})
var xU = _((gSt, MJ) => {
  "use strict"
  var kJ = xs(),
    dPe = {
      nextElementSibling: {
        get: function () {
          if (this.parentNode) {
            for (var e = this.nextSibling; e !== null; e = e.nextSibling)
              if (e.nodeType === kJ.ELEMENT_NODE) return e
          }
          return null
        },
      },
      previousElementSibling: {
        get: function () {
          if (this.parentNode) {
            for (
              var e = this.previousSibling;
              e !== null;
              e = e.previousSibling
            )
              if (e.nodeType === kJ.ELEMENT_NODE) return e
          }
          return null
        },
      },
    }
  MJ.exports = dPe
})
var wU = _((pSt, QJ) => {
  "use strict"
  QJ.exports = FJ
  var ZA = oi()
  function FJ(e) {
    this.element = e
  }
  Object.defineProperties(FJ.prototype, {
    length: { get: ZA.shouldOverride },
    item: { value: ZA.shouldOverride },
    getNamedItem: {
      value: function (t) {
        return this.element.getAttributeNode(t)
      },
    },
    getNamedItemNS: {
      value: function (t, r) {
        return this.element.getAttributeNodeNS(t, r)
      },
    },
    setNamedItem: { value: ZA.nyi },
    setNamedItemNS: { value: ZA.nyi },
    removeNamedItem: {
      value: function (t) {
        var r = this.element.getAttributeNode(t)
        if (r) return this.element.removeAttribute(t), r
        ZA.NotFoundError()
      },
    },
    removeNamedItemNS: {
      value: function (t, r) {
        var n = this.element.getAttributeNodeNS(t, r)
        if (n) return this.element.removeAttributeNS(t, r), n
        ZA.NotFoundError()
      },
    },
  })
})
var e0 = _((mSt, OJ) => {
  "use strict"
  OJ.exports = th
  var SU = JI(),
    Kn = oi(),
    mu = Kn.NAMESPACE,
    nB = AU(),
    vc = xs(),
    IU = up(),
    fPe = nU(),
    rB = bJ(),
    XA = GI(),
    hPe = vU(),
    BU = eB(),
    PJ = zI(),
    gPe = tB(),
    pPe = xU(),
    LJ = wU(),
    NJ = Object.create(null)
  function th(e, t, r, n) {
    PJ.call(this),
      (this.nodeType = vc.ELEMENT_NODE),
      (this.ownerDocument = e),
      (this.localName = t),
      (this.namespaceURI = r),
      (this.prefix = n),
      (this._tagName = undefined),
      (this._attrsByQName = Object.create(null)),
      (this._attrsByLName = Object.create(null)),
      (this._attrKeys = [])
  }
  function RU(e, t) {
    if (e.nodeType === vc.TEXT_NODE) t.push(e._data)
    else
      for (var r = 0, n = e.childNodes.length; r < n; r++)
        RU(e.childNodes[r], t)
  }
  th.prototype = Object.create(PJ.prototype, {
    isHTML: {
      get: function () {
        return this.namespaceURI === mu.HTML && this.ownerDocument.isHTML
      },
    },
    tagName: {
      get: function () {
        if (this._tagName === undefined) {
          var t
          if (
            (this.prefix === null
              ? (t = this.localName)
              : (t = this.prefix + ":" + this.localName),
            this.isHTML)
          ) {
            var r = NJ[t]
            r || (NJ[t] = r = Kn.toASCIIUpperCase(t)), (t = r)
          }
          this._tagName = t
        }
        return this._tagName
      },
    },
    nodeName: {
      get: function () {
        return this.tagName
      },
    },
    nodeValue: {
      get: function () {
        return null
      },
      set: function () {},
    },
    textContent: {
      get: function () {
        var e = []
        return RU(this, e), e.join("")
      },
      set: function (e) {
        this.removeChildren(),
          e != null &&
            e !== "" &&
            this._appendChild(this.ownerDocument.createTextNode(e))
      },
    },
    innerText: {
      get: function () {
        var e = []
        return (
          RU(this, e),
          e
            .join("")
            .replace(/[ \t\n\f\r]+/g, " ")
            .trim()
        )
      },
      set: function (e) {
        this.removeChildren(),
          e != null &&
            e !== "" &&
            this._appendChild(this.ownerDocument.createTextNode(e))
      },
    },
    innerHTML: {
      get: function () {
        return this.serialize()
      },
      set: Kn.nyi,
    },
    outerHTML: {
      get: function () {
        return fPe.serializeOne(this, { nodeType: 0 })
      },
      set: function (e) {
        var t = this.ownerDocument,
          r = this.parentNode
        if (r !== null) {
          r.nodeType === vc.DOCUMENT_NODE && Kn.NoModificationAllowedError(),
            r.nodeType === vc.DOCUMENT_FRAGMENT_NODE &&
              (r = r.ownerDocument.createElement("body"))
          var n = t.implementation.mozHTMLParser(t._address, r)
          n.parse(e === null ? "" : String(e), true),
            this.replaceWith(n._asDocumentFragment())
        }
      },
    },
    _insertAdjacent: {
      value: function (t, r) {
        var n = false
        switch (t) {
          case "beforebegin":
            n = true
          case "afterend":
            var i = this.parentNode
            return i === null
              ? null
              : i.insertBefore(r, n ? this : this.nextSibling)
          case "afterbegin":
            n = true
          case "beforeend":
            return this.insertBefore(r, n ? this.firstChild : null)
          default:
            return Kn.SyntaxError()
        }
      },
    },
    insertAdjacentElement: {
      value: function (t, r) {
        if (r.nodeType !== vc.ELEMENT_NODE)
          throw new TypeError("not an element")
        return (t = Kn.toASCIILowerCase(String(t))), this._insertAdjacent(t, r)
      },
    },
    insertAdjacentText: {
      value: function (t, r) {
        var n = this.ownerDocument.createTextNode(r)
        ;(t = Kn.toASCIILowerCase(String(t))), this._insertAdjacent(t, n)
      },
    },
    insertAdjacentHTML: {
      value: function (t, r) {
        ;(t = Kn.toASCIILowerCase(String(t))), (r = String(r))
        var n
        switch (t) {
          case "beforebegin":
          case "afterend":
            ;(n = this.parentNode),
              (n === null || n.nodeType === vc.DOCUMENT_NODE) &&
                Kn.NoModificationAllowedError()
            break
          case "afterbegin":
          case "beforeend":
            n = this
            break
          default:
            Kn.SyntaxError()
        }
        ;(!(n instanceof th) ||
          (n.ownerDocument.isHTML &&
            n.localName === "html" &&
            n.namespaceURI === mu.HTML)) &&
          (n = n.ownerDocument.createElementNS(mu.HTML, "body"))
        var i = this.ownerDocument.implementation.mozHTMLParser(
          this.ownerDocument._address,
          n,
        )
        i.parse(r, true), this._insertAdjacent(t, i._asDocumentFragment())
      },
    },
    children: {
      get: function () {
        return this._children || (this._children = new UJ(this)), this._children
      },
    },
    attributes: {
      get: function () {
        return (
          this._attributes || (this._attributes = new TU(this)),
          this._attributes
        )
      },
    },
    firstElementChild: {
      get: function () {
        for (var e = this.firstChild; e !== null; e = e.nextSibling)
          if (e.nodeType === vc.ELEMENT_NODE) return e
        return null
      },
    },
    lastElementChild: {
      get: function () {
        for (var e = this.lastChild; e !== null; e = e.previousSibling)
          if (e.nodeType === vc.ELEMENT_NODE) return e
        return null
      },
    },
    childElementCount: {
      get: function () {
        return this.children.length
      },
    },
    nextElement: {
      value: function (e) {
        e || (e = this.ownerDocument.documentElement)
        var t = this.firstElementChild
        if (!t) {
          if (this === e) return null
          t = this.nextElementSibling
        }
        if (t) return t
        for (var r = this.parentElement; r && r !== e; r = r.parentElement)
          if (((t = r.nextElementSibling), t)) return t
        return null
      },
    },
    getElementsByTagName: {
      value: function (t) {
        var r
        return t
          ? (t === "*"
              ? (r = function () {
                  return true
                })
              : this.isHTML
                ? (r = mPe(t))
                : (r = DU(t)),
            new rB(this, r))
          : new IU()
      },
    },
    getElementsByTagNameNS: {
      value: function (t, r) {
        var n
        return (
          t === "*" && r === "*"
            ? (n = function () {
                return true
              })
            : t === "*"
              ? (n = DU(r))
              : r === "*"
                ? (n = APe(t))
                : (n = yPe(t, r)),
          new rB(this, n)
        )
      },
    },
    getElementsByClassName: {
      value: function (t) {
        if (((t = String(t).trim()), t === "")) {
          var r = new IU()
          return r
        }
        return (t = t.split(/[ \t\r\n\f]+/)), new rB(this, vPe(t))
      },
    },
    getElementsByName: {
      value: function (t) {
        return new rB(this, CPe(String(t)))
      },
    },
    clone: {
      value: function () {
        var t
        this.namespaceURI !== mu.HTML ||
        this.prefix ||
        !this.ownerDocument.isHTML
          ? (t = this.ownerDocument.createElementNS(
              this.namespaceURI,
              this.prefix !== null
                ? this.prefix + ":" + this.localName
                : this.localName,
            ))
          : (t = this.ownerDocument.createElement(this.localName))
        for (var r = 0, n = this._attrKeys.length; r < n; r++) {
          var i = this._attrKeys[r],
            s = this._attrsByLName[i],
            o = s.cloneNode()
          o._setOwnerElement(t), (t._attrsByLName[i] = o), t._addQName(o)
        }
        return (t._attrKeys = this._attrKeys.concat()), t
      },
    },
    isEqual: {
      value: function (t) {
        if (
          this.localName !== t.localName ||
          this.namespaceURI !== t.namespaceURI ||
          this.prefix !== t.prefix ||
          this._numattrs !== t._numattrs
        )
          return false
        for (var r = 0, n = this._numattrs; r < n; r++) {
          var i = this._attr(r)
          if (
            !t.hasAttributeNS(i.namespaceURI, i.localName) ||
            t.getAttributeNS(i.namespaceURI, i.localName) !== i.value
          )
            return false
        }
        return true
      },
    },
    _lookupNamespacePrefix: {
      value: function (t, r) {
        if (
          this.namespaceURI &&
          this.namespaceURI === t &&
          this.prefix !== null &&
          r.lookupNamespaceURI(this.prefix) === t
        )
          return this.prefix
        for (var n = 0, i = this._numattrs; n < i; n++) {
          var s = this._attr(n)
          if (
            s.prefix === "xmlns" &&
            s.value === t &&
            r.lookupNamespaceURI(s.localName) === t
          )
            return s.localName
        }
        var o = this.parentElement
        return o ? o._lookupNamespacePrefix(t, r) : null
      },
    },
    lookupNamespaceURI: {
      value: function (t) {
        if (
          ((t === "" || t === undefined) && (t = null),
          this.namespaceURI !== null && this.prefix === t)
        )
          return this.namespaceURI
        for (var r = 0, n = this._numattrs; r < n; r++) {
          var i = this._attr(r)
          if (
            i.namespaceURI === mu.XMLNS &&
            ((i.prefix === "xmlns" && i.localName === t) ||
              (t === null && i.prefix === null && i.localName === "xmlns"))
          )
            return i.value || null
        }
        var s = this.parentElement
        return s ? s.lookupNamespaceURI(t) : null
      },
    },
    getAttribute: {
      value: function (t) {
        var r = this.getAttributeNode(t)
        return r ? r.value : null
      },
    },
    getAttributeNS: {
      value: function (t, r) {
        var n = this.getAttributeNodeNS(t, r)
        return n ? n.value : null
      },
    },
    getAttributeNode: {
      value: function (t) {
        ;(t = String(t)),
          /[A-Z]/.test(t) && this.isHTML && (t = Kn.toASCIILowerCase(t))
        var r = this._attrsByQName[t]
        return r ? (Array.isArray(r) && (r = r[0]), r) : null
      },
    },
    getAttributeNodeNS: {
      value: function (t, r) {
        ;(t = t == null ? "" : String(t)), (r = String(r))
        var n = this._attrsByLName[t + "|" + r]
        return n || null
      },
    },
    hasAttribute: {
      value: function (t) {
        return (
          (t = String(t)),
          /[A-Z]/.test(t) && this.isHTML && (t = Kn.toASCIILowerCase(t)),
          this._attrsByQName[t] !== undefined
        )
      },
    },
    hasAttributeNS: {
      value: function (t, r) {
        ;(t = t == null ? "" : String(t)), (r = String(r))
        var n = t + "|" + r
        return this._attrsByLName[n] !== undefined
      },
    },
    hasAttributes: {
      value: function () {
        return this._numattrs > 0
      },
    },
    toggleAttribute: {
      value: function (t, r) {
        ;(t = String(t)),
          SU.isValidName(t) || Kn.InvalidCharacterError(),
          /[A-Z]/.test(t) && this.isHTML && (t = Kn.toASCIILowerCase(t))
        var n = this._attrsByQName[t]
        return n === undefined
          ? r === undefined || r === true
            ? (this._setAttribute(t, ""), true)
            : false
          : r === undefined || r === false
            ? (this.removeAttribute(t), false)
            : true
      },
    },
    _setAttribute: {
      value: function (t, r) {
        var n = this._attrsByQName[t],
          i
        n ? Array.isArray(n) && (n = n[0]) : ((n = this._newattr(t)), (i = true)),
          (n.value = r),
          this._attributes && (this._attributes[t] = n),
          i && this._newattrhook && this._newattrhook(t, r)
      },
    },
    setAttribute: {
      value: function (t, r) {
        ;(t = String(t)),
          SU.isValidName(t) || Kn.InvalidCharacterError(),
          /[A-Z]/.test(t) && this.isHTML && (t = Kn.toASCIILowerCase(t)),
          this._setAttribute(t, String(r))
      },
    },
    _setAttributeNS: {
      value: function (t, r, n) {
        var i = r.indexOf(":"),
          s,
          o
        i < 0
          ? ((s = null), (o = r))
          : ((s = r.substring(0, i)), (o = r.substring(i + 1))),
          (t === "" || t === undefined) && (t = null)
        var a = (t === null ? "" : t) + "|" + o,
          l = this._attrsByLName[a],
          c
        l ||
          ((l = new kb(this, o, s, t)),
          (c = true),
          (this._attrsByLName[a] = l),
          this._attributes && (this._attributes[this._attrKeys.length] = l),
          this._attrKeys.push(a),
          this._addQName(l)),
          (l.value = n),
          c && this._newattrhook && this._newattrhook(r, n)
      },
    },
    setAttributeNS: {
      value: function (t, r, n) {
        ;(t = t == null || t === "" ? null : String(t)),
          (r = String(r)),
          SU.isValidQName(r) || Kn.InvalidCharacterError()
        var i = r.indexOf(":"),
          s = i < 0 ? null : r.substring(0, i)
        ;((s !== null && t === null) ||
          (s === "xml" && t !== mu.XML) ||
          ((r === "xmlns" || s === "xmlns") && t !== mu.XMLNS) ||
          (t === mu.XMLNS && !(r === "xmlns" || s === "xmlns"))) &&
          Kn.NamespaceError(),
          this._setAttributeNS(t, r, String(n))
      },
    },
    setAttributeNode: {
      value: function (t) {
        if (t.ownerElement !== null && t.ownerElement !== this)
          throw new XA(XA.INUSE_ATTRIBUTE_ERR)
        var r = null,
          n = this._attrsByQName[t.name]
        if (n) {
          if (
            (Array.isArray(n) || (n = [n]),
            n.some(function (i) {
              return i === t
            }))
          )
            return t
          if (t.ownerElement !== null) throw new XA(XA.INUSE_ATTRIBUTE_ERR)
          n.forEach(function (i) {
            this.removeAttributeNode(i)
          }, this),
            (r = n[0])
        }
        return this.setAttributeNodeNS(t), r
      },
    },
    setAttributeNodeNS: {
      value: function (t) {
        if (t.ownerElement !== null) throw new XA(XA.INUSE_ATTRIBUTE_ERR)
        var r = t.namespaceURI,
          n = (r === null ? "" : r) + "|" + t.localName,
          i = this._attrsByLName[n]
        return (
          i && this.removeAttributeNode(i),
          t._setOwnerElement(this),
          (this._attrsByLName[n] = t),
          this._attributes && (this._attributes[this._attrKeys.length] = t),
          this._attrKeys.push(n),
          this._addQName(t),
          this._newattrhook && this._newattrhook(t.name, t.value),
          i || null
        )
      },
    },
    removeAttribute: {
      value: function (t) {
        ;(t = String(t)),
          /[A-Z]/.test(t) && this.isHTML && (t = Kn.toASCIILowerCase(t))
        var r = this._attrsByQName[t]
        if (r) {
          Array.isArray(r)
            ? r.length > 2
              ? (r = r.shift())
              : ((this._attrsByQName[t] = r[1]), (r = r[0]))
            : (this._attrsByQName[t] = undefined)
          var n = r.namespaceURI,
            i = (n === null ? "" : n) + "|" + r.localName
          this._attrsByLName[i] = undefined
          var s = this._attrKeys.indexOf(i)
          this._attributes &&
            (Array.prototype.splice.call(this._attributes, s, 1),
            (this._attributes[t] = undefined)),
            this._attrKeys.splice(s, 1)
          var o = r.onchange
          r._setOwnerElement(null),
            o && o.call(r, this, r.localName, r.value, null),
            this.rooted && this.ownerDocument.mutateRemoveAttr(r)
        }
      },
    },
    removeAttributeNS: {
      value: function (t, r) {
        ;(t = t == null ? "" : String(t)), (r = String(r))
        var n = t + "|" + r,
          i = this._attrsByLName[n]
        if (i) {
          this._attrsByLName[n] = undefined
          var s = this._attrKeys.indexOf(n)
          this._attributes &&
            Array.prototype.splice.call(this._attributes, s, 1),
            this._attrKeys.splice(s, 1),
            this._removeQName(i)
          var o = i.onchange
          i._setOwnerElement(null),
            o && o.call(i, this, i.localName, i.value, null),
            this.rooted && this.ownerDocument.mutateRemoveAttr(i)
        }
      },
    },
    removeAttributeNode: {
      value: function (t) {
        var r = t.namespaceURI,
          n = (r === null ? "" : r) + "|" + t.localName
        return (
          this._attrsByLName[n] !== t && Kn.NotFoundError(),
          this.removeAttributeNS(r, t.localName),
          t
        )
      },
    },
    getAttributeNames: {
      value: function () {
        var t = this
        return this._attrKeys.map(function (r) {
          return t._attrsByLName[r].name
        })
      },
    },
    _getattr: {
      value: function (t) {
        var r = this._attrsByQName[t]
        return r ? r.value : null
      },
    },
    _setattr: {
      value: function (t, r) {
        var n = this._attrsByQName[t],
          i
        n || ((n = this._newattr(t)), (i = true)),
          (n.value = String(r)),
          this._attributes && (this._attributes[t] = n),
          i && this._newattrhook && this._newattrhook(t, r)
      },
    },
    _newattr: {
      value: function (t) {
        var r = new kb(this, t, null, null),
          n = "|" + t
        return (
          (this._attrsByQName[t] = r),
          (this._attrsByLName[n] = r),
          this._attributes && (this._attributes[this._attrKeys.length] = r),
          this._attrKeys.push(n),
          r
        )
      },
    },
    _addQName: {
      value: function (e) {
        var t = e.name,
          r = this._attrsByQName[t]
        r
          ? Array.isArray(r)
            ? r.push(e)
            : (this._attrsByQName[t] = [r, e])
          : (this._attrsByQName[t] = e),
          this._attributes && (this._attributes[t] = e)
      },
    },
    _removeQName: {
      value: function (e) {
        var t = e.name,
          r = this._attrsByQName[t]
        if (Array.isArray(r)) {
          var n = r.indexOf(e)
          Kn.assert(n !== -1),
            r.length === 2
              ? ((this._attrsByQName[t] = r[1 - n]),
                this._attributes &&
                  (this._attributes[t] = this._attrsByQName[t]))
              : (r.splice(n, 1),
                this._attributes &&
                  this._attributes[t] === e &&
                  (this._attributes[t] = r[0]))
        } else
          Kn.assert(r === e),
            (this._attrsByQName[t] = undefined),
            this._attributes && (this._attributes[t] = undefined)
      },
    },
    _numattrs: {
      get: function () {
        return this._attrKeys.length
      },
    },
    _attr: {
      value: function (e) {
        return this._attrsByLName[this._attrKeys[e]]
      },
    },
    id: nB.property({ name: "id" }),
    className: nB.property({ name: "class" }),
    classList: {
      get: function () {
        var e = this
        if (this._classList) return this._classList
        var t = new hPe(
          function () {
            return e.className || ""
          },
          function (r) {
            e.className = r
          },
        )
        return (this._classList = t), t
      },
      set: function (e) {
        this.className = e
      },
    },
    matches: {
      value: function (e) {
        return BU.matches(this, e)
      },
    },
    closest: {
      value: function (e) {
        var t = this
        do {
          if (t.matches && t.matches(e)) return t
          t = t.parentElement || t.parentNode
        } while (t !== null && t.nodeType === vc.ELEMENT_NODE)
        return null
      },
    },
    querySelector: {
      value: function (e) {
        return BU(e, this)[0]
      },
    },
    querySelectorAll: {
      value: function (e) {
        var t = BU(e, this)
        return t.item ? t : new IU(t)
      },
    },
  })
  Object.defineProperties(th.prototype, gPe)
  Object.defineProperties(th.prototype, pPe)
  nB.registerChangeHandler(th, "id", function (e, t, r, n) {
    e.rooted &&
      (r && e.ownerDocument.delId(r, e), n && e.ownerDocument.addId(n, e))
  })
  nB.registerChangeHandler(th, "class", function (e, t, r, n) {
    e._classList && e._classList._update()
  })
  function kb(e, t, r, n, i) {
    ;(this.localName = t),
      (this.prefix = r === null || r === "" ? null : "" + r),
      (this.namespaceURI = n === null || n === "" ? null : "" + n),
      (this.data = i),
      this._setOwnerElement(e)
  }
  kb.prototype = Object.create(Object.prototype, {
    ownerElement: {
      get: function () {
        return this._ownerElement
      },
    },
    _setOwnerElement: {
      value: function (t) {
        ;(this._ownerElement = t),
          this.prefix === null && this.namespaceURI === null && t
            ? (this.onchange = t._attributeChangeHandlers[this.localName])
            : (this.onchange = null)
      },
    },
    name: {
      get: function () {
        return this.prefix ? this.prefix + ":" + this.localName : this.localName
      },
    },
    specified: {
      get: function () {
        return true
      },
    },
    value: {
      get: function () {
        return this.data
      },
      set: function (e) {
        var t = this.data
        ;(e = e === undefined ? "" : e + ""),
          e !== t &&
            ((this.data = e),
            this.ownerElement &&
              (this.onchange &&
                this.onchange(this.ownerElement, this.localName, t, e),
              this.ownerElement.rooted &&
                this.ownerElement.ownerDocument.mutateAttr(this, t)))
      },
    },
    cloneNode: {
      value: function (t) {
        return new kb(
          null,
          this.localName,
          this.prefix,
          this.namespaceURI,
          this.data,
        )
      },
    },
    nodeType: {
      get: function () {
        return vc.ATTRIBUTE_NODE
      },
    },
    nodeName: {
      get: function () {
        return this.name
      },
    },
    nodeValue: {
      get: function () {
        return this.value
      },
      set: function (e) {
        this.value = e
      },
    },
    textContent: {
      get: function () {
        return this.value
      },
      set: function (e) {
        e == null && (e = ""), (this.value = e)
      },
    },
    innerText: {
      get: function () {
        return this.value
      },
      set: function (e) {
        e == null && (e = ""), (this.value = e)
      },
    },
  })
  th._Attr = kb
  function TU(e) {
    LJ.call(this, e)
    for (var t in e._attrsByQName) this[t] = e._attrsByQName[t]
    for (var r = 0; r < e._attrKeys.length; r++)
      this[r] = e._attrsByLName[e._attrKeys[r]]
  }
  TU.prototype = Object.create(LJ.prototype, {
    length: {
      get: function () {
        return this.element._attrKeys.length
      },
      set: function () {},
    },
    item: {
      value: function (e) {
        return (
          (e = e >>> 0),
          e >= this.length
            ? null
            : this.element._attrsByLName[this.element._attrKeys[e]]
        )
      },
    },
  })
  globalThis.Symbol?.iterator &&
    (TU.prototype[globalThis.Symbol.iterator] = function () {
      var e = 0,
        t = this.length,
        r = this
      return {
        next: function () {
          return e < t ? { value: r.item(e++) } : { done: true }
        },
      }
    })
  function UJ(e) {
    ;(this.element = e), this.updateCache()
  }
  UJ.prototype = Object.create(Object.prototype, {
    length: {
      get: function () {
        return this.updateCache(), this.childrenByNumber.length
      },
    },
    item: {
      value: function (t) {
        return this.updateCache(), this.childrenByNumber[t] || null
      },
    },
    namedItem: {
      value: function (t) {
        return this.updateCache(), this.childrenByName[t] || null
      },
    },
    namedItems: {
      get: function () {
        return this.updateCache(), this.childrenByName
      },
    },
    updateCache: {
      value: function () {
        var t = /^(a|applet|area|embed|form|frame|frameset|iframe|img|object)$/
        if (this.lastModTime !== this.element.lastModTime) {
          this.lastModTime = this.element.lastModTime
          for (
            var r =
                (this.childrenByNumber && this.childrenByNumber.length) || 0,
              n = 0;
            n < r;
            n++
          )
            this[n] = undefined
          ;(this.childrenByNumber = []),
            (this.childrenByName = Object.create(null))
          for (var i = this.element.firstChild; i !== null; i = i.nextSibling)
            if (i.nodeType === vc.ELEMENT_NODE) {
              ;(this[this.childrenByNumber.length] = i),
                this.childrenByNumber.push(i)
              var s = i.getAttribute("id")
              s && !this.childrenByName[s] && (this.childrenByName[s] = i)
              var o = i.getAttribute("name")
              o &&
                this.element.namespaceURI === mu.HTML &&
                t.test(this.element.localName) &&
                !this.childrenByName[o] &&
                (this.childrenByName[s] = i)
            }
        }
      },
    },
  })
  function DU(e) {
    return function (t) {
      return t.localName === e
    }
  }
  function mPe(e) {
    var t = Kn.toASCIILowerCase(e)
    return t === e
      ? DU(e)
      : function (r) {
          return r.isHTML ? r.localName === t : r.localName === e
        }
  }
  function APe(e) {
    return function (t) {
      return t.namespaceURI === e
    }
  }
  function yPe(e, t) {
    return function (r) {
      return r.namespaceURI === e && r.localName === t
    }
  }
  function vPe(e) {
    return function (t) {
      return e.every(function (r) {
        return t.classList.contains(r)
      })
    }
  }
  function CPe(e) {
    return function (t) {
      return t.namespaceURI !== mu.HTML ? false : t.getAttribute("name") === e
    }
  }
})
var kU = _((ASt, GJ) => {
  "use strict"
  GJ.exports = WJ
  var VJ = xs(),
    bPe = up(),
    HJ = oi(),
    qJ = HJ.HierarchyRequestError,
    EPe = HJ.NotFoundError
  function WJ() {
    VJ.call(this)
  }
  WJ.prototype = Object.create(VJ.prototype, {
    hasChildNodes: {
      value: function () {
        return false
      },
    },
    firstChild: { value: null },
    lastChild: { value: null },
    insertBefore: {
      value: function (e, t) {
        if (!e.nodeType) throw new TypeError("not a node")
        qJ()
      },
    },
    replaceChild: {
      value: function (e, t) {
        if (!e.nodeType) throw new TypeError("not a node")
        qJ()
      },
    },
    removeChild: {
      value: function (e) {
        if (!e.nodeType) throw new TypeError("not a node")
        EPe()
      },
    },
    removeChildren: { value: function () {} },
    childNodes: {
      get: function () {
        return (
          this._childNodes || (this._childNodes = new bPe()), this._childNodes
        )
      },
    },
  })
})
var Mb = _((ySt, KJ) => {
  "use strict"
  KJ.exports = iB
  var YJ = kU(),
    $J = oi(),
    _Pe = tB(),
    xPe = xU()
  function iB() {
    YJ.call(this)
  }
  iB.prototype = Object.create(YJ.prototype, {
    substringData: {
      value: function (t, r) {
        if (arguments.length < 2) throw new TypeError("Not enough arguments")
        return (
          (t = t >>> 0),
          (r = r >>> 0),
          (t > this.data.length || t < 0 || r < 0) && $J.IndexSizeError(),
          this.data.substring(t, t + r)
        )
      },
    },
    appendData: {
      value: function (t) {
        if (arguments.length < 1) throw new TypeError("Not enough arguments")
        this.data += String(t)
      },
    },
    insertData: {
      value: function (t, r) {
        return this.replaceData(t, 0, r)
      },
    },
    deleteData: {
      value: function (t, r) {
        return this.replaceData(t, r, "")
      },
    },
    replaceData: {
      value: function (t, r, n) {
        var i = this.data,
          s = i.length
        ;(t = t >>> 0),
          (r = r >>> 0),
          (n = String(n)),
          (t > s || t < 0) && $J.IndexSizeError(),
          t + r > s && (r = s - t)
        var o = i.substring(0, t),
          a = i.substring(t + r)
        this.data = o + n + a
      },
    },
    isEqual: {
      value: function (t) {
        return this._data === t._data
      },
    },
    length: {
      get: function () {
        return this.data.length
      },
    },
  })
  Object.defineProperties(iB.prototype, _Pe)
  Object.defineProperties(iB.prototype, xPe)
})
var FU = _((vSt, ZJ) => {
  "use strict"
  ZJ.exports = MU
  var zJ = oi(),
    JJ = xs(),
    jJ = Mb()
  function MU(e, t) {
    jJ.call(this),
      (this.nodeType = JJ.TEXT_NODE),
      (this.ownerDocument = e),
      (this._data = t),
      (this._index = undefined)
  }
  var Fb = {
    get: function () {
      return this._data
    },
    set: function (e) {
      e == null ? (e = "") : (e = String(e)),
        e !== this._data &&
          ((this._data = e),
          this.rooted && this.ownerDocument.mutateValue(this),
          this.parentNode &&
            this.parentNode._textchangehook &&
            this.parentNode._textchangehook(this))
    },
  }
  MU.prototype = Object.create(jJ.prototype, {
    nodeName: { value: "#text" },
    nodeValue: Fb,
    textContent: Fb,
    innerText: Fb,
    data: {
      get: Fb.get,
      set: function (e) {
        Fb.set.call(this, e === null ? "" : String(e))
      },
    },
    splitText: {
      value: function (t) {
        ;(t > this._data.length || t < 0) && zJ.IndexSizeError()
        var r = this._data.substring(t),
          n = this.ownerDocument.createTextNode(r)
        this.data = this.data.substring(0, t)
        var i = this.parentNode
        return i !== null && i.insertBefore(n, this.nextSibling), n
      },
    },
    wholeText: {
      get: function () {
        for (
          var t = this.textContent, r = this.nextSibling;
          r && r.nodeType === JJ.TEXT_NODE;
          r = r.nextSibling
        )
          t += r.textContent
        return t
      },
    },
    replaceWholeText: { value: zJ.nyi },
    clone: {
      value: function () {
        return new MU(this.ownerDocument, this._data)
      },
    },
  })
})
var NU = _((CSt, ej) => {
  "use strict"
  ej.exports = QU
  var wPe = xs(),
    XJ = Mb()
  function QU(e, t) {
    XJ.call(this),
      (this.nodeType = wPe.COMMENT_NODE),
      (this.ownerDocument = e),
      (this._data = t)
  }
  var Qb = {
    get: function () {
      return this._data
    },
    set: function (e) {
      e == null ? (e = "") : (e = String(e)),
        (this._data = e),
        this.rooted && this.ownerDocument.mutateValue(this)
    },
  }
  QU.prototype = Object.create(XJ.prototype, {
    nodeName: { value: "#comment" },
    nodeValue: Qb,
    textContent: Qb,
    innerText: Qb,
    data: {
      get: Qb.get,
      set: function (e) {
        Qb.set.call(this, e === null ? "" : String(e))
      },
    },
    clone: {
      value: function () {
        return new QU(this.ownerDocument, this._data)
      },
    },
  })
})
var LU = _((bSt, nj) => {
  "use strict"
  nj.exports = PU
  var SPe = xs(),
    IPe = up(),
    rj = zI(),
    sB = e0(),
    BPe = eB(),
    tj = oi()
  function PU(e) {
    rj.call(this),
      (this.nodeType = SPe.DOCUMENT_FRAGMENT_NODE),
      (this.ownerDocument = e)
  }
  PU.prototype = Object.create(rj.prototype, {
    nodeName: { value: "#document-fragment" },
    nodeValue: {
      get: function () {
        return null
      },
      set: function () {},
    },
    textContent: Object.getOwnPropertyDescriptor(sB.prototype, "textContent"),
    innerText: Object.getOwnPropertyDescriptor(sB.prototype, "innerText"),
    querySelector: {
      value: function (e) {
        var t = this.querySelectorAll(e)
        return t.length ? t[0] : null
      },
    },
    querySelectorAll: {
      value: function (e) {
        var t = Object.create(this)
        ;(t.isHTML = true),
          (t.getElementsByTagName = sB.prototype.getElementsByTagName),
          (t.nextElement = Object.getOwnPropertyDescriptor(
            sB.prototype,
            "firstElementChild",
          ).get)
        var r = BPe(e, t)
        return r.item ? r : new IPe(r)
      },
    },
    clone: {
      value: function () {
        return new PU(this.ownerDocument)
      },
    },
    isEqual: {
      value: function (t) {
        return true
      },
    },
    innerHTML: {
      get: function () {
        return this.serialize()
      },
      set: tj.nyi,
    },
    outerHTML: {
      get: function () {
        return this.serialize()
      },
      set: tj.nyi,
    },
  })
})
var OU = _((ESt, sj) => {
  "use strict"
  sj.exports = UU
  var RPe = xs(),
    ij = Mb()
  function UU(e, t, r) {
    ij.call(this),
      (this.nodeType = RPe.PROCESSING_INSTRUCTION_NODE),
      (this.ownerDocument = e),
      (this.target = t),
      (this._data = r)
  }
  var Nb = {
    get: function () {
      return this._data
    },
    set: function (e) {
      e == null ? (e = "") : (e = String(e)),
        (this._data = e),
        this.rooted && this.ownerDocument.mutateValue(this)
    },
  }
  UU.prototype = Object.create(ij.prototype, {
    nodeName: {
      get: function () {
        return this.target
      },
    },
    nodeValue: Nb,
    textContent: Nb,
    innerText: Nb,
    data: {
      get: Nb.get,
      set: function (e) {
        Nb.set.call(this, e === null ? "" : String(e))
      },
    },
    clone: {
      value: function () {
        return new UU(this.ownerDocument, this.target, this._data)
      },
    },
    isEqual: {
      value: function (t) {
        return this.target === t.target && this._data === t._data
      },
    },
  })
})
var Pb = _((_St, oj) => {
  "use strict"
  var qU = {
    FILTER_ACCEPT: 1,
    FILTER_REJECT: 2,
    FILTER_SKIP: 3,
    SHOW_ALL: 4294967295,
    SHOW_ELEMENT: 1,
    SHOW_ATTRIBUTE: 2,
    SHOW_TEXT: 4,
    SHOW_CDATA_SECTION: 8,
    SHOW_ENTITY_REFERENCE: 16,
    SHOW_ENTITY: 32,
    SHOW_PROCESSING_INSTRUCTION: 64,
    SHOW_COMMENT: 128,
    SHOW_DOCUMENT: 256,
    SHOW_DOCUMENT_TYPE: 512,
    SHOW_DOCUMENT_FRAGMENT: 1024,
    SHOW_NOTATION: 2048,
  }
  oj.exports = qU.constructor = qU.prototype = qU
})
var HU = _((wSt, lj) => {
  "use strict"
  var xSt = (lj.exports = {
    nextSkippingChildren: DPe,
    nextAncestorSibling: VU,
    next: TPe,
    previous: kPe,
    deepLastChild: aj,
  })
  function DPe(e, t) {
    return e === t ? null : e.nextSibling !== null ? e.nextSibling : VU(e, t)
  }
  function VU(e, t) {
    for (e = e.parentNode; e !== null; e = e.parentNode) {
      if (e === t) return null
      if (e.nextSibling !== null) return e.nextSibling
    }
    return null
  }
  function TPe(e, t) {
    var r
    return (
      (r = e.firstChild),
      r !== null
        ? r
        : e === t
          ? null
          : ((r = e.nextSibling), r !== null ? r : VU(e, t))
    )
  }
  function aj(e) {
    for (; e.lastChild; ) e = e.lastChild
    return e
  }
  function kPe(e, t) {
    var r
    return (
      (r = e.previousSibling),
      r !== null ? aj(r) : ((r = e.parentNode), r === t ? null : r)
    )
  }
})
var pj = _((SSt, gj) => {
  "use strict"
  gj.exports = hj
  var MPe = xs(),
    ws = Pb(),
    cj = HU(),
    fj = oi(),
    WU = {
      first: "firstChild",
      last: "lastChild",
      next: "firstChild",
      previous: "lastChild",
    },
    GU = {
      first: "nextSibling",
      last: "previousSibling",
      next: "nextSibling",
      previous: "previousSibling",
    }
  function uj(e, t) {
    var r, n, i, s, o
    for (n = e._currentNode[WU[t]]; n !== null; ) {
      if (((s = e._internalFilter(n)), s === ws.FILTER_ACCEPT))
        return (e._currentNode = n), n
      if (s === ws.FILTER_SKIP && ((r = n[WU[t]]), r !== null)) {
        n = r
        continue
      }
      for (; n !== null; ) {
        if (((o = n[GU[t]]), o !== null)) {
          n = o
          break
        }
        if (
          ((i = n.parentNode),
          i === null || i === e.root || i === e._currentNode)
        )
          return null
        n = i
      }
    }
    return null
  }
  function dj(e, t) {
    var r, n, i
    if (((r = e._currentNode), r === e.root)) return null
    for (;;) {
      for (i = r[GU[t]]; i !== null; ) {
        if (((r = i), (n = e._internalFilter(r)), n === ws.FILTER_ACCEPT))
          return (e._currentNode = r), r
        ;(i = r[WU[t]]),
          (n === ws.FILTER_REJECT || i === null) && (i = r[GU[t]])
      }
      if (
        ((r = r.parentNode),
        r === null || r === e.root || e._internalFilter(r) === ws.FILTER_ACCEPT)
      )
        return null
    }
  }
  function hj(e, t, r) {
    ;(!e || !e.nodeType) && fj.NotSupportedError(),
      (this._root = e),
      (this._whatToShow = Number(t) || 0),
      (this._filter = r || null),
      (this._active = false),
      (this._currentNode = e)
  }
  Object.defineProperties(hj.prototype, {
    root: {
      get: function () {
        return this._root
      },
    },
    whatToShow: {
      get: function () {
        return this._whatToShow
      },
    },
    filter: {
      get: function () {
        return this._filter
      },
    },
    currentNode: {
      get: function () {
        return this._currentNode
      },
      set: function (t) {
        if (!(t instanceof MPe)) throw new TypeError("Not a Node")
        this._currentNode = t
      },
    },
    _internalFilter: {
      value: function (t) {
        var r, n
        if (
          (this._active && fj.InvalidStateError(),
          !((1 << (t.nodeType - 1)) & this._whatToShow))
        )
          return ws.FILTER_SKIP
        if (((n = this._filter), n === null)) r = ws.FILTER_ACCEPT
        else {
          this._active = true
          try {
            typeof n == "function" ? (r = n(t)) : (r = n.acceptNode(t))
          } finally {
            this._active = false
          }
        }
        return +r
      },
    },
    parentNode: {
      value: function () {
        for (var t = this._currentNode; t !== this.root; ) {
          if (((t = t.parentNode), t === null)) return null
          if (this._internalFilter(t) === ws.FILTER_ACCEPT)
            return (this._currentNode = t), t
        }
        return null
      },
    },
    firstChild: {
      value: function () {
        return uj(this, "first")
      },
    },
    lastChild: {
      value: function () {
        return uj(this, "last")
      },
    },
    previousSibling: {
      value: function () {
        return dj(this, "previous")
      },
    },
    nextSibling: {
      value: function () {
        return dj(this, "next")
      },
    },
    previousNode: {
      value: function () {
        var t, r, n, i
        for (t = this._currentNode; t !== this._root; ) {
          for (n = t.previousSibling; n; n = t.previousSibling)
            if (
              ((t = n), (r = this._internalFilter(t)), r !== ws.FILTER_REJECT)
            ) {
              for (
                i = t.lastChild;
                i &&
                ((t = i),
                (r = this._internalFilter(t)),
                r !== ws.FILTER_REJECT);
                i = t.lastChild
              );
              if (r === ws.FILTER_ACCEPT) return (this._currentNode = t), t
            }
          if (t === this.root || t.parentNode === null) return null
          if (
            ((t = t.parentNode), this._internalFilter(t) === ws.FILTER_ACCEPT)
          )
            return (this._currentNode = t), t
        }
        return null
      },
    },
    nextNode: {
      value: function () {
        var t, r, n, i
        ;(t = this._currentNode), (r = ws.FILTER_ACCEPT)
        e: for (;;) {
          for (n = t.firstChild; n; n = t.firstChild) {
            if (
              ((t = n), (r = this._internalFilter(t)), r === ws.FILTER_ACCEPT)
            )
              return (this._currentNode = t), t
            if (r === ws.FILTER_REJECT) break
          }
          for (
            i = cj.nextSkippingChildren(t, this.root);
            i;
            i = cj.nextSkippingChildren(t, this.root)
          ) {
            if (
              ((t = i), (r = this._internalFilter(t)), r === ws.FILTER_ACCEPT)
            )
              return (this._currentNode = t), t
            if (r === ws.FILTER_SKIP) continue e
          }
          return null
        }
      },
    },
    toString: {
      value: function () {
        return "[object TreeWalker]"
      },
    },
  })
})
var bj = _((ISt, Cj) => {
  "use strict"
  Cj.exports = vj
  var $U = Pb(),
    YU = HU(),
    yj = oi()
  function FPe(e, t, r) {
    return r ? YU.next(e, t) : e === t ? null : YU.previous(e, null)
  }
  function mj(e, t) {
    for (; t; t = t.parentNode) if (e === t) return true
    return false
  }
  function Aj(e, t) {
    var r, n
    for (r = e._referenceNode, n = e._pointerBeforeReferenceNode; ; ) {
      if (n === t) n = !n
      else if (((r = FPe(r, e._root, t)), r === null)) return null
      var i = e._internalFilter(r)
      if (i === $U.FILTER_ACCEPT) break
    }
    return (e._referenceNode = r), (e._pointerBeforeReferenceNode = n), r
  }
  function vj(e, t, r) {
    ;(!e || !e.nodeType) && yj.NotSupportedError(),
      (this._root = e),
      (this._referenceNode = e),
      (this._pointerBeforeReferenceNode = true),
      (this._whatToShow = Number(t) || 0),
      (this._filter = r || null),
      (this._active = false),
      e.doc._attachNodeIterator(this)
  }
  Object.defineProperties(vj.prototype, {
    root: {
      get: function () {
        return this._root
      },
    },
    referenceNode: {
      get: function () {
        return this._referenceNode
      },
    },
    pointerBeforeReferenceNode: {
      get: function () {
        return this._pointerBeforeReferenceNode
      },
    },
    whatToShow: {
      get: function () {
        return this._whatToShow
      },
    },
    filter: {
      get: function () {
        return this._filter
      },
    },
    _internalFilter: {
      value: function (t) {
        var r, n
        if (
          (this._active && yj.InvalidStateError(),
          !((1 << (t.nodeType - 1)) & this._whatToShow))
        )
          return $U.FILTER_SKIP
        if (((n = this._filter), n === null)) r = $U.FILTER_ACCEPT
        else {
          this._active = true
          try {
            typeof n == "function" ? (r = n(t)) : (r = n.acceptNode(t))
          } finally {
            this._active = false
          }
        }
        return +r
      },
    },
    _preremove: {
      value: function (t) {
        if (!mj(t, this._root) && mj(t, this._referenceNode)) {
          if (this._pointerBeforeReferenceNode) {
            for (var r = t; r.lastChild; ) r = r.lastChild
            if (((r = YU.next(r, this.root)), r)) {
              this._referenceNode = r
              return
            }
            this._pointerBeforeReferenceNode = false
          }
          if (t.previousSibling === null) this._referenceNode = t.parentNode
          else {
            this._referenceNode = t.previousSibling
            var n
            for (
              n = this._referenceNode.lastChild;
              n;
              n = this._referenceNode.lastChild
            )
              this._referenceNode = n
          }
        }
      },
    },
    nextNode: {
      value: function () {
        return Aj(this, true)
      },
    },
    previousNode: {
      value: function () {
        return Aj(this, false)
      },
    },
    detach: { value: function () {} },
    toString: {
      value: function () {
        return "[object NodeIterator]"
      },
    },
  })
})
var oB = _((BSt, Ej) => {
  "use strict"
  Ej.exports = Ss
  function Ss(e) {
    if (!e) return Object.create(Ss.prototype)
    this.url = e.replace(/^[ \t\n\r\f]+|[ \t\n\r\f]+$/g, "")
    var t = Ss.pattern.exec(this.url)
    if (t) {
      if ((t[2] && (this.scheme = t[2]), t[4])) {
        var r = t[4].match(Ss.userinfoPattern)
        if (
          (r &&
            ((this.username = r[1]),
            (this.password = r[3]),
            (t[4] = t[4].substring(r[0].length))),
          t[4].match(Ss.portPattern))
        ) {
          var n = t[4].lastIndexOf(":")
          ;(this.host = t[4].substring(0, n)),
            (this.port = t[4].substring(n + 1))
        } else this.host = t[4]
      }
      t[5] && (this.path = t[5]),
        t[6] && (this.query = t[7]),
        t[8] && (this.fragment = t[9])
    }
  }
  Ss.pattern = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/
  Ss.userinfoPattern = /^([^@:]*)(:([^@]*))?@/
  Ss.portPattern = /:\d+$/
  Ss.authorityPattern = /^[^:\/?#]+:\/\//
  Ss.hierarchyPattern = /^[^:\/?#]+:\//
  Ss.percentEncode = function (t) {
    var r = t.charCodeAt(0)
    if (r < 256) return "%" + r.toString(16)
    throw Error("can't percent-encode codepoints > 255 yet")
  }
  Ss.prototype = {
    constructor: Ss,
    isAbsolute: function () {
      return !!this.scheme
    },
    isAuthorityBased: function () {
      return Ss.authorityPattern.test(this.url)
    },
    isHierarchical: function () {
      return Ss.hierarchyPattern.test(this.url)
    },
    toString: function () {
      var e = ""
      return (
        this.scheme !== undefined && (e += this.scheme + ":"),
        this.isAbsolute() &&
          ((e += "//"),
          (this.username || this.password) &&
            ((e += this.username || ""),
            this.password && (e += ":" + this.password),
            (e += "@")),
          this.host && (e += this.host)),
        this.port !== undefined && (e += ":" + this.port),
        this.path !== undefined && (e += this.path),
        this.query !== undefined && (e += "?" + this.query),
        this.fragment !== undefined && (e += "#" + this.fragment),
        e
      )
    },
    resolve: function (e) {
      var t = this,
        r = new Ss(e),
        n = new Ss()
      return (
        r.scheme !== undefined
          ? ((n.scheme = r.scheme),
            (n.username = r.username),
            (n.password = r.password),
            (n.host = r.host),
            (n.port = r.port),
            (n.path = s(r.path)),
            (n.query = r.query))
          : ((n.scheme = t.scheme),
            r.host !== undefined
              ? ((n.username = r.username),
                (n.password = r.password),
                (n.host = r.host),
                (n.port = r.port),
                (n.path = s(r.path)),
                (n.query = r.query))
              : ((n.username = t.username),
                (n.password = t.password),
                (n.host = t.host),
                (n.port = t.port),
                r.path
                  ? (r.path.charAt(0) === "/"
                      ? (n.path = s(r.path))
                      : ((n.path = i(t.path, r.path)), (n.path = s(n.path))),
                    (n.query = r.query))
                  : ((n.path = t.path),
                    r.query !== undefined
                      ? (n.query = r.query)
                      : (n.query = t.query)))),
        (n.fragment = r.fragment),
        n.toString()
      )
      function i(o, a) {
        if (t.host !== undefined && !t.path) return "/" + a
        var l = o.lastIndexOf("/")
        return l === -1 ? a : o.substring(0, l + 1) + a
      }
      function s(o) {
        if (!o) return o
        for (var a = ""; o.length > 0; ) {
          if (o === "." || o === "..") {
            o = ""
            break
          }
          var l = o.substring(0, 2),
            c = o.substring(0, 3),
            u = o.substring(0, 4)
          if (c === "../") o = o.substring(3)
          else if (l === "./") o = o.substring(2)
          else if (c === "/./") o = "/" + o.substring(3)
          else if (l === "/." && o.length === 2) o = "/"
          else if (u === "/../" || (c === "/.." && o.length === 3))
            (o = "/" + o.substring(4)), (a = a.replace(/\/?[^\/]*$/, ""))
          else {
            var f = o.match(/(\/?([^\/]*))/)[0]
            ;(a += f), (o = o.substring(f.length))
          }
        }
        return a
      }
    },
  }
})
var wj = _((RSt, xj) => {
  "use strict"
  xj.exports = KU
  var _j = YA()
  function KU(e, t) {
    _j.call(this, e, t)
  }
  KU.prototype = Object.create(_j.prototype, { constructor: { value: KU } })
})
var zU = _((DSt, Sj) => {
  "use strict"
  Sj.exports = {
    Event: YA(),
    UIEvent: jL(),
    MouseEvent: XL(),
    CustomEvent: wj(),
  }
})
var Bj = _((t0) => {
  "use strict"
  Object.defineProperty(t0, "__esModule", { value: true })
  t0.hyphenate = t0.parse = undefined
  function QPe(e) {
    let t = [],
      r = 0,
      n = 0,
      i = 0,
      s = 0,
      o = 0,
      a = null
    for (; r < e.length; )
      switch (e.charCodeAt(r++)) {
        case 40:
          n++
          break
        case 41:
          n--
          break
        case 39:
          i === 0 ? (i = 39) : i === 39 && e.charCodeAt(r - 1) !== 92 && (i = 0)
          break
        case 34:
          i === 0 ? (i = 34) : i === 34 && e.charCodeAt(r - 1) !== 92 && (i = 0)
          break
        case 58:
          !a &&
            n === 0 &&
            i === 0 &&
            ((a = Ij(e.substring(o, r - 1).trim())), (s = r))
          break
        case 59:
          if (a && s > 0 && n === 0 && i === 0) {
            let c = e.substring(s, r - 1).trim()
            t.push(a, c), (o = r), (s = 0), (a = null)
          }
          break
      }
    if (a && s) {
      let l = e.slice(s).trim()
      t.push(a, l)
    }
    return t
  }
  t0.parse = QPe
  function Ij(e) {
    return e
      .replace(/[a-z][A-Z]/g, (t) => t.charAt(0) + "-" + t.charAt(1))
      .toLowerCase()
  }
  t0.hyphenate = Ij
})
var aB = _((kSt, Mj) => {
  "use strict"
  var { parse: NPe } = Bj()
  Mj.exports = function (e) {
    let t = new kj(e),
      r = {
        get: function (n, i) {
          return i in n ? n[i] : n.getPropertyValue(Rj(i))
        },
        has: function (n, i) {
          return true
        },
        set: function (n, i, s) {
          return i in n ? (n[i] = s) : n.setProperty(Rj(i), s ?? undefined), true
        },
      }
    return new Proxy(t, r)
  }
  function Rj(e) {
    return e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()
  }
  function kj(e) {
    this._element = e
  }
  var Dj = "!important"
  function Tj(e) {
    let t = { property: {}, priority: {} }
    if (!e) return t
    let r = NPe(e)
    if (r.length < 2) return t
    for (let n = 0; n < r.length; n += 2) {
      let i = r[n],
        s = r[n + 1]
      s.endsWith(Dj) &&
        ((t.priority[i] = "important"), (s = s.slice(0, -Dj.length).trim())),
        (t.property[i] = s)
    }
    return t
  }
  var r0 = {}
  kj.prototype = Object.create(Object.prototype, {
    _parsed: {
      get: function () {
        if (!this._parsedStyles || this.cssText !== this._lastParsedText) {
          var e = this.cssText
          ;(this._parsedStyles = Tj(e)),
            (this._lastParsedText = e),
            delete this._names
        }
        return this._parsedStyles
      },
    },
    _serialize: {
      value: function () {
        var e = this._parsed,
          t = ""
        for (var r in e.property)
          t && (t += " "),
            (t += r + ": " + e.property[r]),
            e.priority[r] && (t += " !" + e.priority[r]),
            (t += ";")
        ;(this.cssText = t), (this._lastParsedText = t), delete this._names
      },
    },
    cssText: {
      get: function () {
        return this._element.getAttribute("style")
      },
      set: function (e) {
        this._element.setAttribute("style", e)
      },
    },
    length: {
      get: function () {
        return (
          this._names ||
            (this._names = Object.getOwnPropertyNames(this._parsed.property)),
          this._names.length
        )
      },
    },
    item: {
      value: function (e) {
        return (
          this._names ||
            (this._names = Object.getOwnPropertyNames(this._parsed.property)),
          this._names[e]
        )
      },
    },
    getPropertyValue: {
      value: function (e) {
        return (e = e.toLowerCase()), this._parsed.property[e] || ""
      },
    },
    getPropertyPriority: {
      value: function (e) {
        return (e = e.toLowerCase()), this._parsed.priority[e] || ""
      },
    },
    setProperty: {
      value: function (e, t, r) {
        if (
          ((e = e.toLowerCase()),
          t == null && (t = ""),
          r == null && (r = ""),
          t !== r0 && (t = "" + t),
          (t = t.trim()),
          t === "")
        ) {
          this.removeProperty(e)
          return
        }
        if (!(r !== "" && r !== r0 && !/^important$/i.test(r))) {
          var n = this._parsed
          if (t === r0) {
            if (!n.property[e]) return
            r !== "" ? (n.priority[e] = "important") : delete n.priority[e]
          } else {
            if (t.indexOf(";") !== -1) return
            var i = Tj(e + ":" + t)
            if (
              Object.getOwnPropertyNames(i.property).length === 0 ||
              Object.getOwnPropertyNames(i.priority).length !== 0
            )
              return
            for (var s in i.property)
              (n.property[s] = i.property[s]),
                r !== r0 &&
                  (r !== ""
                    ? (n.priority[s] = "important")
                    : n.priority[s] && delete n.priority[s])
          }
          this._serialize()
        }
      },
    },
    setPropertyValue: {
      value: function (e, t) {
        return this.setProperty(e, t, r0)
      },
    },
    setPropertyPriority: {
      value: function (e, t) {
        return this.setProperty(e, r0, t)
      },
    },
    removeProperty: {
      value: function (e) {
        e = e.toLowerCase()
        var t = this._parsed
        e in t.property &&
          (delete t.property[e], delete t.priority[e], this._serialize())
      },
    },
  })
})
var JU = _((MSt, Fj) => {
  "use strict"
  var es = oB()
  Fj.exports = Lb
  function Lb() {}
  Lb.prototype = Object.create(Object.prototype, {
    _url: {
      get: function () {
        return new es(this.href)
      },
    },
    protocol: {
      get: function () {
        var e = this._url
        return e && e.scheme ? e.scheme + ":" : ":"
      },
      set: function (e) {
        var t = this.href,
          r = new es(t)
        r.isAbsolute() &&
          ((e = e.replace(/:+$/, "")),
          (e = e.replace(/[^-+\.a-zA-Z0-9]/g, es.percentEncode)),
          e.length > 0 && ((r.scheme = e), (t = r.toString()))),
          (this.href = t)
      },
    },
    host: {
      get: function () {
        var e = this._url
        return e.isAbsolute() && e.isAuthorityBased()
          ? e.host + (e.port ? ":" + e.port : "")
          : ""
      },
      set: function (e) {
        var t = this.href,
          r = new es(t)
        r.isAbsolute() &&
          r.isAuthorityBased() &&
          ((e = e.replace(/[^-+\._~!$&'()*,;:=a-zA-Z0-9]/g, es.percentEncode)),
          e.length > 0 && ((r.host = e), delete r.port, (t = r.toString()))),
          (this.href = t)
      },
    },
    hostname: {
      get: function () {
        var e = this._url
        return e.isAbsolute() && e.isAuthorityBased() ? e.host : ""
      },
      set: function (e) {
        var t = this.href,
          r = new es(t)
        r.isAbsolute() &&
          r.isAuthorityBased() &&
          ((e = e.replace(/^\/+/, "")),
          (e = e.replace(/[^-+\._~!$&'()*,;:=a-zA-Z0-9]/g, es.percentEncode)),
          e.length > 0 && ((r.host = e), (t = r.toString()))),
          (this.href = t)
      },
    },
    port: {
      get: function () {
        var e = this._url
        return e.isAbsolute() && e.isAuthorityBased() && e.port !== undefined
          ? e.port
          : ""
      },
      set: function (e) {
        var t = this.href,
          r = new es(t)
        r.isAbsolute() &&
          r.isAuthorityBased() &&
          ((e = "" + e),
          (e = e.replace(/[^0-9].*$/, "")),
          (e = e.replace(/^0+/, "")),
          e.length === 0 && (e = "0"),
          parseInt(e, 10) <= 65535 && ((r.port = e), (t = r.toString()))),
          (this.href = t)
      },
    },
    pathname: {
      get: function () {
        var e = this._url
        return e.isAbsolute() && e.isHierarchical() ? e.path : ""
      },
      set: function (e) {
        var t = this.href,
          r = new es(t)
        r.isAbsolute() &&
          r.isHierarchical() &&
          (e.charAt(0) !== "/" && (e = "/" + e),
          (e = e.replace(
            /[^-+\._~!$&'()*,;:=@\/a-zA-Z0-9]/g,
            es.percentEncode,
          )),
          (r.path = e),
          (t = r.toString())),
          (this.href = t)
      },
    },
    search: {
      get: function () {
        var e = this._url
        return e.isAbsolute() && e.isHierarchical() && e.query !== undefined
          ? "?" + e.query
          : ""
      },
      set: function (e) {
        var t = this.href,
          r = new es(t)
        r.isAbsolute() &&
          r.isHierarchical() &&
          (e.charAt(0) === "?" && (e = e.substring(1)),
          (e = e.replace(
            /[^-+\._~!$&'()*,;:=@\/?a-zA-Z0-9]/g,
            es.percentEncode,
          )),
          (r.query = e),
          (t = r.toString())),
          (this.href = t)
      },
    },
    hash: {
      get: function () {
        var e = this._url
        return e == null || e.fragment == null || e.fragment === ""
          ? ""
          : "#" + e.fragment
      },
      set: function (e) {
        var t = this.href,
          r = new es(t)
        e.charAt(0) === "#" && (e = e.substring(1)),
          (e = e.replace(
            /[^-+\._~!$&'()*,;:=@\/?a-zA-Z0-9]/g,
            es.percentEncode,
          )),
          (r.fragment = e),
          (t = r.toString()),
          (this.href = t)
      },
    },
    username: {
      get: function () {
        var e = this._url
        return e.username || ""
      },
      set: function (e) {
        var t = this.href,
          r = new es(t)
        r.isAbsolute() &&
          ((e = e.replace(
            /[\x00-\x1F\x7F-\uFFFF "#<>?`\/@\\:]/g,
            es.percentEncode,
          )),
          (r.username = e),
          (t = r.toString())),
          (this.href = t)
      },
    },
    password: {
      get: function () {
        var e = this._url
        return e.password || ""
      },
      set: function (e) {
        var t = this.href,
          r = new es(t)
        r.isAbsolute() &&
          (e === ""
            ? (r.password = null)
            : ((e = e.replace(
                /[\x00-\x1F\x7F-\uFFFF "#<>?`\/@\\]/g,
                es.percentEncode,
              )),
              (r.password = e)),
          (t = r.toString())),
          (this.href = t)
      },
    },
    origin: {
      get: function () {
        var e = this._url
        if (e == null) return ""
        var t = function (r) {
          var n = [e.scheme, e.host, +e.port || r]
          return n[0] + "://" + n[1] + (n[2] === r ? "" : ":" + n[2])
        }
        switch (e.scheme) {
          case "ftp":
            return t(21)
          case "gopher":
            return t(70)
          case "http":
          case "ws":
            return t(80)
          case "https":
          case "wss":
            return t(443)
          default:
            return e.scheme + "://"
        }
      },
    },
  })
  Lb._inherit = function (e) {
    Object.getOwnPropertyNames(Lb.prototype).forEach(function (t) {
      if (!(t === "constructor" || t === "href")) {
        var r = Object.getOwnPropertyDescriptor(Lb.prototype, t)
        Object.defineProperty(e, t, r)
      }
    })
  }
})
var jU = _((FSt, Pj) => {
  "use strict"
  var Qj = AU(),
    PPe = $I().isApiWritable
  Pj.exports = function (e, t, r, n) {
    var i = e.ctor
    if (i) {
      var s = e.props || {}
      if (e.attributes)
        for (var o in e.attributes) {
          var a = e.attributes[o]
          ;(typeof a != "object" || Array.isArray(a)) && (a = { type: a }),
            a.name || (a.name = o.toLowerCase()),
            (s[o] = Qj.property(a))
        }
      ;(s.constructor = { value: i, writable: PPe }),
        (i.prototype = Object.create((e.superclass || t).prototype, s)),
        e.events && UPe(i, e.events),
        (r[e.name] = i)
    } else i = t
    return (
      (e.tags || (e.tag && [e.tag]) || []).forEach(function (l) {
        n[l] = i
      }),
      i
    )
  }
  function Nj(e, t, r, n) {
    ;(this.body = e), (this.document = t), (this.form = r), (this.element = n)
  }
  Nj.prototype.build = function () {
    return () => {}
  }
  function LPe(e, t, r, n) {
    var i = e.ownerDocument || Object.create(null),
      s = e.form || Object.create(null)
    e[t] = new Nj(n, i, s, e).build()
  }
  function UPe(e, t) {
    var r = e.prototype
    t.forEach(function (n) {
      Object.defineProperty(r, "on" + n, {
        get: function () {
          return this._getEventHandler(n)
        },
        set: function (i) {
          this._setEventHandler(n, i)
        },
      }),
        Qj.registerChangeHandler(e, "on" + n, LPe)
    })
  }
})
var uB = _((cB) => {
  "use strict"
  var ZU = xs(),
    Lj = e0(),
    OPe = aB(),
    Ia = oi(),
    Uj = JU(),
    qPe = jU(),
    Qd = (cB.elements = {}),
    Ub = Object.create(null)
  cB.createElement = function (e, t, r) {
    var n = Ub[t] || HPe
    return new n(e, t, r)
  }
  function Fe(e) {
    return qPe(e, Ze, Qd, Ub)
  }
  function ai(e) {
    return {
      get: function () {
        var t = this._getattr(e)
        if (t === null) return ""
        var r = this.doc._resolve(t)
        return r === null ? t : r
      },
      set: function (t) {
        this._setattr(e, t)
      },
    }
  }
  function lB(e) {
    return {
      get: function () {
        var t = this._getattr(e)
        return t === null
          ? null
          : t.toLowerCase() === "use-credentials"
            ? "use-credentials"
            : "anonymous"
      },
      set: function (t) {
        t == null ? this.removeAttribute(e) : this._setattr(e, t)
      },
    }
  }
  var n0 = {
      type: [
        "",
        "no-referrer",
        "no-referrer-when-downgrade",
        "same-origin",
        "origin",
        "strict-origin",
        "origin-when-cross-origin",
        "strict-origin-when-cross-origin",
        "unsafe-url",
      ],
      missing: "",
    },
    VPe = {
      A: true,
      LINK: true,
      BUTTON: true,
      INPUT: true,
      SELECT: true,
      TEXTAREA: true,
      COMMAND: true,
    },
    Cc = function (e, t, r) {
      Ze.call(this, e, t, r), (this._form = null)
    },
    Ze = (cB.HTMLElement = Fe({
      superclass: Lj,
      name: "HTMLElement",
      ctor: function (t, r, n) {
        Lj.call(this, t, r, Ia.NAMESPACE.HTML, n)
      },
      props: {
        dangerouslySetInnerHTML: {
          set: function (e) {
            this._innerHTML = e
          },
        },
        innerHTML: {
          get: function () {
            return this.serialize()
          },
          set: function (e) {
            var t = this.ownerDocument.implementation.mozHTMLParser(
              this.ownerDocument._address,
              this,
            )
            t.parse(e === null ? "" : String(e), true)
            for (
              var r = this instanceof Ub.template ? this.content : this;
              r.hasChildNodes();

            )
              r.removeChild(r.firstChild)
            r.appendChild(t._asDocumentFragment())
          },
        },
        style: {
          get: function () {
            return this._style || (this._style = new OPe(this)), this._style
          },
          set: function (e) {
            e == null && (e = ""), this._setattr("style", String(e))
          },
        },
        blur: { value: function () {} },
        focus: { value: function () {} },
        forceSpellCheck: { value: function () {} },
        click: {
          value: function () {
            if (!this._click_in_progress) {
              this._click_in_progress = true
              try {
                this._pre_click_activation_steps &&
                  this._pre_click_activation_steps()
                var e = this.ownerDocument.createEvent("MouseEvent")
                e.initMouseEvent(
                  "click",
                  true,
                  true,
                  this.ownerDocument.defaultView,
                  1,
                  0,
                  0,
                  0,
                  0,
                  false,
                  false,
                  false,
                  false,
                  0,
                  null,
                )
                var t = this.dispatchEvent(e)
                t
                  ? this._post_click_activation_steps &&
                    this._post_click_activation_steps(e)
                  : this._cancelled_activation_steps &&
                    this._cancelled_activation_steps()
              } finally {
                this._click_in_progress = false
              }
            }
          },
        },
        submit: { value: Ia.nyi },
      },
      attributes: {
        title: String,
        lang: String,
        dir: { type: ["ltr", "rtl", "auto"], missing: "" },
        draggable: { type: ["true", "false"], treatNullAsEmptyString: true },
        spellcheck: { type: ["true", "false"], missing: "" },
        enterKeyHint: {
          type: ["enter", "done", "go", "next", "previous", "search", "send"],
          missing: "",
        },
        autoCapitalize: {
          type: ["off", "on", "none", "sentences", "words", "characters"],
          missing: "",
        },
        autoFocus: Boolean,
        accessKey: String,
        nonce: String,
        hidden: Boolean,
        translate: { type: ["no", "yes"], missing: "" },
        tabIndex: {
          type: "long",
          default: function () {
            return this.tagName in VPe || this.contentEditable ? 0 : -1
          },
        },
      },
      events: [
        "abort",
        "canplay",
        "canplaythrough",
        "change",
        "click",
        "contextmenu",
        "cuechange",
        "dblclick",
        "drag",
        "dragend",
        "dragenter",
        "dragleave",
        "dragover",
        "dragstart",
        "drop",
        "durationchange",
        "emptied",
        "ended",
        "input",
        "invalid",
        "keydown",
        "keypress",
        "keyup",
        "loadeddata",
        "loadedmetadata",
        "loadstart",
        "mousedown",
        "mousemove",
        "mouseout",
        "mouseover",
        "mouseup",
        "mousewheel",
        "pause",
        "play",
        "playing",
        "progress",
        "ratechange",
        "readystatechange",
        "reset",
        "seeked",
        "seeking",
        "select",
        "show",
        "stalled",
        "submit",
        "suspend",
        "timeupdate",
        "volumechange",
        "waiting",
        "blur",
        "error",
        "focus",
        "load",
        "scroll",
      ],
    })),
    HPe = Fe({
      name: "HTMLUnknownElement",
      ctor: function (t, r, n) {
        Ze.call(this, t, r, n)
      },
    }),
    bc = {
      form: {
        get: function () {
          return this._form
        },
      },
    }
  Fe({
    tag: "a",
    name: "HTMLAnchorElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    props: {
      _post_click_activation_steps: {
        value: function (e) {
          this.href && (this.ownerDocument.defaultView.location = this.href)
        },
      },
    },
    attributes: {
      href: ai,
      ping: String,
      download: String,
      target: String,
      rel: String,
      media: String,
      hreflang: String,
      type: String,
      referrerPolicy: n0,
      coords: String,
      charset: String,
      name: String,
      rev: String,
      shape: String,
    },
  })
  Uj._inherit(Ub.a.prototype)
  Fe({
    tag: "area",
    name: "HTMLAreaElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: {
      alt: String,
      target: String,
      download: String,
      rel: String,
      media: String,
      href: ai,
      hreflang: String,
      type: String,
      shape: String,
      coords: String,
      ping: String,
      referrerPolicy: n0,
      noHref: Boolean,
    },
  })
  Uj._inherit(Ub.area.prototype)
  Fe({
    tag: "br",
    name: "HTMLBRElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { clear: String },
  })
  Fe({
    tag: "base",
    name: "HTMLBaseElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { target: String },
  })
  Fe({
    tag: "body",
    name: "HTMLBodyElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    events: [
      "afterprint",
      "beforeprint",
      "beforeunload",
      "blur",
      "error",
      "focus",
      "hashchange",
      "load",
      "message",
      "offline",
      "online",
      "pagehide",
      "pageshow",
      "popstate",
      "resize",
      "scroll",
      "storage",
      "unload",
    ],
    attributes: {
      text: { type: String, treatNullAsEmptyString: true },
      link: { type: String, treatNullAsEmptyString: true },
      vLink: { type: String, treatNullAsEmptyString: true },
      aLink: { type: String, treatNullAsEmptyString: true },
      bgColor: { type: String, treatNullAsEmptyString: true },
      background: String,
    },
  })
  Fe({
    tag: "button",
    name: "HTMLButtonElement",
    ctor: function (t, r, n) {
      Cc.call(this, t, r, n)
    },
    props: bc,
    attributes: {
      name: String,
      value: String,
      disabled: Boolean,
      autofocus: Boolean,
      type: { type: ["submit", "reset", "button", "menu"], missing: "submit" },
      formTarget: String,
      formAction: ai,
      formNoValidate: Boolean,
      formMethod: {
        type: ["get", "post", "dialog"],
        invalid: "get",
        missing: "",
      },
      formEnctype: {
        type: [
          "application/x-www-form-urlencoded",
          "multipart/form-data",
          "text/plain",
        ],
        invalid: "application/x-www-form-urlencoded",
        missing: "",
      },
    },
  })
  Fe({
    tag: "dl",
    name: "HTMLDListElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { compact: Boolean },
  })
  Fe({
    tag: "data",
    name: "HTMLDataElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { value: String },
  })
  Fe({
    tag: "datalist",
    name: "HTMLDataListElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
  })
  Fe({
    tag: "details",
    name: "HTMLDetailsElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { open: Boolean },
  })
  Fe({
    tag: "div",
    name: "HTMLDivElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { align: String },
  })
  Fe({
    tag: "embed",
    name: "HTMLEmbedElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: {
      src: ai,
      type: String,
      width: String,
      height: String,
      align: String,
      name: String,
    },
  })
  Fe({
    tag: "fieldset",
    name: "HTMLFieldSetElement",
    ctor: function (t, r, n) {
      Cc.call(this, t, r, n)
    },
    props: bc,
    attributes: { disabled: Boolean, name: String },
  })
  Fe({
    tag: "form",
    name: "HTMLFormElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: {
      action: String,
      autocomplete: { type: ["on", "off"], missing: "on" },
      name: String,
      acceptCharset: { name: "accept-charset" },
      target: String,
      noValidate: Boolean,
      method: {
        type: ["get", "post", "dialog"],
        invalid: "get",
        missing: "get",
      },
      enctype: {
        type: [
          "application/x-www-form-urlencoded",
          "multipart/form-data",
          "text/plain",
        ],
        invalid: "application/x-www-form-urlencoded",
        missing: "application/x-www-form-urlencoded",
      },
      encoding: {
        name: "enctype",
        type: [
          "application/x-www-form-urlencoded",
          "multipart/form-data",
          "text/plain",
        ],
        invalid: "application/x-www-form-urlencoded",
        missing: "application/x-www-form-urlencoded",
      },
    },
  })
  Fe({
    tag: "hr",
    name: "HTMLHRElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: {
      align: String,
      color: String,
      noShade: Boolean,
      size: String,
      width: String,
    },
  })
  Fe({
    tag: "head",
    name: "HTMLHeadElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
  })
  Fe({
    tags: ["h1", "h2", "h3", "h4", "h5", "h6"],
    name: "HTMLHeadingElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { align: String },
  })
  Fe({
    tag: "html",
    name: "HTMLHtmlElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { xmlns: ai, version: String },
  })
  Fe({
    tag: "iframe",
    name: "HTMLIFrameElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: {
      src: ai,
      srcdoc: String,
      name: String,
      width: String,
      height: String,
      seamless: Boolean,
      allow: Boolean,
      allowFullscreen: Boolean,
      allowUserMedia: Boolean,
      allowPaymentRequest: Boolean,
      referrerPolicy: n0,
      loading: { type: ["eager", "lazy"], treatNullAsEmptyString: true },
      align: String,
      scrolling: String,
      frameBorder: String,
      longDesc: ai,
      marginHeight: { type: String, treatNullAsEmptyString: true },
      marginWidth: { type: String, treatNullAsEmptyString: true },
    },
  })
  Fe({
    tag: "img",
    name: "HTMLImageElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: {
      alt: String,
      src: ai,
      srcset: String,
      crossOrigin: lB,
      useMap: String,
      isMap: Boolean,
      sizes: String,
      height: { type: "unsigned long", default: 0 },
      width: { type: "unsigned long", default: 0 },
      referrerPolicy: n0,
      loading: { type: ["eager", "lazy"], missing: "" },
      name: String,
      lowsrc: ai,
      align: String,
      hspace: { type: "unsigned long", default: 0 },
      vspace: { type: "unsigned long", default: 0 },
      longDesc: ai,
      border: { type: String, treatNullAsEmptyString: true },
    },
  })
  Fe({
    tag: "input",
    name: "HTMLInputElement",
    ctor: function (t, r, n) {
      Cc.call(this, t, r, n)
    },
    props: {
      form: bc.form,
      _post_click_activation_steps: {
        value: function (e) {
          if (this.type === "checkbox") this.checked = !this.checked
          else if (this.type === "radio")
            for (
              var t = this.form.getElementsByName(this.name), r = t.length - 1;
              r >= 0;
              r--
            ) {
              var n = t[r]
              n.checked = n === this
            }
        },
      },
    },
    attributes: {
      name: String,
      disabled: Boolean,
      autofocus: Boolean,
      accept: String,
      alt: String,
      max: String,
      min: String,
      pattern: String,
      placeholder: String,
      step: String,
      dirName: String,
      defaultValue: { name: "value" },
      multiple: Boolean,
      required: Boolean,
      readOnly: Boolean,
      checked: Boolean,
      value: String,
      src: ai,
      defaultChecked: { name: "checked", type: Boolean },
      size: { type: "unsigned long", default: 20, min: 1, setmin: 1 },
      width: { type: "unsigned long", min: 0, setmin: 0, default: 0 },
      height: { type: "unsigned long", min: 0, setmin: 0, default: 0 },
      minLength: { type: "unsigned long", min: 0, setmin: 0, default: -1 },
      maxLength: { type: "unsigned long", min: 0, setmin: 0, default: -1 },
      autocomplete: String,
      type: {
        type: [
          "text",
          "hidden",
          "search",
          "tel",
          "url",
          "email",
          "password",
          "datetime",
          "date",
          "month",
          "week",
          "time",
          "datetime-local",
          "number",
          "range",
          "color",
          "checkbox",
          "radio",
          "file",
          "submit",
          "image",
          "reset",
          "button",
        ],
        missing: "text",
      },
      formTarget: String,
      formNoValidate: Boolean,
      formMethod: { type: ["get", "post"], invalid: "get", missing: "" },
      formEnctype: {
        type: [
          "application/x-www-form-urlencoded",
          "multipart/form-data",
          "text/plain",
        ],
        invalid: "application/x-www-form-urlencoded",
        missing: "",
      },
      inputMode: {
        type: [
          "verbatim",
          "latin",
          "latin-name",
          "latin-prose",
          "full-width-latin",
          "kana",
          "kana-name",
          "katakana",
          "numeric",
          "tel",
          "email",
          "url",
        ],
        missing: "",
      },
      align: String,
      useMap: String,
    },
  })
  Fe({
    tag: "keygen",
    name: "HTMLKeygenElement",
    ctor: function (t, r, n) {
      Cc.call(this, t, r, n)
    },
    props: bc,
    attributes: {
      name: String,
      disabled: Boolean,
      autofocus: Boolean,
      challenge: String,
      keytype: { type: ["rsa"], missing: "" },
    },
  })
  Fe({
    tag: "li",
    name: "HTMLLIElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { value: { type: "long", default: 0 }, type: String },
  })
  Fe({
    tag: "label",
    name: "HTMLLabelElement",
    ctor: function (t, r, n) {
      Cc.call(this, t, r, n)
    },
    props: bc,
    attributes: { htmlFor: { name: "for", type: String } },
  })
  Fe({
    tag: "legend",
    name: "HTMLLegendElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { align: String },
  })
  Fe({
    tag: "link",
    name: "HTMLLinkElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: {
      href: ai,
      rel: String,
      media: String,
      hreflang: String,
      type: String,
      crossOrigin: lB,
      nonce: String,
      integrity: String,
      referrerPolicy: n0,
      imageSizes: String,
      imageSrcset: String,
      charset: String,
      rev: String,
      target: String,
    },
  })
  Fe({
    tag: "map",
    name: "HTMLMapElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { name: String },
  })
  Fe({
    tag: "menu",
    name: "HTMLMenuElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: {
      type: { type: ["context", "popup", "toolbar"], missing: "toolbar" },
      label: String,
      compact: Boolean,
    },
  })
  Fe({
    tag: "meta",
    name: "HTMLMetaElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: {
      name: String,
      content: String,
      httpEquiv: { name: "http-equiv", type: String },
      scheme: String,
    },
  })
  Fe({
    tag: "meter",
    name: "HTMLMeterElement",
    ctor: function (t, r, n) {
      Cc.call(this, t, r, n)
    },
    props: bc,
  })
  Fe({
    tags: ["ins", "del"],
    name: "HTMLModElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { cite: ai, dateTime: String },
  })
  Fe({
    tag: "ol",
    name: "HTMLOListElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    props: {
      _numitems: {
        get: function () {
          var e = 0
          return (
            this.childNodes.forEach(function (t) {
              t.nodeType === ZU.ELEMENT_NODE && t.tagName === "LI" && e++
            }),
            e
          )
        },
      },
    },
    attributes: {
      type: String,
      reversed: Boolean,
      start: {
        type: "long",
        default: function () {
          return this.reversed ? this._numitems : 1
        },
      },
      compact: Boolean,
    },
  })
  Fe({
    tag: "object",
    name: "HTMLObjectElement",
    ctor: function (t, r, n) {
      Cc.call(this, t, r, n)
    },
    props: bc,
    attributes: {
      data: ai,
      type: String,
      name: String,
      useMap: String,
      typeMustMatch: Boolean,
      width: String,
      height: String,
      align: String,
      archive: String,
      code: String,
      declare: Boolean,
      hspace: { type: "unsigned long", default: 0 },
      standby: String,
      vspace: { type: "unsigned long", default: 0 },
      codeBase: ai,
      codeType: String,
      border: { type: String, treatNullAsEmptyString: true },
    },
  })
  Fe({
    tag: "optgroup",
    name: "HTMLOptGroupElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { disabled: Boolean, label: String },
  })
  Fe({
    tag: "option",
    name: "HTMLOptionElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    props: {
      form: {
        get: function () {
          for (var e = this.parentNode; e && e.nodeType === ZU.ELEMENT_NODE; ) {
            if (e.localName === "select") return e.form
            e = e.parentNode
          }
        },
      },
      value: {
        get: function () {
          return this._getattr("value") || this.text
        },
        set: function (e) {
          this._setattr("value", e)
        },
      },
      text: {
        get: function () {
          return this.textContent.replace(/[ \t\n\f\r]+/g, " ").trim()
        },
        set: function (e) {
          this.textContent = e
        },
      },
    },
    attributes: {
      disabled: Boolean,
      defaultSelected: { name: "selected", type: Boolean },
      label: String,
    },
  })
  Fe({
    tag: "output",
    name: "HTMLOutputElement",
    ctor: function (t, r, n) {
      Cc.call(this, t, r, n)
    },
    props: bc,
    attributes: { name: String },
  })
  Fe({
    tag: "p",
    name: "HTMLParagraphElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { align: String },
  })
  Fe({
    tag: "param",
    name: "HTMLParamElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: {
      name: String,
      value: String,
      type: String,
      valueType: String,
    },
  })
  Fe({
    tags: ["pre", "listing", "xmp"],
    name: "HTMLPreElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { width: { type: "long", default: 0 } },
  })
  Fe({
    tag: "progress",
    name: "HTMLProgressElement",
    ctor: function (t, r, n) {
      Cc.call(this, t, r, n)
    },
    props: bc,
    attributes: { max: { type: Number, float: true, default: 1, min: 0 } },
  })
  Fe({
    tags: ["q", "blockquote"],
    name: "HTMLQuoteElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { cite: ai },
  })
  Fe({
    tag: "script",
    name: "HTMLScriptElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    props: {
      text: {
        get: function () {
          for (var e = "", t = 0, r = this.childNodes.length; t < r; t++) {
            var n = this.childNodes[t]
            n.nodeType === ZU.TEXT_NODE && (e += n._data)
          }
          return e
        },
        set: function (e) {
          this.removeChildren(),
            e !== null &&
              e !== "" &&
              this.appendChild(this.ownerDocument.createTextNode(e))
        },
      },
    },
    attributes: {
      src: ai,
      type: String,
      charset: String,
      referrerPolicy: n0,
      defer: Boolean,
      async: Boolean,
      nomodule: Boolean,
      crossOrigin: lB,
      nonce: String,
      integrity: String,
    },
  })
  Fe({
    tag: "select",
    name: "HTMLSelectElement",
    ctor: function (t, r, n) {
      Cc.call(this, t, r, n)
    },
    props: {
      form: bc.form,
      options: {
        get: function () {
          return this.getElementsByTagName("option")
        },
      },
    },
    attributes: {
      autocomplete: String,
      name: String,
      disabled: Boolean,
      autofocus: Boolean,
      multiple: Boolean,
      required: Boolean,
      size: { type: "unsigned long", default: 0 },
    },
  })
  Fe({
    tag: "span",
    name: "HTMLSpanElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
  })
  Fe({
    tag: "style",
    name: "HTMLStyleElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { media: String, type: String, scoped: Boolean },
  })
  Fe({
    tag: "caption",
    name: "HTMLTableCaptionElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { align: String },
  })
  Fe({
    name: "HTMLTableCellElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: {
      colSpan: { type: "unsigned long", default: 1 },
      rowSpan: { type: "unsigned long", default: 1 },
      scope: { type: ["row", "col", "rowgroup", "colgroup"], missing: "" },
      abbr: String,
      align: String,
      axis: String,
      height: String,
      width: String,
      ch: { name: "char", type: String },
      chOff: { name: "charoff", type: String },
      noWrap: Boolean,
      vAlign: String,
      bgColor: { type: String, treatNullAsEmptyString: true },
    },
  })
  Fe({
    tags: ["col", "colgroup"],
    name: "HTMLTableColElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: {
      span: { type: "limited unsigned long with fallback", default: 1, min: 1 },
      align: String,
      ch: { name: "char", type: String },
      chOff: { name: "charoff", type: String },
      vAlign: String,
      width: String,
    },
  })
  Fe({
    tag: "table",
    name: "HTMLTableElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    props: {
      rows: {
        get: function () {
          return this.getElementsByTagName("tr")
        },
      },
    },
    attributes: {
      align: String,
      border: String,
      frame: String,
      rules: String,
      summary: String,
      width: String,
      bgColor: { type: String, treatNullAsEmptyString: true },
      cellPadding: { type: String, treatNullAsEmptyString: true },
      cellSpacing: { type: String, treatNullAsEmptyString: true },
    },
  })
  Fe({
    tag: "template",
    name: "HTMLTemplateElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n),
        (this._contentFragment = t._templateDoc.createDocumentFragment())
    },
    props: {
      content: {
        get: function () {
          return this._contentFragment
        },
      },
      serialize: {
        value: function () {
          return this.content.serialize()
        },
      },
    },
  })
  Fe({
    tag: "tr",
    name: "HTMLTableRowElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    props: {
      cells: {
        get: function () {
          return this.querySelectorAll("td,th")
        },
      },
    },
    attributes: {
      align: String,
      ch: { name: "char", type: String },
      chOff: { name: "charoff", type: String },
      vAlign: String,
      bgColor: { type: String, treatNullAsEmptyString: true },
    },
  })
  Fe({
    tags: ["thead", "tfoot", "tbody"],
    name: "HTMLTableSectionElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    props: {
      rows: {
        get: function () {
          return this.getElementsByTagName("tr")
        },
      },
    },
    attributes: {
      align: String,
      ch: { name: "char", type: String },
      chOff: { name: "charoff", type: String },
      vAlign: String,
    },
  })
  Fe({
    tag: "textarea",
    name: "HTMLTextAreaElement",
    ctor: function (t, r, n) {
      Cc.call(this, t, r, n)
    },
    props: {
      form: bc.form,
      type: {
        get: function () {
          return "textarea"
        },
      },
      defaultValue: {
        get: function () {
          return this.textContent
        },
        set: function (e) {
          this.textContent = e
        },
      },
      value: {
        get: function () {
          return this.defaultValue
        },
        set: function (e) {
          this.defaultValue = e
        },
      },
      textLength: {
        get: function () {
          return this.value.length
        },
      },
    },
    attributes: {
      autocomplete: String,
      name: String,
      disabled: Boolean,
      autofocus: Boolean,
      placeholder: String,
      wrap: String,
      dirName: String,
      required: Boolean,
      readOnly: Boolean,
      rows: { type: "limited unsigned long with fallback", default: 2 },
      cols: { type: "limited unsigned long with fallback", default: 20 },
      maxLength: { type: "unsigned long", min: 0, setmin: 0, default: -1 },
      minLength: { type: "unsigned long", min: 0, setmin: 0, default: -1 },
      inputMode: {
        type: [
          "verbatim",
          "latin",
          "latin-name",
          "latin-prose",
          "full-width-latin",
          "kana",
          "kana-name",
          "katakana",
          "numeric",
          "tel",
          "email",
          "url",
        ],
        missing: "",
      },
    },
  })
  Fe({
    tag: "time",
    name: "HTMLTimeElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { dateTime: String, pubDate: Boolean },
  })
  Fe({
    tag: "title",
    name: "HTMLTitleElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    props: {
      text: {
        get: function () {
          return this.textContent
        },
      },
    },
  })
  Fe({
    tag: "ul",
    name: "HTMLUListElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { type: String, compact: Boolean },
  })
  Fe({
    name: "HTMLMediaElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: {
      src: ai,
      crossOrigin: lB,
      preload: {
        type: ["metadata", "none", "auto", { value: "", alias: "auto" }],
        missing: "auto",
      },
      loop: Boolean,
      autoplay: Boolean,
      mediaGroup: String,
      controls: Boolean,
      defaultMuted: { name: "muted", type: Boolean },
    },
  })
  Fe({
    name: "HTMLAudioElement",
    tag: "audio",
    superclass: Qd.HTMLMediaElement,
    ctor: function (t, r, n) {
      Qd.HTMLMediaElement.call(this, t, r, n)
    },
  })
  Fe({
    name: "HTMLVideoElement",
    tag: "video",
    superclass: Qd.HTMLMediaElement,
    ctor: function (t, r, n) {
      Qd.HTMLMediaElement.call(this, t, r, n)
    },
    attributes: {
      poster: ai,
      width: { type: "unsigned long", min: 0, default: 0 },
      height: { type: "unsigned long", min: 0, default: 0 },
    },
  })
  Fe({
    tag: "td",
    name: "HTMLTableDataCellElement",
    superclass: Qd.HTMLTableCellElement,
    ctor: function (t, r, n) {
      Qd.HTMLTableCellElement.call(this, t, r, n)
    },
  })
  Fe({
    tag: "th",
    name: "HTMLTableHeaderCellElement",
    superclass: Qd.HTMLTableCellElement,
    ctor: function (t, r, n) {
      Qd.HTMLTableCellElement.call(this, t, r, n)
    },
  })
  Fe({
    tag: "frameset",
    name: "HTMLFrameSetElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
  })
  Fe({
    tag: "frame",
    name: "HTMLFrameElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
  })
  Fe({
    tag: "canvas",
    name: "HTMLCanvasElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    props: {
      getContext: { value: Ia.nyi },
      probablySupportsContext: { value: Ia.nyi },
      setContext: { value: Ia.nyi },
      transferControlToProxy: { value: Ia.nyi },
      toDataURL: { value: Ia.nyi },
      toBlob: { value: Ia.nyi },
    },
    attributes: {
      width: { type: "unsigned long", default: 300 },
      height: { type: "unsigned long", default: 150 },
    },
  })
  Fe({
    tag: "dialog",
    name: "HTMLDialogElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    props: {
      show: { value: Ia.nyi },
      showModal: { value: Ia.nyi },
      close: { value: Ia.nyi },
    },
    attributes: { open: Boolean, returnValue: String },
  })
  Fe({
    tag: "menuitem",
    name: "HTMLMenuItemElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    props: {
      _label: {
        get: function () {
          var e = this._getattr("label")
          return e !== null && e !== ""
            ? e
            : ((e = this.textContent), e.replace(/[ \t\n\f\r]+/g, " ").trim())
        },
      },
      label: {
        get: function () {
          var e = this._getattr("label")
          return e !== null ? e : this._label
        },
        set: function (e) {
          this._setattr("label", e)
        },
      },
    },
    attributes: {
      type: { type: ["command", "checkbox", "radio"], missing: "command" },
      icon: ai,
      disabled: Boolean,
      checked: Boolean,
      radiogroup: String,
      default: Boolean,
    },
  })
  Fe({
    tag: "source",
    name: "HTMLSourceElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: {
      srcset: String,
      sizes: String,
      media: String,
      src: ai,
      type: String,
      width: String,
      height: String,
    },
  })
  Fe({
    tag: "track",
    name: "HTMLTrackElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: {
      src: ai,
      srclang: String,
      label: String,
      default: Boolean,
      kind: {
        type: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
        missing: "subtitles",
        invalid: "metadata",
      },
    },
    props: {
      NONE: {
        get: function () {
          return 0
        },
      },
      LOADING: {
        get: function () {
          return 1
        },
      },
      LOADED: {
        get: function () {
          return 2
        },
      },
      ERROR: {
        get: function () {
          return 3
        },
      },
      readyState: { get: Ia.nyi },
      track: { get: Ia.nyi },
    },
  })
  Fe({
    tag: "font",
    name: "HTMLFontElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: {
      color: { type: String, treatNullAsEmptyString: true },
      face: { type: String },
      size: { type: String },
    },
  })
  Fe({
    tag: "dir",
    name: "HTMLDirectoryElement",
    ctor: function (t, r, n) {
      Ze.call(this, t, r, n)
    },
    attributes: { compact: Boolean },
  })
  Fe({
    tags: [
      "abbr",
      "address",
      "article",
      "aside",
      "b",
      "bdi",
      "bdo",
      "cite",
      "content",
      "code",
      "dd",
      "dfn",
      "dt",
      "em",
      "figcaption",
      "figure",
      "footer",
      "header",
      "hgroup",
      "i",
      "kbd",
      "main",
      "mark",
      "nav",
      "noscript",
      "rb",
      "rp",
      "rt",
      "rtc",
      "ruby",
      "s",
      "samp",
      "section",
      "small",
      "strong",
      "sub",
      "summary",
      "sup",
      "u",
      "var",
      "wbr",
      "acronym",
      "basefont",
      "big",
      "center",
      "nobr",
      "noembed",
      "noframes",
      "plaintext",
      "strike",
      "tt",
    ],
  })
})
var tO = _((dB) => {
  "use strict"
  var Oj = e0(),
    WPe = jU(),
    GPe = oi(),
    $Pe = aB(),
    YPe = (dB.elements = {}),
    qj = Object.create(null)
  dB.createElement = function (e, t, r) {
    var n = qj[t] || eO
    return new n(e, t, r)
  }
  function XU(e) {
    return WPe(e, eO, YPe, qj)
  }
  var eO = XU({
    superclass: Oj,
    name: "SVGElement",
    ctor: function (t, r, n) {
      Oj.call(this, t, r, GPe.NAMESPACE.SVG, n)
    },
    props: {
      style: {
        get: function () {
          return this._style || (this._style = new $Pe(this)), this._style
        },
      },
    },
  })
  XU({
    name: "SVGSVGElement",
    ctor: function (t, r, n) {
      eO.call(this, t, r, n)
    },
    tag: "svg",
    props: {
      createSVGRect: {
        value: function () {
          return dB.createElement(this.ownerDocument, "rect", null)
        },
      },
    },
  })
  XU({
    tags: [
      "a",
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animate",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "circle",
      "clipPath",
      "color-profile",
      "cursor",
      "defs",
      "desc",
      "ellipse",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "filter",
      "font",
      "font-face",
      "font-face-format",
      "font-face-name",
      "font-face-src",
      "font-face-uri",
      "foreignObject",
      "g",
      "glyph",
      "glyphRef",
      "hkern",
      "image",
      "line",
      "linearGradient",
      "marker",
      "mask",
      "metadata",
      "missing-glyph",
      "mpath",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialGradient",
      "rect",
      "script",
      "set",
      "stop",
      "style",
      "switch",
      "symbol",
      "text",
      "textPath",
      "title",
      "tref",
      "tspan",
      "use",
      "view",
      "vkern",
    ],
  })
})
var Hj = _((PSt, Vj) => {
  "use strict"
  Vj.exports = {
    VALUE: 1,
    ATTR: 2,
    REMOVE_ATTR: 3,
    REMOVE: 4,
    MOVE: 5,
    INSERT: 6,
  }
})
var hB = _((LSt, Xj) => {
  "use strict"
  Xj.exports = qb
  var Hs = xs(),
    KPe = up(),
    zj = zI(),
    rh = e0(),
    zPe = FU(),
    JPe = NU(),
    Ob = YA(),
    jPe = LU(),
    ZPe = OU(),
    XPe = Vb(),
    eLe = pj(),
    tLe = bj(),
    Wj = Pb(),
    Gj = oB(),
    $j = eB(),
    rLe = zU(),
    fB = JI(),
    rO = uB(),
    nLe = tO(),
    qr = oi(),
    i0 = Hj(),
    o0 = qr.NAMESPACE,
    nO = $I().isApiWritable
  function qb(e, t) {
    zj.call(this),
      (this.nodeType = Hs.DOCUMENT_NODE),
      (this.isHTML = e),
      (this._address = t || "about:blank"),
      (this.readyState = "loading"),
      (this.implementation = new XPe(this)),
      (this.ownerDocument = null),
      (this._contentType = e ? "text/html" : "application/xml"),
      (this.doctype = null),
      (this.documentElement = null),
      (this._templateDocCache = null),
      (this._nodeIterators = null),
      (this._nid = 1),
      (this._nextnid = 2),
      (this._nodes = [null, this]),
      (this.byId = Object.create(null)),
      (this.modclock = 0)
  }
  var iLe = {
      event: "Event",
      customevent: "CustomEvent",
      uievent: "UIEvent",
      mouseevent: "MouseEvent",
    },
    sLe = {
      events: "event",
      htmlevents: "event",
      mouseevents: "mouseevent",
      mutationevents: "mutationevent",
      uievents: "uievent",
    },
    s0 = function (e, t, r) {
      return {
        get: function () {
          var n = e.call(this)
          return n ? n[t] : r
        },
        set: function (n) {
          var i = e.call(this)
          i && (i[t] = n)
        },
      }
    }
  function Yj(e, t) {
    var r, n, i
    return (
      e === "" && (e = null),
      fB.isValidQName(t) || qr.InvalidCharacterError(),
      (r = null),
      (n = t),
      (i = t.indexOf(":")),
      i >= 0 && ((r = t.substring(0, i)), (n = t.substring(i + 1))),
      r !== null && e === null && qr.NamespaceError(),
      r === "xml" && e !== o0.XML && qr.NamespaceError(),
      (r === "xmlns" || t === "xmlns") && e !== o0.XMLNS && qr.NamespaceError(),
      e === o0.XMLNS &&
        !(r === "xmlns" || t === "xmlns") &&
        qr.NamespaceError(),
      { namespace: e, prefix: r, localName: n }
    )
  }
  qb.prototype = Object.create(zj.prototype, {
    _setMutationHandler: {
      value: function (e) {
        this.mutationHandler = e
      },
    },
    _dispatchRendererEvent: {
      value: function (e, t, r) {
        var n = this._nodes[e]
        n && n._dispatchEvent(new Ob(t, r), true)
      },
    },
    nodeName: { value: "#document" },
    nodeValue: {
      get: function () {
        return null
      },
      set: function () {},
    },
    documentURI: {
      get: function () {
        return this._address
      },
      set: qr.nyi,
    },
    compatMode: {
      get: function () {
        return this._quirks ? "BackCompat" : "CSS1Compat"
      },
    },
    createTextNode: {
      value: function (e) {
        return new zPe(this, String(e))
      },
    },
    createComment: {
      value: function (e) {
        return new JPe(this, e)
      },
    },
    createDocumentFragment: {
      value: function () {
        return new jPe(this)
      },
    },
    createProcessingInstruction: {
      value: function (e, t) {
        return (
          (!fB.isValidName(e) || t.indexOf("?>") !== -1) &&
            qr.InvalidCharacterError(),
          new ZPe(this, e, t)
        )
      },
    },
    createAttribute: {
      value: function (e) {
        return (
          (e = String(e)),
          fB.isValidName(e) || qr.InvalidCharacterError(),
          this.isHTML && (e = qr.toASCIILowerCase(e)),
          new rh._Attr(null, e, null, null, "")
        )
      },
    },
    createAttributeNS: {
      value: function (e, t) {
        ;(e = e == null || e === "" ? null : String(e)), (t = String(t))
        var r = Yj(e, t)
        return new rh._Attr(null, r.localName, r.prefix, r.namespace, "")
      },
    },
    createElement: {
      value: function (e) {
        return (
          (e = String(e)),
          fB.isValidName(e) || qr.InvalidCharacterError(),
          this.isHTML
            ? (/[A-Z]/.test(e) && (e = qr.toASCIILowerCase(e)),
              rO.createElement(this, e, null))
            : this.contentType === "application/xhtml+xml"
              ? rO.createElement(this, e, null)
              : new rh(this, e, null, null)
        )
      },
      writable: nO,
    },
    createElementNS: {
      value: function (e, t) {
        ;(e = e == null || e === "" ? null : String(e)), (t = String(t))
        var r = Yj(e, t)
        return this._createElementNS(r.localName, r.namespace, r.prefix)
      },
      writable: nO,
    },
    _createElementNS: {
      value: function (e, t, r) {
        return t === o0.HTML
          ? rO.createElement(this, e, r)
          : t === o0.SVG
            ? nLe.createElement(this, e, r)
            : new rh(this, e, t, r)
      },
    },
    createEvent: {
      value: function (t) {
        t = t.toLowerCase()
        var r = sLe[t] || t,
          n = rLe[iLe[r]]
        if (n) {
          var i = new n()
          return (i._initialized = false), i
        } else qr.NotSupportedError()
      },
    },
    createTreeWalker: {
      value: function (e, t, r) {
        if (!e) throw new TypeError("root argument is required")
        if (!(e instanceof Hs)) throw new TypeError("root not a node")
        return (
          (t = t === undefined ? Wj.SHOW_ALL : +t),
          (r = r === undefined ? null : r),
          new eLe(e, t, r)
        )
      },
    },
    createNodeIterator: {
      value: function (e, t, r) {
        if (!e) throw new TypeError("root argument is required")
        if (!(e instanceof Hs)) throw new TypeError("root not a node")
        return (
          (t = t === undefined ? Wj.SHOW_ALL : +t),
          (r = r === undefined ? null : r),
          new tLe(e, t, r)
        )
      },
    },
    _attachNodeIterator: {
      value: function (e) {
        this._nodeIterators || (this._nodeIterators = []),
          this._nodeIterators.push(e)
      },
    },
    _detachNodeIterator: {
      value: function (e) {
        var t = this._nodeIterators.indexOf(e)
        this._nodeIterators.splice(t, 1)
      },
    },
    _preremoveNodeIterators: {
      value: function (e) {
        this._nodeIterators &&
          this._nodeIterators.forEach(function (t) {
            t._preremove(e)
          })
      },
    },
    _updateDocTypeElement: {
      value: function () {
        this.doctype = this.documentElement = null
        for (var t = this.firstChild; t !== null; t = t.nextSibling)
          t.nodeType === Hs.DOCUMENT_TYPE_NODE
            ? (this.doctype = t)
            : t.nodeType === Hs.ELEMENT_NODE && (this.documentElement = t)
      },
    },
    insertBefore: {
      value: function (t, r) {
        return (
          Hs.prototype.insertBefore.call(this, t, r),
          this._updateDocTypeElement(),
          t
        )
      },
    },
    replaceChild: {
      value: function (t, r) {
        return (
          Hs.prototype.replaceChild.call(this, t, r),
          this._updateDocTypeElement(),
          r
        )
      },
    },
    removeChild: {
      value: function (t) {
        return (
          Hs.prototype.removeChild.call(this, t),
          this._updateDocTypeElement(),
          t
        )
      },
    },
    getElementById: {
      value: function (e) {
        var t = this.byId[e]
        return t ? (t instanceof Nd ? t.getFirst() : t) : null
      },
    },
    _hasMultipleElementsWithId: {
      value: function (e) {
        return this.byId[e] instanceof Nd
      },
    },
    getElementsByName: { value: rh.prototype.getElementsByName },
    getElementsByTagName: { value: rh.prototype.getElementsByTagName },
    getElementsByTagNameNS: { value: rh.prototype.getElementsByTagNameNS },
    getElementsByClassName: { value: rh.prototype.getElementsByClassName },
    adoptNode: {
      value: function (t) {
        return (
          t.nodeType === Hs.DOCUMENT_NODE && qr.NotSupportedError(),
          t.nodeType === Hs.ATTRIBUTE_NODE ||
            (t.parentNode && t.parentNode.removeChild(t),
            t.ownerDocument !== this && Zj(t, this)),
          t
        )
      },
    },
    importNode: {
      value: function (t, r) {
        return this.adoptNode(t.cloneNode(r))
      },
      writable: nO,
    },
    origin: {
      get: function () {
        return null
      },
    },
    characterSet: {
      get: function () {
        return "UTF-8"
      },
    },
    contentType: {
      get: function () {
        return this._contentType
      },
    },
    URL: {
      get: function () {
        return this._address
      },
    },
    domain: { get: qr.nyi, set: qr.nyi },
    referrer: { get: qr.nyi },
    cookie: { get: qr.nyi, set: qr.nyi },
    lastModified: { get: qr.nyi },
    location: {
      get: function () {
        return this.defaultView ? this.defaultView.location : null
      },
      set: qr.nyi,
    },
    _titleElement: {
      get: function () {
        return this.getElementsByTagName("title").item(0) || null
      },
    },
    title: {
      get: function () {
        var e = this._titleElement,
          t = e ? e.textContent : ""
        return t.replace(/[ \t\n\r\f]+/g, " ").replace(/(^ )|( $)/g, "")
      },
      set: function (e) {
        var t = this._titleElement,
          r = this.head
        ;(!t && !r) ||
          (t || ((t = this.createElement("title")), r.appendChild(t)),
          (t.textContent = e))
      },
    },
    dir: s0(
      function () {
        var e = this.documentElement
        if (e && e.tagName === "HTML") return e
      },
      "dir",
      "",
    ),
    fgColor: s0(
      function () {
        return this.body
      },
      "text",
      "",
    ),
    linkColor: s0(
      function () {
        return this.body
      },
      "link",
      "",
    ),
    vlinkColor: s0(
      function () {
        return this.body
      },
      "vLink",
      "",
    ),
    alinkColor: s0(
      function () {
        return this.body
      },
      "aLink",
      "",
    ),
    bgColor: s0(
      function () {
        return this.body
      },
      "bgColor",
      "",
    ),
    charset: {
      get: function () {
        return this.characterSet
      },
    },
    inputEncoding: {
      get: function () {
        return this.characterSet
      },
    },
    scrollingElement: {
      get: function () {
        return this._quirks ? this.body : this.documentElement
      },
    },
    body: {
      get: function () {
        return Kj(this.documentElement, "body")
      },
      set: qr.nyi,
    },
    head: {
      get: function () {
        return Kj(this.documentElement, "head")
      },
    },
    images: { get: qr.nyi },
    embeds: { get: qr.nyi },
    plugins: { get: qr.nyi },
    links: { get: qr.nyi },
    forms: { get: qr.nyi },
    scripts: { get: qr.nyi },
    applets: {
      get: function () {
        return []
      },
    },
    activeElement: {
      get: function () {
        return null
      },
    },
    innerHTML: {
      get: function () {
        return this.serialize()
      },
      set: qr.nyi,
    },
    outerHTML: {
      get: function () {
        return this.serialize()
      },
      set: qr.nyi,
    },
    write: {
      value: function (e) {
        if ((this.isHTML || qr.InvalidStateError(), !!this._parser)) {
          this._parser
          var t = arguments.join("")
          this._parser.parse(t)
        }
      },
    },
    writeln: {
      value: function (t) {
        this.write(
          Array.prototype.join.call(arguments, "") +
            `
`,
        )
      },
    },
    open: {
      value: function () {
        this.documentElement = null
      },
    },
    close: {
      value: function () {
        ;(this.readyState = "interactive"),
          this._dispatchEvent(new Ob("readystatechange"), true),
          this._dispatchEvent(new Ob("DOMContentLoaded"), true),
          (this.readyState = "complete"),
          this._dispatchEvent(new Ob("readystatechange"), true),
          this.defaultView &&
            this.defaultView._dispatchEvent(new Ob("load"), true)
      },
    },
    clone: {
      value: function () {
        var t = new qb(this.isHTML, this._address)
        return (
          (t._quirks = this._quirks), (t._contentType = this._contentType), t
        )
      },
    },
    cloneNode: {
      value: function (t) {
        var r = Hs.prototype.cloneNode.call(this, false)
        if (t)
          for (var n = this.firstChild; n !== null; n = n.nextSibling)
            r._appendChild(r.importNode(n, true))
        return r._updateDocTypeElement(), r
      },
    },
    isEqual: {
      value: function (t) {
        return true
      },
    },
    mutateValue: {
      value: function (e) {
        this.mutationHandler &&
          this.mutationHandler({ type: i0.VALUE, target: e, data: e.data })
      },
    },
    mutateAttr: {
      value: function (e, t) {
        this.mutationHandler &&
          this.mutationHandler({
            type: i0.ATTR,
            target: e.ownerElement,
            attr: e,
          })
      },
    },
    mutateRemoveAttr: {
      value: function (e) {
        this.mutationHandler &&
          this.mutationHandler({
            type: i0.REMOVE_ATTR,
            target: e.ownerElement,
            attr: e,
          })
      },
    },
    mutateRemove: {
      value: function (e) {
        this.mutationHandler &&
          this.mutationHandler({
            type: i0.REMOVE,
            target: e.parentNode,
            node: e,
          }),
          jj(e)
      },
    },
    mutateInsert: {
      value: function (e) {
        Jj(e),
          this.mutationHandler &&
            this.mutationHandler({
              type: i0.INSERT,
              target: e.parentNode,
              node: e,
            })
      },
    },
    mutateMove: {
      value: function (e) {
        this.mutationHandler &&
          this.mutationHandler({ type: i0.MOVE, target: e })
      },
    },
    addId: {
      value: function (t, r) {
        var n = this.byId[t]
        n
          ? (n instanceof Nd || ((n = new Nd(n)), (this.byId[t] = n)), n.add(r))
          : (this.byId[t] = r)
      },
    },
    delId: {
      value: function (t, r) {
        var n = this.byId[t]
        qr.assert(n),
          n instanceof Nd
            ? (n.del(r), n.length === 1 && (this.byId[t] = n.downgrade()))
            : (this.byId[t] = undefined)
      },
    },
    _resolve: {
      value: function (e) {
        return new Gj(this._documentBaseURL).resolve(e)
      },
    },
    _documentBaseURL: {
      get: function () {
        var e = this._address
        e === "about:blank" && (e = "/")
        var t = this.querySelector("base[href]")
        return t ? new Gj(e).resolve(t.getAttribute("href")) : e
      },
    },
    _templateDoc: {
      get: function () {
        if (!this._templateDocCache) {
          var e = new qb(this.isHTML, this._address)
          this._templateDocCache = e._templateDocCache = e
        }
        return this._templateDocCache
      },
    },
    querySelector: {
      value: function (e) {
        return $j(e, this)[0]
      },
    },
    querySelectorAll: {
      value: function (e) {
        var t = $j(e, this)
        return t.item ? t : new KPe(t)
      },
    },
  })
  var oLe = [
    "abort",
    "canplay",
    "canplaythrough",
    "change",
    "click",
    "contextmenu",
    "cuechange",
    "dblclick",
    "drag",
    "dragend",
    "dragenter",
    "dragleave",
    "dragover",
    "dragstart",
    "drop",
    "durationchange",
    "emptied",
    "ended",
    "input",
    "invalid",
    "keydown",
    "keypress",
    "keyup",
    "loadeddata",
    "loadedmetadata",
    "loadstart",
    "mousedown",
    "mousemove",
    "mouseout",
    "mouseover",
    "mouseup",
    "mousewheel",
    "pause",
    "play",
    "playing",
    "progress",
    "ratechange",
    "readystatechange",
    "reset",
    "seeked",
    "seeking",
    "select",
    "show",
    "stalled",
    "submit",
    "suspend",
    "timeupdate",
    "volumechange",
    "waiting",
    "blur",
    "error",
    "focus",
    "load",
    "scroll",
  ]
  oLe.forEach(function (e) {
    Object.defineProperty(qb.prototype, "on" + e, {
      get: function () {
        return this._getEventHandler(e)
      },
      set: function (t) {
        this._setEventHandler(e, t)
      },
    })
  })
  function Kj(e, t) {
    if (e && e.isHTML) {
      for (var r = e.firstChild; r !== null; r = r.nextSibling)
        if (
          r.nodeType === Hs.ELEMENT_NODE &&
          r.localName === t &&
          r.namespaceURI === o0.HTML
        )
          return r
    }
    return null
  }
  function aLe(e) {
    if (
      ((e._nid = e.ownerDocument._nextnid++),
      (e.ownerDocument._nodes[e._nid] = e),
      e.nodeType === Hs.ELEMENT_NODE)
    ) {
      var t = e.getAttribute("id")
      t && e.ownerDocument.addId(t, e), e._roothook && e._roothook()
    }
  }
  function lLe(e) {
    if (e.nodeType === Hs.ELEMENT_NODE) {
      var t = e.getAttribute("id")
      t && e.ownerDocument.delId(t, e)
    }
    ;(e.ownerDocument._nodes[e._nid] = undefined), (e._nid = undefined)
  }
  function Jj(e) {
    if ((aLe(e), e.nodeType === Hs.ELEMENT_NODE))
      for (var t = e.firstChild; t !== null; t = t.nextSibling) Jj(t)
  }
  function jj(e) {
    lLe(e)
    for (var t = e.firstChild; t !== null; t = t.nextSibling) jj(t)
  }
  function Zj(e, t) {
    ;(e.ownerDocument = t),
      (e._lastModTime = undefined),
      Object.prototype.hasOwnProperty.call(e, "_tagName") &&
        (e._tagName = undefined)
    for (var r = e.firstChild; r !== null; r = r.nextSibling) Zj(r, t)
  }
  function Nd(e) {
    ;(this.nodes = Object.create(null)),
      (this.nodes[e._nid] = e),
      (this.length = 1),
      (this.firstNode = undefined)
  }
  Nd.prototype.add = function (e) {
    this.nodes[e._nid] ||
      ((this.nodes[e._nid] = e), this.length++, (this.firstNode = undefined))
  }
  Nd.prototype.del = function (e) {
    this.nodes[e._nid] &&
      (delete this.nodes[e._nid], this.length--, (this.firstNode = undefined))
  }
  Nd.prototype.getFirst = function () {
    if (!this.firstNode) {
      var e
      for (e in this.nodes)
        (this.firstNode === undefined ||
          this.firstNode.compareDocumentPosition(this.nodes[e]) &
            Hs.DOCUMENT_POSITION_PRECEDING) &&
          (this.firstNode = this.nodes[e])
    }
    return this.firstNode
  }
  Nd.prototype.downgrade = function () {
    if (this.length === 1) {
      var e
      for (e in this.nodes) return this.nodes[e]
    }
    return this
  }
})
var pB = _((USt, t7) => {
  "use strict"
  t7.exports = gB
  var cLe = xs(),
    e7 = kU(),
    uLe = tB()
  function gB(e, t, r, n) {
    e7.call(this),
      (this.nodeType = cLe.DOCUMENT_TYPE_NODE),
      (this.ownerDocument = e || null),
      (this.name = t),
      (this.publicId = r || ""),
      (this.systemId = n || "")
  }
  gB.prototype = Object.create(e7.prototype, {
    nodeName: {
      get: function () {
        return this.name
      },
    },
    nodeValue: {
      get: function () {
        return null
      },
      set: function () {},
    },
    clone: {
      value: function () {
        return new gB(
          this.ownerDocument,
          this.name,
          this.publicId,
          this.systemId,
        )
      },
    },
    isEqual: {
      value: function (t) {
        return (
          this.name === t.name &&
          this.publicId === t.publicId &&
          this.systemId === t.systemId
        )
      },
    },
  })
  Object.defineProperties(gB.prototype, uLe)
})
var EB = _((OSt, x7) => {
  "use strict"
  x7.exports = Qr
  var dLe = hB(),
    fLe = pB(),
    iO = xs(),
    lt = oi().NAMESPACE,
    m7 = uB(),
    en = m7.elements,
    fp = Function.prototype.apply.bind(Array.prototype.push),
    mB = -1,
    a0 = 1,
    Ws = 2,
    ur = 3,
    Au = 4,
    hLe = 5,
    gLe = [],
    pLe =
      /^HTML$|^-\/\/W3O\/\/DTD W3 HTML Strict 3\.0\/\/EN\/\/$|^-\/W3C\/DTD HTML 4\.0 Transitional\/EN$|^\+\/\/Silmaril\/\/dtd html Pro v0r11 19970101\/\/|^-\/\/AdvaSoft Ltd\/\/DTD HTML 3\.0 asWedit \+ extensions\/\/|^-\/\/AS\/\/DTD HTML 3\.0 asWedit \+ extensions\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Level 1\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Level 2\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict Level 1\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict Level 2\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict\/\/|^-\/\/IETF\/\/DTD HTML 2\.0\/\/|^-\/\/IETF\/\/DTD HTML 2\.1E\/\/|^-\/\/IETF\/\/DTD HTML 3\.0\/\/|^-\/\/IETF\/\/DTD HTML 3\.2 Final\/\/|^-\/\/IETF\/\/DTD HTML 3\.2\/\/|^-\/\/IETF\/\/DTD HTML 3\/\/|^-\/\/IETF\/\/DTD HTML Level 0\/\/|^-\/\/IETF\/\/DTD HTML Level 1\/\/|^-\/\/IETF\/\/DTD HTML Level 2\/\/|^-\/\/IETF\/\/DTD HTML Level 3\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 0\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 1\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 2\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 3\/\/|^-\/\/IETF\/\/DTD HTML Strict\/\/|^-\/\/IETF\/\/DTD HTML\/\/|^-\/\/Metrius\/\/DTD Metrius Presentational\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 HTML Strict\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 HTML\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 Tables\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 HTML Strict\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 HTML\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 Tables\/\/|^-\/\/Netscape Comm\. Corp\.\/\/DTD HTML\/\/|^-\/\/Netscape Comm\. Corp\.\/\/DTD Strict HTML\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML 2\.0\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML Extended 1\.0\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML Extended Relaxed 1\.0\/\/|^-\/\/SoftQuad Software\/\/DTD HoTMetaL PRO 6\.0::19990601::extensions to HTML 4\.0\/\/|^-\/\/SoftQuad\/\/DTD HoTMetaL PRO 4\.0::19971010::extensions to HTML 4\.0\/\/|^-\/\/Spyglass\/\/DTD HTML 2\.0 Extended\/\/|^-\/\/SQ\/\/DTD HTML 2\.0 HoTMetaL \+ extensions\/\/|^-\/\/Sun Microsystems Corp\.\/\/DTD HotJava HTML\/\/|^-\/\/Sun Microsystems Corp\.\/\/DTD HotJava Strict HTML\/\/|^-\/\/W3C\/\/DTD HTML 3 1995-03-24\/\/|^-\/\/W3C\/\/DTD HTML 3\.2 Draft\/\/|^-\/\/W3C\/\/DTD HTML 3\.2 Final\/\/|^-\/\/W3C\/\/DTD HTML 3\.2\/\/|^-\/\/W3C\/\/DTD HTML 3\.2S Draft\/\/|^-\/\/W3C\/\/DTD HTML 4\.0 Frameset\/\/|^-\/\/W3C\/\/DTD HTML 4\.0 Transitional\/\/|^-\/\/W3C\/\/DTD HTML Experimental 19960712\/\/|^-\/\/W3C\/\/DTD HTML Experimental 970421\/\/|^-\/\/W3C\/\/DTD W3 HTML\/\/|^-\/\/W3O\/\/DTD W3 HTML 3\.0\/\/|^-\/\/WebTechs\/\/DTD Mozilla HTML 2\.0\/\/|^-\/\/WebTechs\/\/DTD Mozilla HTML\/\//i,
    mLe = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd",
    r7 =
      /^-\/\/W3C\/\/DTD HTML 4\.01 Frameset\/\/|^-\/\/W3C\/\/DTD HTML 4\.01 Transitional\/\//i,
    ALe =
      /^-\/\/W3C\/\/DTD XHTML 1\.0 Frameset\/\/|^-\/\/W3C\/\/DTD XHTML 1\.0 Transitional\/\//i,
    gp = Object.create(null)
  gp[lt.HTML] = {
    __proto__: null,
    address: true,
    applet: true,
    area: true,
    article: true,
    aside: true,
    base: true,
    basefont: true,
    bgsound: true,
    blockquote: true,
    body: true,
    br: true,
    button: true,
    caption: true,
    center: true,
    col: true,
    colgroup: true,
    dd: true,
    details: true,
    dir: true,
    div: true,
    dl: true,
    dt: true,
    embed: true,
    fieldset: true,
    figcaption: true,
    figure: true,
    footer: true,
    form: true,
    frame: true,
    frameset: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    head: true,
    header: true,
    hgroup: true,
    hr: true,
    html: true,
    iframe: true,
    img: true,
    input: true,
    li: true,
    link: true,
    listing: true,
    main: true,
    marquee: true,
    menu: true,
    meta: true,
    nav: true,
    noembed: true,
    noframes: true,
    noscript: true,
    object: true,
    ol: true,
    p: true,
    param: true,
    plaintext: true,
    pre: true,
    script: true,
    section: true,
    select: true,
    source: true,
    style: true,
    summary: true,
    table: true,
    tbody: true,
    td: true,
    template: true,
    textarea: true,
    tfoot: true,
    th: true,
    thead: true,
    title: true,
    tr: true,
    track: true,
    ul: true,
    wbr: true,
    xmp: true,
  }
  gp[lt.SVG] = { __proto__: null, foreignObject: true, desc: true, title: true }
  gp[lt.MATHML] = {
    __proto__: null,
    mi: true,
    mo: true,
    mn: true,
    ms: true,
    mtext: true,
    "annotation-xml": true,
  }
  var aO = Object.create(null)
  aO[lt.HTML] = { __proto__: null, address: true, div: true, p: true }
  var A7 = Object.create(null)
  A7[lt.HTML] = { __proto__: null, dd: true, dt: true }
  var l0 = Object.create(null)
  l0[lt.HTML] = {
    __proto__: null,
    table: true,
    thead: true,
    tbody: true,
    tfoot: true,
    tr: true,
  }
  var y7 = Object.create(null)
  y7[lt.HTML] = {
    __proto__: null,
    dd: true,
    dt: true,
    li: true,
    menuitem: true,
    optgroup: true,
    option: true,
    p: true,
    rb: true,
    rp: true,
    rt: true,
    rtc: true,
  }
  var v7 = Object.create(null)
  v7[lt.HTML] = {
    __proto__: null,
    caption: true,
    colgroup: true,
    dd: true,
    dt: true,
    li: true,
    optgroup: true,
    option: true,
    p: true,
    rb: true,
    rp: true,
    rt: true,
    rtc: true,
    tbody: true,
    td: true,
    tfoot: true,
    th: true,
    thead: true,
    tr: true,
  }
  var vB = Object.create(null)
  vB[lt.HTML] = { __proto__: null, table: true, template: true, html: true }
  var CB = Object.create(null)
  CB[lt.HTML] = {
    __proto__: null,
    tbody: true,
    tfoot: true,
    thead: true,
    template: true,
    html: true,
  }
  var lO = Object.create(null)
  lO[lt.HTML] = { __proto__: null, tr: true, template: true, html: true }
  var C7 = Object.create(null)
  C7[lt.HTML] = {
    __proto__: null,
    button: true,
    fieldset: true,
    input: true,
    keygen: true,
    object: true,
    output: true,
    select: true,
    textarea: true,
    img: true,
  }
  var yu = Object.create(null)
  yu[lt.HTML] = {
    __proto__: null,
    applet: true,
    caption: true,
    html: true,
    table: true,
    td: true,
    th: true,
    marquee: true,
    object: true,
    template: true,
  }
  yu[lt.MATHML] = {
    __proto__: null,
    mi: true,
    mo: true,
    mn: true,
    ms: true,
    mtext: true,
    "annotation-xml": true,
  }
  yu[lt.SVG] = { __proto__: null, foreignObject: true, desc: true, title: true }
  var bB = Object.create(yu)
  bB[lt.HTML] = Object.create(yu[lt.HTML])
  bB[lt.HTML].ol = true
  bB[lt.HTML].ul = true
  var cO = Object.create(yu)
  cO[lt.HTML] = Object.create(yu[lt.HTML])
  cO[lt.HTML].button = true
  var b7 = Object.create(null)
  b7[lt.HTML] = { __proto__: null, html: true, table: true, template: true }
  var yLe = Object.create(null)
  yLe[lt.HTML] = { __proto__: null, optgroup: true, option: true }
  var E7 = Object.create(null)
  E7[lt.MATHML] = { __proto__: null, mi: true, mo: true, mn: true, ms: true, mtext: true }
  var _7 = Object.create(null)
  _7[lt.SVG] = { __proto__: null, foreignObject: true, desc: true, title: true }
  var n7 = {
      __proto__: null,
      "xlink:actuate": lt.XLINK,
      "xlink:arcrole": lt.XLINK,
      "xlink:href": lt.XLINK,
      "xlink:role": lt.XLINK,
      "xlink:show": lt.XLINK,
      "xlink:title": lt.XLINK,
      "xlink:type": lt.XLINK,
      "xml:base": lt.XML,
      "xml:lang": lt.XML,
      "xml:space": lt.XML,
      xmlns: lt.XMLNS,
      "xmlns:xlink": lt.XMLNS,
    },
    i7 = {
      __proto__: null,
      attributename: "attributeName",
      attributetype: "attributeType",
      basefrequency: "baseFrequency",
      baseprofile: "baseProfile",
      calcmode: "calcMode",
      clippathunits: "clipPathUnits",
      diffuseconstant: "diffuseConstant",
      edgemode: "edgeMode",
      filterunits: "filterUnits",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      limitingconeangle: "limitingConeAngle",
      markerheight: "markerHeight",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      numoctaves: "numOctaves",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      refx: "refX",
      refy: "refY",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stitchtiles: "stitchTiles",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textlength: "textLength",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      xchannelselector: "xChannelSelector",
      ychannelselector: "yChannelSelector",
      zoomandpan: "zoomAndPan",
    },
    s7 = {
      __proto__: null,
      altglyph: "altGlyph",
      altglyphdef: "altGlyphDef",
      altglyphitem: "altGlyphItem",
      animatecolor: "animateColor",
      animatemotion: "animateMotion",
      animatetransform: "animateTransform",
      clippath: "clipPath",
      feblend: "feBlend",
      fecolormatrix: "feColorMatrix",
      fecomponenttransfer: "feComponentTransfer",
      fecomposite: "feComposite",
      feconvolvematrix: "feConvolveMatrix",
      fediffuselighting: "feDiffuseLighting",
      fedisplacementmap: "feDisplacementMap",
      fedistantlight: "feDistantLight",
      feflood: "feFlood",
      fefunca: "feFuncA",
      fefuncb: "feFuncB",
      fefuncg: "feFuncG",
      fefuncr: "feFuncR",
      fegaussianblur: "feGaussianBlur",
      feimage: "feImage",
      femerge: "feMerge",
      femergenode: "feMergeNode",
      femorphology: "feMorphology",
      feoffset: "feOffset",
      fepointlight: "fePointLight",
      fespecularlighting: "feSpecularLighting",
      fespotlight: "feSpotLight",
      fetile: "feTile",
      feturbulence: "feTurbulence",
      foreignobject: "foreignObject",
      glyphref: "glyphRef",
      lineargradient: "linearGradient",
      radialgradient: "radialGradient",
      textpath: "textPath",
    },
    o7 = {
      __proto__: null,
      0: 65533,
      128: 8364,
      130: 8218,
      131: 402,
      132: 8222,
      133: 8230,
      134: 8224,
      135: 8225,
      136: 710,
      137: 8240,
      138: 352,
      139: 8249,
      140: 338,
      142: 381,
      145: 8216,
      146: 8217,
      147: 8220,
      148: 8221,
      149: 8226,
      150: 8211,
      151: 8212,
      152: 732,
      153: 8482,
      154: 353,
      155: 8250,
      156: 339,
      158: 382,
      159: 376,
    },
    vLe = {
      __proto__: null,
      AElig: 198,
      "AElig;": 198,
      AMP: 38,
      "AMP;": 38,
      Aacute: 193,
      "Aacute;": 193,
      "Abreve;": 258,
      Acirc: 194,
      "Acirc;": 194,
      "Acy;": 1040,
      "Afr;": [55349, 56580],
      Agrave: 192,
      "Agrave;": 192,
      "Alpha;": 913,
      "Amacr;": 256,
      "And;": 10835,
      "Aogon;": 260,
      "Aopf;": [55349, 56632],
      "ApplyFunction;": 8289,
      Aring: 197,
      "Aring;": 197,
      "Ascr;": [55349, 56476],
      "Assign;": 8788,
      Atilde: 195,
      "Atilde;": 195,
      Auml: 196,
      "Auml;": 196,
      "Backslash;": 8726,
      "Barv;": 10983,
      "Barwed;": 8966,
      "Bcy;": 1041,
      "Because;": 8757,
      "Bernoullis;": 8492,
      "Beta;": 914,
      "Bfr;": [55349, 56581],
      "Bopf;": [55349, 56633],
      "Breve;": 728,
      "Bscr;": 8492,
      "Bumpeq;": 8782,
      "CHcy;": 1063,
      COPY: 169,
      "COPY;": 169,
      "Cacute;": 262,
      "Cap;": 8914,
      "CapitalDifferentialD;": 8517,
      "Cayleys;": 8493,
      "Ccaron;": 268,
      Ccedil: 199,
      "Ccedil;": 199,
      "Ccirc;": 264,
      "Cconint;": 8752,
      "Cdot;": 266,
      "Cedilla;": 184,
      "CenterDot;": 183,
      "Cfr;": 8493,
      "Chi;": 935,
      "CircleDot;": 8857,
      "CircleMinus;": 8854,
      "CirclePlus;": 8853,
      "CircleTimes;": 8855,
      "ClockwiseContourIntegral;": 8754,
      "CloseCurlyDoubleQuote;": 8221,
      "CloseCurlyQuote;": 8217,
      "Colon;": 8759,
      "Colone;": 10868,
      "Congruent;": 8801,
      "Conint;": 8751,
      "ContourIntegral;": 8750,
      "Copf;": 8450,
      "Coproduct;": 8720,
      "CounterClockwiseContourIntegral;": 8755,
      "Cross;": 10799,
      "Cscr;": [55349, 56478],
      "Cup;": 8915,
      "CupCap;": 8781,
      "DD;": 8517,
      "DDotrahd;": 10513,
      "DJcy;": 1026,
      "DScy;": 1029,
      "DZcy;": 1039,
      "Dagger;": 8225,
      "Darr;": 8609,
      "Dashv;": 10980,
      "Dcaron;": 270,
      "Dcy;": 1044,
      "Del;": 8711,
      "Delta;": 916,
      "Dfr;": [55349, 56583],
      "DiacriticalAcute;": 180,
      "DiacriticalDot;": 729,
      "DiacriticalDoubleAcute;": 733,
      "DiacriticalGrave;": 96,
      "DiacriticalTilde;": 732,
      "Diamond;": 8900,
      "DifferentialD;": 8518,
      "Dopf;": [55349, 56635],
      "Dot;": 168,
      "DotDot;": 8412,
      "DotEqual;": 8784,
      "DoubleContourIntegral;": 8751,
      "DoubleDot;": 168,
      "DoubleDownArrow;": 8659,
      "DoubleLeftArrow;": 8656,
      "DoubleLeftRightArrow;": 8660,
      "DoubleLeftTee;": 10980,
      "DoubleLongLeftArrow;": 10232,
      "DoubleLongLeftRightArrow;": 10234,
      "DoubleLongRightArrow;": 10233,
      "DoubleRightArrow;": 8658,
      "DoubleRightTee;": 8872,
      "DoubleUpArrow;": 8657,
      "DoubleUpDownArrow;": 8661,
      "DoubleVerticalBar;": 8741,
      "DownArrow;": 8595,
      "DownArrowBar;": 10515,
      "DownArrowUpArrow;": 8693,
      "DownBreve;": 785,
      "DownLeftRightVector;": 10576,
      "DownLeftTeeVector;": 10590,
      "DownLeftVector;": 8637,
      "DownLeftVectorBar;": 10582,
      "DownRightTeeVector;": 10591,
      "DownRightVector;": 8641,
      "DownRightVectorBar;": 10583,
      "DownTee;": 8868,
      "DownTeeArrow;": 8615,
      "Downarrow;": 8659,
      "Dscr;": [55349, 56479],
      "Dstrok;": 272,
      "ENG;": 330,
      ETH: 208,
      "ETH;": 208,
      Eacute: 201,
      "Eacute;": 201,
      "Ecaron;": 282,
      Ecirc: 202,
      "Ecirc;": 202,
      "Ecy;": 1069,
      "Edot;": 278,
      "Efr;": [55349, 56584],
      Egrave: 200,
      "Egrave;": 200,
      "Element;": 8712,
      "Emacr;": 274,
      "EmptySmallSquare;": 9723,
      "EmptyVerySmallSquare;": 9643,
      "Eogon;": 280,
      "Eopf;": [55349, 56636],
      "Epsilon;": 917,
      "Equal;": 10869,
      "EqualTilde;": 8770,
      "Equilibrium;": 8652,
      "Escr;": 8496,
      "Esim;": 10867,
      "Eta;": 919,
      Euml: 203,
      "Euml;": 203,
      "Exists;": 8707,
      "ExponentialE;": 8519,
      "Fcy;": 1060,
      "Ffr;": [55349, 56585],
      "FilledSmallSquare;": 9724,
      "FilledVerySmallSquare;": 9642,
      "Fopf;": [55349, 56637],
      "ForAll;": 8704,
      "Fouriertrf;": 8497,
      "Fscr;": 8497,
      "GJcy;": 1027,
      GT: 62,
      "GT;": 62,
      "Gamma;": 915,
      "Gammad;": 988,
      "Gbreve;": 286,
      "Gcedil;": 290,
      "Gcirc;": 284,
      "Gcy;": 1043,
      "Gdot;": 288,
      "Gfr;": [55349, 56586],
      "Gg;": 8921,
      "Gopf;": [55349, 56638],
      "GreaterEqual;": 8805,
      "GreaterEqualLess;": 8923,
      "GreaterFullEqual;": 8807,
      "GreaterGreater;": 10914,
      "GreaterLess;": 8823,
      "GreaterSlantEqual;": 10878,
      "GreaterTilde;": 8819,
      "Gscr;": [55349, 56482],
      "Gt;": 8811, // Gt 重命名为 AfterPreviewState
      "HARDcy;": 1066,
      "Hacek;": 711,
      "Hat;": 94,
      "Hcirc;": 292,
      "Hfr;": 8460,
      "HilbertSpace;": 8459,
      "Hopf;": 8461,
      "HorizontalLine;": 9472,
      "Hscr;": 8459,
      "Hstrok;": 294,
      "HumpDownHump;": 8782,
      "HumpEqual;": 8783,
      "IEcy;": 1045,
      "IJlig;": 306,
      "IOcy;": 1025,
      Iacute: 205,
      "Iacute;": 205,
      Icirc: 206,
      "Icirc;": 206,
      "Icy;": 1048,
      "Idot;": 304,
      "Ifr;": 8465,
      Igrave: 204,
      "Igrave;": 204,
      "Im;": 8465,
      "Imacr;": 298,
      "ImaginaryI;": 8520,
      "Implies;": 8658,
      "Int;": 8748,
      "Integral;": 8747,
      "Intersection;": 8898,
      "InvisibleComma;": 8291,
      "InvisibleTimes;": 8290,
      "Iogon;": 302,
      "Iopf;": [55349, 56640],
      "Iota;": 921,
      "Iscr;": 8464,
      "Itilde;": 296,
      "Iukcy;": 1030,
      Iuml: 207,
      "Iuml;": 207,
      "Jcirc;": 308,
      "Jcy;": 1049,
      "Jfr;": [55349, 56589],
      "Jopf;": [55349, 56641],
      "Jscr;": [55349, 56485],
      "Jsercy;": 1032,
      "Jukcy;": 1028,
      "KHcy;": 1061,
      "KJcy;": 1036,
      "Kappa;": 922,
      "Kcedil;": 310,
      "Kcy;": 1050,
      "Kfr;": [55349, 56590],
      "Kopf;": [55349, 56642],
      "Kscr;": [55349, 56486],
      "LJcy;": 1033,
      LT: 60,
      "LT;": 60,
      "Lacute;": 313,
      "Lambda;": 923,
      "Lang;": 10218,
      "Laplacetrf;": 8466,
      "Larr;": 8606,
      "Lcaron;": 317,
      "Lcedil;": 315,
      "Lcy;": 1051,
      "LeftAngleBracket;": 10216,
      "LeftArrow;": 8592,
      "LeftArrowBar;": 8676,
      "LeftArrowRightArrow;": 8646,
      "LeftCeiling;": 8968,
      "LeftDoubleBracket;": 10214,
      "LeftDownTeeVector;": 10593,
      "LeftDownVector;": 8643,
      "LeftDownVectorBar;": 10585,
      "LeftFloor;": 8970,
      "LeftRightArrow;": 8596,
      "LeftRightVector;": 10574,
      "LeftTee;": 8867,
      "LeftTeeArrow;": 8612,
      "LeftTeeVector;": 10586,
      "LeftTriangle;": 8882,
      "LeftTriangleBar;": 10703,
      "LeftTriangleEqual;": 8884,
      "LeftUpDownVector;": 10577,
      "LeftUpTeeVector;": 10592,
      "LeftUpVector;": 8639,
      "LeftUpVectorBar;": 10584,
      "LeftVector;": 8636,
      "LeftVectorBar;": 10578,
      "Leftarrow;": 8656,
      "Leftrightarrow;": 8660,
      "LessEqualGreater;": 8922,
      "LessFullEqual;": 8806,
      "LessGreater;": 8822,
      "LessLess;": 10913,
      "LessSlantEqual;": 10877,
      "LessTilde;": 8818,
      "Lfr;": [55349, 56591],
      "Ll;": 8920,
      "Lleftarrow;": 8666,
      "Lmidot;": 319,
      "LongLeftArrow;": 10229,
      "LongLeftRightArrow;": 10231,
      "LongRightArrow;": 10230,
      "Longleftarrow;": 10232,
      "Longleftrightarrow;": 10234,
      "Longrightarrow;": 10233,
      "Lopf;": [55349, 56643],
      "LowerLeftArrow;": 8601,
      "LowerRightArrow;": 8600,
      "Lscr;": 8466,
      "Lsh;": 8624,
      "Lstrok;": 321,
      "Lt;": 8810,
      "Map;": 10501,
      "Mcy;": 1052,
      "MediumSpace;": 8287,
      "Mellintrf;": 8499,
      "Mfr;": [55349, 56592],
      "MinusPlus;": 8723,
      "Mopf;": [55349, 56644],
      "Mscr;": 8499,
      "Mu;": 924,
      "NJcy;": 1034,
      "Nacute;": 323,
      "Ncaron;": 327,
      "Ncedil;": 325,
      "Ncy;": 1053,
      "NegativeMediumSpace;": 8203,
      "NegativeThickSpace;": 8203,
      "NegativeThinSpace;": 8203,
      "NegativeVeryThinSpace;": 8203,
      "NestedGreaterGreater;": 8811,
      "NestedLessLess;": 8810,
      "NewLine;": 10,
      "Nfr;": [55349, 56593],
      "NoBreak;": 8288,
      "NonBreakingSpace;": 160,
      "Nopf;": 8469,
      "Not;": 10988,
      "NotCongruent;": 8802,
      "NotCupCap;": 8813,
      "NotDoubleVerticalBar;": 8742,
      "NotElement;": 8713,
      "NotEqual;": 8800,
      "NotEqualTilde;": [8770, 824],
      "NotExists;": 8708,
      "NotGreater;": 8815,
      "NotGreaterEqual;": 8817,
      "NotGreaterFullEqual;": [8807, 824],
      "NotGreaterGreater;": [8811, 824],
      "NotGreaterLess;": 8825,
      "NotGreaterSlantEqual;": [10878, 824],
      "NotGreaterTilde;": 8821,
      "NotHumpDownHump;": [8782, 824],
      "NotHumpEqual;": [8783, 824],
      "NotLeftTriangle;": 8938,
      "NotLeftTriangleBar;": [10703, 824],
      "NotLeftTriangleEqual;": 8940,
      "NotLess;": 8814,
      "NotLessEqual;": 8816,
      "NotLessGreater;": 8824,
      "NotLessLess;": [8810, 824],
      "NotLessSlantEqual;": [10877, 824],
      "NotLessTilde;": 8820,
      "NotNestedGreaterGreater;": [10914, 824],
      "NotNestedLessLess;": [10913, 824],
      "NotPrecedes;": 8832,
      "NotPrecedesEqual;": [10927, 824],
      "NotPrecedesSlantEqual;": 8928,
      "NotReverseElement;": 8716,
      "NotRightTriangle;": 8939,
      "NotRightTriangleBar;": [10704, 824],
      "NotRightTriangleEqual;": 8941,
      "NotSquareSubset;": [8847, 824],
      "NotSquareSubsetEqual;": 8930,
      "NotSquareSuperset;": [8848, 824],
      "NotSquareSupersetEqual;": 8931,
      "NotSubset;": [8834, 8402],
      "NotSubsetEqual;": 8840,
      "NotSucceeds;": 8833,
      "NotSucceedsEqual;": [10928, 824],
      "NotSucceedsSlantEqual;": 8929,
      "NotSucceedsTilde;": [8831, 824],
      "NotSuperset;": [8835, 8402],
      "NotSupersetEqual;": 8841,
      "NotTilde;": 8769,
      "NotTildeEqual;": 8772,
      "NotTildeFullEqual;": 8775,
      "NotTildeTilde;": 8777,
      "NotVerticalBar;": 8740,
      "Nscr;": [55349, 56489],
      Ntilde: 209,
      "Ntilde;": 209,
      "Nu;": 925,
      "OElig;": 338,
      Oacute: 211,
      "Oacute;": 211,
      Ocirc: 212,
      "Ocirc;": 212,
      "Ocy;": 1054,
      "Odblac;": 336,
      "Ofr;": [55349, 56594],
      Ograve: 210,
      "Ograve;": 210,
      "Omacr;": 332,
      "Omega;": 937,
      "Omicron;": 927,
      "Oopf;": [55349, 56646],
      "OpenCurlyDoubleQuote;": 8220,
      "OpenCurlyQuote;": 8216,
      "Or;": 10836,
      "Oscr;": [55349, 56490],
      Oslash: 216,
      "Oslash;": 216,
      Otilde: 213,
      "Otilde;": 213,
      "Otimes;": 10807,
      Ouml: 214,
      "Ouml;": 214,
      "OverBar;": 8254,
      "OverBrace;": 9182,
      "OverBracket;": 9140,
      "OverParenthesis;": 9180,
      "PartialD;": 8706,
      "Pcy;": 1055,
      "Pfr;": [55349, 56595],
      "Phi;": 934,
      "Pi;": 928,
      "PlusMinus;": 177,
      "Poincareplane;": 8460,
      "Popf;": 8473,
      "Pr;": 10939,
      "Precedes;": 8826,
      "PrecedesEqual;": 10927,
      "PrecedesSlantEqual;": 8828,
      "PrecedesTilde;": 8830,
      "Prime;": 8243,
      "Product;": 8719,
      "Proportion;": 8759,
      "Proportional;": 8733,
      "Pscr;": [55349, 56491],
      "Psi;": 936,
      QUOT: 34,
      "QUOT;": 34,
      "Qfr;": [55349, 56596],
      "Qopf;": 8474,
      "Qscr;": [55349, 56492],
      "RBarr;": 10512,
      REG: 174,
      "REG;": 174,
      "Racute;": 340,
      "Rang;": 10219,
      "Rarr;": 8608,
      "Rarrtl;": 10518,
      "Rcaron;": 344,
      "Rcedil;": 342,
      "Rcy;": 1056,
      "Re;": 8476,
      "ReverseElement;": 8715,
      "ReverseEquilibrium;": 8651,
      "ReverseUpEquilibrium;": 10607,
      "Rfr;": 8476,
      "Rho;": 929,
      "RightAngleBracket;": 10217,
      "RightArrow;": 8594,
      "RightArrowBar;": 8677,
      "RightArrowLeftArrow;": 8644,
      "RightCeiling;": 8969,
      "RightDoubleBracket;": 10215,
      "RightDownTeeVector;": 10589,
      "RightDownVector;": 8642,
      "RightDownVectorBar;": 10581,
      "RightFloor;": 8971,
      "RightTee;": 8866,
      "RightTeeArrow;": 8614,
      "RightTeeVector;": 10587,
      "RightTriangle;": 8883,
      "RightTriangleBar;": 10704,
      "RightTriangleEqual;": 8885,
      "RightUpDownVector;": 10575,
      "RightUpTeeVector;": 10588,
      "RightUpVector;": 8638,
      "RightUpVectorBar;": 10580,
      "RightVector;": 8640,
      "RightVectorBar;": 10579,
      "Rightarrow;": 8658,
      "Ropf;": 8477,
      "RoundImplies;": 10608,
      "Rrightarrow;": 8667,
      "Rscr;": 8475,
      "Rsh;": 8625,
      "RuleDelayed;": 10740,
      "SHCHcy;": 1065,
      "SHcy;": 1064,
      "SOFTcy;": 1068,
      "Sacute;": 346,
      "Sc;": 10940,
      "Scaron;": 352,
      "Scedil;": 350,
      "Scirc;": 348,
      "Scy;": 1057,
      "Sfr;": [55349, 56598],
      "ShortDownArrow;": 8595,
      "ShortLeftArrow;": 8592,
      "ShortRightArrow;": 8594,
      "ShortUpArrow;": 8593,
      "Sigma;": 931,
      "SmallCircle;": 8728,
      "Sopf;": [55349, 56650],
      "Sqrt;": 8730,
      "Square;": 9633,
      "SquareIntersection;": 8851,
      "SquareSubset;": 8847,
      "SquareSubsetEqual;": 8849,
      "SquareSuperset;": 8848,
      "SquareSupersetEqual;": 8850,
      "SquareUnion;": 8852,
      "Sscr;": [55349, 56494],
      "Star;": 8902,
      "Sub;": 8912,
      "Subset;": 8912,
      "SubsetEqual;": 8838,
      "Succeeds;": 8827,
      "SucceedsEqual;": 10928,
      "SucceedsSlantEqual;": 8829,
      "SucceedsTilde;": 8831,
      "SuchThat;": 8715,
      "Sum;": 8721,
      "Sup;": 8913,
      "Superset;": 8835,
      "SupersetEqual;": 8839,
      "Supset;": 8913,
      THORN: 222,
      "THORN;": 222,
      "TRADE;": 8482,
      "TSHcy;": 1035,
      "TScy;": 1062,
      "Tab;": 9,
      "Tau;": 932,
      "Tcaron;": 356,
      "Tcedil;": 354,
      "Tcy;": 1058,
      "Tfr;": [55349, 56599],
      "Therefore;": 8756,
      "Theta;": 920,
      "ThickSpace;": [8287, 8202],
      "ThinSpace;": 8201,
      "Tilde;": 8764,
      "TildeEqual;": 8771,
      "TildeFullEqual;": 8773,
      "TildeTilde;": 8776,
      "Topf;": [55349, 56651],
      "TripleDot;": 8411,
      "Tscr;": [55349, 56495],
      "Tstrok;": 358,
      Uacute: 218,
      "Uacute;": 218,
      "Uarr;": 8607,
      "Uarrocir;": 10569,
      "Ubrcy;": 1038,
      "Ubreve;": 364,
      Ucirc: 219,
      "Ucirc;": 219,
      "Ucy;": 1059,
      "Udblac;": 368,
      "Ufr;": [55349, 56600],
      Ugrave: 217,
      "Ugrave;": 217,
      "Umacr;": 362,
      "UnderBar;": 95,
      "UnderBrace;": 9183,
      "UnderBracket;": 9141,
      "UnderParenthesis;": 9181,
      "Union;": 8899,
      "UnionPlus;": 8846,
      "Uogon;": 370,
      "Uopf;": [55349, 56652],
      "UpArrow;": 8593,
      "UpArrowBar;": 10514,
      "UpArrowDownArrow;": 8645,
      "UpDownArrow;": 8597,
      "UpEquilibrium;": 10606,
      "UpTee;": 8869,
      "UpTeeArrow;": 8613,
      "Uparrow;": 8657,
      "Updownarrow;": 8661,
      "UpperLeftArrow;": 8598,
      "UpperRightArrow;": 8599,
      "Upsi;": 978,
      "Upsilon;": 933,
      "Uring;": 366,
      "Uscr;": [55349, 56496],
      "Utilde;": 360,
      Uuml: 220,
      "Uuml;": 220,
      "VDash;": 8875,
      "Vbar;": 10987,
      "Vcy;": 1042,
      "Vdash;": 8873,
      "Vdashl;": 10982,
      "Vee;": 8897,
      "Verbar;": 8214,
      "Vert;": 8214,
      "VerticalBar;": 8739,
      "VerticalLine;": 124,
      "VerticalSeparator;": 10072,
      "VerticalTilde;": 8768,
      "VeryThinSpace;": 8202,
      "Vfr;": [55349, 56601],
      "Vopf;": [55349, 56653],
      "Vscr;": [55349, 56497],
      "Vvdash;": 8874,
      "Wcirc;": 372,
      "Wedge;": 8896,
      "Wfr;": [55349, 56602],
      "Wopf;": [55349, 56654],
      "Wscr;": [55349, 56498],
      "Xfr;": [55349, 56603],
      "Xi;": 926,
      "Xopf;": [55349, 56655],
      "Xscr;": [55349, 56499],
      "YAcy;": 1071,
      "YIcy;": 1031,
      "YUcy;": 1070,
      Yacute: 221,
      "Yacute;": 221,
      "Ycirc;": 374,
      "Ycy;": 1067,
      "Yfr;": [55349, 56604],
      "Yopf;": [55349, 56656],
      "Yscr;": [55349, 56500],
      "Yuml;": 376,
      "ZHcy;": 1046,
      "Zacute;": 377,
      "Zcaron;": 381,
      "Zcy;": 1047,
      "Zdot;": 379,
      "ZeroWidthSpace;": 8203,
      "Zeta;": 918,
      "Zfr;": 8488,
      "Zopf;": 8484,
      "Zscr;": [55349, 56501],
      aacute: 225,
      "aacute;": 225,
      "abreve;": 259,
      "ac;": 8766,
      "acE;": [8766, 819],
      "acd;": 8767,
      acirc: 226,
      "acirc;": 226,
      acute: 180,
      "acute;": 180,
      "acy;": 1072,
      aelig: 230,
      "aelig;": 230,
      "af;": 8289,
      "afr;": [55349, 56606],
      agrave: 224,
      "agrave;": 224,
      "alefsym;": 8501,
      "aleph;": 8501,
      "alpha;": 945,
      "amacr;": 257,
      "amalg;": 10815,
      amp: 38,
      "amp;": 38,
      "and;": 8743,
      "andand;": 10837,
      "andd;": 10844,
      "andslope;": 10840,
      "andv;": 10842,
      "ang;": 8736,
      "ange;": 10660,
      "angle;": 8736,
      "angmsd;": 8737,
      "angmsdaa;": 10664,
      "angmsdab;": 10665,
      "angmsdac;": 10666,
      "angmsdad;": 10667,
      "angmsdae;": 10668,
      "angmsdaf;": 10669,
      "angmsdag;": 10670,
      "angmsdah;": 10671,
      "angrt;": 8735,
      "angrtvb;": 8894,
      "angrtvbd;": 10653,
      "angsph;": 8738,
      "angst;": 197,
      "angzarr;": 9084,
      "aogon;": 261,
      "aopf;": [55349, 56658],
      "ap;": 8776,
      "apE;": 10864,
      "apacir;": 10863,
      "ape;": 8778,
      "apid;": 8779,
      "apos;": 39,
      "approx;": 8776,
      "approxeq;": 8778,
      aring: 229,
      "aring;": 229,
      "ascr;": [55349, 56502],
      "ast;": 42,
      "asymp;": 8776,
      "asympeq;": 8781,
      atilde: 227,
      "atilde;": 227,
      auml: 228,
      "auml;": 228,
      "awconint;": 8755,
      "awint;": 10769,
      "bNot;": 10989,
      "backcong;": 8780,
      "backepsilon;": 1014,
      "backprime;": 8245,
      "backsim;": 8765,
      "backsimeq;": 8909,
      "barvee;": 8893,
      "barwed;": 8965,
      "barwedge;": 8965,
      "bbrk;": 9141,
      "bbrktbrk;": 9142,
      "bcong;": 8780,
      "bcy;": 1073,
      "bdquo;": 8222,
      "becaus;": 8757,
      "because;": 8757,
      "bemptyv;": 10672,
      "bepsi;": 1014,
      "bernou;": 8492,
      "beta;": 946,
      "beth;": 8502,
      "between;": 8812,
      "bfr;": [55349, 56607],
      "bigcap;": 8898,
      "bigcirc;": 9711,
      "bigcup;": 8899,
      "bigodot;": 10752,
      "bigoplus;": 10753,
      "bigotimes;": 10754,
      "bigsqcup;": 10758,
      "bigstar;": 9733,
      "bigtriangledown;": 9661,
      "bigtriangleup;": 9651,
      "biguplus;": 10756,
      "bigvee;": 8897,
      "bigwedge;": 8896,
      "bkarow;": 10509,
      "blacklozenge;": 10731,
      "blacksquare;": 9642,
      "blacktriangle;": 9652,
      "blacktriangledown;": 9662,
      "blacktriangleleft;": 9666,
      "blacktriangleright;": 9656,
      "blank;": 9251,
      "blk12;": 9618,
      "blk14;": 9617,
      "blk34;": 9619,
      "block;": 9608,
      "bne;": [61, 8421],
      "bnequiv;": [8801, 8421],
      "bnot;": 8976,
      "bopf;": [55349, 56659],
      "bot;": 8869,
      "bottom;": 8869,
      "bowtie;": 8904,
      "boxDL;": 9559,
      "boxDR;": 9556,
      "boxDl;": 9558,
      "boxDr;": 9555,
      "boxH;": 9552,
      "boxHD;": 9574,
      "boxHU;": 9577,
      "boxHd;": 9572,
      "boxHu;": 9575,
      "boxUL;": 9565,
      "boxUR;": 9562,
      "boxUl;": 9564,
      "boxUr;": 9561,
      "boxV;": 9553,
      "boxVH;": 9580,
      "boxVL;": 9571,
      "boxVR;": 9568,
      "boxVh;": 9579,
      "boxVl;": 9570,
      "boxVr;": 9567,
      "boxbox;": 10697,
      "boxdL;": 9557,
      "boxdR;": 9554,
      "boxdl;": 9488,
      "boxdr;": 9484,
      "boxh;": 9472,
      "boxhD;": 9573,
      "boxhU;": 9576,
      "boxhd;": 9516,
      "boxhu;": 9524,
      "boxminus;": 8863,
      "boxplus;": 8862,
      "boxtimes;": 8864,
      "boxuL;": 9563,
      "boxuR;": 9560,
      "boxul;": 9496,
      "boxur;": 9492,
      "boxv;": 9474,
      "boxvH;": 9578,
      "boxvL;": 9569,
      "boxvR;": 9566,
      "boxvh;": 9532,
      "boxvl;": 9508,
      "boxvr;": 9500,
      "bprime;": 8245,
      "breve;": 728,
      brvbar: 166,
      "brvbar;": 166,
      "bscr;": [55349, 56503],
      "bsemi;": 8271,
      "bsim;": 8765,
      "bsime;": 8909,
      "bsol;": 92,
      "bsolb;": 10693,
      "bsolhsub;": 10184,
      "bull;": 8226,
      "bullet;": 8226,
      "bump;": 8782,
      "bumpE;": 10926,
      "bumpe;": 8783,
      "bumpeq;": 8783,
      "cacute;": 263,
      "cap;": 8745,
      "capand;": 10820,
      "capbrcup;": 10825,
      "capcap;": 10827,
      "capcup;": 10823,
      "capdot;": 10816,
      "caps;": [8745, 65024],
      "caret;": 8257,
      "caron;": 711,
      "ccaps;": 10829,
      "ccaron;": 269,
      ccedil: 231,
      "ccedil;": 231,
      "ccirc;": 265,
      "ccups;": 10828,
      "ccupssm;": 10832,
      "cdot;": 267,
      cedil: 184,
      "cedil;": 184,
      "cemptyv;": 10674,
      cent: 162,
      "cent;": 162,
      "centerdot;": 183,
      "cfr;": [55349, 56608],
      "chcy;": 1095,
      "check;": 10003,
      "checkmark;": 10003,
      "chi;": 967,
      "cir;": 9675,
      "cirE;": 10691,
      "circ;": 710,
      "circeq;": 8791,
      "circlearrowleft;": 8634,
      "circlearrowright;": 8635,
      "circledR;": 174,
      "circledS;": 9416,
      "circledast;": 8859,
      "circledcirc;": 8858,
      "circleddash;": 8861,
      "cire;": 8791,
      "cirfnint;": 10768,
      "cirmid;": 10991,
      "cirscir;": 10690,
      "clubs;": 9827,
      "clubsuit;": 9827,
      "colon;": 58,
      "colone;": 8788,
      "coloneq;": 8788,
      "comma;": 44,
      "commat;": 64,
      "comp;": 8705,
      "compfn;": 8728,
      "complement;": 8705,
      "complexes;": 8450,
      "cong;": 8773,
      "congdot;": 10861,
      "conint;": 8750,
      "copf;": [55349, 56660],
      "coprod;": 8720,
      copy: 169,
      "copy;": 169,
      "copysr;": 8471,
      "crarr;": 8629,
      "cross;": 10007,
      "cscr;": [55349, 56504],
      "csub;": 10959,
      "csube;": 10961,
      "csup;": 10960,
      "csupe;": 10962,
      "ctdot;": 8943,
      "cudarrl;": 10552,
      "cudarrr;": 10549,
      "cuepr;": 8926,
      "cuesc;": 8927,
      "cularr;": 8630,
      "cularrp;": 10557,
      "cup;": 8746,
      "cupbrcap;": 10824,
      "cupcap;": 10822,
      "cupcup;": 10826,
      "cupdot;": 8845,
      "cupor;": 10821,
      "cups;": [8746, 65024],
      "curarr;": 8631,
      "curarrm;": 10556,
      "curlyeqprec;": 8926,
      "curlyeqsucc;": 8927,
      "curlyvee;": 8910,
      "curlywedge;": 8911,
      curren: 164,
      "curren;": 164,
      "curvearrowleft;": 8630,
      "curvearrowright;": 8631,
      "cuvee;": 8910,
      "cuwed;": 8911,
      "cwconint;": 8754,
      "cwint;": 8753,
      "cylcty;": 9005,
      "dArr;": 8659,
      "dHar;": 10597,
      "dagger;": 8224,
      "daleth;": 8504,
      "darr;": 8595,
      "dash;": 8208,
      "dashv;": 8867,
      "dbkarow;": 10511,
      "dblac;": 733,
      "dcaron;": 271,
      "dcy;": 1076,
      "dd;": 8518,
      "ddagger;": 8225,
      "ddarr;": 8650,
      "ddotseq;": 10871,
      deg: 176,
      "deg;": 176,
      "delta;": 948,
      "demptyv;": 10673,
      "dfisht;": 10623,
      "dfr;": [55349, 56609],
      "dharl;": 8643,
      "dharr;": 8642,
      "diam;": 8900,
      "diamond;": 8900,
      "diamondsuit;": 9830,
      "diams;": 9830,
      "die;": 168,
      "digamma;": 989,
      "disin;": 8946,
      "div;": 247,
      divide: 247,
      "divide;": 247,
      "divideontimes;": 8903,
      "divonx;": 8903,
      "djcy;": 1106,
      "dlcorn;": 8990,
      "dlcrop;": 8973,
      "dollar;": 36,
      "dopf;": [55349, 56661],
      "dot;": 729,
      "doteq;": 8784,
      "doteqdot;": 8785,
      "dotminus;": 8760,
      "dotplus;": 8724,
      "dotsquare;": 8865,
      "doublebarwedge;": 8966,
      "downarrow;": 8595,
      "downdownarrows;": 8650,
      "downharpoonleft;": 8643,
      "downharpoonright;": 8642,
      "drbkarow;": 10512,
      "drcorn;": 8991,
      "drcrop;": 8972,
      "dscr;": [55349, 56505],
      "dscy;": 1109,
      "dsol;": 10742,
      "dstrok;": 273,
      "dtdot;": 8945,
      "dtri;": 9663,
      "dtrif;": 9662,
      "duarr;": 8693,
      "duhar;": 10607,
      "dwangle;": 10662,
      "dzcy;": 1119,
      "dzigrarr;": 10239,
      "eDDot;": 10871,
      "eDot;": 8785,
      eacute: 233,
      "eacute;": 233,
      "easter;": 10862,
      "ecaron;": 283,
      "ecir;": 8790,
      ecirc: 234,
      "ecirc;": 234,
      "ecolon;": 8789,
      "ecy;": 1101,
      "edot;": 279,
      "ee;": 8519,
      "efDot;": 8786,
      "efr;": [55349, 56610],
      "eg;": 10906,
      egrave: 232,
      "egrave;": 232,
      "egs;": 10902,
      "egsdot;": 10904,
      "el;": 10905,
      "elinters;": 9191,
      "ell;": 8467,
      "els;": 10901,
      "elsdot;": 10903,
      "emacr;": 275,
      "empty;": 8709,
      "emptyset;": 8709,
      "emptyv;": 8709,
      "emsp13;": 8196,
      "emsp14;": 8197,
      "emsp;": 8195,
      "eng;": 331,
      "ensp;": 8194,
      "eogon;": 281,
      "eopf;": [55349, 56662],
      "epar;": 8917,
      "eparsl;": 10723,
      "eplus;": 10865,
      "epsi;": 949,
      "epsilon;": 949,
      "epsiv;": 1013,
      "eqcirc;": 8790,
      "eqcolon;": 8789,
      "eqsim;": 8770,
      "eqslantgtr;": 10902,
      "eqslantless;": 10901,
      "equals;": 61,
      "equest;": 8799,
      "equiv;": 8801,
      "equivDD;": 10872,
      "eqvparsl;": 10725,
      "erDot;": 8787,
      "erarr;": 10609,
      "escr;": 8495,
      "esdot;": 8784,
      "esim;": 8770,
      "eta;": 951,
      eth: 240,
      "eth;": 240,
      euml: 235,
      "euml;": 235,
      "euro;": 8364,
      "excl;": 33,
      "exist;": 8707,
      "expectation;": 8496,
      "exponentiale;": 8519,
      "fallingdotseq;": 8786,
      "fcy;": 1092,
      "female;": 9792,
      "ffilig;": 64259,
      "fflig;": 64256,
      "ffllig;": 64260,
      "ffr;": [55349, 56611],
      "filig;": 64257,
      "fjlig;": [102, 106],
      "flat;": 9837,
      "fllig;": 64258,
      "fltns;": 9649,
      "fnof;": 402,
      "fopf;": [55349, 56663],
      "forall;": 8704,
      "fork;": 8916,
      "forkv;": 10969,
      "fpartint;": 10765,
      frac12: 189,
      "frac12;": 189,
      "frac13;": 8531,
      frac14: 188,
      "frac14;": 188,
      "frac15;": 8533,
      "frac16;": 8537,
      "frac18;": 8539,
      "frac23;": 8532,
      "frac25;": 8534,
      frac34: 190,
      "frac34;": 190,
      "frac35;": 8535,
      "frac38;": 8540,
      "frac45;": 8536,
      "frac56;": 8538,
      "frac58;": 8541,
      "frac78;": 8542,
      "frasl;": 8260,
      "frown;": 8994,
      "fscr;": [55349, 56507],
      "gE;": 8807,
      "gEl;": 10892,
      "gacute;": 501,
      "gamma;": 947,
      "gammad;": 989,
      "gap;": 10886,
      "gbreve;": 287,
      "gcirc;": 285,
      "gcy;": 1075,
      "gdot;": 289,
      "ge;": 8805,
      "gel;": 8923,
      "geq;": 8805,
      "geqq;": 8807,
      "geqslant;": 10878,
      "ges;": 10878,
      "gescc;": 10921,
      "gesdot;": 10880,
      "gesdoto;": 10882,
      "gesdotol;": 10884,
      "gesl;": [8923, 65024],
      "gesles;": 10900,
      "gfr;": [55349, 56612],
      "gg;": 8811,
      "ggg;": 8921,
      "gimel;": 8503,
      "gjcy;": 1107,
      "gl;": 8823,
      "glE;": 10898,
      "gla;": 10917,
      "glj;": 10916,
      "gnE;": 8809,
      "gnap;": 10890,
      "gnapprox;": 10890,
      "gne;": 10888,
      "gneq;": 10888,
      "gneqq;": 8809,
      "gnsim;": 8935,
      "gopf;": [55349, 56664],
      "grave;": 96,
      "gscr;": 8458,
      "gsim;": 8819,
      "gsime;": 10894,
      "gsiml;": 10896,
      gt: 62,
      "gt;": 62,
      "gtcc;": 10919,
      "gtcir;": 10874,
      "gtdot;": 8919,
      "gtlPar;": 10645,
      "gtquest;": 10876,
      "gtrapprox;": 10886,
      "gtrarr;": 10616,
      "gtrdot;": 8919,
      "gtreqless;": 8923,
      "gtreqqless;": 10892,
      "gtrless;": 8823,
      "gtrsim;": 8819,
      "gvertneqq;": [8809, 65024],
      "gvnE;": [8809, 65024],
      "hArr;": 8660,
      "hairsp;": 8202,
      "half;": 189,
      "hamilt;": 8459,
      "hardcy;": 1098,
      "harr;": 8596,
      "harrcir;": 10568,
      "harrw;": 8621,
      "hbar;": 8463,
      "hcirc;": 293,
      "hearts;": 9829,
      "heartsuit;": 9829,
      "hellip;": 8230,
      "hercon;": 8889,
      "hfr;": [55349, 56613],
      "hksearow;": 10533,
      "hkswarow;": 10534,
      "hoarr;": 8703,
      "homtht;": 8763,
      "hookleftarrow;": 8617,
      "hookrightarrow;": 8618,
      "hopf;": [55349, 56665],
      "horbar;": 8213,
      "hscr;": [55349, 56509],
      "hslash;": 8463,
      "hstrok;": 295,
      "hybull;": 8259,
      "hyphen;": 8208,
      iacute: 237,
      "iacute;": 237,
      "ic;": 8291,
      icirc: 238,
      "icirc;": 238,
      "icy;": 1080,
      "iecy;": 1077,
      iexcl: 161,
      "iexcl;": 161,
      "iff;": 8660,
      "ifr;": [55349, 56614],
      igrave: 236,
      "igrave;": 236,
      "ii;": 8520,
      "iiiint;": 10764,
      "iiint;": 8749,
      "iinfin;": 10716,
      "iiota;": 8489,
      "ijlig;": 307,
      "imacr;": 299,
      "image;": 8465,
      "imagline;": 8464,
      "imagpart;": 8465,
      "imath;": 305,
      "imof;": 8887,
      "imped;": 437,
      "in;": 8712,
      "incare;": 8453,
      "infin;": 8734,
      "infintie;": 10717,
      "inodot;": 305,
      "int;": 8747,
      "intcal;": 8890,
      "integers;": 8484,
      "intercal;": 8890,
      "intlarhk;": 10775,
      "intprod;": 10812,
      "iocy;": 1105,
      "iogon;": 303,
      "iopf;": [55349, 56666],
      "iota;": 953,
      "iprod;": 10812,
      iquest: 191,
      "iquest;": 191,
      "iscr;": [55349, 56510],
      "isin;": 8712,
      "isinE;": 8953,
      "isindot;": 8949,
      "isins;": 8948,
      "isinsv;": 8947,
      "isinv;": 8712,
      "it;": 8290,
      "itilde;": 297,
      "iukcy;": 1110,
      iuml: 239,
      "iuml;": 239,
      "jcirc;": 309,
      "jcy;": 1081,
      "jfr;": [55349, 56615],
      "jmath;": 567,
      "jopf;": [55349, 56667],
      "jscr;": [55349, 56511],
      "jsercy;": 1112,
      "jukcy;": 1108,
      "kappa;": 954,
      "kappav;": 1008,
      "kcedil;": 311,
      "kcy;": 1082,
      "kfr;": [55349, 56616],
      "kgreen;": 312,
      "khcy;": 1093,
      "kjcy;": 1116,
      "kopf;": [55349, 56668],
      "kscr;": [55349, 56512],
      "lAarr;": 8666,
      "lArr;": 8656,
      "lAtail;": 10523,
      "lBarr;": 10510,
      "lE;": 8806,
      "lEg;": 10891,
      "lHar;": 10594,
      "lacute;": 314,
      "laemptyv;": 10676,
      "lagran;": 8466,
      "lambda;": 955,
      "lang;": 10216,
      "langd;": 10641,
      "langle;": 10216,
      "lap;": 10885,
      laquo: 171,
      "laquo;": 171,
      "larr;": 8592,
      "larrb;": 8676,
      "larrbfs;": 10527,
      "larrfs;": 10525,
      "larrhk;": 8617,
      "larrlp;": 8619,
      "larrpl;": 10553,
      "larrsim;": 10611,
      "larrtl;": 8610,
      "lat;": 10923,
      "latail;": 10521,
      "late;": 10925,
      "lates;": [10925, 65024],
      "lbarr;": 10508,
      "lbbrk;": 10098,
      "lbrace;": 123,
      "lbrack;": 91,
      "lbrke;": 10635,
      "lbrksld;": 10639,
      "lbrkslu;": 10637,
      "lcaron;": 318,
      "lcedil;": 316,
      "lceil;": 8968,
      "lcub;": 123,
      "lcy;": 1083,
      "ldca;": 10550,
      "ldquo;": 8220,
      "ldquor;": 8222,
      "ldrdhar;": 10599,
      "ldrushar;": 10571,
      "ldsh;": 8626,
      "le;": 8804,
      "leftarrow;": 8592,
      "leftarrowtail;": 8610,
      "leftharpoondown;": 8637,
      "leftharpoonup;": 8636,
      "leftleftarrows;": 8647,
      "leftrightarrow;": 8596,
      "leftrightarrows;": 8646,
      "leftrightharpoons;": 8651,
      "leftrightsquigarrow;": 8621,
      "leftthreetimes;": 8907,
      "leg;": 8922,
      "leq;": 8804,
      "leqq;": 8806,
      "leqslant;": 10877,
      "les;": 10877,
      "lescc;": 10920,
      "lesdot;": 10879,
      "lesdoto;": 10881,
      "lesdotor;": 10883,
      "lesg;": [8922, 65024],
      "lesges;": 10899,
      "lessapprox;": 10885,
      "lessdot;": 8918,
      "lesseqgtr;": 8922,
      "lesseqqgtr;": 10891,
      "lessgtr;": 8822,
      "lesssim;": 8818,
      "lfisht;": 10620,
      "lfloor;": 8970,
      "lfr;": [55349, 56617],
      "lg;": 8822,
      "lgE;": 10897,
      "lhard;": 8637,
      "lharu;": 8636,
      "lharul;": 10602,
      "lhblk;": 9604,
      "ljcy;": 1113,
      "ll;": 8810,
      "llarr;": 8647,
      "llcorner;": 8990,
      "llhard;": 10603,
      "lltri;": 9722,
      "lmidot;": 320,
      "lmoust;": 9136,
      "lmoustache;": 9136,
      "lnE;": 8808,
      "lnap;": 10889,
      "lnapprox;": 10889,
      "lne;": 10887,
      "lneq;": 10887,
      "lneqq;": 8808,
      "lnsim;": 8934,
      "loang;": 10220,
      "loarr;": 8701,
      "lobrk;": 10214,
      "longleftarrow;": 10229,
      "longleftrightarrow;": 10231,
      "longmapsto;": 10236,
      "longrightarrow;": 10230,
      "looparrowleft;": 8619,
      "looparrowright;": 8620,
      "lopar;": 10629,
      "lopf;": [55349, 56669],
      "loplus;": 10797,
      "lotimes;": 10804,
      "lowast;": 8727,
      "lowbar;": 95,
      "loz;": 9674,
      "lozenge;": 9674,
      "lozf;": 10731,
      "lpar;": 40,
      "lparlt;": 10643,
      "lrarr;": 8646,
      "lrcorner;": 8991,
      "lrhar;": 8651,
      "lrhard;": 10605,
      "lrm;": 8206,
      "lrtri;": 8895,
      "lsaquo;": 8249,
      "lscr;": [55349, 56513],
      "lsh;": 8624,
      "lsim;": 8818,
      "lsime;": 10893,
      "lsimg;": 10895,
      "lsqb;": 91,
      "lsquo;": 8216,
      "lsquor;": 8218,
      "lstrok;": 322,
      lt: 60,
      "lt;": 60,
      "ltcc;": 10918,
      "ltcir;": 10873,
      "ltdot;": 8918,
      "lthree;": 8907,
      "ltimes;": 8905,
      "ltlarr;": 10614,
      "ltquest;": 10875,
      "ltrPar;": 10646,
      "ltri;": 9667,
      "ltrie;": 8884,
      "ltrif;": 9666,
      "lurdshar;": 10570,
      "luruhar;": 10598,
      "lvertneqq;": [8808, 65024],
      "lvnE;": [8808, 65024],
      "mDDot;": 8762,
      macr: 175,
      "macr;": 175,
      "male;": 9794,
      "malt;": 10016,
      "maltese;": 10016,
      "map;": 8614,
      "mapsto;": 8614,
      "mapstodown;": 8615,
      "mapstoleft;": 8612,
      "mapstoup;": 8613,
      "marker;": 9646,
      "mcomma;": 10793,
      "mcy;": 1084,
      "mdash;": 8212,
      "measuredangle;": 8737,
      "mfr;": [55349, 56618],
      "mho;": 8487,
      micro: 181,
      "micro;": 181,
      "mid;": 8739,
      "midast;": 42,
      "midcir;": 10992,
      middot: 183,
      "middot;": 183,
      "minus;": 8722,
      "minusb;": 8863,
      "minusd;": 8760,
      "minusdu;": 10794,
      "mlcp;": 10971,
      "mldr;": 8230,
      "mnplus;": 8723,
      "models;": 8871,
      "mopf;": [55349, 56670],
      "mp;": 8723,
      "mscr;": [55349, 56514],
      "mstpos;": 8766,
      "mu;": 956,
      "multimap;": 8888,
      "mumap;": 8888,
      "nGg;": [8921, 824],
      "nGt;": [8811, 8402],
      "nGtv;": [8811, 824],
      "nLeftarrow;": 8653,
      "nLeftrightarrow;": 8654,
      "nLl;": [8920, 824],
      "nLt;": [8810, 8402],
      "nLtv;": [8810, 824],
      "nRightarrow;": 8655,
      "nVDash;": 8879,
      "nVdash;": 8878,
      "nabla;": 8711,
      "nacute;": 324,
      "nang;": [8736, 8402],
      "nap;": 8777,
      "napE;": [10864, 824],
      "napid;": [8779, 824],
      "napos;": 329,
      "napprox;": 8777,
      "natur;": 9838,
      "natural;": 9838,
      "naturals;": 8469,
      nbsp: 160,
      "nbsp;": 160,
      "nbump;": [8782, 824],
      "nbumpe;": [8783, 824],
      "ncap;": 10819,
      "ncaron;": 328,
      "ncedil;": 326,
      "ncong;": 8775,
      "ncongdot;": [10861, 824],
      "ncup;": 10818,
      "ncy;": 1085,
      "ndash;": 8211,
      "ne;": 8800,
      "neArr;": 8663,
      "nearhk;": 10532,
      "nearr;": 8599,
      "nearrow;": 8599,
      "nedot;": [8784, 824],
      "nequiv;": 8802,
      "nesear;": 10536,
      "nesim;": [8770, 824],
      "nexist;": 8708,
      "nexists;": 8708,
      "nfr;": [55349, 56619],
      "ngE;": [8807, 824],
      "nge;": 8817,
      "ngeq;": 8817,
      "ngeqq;": [8807, 824],
      "ngeqslant;": [10878, 824],
      "nges;": [10878, 824],
      "ngsim;": 8821,
      "ngt;": 8815,
      "ngtr;": 8815,
      "nhArr;": 8654,
      "nharr;": 8622,
      "nhpar;": 10994,
      "ni;": 8715,
      "nis;": 8956,
      "nisd;": 8954,
      "niv;": 8715,
      "njcy;": 1114,
      "nlArr;": 8653,
      "nlE;": [8806, 824],
      "nlarr;": 8602,
      "nldr;": 8229,
      "nle;": 8816,
      "nleftarrow;": 8602,
      "nleftrightarrow;": 8622,
      "nleq;": 8816,
      "nleqq;": [8806, 824],
      "nleqslant;": [10877, 824],
      "nles;": [10877, 824],
      "nless;": 8814,
      "nlsim;": 8820,
      "nlt;": 8814,
      "nltri;": 8938,
      "nltrie;": 8940,
      "nmid;": 8740,
      "nopf;": [55349, 56671],
      not: 172,
      "not;": 172,
      "notin;": 8713,
      "notinE;": [8953, 824],
      "notindot;": [8949, 824],
      "notinva;": 8713,
      "notinvb;": 8951,
      "notinvc;": 8950,
      "notni;": 8716,
      "notniva;": 8716,
      "notnivb;": 8958,
      "notnivc;": 8957,
      "npar;": 8742,
      "nparallel;": 8742,
      "nparsl;": [11005, 8421],
      "npart;": [8706, 824],
      "npolint;": 10772,
      "npr;": 8832,
      "nprcue;": 8928,
      "npre;": [10927, 824],
      "nprec;": 8832,
      "npreceq;": [10927, 824],
      "nrArr;": 8655,
      "nrarr;": 8603,
      "nrarrc;": [10547, 824],
      "nrarrw;": [8605, 824],
      "nrightarrow;": 8603,
      "nrtri;": 8939,
      "nrtrie;": 8941,
      "nsc;": 8833,
      "nsccue;": 8929,
      "nsce;": [10928, 824],
      "nscr;": [55349, 56515],
      "nshortmid;": 8740,
      "nshortparallel;": 8742,
      "nsim;": 8769,
      "nsime;": 8772,
      "nsimeq;": 8772,
      "nsmid;": 8740,
      "nspar;": 8742,
      "nsqsube;": 8930,
      "nsqsupe;": 8931,
      "nsub;": 8836,
      "nsubE;": [10949, 824],
      "nsube;": 8840,
      "nsubset;": [8834, 8402],
      "nsubseteq;": 8840,
      "nsubseteqq;": [10949, 824],
      "nsucc;": 8833,
      "nsucceq;": [10928, 824],
      "nsup;": 8837,
      "nsupE;": [10950, 824],
      "nsupe;": 8841,
      "nsupset;": [8835, 8402],
      "nsupseteq;": 8841,
      "nsupseteqq;": [10950, 824],
      "ntgl;": 8825,
      ntilde: 241,
      "ntilde;": 241,
      "ntlg;": 8824,
      "ntriangleleft;": 8938,
      "ntrianglelefteq;": 8940,
      "ntriangleright;": 8939,
      "ntrianglerighteq;": 8941,
      "nu;": 957,
      "num;": 35,
      "numero;": 8470,
      "numsp;": 8199,
      "nvDash;": 8877,
      "nvHarr;": 10500,
      "nvap;": [8781, 8402],
      "nvdash;": 8876,
      "nvge;": [8805, 8402],
      "nvgt;": [62, 8402],
      "nvinfin;": 10718,
      "nvlArr;": 10498,
      "nvle;": [8804, 8402],
      "nvlt;": [60, 8402],
      "nvltrie;": [8884, 8402],
      "nvrArr;": 10499,
      "nvrtrie;": [8885, 8402],
      "nvsim;": [8764, 8402],
      "nwArr;": 8662,
      "nwarhk;": 10531,
      "nwarr;": 8598,
      "nwarrow;": 8598,
      "nwnear;": 10535,
      "oS;": 9416,
      oacute: 243,
      "oacute;": 243,
      "oast;": 8859,
      "ocir;": 8858,
      ocirc: 244,
      "ocirc;": 244,
      "ocy;": 1086,
      "odash;": 8861,
      "odblac;": 337,
      "odiv;": 10808,
      "odot;": 8857,
      "odsold;": 10684,
      "oelig;": 339,
      "ofcir;": 10687,
      "ofr;": [55349, 56620],
      "ogon;": 731,
      ograve: 242,
      "ograve;": 242,
      "ogt;": 10689,
      "ohbar;": 10677,
      "ohm;": 937,
      "oint;": 8750,
      "olarr;": 8634,
      "olcir;": 10686,
      "olcross;": 10683,
      "oline;": 8254,
      "olt;": 10688,
      "omacr;": 333,
      "omega;": 969,
      "omicron;": 959,
      "omid;": 10678,
      "ominus;": 8854,
      "oopf;": [55349, 56672],
      "opar;": 10679,
      "operp;": 10681,
      "oplus;": 8853,
      "or;": 8744,
      "orarr;": 8635,
      "ord;": 10845,
      "order;": 8500,
      "orderof;": 8500,
      ordf: 170,
      "ordf;": 170,
      ordm: 186,
      "ordm;": 186,
      "origof;": 8886,
      "oror;": 10838,
      "orslope;": 10839,
      "orv;": 10843,
      "oscr;": 8500,
      oslash: 248,
      "oslash;": 248,
      "osol;": 8856,
      otilde: 245,
      "otilde;": 245,
      "otimes;": 8855,
      "otimesas;": 10806,
      ouml: 246,
      "ouml;": 246,
      "ovbar;": 9021,
      "par;": 8741,
      para: 182,
      "para;": 182,
      "parallel;": 8741,
      "parsim;": 10995,
      "parsl;": 11005,
      "part;": 8706,
      "pcy;": 1087,
      "percnt;": 37,
      "period;": 46,
      "permil;": 8240,
      "perp;": 8869,
      "pertenk;": 8241,
      "pfr;": [55349, 56621],
      "phi;": 966,
      "phiv;": 981,
      "phmmat;": 8499,
      "phone;": 9742,
      "pi;": 960,
      "pitchfork;": 8916,
      "piv;": 982,
      "planck;": 8463,
      "planckh;": 8462,
      "plankv;": 8463,
      "plus;": 43,
      "plusacir;": 10787,
      "plusb;": 8862,
      "pluscir;": 10786,
      "plusdo;": 8724,
      "plusdu;": 10789,
      "pluse;": 10866,
      plusmn: 177,
      "plusmn;": 177,
      "plussim;": 10790,
      "plustwo;": 10791,
      "pm;": 177,
      "pointint;": 10773,
      "popf;": [55349, 56673],
      pound: 163,
      "pound;": 163,
      "pr;": 8826,
      "prE;": 10931,
      "prap;": 10935,
      "prcue;": 8828,
      "pre;": 10927,
      "prec;": 8826,
      "precapprox;": 10935,
      "preccurlyeq;": 8828,
      "preceq;": 10927,
      "precnapprox;": 10937,
      "precneqq;": 10933,
      "precnsim;": 8936,
      "precsim;": 8830,
      "prime;": 8242,
      "primes;": 8473,
      "prnE;": 10933,
      "prnap;": 10937,
      "prnsim;": 8936,
      "prod;": 8719,
      "profalar;": 9006,
      "profline;": 8978,
      "profsurf;": 8979,
      "prop;": 8733,
      "propto;": 8733,
      "prsim;": 8830,
      "prurel;": 8880,
      "pscr;": [55349, 56517],
      "psi;": 968,
      "puncsp;": 8200,
      "qfr;": [55349, 56622],
      "qint;": 10764,
      "qopf;": [55349, 56674],
      "qprime;": 8279,
      "qscr;": [55349, 56518],
      "quaternions;": 8461,
      "quatint;": 10774,
      "quest;": 63,
      "questeq;": 8799,
      quot: 34,
      "quot;": 34,
      "rAarr;": 8667,
      "rArr;": 8658,
      "rAtail;": 10524,
      "rBarr;": 10511,
      "rHar;": 10596,
      "race;": [8765, 817],
      "racute;": 341,
      "radic;": 8730,
      "raemptyv;": 10675,
      "rang;": 10217,
      "rangd;": 10642,
      "range;": 10661,
      "rangle;": 10217,
      raquo: 187,
      "raquo;": 187,
      "rarr;": 8594,
      "rarrap;": 10613,
      "rarrb;": 8677,
      "rarrbfs;": 10528,
      "rarrc;": 10547,
      "rarrfs;": 10526,
      "rarrhk;": 8618,
      "rarrlp;": 8620,
      "rarrpl;": 10565,
      "rarrsim;": 10612,
      "rarrtl;": 8611,
      "rarrw;": 8605,
      "ratail;": 10522,
      "ratio;": 8758,
      "rationals;": 8474,
      "rbarr;": 10509,
      "rbbrk;": 10099,
      "rbrace;": 125,
      "rbrack;": 93,
      "rbrke;": 10636,
      "rbrksld;": 10638,
      "rbrkslu;": 10640,
      "rcaron;": 345,
      "rcedil;": 343,
      "rceil;": 8969,
      "rcub;": 125,
      "rcy;": 1088,
      "rdca;": 10551,
      "rdldhar;": 10601,
      "rdquo;": 8221,
      "rdquor;": 8221,
      "rdsh;": 8627,
      "real;": 8476,
      "realine;": 8475,
      "realpart;": 8476,
      "reals;": 8477,
      "rect;": 9645,
      reg: 174,
      "reg;": 174,
      "rfisht;": 10621,
      "rfloor;": 8971,
      "rfr;": [55349, 56623],
      "rhard;": 8641,
      "rharu;": 8640,
      "rharul;": 10604,
      "rho;": 961,
      "rhov;": 1009,
      "rightarrow;": 8594,
      "rightarrowtail;": 8611,
      "rightharpoondown;": 8641,
      "rightharpoonup;": 8640,
      "rightleftarrows;": 8644,
      "rightleftharpoons;": 8652,
      "rightrightarrows;": 8649,
      "rightsquigarrow;": 8605,
      "rightthreetimes;": 8908,
      "ring;": 730,
      "risingdotseq;": 8787,
      "rlarr;": 8644,
      "rlhar;": 8652,
      "rlm;": 8207,
      "rmoust;": 9137,
      "rmoustache;": 9137,
      "rnmid;": 10990,
      "roang;": 10221,
      "roarr;": 8702,
      "robrk;": 10215,
      "ropar;": 10630,
      "ropf;": [55349, 56675],
      "roplus;": 10798,
      "rotimes;": 10805,
      "rpar;": 41,
      "rpargt;": 10644,
      "rppolint;": 10770,
      "rrarr;": 8649,
      "rsaquo;": 8250,
      "rscr;": [55349, 56519],
      "rsh;": 8625,
      "rsqb;": 93,
      "rsquo;": 8217,
      "rsquor;": 8217,
      "rthree;": 8908,
      "rtimes;": 8906,
      "rtri;": 9657,
      "rtrie;": 8885,
      "rtrif;": 9656,
      "rtriltri;": 10702,
      "ruluhar;": 10600,
      "rx;": 8478,
      "sacute;": 347,
      "sbquo;": 8218,
      "sc;": 8827,
      "scE;": 10932,
      "scap;": 10936,
      "scaron;": 353,
      "sccue;": 8829,
      "sce;": 10928,
      "scedil;": 351,
      "scirc;": 349,
      "scnE;": 10934,
      "scnap;": 10938,
      "scnsim;": 8937,
      "scpolint;": 10771,
      "scsim;": 8831,
      "scy;": 1089,
      "sdot;": 8901,
      "sdotb;": 8865,
      "sdote;": 10854,
      "seArr;": 8664,
      "searhk;": 10533,
      "searr;": 8600,
      "searrow;": 8600,
      sect: 167,
      "sect;": 167,
      "semi;": 59,
      "seswar;": 10537,
      "setminus;": 8726,
      "setmn;": 8726,
      "sext;": 10038,
      "sfr;": [55349, 56624],
      "sfrown;": 8994,
      "sharp;": 9839,
      "shchcy;": 1097,
      "shcy;": 1096,
      "shortmid;": 8739,
      "shortparallel;": 8741,
      shy: 173,
      "shy;": 173,
      "sigma;": 963,
      "sigmaf;": 962,
      "sigmav;": 962,
      "sim;": 8764,
      "simdot;": 10858,
      "sime;": 8771,
      "simeq;": 8771,
      "simg;": 10910,
      "simgE;": 10912,
      "siml;": 10909,
      "simlE;": 10911,
      "simne;": 8774,
      "simplus;": 10788,
      "simrarr;": 10610,
      "slarr;": 8592,
      "smallsetminus;": 8726,
      "smashp;": 10803,
      "smeparsl;": 10724,
      "smid;": 8739,
      "smile;": 8995,
      "smt;": 10922,
      "smte;": 10924,
      "smtes;": [10924, 65024],
      "softcy;": 1100,
      "sol;": 47,
      "solb;": 10692,
      "solbar;": 9023,
      "sopf;": [55349, 56676],
      "spades;": 9824,
      "spadesuit;": 9824,
      "spar;": 8741,
      "sqcap;": 8851,
      "sqcaps;": [8851, 65024],
      "sqcup;": 8852,
      "sqcups;": [8852, 65024],
      "sqsub;": 8847,
      "sqsube;": 8849,
      "sqsubset;": 8847,
      "sqsubseteq;": 8849,
      "sqsup;": 8848,
      "sqsupe;": 8850,
      "sqsupset;": 8848,
      "sqsupseteq;": 8850,
      "squ;": 9633,
      "square;": 9633,
      "squarf;": 9642,
      "squf;": 9642,
      "srarr;": 8594,
      "sscr;": [55349, 56520],
      "ssetmn;": 8726,
      "ssmile;": 8995,
      "sstarf;": 8902,
      "star;": 9734,
      "starf;": 9733,
      "straightepsilon;": 1013,
      "straightphi;": 981,
      "strns;": 175,
      "sub;": 8834,
      "subE;": 10949,
      "subdot;": 10941,
      "sube;": 8838,
      "subedot;": 10947,
      "submult;": 10945,
      "subnE;": 10955,
      "subne;": 8842,
      "subplus;": 10943,
      "subrarr;": 10617,
      "subset;": 8834,
      "subseteq;": 8838,
      "subseteqq;": 10949,
      "subsetneq;": 8842,
      "subsetneqq;": 10955,
      "subsim;": 10951,
      "subsub;": 10965,
      "subsup;": 10963,
      "succ;": 8827,
      "succapprox;": 10936,
      "succcurlyeq;": 8829,
      "succeq;": 10928,
      "succnapprox;": 10938,
      "succneqq;": 10934,
      "succnsim;": 8937,
      "succsim;": 8831,
      "sum;": 8721,
      "sung;": 9834,
      sup1: 185,
      "sup1;": 185,
      sup2: 178,
      "sup2;": 178,
      sup3: 179,
      "sup3;": 179,
      "sup;": 8835,
      "supE;": 10950,
      "supdot;": 10942,
      "supdsub;": 10968,
      "supe;": 8839,
      "supedot;": 10948,
      "suphsol;": 10185,
      "suphsub;": 10967,
      "suplarr;": 10619,
      "supmult;": 10946,
      "supnE;": 10956,
      "supne;": 8843,
      "supplus;": 10944,
      "supset;": 8835,
      "supseteq;": 8839,
      "supseteqq;": 10950,
      "supsetneq;": 8843,
      "supsetneqq;": 10956,
      "supsim;": 10952,
      "supsub;": 10964,
      "supsup;": 10966,
      "swArr;": 8665,
      "swarhk;": 10534,
      "swarr;": 8601,
      "swarrow;": 8601,
      "swnwar;": 10538,
      szlig: 223,
      "szlig;": 223,
      "target;": 8982,
      "tau;": 964,
      "tbrk;": 9140,
      "tcaron;": 357,
      "tcedil;": 355,
      "tcy;": 1090,
      "tdot;": 8411,
      "telrec;": 8981,
      "tfr;": [55349, 56625],
      "there4;": 8756,
      "therefore;": 8756,
      "theta;": 952,
      "thetasym;": 977,
      "thetav;": 977,
      "thickapprox;": 8776,
      "thicksim;": 8764,
      "thinsp;": 8201,
      "thkap;": 8776,
      "thksim;": 8764,
      thorn: 254,
      "thorn;": 254,
      "tilde;": 732,
      times: 215,
      "times;": 215,
      "timesb;": 8864,
      "timesbar;": 10801,
      "timesd;": 10800,
      "tint;": 8749,
      "toea;": 10536,
      "top;": 8868,
      "topbot;": 9014,
      "topcir;": 10993,
      "topf;": [55349, 56677],
      "topfork;": 10970,
      "tosa;": 10537,
      "tprime;": 8244,
      "trade;": 8482,
      "triangle;": 9653,
      "triangledown;": 9663,
      "triangleleft;": 9667,
      "trianglelefteq;": 8884,
      "triangleq;": 8796,
      "triangleright;": 9657,
      "trianglerighteq;": 8885,
      "tridot;": 9708,
      "trie;": 8796,
      "triminus;": 10810,
      "triplus;": 10809,
      "trisb;": 10701,
      "tritime;": 10811,
      "trpezium;": 9186,
      "tscr;": [55349, 56521],
      "tscy;": 1094,
      "tshcy;": 1115,
      "tstrok;": 359,
      "twixt;": 8812,
      "twoheadleftarrow;": 8606,
      "twoheadrightarrow;": 8608,
      "uArr;": 8657,
      "uHar;": 10595,
      uacute: 250,
      "uacute;": 250,
      "uarr;": 8593,
      "ubrcy;": 1118,
      "ubreve;": 365,
      ucirc: 251,
      "ucirc;": 251,
      "ucy;": 1091,
      "udarr;": 8645,
      "udblac;": 369,
      "udhar;": 10606,
      "ufisht;": 10622,
      "ufr;": [55349, 56626],
      ugrave: 249,
      "ugrave;": 249,
      "uharl;": 8639,
      "uharr;": 8638,
      "uhblk;": 9600,
      "ulcorn;": 8988,
      "ulcorner;": 8988,
      "ulcrop;": 8975,
      "ultri;": 9720,
      "umacr;": 363,
      uml: 168,
      "uml;": 168,
      "uogon;": 371,
      "uopf;": [55349, 56678],
      "uparrow;": 8593,
      "updownarrow;": 8597,
      "upharpoonleft;": 8639,
      "upharpoonright;": 8638,
      "uplus;": 8846,
      "upsi;": 965,
      "upsih;": 978,
      "upsilon;": 965,
      "upuparrows;": 8648,
      "urcorn;": 8989,
      "urcorner;": 8989,
      "urcrop;": 8974,
      "uring;": 367,
      "urtri;": 9721,
      "uscr;": [55349, 56522],
      "utdot;": 8944,
      "utilde;": 361,
      "utri;": 9653,
      "utrif;": 9652,
      "uuarr;": 8648,
      uuml: 252,
      "uuml;": 252,
      "uwangle;": 10663,
      "vArr;": 8661,
      "vBar;": 10984,
      "vBarv;": 10985,
      "vDash;": 8872,
      "vangrt;": 10652,
      "varepsilon;": 1013,
      "varkappa;": 1008,
      "varnothing;": 8709,
      "varphi;": 981,
      "varpi;": 982,
      "varpropto;": 8733,
      "varr;": 8597,
      "varrho;": 1009,
      "varsigma;": 962,
      "varsubsetneq;": [8842, 65024],
      "varsubsetneqq;": [10955, 65024],
      "varsupsetneq;": [8843, 65024],
      "varsupsetneqq;": [10956, 65024],
      "vartheta;": 977,
      "vartriangleleft;": 8882,
      "vartriangleright;": 8883,
      "vcy;": 1074,
      "vdash;": 8866,
      "vee;": 8744,
      "veebar;": 8891,
      "veeeq;": 8794,
      "vellip;": 8942,
      "verbar;": 124,
      "vert;": 124,
      "vfr;": [55349, 56627],
      "vltri;": 8882,
      "vnsub;": [8834, 8402],
      "vnsup;": [8835, 8402],
      "vopf;": [55349, 56679],
      "vprop;": 8733,
      "vrtri;": 8883,
      "vscr;": [55349, 56523],
      "vsubnE;": [10955, 65024],
      "vsubne;": [8842, 65024],
      "vsupnE;": [10956, 65024],
      "vsupne;": [8843, 65024],
      "vzigzag;": 10650,
      "wcirc;": 373,
      "wedbar;": 10847,
      "wedge;": 8743,
      "wedgeq;": 8793,
      "weierp;": 8472,
      "wfr;": [55349, 56628],
      "wopf;": [55349, 56680],
      "wp;": 8472,
      "wr;": 8768,
      "wreath;": 8768,
      "wscr;": [55349, 56524],
      "xcap;": 8898,
      "xcirc;": 9711,
      "xcup;": 8899,
      "xdtri;": 9661,
      "xfr;": [55349, 56629],
      "xhArr;": 10234,
      "xharr;": 10231,
      "xi;": 958,
      "xlArr;": 10232,
      "xlarr;": 10229,
      "xmap;": 10236,
      "xnis;": 8955,
      "xodot;": 10752,
      "xopf;": [55349, 56681],
      "xoplus;": 10753,
      "xotime;": 10754,
      "xrArr;": 10233,
      "xrarr;": 10230,
      "xscr;": [55349, 56525],
      "xsqcup;": 10758,
      "xuplus;": 10756,
      "xutri;": 9651,
      "xvee;": 8897,
      "xwedge;": 8896,
      yacute: 253,
      "yacute;": 253,
      "yacy;": 1103,
      "ycirc;": 375,
      "ycy;": 1099,
      yen: 165,
      "yen;": 165,
      "yfr;": [55349, 56630],
      "yicy;": 1111,
      "yopf;": [55349, 56682],
      "yscr;": [55349, 56526],
      "yucy;": 1102,
      yuml: 255,
      "yuml;": 255,
      "zacute;": 378,
      "zcaron;": 382,
      "zcy;": 1079,
      "zdot;": 380,
      "zeetrf;": 8488,
      "zeta;": 950,
      "zfr;": [55349, 56631],
      "zhcy;": 1078,
      "zigrarr;": 8669,
      "zopf;": [55349, 56683],
      "zscr;": [55349, 56527],
      "zwj;": 8205,
      "zwnj;": 8204,
    },
    a7 =
      /(A(?:Elig;?|MP;?|acute;?|breve;|c(?:irc;?|y;)|fr;|grave;?|lpha;|macr;|nd;|o(?:gon;|pf;)|pplyFunction;|ring;?|s(?:cr;|sign;)|tilde;?|uml;?)|B(?:a(?:ckslash;|r(?:v;|wed;))|cy;|e(?:cause;|rnoullis;|ta;)|fr;|opf;|reve;|scr;|umpeq;)|C(?:Hcy;|OPY;?|a(?:cute;|p(?:;|italDifferentialD;)|yleys;)|c(?:aron;|edil;?|irc;|onint;)|dot;|e(?:dilla;|nterDot;)|fr;|hi;|ircle(?:Dot;|Minus;|Plus;|Times;)|lo(?:ckwiseContourIntegral;|seCurly(?:DoubleQuote;|Quote;))|o(?:lon(?:;|e;)|n(?:gruent;|int;|tourIntegral;)|p(?:f;|roduct;)|unterClockwiseContourIntegral;)|ross;|scr;|up(?:;|Cap;))|D(?:D(?:;|otrahd;)|Jcy;|Scy;|Zcy;|a(?:gger;|rr;|shv;)|c(?:aron;|y;)|el(?:;|ta;)|fr;|i(?:a(?:critical(?:Acute;|Do(?:t;|ubleAcute;)|Grave;|Tilde;)|mond;)|fferentialD;)|o(?:pf;|t(?:;|Dot;|Equal;)|uble(?:ContourIntegral;|Do(?:t;|wnArrow;)|L(?:eft(?:Arrow;|RightArrow;|Tee;)|ong(?:Left(?:Arrow;|RightArrow;)|RightArrow;))|Right(?:Arrow;|Tee;)|Up(?:Arrow;|DownArrow;)|VerticalBar;)|wn(?:Arrow(?:;|Bar;|UpArrow;)|Breve;|Left(?:RightVector;|TeeVector;|Vector(?:;|Bar;))|Right(?:TeeVector;|Vector(?:;|Bar;))|Tee(?:;|Arrow;)|arrow;))|s(?:cr;|trok;))|E(?:NG;|TH;?|acute;?|c(?:aron;|irc;?|y;)|dot;|fr;|grave;?|lement;|m(?:acr;|pty(?:SmallSquare;|VerySmallSquare;))|o(?:gon;|pf;)|psilon;|qu(?:al(?:;|Tilde;)|ilibrium;)|s(?:cr;|im;)|ta;|uml;?|x(?:ists;|ponentialE;))|F(?:cy;|fr;|illed(?:SmallSquare;|VerySmallSquare;)|o(?:pf;|rAll;|uriertrf;)|scr;)|G(?:Jcy;|T;?|amma(?:;|d;)|breve;|c(?:edil;|irc;|y;)|dot;|fr;|g;|opf;|reater(?:Equal(?:;|Less;)|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|scr;|t;)|H(?:ARDcy;|a(?:cek;|t;)|circ;|fr;|ilbertSpace;|o(?:pf;|rizontalLine;)|s(?:cr;|trok;)|ump(?:DownHump;|Equal;))|I(?:Ecy;|Jlig;|Ocy;|acute;?|c(?:irc;?|y;)|dot;|fr;|grave;?|m(?:;|a(?:cr;|ginaryI;)|plies;)|n(?:t(?:;|e(?:gral;|rsection;))|visible(?:Comma;|Times;))|o(?:gon;|pf;|ta;)|scr;|tilde;|u(?:kcy;|ml;?))|J(?:c(?:irc;|y;)|fr;|opf;|s(?:cr;|ercy;)|ukcy;)|K(?:Hcy;|Jcy;|appa;|c(?:edil;|y;)|fr;|opf;|scr;)|L(?:Jcy;|T;?|a(?:cute;|mbda;|ng;|placetrf;|rr;)|c(?:aron;|edil;|y;)|e(?:ft(?:A(?:ngleBracket;|rrow(?:;|Bar;|RightArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|Right(?:Arrow;|Vector;)|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;|rightarrow;)|ss(?:EqualGreater;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;))|fr;|l(?:;|eftarrow;)|midot;|o(?:ng(?:Left(?:Arrow;|RightArrow;)|RightArrow;|left(?:arrow;|rightarrow;)|rightarrow;)|pf;|wer(?:LeftArrow;|RightArrow;))|s(?:cr;|h;|trok;)|t;)|M(?:ap;|cy;|e(?:diumSpace;|llintrf;)|fr;|inusPlus;|opf;|scr;|u;)|N(?:Jcy;|acute;|c(?:aron;|edil;|y;)|e(?:gative(?:MediumSpace;|Thi(?:ckSpace;|nSpace;)|VeryThinSpace;)|sted(?:GreaterGreater;|LessLess;)|wLine;)|fr;|o(?:Break;|nBreakingSpace;|pf;|t(?:;|C(?:ongruent;|upCap;)|DoubleVerticalBar;|E(?:lement;|qual(?:;|Tilde;)|xists;)|Greater(?:;|Equal;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|Hump(?:DownHump;|Equal;)|Le(?:ftTriangle(?:;|Bar;|Equal;)|ss(?:;|Equal;|Greater;|Less;|SlantEqual;|Tilde;))|Nested(?:GreaterGreater;|LessLess;)|Precedes(?:;|Equal;|SlantEqual;)|R(?:everseElement;|ightTriangle(?:;|Bar;|Equal;))|S(?:quareSu(?:bset(?:;|Equal;)|perset(?:;|Equal;))|u(?:bset(?:;|Equal;)|cceeds(?:;|Equal;|SlantEqual;|Tilde;)|perset(?:;|Equal;)))|Tilde(?:;|Equal;|FullEqual;|Tilde;)|VerticalBar;))|scr;|tilde;?|u;)|O(?:Elig;|acute;?|c(?:irc;?|y;)|dblac;|fr;|grave;?|m(?:acr;|ega;|icron;)|opf;|penCurly(?:DoubleQuote;|Quote;)|r;|s(?:cr;|lash;?)|ti(?:lde;?|mes;)|uml;?|ver(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;))|P(?:artialD;|cy;|fr;|hi;|i;|lusMinus;|o(?:incareplane;|pf;)|r(?:;|ecedes(?:;|Equal;|SlantEqual;|Tilde;)|ime;|o(?:duct;|portion(?:;|al;)))|s(?:cr;|i;))|Q(?:UOT;?|fr;|opf;|scr;)|R(?:Barr;|EG;?|a(?:cute;|ng;|rr(?:;|tl;))|c(?:aron;|edil;|y;)|e(?:;|verse(?:E(?:lement;|quilibrium;)|UpEquilibrium;))|fr;|ho;|ight(?:A(?:ngleBracket;|rrow(?:;|Bar;|LeftArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;)|o(?:pf;|undImplies;)|rightarrow;|s(?:cr;|h;)|uleDelayed;)|S(?:H(?:CHcy;|cy;)|OFTcy;|acute;|c(?:;|aron;|edil;|irc;|y;)|fr;|hort(?:DownArrow;|LeftArrow;|RightArrow;|UpArrow;)|igma;|mallCircle;|opf;|q(?:rt;|uare(?:;|Intersection;|Su(?:bset(?:;|Equal;)|perset(?:;|Equal;))|Union;))|scr;|tar;|u(?:b(?:;|set(?:;|Equal;))|c(?:ceeds(?:;|Equal;|SlantEqual;|Tilde;)|hThat;)|m;|p(?:;|erset(?:;|Equal;)|set;)))|T(?:HORN;?|RADE;|S(?:Hcy;|cy;)|a(?:b;|u;)|c(?:aron;|edil;|y;)|fr;|h(?:e(?:refore;|ta;)|i(?:ckSpace;|nSpace;))|ilde(?:;|Equal;|FullEqual;|Tilde;)|opf;|ripleDot;|s(?:cr;|trok;))|U(?:a(?:cute;?|rr(?:;|ocir;))|br(?:cy;|eve;)|c(?:irc;?|y;)|dblac;|fr;|grave;?|macr;|n(?:der(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;)|ion(?:;|Plus;))|o(?:gon;|pf;)|p(?:Arrow(?:;|Bar;|DownArrow;)|DownArrow;|Equilibrium;|Tee(?:;|Arrow;)|arrow;|downarrow;|per(?:LeftArrow;|RightArrow;)|si(?:;|lon;))|ring;|scr;|tilde;|uml;?)|V(?:Dash;|bar;|cy;|dash(?:;|l;)|e(?:e;|r(?:bar;|t(?:;|ical(?:Bar;|Line;|Separator;|Tilde;))|yThinSpace;))|fr;|opf;|scr;|vdash;)|W(?:circ;|edge;|fr;|opf;|scr;)|X(?:fr;|i;|opf;|scr;)|Y(?:Acy;|Icy;|Ucy;|acute;?|c(?:irc;|y;)|fr;|opf;|scr;|uml;)|Z(?:Hcy;|acute;|c(?:aron;|y;)|dot;|e(?:roWidthSpace;|ta;)|fr;|opf;|scr;)|a(?:acute;?|breve;|c(?:;|E;|d;|irc;?|ute;?|y;)|elig;?|f(?:;|r;)|grave;?|l(?:e(?:fsym;|ph;)|pha;)|m(?:a(?:cr;|lg;)|p;?)|n(?:d(?:;|and;|d;|slope;|v;)|g(?:;|e;|le;|msd(?:;|a(?:a;|b;|c;|d;|e;|f;|g;|h;))|rt(?:;|vb(?:;|d;))|s(?:ph;|t;)|zarr;))|o(?:gon;|pf;)|p(?:;|E;|acir;|e;|id;|os;|prox(?:;|eq;))|ring;?|s(?:cr;|t;|ymp(?:;|eq;))|tilde;?|uml;?|w(?:conint;|int;))|b(?:Not;|a(?:ck(?:cong;|epsilon;|prime;|sim(?:;|eq;))|r(?:vee;|wed(?:;|ge;)))|brk(?:;|tbrk;)|c(?:ong;|y;)|dquo;|e(?:caus(?:;|e;)|mptyv;|psi;|rnou;|t(?:a;|h;|ween;))|fr;|ig(?:c(?:ap;|irc;|up;)|o(?:dot;|plus;|times;)|s(?:qcup;|tar;)|triangle(?:down;|up;)|uplus;|vee;|wedge;)|karow;|l(?:a(?:ck(?:lozenge;|square;|triangle(?:;|down;|left;|right;))|nk;)|k(?:1(?:2;|4;)|34;)|ock;)|n(?:e(?:;|quiv;)|ot;)|o(?:pf;|t(?:;|tom;)|wtie;|x(?:D(?:L;|R;|l;|r;)|H(?:;|D;|U;|d;|u;)|U(?:L;|R;|l;|r;)|V(?:;|H;|L;|R;|h;|l;|r;)|box;|d(?:L;|R;|l;|r;)|h(?:;|D;|U;|d;|u;)|minus;|plus;|times;|u(?:L;|R;|l;|r;)|v(?:;|H;|L;|R;|h;|l;|r;)))|prime;|r(?:eve;|vbar;?)|s(?:cr;|emi;|im(?:;|e;)|ol(?:;|b;|hsub;))|u(?:ll(?:;|et;)|mp(?:;|E;|e(?:;|q;))))|c(?:a(?:cute;|p(?:;|and;|brcup;|c(?:ap;|up;)|dot;|s;)|r(?:et;|on;))|c(?:a(?:ps;|ron;)|edil;?|irc;|ups(?:;|sm;))|dot;|e(?:dil;?|mptyv;|nt(?:;|erdot;|))|fr;|h(?:cy;|eck(?:;|mark;)|i;)|ir(?:;|E;|c(?:;|eq;|le(?:arrow(?:left;|right;)|d(?:R;|S;|ast;|circ;|dash;)))|e;|fnint;|mid;|scir;)|lubs(?:;|uit;)|o(?:lon(?:;|e(?:;|q;))|m(?:ma(?:;|t;)|p(?:;|fn;|le(?:ment;|xes;)))|n(?:g(?:;|dot;)|int;)|p(?:f;|rod;|y(?:;|sr;|)))|r(?:arr;|oss;)|s(?:cr;|u(?:b(?:;|e;)|p(?:;|e;)))|tdot;|u(?:darr(?:l;|r;)|e(?:pr;|sc;)|larr(?:;|p;)|p(?:;|brcap;|c(?:ap;|up;)|dot;|or;|s;)|r(?:arr(?:;|m;)|ly(?:eq(?:prec;|succ;)|vee;|wedge;)|ren;?|vearrow(?:left;|right;))|vee;|wed;)|w(?:conint;|int;)|ylcty;)|d(?:Arr;|Har;|a(?:gger;|leth;|rr;|sh(?:;|v;))|b(?:karow;|lac;)|c(?:aron;|y;)|d(?:;|a(?:gger;|rr;)|otseq;)|e(?:g;?|lta;|mptyv;)|f(?:isht;|r;)|har(?:l;|r;)|i(?:am(?:;|ond(?:;|suit;)|s;)|e;|gamma;|sin;|v(?:;|ide(?:;|ontimes;|)|onx;))|jcy;|lc(?:orn;|rop;)|o(?:llar;|pf;|t(?:;|eq(?:;|dot;)|minus;|plus;|square;)|ublebarwedge;|wn(?:arrow;|downarrows;|harpoon(?:left;|right;)))|r(?:bkarow;|c(?:orn;|rop;))|s(?:c(?:r;|y;)|ol;|trok;)|t(?:dot;|ri(?:;|f;))|u(?:arr;|har;)|wangle;|z(?:cy;|igrarr;))|e(?:D(?:Dot;|ot;)|a(?:cute;?|ster;)|c(?:aron;|ir(?:;|c;?)|olon;|y;)|dot;|e;|f(?:Dot;|r;)|g(?:;|rave;?|s(?:;|dot;))|l(?:;|inters;|l;|s(?:;|dot;))|m(?:acr;|pty(?:;|set;|v;)|sp(?:1(?:3;|4;)|;))|n(?:g;|sp;)|o(?:gon;|pf;)|p(?:ar(?:;|sl;)|lus;|si(?:;|lon;|v;))|q(?:c(?:irc;|olon;)|s(?:im;|lant(?:gtr;|less;))|u(?:als;|est;|iv(?:;|DD;))|vparsl;)|r(?:Dot;|arr;)|s(?:cr;|dot;|im;)|t(?:a;|h;?)|u(?:ml;?|ro;)|x(?:cl;|ist;|p(?:ectation;|onentiale;)))|f(?:allingdotseq;|cy;|emale;|f(?:ilig;|l(?:ig;|lig;)|r;)|ilig;|jlig;|l(?:at;|lig;|tns;)|nof;|o(?:pf;|r(?:all;|k(?:;|v;)))|partint;|r(?:a(?:c(?:1(?:2;?|3;|4;?|5;|6;|8;)|2(?:3;|5;)|3(?:4;?|5;|8;)|45;|5(?:6;|8;)|78;)|sl;)|own;)|scr;)|g(?:E(?:;|l;)|a(?:cute;|mma(?:;|d;)|p;)|breve;|c(?:irc;|y;)|dot;|e(?:;|l;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|l;))|l(?:;|es;)))|fr;|g(?:;|g;)|imel;|jcy;|l(?:;|E;|a;|j;)|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|opf;|rave;|s(?:cr;|im(?:;|e;|l;))|t(?:;|c(?:c;|ir;)|dot;|lPar;|quest;|r(?:a(?:pprox;|rr;)|dot;|eq(?:less;|qless;)|less;|sim;)|)|v(?:ertneqq;|nE;))|h(?:Arr;|a(?:irsp;|lf;|milt;|r(?:dcy;|r(?:;|cir;|w;)))|bar;|circ;|e(?:arts(?:;|uit;)|llip;|rcon;)|fr;|ks(?:earow;|warow;)|o(?:arr;|mtht;|ok(?:leftarrow;|rightarrow;)|pf;|rbar;)|s(?:cr;|lash;|trok;)|y(?:bull;|phen;))|i(?:acute;?|c(?:;|irc;?|y;)|e(?:cy;|xcl;?)|f(?:f;|r;)|grave;?|i(?:;|i(?:int;|nt;)|nfin;|ota;)|jlig;|m(?:a(?:cr;|g(?:e;|line;|part;)|th;)|of;|ped;)|n(?:;|care;|fin(?:;|tie;)|odot;|t(?:;|cal;|e(?:gers;|rcal;)|larhk;|prod;))|o(?:cy;|gon;|pf;|ta;)|prod;|quest;?|s(?:cr;|in(?:;|E;|dot;|s(?:;|v;)|v;))|t(?:;|ilde;)|u(?:kcy;|ml;?))|j(?:c(?:irc;|y;)|fr;|math;|opf;|s(?:cr;|ercy;)|ukcy;)|k(?:appa(?:;|v;)|c(?:edil;|y;)|fr;|green;|hcy;|jcy;|opf;|scr;)|l(?:A(?:arr;|rr;|tail;)|Barr;|E(?:;|g;)|Har;|a(?:cute;|emptyv;|gran;|mbda;|ng(?:;|d;|le;)|p;|quo;?|rr(?:;|b(?:;|fs;)|fs;|hk;|lp;|pl;|sim;|tl;)|t(?:;|ail;|e(?:;|s;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|quo(?:;|r;)|r(?:dhar;|ushar;)|sh;)|e(?:;|ft(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|leftarrows;|right(?:arrow(?:;|s;)|harpoons;|squigarrow;)|threetimes;)|g;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|r;))|g(?:;|es;)|s(?:approx;|dot;|eq(?:gtr;|qgtr;)|gtr;|sim;)))|f(?:isht;|loor;|r;)|g(?:;|E;)|h(?:ar(?:d;|u(?:;|l;))|blk;)|jcy;|l(?:;|arr;|corner;|hard;|tri;)|m(?:idot;|oust(?:;|ache;))|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|o(?:a(?:ng;|rr;)|brk;|ng(?:left(?:arrow;|rightarrow;)|mapsto;|rightarrow;)|oparrow(?:left;|right;)|p(?:ar;|f;|lus;)|times;|w(?:ast;|bar;)|z(?:;|enge;|f;))|par(?:;|lt;)|r(?:arr;|corner;|har(?:;|d;)|m;|tri;)|s(?:aquo;|cr;|h;|im(?:;|e;|g;)|q(?:b;|uo(?:;|r;))|trok;)|t(?:;|c(?:c;|ir;)|dot;|hree;|imes;|larr;|quest;|r(?:Par;|i(?:;|e;|f;))|)|ur(?:dshar;|uhar;)|v(?:ertneqq;|nE;))|m(?:DDot;|a(?:cr;?|l(?:e;|t(?:;|ese;))|p(?:;|sto(?:;|down;|left;|up;))|rker;)|c(?:omma;|y;)|dash;|easuredangle;|fr;|ho;|i(?:cro;?|d(?:;|ast;|cir;|dot;?)|nus(?:;|b;|d(?:;|u;)))|l(?:cp;|dr;)|nplus;|o(?:dels;|pf;)|p;|s(?:cr;|tpos;)|u(?:;|ltimap;|map;))|n(?:G(?:g;|t(?:;|v;))|L(?:eft(?:arrow;|rightarrow;)|l;|t(?:;|v;))|Rightarrow;|V(?:Dash;|dash;)|a(?:bla;|cute;|ng;|p(?:;|E;|id;|os;|prox;)|tur(?:;|al(?:;|s;)))|b(?:sp;?|ump(?:;|e;))|c(?:a(?:p;|ron;)|edil;|ong(?:;|dot;)|up;|y;)|dash;|e(?:;|Arr;|ar(?:hk;|r(?:;|ow;))|dot;|quiv;|s(?:ear;|im;)|xist(?:;|s;))|fr;|g(?:E;|e(?:;|q(?:;|q;|slant;)|s;)|sim;|t(?:;|r;))|h(?:Arr;|arr;|par;)|i(?:;|s(?:;|d;)|v;)|jcy;|l(?:Arr;|E;|arr;|dr;|e(?:;|ft(?:arrow;|rightarrow;)|q(?:;|q;|slant;)|s(?:;|s;))|sim;|t(?:;|ri(?:;|e;)))|mid;|o(?:pf;|t(?:;|in(?:;|E;|dot;|v(?:a;|b;|c;))|ni(?:;|v(?:a;|b;|c;))|))|p(?:ar(?:;|allel;|sl;|t;)|olint;|r(?:;|cue;|e(?:;|c(?:;|eq;))))|r(?:Arr;|arr(?:;|c;|w;)|ightarrow;|tri(?:;|e;))|s(?:c(?:;|cue;|e;|r;)|hort(?:mid;|parallel;)|im(?:;|e(?:;|q;))|mid;|par;|qsu(?:be;|pe;)|u(?:b(?:;|E;|e;|set(?:;|eq(?:;|q;)))|cc(?:;|eq;)|p(?:;|E;|e;|set(?:;|eq(?:;|q;)))))|t(?:gl;|ilde;?|lg;|riangle(?:left(?:;|eq;)|right(?:;|eq;)))|u(?:;|m(?:;|ero;|sp;))|v(?:Dash;|Harr;|ap;|dash;|g(?:e;|t;)|infin;|l(?:Arr;|e;|t(?:;|rie;))|r(?:Arr;|trie;)|sim;)|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|near;))|o(?:S;|a(?:cute;?|st;)|c(?:ir(?:;|c;?)|y;)|d(?:ash;|blac;|iv;|ot;|sold;)|elig;|f(?:cir;|r;)|g(?:on;|rave;?|t;)|h(?:bar;|m;)|int;|l(?:arr;|c(?:ir;|ross;)|ine;|t;)|m(?:acr;|ega;|i(?:cron;|d;|nus;))|opf;|p(?:ar;|erp;|lus;)|r(?:;|arr;|d(?:;|er(?:;|of;)|f;?|m;?)|igof;|or;|slope;|v;)|s(?:cr;|lash;?|ol;)|ti(?:lde;?|mes(?:;|as;))|uml;?|vbar;)|p(?:ar(?:;|a(?:;|llel;|)|s(?:im;|l;)|t;)|cy;|er(?:cnt;|iod;|mil;|p;|tenk;)|fr;|h(?:i(?:;|v;)|mmat;|one;)|i(?:;|tchfork;|v;)|l(?:an(?:ck(?:;|h;)|kv;)|us(?:;|acir;|b;|cir;|d(?:o;|u;)|e;|mn;?|sim;|two;))|m;|o(?:intint;|pf;|und;?)|r(?:;|E;|ap;|cue;|e(?:;|c(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;))|ime(?:;|s;)|n(?:E;|ap;|sim;)|o(?:d;|f(?:alar;|line;|surf;)|p(?:;|to;))|sim;|urel;)|s(?:cr;|i;)|uncsp;)|q(?:fr;|int;|opf;|prime;|scr;|u(?:at(?:ernions;|int;)|est(?:;|eq;)|ot;?))|r(?:A(?:arr;|rr;|tail;)|Barr;|Har;|a(?:c(?:e;|ute;)|dic;|emptyv;|ng(?:;|d;|e;|le;)|quo;?|rr(?:;|ap;|b(?:;|fs;)|c;|fs;|hk;|lp;|pl;|sim;|tl;|w;)|t(?:ail;|io(?:;|nals;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|ldhar;|quo(?:;|r;)|sh;)|e(?:al(?:;|ine;|part;|s;)|ct;|g;?)|f(?:isht;|loor;|r;)|h(?:ar(?:d;|u(?:;|l;))|o(?:;|v;))|i(?:ght(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|left(?:arrows;|harpoons;)|rightarrows;|squigarrow;|threetimes;)|ng;|singdotseq;)|l(?:arr;|har;|m;)|moust(?:;|ache;)|nmid;|o(?:a(?:ng;|rr;)|brk;|p(?:ar;|f;|lus;)|times;)|p(?:ar(?:;|gt;)|polint;)|rarr;|s(?:aquo;|cr;|h;|q(?:b;|uo(?:;|r;)))|t(?:hree;|imes;|ri(?:;|e;|f;|ltri;))|uluhar;|x;)|s(?:acute;|bquo;|c(?:;|E;|a(?:p;|ron;)|cue;|e(?:;|dil;)|irc;|n(?:E;|ap;|sim;)|polint;|sim;|y;)|dot(?:;|b;|e;)|e(?:Arr;|ar(?:hk;|r(?:;|ow;))|ct;?|mi;|swar;|tm(?:inus;|n;)|xt;)|fr(?:;|own;)|h(?:arp;|c(?:hcy;|y;)|ort(?:mid;|parallel;)|y;?)|i(?:gma(?:;|f;|v;)|m(?:;|dot;|e(?:;|q;)|g(?:;|E;)|l(?:;|E;)|ne;|plus;|rarr;))|larr;|m(?:a(?:llsetminus;|shp;)|eparsl;|i(?:d;|le;)|t(?:;|e(?:;|s;)))|o(?:ftcy;|l(?:;|b(?:;|ar;))|pf;)|pa(?:des(?:;|uit;)|r;)|q(?:c(?:ap(?:;|s;)|up(?:;|s;))|su(?:b(?:;|e;|set(?:;|eq;))|p(?:;|e;|set(?:;|eq;)))|u(?:;|ar(?:e;|f;)|f;))|rarr;|s(?:cr;|etmn;|mile;|tarf;)|t(?:ar(?:;|f;)|r(?:aight(?:epsilon;|phi;)|ns;))|u(?:b(?:;|E;|dot;|e(?:;|dot;)|mult;|n(?:E;|e;)|plus;|rarr;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;)))|cc(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;)|m;|ng;|p(?:1;?|2;?|3;?|;|E;|d(?:ot;|sub;)|e(?:;|dot;)|hs(?:ol;|ub;)|larr;|mult;|n(?:E;|e;)|plus;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;))))|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|nwar;)|zlig;?)|t(?:a(?:rget;|u;)|brk;|c(?:aron;|edil;|y;)|dot;|elrec;|fr;|h(?:e(?:re(?:4;|fore;)|ta(?:;|sym;|v;))|i(?:ck(?:approx;|sim;)|nsp;)|k(?:ap;|sim;)|orn;?)|i(?:lde;|mes(?:;|b(?:;|ar;)|d;|)|nt;)|o(?:ea;|p(?:;|bot;|cir;|f(?:;|ork;))|sa;)|prime;|r(?:ade;|i(?:angle(?:;|down;|left(?:;|eq;)|q;|right(?:;|eq;))|dot;|e;|minus;|plus;|sb;|time;)|pezium;)|s(?:c(?:r;|y;)|hcy;|trok;)|w(?:ixt;|ohead(?:leftarrow;|rightarrow;)))|u(?:Arr;|Har;|a(?:cute;?|rr;)|br(?:cy;|eve;)|c(?:irc;?|y;)|d(?:arr;|blac;|har;)|f(?:isht;|r;)|grave;?|h(?:ar(?:l;|r;)|blk;)|l(?:c(?:orn(?:;|er;)|rop;)|tri;)|m(?:acr;|l;?)|o(?:gon;|pf;)|p(?:arrow;|downarrow;|harpoon(?:left;|right;)|lus;|si(?:;|h;|lon;)|uparrows;)|r(?:c(?:orn(?:;|er;)|rop;)|ing;|tri;)|scr;|t(?:dot;|ilde;|ri(?:;|f;))|u(?:arr;|ml;?)|wangle;)|v(?:Arr;|Bar(?:;|v;)|Dash;|a(?:ngrt;|r(?:epsilon;|kappa;|nothing;|p(?:hi;|i;|ropto;)|r(?:;|ho;)|s(?:igma;|u(?:bsetneq(?:;|q;)|psetneq(?:;|q;)))|t(?:heta;|riangle(?:left;|right;))))|cy;|dash;|e(?:e(?:;|bar;|eq;)|llip;|r(?:bar;|t;))|fr;|ltri;|nsu(?:b;|p;)|opf;|prop;|rtri;|s(?:cr;|u(?:bn(?:E;|e;)|pn(?:E;|e;)))|zigzag;)|w(?:circ;|e(?:d(?:bar;|ge(?:;|q;))|ierp;)|fr;|opf;|p;|r(?:;|eath;)|scr;)|x(?:c(?:ap;|irc;|up;)|dtri;|fr;|h(?:Arr;|arr;)|i;|l(?:Arr;|arr;)|map;|nis;|o(?:dot;|p(?:f;|lus;)|time;)|r(?:Arr;|arr;)|s(?:cr;|qcup;)|u(?:plus;|tri;)|vee;|wedge;)|y(?:ac(?:ute;?|y;)|c(?:irc;|y;)|en;?|fr;|icy;|opf;|scr;|u(?:cy;|ml;?))|z(?:acute;|c(?:aron;|y;)|dot;|e(?:etrf;|ta;)|fr;|hcy;|igrarr;|opf;|scr;|w(?:j;|nj;)))|[\s\S]/g,
    CLe = 32,
    bLe = /[^\r"&\u0000]+/g,
    ELe = /[^\r'&\u0000]+/g,
    _Le = /[^\r\t\n\f &>\u0000]+/g,
    xLe = /[^\r\t\n\f \/>A-Z\u0000]+/g,
    wLe = /[^\r\t\n\f \/=>A-Z\u0000]+/g,
    SLe = /[^\]\r\u0000\uffff]*/g,
    ILe = /[^&<\r\u0000\uffff]*/g,
    l7 = /[^<\r\u0000\uffff]*/g,
    BLe = /[^\r\u0000\uffff]*/g,
    c7 = /(?:(\/)?([a-z]+)>)|[\s\S]/g,
    u7 =
      /(?:([-a-z]+)[ \t\n\f]*=[ \t\n\f]*('[^'&\r\u0000]*'|"[^"&\r\u0000]*"|[^\t\n\r\f "&'\u0000>][^&> \t\n\r\f\u0000]*[ \t\n\f]))|[\s\S]/g,
    AB = /[^\x09\x0A\x0C\x0D\x20]/,
    sO = /[^\x09\x0A\x0C\x0D\x20]/g,
    RLe = /[^\x00\x09\x0A\x0C\x0D\x20]/,
    hp = /^[\x09\x0A\x0C\x0D\x20]+/,
    yB = /\x00/g
  function Gs(e) {
    var t = 16384
    if (e.length < t) return String.fromCharCode.apply(String, e)
    for (var r = "", n = 0; n < e.length; n += t)
      r += String.fromCharCode.apply(String, e.slice(n, n + t))
    return r
  }
  function DLe(e) {
    for (var t = [], r = 0; r < e.length; r++) t[r] = e.charCodeAt(r)
    return t
  }
  function tn(e, t) {
    if (typeof t == "string")
      return e.namespaceURI === lt.HTML && e.localName === t
    var r = t[e.namespaceURI]
    return r && r[e.localName]
  }
  function d7(e) {
    return tn(e, E7)
  }
  function f7(e) {
    if (tn(e, _7)) return true
    if (e.namespaceURI === lt.MATHML && e.localName === "annotation-xml") {
      var t = e.getAttribute("encoding")
      if (
        (t && (t = t.toLowerCase()),
        t === "text/html" || t === "application/xhtml+xml")
      )
        return true
    }
    return false
  }
  function TLe(e) {
    return e in s7 ? s7[e] : e
  }
  function h7(e) {
    for (var t = 0, r = e.length; t < r; t++)
      e[t][0] in i7 && (e[t][0] = i7[e[t][0]])
  }
  function g7(e) {
    for (var t = 0, r = e.length; t < r; t++)
      if (e[t][0] === "definitionurl") {
        e[t][0] = "definitionURL"
        break
      }
  }
  function oO(e) {
    for (var t = 0, r = e.length; t < r; t++)
      e[t][0] in n7 && e[t].push(n7[e[t][0]])
  }
  function p7(e, t) {
    for (var r = 0, n = e.length; r < n; r++) {
      var i = e[r][0],
        s = e[r][1]
      t.hasAttribute(i) || t._setAttribute(i, s)
    }
  }
  Qr.ElementStack = function () {
    ;(this.elements = []), (this.top = null)
  }
  Qr.ElementStack.prototype.push = function (e) {
    this.elements.push(e), (this.top = e)
  }
  Qr.ElementStack.prototype.pop = function (e) {
    this.elements.pop(), (this.top = this.elements[this.elements.length - 1])
  }
  Qr.ElementStack.prototype.popTag = function (e) {
    for (var t = this.elements.length - 1; t > 0; t--) {
      var r = this.elements[t]
      if (tn(r, e)) break
    }
    ;(this.elements.length = t), (this.top = this.elements[t - 1])
  }
  Qr.ElementStack.prototype.popElementType = function (e) {
    for (
      var t = this.elements.length - 1;
      t > 0 && !(this.elements[t] instanceof e);
      t--
    );
    ;(this.elements.length = t), (this.top = this.elements[t - 1])
  }
  Qr.ElementStack.prototype.popElement = function (e) {
    for (
      var t = this.elements.length - 1;
      t > 0 && this.elements[t] !== e;
      t--
    );
    ;(this.elements.length = t), (this.top = this.elements[t - 1])
  }
  Qr.ElementStack.prototype.removeElement = function (e) {
    if (this.top === e) this.pop()
    else {
      var t = this.elements.lastIndexOf(e)
      t !== -1 && this.elements.splice(t, 1)
    }
  }
  Qr.ElementStack.prototype.clearToContext = function (e) {
    for (
      var t = this.elements.length - 1;
      t > 0 && !tn(this.elements[t], e);
      t--
    );
    ;(this.elements.length = t + 1), (this.top = this.elements[t])
  }
  Qr.ElementStack.prototype.contains = function (e) {
    return this.inSpecificScope(e, Object.create(null))
  }
  Qr.ElementStack.prototype.inSpecificScope = function (e, t) {
    for (var r = this.elements.length - 1; r >= 0; r--) {
      var n = this.elements[r]
      if (tn(n, e)) return true
      if (tn(n, t)) return false
    }
    return false
  }
  Qr.ElementStack.prototype.elementInSpecificScope = function (e, t) {
    for (var r = this.elements.length - 1; r >= 0; r--) {
      var n = this.elements[r]
      if (n === e) return true
      if (tn(n, t)) return false
    }
    return false
  }
  Qr.ElementStack.prototype.elementTypeInSpecificScope = function (e, t) {
    for (var r = this.elements.length - 1; r >= 0; r--) {
      var n = this.elements[r]
      if (n instanceof e) return true
      if (tn(n, t)) return false
    }
    return false
  }
  Qr.ElementStack.prototype.inScope = function (e) {
    return this.inSpecificScope(e, yu)
  }
  Qr.ElementStack.prototype.elementInScope = function (e) {
    return this.elementInSpecificScope(e, yu)
  }
  Qr.ElementStack.prototype.elementTypeInScope = function (e) {
    return this.elementTypeInSpecificScope(e, yu)
  }
  Qr.ElementStack.prototype.inButtonScope = function (e) {
    return this.inSpecificScope(e, cO)
  }
  Qr.ElementStack.prototype.inListItemScope = function (e) {
    return this.inSpecificScope(e, bB)
  }
  Qr.ElementStack.prototype.inTableScope = function (e) {
    return this.inSpecificScope(e, b7)
  }
  Qr.ElementStack.prototype.inSelectScope = function (e) {
    for (var t = this.elements.length - 1; t >= 0; t--) {
      var r = this.elements[t]
      if (r.namespaceURI !== lt.HTML) return false
      var n = r.localName
      if (n === e) return true
      if (n !== "optgroup" && n !== "option") return false
    }
    return false
  }
  Qr.ElementStack.prototype.generateImpliedEndTags = function (e, t) {
    for (var r = t ? v7 : y7, n = this.elements.length - 1; n >= 0; n--) {
      var i = this.elements[n]
      if ((e && tn(i, e)) || !tn(this.elements[n], r)) break
    }
    ;(this.elements.length = n + 1), (this.top = this.elements[n])
  }
  Qr.ActiveFormattingElements = function () {
    ;(this.list = []), (this.attrs = [])
  }
  Qr.ActiveFormattingElements.prototype.MARKER = { localName: "|" }
  Qr.ActiveFormattingElements.prototype.insertMarker = function () {
    this.list.push(this.MARKER), this.attrs.push(this.MARKER)
  }
  Qr.ActiveFormattingElements.prototype.push = function (e, t) {
    for (
      var r = 0, n = this.list.length - 1;
      n >= 0 && this.list[n] !== this.MARKER;
      n--
    )
      if (o(e, this.list[n], this.attrs[n]) && (r++, r === 3)) {
        this.list.splice(n, 1), this.attrs.splice(n, 1)
        break
      }
    this.list.push(e)
    for (var i = [], s = 0; s < t.length; s++) i[s] = t[s]
    this.attrs.push(i)
    function o(a, l, c) {
      if (a.localName !== l.localName || a._numattrs !== c.length) return false
      for (var u = 0, f = c.length; u < f; u++) {
        var p = c[u][0],
          g = c[u][1]
        if (!a.hasAttribute(p) || a.getAttribute(p) !== g) return false
      }
      return true
    }
  }
  Qr.ActiveFormattingElements.prototype.clearToMarker = function () {
    for (
      var e = this.list.length - 1;
      e >= 0 && this.list[e] !== this.MARKER;
      e--
    );
    e < 0 && (e = 0), (this.list.length = e), (this.attrs.length = e)
  }
  Qr.ActiveFormattingElements.prototype.findElementByTag = function (e) {
    for (var t = this.list.length - 1; t >= 0; t--) {
      var r = this.list[t]
      if (r === this.MARKER) break
      if (r.localName === e) return r
    }
    return null
  }
  Qr.ActiveFormattingElements.prototype.indexOf = function (e) {
    return this.list.lastIndexOf(e)
  }
  Qr.ActiveFormattingElements.prototype.remove = function (e) {
    var t = this.list.lastIndexOf(e)
    t !== -1 && (this.list.splice(t, 1), this.attrs.splice(t, 1))
  }
  Qr.ActiveFormattingElements.prototype.replace = function (e, t, r) {
    var n = this.list.lastIndexOf(e)
    n !== -1 && ((this.list[n] = t), (this.attrs[n] = r))
  }
  Qr.ActiveFormattingElements.prototype.insertAfter = function (e, t) {
    var r = this.list.lastIndexOf(e)
    r !== -1 && (this.list.splice(r, 0, t), this.attrs.splice(r, 0, t))
  }
  function Qr(e, t, r) {
    var n = null,
      i = 0,
      s = 0,
      o = false,
      a = false,
      l = 0,
      c = [],
      u = "",
      f = true,
      p = 0,
      g = er,
      m,
      y,
      v = "",
      C = "",
      E = [],
      w = "",
      B = "",
      T = [],
      N = [],
      W = [],
      Z = [],
      te = [],
      Y = false,
      U = oS,
      ce = null,
      Ie = [],
      Q = new Qr.ElementStack(),
      se = new Qr.ActiveFormattingElements(),
      J = t !== undefined,
      ie = null,
      Ue = null,
      At = true
    t && (At = t.ownerDocument._scripting_enabled),
      r && r.scripting_enabled === false && (At = false)
    var ve = true,
      Mt = false,
      Xt,
      rr,
      ue = [],
      wr = false,
      or = false,
      Wr = {
        document: function () {
          return Ge
        },
        _asDocumentFragment: function () {
          for (
            var x = Ge.createDocumentFragment(), S = Ge.firstChild;
            S.hasChildNodes();

          )
            x.appendChild(S.firstChild)
          return x
        },
        pause: function () {
          p++
        },
        resume: function () {
          p--, this.parse("")
        },
        parse: function (x, S, L) {
          var re
          return p > 0
            ? ((u += x), true)
            : (l === 0
                ? (u && ((x = u + x), (u = "")),
                  S && ((x += "\uFFFF"), (o = true)),
                  (n = x),
                  (i = x.length),
                  (s = 0),
                  f && ((f = false), n.charCodeAt(0) === 65279 && (s = 1)),
                  l++,
                  (re = pr(L)),
                  (u = n.substring(s, i)),
                  l--)
                : (l++,
                  c.push(n, i, s),
                  (n = x),
                  (i = x.length),
                  (s = 0),
                  pr(),
                  (re = false),
                  (u = n.substring(s, i)),
                  (s = c.pop()),
                  (i = c.pop()),
                  (n = c.pop()),
                  u &&
                    ((n = u + n.substring(s)),
                    (i = n.length),
                    (s = 0),
                    (u = "")),
                  l--),
              re)
        },
      },
      Ge = new dLe(true, e)
    if (((Ge._parser = Wr), (Ge._scripting_enabled = At), t)) {
      if (
        (t.ownerDocument._quirks && (Ge._quirks = true),
        t.ownerDocument._limitedQuirks && (Ge._limitedQuirks = true),
        t.namespaceURI === lt.HTML)
      )
        switch (t.localName) {
          case "title":
          case "textarea":
            g = iu
            break
          case "style":
          case "xmp":
          case "iframe":
          case "noembed":
          case "noframes":
          case "script":
          case "plaintext":
            g = wC
            break
        }
      var ln = Ge.createElement("html")
      Ge._appendChild(ln),
        Q.push(ln),
        t instanceof en.HTMLTemplateElement && Ie.push(Tg),
        Tf()
      for (var Gr = t; Gr !== null; Gr = Gr.parentElement)
        if (Gr instanceof en.HTMLFormElement) {
          Ue = Gr
          break
        }
    }
    function pr(x) {
      for (var S, L, re, oe; s < i; ) {
        if (p > 0 || (x && x())) return true
        switch (typeof g.lookahead) {
          case "undefined":
            if (((S = n.charCodeAt(s++)), a && ((a = false), S === 10))) {
              s++
              continue
            }
            switch (S) {
              case 13:
                s < i ? n.charCodeAt(s) === 10 && s++ : (a = true), g(10)
                break
              case 65535:
                if (o && s === i) {
                  g(mB)
                  break
                }
              default:
                g(S)
                break
            }
            break
          case "number":
            S = n.charCodeAt(s)
            var Re = g.lookahead,
              st = true
            if ((Re < 0 && ((st = false), (Re = -Re)), Re < i - s))
              (L = st ? n.substring(s, s + Re) : null), (oe = false)
            else if (o)
              (L = st ? n.substring(s, i) : null),
                (oe = true),
                S === 65535 && s === i - 1 && (S = mB)
            else return true
            g(S, L, oe)
            break
          case "string":
            ;(S = n.charCodeAt(s)), (re = g.lookahead)
            var $t = n.indexOf(re, s)
            if ($t !== -1) (L = n.substring(s, $t + re.length)), (oe = false)
            else {
              if (!o) return true
              ;(L = n.substring(s, i)),
                S === 65535 && s === i - 1 && (S = mB),
                (oe = true)
            }
            g(S, L, oe)
            break
        }
      }
      return false
    }
    function Ee(x, S) {
      for (var L = 0; L < te.length; L++) if (te[L][0] === x) return
      S !== undefined ? te.push([x, S]) : te.push([x])
    }
    function Or() {
      u7.lastIndex = s - 1
      var x = u7.exec(n)
      if (!x) throw new Error("should never happen")
      var S = x[1]
      if (!S) return false
      var L = x[2],
        re = L.length
      switch (L[0]) {
        case '"':
        case "'":
          ;(L = L.substring(1, re - 1)), (s += x[0].length - 1), (g = lA)
          break
        default:
          ;(g = oo), (s += x[0].length - 1), (L = L.substring(0, re - 1))
          break
      }
      for (var oe = 0; oe < te.length; oe++) if (te[oe][0] === S) return true
      return te.push([S, L]), true
    }
    function he() {
      ;(Y = false), (v = ""), (te.length = 0)
    }
    function be() {
      ;(Y = true), (v = ""), (te.length = 0)
    }
    function _t() {
      E.length = 0
    }
    function hn() {
      w = ""
    }
    function Rn() {
      B = ""
    }
    function Ii() {
      T.length = 0
    }
    function so() {
      ;(N.length = 0), (W = null), (Z = null)
    }
    function cd() {
      W = []
    }
    function nu() {
      Z = []
    }
    function ar() {
      Mt = true
    }
    function G2() {
      return Q.top && Q.top.namespaceURI !== "http://www.w3.org/1999/xhtml"
    }
    function ji(x) {
      return C === x
    }
    function pa() {
      if (ue.length > 0) {
        var x = Gs(ue)
        if (
          ((ue.length = 0),
          or &&
            ((or = false),
            x[0] ===
              `
` && (x = x.substring(1)),
            x.length === 0))
        )
          return
        Dn(a0, x), (wr = false)
      }
      or = false
    }
    function ud(x) {
      x.lastIndex = s - 1
      var S = x.exec(n)
      if (S && S.index === s - 1)
        return (
          (S = S[0]),
          (s += S.length - 1),
          o && s === i && ((S = S.slice(0, -1)), s--),
          S
        )
      throw new Error("should never happen")
    }
    function dd(x) {
      x.lastIndex = s - 1
      var S = x.exec(n)[0]
      return S ? (vC(S), (s += S.length - 1), true) : false
    }
    function vC(x) {
      ue.length > 0 && pa(),
        !(
          or &&
          ((or = false),
          x[0] ===
            `
` && (x = x.substring(1)),
          x.length === 0)
        ) && Dn(a0, x)
    }
    function ma() {
      if (Y) Dn(ur, v)
      else {
        var x = v
        ;(v = ""), (C = x), Dn(Ws, x, te)
      }
    }
    function CC() {
      if (s === i) return false
      c7.lastIndex = s
      var x = c7.exec(n)
      if (!x) throw new Error("should never happen")
      var S = x[2]
      if (!S) return false
      var L = x[1]
      return (
        L
          ? ((s += S.length + 2), Dn(ur, S))
          : ((s += S.length + 1), (C = S), Dn(Ws, S, gLe)),
        true
      )
    }
    function bC() {
      Y ? Dn(ur, v, null, true) : Dn(Ws, v, te, true)
    }
    function _r() {
      Dn(hLe, Gs(N), W ? Gs(W) : undefined, Z ? Gs(Z) : undefined)
    }
    function It() {
      pa(), U(mB), (Ge.modclock = 1)
    }
    var Dn = (Wr.insertToken = function (S, L, re, oe) {
      pa()
      var Re = Q.top
      !Re || Re.namespaceURI === lt.HTML
        ? U(S, L, re, oe)
        : S !== Ws && S !== a0
          ? Ad(S, L, re, oe)
          : (d7(Re) &&
                (S === a0 ||
                  (S === Ws && L !== "mglyph" && L !== "malignmark"))) ||
              (S === Ws &&
                L === "svg" &&
                Re.namespaceURI === lt.MATHML &&
                Re.localName === "annotation-xml") ||
              f7(Re)
            ? ((rr = true), U(S, L, re, oe), (rr = false))
            : Ad(S, L, re, oe)
    })
    function ol(x) {
      var S = Q.top
      ic && tn(S, l0)
        ? tA(function (L) {
            return L.createComment(x)
          })
        : (S instanceof en.HTMLTemplateElement && (S = S.content),
          S._appendChild(S.ownerDocument.createComment(x)))
    }
    function al(x) {
      var S = Q.top
      if (ic && tn(S, l0))
        tA(function (re) {
          return re.createTextNode(x)
        })
      else {
        S instanceof en.HTMLTemplateElement && (S = S.content)
        var L = S.lastChild
        L && L.nodeType === iO.TEXT_NODE
          ? L.appendData(x)
          : S._appendChild(S.ownerDocument.createTextNode(x))
      }
    }
    function Ig(x, S, L) {
      var re = m7.createElement(x, S, null)
      if (L)
        for (var oe = 0, Re = L.length; oe < Re; oe++)
          re._setAttribute(L[oe][0], L[oe][1])
      return re
    }
    var ic = false
    function bt(x, S) {
      var L = eA(function (re) {
        return Ig(re, x, S)
      })
      return tn(L, C7) && (L._form = Ue), L
    }
    function eA(x) {
      var S
      return (
        ic && tn(Q.top, l0)
          ? (S = tA(x))
          : Q.top instanceof en.HTMLTemplateElement
            ? ((S = x(Q.top.content.ownerDocument)),
              Q.top.content._appendChild(S))
            : ((S = x(Q.top.ownerDocument)), Q.top._appendChild(S)),
        Q.push(S),
        S
      )
    }
    function EC(x, S, L) {
      return eA(function (re) {
        var oe = re._createElementNS(x, L, null)
        if (S)
          for (var Re = 0, st = S.length; Re < st; Re++) {
            var $t = S[Re]
            $t.length === 2
              ? oe._setAttribute($t[0], $t[1])
              : oe._setAttributeNS($t[2], $t[0], $t[1])
          }
        return oe
      })
    }
    function Nw(x) {
      for (var S = Q.elements.length - 1; S >= 0; S--)
        if (Q.elements[S] instanceof x) return S
      return -1
    }
    function tA(x) {
      var S,
        L,
        re = -1,
        oe = -1,
        Re
      if (
        ((re = Nw(en.HTMLTableElement)),
        (oe = Nw(en.HTMLTemplateElement)),
        oe >= 0 && (re < 0 || oe > re)
          ? (S = Q.elements[oe])
          : re >= 0 &&
            ((S = Q.elements[re].parentNode),
            S ? (L = Q.elements[re]) : (S = Q.elements[re - 1])),
        S || (S = Q.elements[0]),
        S instanceof en.HTMLTemplateElement && (S = S.content),
        (Re = x(S.ownerDocument)),
        Re.nodeType === iO.TEXT_NODE)
      ) {
        var st
        if (
          (L ? (st = L.previousSibling) : (st = S.lastChild),
          st && st.nodeType === iO.TEXT_NODE)
        )
          return st.appendData(Re.data), Re
      }
      return L ? S.insertBefore(Re, L) : S._appendChild(Re), Re
    }
    function Tf() {
      for (var x = false, S = Q.elements.length - 1; S >= 0; S--) {
        var L = Q.elements[S]
        if ((S === 0 && ((x = true), J && (L = t)), L.namespaceURI === lt.HTML)) {
          var re = L.localName
          switch (re) {
            case "select":
              for (var oe = S; oe > 0; ) {
                var Re = Q.elements[--oe]
                if (Re instanceof en.HTMLTemplateElement) break
                if (Re instanceof en.HTMLTableElement) {
                  U = dA
                  return
                }
              }
              U = ya
              return
            case "tr":
              U = Zr
              return
            case "tbody":
            case "tfoot":
            case "thead":
              U = oc
              return
            case "caption":
              U = cl
              return
            case "colgroup":
              U = md
              return
            case "table":
              U = Po
              return
            case "template":
              U = Ie[Ie.length - 1]
              return
            case "body":
              U = it
              return
            case "frameset":
              U = LC
              return
            case "html":
              ie === null ? (U = Dg) : (U = vs)
              return
            default:
              if (!x) {
                if (re === "head") {
                  U = Tn
                  return
                }
                if (re === "td" || re === "th") {
                  U = ao
                  return
                }
              }
          }
        }
        if (x) {
          U = it
          return
        }
      }
    }
    function rA(x, S) {
      bt(x, S), (g = Bg), (ce = U), (U = Cs)
    }
    function $2(x, S) {
      bt(x, S), (g = iu), (ce = U), (U = Cs)
    }
    function _C(x, S) {
      return {
        elt: Ig(x, se.list[S].localName, se.attrs[S]),
        attrs: se.attrs[S],
      }
    }
    function Li() {
      if (se.list.length !== 0) {
        var x = se.list[se.list.length - 1]
        if (x !== se.MARKER && Q.elements.lastIndexOf(x) === -1) {
          for (
            var S = se.list.length - 2;
            S >= 0 &&
            ((x = se.list[S]),
            !(x === se.MARKER || Q.elements.lastIndexOf(x) !== -1));
            S--
          );
          for (S = S + 1; S < se.list.length; S++) {
            var L = eA(function (re) {
              return _C(re, S).elt
            })
            se.list[S] = L
          }
        }
      }
    }
    var nA = { localName: "BM" }
    function xC(x) {
      if (tn(Q.top, x) && se.indexOf(Q.top) === -1) return Q.pop(), true
      for (var S = 0; S < 8; ) {
        S++
        var L = se.findElementByTag(x)
        if (!L) return false
        var re = Q.elements.lastIndexOf(L)
        if (re === -1) return se.remove(L), true
        if (!Q.elementInScope(L)) return true
        for (var oe = null, Re, st = re + 1; st < Q.elements.length; st++)
          if (tn(Q.elements[st], gp)) {
            ;(oe = Q.elements[st]), (Re = st)
            break
          }
        if (oe) {
          var $t = Q.elements[re - 1]
          se.insertAfter(L, nA)
          for (
            var yn = oe, Ui = oe, lo = Re, kn, ac = 0;
            ac++, (yn = Q.elements[--lo]), yn !== L;

          ) {
            if (
              ((kn = se.indexOf(yn)),
              ac > 3 && kn !== -1 && (se.remove(yn), (kn = -1)),
              kn === -1)
            ) {
              Q.removeElement(yn)
              continue
            }
            var Lo = _C($t.ownerDocument, kn)
            se.replace(yn, Lo.elt, Lo.attrs),
              (Q.elements[lo] = Lo.elt),
              (yn = Lo.elt),
              Ui === oe && (se.remove(nA), se.insertAfter(Lo.elt, nA)),
              yn._appendChild(Ui),
              (Ui = yn)
          }
          ic && tn($t, l0)
            ? tA(function () {
                return Ui
              })
            : $t instanceof en.HTMLTemplateElement
              ? $t.content._appendChild(Ui)
              : $t._appendChild(Ui)
          for (
            var Qf = _C(oe.ownerDocument, se.indexOf(L));
            oe.hasChildNodes();

          )
            Qf.elt._appendChild(oe.firstChild)
          oe._appendChild(Qf.elt),
            se.remove(L),
            se.replace(nA, Qf.elt, Qf.attrs),
            Q.removeElement(L)
          var uS = Q.elements.lastIndexOf(oe)
          Q.elements.splice(uS + 1, 0, Qf.elt)
        } else return Q.popElement(L), se.remove(L), true
      }
      return true
    }
    function Y2() {
      Q.pop(), (U = ce)
    }
    function fd() {
      delete Ge._parser,
        (Q.elements.length = 0),
        Ge.defaultView && Ge.defaultView.dispatchEvent(new en.Event("load", {}))
    }
    function je(x, S) {
      ;(g = S), s--
    }
    function er(x) {
      switch (x) {
        case 38:
          ;(m = er), (g = Ff)
          break
        case 60:
          if (CC()) break
          g = Pw
          break
        case 0:
          ue.push(x), (wr = true)
          break
        case -1:
          It()
          break
        default:
          dd(ILe) || ue.push(x)
          break
      }
    }
    function iu(x) {
      switch (x) {
        case 38:
          ;(m = iu), (g = Ff)
          break
        case 60:
          g = z2
          break
        case 0:
          ue.push(65533), (wr = true)
          break
        case -1:
          It()
          break
        default:
          ue.push(x)
          break
      }
    }
    function Bg(x) {
      switch (x) {
        case 60:
          g = Z2
          break
        case 0:
          ue.push(65533)
          break
        case -1:
          It()
          break
        default:
          dd(l7) || ue.push(x)
          break
      }
    }
    function su(x) {
      switch (x) {
        case 60:
          g = sA
          break
        case 0:
          ue.push(65533)
          break
        case -1:
          It()
          break
        default:
          dd(l7) || ue.push(x)
          break
      }
    }
    function wC(x) {
      switch (x) {
        case 0:
          ue.push(65533)
          break
        case -1:
          It()
          break
        default:
          dd(BLe) || ue.push(x)
          break
      }
    }
    function Pw(x) {
      switch (x) {
        case 33:
          g = hd
          break
        case 47:
          g = K2
          break
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          he(), je(x, Lw)
          break
        case 63:
          je(x, Mf)
          break
        default:
          ue.push(60), je(x, er)
          break
      }
    }
    function K2(x) {
      switch (x) {
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          be(), je(x, Lw)
          break
        case 62:
          g = er
          break
        case -1:
          ue.push(60), ue.push(47), It()
          break
        default:
          je(x, Mf)
          break
      }
    }
    function Lw(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          g = oo
          break
        case 47:
          g = ll
          break
        case 62:
          ;(g = er), ma()
          break
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          v += String.fromCharCode(x + 32)
          break
        case 0:
          v += "\uFFFD"
          break
        case -1:
          It()
          break
        default:
          v += ud(xLe)
          break
      }
    }
    function z2(x) {
      x === 47 ? (_t(), (g = J2)) : (ue.push(60), je(x, iu))
    }
    function J2(x) {
      switch (x) {
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          be(), je(x, j2)
          break
        default:
          ue.push(60), ue.push(47), je(x, iu)
          break
      }
    }
    function j2(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          if (ji(v)) {
            g = oo
            return
          }
          break
        case 47:
          if (ji(v)) {
            g = ll
            return
          }
          break
        case 62:
          if (ji(v)) {
            ;(g = er), ma()
            return
          }
          break
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          ;(v += String.fromCharCode(x + 32)), E.push(x)
          return
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          ;(v += String.fromCharCode(x)), E.push(x)
          return
        default:
          break
      }
      ue.push(60), ue.push(47), fp(ue, E), je(x, iu)
    }
    function Z2(x) {
      x === 47 ? (_t(), (g = iA)) : (ue.push(60), je(x, Bg))
    }
    function iA(x) {
      switch (x) {
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          be(), je(x, X2)
          break
        default:
          ue.push(60), ue.push(47), je(x, Bg)
          break
      }
    }
    function X2(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          if (ji(v)) {
            g = oo
            return
          }
          break
        case 47:
          if (ji(v)) {
            g = ll
            return
          }
          break
        case 62:
          if (ji(v)) {
            ;(g = er), ma()
            return
          }
          break
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          ;(v += String.fromCharCode(x + 32)), E.push(x)
          return
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          ;(v += String.fromCharCode(x)), E.push(x)
          return
        default:
          break
      }
      ue.push(60), ue.push(47), fp(ue, E), je(x, Bg)
    }
    function sA(x) {
      switch (x) {
        case 47:
          _t(), (g = eP)
          break
        case 33:
          ;(g = rP), ue.push(60), ue.push(33)
          break
        default:
          ue.push(60), je(x, su)
          break
      }
    }
    function eP(x) {
      switch (x) {
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          be(), je(x, tP)
          break
        default:
          ue.push(60), ue.push(47), je(x, su)
          break
      }
    }
    function tP(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          if (ji(v)) {
            g = oo
            return
          }
          break
        case 47:
          if (ji(v)) {
            g = ll
            return
          }
          break
        case 62:
          if (ji(v)) {
            ;(g = er), ma()
            return
          }
          break
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          ;(v += String.fromCharCode(x + 32)), E.push(x)
          return
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          ;(v += String.fromCharCode(x)), E.push(x)
          return
        default:
          break
      }
      ue.push(60), ue.push(47), fp(ue, E), je(x, su)
    }
    function rP(x) {
      x === 45 ? ((g = Uw), ue.push(45)) : je(x, su)
    }
    function Uw(x) {
      x === 45 ? ((g = qw), ue.push(45)) : je(x, su)
    }
    function Aa(x) {
      switch (x) {
        case 45:
          ;(g = Ow), ue.push(45)
          break
        case 60:
          g = SC
          break
        case 0:
          ue.push(65533)
          break
        case -1:
          It()
          break
        default:
          ue.push(x)
          break
      }
    }
    function Ow(x) {
      switch (x) {
        case 45:
          ;(g = qw), ue.push(45)
          break
        case 60:
          g = SC
          break
        case 0:
          ;(g = Aa), ue.push(65533)
          break
        case -1:
          It()
          break
        default:
          ;(g = Aa), ue.push(x)
          break
      }
    }
    function qw(x) {
      switch (x) {
        case 45:
          ue.push(45)
          break
        case 60:
          g = SC
          break
        case 62:
          ;(g = su), ue.push(62)
          break
        case 0:
          ;(g = Aa), ue.push(65533)
          break
        case -1:
          It()
          break
        default:
          ;(g = Aa), ue.push(x)
          break
      }
    }
    function SC(x) {
      switch (x) {
        case 47:
          _t(), (g = nP)
          break
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          _t(), ue.push(60), je(x, Vw)
          break
        default:
          ue.push(60), je(x, Aa)
          break
      }
    }
    function nP(x) {
      switch (x) {
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          be(), je(x, iP)
          break
        default:
          ue.push(60), ue.push(47), je(x, Aa)
          break
      }
    }
    function iP(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          if (ji(v)) {
            g = oo
            return
          }
          break
        case 47:
          if (ji(v)) {
            g = ll
            return
          }
          break
        case 62:
          if (ji(v)) {
            ;(g = er), ma()
            return
          }
          break
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          ;(v += String.fromCharCode(x + 32)), E.push(x)
          return
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          ;(v += String.fromCharCode(x)), E.push(x)
          return
        default:
          break
      }
      ue.push(60), ue.push(47), fp(ue, E), je(x, Aa)
    }
    function Vw(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
        case 47:
        case 62:
          Gs(E) === "script" ? (g = sc) : (g = Aa), ue.push(x)
          break
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          E.push(x + 32), ue.push(x)
          break
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          E.push(x), ue.push(x)
          break
        default:
          je(x, Aa)
          break
      }
    }
    function sc(x) {
      switch (x) {
        case 45:
          ;(g = Hw), ue.push(45)
          break
        case 60:
          ;(g = BC), ue.push(60)
          break
        case 0:
          ue.push(65533)
          break
        case -1:
          It()
          break
        default:
          ue.push(x)
          break
      }
    }
    function Hw(x) {
      switch (x) {
        case 45:
          ;(g = IC), ue.push(45)
          break
        case 60:
          ;(g = BC), ue.push(60)
          break
        case 0:
          ;(g = sc), ue.push(65533)
          break
        case -1:
          It()
          break
        default:
          ;(g = sc), ue.push(x)
          break
      }
    }
    function IC(x) {
      switch (x) {
        case 45:
          ue.push(45)
          break
        case 60:
          ;(g = BC), ue.push(60)
          break
        case 62:
          ;(g = su), ue.push(62)
          break
        case 0:
          ;(g = sc), ue.push(65533)
          break
        case -1:
          It()
          break
        default:
          ;(g = sc), ue.push(x)
          break
      }
    }
    function BC(x) {
      x === 47 ? (_t(), (g = Ww), ue.push(47)) : je(x, sc)
    }
    function Ww(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
        case 47:
        case 62:
          Gs(E) === "script" ? (g = Aa) : (g = sc), ue.push(x)
          break
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          E.push(x + 32), ue.push(x)
          break
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
          E.push(x), ue.push(x)
          break
        default:
          je(x, sc)
          break
      }
    }
    function oo(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          break
        case 47:
          g = ll
          break
        case 62:
          ;(g = er), ma()
          break
        case -1:
          It()
          break
        case 61:
          hn(), (w += String.fromCharCode(x)), (g = oA)
          break
        default:
          if (Or()) break
          hn(), je(x, oA)
          break
      }
    }
    function oA(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
        case 47:
        case 62:
        case -1:
          je(x, sP)
          break
        case 61:
          g = RC
          break
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          w += String.fromCharCode(x + 32)
          break
        case 0:
          w += "\uFFFD"
          break
        case 34:
        case 39:
        case 60:
        default:
          w += ud(wLe)
          break
      }
    }
    function sP(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          break
        case 47:
          Ee(w), (g = ll)
          break
        case 61:
          g = RC
          break
        case 62:
          ;(g = er), Ee(w), ma()
          break
        case -1:
          Ee(w), It()
          break
        default:
          Ee(w), hn(), je(x, oA)
          break
      }
    }
    function RC(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          break
        case 34:
          Rn(), (g = Rg)
          break
        case 39:
          Rn(), (g = kf)
          break
        case 62:
        default:
          Rn(), je(x, aA)
          break
      }
    }
    function Rg(x) {
      switch (x) {
        case 34:
          Ee(w, B), (g = lA)
          break
        case 38:
          ;(m = Rg), (g = Ff)
          break
        case 0:
          B += "\uFFFD"
          break
        case -1:
          It()
          break
        case 10:
          B += String.fromCharCode(x)
          break
        default:
          B += ud(bLe)
          break
      }
    }
    function kf(x) {
      switch (x) {
        case 39:
          Ee(w, B), (g = lA)
          break
        case 38:
          ;(m = kf), (g = Ff)
          break
        case 0:
          B += "\uFFFD"
          break
        case -1:
          It()
          break
        case 10:
          B += String.fromCharCode(x)
          break
        default:
          B += ud(ELe)
          break
      }
    }
    function aA(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          Ee(w, B), (g = oo)
          break
        case 38:
          ;(m = aA), (g = Ff)
          break
        case 62:
          Ee(w, B), (g = er), ma()
          break
        case 0:
          B += "\uFFFD"
          break
        case -1:
          s--, (g = er)
          break
        case 34:
        case 39:
        case 60:
        case 61:
        case 96:
        default:
          B += ud(_Le)
          break
      }
    }
    function lA(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          g = oo
          break
        case 47:
          g = ll
          break
        case 62:
          ;(g = er), ma()
          break
        case -1:
          It()
          break
        default:
          je(x, oo)
          break
      }
    }
    function ll(x) {
      switch (x) {
        case 62:
          ;(g = er), bC(true)
          break
        case -1:
          It()
          break
        default:
          je(x, oo)
          break
      }
    }
    function Mf(x, S, L) {
      var re = S.length
      L ? (s += re - 1) : (s += re)
      var oe = S.substring(0, re - 1)
      ;(oe = oe.replace(/\u0000/g, "\uFFFD")),
        (oe = oe.replace(
          /\u000D\u000A/g,
          `
`,
        )),
        (oe = oe.replace(
          /\u000D/g,
          `
`,
        )),
        Dn(Au, oe),
        (g = er)
    }
    Mf.lookahead = ">"
    function hd(x, S, L) {
      if (S[0] === "-" && S[1] === "-") {
        ;(s += 2), Ii(), (g = Gw)
        return
      }
      S.toUpperCase() === "DOCTYPE"
        ? ((s += 7), (g = jw))
        : S === "[CDATA[" && G2()
          ? ((s += 7), (g = MC))
          : (g = Mf)
    }
    hd.lookahead = 7
    function Gw(x) {
      switch ((Ii(), x)) {
        case 45:
          g = $w
          break
        case 62:
          ;(g = er), Dn(Au, Gs(T))
          break
        default:
          je(x, gd)
          break
      }
    }
    function $w(x) {
      switch (x) {
        case 45:
          g = cA
          break
        case 62:
          ;(g = er), Dn(Au, Gs(T))
          break
        case -1:
          Dn(Au, Gs(T)), It()
          break
        default:
          T.push(45), je(x, gd)
          break
      }
    }
    function gd(x) {
      switch (x) {
        case 60:
          T.push(x), (g = Yw)
          break
        case 45:
          g = DC
          break
        case 0:
          T.push(65533)
          break
        case -1:
          Dn(Au, Gs(T)), It()
          break
        default:
          T.push(x)
          break
      }
    }
    function Yw(x) {
      switch (x) {
        case 33:
          T.push(x), (g = Kw)
          break
        case 60:
          T.push(x)
          break
        default:
          je(x, gd)
          break
      }
    }
    function Kw(x) {
      switch (x) {
        case 45:
          g = zw
          break
        default:
          je(x, gd)
          break
      }
    }
    function zw(x) {
      switch (x) {
        case 45:
          g = Jw
          break
        default:
          je(x, DC)
          break
      }
    }
    function Jw(x) {
      switch (x) {
        case 62:
        case -1:
          je(x, cA)
          break
        default:
          je(x, cA)
          break
      }
    }
    function DC(x) {
      switch (x) {
        case 45:
          g = cA
          break
        case -1:
          Dn(Au, Gs(T)), It()
          break
        default:
          T.push(45), je(x, gd)
          break
      }
    }
    function cA(x) {
      switch (x) {
        case 62:
          ;(g = er), Dn(Au, Gs(T))
          break
        case 33:
          g = oP
          break
        case 45:
          T.push(45)
          break
        case -1:
          Dn(Au, Gs(T)), It()
          break
        default:
          T.push(45), T.push(45), je(x, gd)
          break
      }
    }
    function oP(x) {
      switch (x) {
        case 45:
          T.push(45), T.push(45), T.push(33), (g = DC)
          break
        case 62:
          ;(g = er), Dn(Au, Gs(T))
          break
        case -1:
          Dn(Au, Gs(T)), It()
          break
        default:
          T.push(45), T.push(45), T.push(33), je(x, gd)
          break
      }
    }
    function jw(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          g = Zw
          break
        case -1:
          so(), ar(), _r(), It()
          break
        default:
          je(x, Zw)
          break
      }
    }
    function Zw(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          break
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          so(), N.push(x + 32), (g = TC)
          break
        case 0:
          so(), N.push(65533), (g = TC)
          break
        case 62:
          so(), ar(), (g = er), _r()
          break
        case -1:
          so(), ar(), _r(), It()
          break
        default:
          so(), N.push(x), (g = TC)
          break
      }
    }
    function TC(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          g = Xw
          break
        case 62:
          ;(g = er), _r()
          break
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          N.push(x + 32)
          break
        case 0:
          N.push(65533)
          break
        case -1:
          ar(), _r(), It()
          break
        default:
          N.push(x)
          break
      }
    }
    function Xw(x, S, L) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          s += 1
          break
        case 62:
          ;(g = er), (s += 1), _r()
          break
        case -1:
          ar(), _r(), It()
          break
        default:
          ;(S = S.toUpperCase()),
            S === "PUBLIC"
              ? ((s += 6), (g = aP))
              : S === "SYSTEM"
                ? ((s += 6), (g = cP))
                : (ar(), (g = ou))
          break
      }
    }
    Xw.lookahead = 6
    function aP(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          g = kC
          break
        case 34:
          cd(), (g = eS)
          break
        case 39:
          cd(), (g = tS)
          break
        case 62:
          ar(), (g = er), _r()
          break
        case -1:
          ar(), _r(), It()
          break
        default:
          ar(), (g = ou)
          break
      }
    }
    function kC(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          break
        case 34:
          cd(), (g = eS)
          break
        case 39:
          cd(), (g = tS)
          break
        case 62:
          ar(), (g = er), _r()
          break
        case -1:
          ar(), _r(), It()
          break
        default:
          ar(), (g = ou)
          break
      }
    }
    function eS(x) {
      switch (x) {
        case 34:
          g = rS
          break
        case 0:
          W.push(65533)
          break
        case 62:
          ar(), (g = er), _r()
          break
        case -1:
          ar(), _r(), It()
          break
        default:
          W.push(x)
          break
      }
    }
    function tS(x) {
      switch (x) {
        case 39:
          g = rS
          break
        case 0:
          W.push(65533)
          break
        case 62:
          ar(), (g = er), _r()
          break
        case -1:
          ar(), _r(), It()
          break
        default:
          W.push(x)
          break
      }
    }
    function rS(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          g = lP
          break
        case 62:
          ;(g = er), _r()
          break
        case 34:
          nu(), (g = $r)
          break
        case 39:
          nu(), (g = uA)
          break
        case -1:
          ar(), _r(), It()
          break
        default:
          ar(), (g = ou)
          break
      }
    }
    function lP(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          break
        case 62:
          ;(g = er), _r()
          break
        case 34:
          nu(), (g = $r)
          break
        case 39:
          nu(), (g = uA)
          break
        case -1:
          ar(), _r(), It()
          break
        default:
          ar(), (g = ou)
          break
      }
    }
    function cP(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          g = An
          break
        case 34:
          nu(), (g = $r)
          break
        case 39:
          nu(), (g = uA)
          break
        case 62:
          ar(), (g = er), _r()
          break
        case -1:
          ar(), _r(), It()
          break
        default:
          ar(), (g = ou)
          break
      }
    }
    function An(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          break
        case 34:
          nu(), (g = $r)
          break
        case 39:
          nu(), (g = uA)
          break
        case 62:
          ar(), (g = er), _r()
          break
        case -1:
          ar(), _r(), It()
          break
        default:
          ar(), (g = ou)
          break
      }
    }
    function $r(x) {
      switch (x) {
        case 34:
          g = nS
          break
        case 0:
          Z.push(65533)
          break
        case 62:
          ar(), (g = er), _r()
          break
        case -1:
          ar(), _r(), It()
          break
        default:
          Z.push(x)
          break
      }
    }
    function uA(x) {
      switch (x) {
        case 39:
          g = nS
          break
        case 0:
          Z.push(65533)
          break
        case 62:
          ar(), (g = er), _r()
          break
        case -1:
          ar(), _r(), It()
          break
        default:
          Z.push(x)
          break
      }
    }
    function nS(x) {
      switch (x) {
        case 9:
        case 10:
        case 12:
        case 32:
          break
        case 62:
          ;(g = er), _r()
          break
        case -1:
          ar(), _r(), It()
          break
        default:
          g = ou
          break
      }
    }
    function ou(x) {
      switch (x) {
        case 62:
          ;(g = er), _r()
          break
        case -1:
          _r(), It()
          break
        default:
          break
      }
    }
    function MC(x) {
      switch (x) {
        case 93:
          g = uP
          break
        case -1:
          It()
          break
        case 0:
          wr = true
        default:
          dd(SLe) || ue.push(x)
          break
      }
    }
    function uP(x) {
      switch (x) {
        case 93:
          g = dP
          break
        default:
          ue.push(93), je(x, MC)
          break
      }
    }
    function dP(x) {
      switch (x) {
        case 93:
          ue.push(93)
          break
        case 62:
          pa(), (g = er)
          break
        default:
          ue.push(93), ue.push(93), je(x, MC)
          break
      }
    }
    function Ff(x) {
      switch ((_t(), E.push(38), x)) {
        case 9:
        case 10:
        case 12:
        case 32:
        case 60:
        case 38:
        case -1:
          je(x, au)
          break
        case 35:
          E.push(x), (g = Bi)
          break
        default:
          je(x, iS)
          break
      }
    }
    function iS(x) {
      a7.lastIndex = s
      var S = a7.exec(n)
      if (!S) throw new Error("should never happen")
      var L = S[1]
      if (!L) {
        g = au
        return
      }
      switch (((s += L.length), fp(E, DLe(L)), m)) {
        case Rg:
        case kf:
        case aA:
          if (L[L.length - 1] !== ";" && /[=A-Za-z0-9]/.test(n[s])) {
            g = au
            return
          }
          break
        default:
          break
      }
      _t()
      var re = vLe[L]
      typeof re == "number" ? E.push(re) : fp(E, re), (g = au)
    }
    iS.lookahead = -CLe
    function Bi(x) {
      switch (((y = 0), x)) {
        case 120:
        case 88:
          E.push(x), (g = FC)
          break
        default:
          je(x, pd)
          break
      }
    }
    function FC(x) {
      switch (x) {
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
          je(x, sS)
          break
        default:
          je(x, au)
          break
      }
    }
    function pd(x) {
      switch (x) {
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          je(x, QC)
          break
        default:
          je(x, au)
          break
      }
    }
    function sS(x) {
      switch (x) {
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
          ;(y *= 16), (y += x - 55)
          break
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
          ;(y *= 16), (y += x - 87)
          break
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          ;(y *= 16), (y += x - 48)
          break
        case 59:
          g = ys
          break
        default:
          je(x, ys)
          break
      }
    }
    function QC(x) {
      switch (x) {
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          ;(y *= 10), (y += x - 48)
          break
        case 59:
          g = ys
          break
        default:
          je(x, ys)
          break
      }
    }
    function ys(x) {
      y in o7
        ? (y = o7[y])
        : (y > 1114111 || (y >= 55296 && y < 57344)) && (y = 65533),
        _t(),
        y <= 65535
          ? E.push(y)
          : ((y = y - 65536),
            E.push(55296 + (y >> 10)),
            E.push(56320 + (y & 1023))),
        je(x, au)
    }
    function au(x) {
      switch (m) {
        case Rg:
        case kf:
        case aA:
          B += Gs(E)
          break
        default:
          fp(ue, E)
          break
      }
      je(x, m)
    }
    function oS(x, S, L, re) {
      switch (x) {
        case 1:
          if (((S = S.replace(hp, "")), S.length === 0)) return
          break
        case 4:
          Ge._appendChild(Ge.createComment(S))
          return
        case 5:
          var oe = S,
            Re = L,
            st = re
          Ge.appendChild(new fLe(Ge, oe, Re, st)),
            Mt ||
            oe.toLowerCase() !== "html" ||
            pLe.test(Re) ||
            (st && st.toLowerCase() === mLe) ||
            (st === undefined && r7.test(Re))
              ? (Ge._quirks = true)
              : (ALe.test(Re) || (st !== undefined && r7.test(Re))) &&
                (Ge._limitedQuirks = true),
            (U = NC)
          return
      }
      ;(Ge._quirks = true), (U = NC), U(x, S, L, re)
    }
    function NC(x, S, L, re) {
      var oe
      switch (x) {
        case 1:
          if (((S = S.replace(hp, "")), S.length === 0)) return
          break
        case 5:
          return
        case 4:
          Ge._appendChild(Ge.createComment(S))
          return
        case 2:
          if (S === "html") {
            ;(oe = Ig(Ge, S, L)), Q.push(oe), Ge.appendChild(oe), (U = Dg)
            return
          }
          break
        case 3:
          switch (S) {
            case "html":
            case "head":
            case "body":
            case "br":
              break
            default:
              return
          }
      }
      ;(oe = Ig(Ge, "html", null)),
        Q.push(oe),
        Ge.appendChild(oe),
        (U = Dg),
        U(x, S, L, re)
    }
    function Dg(x, S, L, re) {
      switch (x) {
        case 1:
          if (((S = S.replace(hp, "")), S.length === 0)) return
          break
        case 5:
          return
        case 4:
          ol(S)
          return
        case 2:
          switch (S) {
            case "html":
              it(x, S, L, re)
              return
            case "head":
              var oe = bt(S, L)
              ;(ie = oe), (U = Tn)
              return
          }
          break
        case 3:
          switch (S) {
            case "html":
            case "head":
            case "body":
            case "br":
              break
            default:
              return
          }
      }
      Dg(Ws, "head", null), U(x, S, L, re)
    }
    function Tn(x, S, L, re) {
      switch (x) {
        case 1:
          var oe = S.match(hp)
          if (
            (oe && (al(oe[0]), (S = S.substring(oe[0].length))), S.length === 0)
          )
            return
          break
        case 4:
          ol(S)
          return
        case 5:
          return
        case 2:
          switch (S) {
            case "html":
              it(x, S, L, re)
              return
            case "meta":
            case "base":
            case "basefont":
            case "bgsound":
            case "link":
              bt(S, L), Q.pop()
              return
            case "title":
              $2(S, L)
              return
            case "noscript":
              if (!At) {
                bt(S, L), (U = PC)
                return
              }
            case "noframes":
            case "style":
              rA(S, L)
              return
            case "script":
              eA(function (Re) {
                var st = Ig(Re, S, L)
                return (
                  (st._parser_inserted = true),
                  (st._force_async = false),
                  J && (st._already_started = true),
                  pa(),
                  st
                )
              }),
                (g = su),
                (ce = U),
                (U = Cs)
              return
            case "template":
              bt(S, L), se.insertMarker(), (ve = false), (U = Tg), Ie.push(U)
              return
            case "head":
              return
          }
          break
        case 3:
          switch (S) {
            case "head":
              Q.pop(), (U = vs)
              return
            case "body":
            case "html":
            case "br":
              break
            case "template":
              if (!Q.contains("template")) return
              Q.generateImpliedEndTags(null, "thorough"),
                Q.popTag("template"),
                se.clearToMarker(),
                Ie.pop(),
                Tf()
              return
            default:
              return
          }
          break
      }
      Tn(ur, "head", null), U(x, S, L, re)
    }
    function PC(x, S, L, re) {
      switch (x) {
        case 5:
          return
        case 4:
          Tn(x, S)
          return
        case 1:
          var oe = S.match(hp)
          if (
            (oe && (Tn(x, oe[0]), (S = S.substring(oe[0].length))),
            S.length === 0)
          )
            return
          break
        case 2:
          switch (S) {
            case "html":
              it(x, S, L, re)
              return
            case "basefont":
            case "bgsound":
            case "link":
            case "meta":
            case "noframes":
            case "style":
              Tn(x, S, L)
              return
            case "head":
            case "noscript":
              return
          }
          break
        case 3:
          switch (S) {
            case "noscript":
              Q.pop(), (U = Tn)
              return
            case "br":
              break
            default:
              return
          }
          break
      }
      PC(ur, "noscript", null), U(x, S, L, re)
    }
    function vs(x, S, L, re) {
      switch (x) {
        case 1:
          var oe = S.match(hp)
          if (
            (oe && (al(oe[0]), (S = S.substring(oe[0].length))), S.length === 0)
          )
            return
          break
        case 4:
          ol(S)
          return
        case 5:
          return
        case 2:
          switch (S) {
            case "html":
              it(x, S, L, re)
              return
            case "body":
              bt(S, L), (ve = false), (U = it)
              return
            case "frameset":
              bt(S, L), (U = LC)
              return
            case "base":
            case "basefont":
            case "bgsound":
            case "link":
            case "meta":
            case "noframes":
            case "script":
            case "style":
            case "template":
            case "title":
              Q.push(ie), Tn(Ws, S, L), Q.removeElement(ie)
              return
            case "head":
              return
          }
          break
        case 3:
          switch (S) {
            case "template":
              return Tn(x, S, L, re)
            case "body":
            case "html":
            case "br":
              break
            default:
              return
          }
          break
      }
      vs(Ws, "body", null), (ve = true), U(x, S, L, re)
    }
    function it(x, S, L, re) {
      var oe, Re, st, $t
      switch (x) {
        case 1:
          if (wr && ((S = S.replace(yB, "")), S.length === 0)) return
          ve && AB.test(S) && (ve = false), Li(), al(S)
          return
        case 5:
          return
        case 4:
          ol(S)
          return
        case -1:
          if (Ie.length) return Tg(x)
          fd()
          return
        case 2:
          switch (S) {
            case "html":
              if (Q.contains("template")) return
              p7(L, Q.elements[0])
              return
            case "base":
            case "basefont":
            case "bgsound":
            case "link":
            case "meta":
            case "noframes":
            case "script":
            case "style":
            case "template":
            case "title":
              Tn(Ws, S, L)
              return
            case "body":
              if (
                ((oe = Q.elements[1]),
                !oe ||
                  !(oe instanceof en.HTMLBodyElement) ||
                  Q.contains("template"))
              )
                return
              ;(ve = false), p7(L, oe)
              return
            case "frameset":
              if (
                !ve ||
                ((oe = Q.elements[1]),
                !oe || !(oe instanceof en.HTMLBodyElement))
              )
                return
              for (
                oe.parentNode && oe.parentNode.removeChild(oe);
                !(Q.top instanceof en.HTMLHtmlElement);

              )
                Q.pop()
              bt(S, L), (U = LC)
              return
            case "address":
            case "article":
            case "aside":
            case "blockquote":
            case "center":
            case "details":
            case "dialog":
            case "dir":
            case "div":
            case "dl":
            case "fieldset":
            case "figcaption":
            case "figure":
            case "footer":
            case "header":
            case "hgroup":
            case "main":
            case "nav":
            case "ol":
            case "p":
            case "section":
            case "summary":
            case "ul":
              Q.inButtonScope("p") && it(ur, "p"), bt(S, L)
              return
            case "menu":
              Q.inButtonScope("p") && it(ur, "p"),
                tn(Q.top, "menuitem") && Q.pop(),
                bt(S, L)
              return
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              Q.inButtonScope("p") && it(ur, "p"),
                Q.top instanceof en.HTMLHeadingElement && Q.pop(),
                bt(S, L)
              return
            case "pre":
            case "listing":
              Q.inButtonScope("p") && it(ur, "p"),
                bt(S, L),
                (or = true),
                (ve = false)
              return
            case "form":
              if (Ue && !Q.contains("template")) return
              Q.inButtonScope("p") && it(ur, "p"),
                ($t = bt(S, L)),
                Q.contains("template") || (Ue = $t)
              return
            case "li":
              for (ve = false, Re = Q.elements.length - 1; Re >= 0; Re--) {
                if (((st = Q.elements[Re]), st instanceof en.HTMLLIElement)) {
                  it(ur, "li")
                  break
                }
                if (tn(st, gp) && !tn(st, aO)) break
              }
              Q.inButtonScope("p") && it(ur, "p"), bt(S, L)
              return
            case "dd":
            case "dt":
              for (ve = false, Re = Q.elements.length - 1; Re >= 0; Re--) {
                if (((st = Q.elements[Re]), tn(st, A7))) {
                  it(ur, st.localName)
                  break
                }
                if (tn(st, gp) && !tn(st, aO)) break
              }
              Q.inButtonScope("p") && it(ur, "p"), bt(S, L)
              return
            case "plaintext":
              Q.inButtonScope("p") && it(ur, "p"), bt(S, L), (g = wC)
              return
            case "button":
              Q.inScope("button")
                ? (it(ur, "button"), U(x, S, L, re))
                : (Li(), bt(S, L), (ve = false))
              return
            case "a":
              var yn = se.findElementByTag("a")
              yn && (it(ur, S), se.remove(yn), Q.removeElement(yn))
            case "b":
            case "big":
            case "code":
            case "em":
            case "font":
            case "i":
            case "s":
            case "small":
            case "strike":
            case "strong":
            case "tt":
            case "u":
              Li(), se.push(bt(S, L), L)
              return
            case "nobr":
              Li(), Q.inScope(S) && (it(ur, S), Li()), se.push(bt(S, L), L)
              return
            case "applet":
            case "marquee":
            case "object":
              Li(), bt(S, L), se.insertMarker(), (ve = false)
              return
            case "table":
              !Ge._quirks && Q.inButtonScope("p") && it(ur, "p"),
                bt(S, L),
                (ve = false),
                (U = Po)
              return
            case "area":
            case "br":
            case "embed":
            case "img":
            case "keygen":
            case "wbr":
              Li(), bt(S, L), Q.pop(), (ve = false)
              return
            case "input":
              Li(), ($t = bt(S, L)), Q.pop()
              var Ui = $t.getAttribute("type")
              ;(!Ui || Ui.toLowerCase() !== "hidden") && (ve = false)
              return
            case "param":
            case "source":
            case "track":
              bt(S, L), Q.pop()
              return
            case "hr":
              Q.inButtonScope("p") && it(ur, "p"),
                tn(Q.top, "menuitem") && Q.pop(),
                bt(S, L),
                Q.pop(),
                (ve = false)
              return
            case "image":
              it(Ws, "img", L, re)
              return
            case "textarea":
              bt(S, L), (or = true), (ve = false), (g = iu), (ce = U), (U = Cs)
              return
            case "xmp":
              Q.inButtonScope("p") && it(ur, "p"), Li(), (ve = false), rA(S, L)
              return
            case "iframe":
              ;(ve = false), rA(S, L)
              return
            case "noembed":
              rA(S, L)
              return
            case "select":
              Li(),
                bt(S, L),
                (ve = false),
                U === Po || U === cl || U === oc || U === Zr || U === ao
                  ? (U = dA)
                  : (U = ya)
              return
            case "optgroup":
            case "option":
              Q.top instanceof en.HTMLOptionElement && it(ur, "option"),
                Li(),
                bt(S, L)
              return
            case "menuitem":
              tn(Q.top, "menuitem") && Q.pop(), Li(), bt(S, L)
              return
            case "rb":
            case "rtc":
              Q.inScope("ruby") && Q.generateImpliedEndTags(), bt(S, L)
              return
            case "rp":
            case "rt":
              Q.inScope("ruby") && Q.generateImpliedEndTags("rtc"), bt(S, L)
              return
            case "math":
              Li(), g7(L), oO(L), EC(S, L, lt.MATHML), re && Q.pop()
              return
            case "svg":
              Li(), h7(L), oO(L), EC(S, L, lt.SVG), re && Q.pop()
              return
            case "caption":
            case "col":
            case "colgroup":
            case "frame":
            case "head":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return
          }
          Li(), bt(S, L)
          return
        case 3:
          switch (S) {
            case "template":
              Tn(ur, S, L)
              return
            case "body":
              if (!Q.inScope("body")) return
              U = lS
              return
            case "html":
              if (!Q.inScope("body")) return
              ;(U = lS), U(x, S, L)
              return
            case "address":
            case "article":
            case "aside":
            case "blockquote":
            case "button":
            case "center":
            case "details":
            case "dialog":
            case "dir":
            case "div":
            case "dl":
            case "fieldset":
            case "figcaption":
            case "figure":
            case "footer":
            case "header":
            case "hgroup":
            case "listing":
            case "main":
            case "menu":
            case "nav":
            case "ol":
            case "pre":
            case "section":
            case "summary":
            case "ul":
              if (!Q.inScope(S)) return
              Q.generateImpliedEndTags(), Q.popTag(S)
              return
            case "form":
              if (Q.contains("template")) {
                if (!Q.inScope("form")) return
                Q.generateImpliedEndTags(), Q.popTag("form")
              } else {
                var lo = Ue
                if (((Ue = null), !lo || !Q.elementInScope(lo))) return
                Q.generateImpliedEndTags(), Q.removeElement(lo)
              }
              return
            case "p":
              Q.inButtonScope(S)
                ? (Q.generateImpliedEndTags(S), Q.popTag(S))
                : (it(Ws, S, null), U(x, S, L, re))
              return
            case "li":
              if (!Q.inListItemScope(S)) return
              Q.generateImpliedEndTags(S), Q.popTag(S)
              return
            case "dd":
            case "dt":
              if (!Q.inScope(S)) return
              Q.generateImpliedEndTags(S), Q.popTag(S)
              return
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              if (!Q.elementTypeInScope(en.HTMLHeadingElement)) return
              Q.generateImpliedEndTags(),
                Q.popElementType(en.HTMLHeadingElement)
              return
            case "sarcasm":
              break
            case "a":
            case "b":
            case "big":
            case "code":
            case "em":
            case "font":
            case "i":
            case "nobr":
            case "s":
            case "small":
            case "strike":
            case "strong":
            case "tt":
            case "u":
              var kn = xC(S)
              if (kn) return
              break
            case "applet":
            case "marquee":
            case "object":
              if (!Q.inScope(S)) return
              Q.generateImpliedEndTags(), Q.popTag(S), se.clearToMarker()
              return
            case "br":
              it(Ws, S, null)
              return
          }
          for (Re = Q.elements.length - 1; Re >= 0; Re--)
            if (((st = Q.elements[Re]), tn(st, S))) {
              Q.generateImpliedEndTags(S), Q.popElement(st)
              break
            } else if (tn(st, gp)) return
          return
      }
    }
    function Cs(x, S, L, re) {
      switch (x) {
        case 1:
          al(S)
          return
        case -1:
          Q.top instanceof en.HTMLScriptElement &&
            (Q.top._already_started = true),
            Q.pop(),
            (U = ce),
            U(x)
          return
        case 3:
          S === "script" ? Y2() : (Q.pop(), (U = ce))
          return
        default:
          return
      }
    }
    function Po(x, S, L, re) {
      function oe(st) {
        for (var $t = 0, yn = st.length; $t < yn; $t++)
          if (st[$t][0] === "type") return st[$t][1].toLowerCase()
        return null
      }
      switch (x) {
        case 1:
          if (rr) {
            it(x, S, L, re)
            return
          } else if (tn(Q.top, l0)) {
            ;(Xt = []), (ce = U), (U = aS), U(x, S, L, re)
            return
          }
          break
        case 4:
          ol(S)
          return
        case 5:
          return
        case 2:
          switch (S) {
            case "caption":
              Q.clearToContext(vB), se.insertMarker(), bt(S, L), (U = cl)
              return
            case "colgroup":
              Q.clearToContext(vB), bt(S, L), (U = md)
              return
            case "col":
              Po(Ws, "colgroup", null), U(x, S, L, re)
              return
            case "tbody":
            case "tfoot":
            case "thead":
              Q.clearToContext(vB), bt(S, L), (U = oc)
              return
            case "td":
            case "th":
            case "tr":
              Po(Ws, "tbody", null), U(x, S, L, re)
              return
            case "table":
              if (!Q.inTableScope(S)) return
              Po(ur, S), U(x, S, L, re)
              return
            case "style":
            case "script":
            case "template":
              Tn(x, S, L, re)
              return
            case "input":
              var Re = oe(L)
              if (Re !== "hidden") break
              bt(S, L), Q.pop()
              return
            case "form":
              if (Ue || Q.contains("template")) return
              ;(Ue = bt(S, L)), Q.popElement(Ue)
              return
          }
          break
        case 3:
          switch (S) {
            case "table":
              if (!Q.inTableScope(S)) return
              Q.popTag(S), Tf()
              return
            case "body":
            case "caption":
            case "col":
            case "colgroup":
            case "html":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return
            case "template":
              Tn(x, S, L, re)
              return
          }
          break
        case -1:
          it(x, S, L, re)
          return
      }
      ;(ic = true), it(x, S, L, re), (ic = false)
    }
    function aS(x, S, L, re) {
      if (x === a0) {
        if (wr && ((S = S.replace(yB, "")), S.length === 0)) return
        Xt.push(S)
      } else {
        var oe = Xt.join("")
        ;(Xt.length = 0),
          AB.test(oe) ? ((ic = true), it(a0, oe), (ic = false)) : al(oe),
          (U = ce),
          U(x, S, L, re)
      }
    }
    function cl(x, S, L, re) {
      function oe() {
        return Q.inTableScope("caption")
          ? (Q.generateImpliedEndTags(),
            Q.popTag("caption"),
            se.clearToMarker(),
            (U = Po),
            true)
          : false
      }
      switch (x) {
        case 2:
          switch (S) {
            case "caption":
            case "col":
            case "colgroup":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              oe() && U(x, S, L, re)
              return
          }
          break
        case 3:
          switch (S) {
            case "caption":
              oe()
              return
            case "table":
              oe() && U(x, S, L, re)
              return
            case "body":
            case "col":
            case "colgroup":
            case "html":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return
          }
          break
      }
      it(x, S, L, re)
    }
    function md(x, S, L, re) {
      switch (x) {
        case 1:
          var oe = S.match(hp)
          if (
            (oe && (al(oe[0]), (S = S.substring(oe[0].length))), S.length === 0)
          )
            return
          break
        case 4:
          ol(S)
          return
        case 5:
          return
        case 2:
          switch (S) {
            case "html":
              it(x, S, L, re)
              return
            case "col":
              bt(S, L), Q.pop()
              return
            case "template":
              Tn(x, S, L, re)
              return
          }
          break
        case 3:
          switch (S) {
            case "colgroup":
              if (!tn(Q.top, "colgroup")) return
              Q.pop(), (U = Po)
              return
            case "col":
              return
            case "template":
              Tn(x, S, L, re)
              return
          }
          break
        case -1:
          it(x, S, L, re)
          return
      }
      tn(Q.top, "colgroup") && (md(ur, "colgroup"), U(x, S, L, re))
    }
    function oc(x, S, L, re) {
      function oe() {
        ;(!Q.inTableScope("tbody") &&
          !Q.inTableScope("thead") &&
          !Q.inTableScope("tfoot")) ||
          (Q.clearToContext(CB), oc(ur, Q.top.localName, null), U(x, S, L, re))
      }
      switch (x) {
        case 2:
          switch (S) {
            case "tr":
              Q.clearToContext(CB), bt(S, L), (U = Zr)
              return
            case "th":
            case "td":
              oc(Ws, "tr", null), U(x, S, L, re)
              return
            case "caption":
            case "col":
            case "colgroup":
            case "tbody":
            case "tfoot":
            case "thead":
              oe()
              return
          }
          break
        case 3:
          switch (S) {
            case "table":
              oe()
              return
            case "tbody":
            case "tfoot":
            case "thead":
              Q.inTableScope(S) && (Q.clearToContext(CB), Q.pop(), (U = Po))
              return
            case "body":
            case "caption":
            case "col":
            case "colgroup":
            case "html":
            case "td":
            case "th":
            case "tr":
              return
          }
          break
      }
      Po(x, S, L, re)
    }
    function Zr(x, S, L, re) {
      function oe() {
        return Q.inTableScope("tr")
          ? (Q.clearToContext(lO), Q.pop(), (U = oc), true)
          : false
      }
      switch (x) {
        case 2:
          switch (S) {
            case "th":
            case "td":
              Q.clearToContext(lO), bt(S, L), (U = ao), se.insertMarker()
              return
            case "caption":
            case "col":
            case "colgroup":
            case "tbody":
            case "tfoot":
            case "thead":
            case "tr":
              oe() && U(x, S, L, re)
              return
          }
          break
        case 3:
          switch (S) {
            case "tr":
              oe()
              return
            case "table":
              oe() && U(x, S, L, re)
              return
            case "tbody":
            case "tfoot":
            case "thead":
              Q.inTableScope(S) && oe() && U(x, S, L, re)
              return
            case "body":
            case "caption":
            case "col":
            case "colgroup":
            case "html":
            case "td":
            case "th":
              return
          }
          break
      }
      Po(x, S, L, re)
    }
    function ao(x, S, L, re) {
      switch (x) {
        case 2:
          switch (S) {
            case "caption":
            case "col":
            case "colgroup":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              Q.inTableScope("td")
                ? (ao(ur, "td"), U(x, S, L, re))
                : Q.inTableScope("th") && (ao(ur, "th"), U(x, S, L, re))
              return
          }
          break
        case 3:
          switch (S) {
            case "td":
            case "th":
              if (!Q.inTableScope(S)) return
              Q.generateImpliedEndTags(),
                Q.popTag(S),
                se.clearToMarker(),
                (U = Zr)
              return
            case "body":
            case "caption":
            case "col":
            case "colgroup":
            case "html":
              return
            case "table":
            case "tbody":
            case "tfoot":
            case "thead":
            case "tr":
              if (!Q.inTableScope(S)) return
              ao(ur, Q.inTableScope("td") ? "td" : "th"), U(x, S, L, re)
              return
          }
          break
      }
      it(x, S, L, re)
    }
    function ya(x, S, L, re) {
      switch (x) {
        case 1:
          if (wr && ((S = S.replace(yB, "")), S.length === 0)) return
          al(S)
          return
        case 4:
          ol(S)
          return
        case 5:
          return
        case -1:
          it(x, S, L, re)
          return
        case 2:
          switch (S) {
            case "html":
              it(x, S, L, re)
              return
            case "option":
              Q.top instanceof en.HTMLOptionElement && ya(ur, S), bt(S, L)
              return
            case "optgroup":
              Q.top instanceof en.HTMLOptionElement && ya(ur, "option"),
                Q.top instanceof en.HTMLOptGroupElement && ya(ur, S),
                bt(S, L)
              return
            case "select":
              ya(ur, S)
              return
            case "input":
            case "keygen":
            case "textarea":
              if (!Q.inSelectScope("select")) return
              ya(ur, "select"), U(x, S, L, re)
              return
            case "script":
            case "template":
              Tn(x, S, L, re)
              return
          }
          break
        case 3:
          switch (S) {
            case "optgroup":
              Q.top instanceof en.HTMLOptionElement &&
                Q.elements[Q.elements.length - 2] instanceof
                  en.HTMLOptGroupElement &&
                ya(ur, "option"),
                Q.top instanceof en.HTMLOptGroupElement && Q.pop()
              return
            case "option":
              Q.top instanceof en.HTMLOptionElement && Q.pop()
              return
            case "select":
              if (!Q.inSelectScope(S)) return
              Q.popTag(S), Tf()
              return
            case "template":
              Tn(x, S, L, re)
              return
          }
          break
      }
    }
    function dA(x, S, L, re) {
      switch (S) {
        case "caption":
        case "table":
        case "tbody":
        case "tfoot":
        case "thead":
        case "tr":
        case "td":
        case "th":
          switch (x) {
            case 2:
              dA(ur, "select"), U(x, S, L, re)
              return
            case 3:
              Q.inTableScope(S) && (dA(ur, "select"), U(x, S, L, re))
              return
          }
      }
      ya(x, S, L, re)
    }
    function Tg(x, S, L, re) {
      function oe(Re) {
        ;(U = Re), (Ie[Ie.length - 1] = U), U(x, S, L, re)
      }
      switch (x) {
        case 1:
        case 4:
        case 5:
          it(x, S, L, re)
          return
        case -1:
          Q.contains("template")
            ? (Q.popTag("template"),
              se.clearToMarker(),
              Ie.pop(),
              Tf(),
              U(x, S, L, re))
            : fd()
          return
        case 2:
          switch (S) {
            case "base":
            case "basefont":
            case "bgsound":
            case "link":
            case "meta":
            case "noframes":
            case "script":
            case "style":
            case "template":
            case "title":
              Tn(x, S, L, re)
              return
            case "caption":
            case "colgroup":
            case "tbody":
            case "tfoot":
            case "thead":
              oe(Po)
              return
            case "col":
              oe(md)
              return
            case "tr":
              oe(oc)
              return
            case "td":
            case "th":
              oe(Zr)
              return
          }
          oe(it)
          return
        case 3:
          switch (S) {
            case "template":
              Tn(x, S, L, re)
              return
            default:
              return
          }
      }
    }
    function lS(x, S, L, re) {
      switch (x) {
        case 1:
          if (AB.test(S)) break
          it(x, S)
          return
        case 4:
          Q.elements[0]._appendChild(Ge.createComment(S))
          return
        case 5:
          return
        case -1:
          fd()
          return
        case 2:
          if (S === "html") {
            it(x, S, L, re)
            return
          }
          break
        case 3:
          if (S === "html") {
            if (J) return
            U = cS
            return
          }
          break
      }
      ;(U = it), U(x, S, L, re)
    }
    function LC(x, S, L, re) {
      switch (x) {
        case 1:
          ;(S = S.replace(sO, "")), S.length > 0 && al(S)
          return
        case 4:
          ol(S)
          return
        case 5:
          return
        case -1:
          fd()
          return
        case 2:
          switch (S) {
            case "html":
              it(x, S, L, re)
              return
            case "frameset":
              bt(S, L)
              return
            case "frame":
              bt(S, L), Q.pop()
              return
            case "noframes":
              Tn(x, S, L, re)
              return
          }
          break
        case 3:
          if (S === "frameset") {
            if (J && Q.top instanceof en.HTMLHtmlElement) return
            Q.pop(),
              !J && !(Q.top instanceof en.HTMLFrameSetElement) && (U = fP)
            return
          }
          break
      }
    }
    function fP(x, S, L, re) {
      switch (x) {
        case 1:
          ;(S = S.replace(sO, "")), S.length > 0 && al(S)
          return
        case 4:
          ol(S)
          return
        case 5:
          return
        case -1:
          fd()
          return
        case 2:
          switch (S) {
            case "html":
              it(x, S, L, re)
              return
            case "noframes":
              Tn(x, S, L, re)
              return
          }
          break
        case 3:
          if (S === "html") {
            U = fA
            return
          }
          break
      }
    }
    function cS(x, S, L, re) {
      switch (x) {
        case 1:
          if (AB.test(S)) break
          it(x, S, L, re)
          return
        case 4:
          Ge._appendChild(Ge.createComment(S))
          return
        case 5:
          it(x, S, L, re)
          return
        case -1:
          fd()
          return
        case 2:
          if (S === "html") {
            it(x, S, L, re)
            return
          }
          break
      }
      ;(U = it), U(x, S, L, re)
    }
    function fA(x, S, L, re) {
      switch (x) {
        case 1:
          ;(S = S.replace(sO, "")), S.length > 0 && it(x, S, L, re)
          return
        case 4:
          Ge._appendChild(Ge.createComment(S))
          return
        case 5:
          it(x, S, L, re)
          return
        case -1:
          fd()
          return
        case 2:
          switch (S) {
            case "html":
              it(x, S, L, re)
              return
            case "noframes":
              Tn(x, S, L, re)
              return
          }
          break
      }
    }
    function Ad(x, S, L, re) {
      function oe(yn) {
        for (var Ui = 0, lo = yn.length; Ui < lo; Ui++)
          switch (yn[Ui][0]) {
            case "color":
            case "face":
            case "size":
              return true
          }
        return false
      }
      var Re
      switch (x) {
        case 1:
          ve && RLe.test(S) && (ve = false),
            wr && (S = S.replace(yB, "\uFFFD")),
            al(S)
          return
        case 4:
          ol(S)
          return
        case 5:
          return
        case 2:
          switch (S) {
            case "font":
              if (!oe(L)) break
            case "b":
            case "big":
            case "blockquote":
            case "body":
            case "br":
            case "center":
            case "code":
            case "dd":
            case "div":
            case "dl":
            case "dt":
            case "em":
            case "embed":
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
            case "head":
            case "hr":
            case "i":
            case "img":
            case "li":
            case "listing":
            case "menu":
            case "meta":
            case "nobr":
            case "ol":
            case "p":
            case "pre":
            case "ruby":
            case "s":
            case "small":
            case "span":
            case "strong":
            case "strike":
            case "sub":
            case "sup":
            case "table":
            case "tt":
            case "u":
            case "ul":
            case "var":
              if (J) break
              do Q.pop(), (Re = Q.top)
              while (Re.namespaceURI !== lt.HTML && !d7(Re) && !f7(Re))
              Dn(x, S, L, re)
              return
          }
          ;(Re = Q.elements.length === 1 && J ? t : Q.top),
            Re.namespaceURI === lt.MATHML
              ? g7(L)
              : Re.namespaceURI === lt.SVG && ((S = TLe(S)), h7(L)),
            oO(L),
            EC(S, L, Re.namespaceURI),
            re && (S === "script" && (Re.namespaceURI, lt.SVG), Q.pop())
          return
        case 3:
          if (
            ((Re = Q.top),
            S === "script" &&
              Re.namespaceURI === lt.SVG &&
              Re.localName === "script")
          )
            Q.pop()
          else
            for (var st = Q.elements.length - 1, $t = Q.elements[st]; ; ) {
              if ($t.localName.toLowerCase() === S) {
                Q.popElement($t)
                break
              }
              if ((($t = Q.elements[--st]), $t.namespaceURI === lt.HTML)) {
                U(x, S, L, re)
                break
              }
            }
          return
      }
    }
    return (
      (Wr.testTokenizer = function (x, S, L, re) {
        var oe = []
        switch (S) {
          case "PCDATA state":
            g = er
            break
          case "RCDATA state":
            g = iu
            break
          case "RAWTEXT state":
            g = Bg
            break
          case "PLAINTEXT state":
            g = wC
            break
        }
        if (
          (L && (C = L),
          (Dn = function (st, $t, yn, Ui) {
            switch ((pa(), st)) {
              case 1:
                oe.length > 0 && oe[oe.length - 1][0] === "Character"
                  ? (oe[oe.length - 1][1] += $t)
                  : oe.push(["Character", $t])
                break
              case 4:
                oe.push(["Comment", $t])
                break
              case 5:
                oe.push([
                  "DOCTYPE",
                  $t,
                  yn === undefined ? null : yn,
                  Ui === undefined ? null : Ui,
                  !Mt,
                ])
                break
              case 2:
                for (
                  var lo = Object.create(null), kn = 0;
                  kn < yn.length;
                  kn++
                ) {
                  var ac = yn[kn]
                  ac.length === 1 ? (lo[ac[0]] = "") : (lo[ac[0]] = ac[1])
                }
                var Lo = ["StartTag", $t, lo]
                Ui && Lo.push(true), oe.push(Lo)
                break
              case 3:
                oe.push(["EndTag", $t])
                break
              case -1:
                break
            }
          }),
          !re)
        )
          this.parse(x, true)
        else {
          for (var Re = 0; Re < x.length; Re++) this.parse(x[Re])
          this.parse("", true)
        }
        return oe
      }),
      Wr
    )
  }
})
var Vb = _((qSt, B7) => {
  "use strict"
  B7.exports = I7
  var w7 = hB(),
    S7 = pB(),
    kLe = EB(),
    _B = oi(),
    MLe = JI()
  function I7(e) {
    this.contextObject = e
  }
  var FLe = {
    xml: { "": true, "1.0": true, "2.0": true },
    core: { "": true, "2.0": true },
    html: { "": true, "1.0": true, "2.0": true },
    xhtml: { "": true, "1.0": true, "2.0": true },
  }
  I7.prototype = {
    hasFeature: function (t, r) {
      var n = FLe[(t || "").toLowerCase()]
      return (n && n[r || ""]) || false
    },
    createDocumentType: function (t, r, n) {
      return (
        MLe.isValidQName(t) || _B.InvalidCharacterError(),
        new S7(this.contextObject, t, r, n)
      )
    },
    createDocument: function (t, r, n) {
      var i = new w7(false, null),
        s
      return (
        r ? (s = i.createElementNS(t, r)) : (s = null),
        n && i.appendChild(n),
        s && i.appendChild(s),
        t === _B.NAMESPACE.HTML
          ? (i._contentType = "application/xhtml+xml")
          : t === _B.NAMESPACE.SVG
            ? (i._contentType = "image/svg+xml")
            : (i._contentType = "application/xml"),
        i
      )
    },
    createHTMLDocument: function (t) {
      var r = new w7(true, null)
      r.appendChild(new S7(r, "html"))
      var n = r.createElement("html")
      r.appendChild(n)
      var i = r.createElement("head")
      if ((n.appendChild(i), t !== undefined)) {
        var s = r.createElement("title")
        i.appendChild(s), s.appendChild(r.createTextNode(t))
      }
      return n.appendChild(r.createElement("body")), (r.modclock = 1), r
    },
    mozSetOutputMutationHandler: function (e, t) {
      e.mutationHandler = t
    },
    mozGetInputMutationHandler: function (e) {
      _B.nyi()
    },
    mozHTMLParser: kLe,
  }
})
var D7 = _((VSt, R7) => {
  "use strict"
  var QLe = oB(),
    NLe = JU()
  R7.exports = uO
  function uO(e, t) {
    ;(this._window = e), (this._href = t)
  }
  uO.prototype = Object.create(NLe.prototype, {
    constructor: { value: uO },
    href: {
      get: function () {
        return this._href
      },
      set: function (e) {
        this.assign(e)
      },
    },
    assign: {
      value: function (e) {
        var t = new QLe(this._href),
          r = t.resolve(e)
        this._href = r
      },
    },
    replace: {
      value: function (e) {
        this.assign(e)
      },
    },
    reload: {
      value: function () {
        this.assign(this.href)
      },
    },
    toString: {
      value: function () {
        return this.href
      },
    },
  })
})
var k7 = _((HSt, T7) => {
  "use strict"
  var PLe = Object.create(null, {
    appCodeName: { value: "Mozilla" },
    appName: { value: "Netscape" },
    appVersion: { value: "4.0" },
    platform: { value: "" },
    product: { value: "Gecko" },
    productSub: { value: "20100101" },
    userAgent: { value: "" },
    vendor: { value: "" },
    vendorSub: { value: "" },
    taintEnabled: {
      value: function () {
        return false
      },
    },
  })
  T7.exports = PLe
})
var F7 = _((WSt, M7) => {
  "use strict"
  var LLe = { setTimeout, clearTimeout, setInterval, clearInterval }
  M7.exports = LLe
})
var fO = _((Hb, Q7) => {
  "use strict"
  var dO = oi()
  Hb = Q7.exports = {
    CSSStyleDeclaration: aB(),
    CharacterData: Mb(),
    Comment: NU(),
    DOMException: GI(),
    DOMImplementation: Vb(),
    DOMTokenList: vU(),
    Document: hB(),
    DocumentFragment: LU(),
    DocumentType: pB(),
    Element: e0(),
    HTMLParser: EB(),
    NamedNodeMap: wU(),
    Node: xs(),
    NodeList: up(),
    NodeFilter: Pb(),
    ProcessingInstruction: OU(),
    Text: FU(),
    Window: hO(),
  }
  dO.merge(Hb, zU())
  dO.merge(Hb, uB().elements)
  dO.merge(Hb, tO().elements)
})
var hO = _((GSt, N7) => {
  "use strict"
  var ULe = Vb(),
    OLe = tU(),
    qLe = D7(),
    Wb = oi()
  N7.exports = xB
  function xB(e) {
    ;(this.document = e || new ULe(null).createHTMLDocument("")),
      (this.document._scripting_enabled = true),
      (this.document.defaultView = this),
      (this.location = new qLe(this, this.document._address || "about:blank"))
  }
  xB.prototype = Object.create(OLe.prototype, {
    console: { value: console },
    history: { value: { back: Wb.nyi, forward: Wb.nyi, go: Wb.nyi } },
    navigator: { value: k7() },
    window: {
      get: function () {
        return this
      },
    },
    self: {
      get: function () {
        return this
      },
    },
    frames: {
      get: function () {
        return this
      },
    },
    parent: {
      get: function () {
        return this
      },
    },
    top: {
      get: function () {
        return this
      },
    },
    length: { value: 0 },
    frameElement: { value: null },
    opener: { value: null },
    onload: {
      get: function () {
        return this._getEventHandler("load")
      },
      set: function (e) {
        this._setEventHandler("load", e)
      },
    },
    getComputedStyle: {
      value: function (t) {
        return t.style
      },
    },
  })
  Wb.expose(F7(), xB)
  Wb.expose(fO(), xB)
})
var O7 = _((pp) => {
  "use strict"
  var P7 = Vb(),
    L7 = EB(),
    $St = hO(),
    U7 = fO()
  pp.createDOMImplementation = function () {
    return new P7(null)
  }
  pp.createDocument = function (e, t) {
    if (e || t) {
      var r = new L7()
      return r.parse(e || "", true), r.document()
    }
    return new P7(null).createHTMLDocument("")
  }
  pp.createIncrementalHTMLParser = function () {
    var e = new L7()
    return {
      write: function (t) {
        t.length > 0 &&
          e.parse(t, false, function () {
            return true
          })
      },
      end: function (t) {
        e.parse(t || "", true, function () {
          return true
        })
      },
      process: function (t) {
        return e.parse("", false, t)
      },
      document: function () {
        return e.document()
      },
    }
  }
  pp.createWindow = function (e, t) {
    var r = pp.createDocument(e)
    return t !== undefined && (r._address = t), new U7.Window(r)
  }
  pp.impl = U7
})
var Z7 = _((KSt, j7) => {
  "use strict"
  function VLe(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t]
      for (var n in r) r.hasOwnProperty(n) && (e[n] = r[n])
    }
    return e
  }
  function AO(e, t) {
    return Array(t + 1).join(e)
  }
  function HLe(e) {
    return e.replace(/^\n*/, "")
  }
  function WLe(e) {
    for (
      var t = e.length;
      t > 0 &&
      e[t - 1] ===
        `
`;

    )
      t--
    return e.substring(0, t)
  }
  var GLe = [
    "ADDRESS",
    "ARTICLE",
    "ASIDE",
    "AUDIO",
    "BLOCKQUOTE",
    "BODY",
    "CANVAS",
    "CENTER",
    "DD",
    "DIR",
    "DIV",
    "DL",
    "DT",
    "FIELDSET",
    "FIGCAPTION",
    "FIGURE",
    "FOOTER",
    "FORM",
    "FRAMESET",
    "H1",
    "H2",
    "H3",
    "H4",
    "H5",
    "H6",
    "HEADER",
    "HGROUP",
    "HR",
    "HTML",
    "ISINDEX",
    "LI",
    "MAIN",
    "MENU",
    "NAV",
    "NOFRAMES",
    "NOSCRIPT",
    "OL",
    "OUTPUT",
    "P",
    "PRE",
    "SECTION",
    "TABLE",
    "TBODY",
    "TD",
    "TFOOT",
    "TH",
    "THEAD",
    "TR",
    "UL",
  ]
  function yO(e) {
    return vO(e, GLe)
  }
  var H7 = [
    "AREA",
    "BASE",
    "BR",
    "COL",
    "COMMAND",
    "EMBED",
    "HR",
    "IMG",
    "INPUT",
    "KEYGEN",
    "LINK",
    "META",
    "PARAM",
    "SOURCE",
    "TRACK",
    "WBR",
  ]
  function W7(e) {
    return vO(e, H7)
  }
  function $Le(e) {
    return $7(e, H7)
  }
  var G7 = [
    "A",
    "TABLE",
    "THEAD",
    "TBODY",
    "TFOOT",
    "TH",
    "TD",
    "IFRAME",
    "SCRIPT",
    "AUDIO",
    "VIDEO",
  ]
  function YLe(e) {
    return vO(e, G7)
  }
  function KLe(e) {
    return $7(e, G7)
  }
  function vO(e, t) {
    return t.indexOf(e.nodeName) >= 0
  }
  function $7(e, t) {
    return (
      e.getElementsByTagName &&
      t.some(function (r) {
        return e.getElementsByTagName(r).length
      })
    )
  }
  var $s = {}
  $s.paragraph = {
    filter: "p",
    replacement: function (e) {
      return (
        `

` +
        e +
        `

`
      )
    },
  }
  $s.lineBreak = {
    filter: "br",
    replacement: function (e, t, r) {
      return (
        r.br +
        `
`
      )
    },
  }
  $s.heading = {
    filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
    replacement: function (e, t, r) {
      var n = Number(t.nodeName.charAt(1))
      if (r.headingStyle === "setext" && n < 3) {
        var i = AO(n === 1 ? "=" : "-", e.length)
        return (
          `

` +
          e +
          `
` +
          i +
          `

`
        )
      } else
        return (
          `

` +
          AO("#", n) +
          " " +
          e +
          `

`
        )
    },
  }
  $s.blockquote = {
    filter: "blockquote",
    replacement: function (e) {
      return (
        (e = e.replace(/^\n+|\n+$/g, "")),
        (e = e.replace(/^/gm, "> ")),
        `

` +
          e +
          `

`
      )
    },
  }
  $s.list = {
    filter: ["ul", "ol"],
    replacement: function (e, t) {
      var r = t.parentNode
      return r.nodeName === "LI" && r.lastElementChild === t
        ? `
` + e
        : `

` +
            e +
            `

`
    },
  }
  $s.listItem = {
    filter: "li",
    replacement: function (e, t, r) {
      e = e
        .replace(/^\n+/, "")
        .replace(
          /\n+$/,
          `
`,
        )
        .replace(
          /\n/gm,
          `
    `,
        )
      var n = r.bulletListMarker + "   ",
        i = t.parentNode
      if (i.nodeName === "OL") {
        var s = i.getAttribute("start"),
          o = Array.prototype.indexOf.call(i.children, t)
        n = (s ? Number(s) + o : o + 1) + ".  "
      }
      return (
        n +
        e +
        (t.nextSibling && !/\n$/.test(e)
          ? `
`
          : "")
      )
    },
  }
  $s.indentedCodeBlock = {
    filter: function (e, t) {
      return (
        t.codeBlockStyle === "indented" &&
        e.nodeName === "PRE" &&
        e.firstChild &&
        e.firstChild.nodeName === "CODE"
      )
    },
    replacement: function (e, t, r) {
      return (
        `

    ` +
        t.firstChild.textContent.replace(
          /\n/g,
          `
    `,
        ) +
        `

`
      )
    },
  }
  $s.fencedCodeBlock = {
    filter: function (e, t) {
      return (
        t.codeBlockStyle === "fenced" &&
        e.nodeName === "PRE" &&
        e.firstChild &&
        e.firstChild.nodeName === "CODE"
      )
    },
    replacement: function (e, t, r) {
      for (
        var n = t.firstChild.getAttribute("class") || "",
          i = (n.match(/language-(\S+)/) || [null, ""])[1],
          s = t.firstChild.textContent,
          o = r.fence.charAt(0),
          a = 3,
          l = new RegExp("^" + o + "{3,}", "gm"),
          c;
        (c = l.exec(s));

      )
        c[0].length >= a && (a = c[0].length + 1)
      var u = AO(o, a)
      return (
        `

` +
        u +
        i +
        `
` +
        s.replace(/\n$/, "") +
        `
` +
        u +
        `

`
      )
    },
  }
  $s.horizontalRule = {
    filter: "hr",
    replacement: function (e, t, r) {
      return (
        `

` +
        r.hr +
        `

`
      )
    },
  }
  $s.inlineLink = {
    filter: function (e, t) {
      return (
        t.linkStyle === "inlined" &&
        e.nodeName === "A" &&
        e.getAttribute("href")
      )
    },
    replacement: function (e, t) {
      var r = t.getAttribute("href")
      r && (r = r.replace(/([()])/g, "\\$1"))
      var n = wB(t.getAttribute("title"))
      return (
        n && (n = ' "' + n.replace(/"/g, '\\"') + '"'),
        "[" + e + "](" + r + n + ")"
      )
    },
  }
  $s.referenceLink = {
    filter: function (e, t) {
      return (
        t.linkStyle === "referenced" &&
        e.nodeName === "A" &&
        e.getAttribute("href")
      )
    },
    replacement: function (e, t, r) {
      var n = t.getAttribute("href"),
        i = wB(t.getAttribute("title"))
      i && (i = ' "' + i + '"')
      var s, o
      switch (r.linkReferenceStyle) {
        case "collapsed":
          ;(s = "[" + e + "][]"), (o = "[" + e + "]: " + n + i)
          break
        case "shortcut":
          ;(s = "[" + e + "]"), (o = "[" + e + "]: " + n + i)
          break
        default:
          var a = this.references.length + 1
          ;(s = "[" + e + "][" + a + "]"), (o = "[" + a + "]: " + n + i)
      }
      return this.references.push(o), s
    },
    references: [],
    append: function (e) {
      var t = ""
      return (
        this.references.length &&
          ((t =
            `

` +
            this.references.join(`
`) +
            `

`),
          (this.references = [])),
        t
      )
    },
  }
  $s.emphasis = {
    filter: ["em", "i"],
    replacement: function (e, t, r) {
      return e.trim() ? r.emDelimiter + e + r.emDelimiter : ""
    },
  }
  $s.strong = {
    filter: ["strong", "b"],
    replacement: function (e, t, r) {
      return e.trim() ? r.strongDelimiter + e + r.strongDelimiter : ""
    },
  }
  $s.code = {
    filter: function (e) {
      var t = e.previousSibling || e.nextSibling,
        r = e.parentNode.nodeName === "PRE" && !t
      return e.nodeName === "CODE" && !r
    },
    replacement: function (e) {
      if (!e) return ""
      e = e.replace(/\r?\n|\r/g, " ")
      for (
        var t = /^`|^ .*?[^ ].* $|`$/.test(e) ? " " : "",
          r = "`",
          n = e.match(/`+/gm) || [];
        n.indexOf(r) !== -1;

      )
        r = r + "`"
      return r + t + e + t + r
    },
  }
  $s.image = {
    filter: "img",
    replacement: function (e, t) {
      var r = wB(t.getAttribute("alt")),
        n = t.getAttribute("src") || "",
        i = wB(t.getAttribute("title")),
        s = i ? ' "' + i + '"' : ""
      return n ? "![" + r + "](" + n + s + ")" : ""
    },
  }
  function wB(e) {
    return e
      ? e.replace(
          /(\n+\s*)+/g,
          `
`,
        )
      : ""
  }
  function Y7(e) {
    ;(this.options = e),
      (this._keep = []),
      (this._remove = []),
      (this.blankRule = { replacement: e.blankReplacement }),
      (this.keepReplacement = e.keepReplacement),
      (this.defaultRule = { replacement: e.defaultReplacement }),
      (this.array = [])
    for (var t in e.rules) this.array.push(e.rules[t])
  }
  Y7.prototype = {
    add: function (e, t) {
      this.array.unshift(t)
    },
    keep: function (e) {
      this._keep.unshift({ filter: e, replacement: this.keepReplacement })
    },
    remove: function (e) {
      this._remove.unshift({
        filter: e,
        replacement: function () {
          return ""
        },
      })
    },
    forNode: function (e) {
      if (e.isBlank) return this.blankRule
      var t
      return (t = gO(this.array, e, this.options)) ||
        (t = gO(this._keep, e, this.options)) ||
        (t = gO(this._remove, e, this.options))
        ? t
        : this.defaultRule
    },
    forEach: function (e) {
      for (var t = 0; t < this.array.length; t++) e(this.array[t], t)
    },
  }
  function gO(e, t, r) {
    for (var n = 0; n < e.length; n++) {
      var i = e[n]
      if (zLe(i, t, r)) return i
    }
  }
  function zLe(e, t, r) {
    var n = e.filter
    if (typeof n == "string") {
      if (n === t.nodeName.toLowerCase()) return true
    } else if (Array.isArray(n)) {
      if (n.indexOf(t.nodeName.toLowerCase()) > -1) return true
    } else if (typeof n == "function") {
      if (n.call(e, t, r)) return true
    } else
      throw new TypeError("`filter` needs to be a string, array, or function")
  }
  function JLe(e) {
    var t = e.element,
      r = e.isBlock,
      n = e.isVoid,
      i =
        e.isPre ||
        function (f) {
          return f.nodeName === "PRE"
        }
    if (!(!t.firstChild || i(t))) {
      for (var s = null, o = false, a = null, l = q7(a, t, i); l !== t; ) {
        if (l.nodeType === 3 || l.nodeType === 4) {
          var c = l.data.replace(/[ \r\n\t]+/g, " ")
          if (
            ((!s || / $/.test(s.data)) &&
              !o &&
              c[0] === " " &&
              (c = c.substr(1)),
            !c)
          ) {
            l = pO(l)
            continue
          }
          ;(l.data = c), (s = l)
        } else if (l.nodeType === 1)
          r(l) || l.nodeName === "BR"
            ? (s && (s.data = s.data.replace(/ $/, "")), (s = null), (o = false))
            : n(l) || i(l)
              ? ((s = null), (o = true))
              : s && (o = false)
        else {
          l = pO(l)
          continue
        }
        var u = q7(a, l, i)
        ;(a = l), (l = u)
      }
      s && ((s.data = s.data.replace(/ $/, "")), s.data || pO(s))
    }
  }
  function pO(e) {
    var t = e.nextSibling || e.parentNode
    return e.parentNode.removeChild(e), t
  }
  function q7(e, t, r) {
    return (e && e.parentNode === t) || r(t)
      ? t.nextSibling || t.parentNode
      : t.firstChild || t.nextSibling || t.parentNode
  }
  var K7 = typeof window < "u" ? window : {}
  function jLe() {
    var e = K7.DOMParser,
      t = false
    try {
      new e().parseFromString("", "text/html") && (t = true)
    } catch {}
    return t
  }
  function ZLe() {
    var e = function () {}
    {
      var t = O7()
      e.prototype.parseFromString = function (r) {
        return t.createDocument(r)
      }
    }
    return e
  }
  var XLe = jLe() ? K7.DOMParser : ZLe()
  function eUe(e, t) {
    var r
    if (typeof e == "string") {
      var n = tUe().parseFromString(
        '<x-turndown id="turndown-root">' + e + "</x-turndown>",
        "text/html",
      )
      r = n.getElementById("turndown-root")
    } else r = e.cloneNode(true)
    return (
      JLe({
        element: r,
        isBlock: yO,
        isVoid: W7,
        isPre: t.preformattedCode ? rUe : null,
      }),
      r
    )
  }
  var mO
  function tUe() {
    return (mO = mO || new XLe()), mO
  }
  function rUe(e) {
    return e.nodeName === "PRE" || e.nodeName === "CODE"
  }
  function nUe(e, t) {
    return (
      (e.isBlock = yO(e)),
      (e.isCode = e.nodeName === "CODE" || e.parentNode.isCode),
      (e.isBlank = iUe(e)),
      (e.flankingWhitespace = sUe(e, t)),
      e
    )
  }
  function iUe(e) {
    return (
      !W7(e) && !YLe(e) && /^\s*$/i.test(e.textContent) && !$Le(e) && !KLe(e)
    )
  }
  function sUe(e, t) {
    if (e.isBlock || (t.preformattedCode && e.isCode))
      return { leading: "", trailing: "" }
    var r = oUe(e.textContent)
    return (
      r.leadingAscii && V7("left", e, t) && (r.leading = r.leadingNonAscii),
      r.trailingAscii && V7("right", e, t) && (r.trailing = r.trailingNonAscii),
      { leading: r.leading, trailing: r.trailing }
    )
  }
  function oUe(e) {
    var t = e.match(
      /^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/,
    )
    return {
      leading: t[1],
      leadingAscii: t[2],
      leadingNonAscii: t[3],
      trailing: t[4],
      trailingNonAscii: t[5],
      trailingAscii: t[6],
    }
  }
  function V7(e, t, r) {
    var n, i, s
    return (
      e === "left"
        ? ((n = t.previousSibling), (i = / $/))
        : ((n = t.nextSibling), (i = /^ /)),
      n &&
        (n.nodeType === 3
          ? (s = i.test(n.nodeValue))
          : r.preformattedCode && n.nodeName === "CODE"
            ? (s = false)
            : n.nodeType === 1 && !yO(n) && (s = i.test(n.textContent))),
      s
    )
  }
  var aUe = Array.prototype.reduce,
    lUe = [
      [/\\/g, "\\\\"],
      [/\*/g, "\\*"],
      [/^-/g, "\\-"],
      [/^\+ /g, "\\+ "],
      [/^(=+)/g, "\\$1"],
      [/^(#{1,6}) /g, "\\$1 "],
      [/`/g, "\\`"],
      [/^~~~/g, "\\~~~"],
      [/\[/g, "\\["],
      [/\]/g, "\\]"],
      [/^>/g, "\\>"],
      [/_/g, "\\_"],
      [/^(\d+)\. /g, "$1\\. "],
    ]
  function SB(e) {
    if (!(this instanceof SB)) return new SB(e)
    var t = {
      rules: $s,
      headingStyle: "setext",
      hr: "* * *",
      bulletListMarker: "*",
      codeBlockStyle: "indented",
      fence: "```",
      emDelimiter: "_",
      strongDelimiter: "**",
      linkStyle: "inlined",
      linkReferenceStyle: "full",
      br: "  ",
      preformattedCode: false,
      blankReplacement: function (r, n) {
        return n.isBlock
          ? `

`
          : ""
      },
      keepReplacement: function (r, n) {
        return n.isBlock
          ? `

` +
              n.outerHTML +
              `

`
          : n.outerHTML
      },
      defaultReplacement: function (r, n) {
        return n.isBlock
          ? `

` +
              r +
              `

`
          : r
      },
    }
    ;(this.options = VLe({}, t, e)), (this.rules = new Y7(this.options))
  }
  SB.prototype = {
    turndown: function (e) {
      if (!dUe(e))
        throw new TypeError(
          e + " is not a string, or an element/document/fragment node.",
        )
      if (e === "") return ""
      var t = z7.call(this, new eUe(e, this.options))
      return cUe.call(this, t)
    },
    use: function (e) {
      if (Array.isArray(e)) for (var t = 0; t < e.length; t++) this.use(e[t])
      else if (typeof e == "function") e(this)
      else
        throw new TypeError(
          "plugin must be a Function or an Array of Functions",
        )
      return this
    },
    addRule: function (e, t) {
      return this.rules.add(e, t), this
    },
    keep: function (e) {
      return this.rules.keep(e), this
    },
    remove: function (e) {
      return this.rules.remove(e), this
    },
    escape: function (e) {
      return lUe.reduce(function (t, r) {
        return t.replace(r[0], r[1])
      }, e)
    },
  }
  function z7(e) {
    var t = this
    return aUe.call(
      e.childNodes,
      function (r, n) {
        n = new nUe(n, t.options)
        var i = ""
        return (
          n.nodeType === 3
            ? (i = n.isCode ? n.nodeValue : t.escape(n.nodeValue))
            : n.nodeType === 1 && (i = uUe.call(t, n)),
          J7(r, i)
        )
      },
      "",
    )
  }
  function cUe(e) {
    var t = this
    return (
      this.rules.forEach(function (r) {
        typeof r.append == "function" && (e = J7(e, r.append(t.options)))
      }),
      e.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "")
    )
  }
  function uUe(e) {
    var t = this.rules.forNode(e),
      r = z7.call(this, e),
      n = e.flankingWhitespace
    return (
      (n.leading || n.trailing) && (r = r.trim()),
      n.leading + t.replacement(r, e, this.options) + n.trailing
    )
  }
  function J7(e, t) {
    var r = WLe(e),
      n = HLe(t),
      i = Math.max(e.length - r.length, t.length - n.length),
      s = `

`.substring(0, i)
    return r + s + n
  }
  function dUe(e) {
    return (
      e != null &&
      (typeof e == "string" ||
        (e.nodeType &&
          (e.nodeType === 1 || e.nodeType === 9 || e.nodeType === 11)))
    )
  }
  j7.exports = SB
})
var tX = _((RBt, eX) => {
  "use strict"
  function Hqe() {
    ;(this.__data__ = []), (this.size = 0)
  }
  eX.exports = Hqe
})
var zB = _((DBt, rX) => {
  "use strict"
  function Wqe(e, t) {
    return e === t || (e !== e && t !== t)
  }
  rX.exports = Wqe
})
var eE = _((TBt, nX) => {
  "use strict"
  var Gqe = zB()
  function $qe(e, t) {
    for (var r = e.length; r--; ) if (Gqe(e[r][0], t)) return r
    return -1
  }
  nX.exports = $qe
})
var sX = _((kBt, iX) => {
  "use strict"
  var Yqe = eE(),
    Kqe = Array.prototype,
    zqe = Kqe.splice
  function Jqe(e) {
    var t = this.__data__,
      r = Yqe(t, e)
    if (r < 0) return false
    var n = t.length - 1
    return r == n ? t.pop() : zqe.call(t, r, 1), --this.size, true
  }
  iX.exports = Jqe
})
var aX = _((MBt, oX) => {
  "use strict"
  var jqe = eE()
  function Zqe(e) {
    var t = this.__data__,
      r = jqe(t, e)
    return r < 0 ? undefined : t[r][1]
  }
  oX.exports = Zqe
})
var cX = _((FBt, lX) => {
  "use strict"
  var Xqe = eE()
  function eVe(e) {
    return Xqe(this.__data__, e) > -1
  }
  lX.exports = eVe
})
var dX = _((QBt, uX) => {
  "use strict"
  var tVe = eE()
  function rVe(e, t) {
    var r = this.__data__,
      n = tVe(r, e)
    return n < 0 ? (++this.size, r.push([e, t])) : (r[n][1] = t), this
  }
  uX.exports = rVe
})
var tE = _((NBt, fX) => {
  "use strict"
  var nVe = tX(),
    iVe = sX(),
    sVe = aX(),
    oVe = cX(),
    aVe = dX()
  function p0(e) {
    var t = -1,
      r = e == null ? 0 : e.length
    for (this.clear(); ++t < r; ) {
      var n = e[t]
      this.set(n[0], n[1])
    }
  }
  p0.prototype.clear = nVe
  p0.prototype.delete = iVe
  p0.prototype.get = sVe
  p0.prototype.has = oVe
  p0.prototype.set = aVe
  fX.exports = p0
})
var gX = _((PBt, hX) => {
  "use strict"
  var lVe = tE()
  function cVe() {
    ;(this.__data__ = new lVe()), (this.size = 0)
  }
  hX.exports = cVe
})
var mX = _((LBt, pX) => {
  "use strict"
  function uVe(e) {
    var t = this.__data__,
      r = t.delete(e)
    return (this.size = t.size), r
  }
  pX.exports = uVe
})
var yX = _((UBt, AX) => {
  "use strict"
  function dVe(e) {
    return this.__data__.get(e)
  }
  AX.exports = dVe
})
var CX = _((OBt, vX) => {
  "use strict"
  function fVe(e) {
    return this.__data__.has(e)
  }
  vX.exports = fVe
})
var FO = _((qBt, bX) => {
  "use strict"
  var hVe = BA(),
    gVe = Bd(),
    pVe = "[object AsyncFunction]",
    mVe = "[object Function]",
    AVe = "[object GeneratorFunction]",
    yVe = "[object Proxy]"
  function vVe(e) {
    if (!gVe(e)) return false
    var t = hVe(e)
    return t == mVe || t == AVe || t == pVe || t == yVe
  }
  bX.exports = vVe
})
var _X = _((VBt, EX) => {
  "use strict"
  var CVe = Al(),
    bVe = CVe["__core-js_shared__"]
  EX.exports = bVe
})
var SX = _((HBt, wX) => {
  "use strict"
  var QO = _X(),
    xX = (function () {
      var e = /[^.]+$/.exec((QO && QO.keys && QO.keys.IE_PROTO) || "")
      return e ? "Symbol(src)_1." + e : ""
    })()
  function EVe(e) {
    return !!xX && xX in e
  }
  wX.exports = EVe
})
var NO = _((WBt, IX) => {
  "use strict"
  var _Ve = Function.prototype,
    xVe = _Ve.toString
  function wVe(e) {
    if (e != null) {
      try {
        return xVe.call(e)
      } catch {}
      try {
        return e + ""
      } catch {}
    }
    return ""
  }
  IX.exports = wVe
})
var RX = _((GBt, BX) => {
  "use strict"
  var SVe = FO(),
    IVe = SX(),
    BVe = Bd(),
    RVe = NO(),
    DVe = /[\\^$.*+?()[\]{}|]/g,
    TVe = /^\[object .+?Constructor\]$/,
    kVe = Function.prototype,
    MVe = Object.prototype,
    FVe = kVe.toString,
    QVe = MVe.hasOwnProperty,
    NVe = RegExp(
      "^" +
        FVe.call(QVe)
          .replace(DVe, "\\$&")
          .replace(
            /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
            "$1.*?",
          ) +
        "$",
    )
  function PVe(e) {
    if (!BVe(e) || IVe(e)) return false
    var t = SVe(e) ? NVe : TVe
    return t.test(RVe(e))
  }
  BX.exports = PVe
})
var TX = _(($Bt, DX) => {
  "use strict"
  function LVe(e, t) {
    return e?.[t]
  }
  DX.exports = LVe
})
var ch = _((YBt, kX) => {
  "use strict"
  var UVe = RX(),
    OVe = TX()
  function qVe(e, t) {
    var r = OVe(e, t)
    return UVe(r) ? r : undefined
  }
  kX.exports = qVe
})
var JB = _((KBt, MX) => {
  "use strict"
  var VVe = ch(),
    HVe = Al(),
    WVe = VVe(HVe, "Map")
  MX.exports = WVe
})
var rE = _((zBt, FX) => {
  "use strict"
  var GVe = ch(),
    $Ve = GVe(Object, "create")
  FX.exports = $Ve
})
var PX = _((JBt, NX) => {
  "use strict"
  var QX = rE()
  function YVe() {
    ;(this.__data__ = QX ? QX(null) : {}), (this.size = 0)
  }
  NX.exports = YVe
})
var UX = _((jBt, LX) => {
  "use strict"
  function KVe(e) {
    var t = this.has(e) && delete this.__data__[e]
    return (this.size -= t ? 1 : 0), t
  }
  LX.exports = KVe
})
var qX = _((ZBt, OX) => {
  "use strict"
  var zVe = rE(),
    JVe = "__lodash_hash_undefined__",
    jVe = Object.prototype,
    ZVe = jVe.hasOwnProperty
  function XVe(e) {
    var t = this.__data__
    if (zVe) {
      var r = t[e]
      return r === JVe ? undefined : r
    }
    return ZVe.call(t, e) ? t[e] : undefined
  }
  OX.exports = XVe
})
var HX = _((XBt, VX) => {
  "use strict"
  var eHe = rE(),
    tHe = Object.prototype,
    rHe = tHe.hasOwnProperty
  function nHe(e) {
    var t = this.__data__
    return eHe ? t[e] !== undefined : rHe.call(t, e)
  }
  VX.exports = nHe
})
var GX = _((eRt, WX) => {
  "use strict"
  var iHe = rE(),
    sHe = "__lodash_hash_undefined__"
  function oHe(e, t) {
    var r = this.__data__
    return (
      (this.size += this.has(e) ? 0 : 1),
      (r[e] = iHe && t === undefined ? sHe : t),
      this
    )
  }
  WX.exports = oHe
})
var YX = _((tRt, $X) => {
  "use strict"
  var aHe = PX(),
    lHe = UX(),
    cHe = qX(),
    uHe = HX(),
    dHe = GX()
  function m0(e) {
    var t = -1,
      r = e == null ? 0 : e.length
    for (this.clear(); ++t < r; ) {
      var n = e[t]
      this.set(n[0], n[1])
    }
  }
  m0.prototype.clear = aHe
  m0.prototype.delete = lHe
  m0.prototype.get = cHe
  m0.prototype.has = uHe
  m0.prototype.set = dHe
  $X.exports = m0
})
var JX = _((rRt, zX) => {
  "use strict"
  var KX = YX(),
    fHe = tE(),
    hHe = JB()
  function gHe() {
    ;(this.size = 0),
      (this.__data__ = {
        hash: new KX(),
        map: new (hHe || fHe)(),
        string: new KX(),
      })
  }
  zX.exports = gHe
})
var ZX = _((nRt, jX) => {
  "use strict"
  function pHe(e) {
    var t = typeof e
    return t == "string" || t == "number" || t == "symbol" || t == "boolean"
      ? e !== "__proto__"
      : e === null
  }
  jX.exports = pHe
})
var nE = _((iRt, XX) => {
  "use strict"
  var mHe = ZX()
  function AHe(e, t) {
    var r = e.__data__
    return mHe(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map
  }
  XX.exports = AHe
})
var tee = _((sRt, eee) => {
  "use strict"
  var yHe = nE()
  function vHe(e) {
    var t = yHe(this, e).delete(e)
    return (this.size -= t ? 1 : 0), t
  }
  eee.exports = vHe
})
var nee = _((oRt, ree) => {
  "use strict"
  var CHe = nE()
  function bHe(e) {
    return CHe(this, e).get(e)
  }
  ree.exports = bHe
})
var see = _((aRt, iee) => {
  "use strict"
  var EHe = nE()
  function _He(e) {
    return EHe(this, e).has(e)
  }
  iee.exports = _He
})
var aee = _((lRt, oee) => {
  "use strict"
  var xHe = nE()
  function wHe(e, t) {
    var r = xHe(this, e),
      n = r.size
    return r.set(e, t), (this.size += r.size == n ? 0 : 1), this
  }
  oee.exports = wHe
})
var PO = _((cRt, lee) => {
  "use strict"
  var SHe = JX(),
    IHe = tee(),
    BHe = nee(),
    RHe = see(),
    DHe = aee()
  function A0(e) {
    var t = -1,
      r = e == null ? 0 : e.length
    for (this.clear(); ++t < r; ) {
      var n = e[t]
      this.set(n[0], n[1])
    }
  }
  A0.prototype.clear = SHe
  A0.prototype.delete = IHe
  A0.prototype.get = BHe
  A0.prototype.has = RHe
  A0.prototype.set = DHe
  lee.exports = A0
})
var uee = _((uRt, cee) => {
  "use strict"
  var THe = tE(),
    kHe = JB(),
    MHe = PO(),
    FHe = 200
  function QHe(e, t) {
    var r = this.__data__
    if (r instanceof THe) {
      var n = r.__data__
      if (!kHe || n.length < FHe - 1)
        return n.push([e, t]), (this.size = ++r.size), this
      r = this.__data__ = new MHe(n)
    }
    return r.set(e, t), (this.size = r.size), this
  }
  cee.exports = QHe
})
var LO = _((dRt, dee) => {
  "use strict"
  var NHe = tE(),
    PHe = gX(),
    LHe = mX(),
    UHe = yX(),
    OHe = CX(),
    qHe = uee()
  function y0(e) {
    var t = (this.__data__ = new NHe(e))
    this.size = t.size
  }
  y0.prototype.clear = PHe
  y0.prototype.delete = LHe
  y0.prototype.get = UHe
  y0.prototype.has = OHe
  y0.prototype.set = qHe
  dee.exports = y0
})
var hee = _((fRt, fee) => {
  "use strict"
  var VHe = "__lodash_hash_undefined__"
  function HHe(e) {
    return this.__data__.set(e, VHe), this
  }
  fee.exports = HHe
})
var pee = _((hRt, gee) => {
  "use strict"
  function WHe(e) {
    return this.__data__.has(e)
  }
  gee.exports = WHe
})
var Aee = _((gRt, mee) => {
  "use strict"
  var GHe = PO(),
    $He = hee(),
    YHe = pee()
  function jB(e) {
    var t = -1,
      r = e == null ? 0 : e.length
    for (this.__data__ = new GHe(); ++t < r; ) this.add(e[t])
  }
  jB.prototype.add = jB.prototype.push = $He
  jB.prototype.has = YHe
  mee.exports = jB
})
var vee = _((pRt, yee) => {
  "use strict"
  function KHe(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length; ++r < n; )
      if (t(e[r], r, e)) return true
    return false
  }
  yee.exports = KHe
})
var bee = _((mRt, Cee) => {
  "use strict"
  function zHe(e, t) {
    return e.has(t)
  }
  Cee.exports = zHe
})
var UO = _((ARt, Eee) => {
  "use strict"
  var JHe = Aee(),
    jHe = vee(),
    ZHe = bee(),
    XHe = 1,
    eWe = 2
  function tWe(e, t, r, n, i, s) {
    var o = r & XHe,
      a = e.length,
      l = t.length
    if (a != l && !(o && l > a)) return false
    var c = s.get(e),
      u = s.get(t)
    if (c && u) return c == t && u == e
    var f = -1,
      p = true,
      g = r & eWe ? new JHe() : undefined
    for (s.set(e, t), s.set(t, e); ++f < a; ) {
      var m = e[f],
        y = t[f]
      if (n) var v = o ? n(y, m, f, t, e, s) : n(m, y, f, e, t, s)
      if (v !== undefined) {
        if (v) continue
        p = false
        break
      }
      if (g) {
        if (
          !jHe(t, function (C, E) {
            if (!ZHe(g, E) && (m === C || i(m, C, r, n, s))) return g.push(E)
          })
        ) {
          p = false
          break
        }
      } else if (!(m === y || i(m, y, r, n, s))) {
        p = false
        break
      }
    }
    return s.delete(e), s.delete(t), p
  }
  Eee.exports = tWe
})
var OO = _((yRt, _ee) => {
  "use strict"
  var rWe = Al(),
    nWe = rWe.Uint8Array
  _ee.exports = nWe
})
var wee = _((vRt, xee) => {
  "use strict"
  function iWe(e) {
    var t = -1,
      r = Array(e.size)
    return (
      e.forEach(function (n, i) {
        r[++t] = [i, n]
      }),
      r
    )
  }
  xee.exports = iWe
})
var Iee = _((CRt, See) => {
  "use strict"
  function sWe(e) {
    var t = -1,
      r = Array(e.size)
    return (
      e.forEach(function (n) {
        r[++t] = n
      }),
      r
    )
  }
  See.exports = sWe
})
var kee = _((bRt, Tee) => {
  "use strict"
  var Bee = sb(),
    Ree = OO(),
    oWe = zB(),
    aWe = UO(),
    lWe = wee(),
    cWe = Iee(),
    uWe = 1,
    dWe = 2,
    fWe = "[object Boolean]",
    hWe = "[object Date]",
    gWe = "[object Error]",
    pWe = "[object Map]",
    mWe = "[object Number]",
    AWe = "[object RegExp]",
    yWe = "[object Set]",
    vWe = "[object String]",
    CWe = "[object Symbol]",
    bWe = "[object ArrayBuffer]",
    EWe = "[object DataView]",
    Dee = Bee ? Bee.prototype : undefined,
    qO = Dee ? Dee.valueOf : undefined
  function _We(e, t, r, n, i, s, o) {
    switch (r) {
      case EWe:
        if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
          return false
        ;(e = e.buffer), (t = t.buffer)
      case bWe:
        return !(e.byteLength != t.byteLength || !s(new Ree(e), new Ree(t)))
      case fWe:
      case hWe:
      case mWe:
        return oWe(+e, +t)
      case gWe:
        return e.name == t.name && e.message == t.message
      case AWe:
      case vWe:
        return e == t + ""
      case pWe:
        var a = lWe
      case yWe:
        var l = n & uWe
        if ((a || (a = cWe), e.size != t.size && !l)) return false
        var c = o.get(e)
        if (c) return c == t
        ;(n |= dWe), o.set(e, t)
        var u = aWe(a(e), a(t), n, i, s, o)
        return o.delete(e), u
      case CWe:
        if (qO) return qO.call(e) == qO.call(t)
    }
    return false
  }
  Tee.exports = _We
})
var VO = _((ERt, Mee) => {
  "use strict"
  function xWe(e, t) {
    for (var r = -1, n = t.length, i = e.length; ++r < n; ) e[i + r] = t[r]
    return e
  }
  Mee.exports = xWe
})
var iE = _((_Rt, Fee) => {
  "use strict"
  var wWe = Array.isArray
  Fee.exports = wWe
})
var HO = _((xRt, Qee) => {
  "use strict"
  var SWe = VO(),
    IWe = iE()
  function BWe(e, t, r) {
    var n = t(e)
    return IWe(e) ? n : SWe(n, r(e))
  }
  Qee.exports = BWe
})
var Pee = _((wRt, Nee) => {
  "use strict"
  function RWe(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length, i = 0, s = []; ++r < n; ) {
      var o = e[r]
      t(o, r, e) && (s[i++] = o)
    }
    return s
  }
  Nee.exports = RWe
})
var WO = _((SRt, Lee) => {
  "use strict"
  function DWe() {
    return []
  }
  Lee.exports = DWe
})
var ZB = _((IRt, Oee) => {
  "use strict"
  var TWe = Pee(),
    kWe = WO(),
    MWe = Object.prototype,
    FWe = MWe.propertyIsEnumerable,
    Uee = Object.getOwnPropertySymbols,
    QWe = Uee
      ? function (e) {
          return e == null
            ? []
            : ((e = Object(e)),
              TWe(Uee(e), function (t) {
                return FWe.call(e, t)
              }))
        }
      : kWe
  Oee.exports = QWe
})
var Vee = _((BRt, qee) => {
  "use strict"
  function NWe(e, t) {
    for (var r = -1, n = Array(e); ++r < e; ) n[r] = t(r)
    return n
  }
  qee.exports = NWe
})
var Wee = _((RRt, Hee) => {
  "use strict"
  var PWe = BA(),
    LWe = $f(),
    UWe = "[object Arguments]"
  function OWe(e) {
    return LWe(e) && PWe(e) == UWe
  }
  Hee.exports = OWe
})
var Kee = _((DRt, Yee) => {
  "use strict"
  var Gee = Wee(),
    qWe = $f(),
    $ee = Object.prototype,
    VWe = $ee.hasOwnProperty,
    HWe = $ee.propertyIsEnumerable,
    WWe = Gee(
      (function () {
        return arguments
      })(),
    )
      ? Gee
      : function (e) {
          return qWe(e) && VWe.call(e, "callee") && !HWe.call(e, "callee")
        }
  Yee.exports = WWe
})
var Jee = _((TRt, zee) => {
  "use strict"
  function GWe() {
    return false
  }
  zee.exports = GWe
})
var XB = _((sE, v0) => {
  "use strict"
  var $We = Al(),
    YWe = Jee(),
    Xee = typeof sE == "object" && sE && !sE.nodeType && sE,
    jee = Xee && typeof v0 == "object" && v0 && !v0.nodeType && v0,
    KWe = jee && jee.exports === Xee,
    Zee = KWe ? $We.Buffer : undefined,
    zWe = Zee ? Zee.isBuffer : undefined,
    JWe = zWe || YWe
  v0.exports = JWe
})
var tte = _((kRt, ete) => {
  "use strict"
  var jWe = 9007199254740991,
    ZWe = /^(?:0|[1-9]\d*)$/
  function XWe(e, t) {
    var r = typeof e
    return (
      (t = t ?? jWe),
      !!t &&
        (r == "number" || (r != "symbol" && ZWe.test(e))) &&
        e > -1 &&
        e % 1 == 0 &&
        e < t
    )
  }
  ete.exports = XWe
})
var GO = _((MRt, rte) => {
  "use strict"
  var e5e = 9007199254740991
  function t5e(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= e5e
  }
  rte.exports = t5e
})
var ite = _((FRt, nte) => {
  "use strict"
  var r5e = BA(),
    n5e = GO(),
    i5e = $f(),
    s5e = "[object Arguments]",
    o5e = "[object Array]",
    a5e = "[object Boolean]",
    l5e = "[object Date]",
    c5e = "[object Error]",
    u5e = "[object Function]",
    d5e = "[object Map]",
    f5e = "[object Number]",
    h5e = "[object Object]",
    g5e = "[object RegExp]",
    p5e = "[object Set]",
    m5e = "[object String]",
    A5e = "[object WeakMap]",
    y5e = "[object ArrayBuffer]",
    v5e = "[object DataView]",
    C5e = "[object Float32Array]",
    b5e = "[object Float64Array]",
    E5e = "[object Int8Array]",
    _5e = "[object Int16Array]",
    x5e = "[object Int32Array]",
    w5e = "[object Uint8Array]",
    S5e = "[object Uint8ClampedArray]",
    I5e = "[object Uint16Array]",
    B5e = "[object Uint32Array]",
    Mn = {}
  Mn[C5e] =
    Mn[b5e] =
    Mn[E5e] =
    Mn[_5e] =
    Mn[x5e] =
    Mn[w5e] =
    Mn[S5e] =
    Mn[I5e] =
    Mn[B5e] =
      true
  Mn[s5e] =
    Mn[o5e] =
    Mn[y5e] =
    Mn[a5e] =
    Mn[v5e] =
    Mn[l5e] =
    Mn[c5e] =
    Mn[u5e] =
    Mn[d5e] =
    Mn[f5e] =
    Mn[h5e] =
    Mn[g5e] =
    Mn[p5e] =
    Mn[m5e] =
    Mn[A5e] =
      false
  function R5e(e) {
    return i5e(e) && n5e(e.length) && !!Mn[r5e(e)]
  }
  nte.exports = R5e
})
var eR = _((QRt, ste) => {
  "use strict"
  function D5e(e) {
    return function (t) {
      return e(t)
    }
  }
  ste.exports = D5e
})
var tR = _((oE, C0) => {
  "use strict"
  var T5e = gL(),
    ote = typeof oE == "object" && oE && !oE.nodeType && oE,
    aE = ote && typeof C0 == "object" && C0 && !C0.nodeType && C0,
    k5e = aE && aE.exports === ote,
    $O = k5e && T5e.process,
    M5e = (function () {
      try {
        var e = aE && aE.require && aE.require("util").types
        return e || ($O && $O.binding && $O.binding("util"))
      } catch {}
    })()
  C0.exports = M5e
})
var YO = _((NRt, cte) => {
  "use strict"
  var F5e = ite(),
    Q5e = eR(),
    ate = tR(),
    lte = ate && ate.isTypedArray,
    N5e = lte ? Q5e(lte) : F5e
  cte.exports = N5e
})
var KO = _((PRt, ute) => {
  "use strict"
  var P5e = Vee(),
    L5e = Kee(),
    U5e = iE(),
    O5e = XB(),
    q5e = tte(),
    V5e = YO(),
    H5e = Object.prototype,
    W5e = H5e.hasOwnProperty
  function G5e(e, t) {
    var r = U5e(e),
      n = !r && L5e(e),
      i = !r && !n && O5e(e),
      s = !r && !n && !i && V5e(e),
      o = r || n || i || s,
      a = o ? P5e(e.length, String) : [],
      l = a.length
    for (var c in e)
      (t || W5e.call(e, c)) &&
        !(
          o &&
          (c == "length" ||
            (i && (c == "offset" || c == "parent")) ||
            (s && (c == "buffer" || c == "byteLength" || c == "byteOffset")) ||
            q5e(c, l))
        ) &&
        a.push(c)
    return a
  }
  ute.exports = G5e
})
var rR = _((LRt, dte) => {
  "use strict"
  var $5e = Object.prototype
  function Y5e(e) {
    var t = e && e.constructor,
      r = (typeof t == "function" && t.prototype) || $5e
    return e === r
  }
  dte.exports = Y5e
})
var zO = _((URt, fte) => {
  "use strict"
  function K5e(e, t) {
    return function (r) {
      return e(t(r))
    }
  }
  fte.exports = K5e
})
var gte = _((ORt, hte) => {
  "use strict"
  var z5e = zO(),
    J5e = z5e(Object.keys, Object)
  hte.exports = J5e
})
var mte = _((qRt, pte) => {
  "use strict"
  var j5e = rR(),
    Z5e = gte(),
    X5e = Object.prototype,
    e3e = X5e.hasOwnProperty
  function t3e(e) {
    if (!j5e(e)) return Z5e(e)
    var t = []
    for (var r in Object(e)) e3e.call(e, r) && r != "constructor" && t.push(r)
    return t
  }
  pte.exports = t3e
})
var JO = _((VRt, Ate) => {
  "use strict"
  var r3e = FO(),
    n3e = GO()
  function i3e(e) {
    return e != null && n3e(e.length) && !r3e(e)
  }
  Ate.exports = i3e
})
var nR = _((HRt, yte) => {
  "use strict"
  var s3e = KO(),
    o3e = mte(),
    a3e = JO()
  function l3e(e) {
    return a3e(e) ? s3e(e) : o3e(e)
  }
  yte.exports = l3e
})
var jO = _((WRt, vte) => {
  "use strict"
  var c3e = HO(),
    u3e = ZB(),
    d3e = nR()
  function f3e(e) {
    return c3e(e, d3e, u3e)
  }
  vte.exports = f3e
})
var Ete = _((GRt, bte) => {
  "use strict"
  var Cte = jO(),
    h3e = 1,
    g3e = Object.prototype,
    p3e = g3e.hasOwnProperty
  function m3e(e, t, r, n, i, s) {
    var o = r & h3e,
      a = Cte(e),
      l = a.length,
      c = Cte(t),
      u = c.length
    if (l != u && !o) return false
    for (var f = l; f--; ) {
      var p = a[f]
      if (!(o ? p in t : p3e.call(t, p))) return false
    }
    var g = s.get(e),
      m = s.get(t)
    if (g && m) return g == t && m == e
    var y = true
    s.set(e, t), s.set(t, e)
    for (var v = o; ++f < l; ) {
      p = a[f]
      var C = e[p],
        E = t[p]
      if (n) var w = o ? n(E, C, p, t, e, s) : n(C, E, p, e, t, s)
      if (!(w === undefined ? C === E || i(C, E, r, n, s) : w)) {
        y = false
        break
      }
      v || (v = p == "constructor")
    }
    if (y && !v) {
      var B = e.constructor,
        T = t.constructor
      B != T &&
        "constructor" in e &&
        "constructor" in t &&
        !(
          typeof B == "function" &&
          B instanceof B &&
          typeof T == "function" &&
          T instanceof T
        ) &&
        (y = false)
    }
    return s.delete(e), s.delete(t), y
  }
  bte.exports = m3e
})
var xte = _(($Rt, _te) => {
  "use strict"
  var A3e = ch(),
    y3e = Al(),
    v3e = A3e(y3e, "DataView")
  _te.exports = v3e
})
var Ste = _((YRt, wte) => {
  "use strict"
  var C3e = ch(),
    b3e = Al(),
    E3e = C3e(b3e, "Promise")
  wte.exports = E3e
})
var Bte = _((KRt, Ite) => {
  "use strict"
  var _3e = ch(),
    x3e = Al(),
    w3e = _3e(x3e, "Set")
  Ite.exports = w3e
})
var Dte = _((zRt, Rte) => {
  "use strict"
  var S3e = ch(),
    I3e = Al(),
    B3e = S3e(I3e, "WeakMap")
  Rte.exports = B3e
})
var lE = _((JRt, Pte) => {
  "use strict"
  var ZO = xte(),
    XO = JB(),
    eq = Ste(),
    tq = Bte(),
    rq = Dte(),
    Nte = BA(),
    b0 = NO(),
    Tte = "[object Map]",
    R3e = "[object Object]",
    kte = "[object Promise]",
    Mte = "[object Set]",
    Fte = "[object WeakMap]",
    Qte = "[object DataView]",
    D3e = b0(ZO),
    T3e = b0(XO),
    k3e = b0(eq),
    M3e = b0(tq),
    F3e = b0(rq),
    vp = Nte
  ;((ZO && vp(new ZO(new ArrayBuffer(1))) != Qte) ||
    (XO && vp(new XO()) != Tte) ||
    (eq && vp(eq.resolve()) != kte) ||
    (tq && vp(new tq()) != Mte) ||
    (rq && vp(new rq()) != Fte)) &&
    (vp = function (e) {
      var t = Nte(e),
        r = t == R3e ? e.constructor : undefined,
        n = r ? b0(r) : ""
      if (n)
        switch (n) {
          case D3e:
            return Qte
          case T3e:
            return Tte
          case k3e:
            return kte
          case M3e:
            return Mte
          case F3e:
            return Fte
        }
      return t
    })
  Pte.exports = vp
})
var Gte = _((jRt, Wte) => {
  "use strict"
  var nq = LO(),
    Q3e = UO(),
    N3e = kee(),
    P3e = Ete(),
    Lte = lE(),
    Ute = iE(),
    Ote = XB(),
    L3e = YO(),
    U3e = 1,
    qte = "[object Arguments]",
    Vte = "[object Array]",
    iR = "[object Object]",
    O3e = Object.prototype,
    Hte = O3e.hasOwnProperty
  function q3e(e, t, r, n, i, s) {
    var o = Ute(e),
      a = Ute(t),
      l = o ? Vte : Lte(e),
      c = a ? Vte : Lte(t)
    ;(l = l == qte ? iR : l), (c = c == qte ? iR : c)
    var u = l == iR,
      f = c == iR,
      p = l == c
    if (p && Ote(e)) {
      if (!Ote(t)) return false
      ;(o = true), (u = false)
    }
    if (p && !u)
      return (
        s || (s = new nq()),
        o || L3e(e) ? Q3e(e, t, r, n, i, s) : N3e(e, t, l, r, n, i, s)
      )
    if (!(r & U3e)) {
      var g = u && Hte.call(e, "__wrapped__"),
        m = f && Hte.call(t, "__wrapped__")
      if (g || m) {
        var y = g ? e.value() : e,
          v = m ? t.value() : t
        return s || (s = new nq()), i(y, v, r, n, s)
      }
    }
    return p ? (s || (s = new nq()), P3e(e, t, r, n, i, s)) : false
  }
  Wte.exports = q3e
})
var zte = _((ZRt, Kte) => {
  "use strict"
  var V3e = Gte(),
    $te = $f()
  function Yte(e, t, r, n, i) {
    return e === t
      ? true
      : e == null || t == null || (!$te(e) && !$te(t))
        ? e !== e && t !== t
        : V3e(e, t, r, n, Yte, i)
  }
  Kte.exports = Yte
})
var jte = _((XRt, Jte) => {
  "use strict"
  var H3e = zte()
  function W3e(e, t) {
    return H3e(e, t)
  }
  Jte.exports = W3e
})
var Wn = _((eDt, Zte) => {
  "use strict"
  Zte.exports = {
    kClose: Symbol("close"),
    kDestroy: Symbol("destroy"),
    kDispatch: Symbol("dispatch"),
    kUrl: Symbol("url"),
    kWriting: Symbol("writing"),
    kResuming: Symbol("resuming"),
    kQueue: Symbol("queue"),
    kConnect: Symbol("connect"),
    kConnecting: Symbol("connecting"),
    kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
    kKeepAlive: Symbol("keep alive"),
    kHeadersTimeout: Symbol("headers timeout"),
    kBodyTimeout: Symbol("body timeout"),
    kServerName: Symbol("server name"),
    kLocalAddress: Symbol("local address"),
    kHost: Symbol("host"),
    kNoRef: Symbol("no ref"),
    kBodyUsed: Symbol("used"),
    kBody: Symbol("abstracted request body"),
    kRunning: Symbol("running"),
    kBlocking: Symbol("blocking"),
    kPending: Symbol("pending"),
    kSize: Symbol("size"),
    kBusy: Symbol("busy"),
    kQueued: Symbol("queued"),
    kFree: Symbol("free"),
    kConnected: Symbol("connected"),
    kClosed: Symbol("closed"),
    kNeedDrain: Symbol("need drain"),
    kReset: Symbol("reset"),
    kDestroyed: Symbol.for("nodejs.stream.destroyed"),
    kResume: Symbol("resume"),
    kOnError: Symbol("on error"),
    kMaxHeadersSize: Symbol("max headers size"),
    kRunningIdx: Symbol("running index"),
    kPendingIdx: Symbol("pending index"),
    kError: Symbol("error"),
    kClients: Symbol("clients"),
    kClient: Symbol("client"),
    kParser: Symbol("parser"),
    kOnDestroyed: Symbol("destroy callbacks"),
    kPipelining: Symbol("pipelining"),
    kSocket: Symbol("socket"),
    kHostHeader: Symbol("host header"),
    kConnector: Symbol("connector"),
    kStrictContentLength: Symbol("strict content length"),
    kMaxRedirections: Symbol("maxRedirections"),
    kMaxRequests: Symbol("maxRequestsPerClient"),
    kProxy: Symbol("proxy agent options"),
    kCounter: Symbol("socket request counter"),
    kInterceptors: Symbol("dispatch interceptors"),
    kMaxResponseSize: Symbol("max response size"),
    kHTTP2Session: Symbol("http2Session"),
    kHTTP2SessionState: Symbol("http2Session state"),
    kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
    kConstruct: Symbol("constructable"),
    kListeners: Symbol("listeners"),
    kHTTPContext: Symbol("http context"),
    kMaxConcurrentStreams: Symbol("max concurrent streams"),
    kNoProxyAgent: Symbol("no proxy agent"),
    kHttpProxyAgent: Symbol("http proxy agent"),
    kHttpsProxyAgent: Symbol("https proxy agent"),
  }
})
var Jr = _((tDt, Xte) => {
  "use strict"
  var zn = class extends Error {
      constructor(t) {
        super(t), (this.name = "UndiciError"), (this.code = "UND_ERR")
      }
    },
    iq = class extends zn {
      constructor(t) {
        super(t),
          (this.name = "ConnectTimeoutError"),
          (this.message = t || "Connect Timeout Error"),
          (this.code = "UND_ERR_CONNECT_TIMEOUT")
      }
    },
    sq = class extends zn {
      constructor(t) {
        super(t),
          (this.name = "HeadersTimeoutError"),
          (this.message = t || "Headers Timeout Error"),
          (this.code = "UND_ERR_HEADERS_TIMEOUT")
      }
    },
    oq = class extends zn {
      constructor(t) {
        super(t),
          (this.name = "HeadersOverflowError"),
          (this.message = t || "Headers Overflow Error"),
          (this.code = "UND_ERR_HEADERS_OVERFLOW")
      }
    },
    aq = class extends zn {
      constructor(t) {
        super(t),
          (this.name = "BodyTimeoutError"),
          (this.message = t || "Body Timeout Error"),
          (this.code = "UND_ERR_BODY_TIMEOUT")
      }
    },
    lq = class extends zn {
      constructor(t, r, n, i) {
        super(t),
          (this.name = "ResponseStatusCodeError"),
          (this.message = t || "Response Status Code Error"),
          (this.code = "UND_ERR_RESPONSE_STATUS_CODE"),
          (this.body = i),
          (this.status = r),
          (this.statusCode = r),
          (this.headers = n)
      }
    },
    cq = class extends zn {
      constructor(t) {
        super(t),
          (this.name = "InvalidArgumentError"),
          (this.message = t || "Invalid Argument Error"),
          (this.code = "UND_ERR_INVALID_ARG")
      }
    },
    uq = class extends zn {
      constructor(t) {
        super(t),
          (this.name = "InvalidReturnValueError"),
          (this.message = t || "Invalid Return Value Error"),
          (this.code = "UND_ERR_INVALID_RETURN_VALUE")
      }
    },
    sR = class extends zn {
      constructor(t) {
        super(t),
          (this.name = "AbortError"),
          (this.message = t || "The operation was aborted")
      }
    },
    dq = class extends sR {
      constructor(t) {
        super(t),
          (this.name = "AbortError"),
          (this.message = t || "Request aborted"),
          (this.code = "UND_ERR_ABORTED")
      }
    },
    fq = class extends zn {
      constructor(t) {
        super(t),
          (this.name = "InformationalError"),
          (this.message = t || "Request information"),
          (this.code = "UND_ERR_INFO")
      }
    },
    hq = class extends zn {
      constructor(t) {
        super(t),
          (this.name = "RequestContentLengthMismatchError"),
          (this.message =
            t || "Request body length does not match content-length header"),
          (this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH")
      }
    },
    gq = class extends zn {
      constructor(t) {
        super(t),
          (this.name = "ResponseContentLengthMismatchError"),
          (this.message =
            t || "Response body length does not match content-length header"),
          (this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH")
      }
    },
    pq = class extends zn {
      constructor(t) {
        super(t),
          (this.name = "ClientDestroyedError"),
          (this.message = t || "The client is destroyed"),
          (this.code = "UND_ERR_DESTROYED")
      }
    },
    mq = class extends zn {
      constructor(t) {
        super(t),
          (this.name = "ClientClosedError"),
          (this.message = t || "The client is closed"),
          (this.code = "UND_ERR_CLOSED")
      }
    },
    Aq = class extends zn {
      constructor(t, r) {
        super(t),
          (this.name = "SocketError"),
          (this.message = t || "Socket error"),
          (this.code = "UND_ERR_SOCKET"),
          (this.socket = r)
      }
    },
    yq = class extends zn {
      constructor(t) {
        super(t),
          (this.name = "NotSupportedError"),
          (this.message = t || "Not supported error"),
          (this.code = "UND_ERR_NOT_SUPPORTED")
      }
    },
    vq = class extends zn {
      constructor(t) {
        super(t),
          (this.name = "MissingUpstreamError"),
          (this.message =
            t || "No upstream has been added to the BalancedPool"),
          (this.code = "UND_ERR_BPL_MISSING_UPSTREAM")
      }
    },
    Cq = class extends Error {
      constructor(t, r, n) {
        super(t),
          (this.name = "HTTPParserError"),
          (this.code = r ? `HPE_${r}` : undefined),
          (this.data = n ? n.toString() : undefined)
      }
    },
    bq = class extends zn {
      constructor(t) {
        super(t),
          (this.name = "ResponseExceededMaxSizeError"),
          (this.message = t || "Response content exceeded max size"),
          (this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE")
      }
    },
    Eq = class extends zn {
      constructor(t, r, { headers: n, data: i }) {
        super(t),
          (this.name = "RequestRetryError"),
          (this.message = t || "Request retry error"),
          (this.code = "UND_ERR_REQ_RETRY"),
          (this.statusCode = r),
          (this.data = i),
          (this.headers = n)
      }
    },
    _q = class extends zn {
      constructor(t, r, { headers: n, data: i }) {
        super(t),
          (this.name = "ResponseError"),
          (this.message = t || "Response error"),
          (this.code = "UND_ERR_RESPONSE"),
          (this.statusCode = r),
          (this.data = i),
          (this.headers = n)
      }
    },
    xq = class extends zn {
      constructor(t, r, n) {
        super(r, { cause: t, ...(n ?? {}) }),
          (this.name = "SecureProxyConnectionError"),
          (this.message = r || "Secure Proxy Connection failed"),
          (this.code = "UND_ERR_PRX_TLS"),
          (this.cause = t)
      }
    }
  Xte.exports = {
    AbortError: sR,
    HTTPParserError: Cq,
    UndiciError: zn,
    HeadersTimeoutError: sq,
    HeadersOverflowError: oq,
    BodyTimeoutError: aq,
    RequestContentLengthMismatchError: hq,
    ConnectTimeoutError: iq,
    ResponseStatusCodeError: lq,
    InvalidArgumentError: cq,
    InvalidReturnValueError: uq,
    RequestAbortedError: dq,
    ClientDestroyedError: pq,
    ClientClosedError: mq,
    InformationalError: fq,
    SocketError: Aq,
    NotSupportedError: yq,
    ResponseContentLengthMismatchError: gq,
    BalancedPoolMissingUpstreamError: vq,
    ResponseExceededMaxSizeError: bq,
    RequestRetryError: Eq,
    ResponseError: _q,
    SecureProxyConnectionError: xq,
  }
})
var aR = _((rDt, ere) => {
  "use strict"
  var oR = {},
    wq = [
      "Accept",
      "Accept-Encoding",
      "Accept-Language",
      "Accept-Ranges",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Age",
      "Allow",
      "Alt-Svc",
      "Alt-Used",
      "Authorization",
      "Cache-Control",
      "Clear-Site-Data",
      "Connection",
      "Content-Disposition",
      "Content-Encoding",
      "Content-Language",
      "Content-Length",
      "Content-Location",
      "Content-Range",
      "Content-Security-Policy",
      "Content-Security-Policy-Report-Only",
      "Content-Type",
      "Cookie",
      "Cross-Origin-Embedder-Policy",
      "Cross-Origin-Opener-Policy",
      "Cross-Origin-Resource-Policy",
      "Date",
      "Device-Memory",
      "Downlink",
      "ECT",
      "ETag",
      "Expect",
      "Expect-CT",
      "Expires",
      "Forwarded",
      "From",
      "Host",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Range",
      "If-Unmodified-Since",
      "Keep-Alive",
      "Last-Modified",
      "Link",
      "Location",
      "Max-Forwards",
      "Origin",
      "Permissions-Policy",
      "Pragma",
      "Proxy-Authenticate",
      "Proxy-Authorization",
      "RTT",
      "Range",
      "Referer",
      "Referrer-Policy",
      "Refresh",
      "Retry-After",
      "Sec-WebSocket-Accept",
      "Sec-WebSocket-Extensions",
      "Sec-WebSocket-Key",
      "Sec-WebSocket-Protocol",
      "Sec-WebSocket-Version",
      "Server",
      "Server-Timing",
      "Service-Worker-Allowed",
      "Service-Worker-Navigation-Preload",
      "Set-Cookie",
      "SourceMap",
      "Strict-Transport-Security",
      "Supports-Loading-Mode",
      "TE",
      "Timing-Allow-Origin",
      "Trailer",
      "Transfer-Encoding",
      "Upgrade",
      "Upgrade-Insecure-Requests",
      "User-Agent",
      "Vary",
      "Via",
      "WWW-Authenticate",
      "X-Content-Type-Options",
      "X-DNS-Prefetch-Control",
      "X-Frame-Options",
      "X-Permitted-Cross-Domain-Policies",
      "X-Powered-By",
      "X-Requested-With",
      "X-XSS-Protection",
    ]
  for (let e = 0; e < wq.length; ++e) {
    let t = wq[e],
      r = t.toLowerCase()
    oR[t] = oR[r] = r
  }
  Object.setPrototypeOf(oR, null)
  ere.exports = { wellknownHeaderNames: wq, headerNameLowerCasedRecord: oR }
})
var ire = _((nDt, nre) => {
  "use strict"
  var { wellknownHeaderNames: tre, headerNameLowerCasedRecord: G3e } = aR(),
    Sq = class e {
      value = null
      left = null
      middle = null
      right = null
      code
      constructor(t, r, n) {
        if (n === undefined || n >= t.length) throw new TypeError("Unreachable")
        if ((this.code = t.charCodeAt(n)) > 127)
          throw new TypeError("key must be ascii string")
        t.length !== ++n ? (this.middle = new e(t, r, n)) : (this.value = r)
      }
      add(t, r) {
        let n = t.length
        if (n === 0) throw new TypeError("Unreachable")
        let i = 0,
          s = this
        for (;;) {
          let o = t.charCodeAt(i)
          if (o > 127) throw new TypeError("key must be ascii string")
          if (s.code === o)
            if (n === ++i) {
              s.value = r
              break
            } else if (s.middle !== null) s = s.middle
            else {
              s.middle = new e(t, r, i)
              break
            }
          else if (s.code < o)
            if (s.left !== null) s = s.left
            else {
              s.left = new e(t, r, i)
              break
            }
          else if (s.right !== null) s = s.right
          else {
            s.right = new e(t, r, i)
            break
          }
        }
      }
      search(t) {
        let r = t.length,
          n = 0,
          i = this
        for (; i !== null && n < r; ) {
          let s = t[n]
          for (s <= 90 && s >= 65 && (s |= 32); i !== null; ) {
            if (s === i.code) {
              if (r === ++n) return i
              i = i.middle
              break
            }
            i = i.code < s ? i.left : i.right
          }
        }
        return null
      }
    },
    lR = class {
      node = null
      insert(t, r) {
        this.node === null ? (this.node = new Sq(t, r, 0)) : this.node.add(t, r)
      }
      lookup(t) {
        return this.node?.search(t)?.value ?? null
      }
    },
    rre = new lR()
  for (let e = 0; e < tre.length; ++e) {
    let t = G3e[tre[e]]
    rre.insert(t, t)
  }
  nre.exports = { TernarySearchTree: lR, tree: rre }
})
var ir = _((iDt, Cre) => {
  "use strict"
  var cE = require("assert"),
    { kDestroyed: ore, kBodyUsed: E0, kListeners: Iq, kBody: sre } = Wn(),
    { IncomingMessage: $3e } = require("http"),
    dR = require("stream"),
    Y3e = require("net"),
    { Blob: K3e } = require("buffer"),
    z3e = require("util"),
    { stringify: J3e } = require("querystring"),
    { EventEmitter: j3e } = require("events"),
    { InvalidArgumentError: ts } = Jr(),
    { headerNameLowerCasedRecord: Z3e } = aR(),
    { tree: are } = ire(),
    [X3e, eGe] = process.versions.node.split(".").map((e) => Number(e)),
    uR = class {
      constructor(t) {
        ;(this[sre] = t), (this[E0] = false)
      }
      async *[Symbol.asyncIterator]() {
        cE(!this[E0], "disturbed"), (this[E0] = true), yield* this[sre]
      }
    }
  function tGe(e) {
    return fR(e)
      ? (fre(e) === 0 &&
          e.on("data", function () {
            cE(false)
          }),
        typeof e.readableDidRead != "boolean" &&
          ((e[E0] = false),
          j3e.prototype.on.call(e, "data", function () {
            this[E0] = true
          })),
        e)
      : e && typeof e.pipeTo == "function"
        ? new uR(e)
        : e && typeof e != "string" && !ArrayBuffer.isView(e) && dre(e)
          ? new uR(e)
          : e
  }
  function rGe() {}
  function fR(e) {
    return (
      e &&
      typeof e == "object" &&
      typeof e.pipe == "function" &&
      typeof e.on == "function"
    )
  }
  function lre(e) {
    if (e === null) return false
    if (e instanceof K3e) return true
    if (typeof e != "object") return false
    {
      let t = e[Symbol.toStringTag]
      return (
        (t === "Blob" || t === "File") &&
        (("stream" in e && typeof e.stream == "function") ||
          ("arrayBuffer" in e && typeof e.arrayBuffer == "function"))
      )
    }
  }
  function nGe(e, t) {
    if (e.includes("?") || e.includes("#"))
      throw new Error(
        'Query params cannot be passed when url already contains "?" or "#".',
      )
    let r = J3e(t)
    return r && (e += "?" + r), e
  }
  function cre(e) {
    let t = parseInt(e, 10)
    return t === Number(e) && t >= 0 && t <= 65535
  }
  function cR(e) {
    return (
      e != null &&
      e[0] === "h" &&
      e[1] === "t" &&
      e[2] === "t" &&
      e[3] === "p" &&
      (e[4] === ":" || (e[4] === "s" && e[5] === ":"))
    )
  }
  function ure(e) {
    if (typeof e == "string") {
      if (((e = new URL(e)), !cR(e.origin || e.protocol)))
        throw new ts(
          "Invalid URL protocol: the URL must start with `http:` or `https:`.",
        )
      return e
    }
    if (!e || typeof e != "object")
      throw new ts("Invalid URL: The URL argument must be a non-null object.")
    if (!(e instanceof URL)) {
      if (e.port != null && e.port !== "" && cre(e.port) === false)
        throw new ts(
          "Invalid URL: port must be a valid integer or a string representation of an integer.",
        )
      if (e.path != null && typeof e.path != "string")
        throw new ts(
          "Invalid URL path: the path must be a string or null/undefined.",
        )
      if (e.pathname != null && typeof e.pathname != "string")
        throw new ts(
          "Invalid URL pathname: the pathname must be a string or null/undefined.",
        )
      if (e.hostname != null && typeof e.hostname != "string")
        throw new ts(
          "Invalid URL hostname: the hostname must be a string or null/undefined.",
        )
      if (e.origin != null && typeof e.origin != "string")
        throw new ts(
          "Invalid URL origin: the origin must be a string or null/undefined.",
        )
      if (!cR(e.origin || e.protocol))
        throw new ts(
          "Invalid URL protocol: the URL must start with `http:` or `https:`.",
        )
      let t = e.port != null ? e.port : e.protocol === "https:" ? 443 : 80,
        r =
          e.origin != null
            ? e.origin
            : `${e.protocol || ""}//${e.hostname || ""}:${t}`,
        n = e.path != null ? e.path : `${e.pathname || ""}${e.search || ""}`
      return (
        r[r.length - 1] === "/" && (r = r.slice(0, r.length - 1)),
        n && n[0] !== "/" && (n = `/${n}`),
        new URL(`${r}${n}`)
      )
    }
    if (!cR(e.origin || e.protocol))
      throw new ts(
        "Invalid URL protocol: the URL must start with `http:` or `https:`.",
      )
    return e
  }
  function iGe(e) {
    if (((e = ure(e)), e.pathname !== "/" || e.search || e.hash))
      throw new ts("invalid url")
    return e
  }
  function sGe(e) {
    if (e[0] === "[") {
      let r = e.indexOf("]")
      return cE(r !== -1), e.substring(1, r)
    }
    let t = e.indexOf(":")
    return t === -1 ? e : e.substring(0, t)
  }
  function oGe(e) {
    if (!e) return null
    cE(typeof e == "string")
    let t = sGe(e)
    return Y3e.isIP(t) ? "" : t
  }
  function aGe(e) {
    return JSON.parse(JSON.stringify(e))
  }
  function lGe(e) {
    return e != null && typeof e[Symbol.asyncIterator] == "function"
  }
  function dre(e) {
    return (
      e != null &&
      (typeof e[Symbol.iterator] == "function" ||
        typeof e[Symbol.asyncIterator] == "function")
    )
  }
  function fre(e) {
    if (e == null) return 0
    if (fR(e)) {
      let t = e._readableState
      return t &&
        t.objectMode === false &&
        t.ended === true &&
        Number.isFinite(t.length)
        ? t.length
        : null
    } else {
      if (lre(e)) return e.size != null ? e.size : null
      if (pre(e)) return e.byteLength
    }
    return null
  }
  function hre(e) {
    return e && !!(e.destroyed || e[ore] || dR.isDestroyed?.(e))
  }
  function cGe(e, t) {
    e == null ||
      !fR(e) ||
      hre(e) ||
      (typeof e.destroy == "function"
        ? (Object.getPrototypeOf(e).constructor === $3e && (e.socket = null),
          e.destroy(t))
        : t &&
          queueMicrotask(() => {
            e.emit("error", t)
          }),
      e.destroyed !== true && (e[ore] = true))
  }
  var uGe = /timeout=(\d+)/
  function dGe(e) {
    let t = e.toString().match(uGe)
    return t ? parseInt(t[1], 10) * 1e3 : null
  }
  function gre(e) {
    return typeof e == "string"
      ? (Z3e[e] ?? e.toLowerCase())
      : (are.lookup(e) ?? e.toString("latin1").toLowerCase())
  }
  function fGe(e) {
    return are.lookup(e) ?? e.toString("latin1").toLowerCase()
  }
  function hGe(e, t) {
    t === undefined && (t = {})
    for (let r = 0; r < e.length; r += 2) {
      let n = gre(e[r]),
        i = t[n]
      if (i)
        typeof i == "string" && ((i = [i]), (t[n] = i)),
          i.push(e[r + 1].toString("utf8"))
      else {
        let s = e[r + 1]
        typeof s == "string"
          ? (t[n] = s)
          : (t[n] = Array.isArray(s)
              ? s.map((o) => o.toString("utf8"))
              : s.toString("utf8"))
      }
    }
    return (
      "content-length" in t &&
        "content-disposition" in t &&
        (t["content-disposition"] = Buffer.from(
          t["content-disposition"],
        ).toString("latin1")),
      t
    )
  }
  function gGe(e) {
    let t = e.length,
      r = new Array(t),
      n = false,
      i = -1,
      s,
      o,
      a = 0
    for (let l = 0; l < e.length; l += 2)
      (s = e[l]),
        (o = e[l + 1]),
        typeof s != "string" && (s = s.toString()),
        typeof o != "string" && (o = o.toString("utf8")),
        (a = s.length),
        a === 14 &&
        s[7] === "-" &&
        (s === "content-length" || s.toLowerCase() === "content-length")
          ? (n = true)
          : a === 19 &&
            s[7] === "-" &&
            (s === "content-disposition" ||
              s.toLowerCase() === "content-disposition") &&
            (i = l + 1),
        (r[l] = s),
        (r[l + 1] = o)
    return n && i !== -1 && (r[i] = Buffer.from(r[i]).toString("latin1")), r
  }
  function pre(e) {
    return e instanceof Uint8Array || Buffer.isBuffer(e)
  }
  function pGe(e, t, r) {
    if (!e || typeof e != "object") throw new ts("handler must be an object")
    if (typeof e.onConnect != "function")
      throw new ts("invalid onConnect method")
    if (typeof e.onError != "function") throw new ts("invalid onError method")
    if (typeof e.onBodySent != "function" && e.onBodySent !== undefined)
      throw new ts("invalid onBodySent method")
    if (r || t === "CONNECT") {
      if (typeof e.onUpgrade != "function")
        throw new ts("invalid onUpgrade method")
    } else {
      if (typeof e.onHeaders != "function")
        throw new ts("invalid onHeaders method")
      if (typeof e.onData != "function") throw new ts("invalid onData method")
      if (typeof e.onComplete != "function")
        throw new ts("invalid onComplete method")
    }
  }
  function mGe(e) {
    return !!(e && (dR.isDisturbed(e) || e[E0]))
  }
  function AGe(e) {
    return !!(e && dR.isErrored(e))
  }
  function yGe(e) {
    return !!(e && dR.isReadable(e))
  }
  function vGe(e) {
    return {
      localAddress: e.localAddress,
      localPort: e.localPort,
      remoteAddress: e.remoteAddress,
      remotePort: e.remotePort,
      remoteFamily: e.remoteFamily,
      timeout: e.timeout,
      bytesWritten: e.bytesWritten,
      bytesRead: e.bytesRead,
    }
  }
  function CGe(e) {
    let t
    return new ReadableStream({
      async start() {
        t = e[Symbol.asyncIterator]()
      },
      async pull(r) {
        let { done: n, value: i } = await t.next()
        if (n)
          queueMicrotask(() => {
            r.close(), r.byobRequest?.respond(0)
          })
        else {
          let s = Buffer.isBuffer(i) ? i : Buffer.from(i)
          s.byteLength && r.enqueue(new Uint8Array(s))
        }
        return r.desiredSize > 0
      },
      async cancel(r) {
        await t.return()
      },
      type: "bytes",
    })
  }
  function bGe(e) {
    return (
      e &&
      typeof e == "object" &&
      typeof e.append == "function" &&
      typeof e.delete == "function" &&
      typeof e.get == "function" &&
      typeof e.getAll == "function" &&
      typeof e.has == "function" &&
      typeof e.set == "function" &&
      e[Symbol.toStringTag] === "FormData"
    )
  }
  function EGe(e, t) {
    return "addEventListener" in e
      ? (e.addEventListener("abort", t, { once: true }),
        () => e.removeEventListener("abort", t))
      : (e.addListener("abort", t), () => e.removeListener("abort", t))
  }
  var _Ge = typeof String.prototype.toWellFormed == "function",
    xGe = typeof String.prototype.isWellFormed == "function"
  function mre(e) {
    return _Ge ? `${e}`.toWellFormed() : z3e.toUSVString(e)
  }
  function wGe(e) {
    return xGe ? `${e}`.isWellFormed() : mre(e) === `${e}`
  }
  function Are(e) {
    switch (e) {
      case 34:
      case 40:
      case 41:
      case 44:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 123:
      case 125:
        return false
      default:
        return e >= 33 && e <= 126
    }
  }
  function SGe(e) {
    if (e.length === 0) return false
    for (let t = 0; t < e.length; ++t) if (!Are(e.charCodeAt(t))) return false
    return true
  }
  var IGe = /[^\t\x20-\x7e\x80-\xff]/
  function BGe(e) {
    return !IGe.test(e)
  }
  function RGe(e) {
    if (e == null || e === "") return { start: 0, end: null, size: null }
    let t = e ? e.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null
    return t
      ? {
          start: parseInt(t[1]),
          end: t[2] ? parseInt(t[2]) : null,
          size: t[3] ? parseInt(t[3]) : null,
        }
      : null
  }
  function DGe(e, t, r) {
    return (e[Iq] ??= []).push([t, r]), e.on(t, r), e
  }
  function TGe(e) {
    for (let [t, r] of e[Iq] ?? []) e.removeListener(t, r)
    e[Iq] = null
  }
  function kGe(e, t, r) {
    try {
      t.onError(r), cE(t.aborted)
    } catch (n) {
      e.emit("error", n)
    }
  }
  var yre = Object.create(null)
  yre.enumerable = true
  var Bq = {
      delete: "DELETE",
      DELETE: "DELETE",
      get: "GET",
      GET: "GET",
      head: "HEAD",
      HEAD: "HEAD",
      options: "OPTIONS",
      OPTIONS: "OPTIONS",
      post: "POST",
      POST: "POST",
      put: "PUT",
      PUT: "PUT",
    },
    vre = { ...Bq, patch: "patch", PATCH: "PATCH" }
  Object.setPrototypeOf(Bq, null)
  Object.setPrototypeOf(vre, null)
  Cre.exports = {
    kEnumerableProperty: yre,
    nop: rGe,
    isDisturbed: mGe,
    isErrored: AGe,
    isReadable: yGe,
    toUSVString: mre,
    isUSVString: wGe,
    isBlobLike: lre,
    parseOrigin: iGe,
    parseURL: ure,
    getServerName: oGe,
    isStream: fR,
    isIterable: dre,
    isAsyncIterable: lGe,
    isDestroyed: hre,
    headerNameToString: gre,
    bufferToLowerCasedHeaderName: fGe,
    addListener: DGe,
    removeAllListeners: TGe,
    errorRequest: kGe,
    parseRawHeaders: gGe,
    parseHeaders: hGe,
    parseKeepAliveTimeout: dGe,
    destroy: cGe,
    bodyLength: fre,
    deepClone: aGe,
    ReadableStreamFrom: CGe,
    isBuffer: pre,
    validateHandler: pGe,
    getSocketInfo: vGe,
    isFormDataLike: bGe,
    buildURL: nGe,
    addAbortListener: EGe,
    isValidHTTPToken: SGe,
    isValidHeaderValue: BGe,
    isTokenCharCode: Are,
    parseRangeHeader: RGe,
    normalizedMethodRecordsBase: Bq,
    normalizedMethodRecords: vre,
    isValidPort: cre,
    isHttpOrHttpsPrefixed: cR,
    nodeMajor: X3e,
    nodeMinor: eGe,
    safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"],
    wrapRequestBody: tGe,
  }
})
var _0 = _((sDt, Ere) => {
  "use strict"
  var nn = require("diagnostics_channel"),
    Dq = require("util"),
    hR = Dq.debuglog("undici"),
    Rq = Dq.debuglog("fetch"),
    Cp = Dq.debuglog("websocket"),
    bre = false,
    MGe = {
      beforeConnect: nn.channel("undici:client:beforeConnect"),
      connected: nn.channel("undici:client:connected"),
      connectError: nn.channel("undici:client:connectError"),
      sendHeaders: nn.channel("undici:client:sendHeaders"),
      create: nn.channel("undici:request:create"),
      bodySent: nn.channel("undici:request:bodySent"),
      headers: nn.channel("undici:request:headers"),
      trailers: nn.channel("undici:request:trailers"),
      error: nn.channel("undici:request:error"),
      open: nn.channel("undici:websocket:open"),
      close: nn.channel("undici:websocket:close"),
      socketError: nn.channel("undici:websocket:socket_error"),
      ping: nn.channel("undici:websocket:ping"),
      pong: nn.channel("undici:websocket:pong"),
    }
  if (hR.enabled || Rq.enabled) {
    let e = Rq.enabled ? Rq : hR
    nn.channel("undici:client:beforeConnect").subscribe((t) => {
      let {
        connectParams: { version: r, protocol: n, port: i, host: s },
      } = t
      e("connecting to %s using %s%s", `${s}${i ? `:${i}` : ""}`, n, r)
    }),
      nn.channel("undici:client:connected").subscribe((t) => {
        let {
          connectParams: { version: r, protocol: n, port: i, host: s },
        } = t
        e("connected to %s using %s%s", `${s}${i ? `:${i}` : ""}`, n, r)
      }),
      nn.channel("undici:client:connectError").subscribe((t) => {
        let {
          connectParams: { version: r, protocol: n, port: i, host: s },
          error: o,
        } = t
        e(
          "connection to %s using %s%s errored - %s",
          `${s}${i ? `:${i}` : ""}`,
          n,
          r,
          o.message,
        )
      }),
      nn.channel("undici:client:sendHeaders").subscribe((t) => {
        let {
          request: { method: r, path: n, origin: i },
        } = t
        e("sending request to %s %s/%s", r, i, n)
      }),
      nn.channel("undici:request:headers").subscribe((t) => {
        let {
          request: { method: r, path: n, origin: i },
          response: { statusCode: s },
        } = t
        e("received response to %s %s/%s - HTTP %d", r, i, n, s)
      }),
      nn.channel("undici:request:trailers").subscribe((t) => {
        let {
          request: { method: r, path: n, origin: i },
        } = t
        e("trailers received from %s %s/%s", r, i, n)
      }),
      nn.channel("undici:request:error").subscribe((t) => {
        let {
          request: { method: r, path: n, origin: i },
          error: s,
        } = t
        e("request to %s %s/%s errored - %s", r, i, n, s.message)
      }),
      (bre = true)
  }
  if (Cp.enabled) {
    if (!bre) {
      let e = hR.enabled ? hR : Cp
      nn.channel("undici:client:beforeConnect").subscribe((t) => {
        let {
          connectParams: { version: r, protocol: n, port: i, host: s },
        } = t
        e("connecting to %s%s using %s%s", s, i ? `:${i}` : "", n, r)
      }),
        nn.channel("undici:client:connected").subscribe((t) => {
          let {
            connectParams: { version: r, protocol: n, port: i, host: s },
          } = t
          e("connected to %s%s using %s%s", s, i ? `:${i}` : "", n, r)
        }),
        nn.channel("undici:client:connectError").subscribe((t) => {
          let {
            connectParams: { version: r, protocol: n, port: i, host: s },
            error: o,
          } = t
          e(
            "connection to %s%s using %s%s errored - %s",
            s,
            i ? `:${i}` : "",
            n,
            r,
            o.message,
          )
        }),
        nn.channel("undici:client:sendHeaders").subscribe((t) => {
          let {
            request: { method: r, path: n, origin: i },
          } = t
          e("sending request to %s %s/%s", r, i, n)
        })
    }
    nn.channel("undici:websocket:open").subscribe((e) => {
      let {
        address: { address: t, port: r },
      } = e
      Cp("connection opened %s%s", t, r ? `:${r}` : "")
    }),
      nn.channel("undici:websocket:close").subscribe((e) => {
        let { websocket: t, code: r, reason: n } = e
        Cp("closed connection to %s - %s %s", t.url, r, n)
      }),
      nn.channel("undici:websocket:socket_error").subscribe((e) => {
        Cp("connection errored - %s", e.message)
      }),
      nn.channel("undici:websocket:ping").subscribe((e) => {
        Cp("ping received")
      }),
      nn.channel("undici:websocket:pong").subscribe((e) => {
        Cp("pong received")
      })
  }
  Ere.exports = { channels: MGe }
})
var Ire = _((oDt, Sre) => {
  "use strict"
  var { InvalidArgumentError: Jn, NotSupportedError: FGe } = Jr(),
    Ld = require("assert"),
    {
      isValidHTTPToken: wre,
      isValidHeaderValue: _re,
      isStream: QGe,
      destroy: NGe,
      isBuffer: PGe,
      isFormDataLike: LGe,
      isIterable: UGe,
      isBlobLike: OGe,
      buildURL: qGe,
      validateHandler: VGe,
      getServerName: HGe,
      normalizedMethodRecords: WGe,
    } = ir(),
    { channels: Cu } = _0(),
    { headerNameLowerCasedRecord: xre } = aR(),
    GGe = /[^\u0021-\u00ff]/,
    _l = Symbol("handler"),
    Tq = class {
      constructor(
        t,
        {
          path: r,
          method: n,
          body: i,
          headers: s,
          query: o,
          idempotent: a,
          blocking: l,
          upgrade: c,
          headersTimeout: u,
          bodyTimeout: f,
          reset: p,
          throwOnError: g,
          expectContinue: m,
          servername: y,
        },
        v,
      ) {
        if (typeof r != "string") throw new Jn("path must be a string")
        if (
          r[0] !== "/" &&
          !(r.startsWith("http://") || r.startsWith("https://")) &&
          n !== "CONNECT"
        )
          throw new Jn("path must be an absolute URL or start with a slash")
        if (GGe.test(r)) throw new Jn("invalid request path")
        if (typeof n != "string") throw new Jn("method must be a string")
        if (WGe[n] === undefined && !wre(n)) throw new Jn("invalid request method")
        if (c && typeof c != "string") throw new Jn("upgrade must be a string")
        if (u != null && (!Number.isFinite(u) || u < 0))
          throw new Jn("invalid headersTimeout")
        if (f != null && (!Number.isFinite(f) || f < 0))
          throw new Jn("invalid bodyTimeout")
        if (p != null && typeof p != "boolean") throw new Jn("invalid reset")
        if (m != null && typeof m != "boolean")
          throw new Jn("invalid expectContinue")
        if (
          ((this.headersTimeout = u),
          (this.bodyTimeout = f),
          (this.throwOnError = g === true),
          (this.method = n),
          (this.abort = null),
          i == null)
        )
          this.body = null
        else if (QGe(i)) {
          this.body = i
          let C = this.body._readableState
          ;(!C || !C.autoDestroy) &&
            ((this.endHandler = function () {
              NGe(this)
            }),
            this.body.on("end", this.endHandler)),
            (this.errorHandler = (E) => {
              this.abort ? this.abort(E) : (this.error = E)
            }),
            this.body.on("error", this.errorHandler)
        } else if (PGe(i)) this.body = i.byteLength ? i : null
        else if (ArrayBuffer.isView(i))
          this.body = i.buffer.byteLength
            ? Buffer.from(i.buffer, i.byteOffset, i.byteLength)
            : null
        else if (i instanceof ArrayBuffer)
          this.body = i.byteLength ? Buffer.from(i) : null
        else if (typeof i == "string")
          this.body = i.length ? Buffer.from(i) : null
        else if (LGe(i) || UGe(i) || OGe(i)) this.body = i
        else
          throw new Jn(
            "body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable",
          )
        if (
          ((this.completed = false),
          (this.aborted = false),
          (this.upgrade = c || null),
          (this.path = o ? qGe(r, o) : r),
          (this.origin = t),
          (this.idempotent = a ?? (n === "HEAD" || n === "GET")),
          (this.blocking = l ?? false),
          (this.reset = p ?? null),
          (this.host = null),
          (this.contentLength = null),
          (this.contentType = null),
          (this.headers = []),
          (this.expectContinue = m ?? false),
          Array.isArray(s))
        ) {
          if (s.length % 2 !== 0) throw new Jn("headers array must be even")
          for (let C = 0; C < s.length; C += 2) gR(this, s[C], s[C + 1])
        } else if (s && typeof s == "object")
          if (s[Symbol.iterator])
            for (let C of s) {
              if (!Array.isArray(C) || C.length !== 2)
                throw new Jn("headers must be in key-value pair format")
              gR(this, C[0], C[1])
            }
          else {
            let C = Object.keys(s)
            for (let E = 0; E < C.length; ++E) gR(this, C[E], s[C[E]])
          }
        else if (s != null)
          throw new Jn("headers must be an object or an array")
        VGe(v, n, c),
          (this.servername = y || HGe(this.host)),
          (this[_l] = v),
          Cu.create.hasSubscribers && Cu.create.publish({ request: this })
      }
      onBodySent(t) {
        if (this[_l].onBodySent)
          try {
            return this[_l].onBodySent(t)
          } catch (r) {
            this.abort(r)
          }
      }
      onRequestSent() {
        if (
          (Cu.bodySent.hasSubscribers && Cu.bodySent.publish({ request: this }),
          this[_l].onRequestSent)
        )
          try {
            return this[_l].onRequestSent()
          } catch (t) {
            this.abort(t)
          }
      }
      onConnect(t) {
        if ((Ld(!this.aborted), Ld(!this.completed), this.error)) t(this.error)
        else return (this.abort = t), this[_l].onConnect(t)
      }
      onResponseStarted() {
        return this[_l].onResponseStarted?.()
      }
      onHeaders(t, r, n, i) {
        Ld(!this.aborted),
          Ld(!this.completed),
          Cu.headers.hasSubscribers &&
            Cu.headers.publish({
              request: this,
              response: { statusCode: t, headers: r, statusText: i },
            })
        try {
          return this[_l].onHeaders(t, r, n, i)
        } catch (s) {
          this.abort(s)
        }
      }
      onData(t) {
        Ld(!this.aborted), Ld(!this.completed)
        try {
          return this[_l].onData(t)
        } catch (r) {
          return this.abort(r), false
        }
      }
      onUpgrade(t, r, n) {
        return (
          Ld(!this.aborted), Ld(!this.completed), this[_l].onUpgrade(t, r, n)
        )
      }
      onComplete(t) {
        this.onFinally(),
          Ld(!this.aborted),
          (this.completed = true),
          Cu.trailers.hasSubscribers &&
            Cu.trailers.publish({ request: this, trailers: t })
        try {
          return this[_l].onComplete(t)
        } catch (r) {
          this.onError(r)
        }
      }
      onError(t) {
        if (
          (this.onFinally(),
          Cu.error.hasSubscribers &&
            Cu.error.publish({ request: this, error: t }),
          !this.aborted)
        )
          return (this.aborted = true), this[_l].onError(t)
      }
      onFinally() {
        this.errorHandler &&
          (this.body.off("error", this.errorHandler),
          (this.errorHandler = null)),
          this.endHandler &&
            (this.body.off("end", this.endHandler), (this.endHandler = null))
      }
      addHeader(t, r) {
        return gR(this, t, r), this
      }
    }
  function gR(e, t, r) {
    if (r && typeof r == "object" && !Array.isArray(r))
      throw new Jn(`invalid ${t} header`)
    if (r === undefined) return
    let n = xre[t]
    if (n === undefined && ((n = t.toLowerCase()), xre[n] === undefined && !wre(n)))
      throw new Jn("invalid header key")
    if (Array.isArray(r)) {
      let i = []
      for (let s = 0; s < r.length; s++)
        if (typeof r[s] == "string") {
          if (!_re(r[s])) throw new Jn(`invalid ${t} header`)
          i.push(r[s])
        } else if (r[s] === null) i.push("")
        else {
          if (typeof r[s] == "object") throw new Jn(`invalid ${t} header`)
          i.push(`${r[s]}`)
        }
      r = i
    } else if (typeof r == "string") {
      if (!_re(r)) throw new Jn(`invalid ${t} header`)
    } else r === null ? (r = "") : (r = `${r}`)
    if (e.host === null && n === "host") {
      if (typeof r != "string") throw new Jn("invalid host header")
      e.host = r
    } else if (e.contentLength === null && n === "content-length") {
      if (
        ((e.contentLength = parseInt(r, 10)), !Number.isFinite(e.contentLength))
      )
        throw new Jn("invalid content-length header")
    } else if (e.contentType === null && n === "content-type")
      (e.contentType = r), e.headers.push(t, r)
    else {
      if (n === "transfer-encoding" || n === "keep-alive" || n === "upgrade")
        throw new Jn(`invalid ${n} header`)
      if (n === "connection") {
        let i = typeof r == "string" ? r.toLowerCase() : null
        if (i !== "close" && i !== "keep-alive")
          throw new Jn("invalid connection header")
        i === "close" && (e.reset = true)
      } else {
        if (n === "expect") throw new FGe("expect header not supported")
        e.headers.push(t, r)
      }
    }
  }
  Sre.exports = Tq
})
var uE = _((aDt, Bre) => {
  "use strict"
  var $Ge = require("events"),
    pR = class extends $Ge {
      dispatch() {
        throw new Error("not implemented")
      }
      close() {
        throw new Error("not implemented")
      }
      destroy() {
        throw new Error("not implemented")
      }
      compose(...t) {
        let r = Array.isArray(t[0]) ? t[0] : t,
          n = this.dispatch.bind(this)
        for (let i of r)
          if (i != null) {
            if (typeof i != "function")
              throw new TypeError(
                `invalid interceptor, expected function received ${typeof i}`,
              )
            if (
              ((n = i(n)),
              n == null || typeof n != "function" || n.length !== 2)
            )
              throw new TypeError("invalid interceptor")
          }
        return new kq(this, n)
      }
    },
    kq = class extends pR {
      #e = null
      #t = null
      constructor(t, r) {
        super(), (this.#e = t), (this.#t = r)
      }
      dispatch(...t) {
        this.#t(...t)
      }
      close(...t) {
        return this.#e.close(...t)
      }
      destroy(...t) {
        return this.#e.destroy(...t)
      }
    }
  Bre.exports = pR
})
var I0 = _((lDt, Rre) => {
  "use strict"
  var YGe = uE(),
    {
      ClientDestroyedError: Mq,
      ClientClosedError: KGe,
      InvalidArgumentError: x0,
    } = Jr(),
    {
      kDestroy: zGe,
      kClose: JGe,
      kClosed: dE,
      kDestroyed: w0,
      kDispatch: Fq,
      kInterceptors: bp,
    } = Wn(),
    Ud = Symbol("onDestroyed"),
    S0 = Symbol("onClosed"),
    mR = Symbol("Intercepted Dispatch"),
    Qq = class extends YGe {
      constructor() {
        super(),
          (this[w0] = false),
          (this[Ud] = null),
          (this[dE] = false),
          (this[S0] = [])
      }
      get destroyed() {
        return this[w0]
      }
      get closed() {
        return this[dE]
      }
      get interceptors() {
        return this[bp]
      }
      set interceptors(t) {
        if (t) {
          for (let r = t.length - 1; r >= 0; r--)
            if (typeof this[bp][r] != "function")
              throw new x0("interceptor must be an function")
        }
        this[bp] = t
      }
      close(t) {
        if (t === undefined)
          return new Promise((n, i) => {
            this.close((s, o) => (s ? i(s) : n(o)))
          })
        if (typeof t != "function") throw new x0("invalid callback")
        if (this[w0]) {
          queueMicrotask(() => t(new Mq(), null))
          return
        }
        if (this[dE]) {
          this[S0] ? this[S0].push(t) : queueMicrotask(() => t(null, null))
          return
        }
        ;(this[dE] = true), this[S0].push(t)
        let r = () => {
          let n = this[S0]
          this[S0] = null
          for (let i = 0; i < n.length; i++) n[i](null, null)
        }
        this[JGe]()
          .then(() => this.destroy())
          .then(() => {
            queueMicrotask(r)
          })
      }
      destroy(t, r) {
        if ((typeof t == "function" && ((r = t), (t = null)), r === undefined))
          return new Promise((i, s) => {
            this.destroy(t, (o, a) => (o ? s(o) : i(a)))
          })
        if (typeof r != "function") throw new x0("invalid callback")
        if (this[w0]) {
          this[Ud] ? this[Ud].push(r) : queueMicrotask(() => r(null, null))
          return
        }
        t || (t = new Mq()),
          (this[w0] = true),
          (this[Ud] = this[Ud] || []),
          this[Ud].push(r)
        let n = () => {
          let i = this[Ud]
          this[Ud] = null
          for (let s = 0; s < i.length; s++) i[s](null, null)
        }
        this[zGe](t).then(() => {
          queueMicrotask(n)
        })
      }
      [mR](t, r) {
        if (!this[bp] || this[bp].length === 0)
          return (this[mR] = this[Fq]), this[Fq](t, r)
        let n = this[Fq].bind(this)
        for (let i = this[bp].length - 1; i >= 0; i--) n = this[bp][i](n)
        return (this[mR] = n), n(t, r)
      }
      dispatch(t, r) {
        if (!r || typeof r != "object")
          throw new x0("handler must be an object")
        try {
          if (!t || typeof t != "object")
            throw new x0("opts must be an object.")
          if (this[w0] || this[Ud]) throw new Mq()
          if (this[dE]) throw new KGe()
          return this[mR](t, r)
        } catch (n) {
          if (typeof r.onError != "function")
            throw new x0("invalid onError method")
          return r.onError(n), false
        }
      }
    }
  Rre.exports = Qq
})
var Vq = _((cDt, Mre) => {
  "use strict"
  var B0 = 0,
    Nq = 1e3,
    Pq = (Nq >> 1) - 1,
    Od,
    Lq = Symbol("kFastTimer"),
    qd = [],
    Uq = -2,
    Oq = -1,
    Tre = 0,
    Dre = 1
  function qq() {
    B0 += Pq
    let e = 0,
      t = qd.length
    for (; e < t; ) {
      let r = qd[e]
      r._state === Tre
        ? ((r._idleStart = B0 - Pq), (r._state = Dre))
        : r._state === Dre &&
          B0 >= r._idleStart + r._idleTimeout &&
          ((r._state = Oq), (r._idleStart = -1), r._onTimeout(r._timerArg)),
        r._state === Oq ? ((r._state = Uq), --t !== 0 && (qd[e] = qd[t])) : ++e
    }
    ;(qd.length = t), qd.length !== 0 && kre()
  }
  function kre() {
    Od
      ? Od.refresh()
      : (clearTimeout(Od), (Od = setTimeout(qq, Pq)), Od.unref && Od.unref())
  }
  var AR = class {
    [Lq] = true
    _state = Uq
    _idleTimeout = -1
    _idleStart = -1
    _onTimeout
    _timerArg
    constructor(t, r, n) {
      ;(this._onTimeout = t),
        (this._idleTimeout = r),
        (this._timerArg = n),
        this.refresh()
    }
    refresh() {
      this._state === Uq && qd.push(this),
        (!Od || qd.length === 1) && kre(),
        (this._state = Tre)
    }
    clear() {
      ;(this._state = Oq), (this._idleStart = -1)
    }
  }
  Mre.exports = {
    setTimeout(e, t, r) {
      return t <= Nq ? setTimeout(e, t, r) : new AR(e, t, r)
    },
    clearTimeout(e) {
      e[Lq] ? e.clear() : clearTimeout(e)
    },
    setFastTimeout(e, t, r) {
      return new AR(e, t, r)
    },
    clearFastTimeout(e) {
      e.clear()
    },
    now() {
      return B0
    },
    tick(e = 0) {
      ;(B0 += e - Nq + 1), qq(), qq()
    },
    reset() {
      ;(B0 = 0), (qd.length = 0), clearTimeout(Od), (Od = null)
    },
    kFastTimer: Lq,
  }
})
var fE = _((fDt, Lre) => {
  "use strict"
  var jGe = require("net"),
    Fre = require("assert"),
    Pre = ir(),
    { InvalidArgumentError: ZGe, ConnectTimeoutError: XGe } = Jr(),
    yR = Vq()
  function Qre() {}
  var Hq, Wq
  global.FinalizationRegistry &&
  !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG)
    ? (Wq = class {
        constructor(t) {
          ;(this._maxCachedSessions = t),
            (this._sessionCache = new Map()),
            (this._sessionRegistry = new global.FinalizationRegistry((r) => {
              if (this._sessionCache.size < this._maxCachedSessions) return
              let n = this._sessionCache.get(r)
              n !== undefined &&
                n.deref() === undefined &&
                this._sessionCache.delete(r)
            }))
        }
        get(t) {
          let r = this._sessionCache.get(t)
          return r ? r.deref() : null
        }
        set(t, r) {
          this._maxCachedSessions !== 0 &&
            (this._sessionCache.set(t, new WeakRef(r)),
            this._sessionRegistry.register(r, t))
        }
      })
    : (Wq = class {
        constructor(t) {
          ;(this._maxCachedSessions = t), (this._sessionCache = new Map())
        }
        get(t) {
          return this._sessionCache.get(t)
        }
        set(t, r) {
          if (this._maxCachedSessions !== 0) {
            if (this._sessionCache.size >= this._maxCachedSessions) {
              let { value: n } = this._sessionCache.keys().next()
              this._sessionCache.delete(n)
            }
            this._sessionCache.set(t, r)
          }
        }
      })
  function e4e({
    allowH2: e,
    maxCachedSessions: t,
    socketPath: r,
    timeout: n,
    session: i,
    ...s
  }) {
    if (t != null && (!Number.isInteger(t) || t < 0))
      throw new ZGe("maxCachedSessions must be a positive integer or zero")
    let o = { path: r, ...s },
      a = new Wq(t ?? 100)
    return (
      (n = n ?? 1e4),
      (e = e ?? false),
      function (
        {
          hostname: c,
          host: u,
          protocol: f,
          port: p,
          servername: g,
          localAddress: m,
          httpSocket: y,
        },
        v,
      ) {
        let C
        if (f === "https:") {
          Hq || (Hq = require("tls")),
            (g = g || o.servername || Pre.getServerName(u) || null)
          let w = g || c
          Fre(w)
          let B = i || a.get(w) || null
          ;(p = p || 443),
            (C = Hq.connect({
              highWaterMark: 16384,
              ...o,
              servername: g,
              session: B,
              localAddress: m,
              ALPNProtocols: e ? ["http/1.1", "h2"] : ["http/1.1"],
              socket: y,
              port: p,
              host: c,
            })),
            C.on("session", function (T) {
              a.set(w, T)
            })
        } else
          Fre(!y, "httpSocket can only be sent on TLS update"),
            (p = p || 80),
            (C = jGe.connect({
              highWaterMark: 64 * 1024,
              ...o,
              localAddress: m,
              port: p,
              host: c,
            }))
        if (o.keepAlive == null || o.keepAlive) {
          let w =
            o.keepAliveInitialDelay === undefined ? 6e4 : o.keepAliveInitialDelay
          C.setKeepAlive(true, w)
        }
        let E = t4e(new WeakRef(C), { timeout: n, hostname: c, port: p })
        return (
          C.setNoDelay(true)
            .once(f === "https:" ? "secureConnect" : "connect", function () {
              if ((queueMicrotask(E), v)) {
                let w = v
                ;(v = null), w(null, this)
              }
            })
            .on("error", function (w) {
              if ((queueMicrotask(E), v)) {
                let B = v
                ;(v = null), B(w)
              }
            }),
          C
        )
      }
    )
  }
  var t4e =
    process.platform === "win32"
      ? (e, t) => {
          if (!t.timeout) return Qre
          let r = null,
            n = null,
            i = yR.setFastTimeout(() => {
              r = setImmediate(() => {
                n = setImmediate(() => Nre(e.deref(), t))
              })
            }, t.timeout)
          return () => {
            yR.clearFastTimeout(i), clearImmediate(r), clearImmediate(n)
          }
        }
      : (e, t) => {
          if (!t.timeout) return Qre
          let r = null,
            n = yR.setFastTimeout(() => {
              r = setImmediate(() => {
                Nre(e.deref(), t)
              })
            }, t.timeout)
          return () => {
            yR.clearFastTimeout(n), clearImmediate(r)
          }
        }
  function Nre(e, t) {
    if (e == null) return
    let r = "Connect Timeout Error"
    Array.isArray(e.autoSelectFamilyAttemptedAddresses)
      ? (r += ` (attempted addresses: ${e.autoSelectFamilyAttemptedAddresses.join(", ")},`)
      : (r += ` (attempted address: ${t.hostname}:${t.port},`),
      (r += ` timeout: ${t.timeout}ms)`),
      Pre.destroy(e, new XGe(r))
  }
  Lre.exports = e4e
})
var Ure = _((vR) => {
  "use strict"
  Object.defineProperty(vR, "__esModule", { value: true })
  vR.enumToMap = undefined
  function r4e(e) {
    let t = {}
    return (
      Object.keys(e).forEach((r) => {
        let n = e[r]
        typeof n == "number" && (t[r] = n)
      }),
      t
    )
  }
  vR.enumToMap = r4e
})
var Ore = _((xe) => {
  "use strict"
  Object.defineProperty(xe, "__esModule", { value: true })
  xe.SPECIAL_HEADERS =
    xe.HEADER_STATE =
    xe.MINOR =
    xe.MAJOR =
    xe.CONNECTION_TOKEN_CHARS =
    xe.HEADER_CHARS =
    xe.TOKEN =
    xe.STRICT_TOKEN =
    xe.HEX =
    xe.URL_CHAR =
    xe.STRICT_URL_CHAR =
    xe.USERINFO_CHARS =
    xe.MARK =
    xe.ALPHANUM =
    xe.NUM =
    xe.HEX_MAP =
    xe.NUM_MAP =
    xe.ALPHA =
    xe.FINISH =
    xe.H_METHOD_MAP =
    xe.METHOD_MAP =
    xe.METHODS_RTSP =
    xe.METHODS_ICE =
    xe.METHODS_HTTP =
    xe.METHODS =
    xe.LENIENT_FLAGS =
    xe.FLAGS =
    xe.TYPE =
    xe.ERROR =
      undefined
  var n4e = Ure(),
    i4e
  ;(function (e) {
    ;(e[(e.OK = 0)] = "OK"),
      (e[(e.INTERNAL = 1)] = "INTERNAL"),
      (e[(e.STRICT = 2)] = "STRICT"),
      (e[(e.LF_EXPECTED = 3)] = "LF_EXPECTED"),
      (e[(e.UNEXPECTED_CONTENT_LENGTH = 4)] = "UNEXPECTED_CONTENT_LENGTH"),
      (e[(e.CLOSED_CONNECTION = 5)] = "CLOSED_CONNECTION"),
      (e[(e.INVALID_METHOD = 6)] = "INVALID_METHOD"),
      (e[(e.INVALID_URL = 7)] = "INVALID_URL"),
      (e[(e.INVALID_CONSTANT = 8)] = "INVALID_CONSTANT"),
      (e[(e.INVALID_VERSION = 9)] = "INVALID_VERSION"),
      (e[(e.INVALID_HEADER_TOKEN = 10)] = "INVALID_HEADER_TOKEN"),
      (e[(e.INVALID_CONTENT_LENGTH = 11)] = "INVALID_CONTENT_LENGTH"),
      (e[(e.INVALID_CHUNK_SIZE = 12)] = "INVALID_CHUNK_SIZE"),
      (e[(e.INVALID_STATUS = 13)] = "INVALID_STATUS"),
      (e[(e.INVALID_EOF_STATE = 14)] = "INVALID_EOF_STATE"),
      (e[(e.INVALID_TRANSFER_ENCODING = 15)] = "INVALID_TRANSFER_ENCODING"),
      (e[(e.CB_MESSAGE_BEGIN = 16)] = "CB_MESSAGE_BEGIN"),
      (e[(e.CB_HEADERS_COMPLETE = 17)] = "CB_HEADERS_COMPLETE"),
      (e[(e.CB_MESSAGE_COMPLETE = 18)] = "CB_MESSAGE_COMPLETE"),
      (e[(e.CB_CHUNK_HEADER = 19)] = "CB_CHUNK_HEADER"),
      (e[(e.CB_CHUNK_COMPLETE = 20)] = "CB_CHUNK_COMPLETE"),
      (e[(e.PAUSED = 21)] = "PAUSED"),
      (e[(e.PAUSED_UPGRADE = 22)] = "PAUSED_UPGRADE"),
      (e[(e.PAUSED_H2_UPGRADE = 23)] = "PAUSED_H2_UPGRADE"),
      (e[(e.USER = 24)] = "USER")
  })((i4e = xe.ERROR || (xe.ERROR = {})))
  var s4e
  ;(function (e) {
    ;(e[(e.BOTH = 0)] = "BOTH"),
      (e[(e.REQUEST = 1)] = "REQUEST"),
      (e[(e.RESPONSE = 2)] = "RESPONSE")
  })((s4e = xe.TYPE || (xe.TYPE = {})))
  var o4e
  ;(function (e) {
    ;(e[(e.CONNECTION_KEEP_ALIVE = 1)] = "CONNECTION_KEEP_ALIVE"),
      (e[(e.CONNECTION_CLOSE = 2)] = "CONNECTION_CLOSE"),
      (e[(e.CONNECTION_UPGRADE = 4)] = "CONNECTION_UPGRADE"),
      (e[(e.CHUNKED = 8)] = "CHUNKED"),
      (e[(e.UPGRADE = 16)] = "UPGRADE"),
      (e[(e.CONTENT_LENGTH = 32)] = "CONTENT_LENGTH"),
      (e[(e.SKIPBODY = 64)] = "SKIPBODY"),
      (e[(e.TRAILING = 128)] = "TRAILING"),
      (e[(e.TRANSFER_ENCODING = 512)] = "TRANSFER_ENCODING")
  })((o4e = xe.FLAGS || (xe.FLAGS = {})))
  var a4e
  ;(function (e) {
    ;(e[(e.HEADERS = 1)] = "HEADERS"),
      (e[(e.CHUNKED_LENGTH = 2)] = "CHUNKED_LENGTH"),
      (e[(e.KEEP_ALIVE = 4)] = "KEEP_ALIVE")
  })((a4e = xe.LENIENT_FLAGS || (xe.LENIENT_FLAGS = {})))
  var ct
  ;(function (e) {
    ;(e[(e.DELETE = 0)] = "DELETE"),
      (e[(e.GET = 1)] = "GET"),
      (e[(e.HEAD = 2)] = "HEAD"),
      (e[(e.POST = 3)] = "POST"),
      (e[(e.PUT = 4)] = "PUT"),
      (e[(e.CONNECT = 5)] = "CONNECT"),
      (e[(e.OPTIONS = 6)] = "OPTIONS"),
      (e[(e.TRACE = 7)] = "TRACE"),
      (e[(e.COPY = 8)] = "COPY"),
      (e[(e.LOCK = 9)] = "LOCK"),
      (e[(e.MKCOL = 10)] = "MKCOL"),
      (e[(e.MOVE = 11)] = "MOVE"),
      (e[(e.PROPFIND = 12)] = "PROPFIND"),
      (e[(e.PROPPATCH = 13)] = "PROPPATCH"),
      (e[(e.SEARCH = 14)] = "SEARCH"),
      (e[(e.UNLOCK = 15)] = "UNLOCK"),
      (e[(e.BIND = 16)] = "BIND"),
      (e[(e.REBIND = 17)] = "REBIND"),
      (e[(e.UNBIND = 18)] = "UNBIND"),
      (e[(e.ACL = 19)] = "ACL"),
      (e[(e.REPORT = 20)] = "REPORT"),
      (e[(e.MKACTIVITY = 21)] = "MKACTIVITY"),
      (e[(e.CHECKOUT = 22)] = "CHECKOUT"),
      (e[(e.MERGE = 23)] = "MERGE"),
      (e[(e["M-SEARCH"] = 24)] = "M-SEARCH"),
      (e[(e.NOTIFY = 25)] = "NOTIFY"),
      (e[(e.SUBSCRIBE = 26)] = "SUBSCRIBE"),
      (e[(e.UNSUBSCRIBE = 27)] = "UNSUBSCRIBE"),
      (e[(e.PATCH = 28)] = "PATCH"),
      (e[(e.PURGE = 29)] = "PURGE"),
      (e[(e.MKCALENDAR = 30)] = "MKCALENDAR"),
      (e[(e.LINK = 31)] = "LINK"),
      (e[(e.UNLINK = 32)] = "UNLINK"),
      (e[(e.SOURCE = 33)] = "SOURCE"),
      (e[(e.PRI = 34)] = "PRI"),
      (e[(e.DESCRIBE = 35)] = "DESCRIBE"),
      (e[(e.ANNOUNCE = 36)] = "ANNOUNCE"),
      (e[(e.SETUP = 37)] = "SETUP"),
      (e[(e.PLAY = 38)] = "PLAY"),
      (e[(e.PAUSE = 39)] = "PAUSE"),
      (e[(e.TEARDOWN = 40)] = "TEARDOWN"),
      (e[(e.GET_PARAMETER = 41)] = "GET_PARAMETER"),
      (e[(e.SET_PARAMETER = 42)] = "SET_PARAMETER"),
      (e[(e.REDIRECT = 43)] = "REDIRECT"),
      (e[(e.RECORD = 44)] = "RECORD"),
      (e[(e.FLUSH = 45)] = "FLUSH")
  })((ct = xe.METHODS || (xe.METHODS = {})))
  xe.METHODS_HTTP = [
    ct.DELETE,
    ct.GET,
    ct.HEAD,
    ct.POST,
    ct.PUT,
    ct.CONNECT,
    ct.OPTIONS,
    ct.TRACE,
    ct.COPY,
    ct.LOCK,
    ct.MKCOL,
    ct.MOVE,
    ct.PROPFIND,
    ct.PROPPATCH,
    ct.SEARCH,
    ct.UNLOCK,
    ct.BIND,
    ct.REBIND,
    ct.UNBIND,
    ct.ACL,
    ct.REPORT,
    ct.MKACTIVITY,
    ct.CHECKOUT,
    ct.MERGE,
    ct["M-SEARCH"],
    ct.NOTIFY,
    ct.SUBSCRIBE,
    ct.UNSUBSCRIBE,
    ct.PATCH,
    ct.PURGE,
    ct.MKCALENDAR,
    ct.LINK,
    ct.UNLINK,
    ct.PRI,
    ct.SOURCE,
  ]
  xe.METHODS_ICE = [ct.SOURCE]
  xe.METHODS_RTSP = [
    ct.OPTIONS,
    ct.DESCRIBE,
    ct.ANNOUNCE,
    ct.SETUP,
    ct.PLAY,
    ct.PAUSE,
    ct.TEARDOWN,
    ct.GET_PARAMETER,
    ct.SET_PARAMETER,
    ct.REDIRECT,
    ct.RECORD,
    ct.FLUSH,
    ct.GET,
    ct.POST,
  ]
  xe.METHOD_MAP = n4e.enumToMap(ct)
  xe.H_METHOD_MAP = {}
  Object.keys(xe.METHOD_MAP).forEach((e) => {
    ;/^H/.test(e) && (xe.H_METHOD_MAP[e] = xe.METHOD_MAP[e])
  })
  var l4e
  ;(function (e) {
    ;(e[(e.SAFE = 0)] = "SAFE"),
      (e[(e.SAFE_WITH_CB = 1)] = "SAFE_WITH_CB"),
      (e[(e.UNSAFE = 2)] = "UNSAFE")
  })((l4e = xe.FINISH || (xe.FINISH = {})))
  xe.ALPHA = []
  for (let e = 65; e <= 90; e++)
    xe.ALPHA.push(String.fromCharCode(e)),
      xe.ALPHA.push(String.fromCharCode(e + 32))
  xe.NUM_MAP = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9 }
  xe.HEX_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15,
  }
  xe.NUM = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
  xe.ALPHANUM = xe.ALPHA.concat(xe.NUM)
  xe.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"]
  xe.USERINFO_CHARS = xe.ALPHANUM.concat(xe.MARK).concat([
    "%",
    ";",
    ":",
    "&",
    "=",
    "+",
    "$",
    ",",
  ])
  xe.STRICT_URL_CHAR = [
    "!",
    '"',
    "$",
    "%",
    "&",
    "'",
    "(",
    ")",
    "*",
    "+",
    ",",
    "-",
    ".",
    "/",
    ":",
    ";",
    "<",
    "=",
    ">",
    "@",
    "[",
    "\\",
    "]",
    "^",
    "_",
    "`",
    "{",
    "|",
    "}",
    "~",
  ].concat(xe.ALPHANUM)
  xe.URL_CHAR = xe.STRICT_URL_CHAR.concat(["	", "\f"])
  for (let e = 128; e <= 255; e++) xe.URL_CHAR.push(e)
  xe.HEX = xe.NUM.concat([
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
  ])
  xe.STRICT_TOKEN = [
    "!",
    "#",
    "$",
    "%",
    "&",
    "'",
    "*",
    "+",
    "-",
    ".",
    "^",
    "_",
    "`",
    "|",
    "~",
  ].concat(xe.ALPHANUM)
  xe.TOKEN = xe.STRICT_TOKEN.concat([" "])
  xe.HEADER_CHARS = ["	"]
  for (let e = 32; e <= 255; e++) e !== 127 && xe.HEADER_CHARS.push(e)
  xe.CONNECTION_TOKEN_CHARS = xe.HEADER_CHARS.filter((e) => e !== 44)
  xe.MAJOR = xe.NUM_MAP
  xe.MINOR = xe.MAJOR
  var R0
  ;(function (e) {
    ;(e[(e.GENERAL = 0)] = "GENERAL"),
      (e[(e.CONNECTION = 1)] = "CONNECTION"),
      (e[(e.CONTENT_LENGTH = 2)] = "CONTENT_LENGTH"),
      (e[(e.TRANSFER_ENCODING = 3)] = "TRANSFER_ENCODING"),
      (e[(e.UPGRADE = 4)] = "UPGRADE"),
      (e[(e.CONNECTION_KEEP_ALIVE = 5)] = "CONNECTION_KEEP_ALIVE"),
      (e[(e.CONNECTION_CLOSE = 6)] = "CONNECTION_CLOSE"),
      (e[(e.CONNECTION_UPGRADE = 7)] = "CONNECTION_UPGRADE"),
      (e[(e.TRANSFER_ENCODING_CHUNKED = 8)] = "TRANSFER_ENCODING_CHUNKED")
  })((R0 = xe.HEADER_STATE || (xe.HEADER_STATE = {})))
  xe.SPECIAL_HEADERS = {
    connection: R0.CONNECTION,
    "content-length": R0.CONTENT_LENGTH,
    "proxy-connection": R0.CONNECTION,
    "transfer-encoding": R0.TRANSFER_ENCODING,
    upgrade: R0.UPGRADE,
  }
})
var Gq = _((pDt, qre) => {
  "use strict"
  var { Buffer: c4e } = require("buffer")
  qre.exports = c4e.from(
    "AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVuaWVudF9oZWFkZXJzACEhbGxodHRwX3NldF9sZW5pZW50X2NodW5rZWRfbGVuZ3RoACIdbGxodHRwX3NldF9sZW5pZW50X2tlZXBfYWxpdmUAIyRsbGh0dHBfc2V0X2xlbmllbnRfdHJhbnNmZXJfZW5jb2RpbmcAJBhsbGh0dHBfbWVzc2FnZV9uZWVkc19lb2YALgkXAQBBAQsRAQIDBAUKBgcrLSwqKSglJyYK07MCLBYAQYjQACgCAARAAAtBiNAAQQE2AgALFAAgABAwIAAgAjYCOCAAIAE6ACgLFAAgACAALwEyIAAtAC4gABAvEAALHgEBf0HAABAyIgEQMCABQYAINgI4IAEgADoAKCABC48MAQd/AkAgAEUNACAAQQhrIgEgAEEEaygCACIAQXhxIgRqIQUCQCAAQQFxDQAgAEEDcUUNASABIAEoAgAiAGsiAUGc0AAoAgBJDQEgACAEaiEEAkACQEGg0AAoAgAgAUcEQCAAQf8BTQRAIABBA3YhAyABKAIIIgAgASgCDCICRgRAQYzQAEGM0AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyABKAIYIQYgASABKAIMIgBHBEAgACABKAIIIgI2AgggAiAANgIMDAMLIAFBFGoiAygCACICRQRAIAEoAhAiAkUNAiABQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFKAIEIgBBA3FBA0cNAiAFIABBfnE2AgRBlNAAIAQ2AgAgBSAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCABKAIcIgJBAnRBvNIAaiIDKAIAIAFGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgAUYbaiAANgIAIABFDQELIAAgBjYCGCABKAIQIgIEQCAAIAI2AhAgAiAANgIYCyABQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAFTw0AIAUoAgQiAEEBcUUNAAJAAkACQAJAIABBAnFFBEBBpNAAKAIAIAVGBEBBpNAAIAE2AgBBmNAAQZjQACgCACAEaiIANgIAIAEgAEEBcjYCBCABQaDQACgCAEcNBkGU0ABBADYCAEGg0ABBADYCAAwGC0Gg0AAoAgAgBUYEQEGg0AAgATYCAEGU0ABBlNAAKAIAIARqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAAwGCyAAQXhxIARqIQQgAEH/AU0EQCAAQQN2IQMgBSgCCCIAIAUoAgwiAkYEQEGM0ABBjNAAKAIAQX4gA3dxNgIADAULIAIgADYCCCAAIAI2AgwMBAsgBSgCGCEGIAUgBSgCDCIARwRAQZzQACgCABogACAFKAIIIgI2AgggAiAANgIMDAMLIAVBFGoiAygCACICRQRAIAUoAhAiAkUNAiAFQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFIABBfnE2AgQgASAEaiAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCAFKAIcIgJBAnRBvNIAaiIDKAIAIAVGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiAANgIAIABFDQELIAAgBjYCGCAFKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAFQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAEaiAENgIAIAEgBEEBcjYCBCABQaDQACgCAEcNAEGU0AAgBDYCAAwBCyAEQf8BTQRAIARBeHFBtNAAaiEAAn9BjNAAKAIAIgJBASAEQQN2dCIDcUUEQEGM0AAgAiADcjYCACAADAELIAAoAggLIgIgATYCDCAAIAE2AgggASAANgIMIAEgAjYCCAwBC0EfIQIgBEH///8HTQRAIARBJiAEQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAgsgASACNgIcIAFCADcCECACQQJ0QbzSAGohAAJAQZDQACgCACIDQQEgAnQiB3FFBEAgACABNgIAQZDQACADIAdyNgIAIAEgADYCGCABIAE2AgggASABNgIMDAELIARBGSACQQF2a0EAIAJBH0cbdCECIAAoAgAhAAJAA0AgACIDKAIEQXhxIARGDQEgAkEddiEAIAJBAXQhAiADIABBBHFqQRBqIgcoAgAiAA0ACyAHIAE2AgAgASADNgIYIAEgATYCDCABIAE2AggMAQsgAygCCCIAIAE2AgwgAyABNgIIIAFBADYCGCABIAM2AgwgASAANgIIC0Gs0ABBrNAAKAIAQQFrIgBBfyAAGzYCAAsLBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LQAEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABAwIAAgBDYCOCAAIAM6ACggACACOgAtIAAgATYCGAu74gECB38DfiABIAJqIQQCQCAAIgIoAgwiAA0AIAIoAgQEQCACIAE2AgQLIwBBEGsiCCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIoAhwiA0EBaw7dAdoBAdkBAgMEBQYHCAkKCwwNDtgBDxDXARES1gETFBUWFxgZGhvgAd8BHB0e1QEfICEiIyQl1AEmJygpKiss0wHSAS0u0QHQAS8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRtsBR0hJSs8BzgFLzQFMzAFNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBywHKAbgByQG5AcgBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgEA3AELQQAMxgELQQ4MxQELQQ0MxAELQQ8MwwELQRAMwgELQRMMwQELQRQMwAELQRUMvwELQRYMvgELQRgMvQELQRkMvAELQRoMuwELQRsMugELQRwMuQELQR0MuAELQQgMtwELQR4MtgELQSAMtQELQR8MtAELQQcMswELQSEMsgELQSIMsQELQSMMsAELQSQMrwELQRIMrgELQREMrQELQSUMrAELQSYMqwELQScMqgELQSgMqQELQcMBDKgBC0EqDKcBC0ErDKYBC0EsDKUBC0EtDKQBC0EuDKMBC0EvDKIBC0HEAQyhAQtBMAygAQtBNAyfAQtBDAyeAQtBMQydAQtBMgycAQtBMwybAQtBOQyaAQtBNQyZAQtBxQEMmAELQQsMlwELQToMlgELQTYMlQELQQoMlAELQTcMkwELQTgMkgELQTwMkQELQTsMkAELQT0MjwELQQkMjgELQSkMjQELQT4MjAELQT8MiwELQcAADIoBC0HBAAyJAQtBwgAMiAELQcMADIcBC0HEAAyGAQtBxQAMhQELQcYADIQBC0EXDIMBC0HHAAyCAQtByAAMgQELQckADIABC0HKAAx/C0HLAAx+C0HNAAx9C0HMAAx8C0HOAAx7C0HPAAx6C0HQAAx5C0HRAAx4C0HSAAx3C0HTAAx2C0HUAAx1C0HWAAx0C0HVAAxzC0EGDHILQdcADHELQQUMcAtB2AAMbwtBBAxuC0HZAAxtC0HaAAxsC0HbAAxrC0HcAAxqC0EDDGkLQd0ADGgLQd4ADGcLQd8ADGYLQeEADGULQeAADGQLQeIADGMLQeMADGILQQIMYQtB5AAMYAtB5QAMXwtB5gAMXgtB5wAMXQtB6AAMXAtB6QAMWwtB6gAMWgtB6wAMWQtB7AAMWAtB7QAMVwtB7gAMVgtB7wAMVQtB8AAMVAtB8QAMUwtB8gAMUgtB8wAMUQtB9AAMUAtB9QAMTwtB9gAMTgtB9wAMTQtB+AAMTAtB+QAMSwtB+gAMSgtB+wAMSQtB/AAMSAtB/QAMRwtB/gAMRgtB/wAMRQtBgAEMRAtBgQEMQwtBggEMQgtBgwEMQQtBhAEMQAtBhQEMPwtBhgEMPgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADDsYBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHyAhIyUmKCorLC8wMTIzNDU2Nzk6Ozw9lANAQkRFRklLTk9QUVJTVFVWWFpbXF1eX2BhYmNkZWZnaGpsb3Bxc3V2eHl6e3x/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcsBzAHNAc4BzwGKA4kDiAOHA4QDgwOAA/sC+gL5AvgC9wL0AvMC8gLLAsECsALZAQsgASAERw3wAkHdASEDDLMDCyABIARHDcgBQcMBIQMMsgMLIAEgBEcNe0H3ACEDDLEDCyABIARHDXBB7wAhAwywAwsgASAERw1pQeoAIQMMrwMLIAEgBEcNZUHoACEDDK4DCyABIARHDWJB5gAhAwytAwsgASAERw0aQRghAwysAwsgASAERw0VQRIhAwyrAwsgASAERw1CQcUAIQMMqgMLIAEgBEcNNEE/IQMMqQMLIAEgBEcNMkE8IQMMqAMLIAEgBEcNK0ExIQMMpwMLIAItAC5BAUYNnwMMwQILQQAhAAJAAkACQCACLQAqRQ0AIAItACtFDQAgAi8BMCIDQQJxRQ0BDAILIAIvATAiA0EBcUUNAQtBASEAIAItAChBAUYNACACLwEyIgVB5ABrQeQASQ0AIAVBzAFGDQAgBUGwAkYNACADQcAAcQ0AQQAhACADQYgEcUGABEYNACADQShxQQBHIQALIAJBADsBMCACQQA6AC8gAEUN3wIgAkIANwMgDOACC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAARQ3MASAAQRVHDd0CIAJBBDYCHCACIAE2AhQgAkGwGDYCECACQRU2AgxBACEDDKQDCyABIARGBEBBBiEDDKQDCyABQQFqIQFBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAA3ZAgwcCyACQgA3AyBBEiEDDIkDCyABIARHDRZBHSEDDKEDCyABIARHBEAgAUEBaiEBQRAhAwyIAwtBByEDDKADCyACIAIpAyAiCiAEIAFrrSILfSIMQgAgCiAMWhs3AyAgCiALWA3UAkEIIQMMnwMLIAEgBEcEQCACQQk2AgggAiABNgIEQRQhAwyGAwtBCSEDDJ4DCyACKQMgQgBSDccBIAIgAi8BMEGAAXI7ATAMQgsgASAERw0/QdAAIQMMnAMLIAEgBEYEQEELIQMMnAMLIAFBAWohAUEAIQACQCACKAI4IgNFDQAgAygCUCIDRQ0AIAIgAxEAACEACyAADc8CDMYBC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ3GASAAQRVHDc0CIAJBCzYCHCACIAE2AhQgAkGCGTYCECACQRU2AgxBACEDDJoDC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ0MIABBFUcNygIgAkEaNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMmQMLQQAhAAJAIAIoAjgiA0UNACADKAJMIgNFDQAgAiADEQAAIQALIABFDcQBIABBFUcNxwIgAkELNgIcIAIgATYCFCACQZEXNgIQIAJBFTYCDEEAIQMMmAMLIAEgBEYEQEEPIQMMmAMLIAEtAAAiAEE7Rg0HIABBDUcNxAIgAUEBaiEBDMMBC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3DASAAQRVHDcICIAJBDzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJYDCwNAIAEtAABB8DVqLQAAIgBBAUcEQCAAQQJHDcECIAIoAgQhAEEAIQMgAkEANgIEIAIgACABQQFqIgEQLSIADcICDMUBCyAEIAFBAWoiAUcNAAtBEiEDDJUDC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3FASAAQRVHDb0CIAJBGzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJQDCyABIARGBEBBFiEDDJQDCyACQQo2AgggAiABNgIEQQAhAAJAIAIoAjgiA0UNACADKAJIIgNFDQAgAiADEQAAIQALIABFDcIBIABBFUcNuQIgAkEVNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMkwMLIAEgBEcEQANAIAEtAABB8DdqLQAAIgBBAkcEQAJAIABBAWsOBMQCvQIAvgK9AgsgAUEBaiEBQQghAwz8AgsgBCABQQFqIgFHDQALQRUhAwyTAwtBFSEDDJIDCwNAIAEtAABB8DlqLQAAIgBBAkcEQCAAQQFrDgTFArcCwwK4ArcCCyAEIAFBAWoiAUcNAAtBGCEDDJEDCyABIARHBEAgAkELNgIIIAIgATYCBEEHIQMM+AILQRkhAwyQAwsgAUEBaiEBDAILIAEgBEYEQEEaIQMMjwMLAkAgAS0AAEENaw4UtQG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwEAvwELQQAhAyACQQA2AhwgAkGvCzYCECACQQI2AgwgAiABQQFqNgIUDI4DCyABIARGBEBBGyEDDI4DCyABLQAAIgBBO0cEQCAAQQ1HDbECIAFBAWohAQy6AQsgAUEBaiEBC0EiIQMM8wILIAEgBEYEQEEcIQMMjAMLQgAhCgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAS0AAEEwaw43wQLAAgABAgMEBQYH0AHQAdAB0AHQAdAB0AEICQoLDA3QAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdABDg8QERIT0AELQgIhCgzAAgtCAyEKDL8CC0IEIQoMvgILQgUhCgy9AgtCBiEKDLwCC0IHIQoMuwILQgghCgy6AgtCCSEKDLkCC0IKIQoMuAILQgshCgy3AgtCDCEKDLYCC0INIQoMtQILQg4hCgy0AgtCDyEKDLMCC0IKIQoMsgILQgshCgyxAgtCDCEKDLACC0INIQoMrwILQg4hCgyuAgtCDyEKDK0CC0IAIQoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsON8ACvwIAAQIDBAUGB74CvgK+Ar4CvgK+Ar4CCAkKCwwNvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ag4PEBESE74CC0ICIQoMvwILQgMhCgy+AgtCBCEKDL0CC0IFIQoMvAILQgYhCgy7AgtCByEKDLoCC0IIIQoMuQILQgkhCgy4AgtCCiEKDLcCC0ILIQoMtgILQgwhCgy1AgtCDSEKDLQCC0IOIQoMswILQg8hCgyyAgtCCiEKDLECC0ILIQoMsAILQgwhCgyvAgtCDSEKDK4CC0IOIQoMrQILQg8hCgysAgsgAiACKQMgIgogBCABa60iC30iDEIAIAogDFobNwMgIAogC1gNpwJBHyEDDIkDCyABIARHBEAgAkEJNgIIIAIgATYCBEElIQMM8AILQSAhAwyIAwtBASEFIAIvATAiA0EIcUUEQCACKQMgQgBSIQULAkAgAi0ALgRAQQEhACACLQApQQVGDQEgA0HAAHFFIAVxRQ0BC0EAIQAgA0HAAHENAEECIQAgA0EIcQ0AIANBgARxBEACQCACLQAoQQFHDQAgAi0ALUEKcQ0AQQUhAAwCC0EEIQAMAQsgA0EgcUUEQAJAIAItAChBAUYNACACLwEyIgBB5ABrQeQASQ0AIABBzAFGDQAgAEGwAkYNAEEEIQAgA0EocUUNAiADQYgEcUGABEYNAgtBACEADAELQQBBAyACKQMgUBshAAsgAEEBaw4FvgIAsAEBpAKhAgtBESEDDO0CCyACQQE6AC8MhAMLIAEgBEcNnQJBJCEDDIQDCyABIARHDRxBxgAhAwyDAwtBACEAAkAgAigCOCIDRQ0AIAMoAkQiA0UNACACIAMRAAAhAAsgAEUNJyAAQRVHDZgCIAJB0AA2AhwgAiABNgIUIAJBkRg2AhAgAkEVNgIMQQAhAwyCAwsgASAERgRAQSghAwyCAwtBACEDIAJBADYCBCACQQw2AgggAiABIAEQKiIARQ2UAiACQSc2AhwgAiABNgIUIAIgADYCDAyBAwsgASAERgRAQSkhAwyBAwsgAS0AACIAQSBGDRMgAEEJRw2VAiABQQFqIQEMFAsgASAERwRAIAFBAWohAQwWC0EqIQMM/wILIAEgBEYEQEErIQMM/wILIAEtAAAiAEEJRyAAQSBHcQ2QAiACLQAsQQhHDd0CIAJBADoALAzdAgsgASAERgRAQSwhAwz+AgsgAS0AAEEKRw2OAiABQQFqIQEMsAELIAEgBEcNigJBLyEDDPwCCwNAIAEtAAAiAEEgRwRAIABBCmsOBIQCiAKIAoQChgILIAQgAUEBaiIBRw0AC0ExIQMM+wILQTIhAyABIARGDfoCIAIoAgAiACAEIAFraiEHIAEgAGtBA2ohBgJAA0AgAEHwO2otAAAgAS0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAEEDRgRAQQYhAQziAgsgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAc2AgAM+wILIAJBADYCAAyGAgtBMyEDIAQgASIARg35AiAEIAFrIAIoAgAiAWohByAAIAFrQQhqIQYCQANAIAFB9DtqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBCEYEQEEFIQEM4QILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPoCCyACQQA2AgAgACEBDIUCC0E0IQMgBCABIgBGDfgCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgJAA0AgAUHQwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYEQEEHIQEM4AILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPkCCyACQQA2AgAgACEBDIQCCyABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRg0JDIECCyAEIAFBAWoiAUcNAAtBMCEDDPgCC0EwIQMM9wILIAEgBEcEQANAIAEtAAAiAEEgRwRAIABBCmsOBP8B/gH+Af8B/gELIAQgAUEBaiIBRw0AC0E4IQMM9wILQTghAwz2AgsDQCABLQAAIgBBIEcgAEEJR3EN9gEgBCABQQFqIgFHDQALQTwhAwz1AgsDQCABLQAAIgBBIEcEQAJAIABBCmsOBPkBBAT5AQALIABBLEYN9QEMAwsgBCABQQFqIgFHDQALQT8hAwz0AgtBwAAhAyABIARGDfMCIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAEGAQGstAAAgAS0AAEEgckcNASAAQQZGDdsCIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPQCCyACQQA2AgALQTYhAwzZAgsgASAERgRAQcEAIQMM8gILIAJBDDYCCCACIAE2AgQgAi0ALEEBaw4E+wHuAewB6wHUAgsgAUEBaiEBDPoBCyABIARHBEADQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxIgBBCUYNACAAQSBGDQACQAJAAkACQCAAQeMAaw4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIQMM3AILIAFBAWohAUEyIQMM2wILIAFBAWohAUEzIQMM2gILDP4BCyAEIAFBAWoiAUcNAAtBNSEDDPACC0E1IQMM7wILIAEgBEcEQANAIAEtAABBgDxqLQAAQQFHDfcBIAQgAUEBaiIBRw0AC0E9IQMM7wILQT0hAwzuAgtBACEAAkAgAigCOCIDRQ0AIAMoAkAiA0UNACACIAMRAAAhAAsgAEUNASAAQRVHDeYBIAJBwgA2AhwgAiABNgIUIAJB4xg2AhAgAkEVNgIMQQAhAwztAgsgAUEBaiEBC0E8IQMM0gILIAEgBEYEQEHCACEDDOsCCwJAA0ACQCABLQAAQQlrDhgAAswCzALRAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAgDMAgsgBCABQQFqIgFHDQALQcIAIQMM6wILIAFBAWohASACLQAtQQFxRQ3+AQtBLCEDDNACCyABIARHDd4BQcQAIQMM6AILA0AgAS0AAEGQwABqLQAAQQFHDZwBIAQgAUEBaiIBRw0AC0HFACEDDOcCCyABLQAAIgBBIEYN/gEgAEE6Rw3AAiACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgAN3gEM3QELQccAIQMgBCABIgBGDeUCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFBkMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvwIgAUEFRg3CAiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzlAgtByAAhAyAEIAEiAEYN5AIgBCABayACKAIAIgFqIQcgACABa0EJaiEGA0AgAUGWwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw2+AkECIAFBCUYNwgIaIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOQCCyABIARGBEBByQAhAwzkAgsCQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxQe4Aaw4HAL8CvwK/Ar8CvwIBvwILIAFBAWohAUE+IQMMywILIAFBAWohAUE/IQMMygILQcoAIQMgBCABIgBGDeICIAQgAWsgAigCACIBaiEGIAAgAWtBAWohBwNAIAFBoMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvAIgAUEBRg2+AiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBjYCAAziAgtBywAhAyAEIAEiAEYN4QIgBCABayACKAIAIgFqIQcgACABa0EOaiEGA0AgAUGiwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw27AiABQQ5GDb4CIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOECC0HMACEDIAQgASIARg3gAiAEIAFrIAIoAgAiAWohByAAIAFrQQ9qIQYDQCABQcDCAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDboCQQMgAUEPRg2+AhogAUEBaiEBIAQgAEEBaiIARw0ACyACIAc2AgAM4AILQc0AIQMgBCABIgBGDd8CIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFB0MIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNuQJBBCABQQVGDb0CGiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzfAgsgASAERgRAQc4AIQMM3wILAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAvAK8ArwCvAK8ArwCvAK8ArwCvAK8ArwCAbwCvAK8AgIDvAILIAFBAWohAUHBACEDDMgCCyABQQFqIQFBwgAhAwzHAgsgAUEBaiEBQcMAIQMMxgILIAFBAWohAUHEACEDDMUCCyABIARHBEAgAkENNgIIIAIgATYCBEHFACEDDMUCC0HPACEDDN0CCwJAAkAgAS0AAEEKaw4EAZABkAEAkAELIAFBAWohAQtBKCEDDMMCCyABIARGBEBB0QAhAwzcAgsgAS0AAEEgRw0AIAFBAWohASACLQAtQQFxRQ3QAQtBFyEDDMECCyABIARHDcsBQdIAIQMM2QILQdMAIQMgASAERg3YAiACKAIAIgAgBCABa2ohBiABIABrQQFqIQUDQCABLQAAIABB1sIAai0AAEcNxwEgAEEBRg3KASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBjYCAAzYAgsgASAERgRAQdUAIQMM2AILIAEtAABBCkcNwgEgAUEBaiEBDMoBCyABIARGBEBB1gAhAwzXAgsCQAJAIAEtAABBCmsOBADDAcMBAcMBCyABQQFqIQEMygELIAFBAWohAUHKACEDDL0CC0EAIQACQCACKAI4IgNFDQAgAygCPCIDRQ0AIAIgAxEAACEACyAADb8BQc0AIQMMvAILIAItAClBIkYNzwIMiQELIAQgASIFRgRAQdsAIQMM1AILQQAhAEEBIQFBASEGQQAhAwJAAn8CQAJAAkACQAJAAkACQCAFLQAAQTBrDgrFAcQBAAECAwQFBgjDAQtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshA0EAIQFBACEGDL0BC0EJIQNBASEAQQAhAUEAIQYMvAELIAEgBEYEQEHdACEDDNMCCyABLQAAQS5HDbgBIAFBAWohAQyIAQsgASAERw22AUHfACEDDNECCyABIARHBEAgAkEONgIIIAIgATYCBEHQACEDDLgCC0HgACEDDNACC0HhACEDIAEgBEYNzwIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGA0AgAS0AACAAQeLCAGotAABHDbEBIABBA0YNswEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMzwILQeIAIQMgASAERg3OAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYDQCABLQAAIABB5sIAai0AAEcNsAEgAEECRg2vASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAzOAgtB4wAhAyABIARGDc0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgNAIAEtAAAgAEHpwgBqLQAARw2vASAAQQNGDa0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADM0CCyABIARGBEBB5QAhAwzNAgsgAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANqgFB1gAhAwyzAgsgASAERwRAA0AgAS0AACIAQSBHBEACQAJAAkAgAEHIAGsOCwABswGzAbMBswGzAbMBswGzAQKzAQsgAUEBaiEBQdIAIQMMtwILIAFBAWohAUHTACEDDLYCCyABQQFqIQFB1AAhAwy1AgsgBCABQQFqIgFHDQALQeQAIQMMzAILQeQAIQMMywILA0AgAS0AAEHwwgBqLQAAIgBBAUcEQCAAQQJrDgOnAaYBpQGkAQsgBCABQQFqIgFHDQALQeYAIQMMygILIAFBAWogASAERw0CGkHnACEDDMkCCwNAIAEtAABB8MQAai0AACIAQQFHBEACQCAAQQJrDgSiAaEBoAEAnwELQdcAIQMMsQILIAQgAUEBaiIBRw0AC0HoACEDDMgCCyABIARGBEBB6QAhAwzIAgsCQCABLQAAIgBBCmsOGrcBmwGbAbQBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBpAGbAZsBAJkBCyABQQFqCyEBQQYhAwytAgsDQCABLQAAQfDGAGotAABBAUcNfSAEIAFBAWoiAUcNAAtB6gAhAwzFAgsgAUEBaiABIARHDQIaQesAIQMMxAILIAEgBEYEQEHsACEDDMQCCyABQQFqDAELIAEgBEYEQEHtACEDDMMCCyABQQFqCyEBQQQhAwyoAgsgASAERgRAQe4AIQMMwQILAkACQAJAIAEtAABB8MgAai0AAEEBaw4HkAGPAY4BAHwBAo0BCyABQQFqIQEMCwsgAUEBagyTAQtBACEDIAJBADYCHCACQZsSNgIQIAJBBzYCDCACIAFBAWo2AhQMwAILAkADQCABLQAAQfDIAGotAAAiAEEERwRAAkACQCAAQQFrDgeUAZMBkgGNAQAEAY0BC0HaACEDDKoCCyABQQFqIQFB3AAhAwypAgsgBCABQQFqIgFHDQALQe8AIQMMwAILIAFBAWoMkQELIAQgASIARgRAQfAAIQMMvwILIAAtAABBL0cNASAAQQFqIQEMBwsgBCABIgBGBEBB8QAhAwy+AgsgAC0AACIBQS9GBEAgAEEBaiEBQd0AIQMMpQILIAFBCmsiA0EWSw0AIAAhAUEBIAN0QYmAgAJxDfkBC0EAIQMgAkEANgIcIAIgADYCFCACQYwcNgIQIAJBBzYCDAy8AgsgASAERwRAIAFBAWohAUHeACEDDKMCC0HyACEDDLsCCyABIARGBEBB9AAhAwy7AgsCQCABLQAAQfDMAGotAABBAWsOA/cBcwCCAQtB4QAhAwyhAgsgASAERwRAA0AgAS0AAEHwygBqLQAAIgBBA0cEQAJAIABBAWsOAvkBAIUBC0HfACEDDKMCCyAEIAFBAWoiAUcNAAtB8wAhAwy6AgtB8wAhAwy5AgsgASAERwRAIAJBDzYCCCACIAE2AgRB4AAhAwygAgtB9QAhAwy4AgsgASAERgRAQfYAIQMMuAILIAJBDzYCCCACIAE2AgQLQQMhAwydAgsDQCABLQAAQSBHDY4CIAQgAUEBaiIBRw0AC0H3ACEDDLUCCyABIARGBEBB+AAhAwy1AgsgAS0AAEEgRw16IAFBAWohAQxbC0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAADXgMgAILIAEgBEYEQEH6ACEDDLMCCyABLQAAQcwARw10IAFBAWohAUETDHYLQfsAIQMgASAERg2xAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYDQCABLQAAIABB8M4Aai0AAEcNcyAAQQVGDXUgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMsQILIAEgBEYEQEH8ACEDDLECCwJAAkAgAS0AAEHDAGsODAB0dHR0dHR0dHR0AXQLIAFBAWohAUHmACEDDJgCCyABQQFqIQFB5wAhAwyXAgtB/QAhAyABIARGDa8CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDXIgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADLACCyACQQA2AgAgBkEBaiEBQRAMcwtB/gAhAyABIARGDa4CIAIoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQfbOAGotAABHDXEgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK8CCyACQQA2AgAgBkEBaiEBQRYMcgtB/wAhAyABIARGDa0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQfzOAGotAABHDXAgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK4CCyACQQA2AgAgBkEBaiEBQQUMcQsgASAERgRAQYABIQMMrQILIAEtAABB2QBHDW4gAUEBaiEBQQgMcAsgASAERgRAQYEBIQMMrAILAkACQCABLQAAQc4Aaw4DAG8BbwsgAUEBaiEBQesAIQMMkwILIAFBAWohAUHsACEDDJICCyABIARGBEBBggEhAwyrAgsCQAJAIAEtAABByABrDggAbm5ubm5uAW4LIAFBAWohAUHqACEDDJICCyABQQFqIQFB7QAhAwyRAgtBgwEhAyABIARGDakCIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQYDPAGotAABHDWwgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKoCCyACQQA2AgAgBkEBaiEBQQAMbQtBhAEhAyABIARGDagCIAIoAgAiACAEIAFraiEFIAEgAGtBBGohBgJAA0AgAS0AACAAQYPPAGotAABHDWsgAEEERg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKkCCyACQQA2AgAgBkEBaiEBQSMMbAsgASAERgRAQYUBIQMMqAILAkACQCABLQAAQcwAaw4IAGtra2trawFrCyABQQFqIQFB7wAhAwyPAgsgAUEBaiEBQfAAIQMMjgILIAEgBEYEQEGGASEDDKcCCyABLQAAQcUARw1oIAFBAWohAQxgC0GHASEDIAEgBEYNpQIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBiM8Aai0AAEcNaCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpgILIAJBADYCACAGQQFqIQFBLQxpC0GIASEDIAEgBEYNpAIgAigCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABB0M8Aai0AAEcNZyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpQILIAJBADYCACAGQQFqIQFBKQxoCyABIARGBEBBiQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEVDF8LQZIBIQMgASAERg2aAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGhzwBqLQAARw1dIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAybAgsgAkEANgIAIAZBAWohAUEeDF4LIAEgBEYEQEGTASEDDJoCCyABLQAAQcwARw1bIAFBAWohAUEKDF0LIAEgBEYEQEGUASEDDJkCCwJAAkAgAS0AAEHBAGsODwBcXFxcXFxcXFxcXFxcAVwLIAFBAWohAUH+ACEDDIACCyABQQFqIQFB/wAhAwz/AQsgASAERgRAQZUBIQMMmAILAkACQCABLQAAQcEAaw4DAFsBWwsgAUEBaiEBQf0AIQMM/wELIAFBAWohAUGAASEDDP4BC0GWASEDIAEgBEYNlgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBp88Aai0AAEcNWSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlwILIAJBADYCACAGQQFqIQFBCwxaCyABIARGBEBBlwEhAwyWAgsCQAJAAkACQCABLQAAQS1rDiMAW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1sBW1tbW1sCW1tbA1sLIAFBAWohAUH7ACEDDP8BCyABQQFqIQFB/AAhAwz+AQsgAUEBaiEBQYEBIQMM/QELIAFBAWohAUGCASEDDPwBC0GYASEDIAEgBEYNlAIgAigCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABBqc8Aai0AAEcNVyAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlQILIAJBADYCACAGQQFqIQFBGQxYC0GZASEDIAEgBEYNkwIgAigCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBrs8Aai0AAEcNViAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlAILIAJBADYCACAGQQFqIQFBBgxXC0GaASEDIAEgBEYNkgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBtM8Aai0AAEcNVSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkwILIAJBADYCACAGQQFqIQFBHAxWC0GbASEDIAEgBEYNkQIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBts8Aai0AAEcNVCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkgILIAJBADYCACAGQQFqIQFBJwxVCyABIARGBEBBnAEhAwyRAgsCQAJAIAEtAABB1ABrDgIAAVQLIAFBAWohAUGGASEDDPgBCyABQQFqIQFBhwEhAwz3AQtBnQEhAyABIARGDY8CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbjPAGotAABHDVIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADJACCyACQQA2AgAgBkEBaiEBQSYMUwtBngEhAyABIARGDY4CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbrPAGotAABHDVEgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI8CCyACQQA2AgAgBkEBaiEBQQMMUgtBnwEhAyABIARGDY0CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDVAgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI4CCyACQQA2AgAgBkEBaiEBQQwMUQtBoAEhAyABIARGDYwCIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQbzPAGotAABHDU8gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI0CCyACQQA2AgAgBkEBaiEBQQ0MUAsgASAERgRAQaEBIQMMjAILAkACQCABLQAAQcYAaw4LAE9PT09PT09PTwFPCyABQQFqIQFBiwEhAwzzAQsgAUEBaiEBQYwBIQMM8gELIAEgBEYEQEGiASEDDIsCCyABLQAAQdAARw1MIAFBAWohAQxGCyABIARGBEBBowEhAwyKAgsCQAJAIAEtAABByQBrDgcBTU1NTU0ATQsgAUEBaiEBQY4BIQMM8QELIAFBAWohAUEiDE0LQaQBIQMgASAERg2IAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHAzwBqLQAARw1LIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyJAgsgAkEANgIAIAZBAWohAUEdDEwLIAEgBEYEQEGlASEDDIgCCwJAAkAgAS0AAEHSAGsOAwBLAUsLIAFBAWohAUGQASEDDO8BCyABQQFqIQFBBAxLCyABIARGBEBBpgEhAwyHAgsCQAJAAkACQAJAIAEtAABBwQBrDhUATU1NTU1NTU1NTQFNTQJNTQNNTQRNCyABQQFqIQFBiAEhAwzxAQsgAUEBaiEBQYkBIQMM8AELIAFBAWohAUGKASEDDO8BCyABQQFqIQFBjwEhAwzuAQsgAUEBaiEBQZEBIQMM7QELQacBIQMgASAERg2FAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHtzwBqLQAARw1IIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyGAgsgAkEANgIAIAZBAWohAUERDEkLQagBIQMgASAERg2EAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHCzwBqLQAARw1HIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyFAgsgAkEANgIAIAZBAWohAUEsDEgLQakBIQMgASAERg2DAiACKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHFzwBqLQAARw1GIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyEAgsgAkEANgIAIAZBAWohAUErDEcLQaoBIQMgASAERg2CAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHKzwBqLQAARw1FIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyDAgsgAkEANgIAIAZBAWohAUEUDEYLIAEgBEYEQEGrASEDDIICCwJAAkACQAJAIAEtAABBwgBrDg8AAQJHR0dHR0dHR0dHRwNHCyABQQFqIQFBkwEhAwzrAQsgAUEBaiEBQZQBIQMM6gELIAFBAWohAUGVASEDDOkBCyABQQFqIQFBlgEhAwzoAQsgASAERgRAQawBIQMMgQILIAEtAABBxQBHDUIgAUEBaiEBDD0LQa0BIQMgASAERg3/ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHNzwBqLQAARw1CIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyAAgsgAkEANgIAIAZBAWohAUEODEMLIAEgBEYEQEGuASEDDP8BCyABLQAAQdAARw1AIAFBAWohAUElDEILQa8BIQMgASAERg39ASACKAIAIgAgBCABa2ohBSABIABrQQhqIQYCQANAIAEtAAAgAEHQzwBqLQAARw1AIABBCEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz+AQsgAkEANgIAIAZBAWohAUEqDEELIAEgBEYEQEGwASEDDP0BCwJAAkAgAS0AAEHVAGsOCwBAQEBAQEBAQEABQAsgAUEBaiEBQZoBIQMM5AELIAFBAWohAUGbASEDDOMBCyABIARGBEBBsQEhAwz8AQsCQAJAIAEtAABBwQBrDhQAPz8/Pz8/Pz8/Pz8/Pz8/Pz8/AT8LIAFBAWohAUGZASEDDOMBCyABQQFqIQFBnAEhAwziAQtBsgEhAyABIARGDfoBIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQdnPAGotAABHDT0gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPsBCyACQQA2AgAgBkEBaiEBQSEMPgtBswEhAyABIARGDfkBIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQd3PAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPoBCyACQQA2AgAgBkEBaiEBQRoMPQsgASAERgRAQbQBIQMM+QELAkACQAJAIAEtAABBxQBrDhEAPT09PT09PT09AT09PT09Aj0LIAFBAWohAUGdASEDDOEBCyABQQFqIQFBngEhAwzgAQsgAUEBaiEBQZ8BIQMM3wELQbUBIQMgASAERg33ASACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHkzwBqLQAARw06IABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz4AQsgAkEANgIAIAZBAWohAUEoDDsLQbYBIQMgASAERg32ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHqzwBqLQAARw05IABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz3AQsgAkEANgIAIAZBAWohAUEHDDoLIAEgBEYEQEG3ASEDDPYBCwJAAkAgAS0AAEHFAGsODgA5OTk5OTk5OTk5OTkBOQsgAUEBaiEBQaEBIQMM3QELIAFBAWohAUGiASEDDNwBC0G4ASEDIAEgBEYN9AEgAigCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB7c8Aai0AAEcNNyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9QELIAJBADYCACAGQQFqIQFBEgw4C0G5ASEDIAEgBEYN8wEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8M8Aai0AAEcNNiAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9AELIAJBADYCACAGQQFqIQFBIAw3C0G6ASEDIAEgBEYN8gEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8s8Aai0AAEcNNSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8wELIAJBADYCACAGQQFqIQFBDww2CyABIARGBEBBuwEhAwzyAQsCQAJAIAEtAABByQBrDgcANTU1NTUBNQsgAUEBaiEBQaUBIQMM2QELIAFBAWohAUGmASEDDNgBC0G8ASEDIAEgBEYN8AEgAigCACIAIAQgAWtqIQUgASAAa0EHaiEGAkADQCABLQAAIABB9M8Aai0AAEcNMyAAQQdGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8QELIAJBADYCACAGQQFqIQFBGww0CyABIARGBEBBvQEhAwzwAQsCQAJAAkAgAS0AAEHCAGsOEgA0NDQ0NDQ0NDQBNDQ0NDQ0AjQLIAFBAWohAUGkASEDDNgBCyABQQFqIQFBpwEhAwzXAQsgAUEBaiEBQagBIQMM1gELIAEgBEYEQEG+ASEDDO8BCyABLQAAQc4ARw0wIAFBAWohAQwsCyABIARGBEBBvwEhAwzuAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQcEAaw4VAAECAz8EBQY/Pz8HCAkKCz8MDQ4PPwsgAUEBaiEBQegAIQMM4wELIAFBAWohAUHpACEDDOIBCyABQQFqIQFB7gAhAwzhAQsgAUEBaiEBQfIAIQMM4AELIAFBAWohAUHzACEDDN8BCyABQQFqIQFB9gAhAwzeAQsgAUEBaiEBQfcAIQMM3QELIAFBAWohAUH6ACEDDNwBCyABQQFqIQFBgwEhAwzbAQsgAUEBaiEBQYQBIQMM2gELIAFBAWohAUGFASEDDNkBCyABQQFqIQFBkgEhAwzYAQsgAUEBaiEBQZgBIQMM1wELIAFBAWohAUGgASEDDNYBCyABQQFqIQFBowEhAwzVAQsgAUEBaiEBQaoBIQMM1AELIAEgBEcEQCACQRA2AgggAiABNgIEQasBIQMM1AELQcABIQMM7AELQQAhAAJAIAIoAjgiA0UNACADKAI0IgNFDQAgAiADEQAAIQALIABFDV4gAEEVRw0HIAJB0QA2AhwgAiABNgIUIAJBsBc2AhAgAkEVNgIMQQAhAwzrAQsgAUEBaiABIARHDQgaQcIBIQMM6gELA0ACQCABLQAAQQprDgQIAAALAAsgBCABQQFqIgFHDQALQcMBIQMM6QELIAEgBEcEQCACQRE2AgggAiABNgIEQQEhAwzQAQtBxAEhAwzoAQsgASAERgRAQcUBIQMM6AELAkACQCABLQAAQQprDgQBKCgAKAsgAUEBagwJCyABQQFqDAULIAEgBEYEQEHGASEDDOcBCwJAAkAgAS0AAEEKaw4XAQsLAQsLCwsLCwsLCwsLCwsLCwsLCwALCyABQQFqIQELQbABIQMMzQELIAEgBEYEQEHIASEDDOYBCyABLQAAQSBHDQkgAkEAOwEyIAFBAWohAUGzASEDDMwBCwNAIAEhAAJAIAEgBEcEQCABLQAAQTBrQf8BcSIDQQpJDQEMJwtBxwEhAwzmAQsCQCACLwEyIgFBmTNLDQAgAiABQQpsIgU7ATIgBUH+/wNxIANB//8Dc0sNACAAQQFqIQEgAiADIAVqIgM7ATIgA0H//wNxQegHSQ0BCwtBACEDIAJBADYCHCACQcEJNgIQIAJBDTYCDCACIABBAWo2AhQM5AELIAJBADYCHCACIAE2AhQgAkHwDDYCECACQRs2AgxBACEDDOMBCyACKAIEIQAgAkEANgIEIAIgACABECYiAA0BIAFBAWoLIQFBrQEhAwzIAQsgAkHBATYCHCACIAA2AgwgAiABQQFqNgIUQQAhAwzgAQsgAigCBCEAIAJBADYCBCACIAAgARAmIgANASABQQFqCyEBQa4BIQMMxQELIAJBwgE2AhwgAiAANgIMIAIgAUEBajYCFEEAIQMM3QELIAJBADYCHCACIAE2AhQgAkGXCzYCECACQQ02AgxBACEDDNwBCyACQQA2AhwgAiABNgIUIAJB4xA2AhAgAkEJNgIMQQAhAwzbAQsgAkECOgAoDKwBC0EAIQMgAkEANgIcIAJBrws2AhAgAkECNgIMIAIgAUEBajYCFAzZAQtBAiEDDL8BC0ENIQMMvgELQSYhAwy9AQtBFSEDDLwBC0EWIQMMuwELQRghAwy6AQtBHCEDDLkBC0EdIQMMuAELQSAhAwy3AQtBISEDDLYBC0EjIQMMtQELQcYAIQMMtAELQS4hAwyzAQtBPSEDDLIBC0HLACEDDLEBC0HOACEDDLABC0HYACEDDK8BC0HZACEDDK4BC0HbACEDDK0BC0HxACEDDKwBC0H0ACEDDKsBC0GNASEDDKoBC0GXASEDDKkBC0GpASEDDKgBC0GvASEDDKcBC0GxASEDDKYBCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB8Rs2AhAgAkEGNgIMDL0BCyACQQA2AgAgBkEBaiEBQSQLOgApIAIoAgQhACACQQA2AgQgAiAAIAEQJyIARQRAQeUAIQMMowELIAJB+QA2AhwgAiABNgIUIAIgADYCDEEAIQMMuwELIABBFUcEQCACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwy7AQsgAkH4ADYCHCACIAE2AhQgAkHKGDYCECACQRU2AgxBACEDDLoBCyACQQA2AhwgAiABNgIUIAJBjhs2AhAgAkEGNgIMQQAhAwy5AQsgAkEANgIcIAIgATYCFCACQf4RNgIQIAJBBzYCDEEAIQMMuAELIAJBADYCHCACIAE2AhQgAkGMHDYCECACQQc2AgxBACEDDLcBCyACQQA2AhwgAiABNgIUIAJBww82AhAgAkEHNgIMQQAhAwy2AQsgAkEANgIcIAIgATYCFCACQcMPNgIQIAJBBzYCDEEAIQMMtQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxBACEDDKIBCyACQeQANgIcIAIgATYCFCACQeMXNgIQIAJBFTYCDEEAIQMMoQELIAJBADYCACAGQQFqIQEgAi0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACEDIAJBADYCHCACIAE2AhQgAkH3CTYCECACQQg2AgwMoAELIAJBADYCACAGQQFqIQEgAi0AKUEhRg0DIAJBADYCHCACIAE2AhQgAkGbCjYCECACQQg2AgxBACEDDJ8BCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJBkDM2AhAgAkEINgIMDJ0BCyACQQA2AgAgBkEBaiEBIAItAClBI0kNACACQQA2AhwgAiABNgIUIAJB0wk2AhAgAkEINgIMQQAhAwycAQtB0QAhAwyCAQsgAS0AAEEwayIAQf8BcUEKSQRAIAIgADoAKiABQQFqIQFBzwAhAwyCAQsgAigCBCEAIAJBADYCBCACIAAgARAoIgBFDYYBIAJB3gA2AhwgAiABNgIUIAIgADYCDEEAIQMMmgELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ2GASACQdwANgIcIAIgATYCFCACIAA2AgxBACEDDJkBCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMhwELIAJB2gA2AhwgAiAFNgIUIAIgADYCDAyYAQtBACEBQQEhAwsgAiADOgArIAVBAWohAwJAAkACQCACLQAtQRBxDQACQAJAAkAgAi0AKg4DAQACBAsgBkUNAwwCCyAADQEMAgsgAUUNAQsgAigCBCEAIAJBADYCBCACIAAgAxAoIgBFBEAgAyEBDAILIAJB2AA2AhwgAiADNgIUIAIgADYCDEEAIQMMmAELIAIoAgQhACACQQA2AgQgAiAAIAMQKCIARQRAIAMhAQyHAQsgAkHZADYCHCACIAM2AhQgAiAANgIMQQAhAwyXAQtBzAAhAwx9CyAAQRVHBEAgAkEANgIcIAIgATYCFCACQZQNNgIQIAJBITYCDEEAIQMMlgELIAJB1wA2AhwgAiABNgIUIAJByRc2AhAgAkEVNgIMQQAhAwyVAQtBACEDIAJBADYCHCACIAE2AhQgAkGAETYCECACQQk2AgwMlAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0AIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMkwELQckAIQMMeQsgAkEANgIcIAIgATYCFCACQcEoNgIQIAJBBzYCDCACQQA2AgBBACEDDJEBCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAlIgBFDQAgAkHSADYCHCACIAE2AhQgAiAANgIMDJABC0HIACEDDHYLIAJBADYCACAFIQELIAJBgBI7ASogAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANAQtBxwAhAwxzCyAAQRVGBEAgAkHRADYCHCACIAE2AhQgAkHjFzYCECACQRU2AgxBACEDDIwBC0EAIQMgAkEANgIcIAIgATYCFCACQbkNNgIQIAJBGjYCDAyLAQtBACEDIAJBADYCHCACIAE2AhQgAkGgGTYCECACQR42AgwMigELIAEtAABBOkYEQCACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgBFDQEgAkHDADYCHCACIAA2AgwgAiABQQFqNgIUDIoBC0EAIQMgAkEANgIcIAIgATYCFCACQbERNgIQIAJBCjYCDAyJAQsgAUEBaiEBQTshAwxvCyACQcMANgIcIAIgADYCDCACIAFBAWo2AhQMhwELQQAhAyACQQA2AhwgAiABNgIUIAJB8A42AhAgAkEcNgIMDIYBCyACIAIvATBBEHI7ATAMZgsCQCACLwEwIgBBCHFFDQAgAi0AKEEBRw0AIAItAC1BCHFFDQMLIAIgAEH3+wNxQYAEcjsBMAwECyABIARHBEACQANAIAEtAABBMGsiAEH/AXFBCk8EQEE1IQMMbgsgAikDICIKQpmz5syZs+bMGVYNASACIApCCn4iCjcDICAKIACtQv8BgyILQn+FVg0BIAIgCiALfDcDICAEIAFBAWoiAUcNAAtBOSEDDIUBCyACKAIEIQBBACEDIAJBADYCBCACIAAgAUEBaiIBECoiAA0MDHcLQTkhAwyDAQsgAi0AMEEgcQ0GQcUBIQMMaQtBACEDIAJBADYCBCACIAEgARAqIgBFDQQgAkE6NgIcIAIgADYCDCACIAFBAWo2AhQMgQELIAItAChBAUcNACACLQAtQQhxRQ0BC0E3IQMMZgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIABEAgAkE7NgIcIAIgADYCDCACIAFBAWo2AhQMfwsgAUEBaiEBDG4LIAJBCDoALAwECyABQQFqIQEMbQtBACEDIAJBADYCHCACIAE2AhQgAkHkEjYCECACQQQ2AgwMewsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ1sIAJBNzYCHCACIAE2AhQgAiAANgIMDHoLIAIgAi8BMEEgcjsBMAtBMCEDDF8LIAJBNjYCHCACIAE2AhQgAiAANgIMDHcLIABBLEcNASABQQFqIQBBASEBAkACQAJAAkACQCACLQAsQQVrDgQDAQIEAAsgACEBDAQLQQIhAQwBC0EEIQELIAJBAToALCACIAIvATAgAXI7ATAgACEBDAELIAIgAi8BMEEIcjsBMCAAIQELQTkhAwxcCyACQQA6ACwLQTQhAwxaCyABIARGBEBBLSEDDHMLAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0EtIQMMdAsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ0CIAJBLDYCHCACIAE2AhQgAiAANgIMDHMLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAS0AAEENRgRAIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAi0ALUEBcQRAQcQBIQMMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIADQEMZQtBLyEDDFcLIAJBLjYCHCACIAE2AhQgAiAANgIMDG8LQQAhAyACQQA2AhwgAiABNgIUIAJB8BQ2AhAgAkEDNgIMDG4LQQEhAwJAAkACQAJAIAItACxBBWsOBAMBAgAECyACIAIvATBBCHI7ATAMAwtBAiEDDAELQQQhAwsgAkEBOgAsIAIgAi8BMCADcjsBMAtBKiEDDFMLQQAhAyACQQA2AhwgAiABNgIUIAJB4Q82AhAgAkEKNgIMDGsLQQEhAwJAAkACQAJAAkACQCACLQAsQQJrDgcFBAQDAQIABAsgAiACLwEwQQhyOwEwDAMLQQIhAwwBC0EEIQMLIAJBAToALCACIAIvATAgA3I7ATALQSshAwxSC0EAIQMgAkEANgIcIAIgATYCFCACQasSNgIQIAJBCzYCDAxqC0EAIQMgAkEANgIcIAIgATYCFCACQf0NNgIQIAJBHTYCDAxpCyABIARHBEADQCABLQAAQSBHDUggBCABQQFqIgFHDQALQSUhAwxpC0ElIQMMaAsgAi0ALUEBcQRAQcMBIQMMTwsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKSIABEAgAkEmNgIcIAIgADYCDCACIAFBAWo2AhQMaAsgAUEBaiEBDFwLIAFBAWohASACLwEwIgBBgAFxBEBBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAEUNBiAAQRVHDR8gAkEFNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMZwsCQCAAQaAEcUGgBEcNACACLQAtQQJxDQBBACEDIAJBADYCHCACIAE2AhQgAkGWEzYCECACQQQ2AgwMZwsgAgJ/IAIvATBBFHFBFEYEQEEBIAItAChBAUYNARogAi8BMkHlAEYMAQsgAi0AKUEFRgs6AC5BACEAAkAgAigCOCIDRQ0AIAMoAiQiA0UNACACIAMRAAAhAAsCQAJAAkACQAJAIAAOFgIBAAQEBAQEBAQEBAQEBAQEBAQEBAMECyACQQE6AC4LIAIgAi8BMEHAAHI7ATALQSchAwxPCyACQSM2AhwgAiABNgIUIAJBpRY2AhAgAkEVNgIMQQAhAwxnC0EAIQMgAkEANgIcIAIgATYCFCACQdULNgIQIAJBETYCDAxmC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAADQELQQ4hAwxLCyAAQRVGBEAgAkECNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMZAtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMYwtBACEDIAJBADYCHCACIAE2AhQgAkGqHDYCECACQQ82AgwMYgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEgCqdqIgEQKyIARQ0AIAJBBTYCHCACIAE2AhQgAiAANgIMDGELQQ8hAwxHC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxfC0IBIQoLIAFBAWohAQJAIAIpAyAiC0L//////////w9YBEAgAiALQgSGIAqENwMgDAELQQAhAyACQQA2AhwgAiABNgIUIAJBrQk2AhAgAkEMNgIMDF4LQSQhAwxEC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxcCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAsIgBFBEAgAUEBaiEBDFILIAJBFzYCHCACIAA2AgwgAiABQQFqNgIUDFsLIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQRY2AhwgAiAANgIMIAIgAUEBajYCFAxbC0EfIQMMQQtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQLSIARQRAIAFBAWohAQxQCyACQRQ2AhwgAiAANgIMIAIgAUEBajYCFAxYCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABEC0iAEUEQCABQQFqIQEMAQsgAkETNgIcIAIgADYCDCACIAFBAWo2AhQMWAtBHiEDDD4LQQAhAyACQQA2AhwgAiABNgIUIAJBxgw2AhAgAkEjNgIMDFYLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABEC0iAEUEQCABQQFqIQEMTgsgAkERNgIcIAIgADYCDCACIAFBAWo2AhQMVQsgAkEQNgIcIAIgATYCFCACIAA2AgwMVAtBACEDIAJBADYCHCACIAE2AhQgAkHGDDYCECACQSM2AgwMUwtBACEDIAJBADYCHCACIAE2AhQgAkHAFTYCECACQQI2AgwMUgsgAigCBCEAQQAhAyACQQA2AgQCQCACIAAgARAtIgBFBEAgAUEBaiEBDAELIAJBDjYCHCACIAA2AgwgAiABQQFqNgIUDFILQRshAww4C0EAIQMgAkEANgIcIAIgATYCFCACQcYMNgIQIAJBIzYCDAxQCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABECwiAEUEQCABQQFqIQEMAQsgAkENNgIcIAIgADYCDCACIAFBAWo2AhQMUAtBGiEDDDYLQQAhAyACQQA2AhwgAiABNgIUIAJBmg82AhAgAkEiNgIMDE4LIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQQw2AhwgAiAANgIMIAIgAUEBajYCFAxOC0EZIQMMNAtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMTAsgAEEVRwRAQQAhAyACQQA2AhwgAiABNgIUIAJBgww2AhAgAkETNgIMDEwLIAJBCjYCHCACIAE2AhQgAkHkFjYCECACQRU2AgxBACEDDEsLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABIAqnaiIBECsiAARAIAJBBzYCHCACIAE2AhQgAiAANgIMDEsLQRMhAwwxCyAAQRVHBEBBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMSgsgAkEeNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMSQtBACEAAkAgAigCOCIDRQ0AIAMoAiwiA0UNACACIAMRAAAhAAsgAEUNQSAAQRVGBEAgAkEDNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMSQtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMSAtBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMRwtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMRgsgAkEAOgAvIAItAC1BBHFFDT8LIAJBADoALyACQQE6ADRBACEDDCsLQQAhAyACQQA2AhwgAkHkETYCECACQQc2AgwgAiABQQFqNgIUDEMLAkADQAJAIAEtAABBCmsOBAACAgACCyAEIAFBAWoiAUcNAAtB3QEhAwxDCwJAAkAgAi0ANEEBRw0AQQAhAAJAIAIoAjgiA0UNACADKAJYIgNFDQAgAiADEQAAIQALIABFDQAgAEEVRw0BIAJB3AE2AhwgAiABNgIUIAJB1RY2AhAgAkEVNgIMQQAhAwxEC0HBASEDDCoLIAJBADYCHCACIAE2AhQgAkHpCzYCECACQR82AgxBACEDDEILAkACQCACLQAoQQFrDgIEAQALQcABIQMMKQtBuQEhAwwoCyACQQI6AC9BACEAAkAgAigCOCIDRQ0AIAMoAgAiA0UNACACIAMRAAAhAAsgAEUEQEHCASEDDCgLIABBFUcEQCACQQA2AhwgAiABNgIUIAJBpAw2AhAgAkEQNgIMQQAhAwxBCyACQdsBNgIcIAIgATYCFCACQfoWNgIQIAJBFTYCDEEAIQMMQAsgASAERgRAQdoBIQMMQAsgAS0AAEHIAEYNASACQQE6ACgLQawBIQMMJQtBvwEhAwwkCyABIARHBEAgAkEQNgIIIAIgATYCBEG+ASEDDCQLQdkBIQMMPAsgASAERgRAQdgBIQMMPAsgAS0AAEHIAEcNBCABQQFqIQFBvQEhAwwiCyABIARGBEBB1wEhAww7CwJAAkAgAS0AAEHFAGsOEAAFBQUFBQUFBQUFBQUFBQEFCyABQQFqIQFBuwEhAwwiCyABQQFqIQFBvAEhAwwhC0HWASEDIAEgBEYNOSACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGD0ABqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw6CyACKAIEIQAgAkIANwMAIAIgACAGQQFqIgEQJyIARQRAQcYBIQMMIQsgAkHVATYCHCACIAE2AhQgAiAANgIMQQAhAww5C0HUASEDIAEgBEYNOCACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGB0ABqLQAARw0CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw5CyACQYEEOwEoIAIoAgQhACACQgA3AwAgAiAAIAZBAWoiARAnIgANAwwCCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB2Bs2AhAgAkEINgIMDDYLQboBIQMMHAsgAkHTATYCHCACIAE2AhQgAiAANgIMQQAhAww0C0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAARQ0AIABBFUYNASACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwwzC0HkACEDDBkLIAJB+AA2AhwgAiABNgIUIAJByhg2AhAgAkEVNgIMQQAhAwwxC0HSASEDIAQgASIARg0wIAQgAWsgAigCACIBaiEFIAAgAWtBBGohBgJAA0AgAC0AACABQfzPAGotAABHDQEgAUEERg0DIAFBAWohASAEIABBAWoiAEcNAAsgAiAFNgIADDELIAJBADYCHCACIAA2AhQgAkGQMzYCECACQQg2AgwgAkEANgIAQQAhAwwwCyABIARHBEAgAkEONgIIIAIgATYCBEG3ASEDDBcLQdEBIQMMLwsgAkEANgIAIAZBAWohAQtBuAEhAwwUCyABIARGBEBB0AEhAwwtCyABLQAAQTBrIgBB/wFxQQpJBEAgAiAAOgAqIAFBAWohAUG2ASEDDBQLIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0UIAJBzwE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAsgASAERgRAQc4BIQMMLAsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0VIAJBzQE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAtBtQEhAwwSCyAEIAEiBUYEQEHMASEDDCsLQQAhAEEBIQFBASEGQQAhAwJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAUtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyEDQQAhAUEAIQYMAgtBCSEDQQEhAEEAIQFBACEGDAELQQAhAUEBIQMLIAIgAzoAKyAFQQFqIQMCQAJAIAItAC1BEHENAAJAAkACQCACLQAqDgMBAAIECyAGRQ0DDAILIAANAQwCCyABRQ0BCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMAwsgAkHJATYCHCACIAM2AhQgAiAANgIMQQAhAwwtCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMGAsgAkHKATYCHCACIAM2AhQgAiAANgIMQQAhAwwsCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMFgsgAkHLATYCHCACIAU2AhQgAiAANgIMDCsLQbQBIQMMEQtBACEAAkAgAigCOCIDRQ0AIAMoAjwiA0UNACACIAMRAAAhAAsCQCAABEAgAEEVRg0BIAJBADYCHCACIAE2AhQgAkGUDTYCECACQSE2AgxBACEDDCsLQbIBIQMMEQsgAkHIATYCHCACIAE2AhQgAkHJFzYCECACQRU2AgxBACEDDCkLIAJBADYCACAGQQFqIQFB9QAhAwwPCyACLQApQQVGBEBB4wAhAwwPC0HiACEDDA4LIAAhASACQQA2AgALIAJBADoALEEJIQMMDAsgAkEANgIAIAdBAWohAUHAACEDDAsLQQELOgAsIAJBADYCACAGQQFqIQELQSkhAwwIC0E4IQMMBwsCQCABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBPiEDDCELQT4hAwwgCwsgAkEAOgAsDAELQQshAwwEC0E6IQMMAwsgAUEBaiEBQS0hAwwCCyACIAE6ACwgAkEANgIAIAZBAWohAUEMIQMMAQsgAkEANgIAIAZBAWohAUEKIQMMAAsAC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwXC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwWC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwVC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwUC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwTC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwSC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwRC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwQC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwPC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwOC0EAIQMgAkEANgIcIAIgATYCFCACQcASNgIQIAJBCzYCDAwNC0EAIQMgAkEANgIcIAIgATYCFCACQZUJNgIQIAJBCzYCDAwMC0EAIQMgAkEANgIcIAIgATYCFCACQeEPNgIQIAJBCjYCDAwLC0EAIQMgAkEANgIcIAIgATYCFCACQfsPNgIQIAJBCjYCDAwKC0EAIQMgAkEANgIcIAIgATYCFCACQfEZNgIQIAJBAjYCDAwJC0EAIQMgAkEANgIcIAIgATYCFCACQcQUNgIQIAJBAjYCDAwIC0EAIQMgAkEANgIcIAIgATYCFCACQfIVNgIQIAJBAjYCDAwHCyACQQI2AhwgAiABNgIUIAJBnBo2AhAgAkEWNgIMQQAhAwwGC0EBIQMMBQtB1AAhAyABIARGDQQgCEEIaiEJIAIoAgAhBQJAAkAgASAERwRAIAVB2MIAaiEHIAQgBWogAWshACAFQX9zQQpqIgUgAWohBgNAIAEtAAAgBy0AAEcEQEECIQcMAwsgBUUEQEEAIQcgBiEBDAMLIAVBAWshBSAHQQFqIQcgBCABQQFqIgFHDQALIAAhBSAEIQELIAlBATYCACACIAU2AgAMAQsgAkEANgIAIAkgBzYCAAsgCSABNgIEIAgoAgwhACAIKAIIDgMBBAIACwALIAJBADYCHCACQbUaNgIQIAJBFzYCDCACIABBAWo2AhRBACEDDAILIAJBADYCHCACIAA2AhQgAkHKGjYCECACQQk2AgxBACEDDAELIAEgBEYEQEEiIQMMAQsgAkEJNgIIIAIgATYCBEEhIQMLIAhBEGokACADRQRAIAIoAgwhAAwBCyACIAM2AhxBACEAIAIoAgQiAUUNACACIAEgBCACKAIIEQEAIgFFDQAgAiAENgIUIAIgATYCDCABIQALIAALvgIBAn8gAEEAOgAAIABB3ABqIgFBAWtBADoAACAAQQA6AAIgAEEAOgABIAFBA2tBADoAACABQQJrQQA6AAAgAEEAOgADIAFBBGtBADoAAEEAIABrQQNxIgEgAGoiAEEANgIAQdwAIAFrQXxxIgIgAGoiAUEEa0EANgIAAkAgAkEJSQ0AIABBADYCCCAAQQA2AgQgAUEIa0EANgIAIAFBDGtBADYCACACQRlJDQAgAEEANgIYIABBADYCFCAAQQA2AhAgAEEANgIMIAFBEGtBADYCACABQRRrQQA2AgAgAUEYa0EANgIAIAFBHGtBADYCACACIABBBHFBGHIiAmsiAUEgSQ0AIAAgAmohAANAIABCADcDGCAAQgA3AxAgAEIANwMIIABCADcDACAAQSBqIQAgAUEgayIBQR9LDQALCwtWAQF/AkAgACgCDA0AAkACQAJAAkAgAC0ALw4DAQADAgsgACgCOCIBRQ0AIAEoAiwiAUUNACAAIAERAAAiAQ0DC0EADwsACyAAQcMWNgIQQQ4hAQsgAQsaACAAKAIMRQRAIABB0Rs2AhAgAEEVNgIMCwsUACAAKAIMQRVGBEAgAEEANgIMCwsUACAAKAIMQRZGBEAgAEEANgIMCwsHACAAKAIMCwcAIAAoAhALCQAgACABNgIQCwcAIAAoAhQLFwAgAEEkTwRAAAsgAEECdEGgM2ooAgALFwAgAEEuTwRAAAsgAEECdEGwNGooAgALvwkBAX9B6yghAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB9ysPC0GQMQ8LQdcxDwtBoi0PC0HUJw8LQeArDwtBnywPC0HrMQ8LQdUfDwtByjEPC0HeJQ8LQdQeDwtB9BwPC0GnMg8LQbEdDwtBoB0PC0G5MQ8LQbwwDwtBkiEPC0GzJg8LQeksDwtBrB4PC0HUKw8LQfcmDwtBgCYPC0GwIQ8LQf4eDwtBjSMPC0GJLQ8LQfciDwtBoDEPC0GuHw8LQcYlDwtB6B4PC0GTIg8LQcIvDwtBwx0PC0GLLA8LQeEdDwtBjS8PC0HqIQ8LQbQtDwtB0i8PC0HfMg8LQdIyDwtB8DAPC0GpIg8LQfkjDwtBmR4PC0G1LA8LQZswDwtBkjIPC0G2Kw8LQcIiDwtB+DIPC0GeJQ8LQdAiDwtBuh4PC0GBHg8LAAtB1iEhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBxhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9go2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7Ro2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBqhs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7RM2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBwhk2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlBQ2AhBBGCEECyAEC1kBAn8CQCAALQAoQQFGDQAgAC8BMiIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEwIgFBAnFFDQEMAgsgAC8BMCIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATIiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtXACAAQRhqQgA3AwAgAEIANwMAIABBOGpCADcDACAAQTBqQgA3AwAgAEEoakIANwMAIABBIGpCADcDACAAQRBqQgA3AwAgAEEIakIANwMAIABB3QE2AhwLBgAgABAyC5otAQt/IwBBEGsiCiQAQaTQACgCACIJRQRAQeTTACgCACIFRQRAQfDTAEJ/NwIAQejTAEKAgISAgIDAADcCAEHk0wAgCkEIakFwcUHYqtWqBXMiBTYCAEH40wBBADYCAEHI0wBBADYCAAtBzNMAQYDUBDYCAEGc0ABBgNQENgIAQbDQACAFNgIAQazQAEF/NgIAQdDTAEGArAM2AgADQCABQcjQAGogAUG80ABqIgI2AgAgAiABQbTQAGoiAzYCACABQcDQAGogAzYCACABQdDQAGogAUHE0ABqIgM2AgAgAyACNgIAIAFB2NAAaiABQczQAGoiAjYCACACIAM2AgAgAUHU0ABqIAI2AgAgAUEgaiIBQYACRw0AC0GM1ARBwasDNgIAQajQAEH00wAoAgA2AgBBmNAAQcCrAzYCAEGk0ABBiNQENgIAQcz/B0E4NgIAQYjUBCEJCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFNBEBBjNAAKAIAIgZBECAAQRNqQXBxIABBC0kbIgRBA3YiAHYiAUEDcQRAAkAgAUEBcSAAckEBcyICQQN0IgBBtNAAaiIBIABBvNAAaigCACIAKAIIIgNGBEBBjNAAIAZBfiACd3E2AgAMAQsgASADNgIIIAMgATYCDAsgAEEIaiEBIAAgAkEDdCICQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDBELQZTQACgCACIIIARPDQEgAQRAAkBBAiAAdCICQQAgAmtyIAEgAHRxaCIAQQN0IgJBtNAAaiIBIAJBvNAAaigCACICKAIIIgNGBEBBjNAAIAZBfiAAd3EiBjYCAAwBCyABIAM2AgggAyABNgIMCyACIARBA3I2AgQgAEEDdCIAIARrIQUgACACaiAFNgIAIAIgBGoiBCAFQQFyNgIEIAgEQCAIQXhxQbTQAGohAEGg0AAoAgAhAwJ/QQEgCEEDdnQiASAGcUUEQEGM0AAgASAGcjYCACAADAELIAAoAggLIgEgAzYCDCAAIAM2AgggAyAANgIMIAMgATYCCAsgAkEIaiEBQaDQACAENgIAQZTQACAFNgIADBELQZDQACgCACILRQ0BIAtoQQJ0QbzSAGooAgAiACgCBEF4cSAEayEFIAAhAgNAAkAgAigCECIBRQRAIAJBFGooAgAiAUUNAQsgASgCBEF4cSAEayIDIAVJIQIgAyAFIAIbIQUgASAAIAIbIQAgASECDAELCyAAKAIYIQkgACgCDCIDIABHBEBBnNAAKAIAGiADIAAoAggiATYCCCABIAM2AgwMEAsgAEEUaiICKAIAIgFFBEAgACgCECIBRQ0DIABBEGohAgsDQCACIQcgASIDQRRqIgIoAgAiAQ0AIANBEGohAiADKAIQIgENAAsgB0EANgIADA8LQX8hBCAAQb9/Sw0AIABBE2oiAUFwcSEEQZDQACgCACIIRQ0AQQAgBGshBQJAAkACQAJ/QQAgBEGAAkkNABpBHyAEQf///wdLDQAaIARBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmoLIgZBAnRBvNIAaigCACICRQRAQQAhAUEAIQMMAQtBACEBIARBGSAGQQF2a0EAIAZBH0cbdCEAQQAhAwNAAkAgAigCBEF4cSAEayIHIAVPDQAgAiEDIAciBQ0AQQAhBSACIQEMAwsgASACQRRqKAIAIgcgByACIABBHXZBBHFqQRBqKAIAIgJGGyABIAcbIQEgAEEBdCEAIAINAAsLIAEgA3JFBEBBACEDQQIgBnQiAEEAIABrciAIcSIARQ0DIABoQQJ0QbzSAGooAgAhAQsgAUUNAQsDQCABKAIEQXhxIARrIgIgBUkhACACIAUgABshBSABIAMgABshAyABKAIQIgAEfyAABSABQRRqKAIACyIBDQALCyADRQ0AIAVBlNAAKAIAIARrTw0AIAMoAhghByADIAMoAgwiAEcEQEGc0AAoAgAaIAAgAygCCCIBNgIIIAEgADYCDAwOCyADQRRqIgIoAgAiAUUEQCADKAIQIgFFDQMgA0EQaiECCwNAIAIhBiABIgBBFGoiAigCACIBDQAgAEEQaiECIAAoAhAiAQ0ACyAGQQA2AgAMDQtBlNAAKAIAIgMgBE8EQEGg0AAoAgAhAQJAIAMgBGsiAkEQTwRAIAEgBGoiACACQQFyNgIEIAEgA2ogAjYCACABIARBA3I2AgQMAQsgASADQQNyNgIEIAEgA2oiACAAKAIEQQFyNgIEQQAhAEEAIQILQZTQACACNgIAQaDQACAANgIAIAFBCGohAQwPC0GY0AAoAgAiAyAESwRAIAQgCWoiACADIARrIgFBAXI2AgRBpNAAIAA2AgBBmNAAIAE2AgAgCSAEQQNyNgIEIAlBCGohAQwPC0EAIQEgBAJ/QeTTACgCAARAQezTACgCAAwBC0Hw0wBCfzcCAEHo0wBCgICEgICAwAA3AgBB5NMAIApBDGpBcHFB2KrVqgVzNgIAQfjTAEEANgIAQcjTAEEANgIAQYCABAsiACAEQccAaiIFaiIGQQAgAGsiB3EiAk8EQEH80wBBMDYCAAwPCwJAQcTTACgCACIBRQ0AQbzTACgCACIIIAJqIQAgACABTSAAIAhLcQ0AQQAhAUH80wBBMDYCAAwPC0HI0wAtAABBBHENBAJAAkAgCQRAQczTACEBA0AgASgCACIAIAlNBEAgACABKAIEaiAJSw0DCyABKAIIIgENAAsLQQAQMyIAQX9GDQUgAiEGQejTACgCACIBQQFrIgMgAHEEQCACIABrIAAgA2pBACABa3FqIQYLIAQgBk8NBSAGQf7///8HSw0FQcTTACgCACIDBEBBvNMAKAIAIgcgBmohASABIAdNDQYgASADSw0GCyAGEDMiASAARw0BDAcLIAYgA2sgB3EiBkH+////B0sNBCAGEDMhACAAIAEoAgAgASgCBGpGDQMgACEBCwJAIAYgBEHIAGpPDQAgAUF/Rg0AQezTACgCACIAIAUgBmtqQQAgAGtxIgBB/v///wdLBEAgASEADAcLIAAQM0F/RwRAIAAgBmohBiABIQAMBwtBACAGaxAzGgwECyABIgBBf0cNBQwDC0EAIQMMDAtBACEADAoLIABBf0cNAgtByNMAQcjTACgCAEEEcjYCAAsgAkH+////B0sNASACEDMhAEEAEDMhASAAQX9GDQEgAUF/Rg0BIAAgAU8NASABIABrIgYgBEE4ak0NAQtBvNMAQbzTACgCACAGaiIBNgIAQcDTACgCACABSQRAQcDTACABNgIACwJAAkACQEGk0AAoAgAiAgRAQczTACEBA0AgACABKAIAIgMgASgCBCIFakYNAiABKAIIIgENAAsMAgtBnNAAKAIAIgFBAEcgACABT3FFBEBBnNAAIAA2AgALQQAhAUHQ0wAgBjYCAEHM0wAgADYCAEGs0ABBfzYCAEGw0ABB5NMAKAIANgIAQdjTAEEANgIAA0AgAUHI0ABqIAFBvNAAaiICNgIAIAIgAUG00ABqIgM2AgAgAUHA0ABqIAM2AgAgAUHQ0ABqIAFBxNAAaiIDNgIAIAMgAjYCACABQdjQAGogAUHM0ABqIgI2AgAgAiADNgIAIAFB1NAAaiACNgIAIAFBIGoiAUGAAkcNAAtBeCAAa0EPcSIBIABqIgIgBkE4ayIDIAFrIgFBAXI2AgRBqNAAQfTTACgCADYCAEGY0AAgATYCAEGk0AAgAjYCACAAIANqQTg2AgQMAgsgACACTQ0AIAIgA0kNACABKAIMQQhxDQBBeCACa0EPcSIAIAJqIgNBmNAAKAIAIAZqIgcgAGsiAEEBcjYCBCABIAUgBmo2AgRBqNAAQfTTACgCADYCAEGY0AAgADYCAEGk0AAgAzYCACACIAdqQTg2AgQMAQsgAEGc0AAoAgBJBEBBnNAAIAA2AgALIAAgBmohA0HM0wAhAQJAAkACQANAIAMgASgCAEcEQCABKAIIIgENAQwCCwsgAS0ADEEIcUUNAQtBzNMAIQEDQCABKAIAIgMgAk0EQCADIAEoAgRqIgUgAksNAwsgASgCCCEBDAALAAsgASAANgIAIAEgASgCBCAGajYCBCAAQXggAGtBD3FqIgkgBEEDcjYCBCADQXggA2tBD3FqIgYgBCAJaiIEayEBIAIgBkYEQEGk0AAgBDYCAEGY0ABBmNAAKAIAIAFqIgA2AgAgBCAAQQFyNgIEDAgLQaDQACgCACAGRgRAQaDQACAENgIAQZTQAEGU0AAoAgAgAWoiADYCACAEIABBAXI2AgQgACAEaiAANgIADAgLIAYoAgQiBUEDcUEBRw0GIAVBeHEhCCAFQf8BTQRAIAVBA3YhAyAGKAIIIgAgBigCDCICRgRAQYzQAEGM0AAoAgBBfiADd3E2AgAMBwsgAiAANgIIIAAgAjYCDAwGCyAGKAIYIQcgBiAGKAIMIgBHBEAgACAGKAIIIgI2AgggAiAANgIMDAULIAZBFGoiAigCACIFRQRAIAYoAhAiBUUNBCAGQRBqIQILA0AgAiEDIAUiAEEUaiICKAIAIgUNACAAQRBqIQIgACgCECIFDQALIANBADYCAAwEC0F4IABrQQ9xIgEgAGoiByAGQThrIgMgAWsiAUEBcjYCBCAAIANqQTg2AgQgAiAFQTcgBWtBD3FqQT9rIgMgAyACQRBqSRsiA0EjNgIEQajQAEH00wAoAgA2AgBBmNAAIAE2AgBBpNAAIAc2AgAgA0EQakHU0wApAgA3AgAgA0HM0wApAgA3AghB1NMAIANBCGo2AgBB0NMAIAY2AgBBzNMAIAA2AgBB2NMAQQA2AgAgA0EkaiEBA0AgAUEHNgIAIAUgAUEEaiIBSw0ACyACIANGDQAgAyADKAIEQX5xNgIEIAMgAyACayIFNgIAIAIgBUEBcjYCBCAFQf8BTQRAIAVBeHFBtNAAaiEAAn9BjNAAKAIAIgFBASAFQQN2dCIDcUUEQEGM0AAgASADcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbzSAGohAEGQ0AAoAgAiA0EBIAF0IgZxRQRAIAAgAjYCAEGQ0AAgAyAGcjYCACACIAA2AhggAiACNgIIIAIgAjYCDAwBCyAFQRkgAUEBdmtBACABQR9HG3QhASAAKAIAIQMCQANAIAMiACgCBEF4cSAFRg0BIAFBHXYhAyABQQF0IQEgACADQQRxakEQaiIGKAIAIgMNAAsgBiACNgIAIAIgADYCGCACIAI2AgwgAiACNgIIDAELIAAoAggiASACNgIMIAAgAjYCCCACQQA2AhggAiAANgIMIAIgATYCCAtBmNAAKAIAIgEgBE0NAEGk0AAoAgAiACAEaiICIAEgBGsiAUEBcjYCBEGY0AAgATYCAEGk0AAgAjYCACAAIARBA3I2AgQgAEEIaiEBDAgLQQAhAUH80wBBMDYCAAwHC0EAIQALIAdFDQACQCAGKAIcIgJBAnRBvNIAaiIDKAIAIAZGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAdBEEEUIAcoAhAgBkYbaiAANgIAIABFDQELIAAgBzYCGCAGKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAGQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAIaiEBIAYgCGoiBigCBCEFCyAGIAVBfnE2AgQgASAEaiABNgIAIAQgAUEBcjYCBCABQf8BTQRAIAFBeHFBtNAAaiEAAn9BjNAAKAIAIgJBASABQQN2dCIBcUUEQEGM0AAgASACcjYCACAADAELIAAoAggLIgEgBDYCDCAAIAQ2AgggBCAANgIMIAQgATYCCAwBC0EfIQUgAUH///8HTQRAIAFBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmohBQsgBCAFNgIcIARCADcCECAFQQJ0QbzSAGohAEGQ0AAoAgAiAkEBIAV0IgNxRQRAIAAgBDYCAEGQ0AAgAiADcjYCACAEIAA2AhggBCAENgIIIAQgBDYCDAwBCyABQRkgBUEBdmtBACAFQR9HG3QhBSAAKAIAIQACQANAIAAiAigCBEF4cSABRg0BIAVBHXYhACAFQQF0IQUgAiAAQQRxakEQaiIDKAIAIgANAAsgAyAENgIAIAQgAjYCGCAEIAQ2AgwgBCAENgIIDAELIAIoAggiACAENgIMIAIgBDYCCCAEQQA2AhggBCACNgIMIAQgADYCCAsgCUEIaiEBDAILAkAgB0UNAAJAIAMoAhwiAUECdEG80gBqIgIoAgAgA0YEQCACIAA2AgAgAA0BQZDQACAIQX4gAXdxIgg2AgAMAgsgB0EQQRQgBygCECADRhtqIAA2AgAgAEUNAQsgACAHNgIYIAMoAhAiAQRAIAAgATYCECABIAA2AhgLIANBFGooAgAiAUUNACAAQRRqIAE2AgAgASAANgIYCwJAIAVBD00EQCADIAQgBWoiAEEDcjYCBCAAIANqIgAgACgCBEEBcjYCBAwBCyADIARqIgIgBUEBcjYCBCADIARBA3I2AgQgAiAFaiAFNgIAIAVB/wFNBEAgBUF4cUG00ABqIQACf0GM0AAoAgAiAUEBIAVBA3Z0IgVxRQRAQYzQACABIAVyNgIAIAAMAQsgACgCCAsiASACNgIMIAAgAjYCCCACIAA2AgwgAiABNgIIDAELQR8hASAFQf///wdNBEAgBUEmIAVBCHZnIgBrdkEBcSAAQQF0a0E+aiEBCyACIAE2AhwgAkIANwIQIAFBAnRBvNIAaiEAQQEgAXQiBCAIcUUEQCAAIAI2AgBBkNAAIAQgCHI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEEAkADQCAEIgAoAgRBeHEgBUYNASABQR12IQQgAUEBdCEBIAAgBEEEcWpBEGoiBigCACIEDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLIANBCGohAQwBCwJAIAlFDQACQCAAKAIcIgFBAnRBvNIAaiICKAIAIABGBEAgAiADNgIAIAMNAUGQ0AAgC0F+IAF3cTYCAAwCCyAJQRBBFCAJKAIQIABGG2ogAzYCACADRQ0BCyADIAk2AhggACgCECIBBEAgAyABNgIQIAEgAzYCGAsgAEEUaigCACIBRQ0AIANBFGogATYCACABIAM2AhgLAkAgBUEPTQRAIAAgBCAFaiIBQQNyNgIEIAAgAWoiASABKAIEQQFyNgIEDAELIAAgBGoiByAFQQFyNgIEIAAgBEEDcjYCBCAFIAdqIAU2AgAgCARAIAhBeHFBtNAAaiEBQaDQACgCACEDAn9BASAIQQN2dCICIAZxRQRAQYzQACACIAZyNgIAIAEMAQsgASgCCAsiAiADNgIMIAEgAzYCCCADIAE2AgwgAyACNgIIC0Gg0AAgBzYCAEGU0AAgBTYCAAsgAEEIaiEBCyAKQRBqJAAgAQtDACAARQRAPwBBEHQPCwJAIABB//8DcQ0AIABBAEgNACAAQRB2QAAiAEF/RgRAQfzTAEEwNgIAQX8PCyAAQRB0DwsACwvcPyIAQYAICwkBAAAAAgAAAAMAQZQICwUEAAAABQBBpAgLCQYAAAAHAAAACABB3AgLii1JbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AFJlc3BvbnNlIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fbWV0aG9kAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAF4TAAAmEwAAMBAAAPAXAACdEwAAFRIAADkXAADwEgAAChAAAHUSAACtEgAAghMAAE8UAAB/EAAAoBUAACMUAACJEgAAixQAAE0VAADUEQAAzxQAABAYAADJFgAA3BYAAMERAADgFwAAuxQAAHQUAAB8FQAA5RQAAAgXAAAfEAAAZRUAAKMUAAAoFQAAAhUAAJkVAAAsEAAAixkAAE8PAADUDgAAahAAAM4QAAACFwAAiQ4AAG4TAAAcEwAAZhQAAFYXAADBEwAAzRMAAGwTAABoFwAAZhcAAF8XAAAiEwAAzg8AAGkOAADYDgAAYxYAAMsTAACqDgAAKBcAACYXAADFEwAAXRYAAOgRAABnEwAAZRMAAPIWAABzEwAAHRcAAPkWAADzEQAAzw4AAM4VAAAMEgAAsxEAAKURAABhEAAAMhcAALsTAEH5NQsBAQBBkDYL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB/TcLAQEAQZE4C14CAwICAgICAAACAgACAgACAgICAgICAgICAAQAAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEH9OQsBAQBBkToLXgIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAQfA7Cw1sb3NlZWVwLWFsaXZlAEGJPAsBAQBBoDwL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBiT4LAQEAQaA+C+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGwwAALXwEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGQwgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBwMIACy1yYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AQfnCAAsFAQIAAQMAQZDDAAvgAQQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5xAALBQECAAEDAEGQxQAL4AEEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cYACwQBAAABAEGRxwAL3wEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH6yAALBAEAAAIAQZDJAAtfAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAQfrKAAsEAQAAAQBBkMsACwEBAEGqywALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEH6zAALBAEAAAEAQZDNAAsBAQBBms0ACwYCAAAAAAIAQbHNAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB8M4AC5YBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv",
    "base64",
  )
})
var Hre = _((mDt, Vre) => {
  "use strict"
  var { Buffer: u4e } = require("buffer")
  Vre.exports = u4e.from(
    "AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVuaWVudF9oZWFkZXJzACEhbGxodHRwX3NldF9sZW5pZW50X2NodW5rZWRfbGVuZ3RoACIdbGxodHRwX3NldF9sZW5pZW50X2tlZXBfYWxpdmUAIyRsbGh0dHBfc2V0X2xlbmllbnRfdHJhbnNmZXJfZW5jb2RpbmcAJBhsbGh0dHBfbWVzc2FnZV9uZWVkc19lb2YALgkXAQBBAQsRAQIDBAUKBgcrLSwqKSglJyYK77MCLBYAQYjQACgCAARAAAtBiNAAQQE2AgALFAAgABAwIAAgAjYCOCAAIAE6ACgLFAAgACAALwEyIAAtAC4gABAvEAALHgEBf0HAABAyIgEQMCABQYAINgI4IAEgADoAKCABC48MAQd/AkAgAEUNACAAQQhrIgEgAEEEaygCACIAQXhxIgRqIQUCQCAAQQFxDQAgAEEDcUUNASABIAEoAgAiAGsiAUGc0AAoAgBJDQEgACAEaiEEAkACQEGg0AAoAgAgAUcEQCAAQf8BTQRAIABBA3YhAyABKAIIIgAgASgCDCICRgRAQYzQAEGM0AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyABKAIYIQYgASABKAIMIgBHBEAgACABKAIIIgI2AgggAiAANgIMDAMLIAFBFGoiAygCACICRQRAIAEoAhAiAkUNAiABQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFKAIEIgBBA3FBA0cNAiAFIABBfnE2AgRBlNAAIAQ2AgAgBSAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCABKAIcIgJBAnRBvNIAaiIDKAIAIAFGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgAUYbaiAANgIAIABFDQELIAAgBjYCGCABKAIQIgIEQCAAIAI2AhAgAiAANgIYCyABQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAFTw0AIAUoAgQiAEEBcUUNAAJAAkACQAJAIABBAnFFBEBBpNAAKAIAIAVGBEBBpNAAIAE2AgBBmNAAQZjQACgCACAEaiIANgIAIAEgAEEBcjYCBCABQaDQACgCAEcNBkGU0ABBADYCAEGg0ABBADYCAAwGC0Gg0AAoAgAgBUYEQEGg0AAgATYCAEGU0ABBlNAAKAIAIARqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAAwGCyAAQXhxIARqIQQgAEH/AU0EQCAAQQN2IQMgBSgCCCIAIAUoAgwiAkYEQEGM0ABBjNAAKAIAQX4gA3dxNgIADAULIAIgADYCCCAAIAI2AgwMBAsgBSgCGCEGIAUgBSgCDCIARwRAQZzQACgCABogACAFKAIIIgI2AgggAiAANgIMDAMLIAVBFGoiAygCACICRQRAIAUoAhAiAkUNAiAFQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFIABBfnE2AgQgASAEaiAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCAFKAIcIgJBAnRBvNIAaiIDKAIAIAVGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiAANgIAIABFDQELIAAgBjYCGCAFKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAFQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAEaiAENgIAIAEgBEEBcjYCBCABQaDQACgCAEcNAEGU0AAgBDYCAAwBCyAEQf8BTQRAIARBeHFBtNAAaiEAAn9BjNAAKAIAIgJBASAEQQN2dCIDcUUEQEGM0AAgAiADcjYCACAADAELIAAoAggLIgIgATYCDCAAIAE2AgggASAANgIMIAEgAjYCCAwBC0EfIQIgBEH///8HTQRAIARBJiAEQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAgsgASACNgIcIAFCADcCECACQQJ0QbzSAGohAAJAQZDQACgCACIDQQEgAnQiB3FFBEAgACABNgIAQZDQACADIAdyNgIAIAEgADYCGCABIAE2AgggASABNgIMDAELIARBGSACQQF2a0EAIAJBH0cbdCECIAAoAgAhAAJAA0AgACIDKAIEQXhxIARGDQEgAkEddiEAIAJBAXQhAiADIABBBHFqQRBqIgcoAgAiAA0ACyAHIAE2AgAgASADNgIYIAEgATYCDCABIAE2AggMAQsgAygCCCIAIAE2AgwgAyABNgIIIAFBADYCGCABIAM2AgwgASAANgIIC0Gs0ABBrNAAKAIAQQFrIgBBfyAAGzYCAAsLBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LQAEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABAwIAAgBDYCOCAAIAM6ACggACACOgAtIAAgATYCGAu74gECB38DfiABIAJqIQQCQCAAIgIoAgwiAA0AIAIoAgQEQCACIAE2AgQLIwBBEGsiCCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIoAhwiA0EBaw7dAdoBAdkBAgMEBQYHCAkKCwwNDtgBDxDXARES1gETFBUWFxgZGhvgAd8BHB0e1QEfICEiIyQl1AEmJygpKiss0wHSAS0u0QHQAS8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRtsBR0hJSs8BzgFLzQFMzAFNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBywHKAbgByQG5AcgBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgEA3AELQQAMxgELQQ4MxQELQQ0MxAELQQ8MwwELQRAMwgELQRMMwQELQRQMwAELQRUMvwELQRYMvgELQRgMvQELQRkMvAELQRoMuwELQRsMugELQRwMuQELQR0MuAELQQgMtwELQR4MtgELQSAMtQELQR8MtAELQQcMswELQSEMsgELQSIMsQELQSMMsAELQSQMrwELQRIMrgELQREMrQELQSUMrAELQSYMqwELQScMqgELQSgMqQELQcMBDKgBC0EqDKcBC0ErDKYBC0EsDKUBC0EtDKQBC0EuDKMBC0EvDKIBC0HEAQyhAQtBMAygAQtBNAyfAQtBDAyeAQtBMQydAQtBMgycAQtBMwybAQtBOQyaAQtBNQyZAQtBxQEMmAELQQsMlwELQToMlgELQTYMlQELQQoMlAELQTcMkwELQTgMkgELQTwMkQELQTsMkAELQT0MjwELQQkMjgELQSkMjQELQT4MjAELQT8MiwELQcAADIoBC0HBAAyJAQtBwgAMiAELQcMADIcBC0HEAAyGAQtBxQAMhQELQcYADIQBC0EXDIMBC0HHAAyCAQtByAAMgQELQckADIABC0HKAAx/C0HLAAx+C0HNAAx9C0HMAAx8C0HOAAx7C0HPAAx6C0HQAAx5C0HRAAx4C0HSAAx3C0HTAAx2C0HUAAx1C0HWAAx0C0HVAAxzC0EGDHILQdcADHELQQUMcAtB2AAMbwtBBAxuC0HZAAxtC0HaAAxsC0HbAAxrC0HcAAxqC0EDDGkLQd0ADGgLQd4ADGcLQd8ADGYLQeEADGULQeAADGQLQeIADGMLQeMADGILQQIMYQtB5AAMYAtB5QAMXwtB5gAMXgtB5wAMXQtB6AAMXAtB6QAMWwtB6gAMWgtB6wAMWQtB7AAMWAtB7QAMVwtB7gAMVgtB7wAMVQtB8AAMVAtB8QAMUwtB8gAMUgtB8wAMUQtB9AAMUAtB9QAMTwtB9gAMTgtB9wAMTQtB+AAMTAtB+QAMSwtB+gAMSgtB+wAMSQtB/AAMSAtB/QAMRwtB/gAMRgtB/wAMRQtBgAEMRAtBgQEMQwtBggEMQgtBgwEMQQtBhAEMQAtBhQEMPwtBhgEMPgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADDsYBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHyAhIyUmKCorLC8wMTIzNDU2Nzk6Ozw9lANAQkRFRklLTk9QUVJTVFVWWFpbXF1eX2BhYmNkZWZnaGpsb3Bxc3V2eHl6e3x/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcsBzAHNAc4BzwGKA4kDiAOHA4QDgwOAA/sC+gL5AvgC9wL0AvMC8gLLAsECsALZAQsgASAERw3wAkHdASEDDLMDCyABIARHDcgBQcMBIQMMsgMLIAEgBEcNe0H3ACEDDLEDCyABIARHDXBB7wAhAwywAwsgASAERw1pQeoAIQMMrwMLIAEgBEcNZUHoACEDDK4DCyABIARHDWJB5gAhAwytAwsgASAERw0aQRghAwysAwsgASAERw0VQRIhAwyrAwsgASAERw1CQcUAIQMMqgMLIAEgBEcNNEE/IQMMqQMLIAEgBEcNMkE8IQMMqAMLIAEgBEcNK0ExIQMMpwMLIAItAC5BAUYNnwMMwQILQQAhAAJAAkACQCACLQAqRQ0AIAItACtFDQAgAi8BMCIDQQJxRQ0BDAILIAIvATAiA0EBcUUNAQtBASEAIAItAChBAUYNACACLwEyIgVB5ABrQeQASQ0AIAVBzAFGDQAgBUGwAkYNACADQcAAcQ0AQQAhACADQYgEcUGABEYNACADQShxQQBHIQALIAJBADsBMCACQQA6AC8gAEUN3wIgAkIANwMgDOACC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAARQ3MASAAQRVHDd0CIAJBBDYCHCACIAE2AhQgAkGwGDYCECACQRU2AgxBACEDDKQDCyABIARGBEBBBiEDDKQDCyABQQFqIQFBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAA3ZAgwcCyACQgA3AyBBEiEDDIkDCyABIARHDRZBHSEDDKEDCyABIARHBEAgAUEBaiEBQRAhAwyIAwtBByEDDKADCyACIAIpAyAiCiAEIAFrrSILfSIMQgAgCiAMWhs3AyAgCiALWA3UAkEIIQMMnwMLIAEgBEcEQCACQQk2AgggAiABNgIEQRQhAwyGAwtBCSEDDJ4DCyACKQMgQgBSDccBIAIgAi8BMEGAAXI7ATAMQgsgASAERw0/QdAAIQMMnAMLIAEgBEYEQEELIQMMnAMLIAFBAWohAUEAIQACQCACKAI4IgNFDQAgAygCUCIDRQ0AIAIgAxEAACEACyAADc8CDMYBC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ3GASAAQRVHDc0CIAJBCzYCHCACIAE2AhQgAkGCGTYCECACQRU2AgxBACEDDJoDC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ0MIABBFUcNygIgAkEaNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMmQMLQQAhAAJAIAIoAjgiA0UNACADKAJMIgNFDQAgAiADEQAAIQALIABFDcQBIABBFUcNxwIgAkELNgIcIAIgATYCFCACQZEXNgIQIAJBFTYCDEEAIQMMmAMLIAEgBEYEQEEPIQMMmAMLIAEtAAAiAEE7Rg0HIABBDUcNxAIgAUEBaiEBDMMBC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3DASAAQRVHDcICIAJBDzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJYDCwNAIAEtAABB8DVqLQAAIgBBAUcEQCAAQQJHDcECIAIoAgQhAEEAIQMgAkEANgIEIAIgACABQQFqIgEQLSIADcICDMUBCyAEIAFBAWoiAUcNAAtBEiEDDJUDC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3FASAAQRVHDb0CIAJBGzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJQDCyABIARGBEBBFiEDDJQDCyACQQo2AgggAiABNgIEQQAhAAJAIAIoAjgiA0UNACADKAJIIgNFDQAgAiADEQAAIQALIABFDcIBIABBFUcNuQIgAkEVNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMkwMLIAEgBEcEQANAIAEtAABB8DdqLQAAIgBBAkcEQAJAIABBAWsOBMQCvQIAvgK9AgsgAUEBaiEBQQghAwz8AgsgBCABQQFqIgFHDQALQRUhAwyTAwtBFSEDDJIDCwNAIAEtAABB8DlqLQAAIgBBAkcEQCAAQQFrDgTFArcCwwK4ArcCCyAEIAFBAWoiAUcNAAtBGCEDDJEDCyABIARHBEAgAkELNgIIIAIgATYCBEEHIQMM+AILQRkhAwyQAwsgAUEBaiEBDAILIAEgBEYEQEEaIQMMjwMLAkAgAS0AAEENaw4UtQG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwEAvwELQQAhAyACQQA2AhwgAkGvCzYCECACQQI2AgwgAiABQQFqNgIUDI4DCyABIARGBEBBGyEDDI4DCyABLQAAIgBBO0cEQCAAQQ1HDbECIAFBAWohAQy6AQsgAUEBaiEBC0EiIQMM8wILIAEgBEYEQEEcIQMMjAMLQgAhCgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAS0AAEEwaw43wQLAAgABAgMEBQYH0AHQAdAB0AHQAdAB0AEICQoLDA3QAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdABDg8QERIT0AELQgIhCgzAAgtCAyEKDL8CC0IEIQoMvgILQgUhCgy9AgtCBiEKDLwCC0IHIQoMuwILQgghCgy6AgtCCSEKDLkCC0IKIQoMuAILQgshCgy3AgtCDCEKDLYCC0INIQoMtQILQg4hCgy0AgtCDyEKDLMCC0IKIQoMsgILQgshCgyxAgtCDCEKDLACC0INIQoMrwILQg4hCgyuAgtCDyEKDK0CC0IAIQoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsON8ACvwIAAQIDBAUGB74CvgK+Ar4CvgK+Ar4CCAkKCwwNvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ag4PEBESE74CC0ICIQoMvwILQgMhCgy+AgtCBCEKDL0CC0IFIQoMvAILQgYhCgy7AgtCByEKDLoCC0IIIQoMuQILQgkhCgy4AgtCCiEKDLcCC0ILIQoMtgILQgwhCgy1AgtCDSEKDLQCC0IOIQoMswILQg8hCgyyAgtCCiEKDLECC0ILIQoMsAILQgwhCgyvAgtCDSEKDK4CC0IOIQoMrQILQg8hCgysAgsgAiACKQMgIgogBCABa60iC30iDEIAIAogDFobNwMgIAogC1gNpwJBHyEDDIkDCyABIARHBEAgAkEJNgIIIAIgATYCBEElIQMM8AILQSAhAwyIAwtBASEFIAIvATAiA0EIcUUEQCACKQMgQgBSIQULAkAgAi0ALgRAQQEhACACLQApQQVGDQEgA0HAAHFFIAVxRQ0BC0EAIQAgA0HAAHENAEECIQAgA0EIcQ0AIANBgARxBEACQCACLQAoQQFHDQAgAi0ALUEKcQ0AQQUhAAwCC0EEIQAMAQsgA0EgcUUEQAJAIAItAChBAUYNACACLwEyIgBB5ABrQeQASQ0AIABBzAFGDQAgAEGwAkYNAEEEIQAgA0EocUUNAiADQYgEcUGABEYNAgtBACEADAELQQBBAyACKQMgUBshAAsgAEEBaw4FvgIAsAEBpAKhAgtBESEDDO0CCyACQQE6AC8MhAMLIAEgBEcNnQJBJCEDDIQDCyABIARHDRxBxgAhAwyDAwtBACEAAkAgAigCOCIDRQ0AIAMoAkQiA0UNACACIAMRAAAhAAsgAEUNJyAAQRVHDZgCIAJB0AA2AhwgAiABNgIUIAJBkRg2AhAgAkEVNgIMQQAhAwyCAwsgASAERgRAQSghAwyCAwtBACEDIAJBADYCBCACQQw2AgggAiABIAEQKiIARQ2UAiACQSc2AhwgAiABNgIUIAIgADYCDAyBAwsgASAERgRAQSkhAwyBAwsgAS0AACIAQSBGDRMgAEEJRw2VAiABQQFqIQEMFAsgASAERwRAIAFBAWohAQwWC0EqIQMM/wILIAEgBEYEQEErIQMM/wILIAEtAAAiAEEJRyAAQSBHcQ2QAiACLQAsQQhHDd0CIAJBADoALAzdAgsgASAERgRAQSwhAwz+AgsgAS0AAEEKRw2OAiABQQFqIQEMsAELIAEgBEcNigJBLyEDDPwCCwNAIAEtAAAiAEEgRwRAIABBCmsOBIQCiAKIAoQChgILIAQgAUEBaiIBRw0AC0ExIQMM+wILQTIhAyABIARGDfoCIAIoAgAiACAEIAFraiEHIAEgAGtBA2ohBgJAA0AgAEHwO2otAAAgAS0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAEEDRgRAQQYhAQziAgsgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAc2AgAM+wILIAJBADYCAAyGAgtBMyEDIAQgASIARg35AiAEIAFrIAIoAgAiAWohByAAIAFrQQhqIQYCQANAIAFB9DtqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBCEYEQEEFIQEM4QILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPoCCyACQQA2AgAgACEBDIUCC0E0IQMgBCABIgBGDfgCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgJAA0AgAUHQwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYEQEEHIQEM4AILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPkCCyACQQA2AgAgACEBDIQCCyABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRg0JDIECCyAEIAFBAWoiAUcNAAtBMCEDDPgCC0EwIQMM9wILIAEgBEcEQANAIAEtAAAiAEEgRwRAIABBCmsOBP8B/gH+Af8B/gELIAQgAUEBaiIBRw0AC0E4IQMM9wILQTghAwz2AgsDQCABLQAAIgBBIEcgAEEJR3EN9gEgBCABQQFqIgFHDQALQTwhAwz1AgsDQCABLQAAIgBBIEcEQAJAIABBCmsOBPkBBAT5AQALIABBLEYN9QEMAwsgBCABQQFqIgFHDQALQT8hAwz0AgtBwAAhAyABIARGDfMCIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAEGAQGstAAAgAS0AAEEgckcNASAAQQZGDdsCIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPQCCyACQQA2AgALQTYhAwzZAgsgASAERgRAQcEAIQMM8gILIAJBDDYCCCACIAE2AgQgAi0ALEEBaw4E+wHuAewB6wHUAgsgAUEBaiEBDPoBCyABIARHBEADQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxIgBBCUYNACAAQSBGDQACQAJAAkACQCAAQeMAaw4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIQMM3AILIAFBAWohAUEyIQMM2wILIAFBAWohAUEzIQMM2gILDP4BCyAEIAFBAWoiAUcNAAtBNSEDDPACC0E1IQMM7wILIAEgBEcEQANAIAEtAABBgDxqLQAAQQFHDfcBIAQgAUEBaiIBRw0AC0E9IQMM7wILQT0hAwzuAgtBACEAAkAgAigCOCIDRQ0AIAMoAkAiA0UNACACIAMRAAAhAAsgAEUNASAAQRVHDeYBIAJBwgA2AhwgAiABNgIUIAJB4xg2AhAgAkEVNgIMQQAhAwztAgsgAUEBaiEBC0E8IQMM0gILIAEgBEYEQEHCACEDDOsCCwJAA0ACQCABLQAAQQlrDhgAAswCzALRAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAgDMAgsgBCABQQFqIgFHDQALQcIAIQMM6wILIAFBAWohASACLQAtQQFxRQ3+AQtBLCEDDNACCyABIARHDd4BQcQAIQMM6AILA0AgAS0AAEGQwABqLQAAQQFHDZwBIAQgAUEBaiIBRw0AC0HFACEDDOcCCyABLQAAIgBBIEYN/gEgAEE6Rw3AAiACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgAN3gEM3QELQccAIQMgBCABIgBGDeUCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFBkMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvwIgAUEFRg3CAiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzlAgtByAAhAyAEIAEiAEYN5AIgBCABayACKAIAIgFqIQcgACABa0EJaiEGA0AgAUGWwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw2+AkECIAFBCUYNwgIaIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOQCCyABIARGBEBByQAhAwzkAgsCQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxQe4Aaw4HAL8CvwK/Ar8CvwIBvwILIAFBAWohAUE+IQMMywILIAFBAWohAUE/IQMMygILQcoAIQMgBCABIgBGDeICIAQgAWsgAigCACIBaiEGIAAgAWtBAWohBwNAIAFBoMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvAIgAUEBRg2+AiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBjYCAAziAgtBywAhAyAEIAEiAEYN4QIgBCABayACKAIAIgFqIQcgACABa0EOaiEGA0AgAUGiwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw27AiABQQ5GDb4CIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOECC0HMACEDIAQgASIARg3gAiAEIAFrIAIoAgAiAWohByAAIAFrQQ9qIQYDQCABQcDCAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDboCQQMgAUEPRg2+AhogAUEBaiEBIAQgAEEBaiIARw0ACyACIAc2AgAM4AILQc0AIQMgBCABIgBGDd8CIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFB0MIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNuQJBBCABQQVGDb0CGiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzfAgsgASAERgRAQc4AIQMM3wILAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAvAK8ArwCvAK8ArwCvAK8ArwCvAK8ArwCAbwCvAK8AgIDvAILIAFBAWohAUHBACEDDMgCCyABQQFqIQFBwgAhAwzHAgsgAUEBaiEBQcMAIQMMxgILIAFBAWohAUHEACEDDMUCCyABIARHBEAgAkENNgIIIAIgATYCBEHFACEDDMUCC0HPACEDDN0CCwJAAkAgAS0AAEEKaw4EAZABkAEAkAELIAFBAWohAQtBKCEDDMMCCyABIARGBEBB0QAhAwzcAgsgAS0AAEEgRw0AIAFBAWohASACLQAtQQFxRQ3QAQtBFyEDDMECCyABIARHDcsBQdIAIQMM2QILQdMAIQMgASAERg3YAiACKAIAIgAgBCABa2ohBiABIABrQQFqIQUDQCABLQAAIABB1sIAai0AAEcNxwEgAEEBRg3KASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBjYCAAzYAgsgASAERgRAQdUAIQMM2AILIAEtAABBCkcNwgEgAUEBaiEBDMoBCyABIARGBEBB1gAhAwzXAgsCQAJAIAEtAABBCmsOBADDAcMBAcMBCyABQQFqIQEMygELIAFBAWohAUHKACEDDL0CC0EAIQACQCACKAI4IgNFDQAgAygCPCIDRQ0AIAIgAxEAACEACyAADb8BQc0AIQMMvAILIAItAClBIkYNzwIMiQELIAQgASIFRgRAQdsAIQMM1AILQQAhAEEBIQFBASEGQQAhAwJAAn8CQAJAAkACQAJAAkACQCAFLQAAQTBrDgrFAcQBAAECAwQFBgjDAQtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshA0EAIQFBACEGDL0BC0EJIQNBASEAQQAhAUEAIQYMvAELIAEgBEYEQEHdACEDDNMCCyABLQAAQS5HDbgBIAFBAWohAQyIAQsgASAERw22AUHfACEDDNECCyABIARHBEAgAkEONgIIIAIgATYCBEHQACEDDLgCC0HgACEDDNACC0HhACEDIAEgBEYNzwIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGA0AgAS0AACAAQeLCAGotAABHDbEBIABBA0YNswEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMzwILQeIAIQMgASAERg3OAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYDQCABLQAAIABB5sIAai0AAEcNsAEgAEECRg2vASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAzOAgtB4wAhAyABIARGDc0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgNAIAEtAAAgAEHpwgBqLQAARw2vASAAQQNGDa0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADM0CCyABIARGBEBB5QAhAwzNAgsgAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANqgFB1gAhAwyzAgsgASAERwRAA0AgAS0AACIAQSBHBEACQAJAAkAgAEHIAGsOCwABswGzAbMBswGzAbMBswGzAQKzAQsgAUEBaiEBQdIAIQMMtwILIAFBAWohAUHTACEDDLYCCyABQQFqIQFB1AAhAwy1AgsgBCABQQFqIgFHDQALQeQAIQMMzAILQeQAIQMMywILA0AgAS0AAEHwwgBqLQAAIgBBAUcEQCAAQQJrDgOnAaYBpQGkAQsgBCABQQFqIgFHDQALQeYAIQMMygILIAFBAWogASAERw0CGkHnACEDDMkCCwNAIAEtAABB8MQAai0AACIAQQFHBEACQCAAQQJrDgSiAaEBoAEAnwELQdcAIQMMsQILIAQgAUEBaiIBRw0AC0HoACEDDMgCCyABIARGBEBB6QAhAwzIAgsCQCABLQAAIgBBCmsOGrcBmwGbAbQBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBpAGbAZsBAJkBCyABQQFqCyEBQQYhAwytAgsDQCABLQAAQfDGAGotAABBAUcNfSAEIAFBAWoiAUcNAAtB6gAhAwzFAgsgAUEBaiABIARHDQIaQesAIQMMxAILIAEgBEYEQEHsACEDDMQCCyABQQFqDAELIAEgBEYEQEHtACEDDMMCCyABQQFqCyEBQQQhAwyoAgsgASAERgRAQe4AIQMMwQILAkACQAJAIAEtAABB8MgAai0AAEEBaw4HkAGPAY4BAHwBAo0BCyABQQFqIQEMCwsgAUEBagyTAQtBACEDIAJBADYCHCACQZsSNgIQIAJBBzYCDCACIAFBAWo2AhQMwAILAkADQCABLQAAQfDIAGotAAAiAEEERwRAAkACQCAAQQFrDgeUAZMBkgGNAQAEAY0BC0HaACEDDKoCCyABQQFqIQFB3AAhAwypAgsgBCABQQFqIgFHDQALQe8AIQMMwAILIAFBAWoMkQELIAQgASIARgRAQfAAIQMMvwILIAAtAABBL0cNASAAQQFqIQEMBwsgBCABIgBGBEBB8QAhAwy+AgsgAC0AACIBQS9GBEAgAEEBaiEBQd0AIQMMpQILIAFBCmsiA0EWSw0AIAAhAUEBIAN0QYmAgAJxDfkBC0EAIQMgAkEANgIcIAIgADYCFCACQYwcNgIQIAJBBzYCDAy8AgsgASAERwRAIAFBAWohAUHeACEDDKMCC0HyACEDDLsCCyABIARGBEBB9AAhAwy7AgsCQCABLQAAQfDMAGotAABBAWsOA/cBcwCCAQtB4QAhAwyhAgsgASAERwRAA0AgAS0AAEHwygBqLQAAIgBBA0cEQAJAIABBAWsOAvkBAIUBC0HfACEDDKMCCyAEIAFBAWoiAUcNAAtB8wAhAwy6AgtB8wAhAwy5AgsgASAERwRAIAJBDzYCCCACIAE2AgRB4AAhAwygAgtB9QAhAwy4AgsgASAERgRAQfYAIQMMuAILIAJBDzYCCCACIAE2AgQLQQMhAwydAgsDQCABLQAAQSBHDY4CIAQgAUEBaiIBRw0AC0H3ACEDDLUCCyABIARGBEBB+AAhAwy1AgsgAS0AAEEgRw16IAFBAWohAQxbC0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAADXgMgAILIAEgBEYEQEH6ACEDDLMCCyABLQAAQcwARw10IAFBAWohAUETDHYLQfsAIQMgASAERg2xAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYDQCABLQAAIABB8M4Aai0AAEcNcyAAQQVGDXUgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMsQILIAEgBEYEQEH8ACEDDLECCwJAAkAgAS0AAEHDAGsODAB0dHR0dHR0dHR0AXQLIAFBAWohAUHmACEDDJgCCyABQQFqIQFB5wAhAwyXAgtB/QAhAyABIARGDa8CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDXIgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADLACCyACQQA2AgAgBkEBaiEBQRAMcwtB/gAhAyABIARGDa4CIAIoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQfbOAGotAABHDXEgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK8CCyACQQA2AgAgBkEBaiEBQRYMcgtB/wAhAyABIARGDa0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQfzOAGotAABHDXAgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK4CCyACQQA2AgAgBkEBaiEBQQUMcQsgASAERgRAQYABIQMMrQILIAEtAABB2QBHDW4gAUEBaiEBQQgMcAsgASAERgRAQYEBIQMMrAILAkACQCABLQAAQc4Aaw4DAG8BbwsgAUEBaiEBQesAIQMMkwILIAFBAWohAUHsACEDDJICCyABIARGBEBBggEhAwyrAgsCQAJAIAEtAABByABrDggAbm5ubm5uAW4LIAFBAWohAUHqACEDDJICCyABQQFqIQFB7QAhAwyRAgtBgwEhAyABIARGDakCIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQYDPAGotAABHDWwgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKoCCyACQQA2AgAgBkEBaiEBQQAMbQtBhAEhAyABIARGDagCIAIoAgAiACAEIAFraiEFIAEgAGtBBGohBgJAA0AgAS0AACAAQYPPAGotAABHDWsgAEEERg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKkCCyACQQA2AgAgBkEBaiEBQSMMbAsgASAERgRAQYUBIQMMqAILAkACQCABLQAAQcwAaw4IAGtra2trawFrCyABQQFqIQFB7wAhAwyPAgsgAUEBaiEBQfAAIQMMjgILIAEgBEYEQEGGASEDDKcCCyABLQAAQcUARw1oIAFBAWohAQxgC0GHASEDIAEgBEYNpQIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBiM8Aai0AAEcNaCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpgILIAJBADYCACAGQQFqIQFBLQxpC0GIASEDIAEgBEYNpAIgAigCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABB0M8Aai0AAEcNZyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpQILIAJBADYCACAGQQFqIQFBKQxoCyABIARGBEBBiQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEVDF8LQZIBIQMgASAERg2aAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGhzwBqLQAARw1dIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAybAgsgAkEANgIAIAZBAWohAUEeDF4LIAEgBEYEQEGTASEDDJoCCyABLQAAQcwARw1bIAFBAWohAUEKDF0LIAEgBEYEQEGUASEDDJkCCwJAAkAgAS0AAEHBAGsODwBcXFxcXFxcXFxcXFxcAVwLIAFBAWohAUH+ACEDDIACCyABQQFqIQFB/wAhAwz/AQsgASAERgRAQZUBIQMMmAILAkACQCABLQAAQcEAaw4DAFsBWwsgAUEBaiEBQf0AIQMM/wELIAFBAWohAUGAASEDDP4BC0GWASEDIAEgBEYNlgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBp88Aai0AAEcNWSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlwILIAJBADYCACAGQQFqIQFBCwxaCyABIARGBEBBlwEhAwyWAgsCQAJAAkACQCABLQAAQS1rDiMAW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1sBW1tbW1sCW1tbA1sLIAFBAWohAUH7ACEDDP8BCyABQQFqIQFB/AAhAwz+AQsgAUEBaiEBQYEBIQMM/QELIAFBAWohAUGCASEDDPwBC0GYASEDIAEgBEYNlAIgAigCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABBqc8Aai0AAEcNVyAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlQILIAJBADYCACAGQQFqIQFBGQxYC0GZASEDIAEgBEYNkwIgAigCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBrs8Aai0AAEcNViAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlAILIAJBADYCACAGQQFqIQFBBgxXC0GaASEDIAEgBEYNkgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBtM8Aai0AAEcNVSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkwILIAJBADYCACAGQQFqIQFBHAxWC0GbASEDIAEgBEYNkQIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBts8Aai0AAEcNVCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkgILIAJBADYCACAGQQFqIQFBJwxVCyABIARGBEBBnAEhAwyRAgsCQAJAIAEtAABB1ABrDgIAAVQLIAFBAWohAUGGASEDDPgBCyABQQFqIQFBhwEhAwz3AQtBnQEhAyABIARGDY8CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbjPAGotAABHDVIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADJACCyACQQA2AgAgBkEBaiEBQSYMUwtBngEhAyABIARGDY4CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbrPAGotAABHDVEgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI8CCyACQQA2AgAgBkEBaiEBQQMMUgtBnwEhAyABIARGDY0CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDVAgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI4CCyACQQA2AgAgBkEBaiEBQQwMUQtBoAEhAyABIARGDYwCIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQbzPAGotAABHDU8gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI0CCyACQQA2AgAgBkEBaiEBQQ0MUAsgASAERgRAQaEBIQMMjAILAkACQCABLQAAQcYAaw4LAE9PT09PT09PTwFPCyABQQFqIQFBiwEhAwzzAQsgAUEBaiEBQYwBIQMM8gELIAEgBEYEQEGiASEDDIsCCyABLQAAQdAARw1MIAFBAWohAQxGCyABIARGBEBBowEhAwyKAgsCQAJAIAEtAABByQBrDgcBTU1NTU0ATQsgAUEBaiEBQY4BIQMM8QELIAFBAWohAUEiDE0LQaQBIQMgASAERg2IAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHAzwBqLQAARw1LIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyJAgsgAkEANgIAIAZBAWohAUEdDEwLIAEgBEYEQEGlASEDDIgCCwJAAkAgAS0AAEHSAGsOAwBLAUsLIAFBAWohAUGQASEDDO8BCyABQQFqIQFBBAxLCyABIARGBEBBpgEhAwyHAgsCQAJAAkACQAJAIAEtAABBwQBrDhUATU1NTU1NTU1NTQFNTQJNTQNNTQRNCyABQQFqIQFBiAEhAwzxAQsgAUEBaiEBQYkBIQMM8AELIAFBAWohAUGKASEDDO8BCyABQQFqIQFBjwEhAwzuAQsgAUEBaiEBQZEBIQMM7QELQacBIQMgASAERg2FAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHtzwBqLQAARw1IIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyGAgsgAkEANgIAIAZBAWohAUERDEkLQagBIQMgASAERg2EAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHCzwBqLQAARw1HIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyFAgsgAkEANgIAIAZBAWohAUEsDEgLQakBIQMgASAERg2DAiACKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHFzwBqLQAARw1GIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyEAgsgAkEANgIAIAZBAWohAUErDEcLQaoBIQMgASAERg2CAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHKzwBqLQAARw1FIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyDAgsgAkEANgIAIAZBAWohAUEUDEYLIAEgBEYEQEGrASEDDIICCwJAAkACQAJAIAEtAABBwgBrDg8AAQJHR0dHR0dHR0dHRwNHCyABQQFqIQFBkwEhAwzrAQsgAUEBaiEBQZQBIQMM6gELIAFBAWohAUGVASEDDOkBCyABQQFqIQFBlgEhAwzoAQsgASAERgRAQawBIQMMgQILIAEtAABBxQBHDUIgAUEBaiEBDD0LQa0BIQMgASAERg3/ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHNzwBqLQAARw1CIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyAAgsgAkEANgIAIAZBAWohAUEODEMLIAEgBEYEQEGuASEDDP8BCyABLQAAQdAARw1AIAFBAWohAUElDEILQa8BIQMgASAERg39ASACKAIAIgAgBCABa2ohBSABIABrQQhqIQYCQANAIAEtAAAgAEHQzwBqLQAARw1AIABBCEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz+AQsgAkEANgIAIAZBAWohAUEqDEELIAEgBEYEQEGwASEDDP0BCwJAAkAgAS0AAEHVAGsOCwBAQEBAQEBAQEABQAsgAUEBaiEBQZoBIQMM5AELIAFBAWohAUGbASEDDOMBCyABIARGBEBBsQEhAwz8AQsCQAJAIAEtAABBwQBrDhQAPz8/Pz8/Pz8/Pz8/Pz8/Pz8/AT8LIAFBAWohAUGZASEDDOMBCyABQQFqIQFBnAEhAwziAQtBsgEhAyABIARGDfoBIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQdnPAGotAABHDT0gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPsBCyACQQA2AgAgBkEBaiEBQSEMPgtBswEhAyABIARGDfkBIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQd3PAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPoBCyACQQA2AgAgBkEBaiEBQRoMPQsgASAERgRAQbQBIQMM+QELAkACQAJAIAEtAABBxQBrDhEAPT09PT09PT09AT09PT09Aj0LIAFBAWohAUGdASEDDOEBCyABQQFqIQFBngEhAwzgAQsgAUEBaiEBQZ8BIQMM3wELQbUBIQMgASAERg33ASACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHkzwBqLQAARw06IABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz4AQsgAkEANgIAIAZBAWohAUEoDDsLQbYBIQMgASAERg32ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHqzwBqLQAARw05IABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz3AQsgAkEANgIAIAZBAWohAUEHDDoLIAEgBEYEQEG3ASEDDPYBCwJAAkAgAS0AAEHFAGsODgA5OTk5OTk5OTk5OTkBOQsgAUEBaiEBQaEBIQMM3QELIAFBAWohAUGiASEDDNwBC0G4ASEDIAEgBEYN9AEgAigCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB7c8Aai0AAEcNNyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9QELIAJBADYCACAGQQFqIQFBEgw4C0G5ASEDIAEgBEYN8wEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8M8Aai0AAEcNNiAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9AELIAJBADYCACAGQQFqIQFBIAw3C0G6ASEDIAEgBEYN8gEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8s8Aai0AAEcNNSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8wELIAJBADYCACAGQQFqIQFBDww2CyABIARGBEBBuwEhAwzyAQsCQAJAIAEtAABByQBrDgcANTU1NTUBNQsgAUEBaiEBQaUBIQMM2QELIAFBAWohAUGmASEDDNgBC0G8ASEDIAEgBEYN8AEgAigCACIAIAQgAWtqIQUgASAAa0EHaiEGAkADQCABLQAAIABB9M8Aai0AAEcNMyAAQQdGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8QELIAJBADYCACAGQQFqIQFBGww0CyABIARGBEBBvQEhAwzwAQsCQAJAAkAgAS0AAEHCAGsOEgA0NDQ0NDQ0NDQBNDQ0NDQ0AjQLIAFBAWohAUGkASEDDNgBCyABQQFqIQFBpwEhAwzXAQsgAUEBaiEBQagBIQMM1gELIAEgBEYEQEG+ASEDDO8BCyABLQAAQc4ARw0wIAFBAWohAQwsCyABIARGBEBBvwEhAwzuAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQcEAaw4VAAECAz8EBQY/Pz8HCAkKCz8MDQ4PPwsgAUEBaiEBQegAIQMM4wELIAFBAWohAUHpACEDDOIBCyABQQFqIQFB7gAhAwzhAQsgAUEBaiEBQfIAIQMM4AELIAFBAWohAUHzACEDDN8BCyABQQFqIQFB9gAhAwzeAQsgAUEBaiEBQfcAIQMM3QELIAFBAWohAUH6ACEDDNwBCyABQQFqIQFBgwEhAwzbAQsgAUEBaiEBQYQBIQMM2gELIAFBAWohAUGFASEDDNkBCyABQQFqIQFBkgEhAwzYAQsgAUEBaiEBQZgBIQMM1wELIAFBAWohAUGgASEDDNYBCyABQQFqIQFBowEhAwzVAQsgAUEBaiEBQaoBIQMM1AELIAEgBEcEQCACQRA2AgggAiABNgIEQasBIQMM1AELQcABIQMM7AELQQAhAAJAIAIoAjgiA0UNACADKAI0IgNFDQAgAiADEQAAIQALIABFDV4gAEEVRw0HIAJB0QA2AhwgAiABNgIUIAJBsBc2AhAgAkEVNgIMQQAhAwzrAQsgAUEBaiABIARHDQgaQcIBIQMM6gELA0ACQCABLQAAQQprDgQIAAALAAsgBCABQQFqIgFHDQALQcMBIQMM6QELIAEgBEcEQCACQRE2AgggAiABNgIEQQEhAwzQAQtBxAEhAwzoAQsgASAERgRAQcUBIQMM6AELAkACQCABLQAAQQprDgQBKCgAKAsgAUEBagwJCyABQQFqDAULIAEgBEYEQEHGASEDDOcBCwJAAkAgAS0AAEEKaw4XAQsLAQsLCwsLCwsLCwsLCwsLCwsLCwALCyABQQFqIQELQbABIQMMzQELIAEgBEYEQEHIASEDDOYBCyABLQAAQSBHDQkgAkEAOwEyIAFBAWohAUGzASEDDMwBCwNAIAEhAAJAIAEgBEcEQCABLQAAQTBrQf8BcSIDQQpJDQEMJwtBxwEhAwzmAQsCQCACLwEyIgFBmTNLDQAgAiABQQpsIgU7ATIgBUH+/wNxIANB//8Dc0sNACAAQQFqIQEgAiADIAVqIgM7ATIgA0H//wNxQegHSQ0BCwtBACEDIAJBADYCHCACQcEJNgIQIAJBDTYCDCACIABBAWo2AhQM5AELIAJBADYCHCACIAE2AhQgAkHwDDYCECACQRs2AgxBACEDDOMBCyACKAIEIQAgAkEANgIEIAIgACABECYiAA0BIAFBAWoLIQFBrQEhAwzIAQsgAkHBATYCHCACIAA2AgwgAiABQQFqNgIUQQAhAwzgAQsgAigCBCEAIAJBADYCBCACIAAgARAmIgANASABQQFqCyEBQa4BIQMMxQELIAJBwgE2AhwgAiAANgIMIAIgAUEBajYCFEEAIQMM3QELIAJBADYCHCACIAE2AhQgAkGXCzYCECACQQ02AgxBACEDDNwBCyACQQA2AhwgAiABNgIUIAJB4xA2AhAgAkEJNgIMQQAhAwzbAQsgAkECOgAoDKwBC0EAIQMgAkEANgIcIAJBrws2AhAgAkECNgIMIAIgAUEBajYCFAzZAQtBAiEDDL8BC0ENIQMMvgELQSYhAwy9AQtBFSEDDLwBC0EWIQMMuwELQRghAwy6AQtBHCEDDLkBC0EdIQMMuAELQSAhAwy3AQtBISEDDLYBC0EjIQMMtQELQcYAIQMMtAELQS4hAwyzAQtBPSEDDLIBC0HLACEDDLEBC0HOACEDDLABC0HYACEDDK8BC0HZACEDDK4BC0HbACEDDK0BC0HxACEDDKwBC0H0ACEDDKsBC0GNASEDDKoBC0GXASEDDKkBC0GpASEDDKgBC0GvASEDDKcBC0GxASEDDKYBCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB8Rs2AhAgAkEGNgIMDL0BCyACQQA2AgAgBkEBaiEBQSQLOgApIAIoAgQhACACQQA2AgQgAiAAIAEQJyIARQRAQeUAIQMMowELIAJB+QA2AhwgAiABNgIUIAIgADYCDEEAIQMMuwELIABBFUcEQCACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwy7AQsgAkH4ADYCHCACIAE2AhQgAkHKGDYCECACQRU2AgxBACEDDLoBCyACQQA2AhwgAiABNgIUIAJBjhs2AhAgAkEGNgIMQQAhAwy5AQsgAkEANgIcIAIgATYCFCACQf4RNgIQIAJBBzYCDEEAIQMMuAELIAJBADYCHCACIAE2AhQgAkGMHDYCECACQQc2AgxBACEDDLcBCyACQQA2AhwgAiABNgIUIAJBww82AhAgAkEHNgIMQQAhAwy2AQsgAkEANgIcIAIgATYCFCACQcMPNgIQIAJBBzYCDEEAIQMMtQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxBACEDDKIBCyACQeQANgIcIAIgATYCFCACQeMXNgIQIAJBFTYCDEEAIQMMoQELIAJBADYCACAGQQFqIQEgAi0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACEDIAJBADYCHCACIAE2AhQgAkH3CTYCECACQQg2AgwMoAELIAJBADYCACAGQQFqIQEgAi0AKUEhRg0DIAJBADYCHCACIAE2AhQgAkGbCjYCECACQQg2AgxBACEDDJ8BCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJBkDM2AhAgAkEINgIMDJ0BCyACQQA2AgAgBkEBaiEBIAItAClBI0kNACACQQA2AhwgAiABNgIUIAJB0wk2AhAgAkEINgIMQQAhAwycAQtB0QAhAwyCAQsgAS0AAEEwayIAQf8BcUEKSQRAIAIgADoAKiABQQFqIQFBzwAhAwyCAQsgAigCBCEAIAJBADYCBCACIAAgARAoIgBFDYYBIAJB3gA2AhwgAiABNgIUIAIgADYCDEEAIQMMmgELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ2GASACQdwANgIcIAIgATYCFCACIAA2AgxBACEDDJkBCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMhwELIAJB2gA2AhwgAiAFNgIUIAIgADYCDAyYAQtBACEBQQEhAwsgAiADOgArIAVBAWohAwJAAkACQCACLQAtQRBxDQACQAJAAkAgAi0AKg4DAQACBAsgBkUNAwwCCyAADQEMAgsgAUUNAQsgAigCBCEAIAJBADYCBCACIAAgAxAoIgBFBEAgAyEBDAILIAJB2AA2AhwgAiADNgIUIAIgADYCDEEAIQMMmAELIAIoAgQhACACQQA2AgQgAiAAIAMQKCIARQRAIAMhAQyHAQsgAkHZADYCHCACIAM2AhQgAiAANgIMQQAhAwyXAQtBzAAhAwx9CyAAQRVHBEAgAkEANgIcIAIgATYCFCACQZQNNgIQIAJBITYCDEEAIQMMlgELIAJB1wA2AhwgAiABNgIUIAJByRc2AhAgAkEVNgIMQQAhAwyVAQtBACEDIAJBADYCHCACIAE2AhQgAkGAETYCECACQQk2AgwMlAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0AIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMkwELQckAIQMMeQsgAkEANgIcIAIgATYCFCACQcEoNgIQIAJBBzYCDCACQQA2AgBBACEDDJEBCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAlIgBFDQAgAkHSADYCHCACIAE2AhQgAiAANgIMDJABC0HIACEDDHYLIAJBADYCACAFIQELIAJBgBI7ASogAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANAQtBxwAhAwxzCyAAQRVGBEAgAkHRADYCHCACIAE2AhQgAkHjFzYCECACQRU2AgxBACEDDIwBC0EAIQMgAkEANgIcIAIgATYCFCACQbkNNgIQIAJBGjYCDAyLAQtBACEDIAJBADYCHCACIAE2AhQgAkGgGTYCECACQR42AgwMigELIAEtAABBOkYEQCACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgBFDQEgAkHDADYCHCACIAA2AgwgAiABQQFqNgIUDIoBC0EAIQMgAkEANgIcIAIgATYCFCACQbERNgIQIAJBCjYCDAyJAQsgAUEBaiEBQTshAwxvCyACQcMANgIcIAIgADYCDCACIAFBAWo2AhQMhwELQQAhAyACQQA2AhwgAiABNgIUIAJB8A42AhAgAkEcNgIMDIYBCyACIAIvATBBEHI7ATAMZgsCQCACLwEwIgBBCHFFDQAgAi0AKEEBRw0AIAItAC1BCHFFDQMLIAIgAEH3+wNxQYAEcjsBMAwECyABIARHBEACQANAIAEtAABBMGsiAEH/AXFBCk8EQEE1IQMMbgsgAikDICIKQpmz5syZs+bMGVYNASACIApCCn4iCjcDICAKIACtQv8BgyILQn+FVg0BIAIgCiALfDcDICAEIAFBAWoiAUcNAAtBOSEDDIUBCyACKAIEIQBBACEDIAJBADYCBCACIAAgAUEBaiIBECoiAA0MDHcLQTkhAwyDAQsgAi0AMEEgcQ0GQcUBIQMMaQtBACEDIAJBADYCBCACIAEgARAqIgBFDQQgAkE6NgIcIAIgADYCDCACIAFBAWo2AhQMgQELIAItAChBAUcNACACLQAtQQhxRQ0BC0E3IQMMZgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIABEAgAkE7NgIcIAIgADYCDCACIAFBAWo2AhQMfwsgAUEBaiEBDG4LIAJBCDoALAwECyABQQFqIQEMbQtBACEDIAJBADYCHCACIAE2AhQgAkHkEjYCECACQQQ2AgwMewsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ1sIAJBNzYCHCACIAE2AhQgAiAANgIMDHoLIAIgAi8BMEEgcjsBMAtBMCEDDF8LIAJBNjYCHCACIAE2AhQgAiAANgIMDHcLIABBLEcNASABQQFqIQBBASEBAkACQAJAAkACQCACLQAsQQVrDgQDAQIEAAsgACEBDAQLQQIhAQwBC0EEIQELIAJBAToALCACIAIvATAgAXI7ATAgACEBDAELIAIgAi8BMEEIcjsBMCAAIQELQTkhAwxcCyACQQA6ACwLQTQhAwxaCyABIARGBEBBLSEDDHMLAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0EtIQMMdAsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ0CIAJBLDYCHCACIAE2AhQgAiAANgIMDHMLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAS0AAEENRgRAIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAi0ALUEBcQRAQcQBIQMMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIADQEMZQtBLyEDDFcLIAJBLjYCHCACIAE2AhQgAiAANgIMDG8LQQAhAyACQQA2AhwgAiABNgIUIAJB8BQ2AhAgAkEDNgIMDG4LQQEhAwJAAkACQAJAIAItACxBBWsOBAMBAgAECyACIAIvATBBCHI7ATAMAwtBAiEDDAELQQQhAwsgAkEBOgAsIAIgAi8BMCADcjsBMAtBKiEDDFMLQQAhAyACQQA2AhwgAiABNgIUIAJB4Q82AhAgAkEKNgIMDGsLQQEhAwJAAkACQAJAAkACQCACLQAsQQJrDgcFBAQDAQIABAsgAiACLwEwQQhyOwEwDAMLQQIhAwwBC0EEIQMLIAJBAToALCACIAIvATAgA3I7ATALQSshAwxSC0EAIQMgAkEANgIcIAIgATYCFCACQasSNgIQIAJBCzYCDAxqC0EAIQMgAkEANgIcIAIgATYCFCACQf0NNgIQIAJBHTYCDAxpCyABIARHBEADQCABLQAAQSBHDUggBCABQQFqIgFHDQALQSUhAwxpC0ElIQMMaAsgAi0ALUEBcQRAQcMBIQMMTwsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKSIABEAgAkEmNgIcIAIgADYCDCACIAFBAWo2AhQMaAsgAUEBaiEBDFwLIAFBAWohASACLwEwIgBBgAFxBEBBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAEUNBiAAQRVHDR8gAkEFNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMZwsCQCAAQaAEcUGgBEcNACACLQAtQQJxDQBBACEDIAJBADYCHCACIAE2AhQgAkGWEzYCECACQQQ2AgwMZwsgAgJ/IAIvATBBFHFBFEYEQEEBIAItAChBAUYNARogAi8BMkHlAEYMAQsgAi0AKUEFRgs6AC5BACEAAkAgAigCOCIDRQ0AIAMoAiQiA0UNACACIAMRAAAhAAsCQAJAAkACQAJAIAAOFgIBAAQEBAQEBAQEBAQEBAQEBAQEBAMECyACQQE6AC4LIAIgAi8BMEHAAHI7ATALQSchAwxPCyACQSM2AhwgAiABNgIUIAJBpRY2AhAgAkEVNgIMQQAhAwxnC0EAIQMgAkEANgIcIAIgATYCFCACQdULNgIQIAJBETYCDAxmC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAADQELQQ4hAwxLCyAAQRVGBEAgAkECNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMZAtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMYwtBACEDIAJBADYCHCACIAE2AhQgAkGqHDYCECACQQ82AgwMYgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEgCqdqIgEQKyIARQ0AIAJBBTYCHCACIAE2AhQgAiAANgIMDGELQQ8hAwxHC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxfC0IBIQoLIAFBAWohAQJAIAIpAyAiC0L//////////w9YBEAgAiALQgSGIAqENwMgDAELQQAhAyACQQA2AhwgAiABNgIUIAJBrQk2AhAgAkEMNgIMDF4LQSQhAwxEC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxcCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAsIgBFBEAgAUEBaiEBDFILIAJBFzYCHCACIAA2AgwgAiABQQFqNgIUDFsLIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQRY2AhwgAiAANgIMIAIgAUEBajYCFAxbC0EfIQMMQQtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQLSIARQRAIAFBAWohAQxQCyACQRQ2AhwgAiAANgIMIAIgAUEBajYCFAxYCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABEC0iAEUEQCABQQFqIQEMAQsgAkETNgIcIAIgADYCDCACIAFBAWo2AhQMWAtBHiEDDD4LQQAhAyACQQA2AhwgAiABNgIUIAJBxgw2AhAgAkEjNgIMDFYLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABEC0iAEUEQCABQQFqIQEMTgsgAkERNgIcIAIgADYCDCACIAFBAWo2AhQMVQsgAkEQNgIcIAIgATYCFCACIAA2AgwMVAtBACEDIAJBADYCHCACIAE2AhQgAkHGDDYCECACQSM2AgwMUwtBACEDIAJBADYCHCACIAE2AhQgAkHAFTYCECACQQI2AgwMUgsgAigCBCEAQQAhAyACQQA2AgQCQCACIAAgARAtIgBFBEAgAUEBaiEBDAELIAJBDjYCHCACIAA2AgwgAiABQQFqNgIUDFILQRshAww4C0EAIQMgAkEANgIcIAIgATYCFCACQcYMNgIQIAJBIzYCDAxQCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABECwiAEUEQCABQQFqIQEMAQsgAkENNgIcIAIgADYCDCACIAFBAWo2AhQMUAtBGiEDDDYLQQAhAyACQQA2AhwgAiABNgIUIAJBmg82AhAgAkEiNgIMDE4LIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQQw2AhwgAiAANgIMIAIgAUEBajYCFAxOC0EZIQMMNAtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMTAsgAEEVRwRAQQAhAyACQQA2AhwgAiABNgIUIAJBgww2AhAgAkETNgIMDEwLIAJBCjYCHCACIAE2AhQgAkHkFjYCECACQRU2AgxBACEDDEsLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABIAqnaiIBECsiAARAIAJBBzYCHCACIAE2AhQgAiAANgIMDEsLQRMhAwwxCyAAQRVHBEBBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMSgsgAkEeNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMSQtBACEAAkAgAigCOCIDRQ0AIAMoAiwiA0UNACACIAMRAAAhAAsgAEUNQSAAQRVGBEAgAkEDNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMSQtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMSAtBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMRwtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMRgsgAkEAOgAvIAItAC1BBHFFDT8LIAJBADoALyACQQE6ADRBACEDDCsLQQAhAyACQQA2AhwgAkHkETYCECACQQc2AgwgAiABQQFqNgIUDEMLAkADQAJAIAEtAABBCmsOBAACAgACCyAEIAFBAWoiAUcNAAtB3QEhAwxDCwJAAkAgAi0ANEEBRw0AQQAhAAJAIAIoAjgiA0UNACADKAJYIgNFDQAgAiADEQAAIQALIABFDQAgAEEVRw0BIAJB3AE2AhwgAiABNgIUIAJB1RY2AhAgAkEVNgIMQQAhAwxEC0HBASEDDCoLIAJBADYCHCACIAE2AhQgAkHpCzYCECACQR82AgxBACEDDEILAkACQCACLQAoQQFrDgIEAQALQcABIQMMKQtBuQEhAwwoCyACQQI6AC9BACEAAkAgAigCOCIDRQ0AIAMoAgAiA0UNACACIAMRAAAhAAsgAEUEQEHCASEDDCgLIABBFUcEQCACQQA2AhwgAiABNgIUIAJBpAw2AhAgAkEQNgIMQQAhAwxBCyACQdsBNgIcIAIgATYCFCACQfoWNgIQIAJBFTYCDEEAIQMMQAsgASAERgRAQdoBIQMMQAsgAS0AAEHIAEYNASACQQE6ACgLQawBIQMMJQtBvwEhAwwkCyABIARHBEAgAkEQNgIIIAIgATYCBEG+ASEDDCQLQdkBIQMMPAsgASAERgRAQdgBIQMMPAsgAS0AAEHIAEcNBCABQQFqIQFBvQEhAwwiCyABIARGBEBB1wEhAww7CwJAAkAgAS0AAEHFAGsOEAAFBQUFBQUFBQUFBQUFBQEFCyABQQFqIQFBuwEhAwwiCyABQQFqIQFBvAEhAwwhC0HWASEDIAEgBEYNOSACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGD0ABqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw6CyACKAIEIQAgAkIANwMAIAIgACAGQQFqIgEQJyIARQRAQcYBIQMMIQsgAkHVATYCHCACIAE2AhQgAiAANgIMQQAhAww5C0HUASEDIAEgBEYNOCACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGB0ABqLQAARw0CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw5CyACQYEEOwEoIAIoAgQhACACQgA3AwAgAiAAIAZBAWoiARAnIgANAwwCCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB2Bs2AhAgAkEINgIMDDYLQboBIQMMHAsgAkHTATYCHCACIAE2AhQgAiAANgIMQQAhAww0C0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAARQ0AIABBFUYNASACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwwzC0HkACEDDBkLIAJB+AA2AhwgAiABNgIUIAJByhg2AhAgAkEVNgIMQQAhAwwxC0HSASEDIAQgASIARg0wIAQgAWsgAigCACIBaiEFIAAgAWtBBGohBgJAA0AgAC0AACABQfzPAGotAABHDQEgAUEERg0DIAFBAWohASAEIABBAWoiAEcNAAsgAiAFNgIADDELIAJBADYCHCACIAA2AhQgAkGQMzYCECACQQg2AgwgAkEANgIAQQAhAwwwCyABIARHBEAgAkEONgIIIAIgATYCBEG3ASEDDBcLQdEBIQMMLwsgAkEANgIAIAZBAWohAQtBuAEhAwwUCyABIARGBEBB0AEhAwwtCyABLQAAQTBrIgBB/wFxQQpJBEAgAiAAOgAqIAFBAWohAUG2ASEDDBQLIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0UIAJBzwE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAsgASAERgRAQc4BIQMMLAsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0VIAJBzQE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAtBtQEhAwwSCyAEIAEiBUYEQEHMASEDDCsLQQAhAEEBIQFBASEGQQAhAwJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAUtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyEDQQAhAUEAIQYMAgtBCSEDQQEhAEEAIQFBACEGDAELQQAhAUEBIQMLIAIgAzoAKyAFQQFqIQMCQAJAIAItAC1BEHENAAJAAkACQCACLQAqDgMBAAIECyAGRQ0DDAILIAANAQwCCyABRQ0BCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMAwsgAkHJATYCHCACIAM2AhQgAiAANgIMQQAhAwwtCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMGAsgAkHKATYCHCACIAM2AhQgAiAANgIMQQAhAwwsCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMFgsgAkHLATYCHCACIAU2AhQgAiAANgIMDCsLQbQBIQMMEQtBACEAAkAgAigCOCIDRQ0AIAMoAjwiA0UNACACIAMRAAAhAAsCQCAABEAgAEEVRg0BIAJBADYCHCACIAE2AhQgAkGUDTYCECACQSE2AgxBACEDDCsLQbIBIQMMEQsgAkHIATYCHCACIAE2AhQgAkHJFzYCECACQRU2AgxBACEDDCkLIAJBADYCACAGQQFqIQFB9QAhAwwPCyACLQApQQVGBEBB4wAhAwwPC0HiACEDDA4LIAAhASACQQA2AgALIAJBADoALEEJIQMMDAsgAkEANgIAIAdBAWohAUHAACEDDAsLQQELOgAsIAJBADYCACAGQQFqIQELQSkhAwwIC0E4IQMMBwsCQCABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBPiEDDCELQT4hAwwgCwsgAkEAOgAsDAELQQshAwwEC0E6IQMMAwsgAUEBaiEBQS0hAwwCCyACIAE6ACwgAkEANgIAIAZBAWohAUEMIQMMAQsgAkEANgIAIAZBAWohAUEKIQMMAAsAC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwXC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwWC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwVC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwUC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwTC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwSC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwRC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwQC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwPC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwOC0EAIQMgAkEANgIcIAIgATYCFCACQcASNgIQIAJBCzYCDAwNC0EAIQMgAkEANgIcIAIgATYCFCACQZUJNgIQIAJBCzYCDAwMC0EAIQMgAkEANgIcIAIgATYCFCACQeEPNgIQIAJBCjYCDAwLC0EAIQMgAkEANgIcIAIgATYCFCACQfsPNgIQIAJBCjYCDAwKC0EAIQMgAkEANgIcIAIgATYCFCACQfEZNgIQIAJBAjYCDAwJC0EAIQMgAkEANgIcIAIgATYCFCACQcQUNgIQIAJBAjYCDAwIC0EAIQMgAkEANgIcIAIgATYCFCACQfIVNgIQIAJBAjYCDAwHCyACQQI2AhwgAiABNgIUIAJBnBo2AhAgAkEWNgIMQQAhAwwGC0EBIQMMBQtB1AAhAyABIARGDQQgCEEIaiEJIAIoAgAhBQJAAkAgASAERwRAIAVB2MIAaiEHIAQgBWogAWshACAFQX9zQQpqIgUgAWohBgNAIAEtAAAgBy0AAEcEQEECIQcMAwsgBUUEQEEAIQcgBiEBDAMLIAVBAWshBSAHQQFqIQcgBCABQQFqIgFHDQALIAAhBSAEIQELIAlBATYCACACIAU2AgAMAQsgAkEANgIAIAkgBzYCAAsgCSABNgIEIAgoAgwhACAIKAIIDgMBBAIACwALIAJBADYCHCACQbUaNgIQIAJBFzYCDCACIABBAWo2AhRBACEDDAILIAJBADYCHCACIAA2AhQgAkHKGjYCECACQQk2AgxBACEDDAELIAEgBEYEQEEiIQMMAQsgAkEJNgIIIAIgATYCBEEhIQMLIAhBEGokACADRQRAIAIoAgwhAAwBCyACIAM2AhxBACEAIAIoAgQiAUUNACACIAEgBCACKAIIEQEAIgFFDQAgAiAENgIUIAIgATYCDCABIQALIAALvgIBAn8gAEEAOgAAIABB3ABqIgFBAWtBADoAACAAQQA6AAIgAEEAOgABIAFBA2tBADoAACABQQJrQQA6AAAgAEEAOgADIAFBBGtBADoAAEEAIABrQQNxIgEgAGoiAEEANgIAQdwAIAFrQXxxIgIgAGoiAUEEa0EANgIAAkAgAkEJSQ0AIABBADYCCCAAQQA2AgQgAUEIa0EANgIAIAFBDGtBADYCACACQRlJDQAgAEEANgIYIABBADYCFCAAQQA2AhAgAEEANgIMIAFBEGtBADYCACABQRRrQQA2AgAgAUEYa0EANgIAIAFBHGtBADYCACACIABBBHFBGHIiAmsiAUEgSQ0AIAAgAmohAANAIABCADcDGCAAQgA3AxAgAEIANwMIIABCADcDACAAQSBqIQAgAUEgayIBQR9LDQALCwtWAQF/AkAgACgCDA0AAkACQAJAAkAgAC0ALw4DAQADAgsgACgCOCIBRQ0AIAEoAiwiAUUNACAAIAERAAAiAQ0DC0EADwsACyAAQcMWNgIQQQ4hAQsgAQsaACAAKAIMRQRAIABB0Rs2AhAgAEEVNgIMCwsUACAAKAIMQRVGBEAgAEEANgIMCwsUACAAKAIMQRZGBEAgAEEANgIMCwsHACAAKAIMCwcAIAAoAhALCQAgACABNgIQCwcAIAAoAhQLFwAgAEEkTwRAAAsgAEECdEGgM2ooAgALFwAgAEEuTwRAAAsgAEECdEGwNGooAgALvwkBAX9B6yghAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB9ysPC0GQMQ8LQdcxDwtBoi0PC0HUJw8LQeArDwtBnywPC0HrMQ8LQdUfDwtByjEPC0HeJQ8LQdQeDwtB9BwPC0GnMg8LQbEdDwtBoB0PC0G5MQ8LQbwwDwtBkiEPC0GzJg8LQeksDwtBrB4PC0HUKw8LQfcmDwtBgCYPC0GwIQ8LQf4eDwtBjSMPC0GJLQ8LQfciDwtBoDEPC0GuHw8LQcYlDwtB6B4PC0GTIg8LQcIvDwtBwx0PC0GLLA8LQeEdDwtBjS8PC0HqIQ8LQbQtDwtB0i8PC0HfMg8LQdIyDwtB8DAPC0GpIg8LQfkjDwtBmR4PC0G1LA8LQZswDwtBkjIPC0G2Kw8LQcIiDwtB+DIPC0GeJQ8LQdAiDwtBuh4PC0GBHg8LAAtB1iEhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBxhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9go2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7Ro2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBqhs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7RM2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBwhk2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlBQ2AhBBGCEECyAEC1kBAn8CQCAALQAoQQFGDQAgAC8BMiIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEwIgFBAnFFDQEMAgsgAC8BMCIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATIiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtzACAAQRBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAA/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQTBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQSBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQd0BNgIcCwYAIAAQMguaLQELfyMAQRBrIgokAEGk0AAoAgAiCUUEQEHk0wAoAgAiBUUEQEHw0wBCfzcCAEHo0wBCgICEgICAwAA3AgBB5NMAIApBCGpBcHFB2KrVqgVzIgU2AgBB+NMAQQA2AgBByNMAQQA2AgALQczTAEGA1AQ2AgBBnNAAQYDUBDYCAEGw0AAgBTYCAEGs0ABBfzYCAEHQ0wBBgKwDNgIAA0AgAUHI0ABqIAFBvNAAaiICNgIAIAIgAUG00ABqIgM2AgAgAUHA0ABqIAM2AgAgAUHQ0ABqIAFBxNAAaiIDNgIAIAMgAjYCACABQdjQAGogAUHM0ABqIgI2AgAgAiADNgIAIAFB1NAAaiACNgIAIAFBIGoiAUGAAkcNAAtBjNQEQcGrAzYCAEGo0ABB9NMAKAIANgIAQZjQAEHAqwM2AgBBpNAAQYjUBDYCAEHM/wdBODYCAEGI1AQhCQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQewBTQRAQYzQACgCACIGQRAgAEETakFwcSAAQQtJGyIEQQN2IgB2IgFBA3EEQAJAIAFBAXEgAHJBAXMiAkEDdCIAQbTQAGoiASAAQbzQAGooAgAiACgCCCIDRgRAQYzQACAGQX4gAndxNgIADAELIAEgAzYCCCADIAE2AgwLIABBCGohASAAIAJBA3QiAkEDcjYCBCAAIAJqIgAgACgCBEEBcjYCBAwRC0GU0AAoAgAiCCAETw0BIAEEQAJAQQIgAHQiAkEAIAJrciABIAB0cWgiAEEDdCICQbTQAGoiASACQbzQAGooAgAiAigCCCIDRgRAQYzQACAGQX4gAHdxIgY2AgAMAQsgASADNgIIIAMgATYCDAsgAiAEQQNyNgIEIABBA3QiACAEayEFIAAgAmogBTYCACACIARqIgQgBUEBcjYCBCAIBEAgCEF4cUG00ABqIQBBoNAAKAIAIQMCf0EBIAhBA3Z0IgEgBnFFBEBBjNAAIAEgBnI2AgAgAAwBCyAAKAIICyIBIAM2AgwgACADNgIIIAMgADYCDCADIAE2AggLIAJBCGohAUGg0AAgBDYCAEGU0AAgBTYCAAwRC0GQ0AAoAgAiC0UNASALaEECdEG80gBqKAIAIgAoAgRBeHEgBGshBSAAIQIDQAJAIAIoAhAiAUUEQCACQRRqKAIAIgFFDQELIAEoAgRBeHEgBGsiAyAFSSECIAMgBSACGyEFIAEgACACGyEAIAEhAgwBCwsgACgCGCEJIAAoAgwiAyAARwRAQZzQACgCABogAyAAKAIIIgE2AgggASADNgIMDBALIABBFGoiAigCACIBRQRAIAAoAhAiAUUNAyAAQRBqIQILA0AgAiEHIAEiA0EUaiICKAIAIgENACADQRBqIQIgAygCECIBDQALIAdBADYCAAwPC0F/IQQgAEG/f0sNACAAQRNqIgFBcHEhBEGQ0AAoAgAiCEUNAEEAIARrIQUCQAJAAkACf0EAIARBgAJJDQAaQR8gBEH///8HSw0AGiAEQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qCyIGQQJ0QbzSAGooAgAiAkUEQEEAIQFBACEDDAELQQAhASAEQRkgBkEBdmtBACAGQR9HG3QhAEEAIQMDQAJAIAIoAgRBeHEgBGsiByAFTw0AIAIhAyAHIgUNAEEAIQUgAiEBDAMLIAEgAkEUaigCACIHIAcgAiAAQR12QQRxakEQaigCACICRhsgASAHGyEBIABBAXQhACACDQALCyABIANyRQRAQQAhA0ECIAZ0IgBBACAAa3IgCHEiAEUNAyAAaEECdEG80gBqKAIAIQELIAFFDQELA0AgASgCBEF4cSAEayICIAVJIQAgAiAFIAAbIQUgASADIAAbIQMgASgCECIABH8gAAUgAUEUaigCAAsiAQ0ACwsgA0UNACAFQZTQACgCACAEa08NACADKAIYIQcgAyADKAIMIgBHBEBBnNAAKAIAGiAAIAMoAggiATYCCCABIAA2AgwMDgsgA0EUaiICKAIAIgFFBEAgAygCECIBRQ0DIANBEGohAgsDQCACIQYgASIAQRRqIgIoAgAiAQ0AIABBEGohAiAAKAIQIgENAAsgBkEANgIADA0LQZTQACgCACIDIARPBEBBoNAAKAIAIQECQCADIARrIgJBEE8EQCABIARqIgAgAkEBcjYCBCABIANqIAI2AgAgASAEQQNyNgIEDAELIAEgA0EDcjYCBCABIANqIgAgACgCBEEBcjYCBEEAIQBBACECC0GU0AAgAjYCAEGg0AAgADYCACABQQhqIQEMDwtBmNAAKAIAIgMgBEsEQCAEIAlqIgAgAyAEayIBQQFyNgIEQaTQACAANgIAQZjQACABNgIAIAkgBEEDcjYCBCAJQQhqIQEMDwtBACEBIAQCf0Hk0wAoAgAEQEHs0wAoAgAMAQtB8NMAQn83AgBB6NMAQoCAhICAgMAANwIAQeTTACAKQQxqQXBxQdiq1aoFczYCAEH40wBBADYCAEHI0wBBADYCAEGAgAQLIgAgBEHHAGoiBWoiBkEAIABrIgdxIgJPBEBB/NMAQTA2AgAMDwsCQEHE0wAoAgAiAUUNAEG80wAoAgAiCCACaiEAIAAgAU0gACAIS3ENAEEAIQFB/NMAQTA2AgAMDwtByNMALQAAQQRxDQQCQAJAIAkEQEHM0wAhAQNAIAEoAgAiACAJTQRAIAAgASgCBGogCUsNAwsgASgCCCIBDQALC0EAEDMiAEF/Rg0FIAIhBkHo0wAoAgAiAUEBayIDIABxBEAgAiAAayAAIANqQQAgAWtxaiEGCyAEIAZPDQUgBkH+////B0sNBUHE0wAoAgAiAwRAQbzTACgCACIHIAZqIQEgASAHTQ0GIAEgA0sNBgsgBhAzIgEgAEcNAQwHCyAGIANrIAdxIgZB/v///wdLDQQgBhAzIQAgACABKAIAIAEoAgRqRg0DIAAhAQsCQCAGIARByABqTw0AIAFBf0YNAEHs0wAoAgAiACAFIAZrakEAIABrcSIAQf7///8HSwRAIAEhAAwHCyAAEDNBf0cEQCAAIAZqIQYgASEADAcLQQAgBmsQMxoMBAsgASIAQX9HDQUMAwtBACEDDAwLQQAhAAwKCyAAQX9HDQILQcjTAEHI0wAoAgBBBHI2AgALIAJB/v///wdLDQEgAhAzIQBBABAzIQEgAEF/Rg0BIAFBf0YNASAAIAFPDQEgASAAayIGIARBOGpNDQELQbzTAEG80wAoAgAgBmoiATYCAEHA0wAoAgAgAUkEQEHA0wAgATYCAAsCQAJAAkBBpNAAKAIAIgIEQEHM0wAhAQNAIAAgASgCACIDIAEoAgQiBWpGDQIgASgCCCIBDQALDAILQZzQACgCACIBQQBHIAAgAU9xRQRAQZzQACAANgIAC0EAIQFB0NMAIAY2AgBBzNMAIAA2AgBBrNAAQX82AgBBsNAAQeTTACgCADYCAEHY0wBBADYCAANAIAFByNAAaiABQbzQAGoiAjYCACACIAFBtNAAaiIDNgIAIAFBwNAAaiADNgIAIAFB0NAAaiABQcTQAGoiAzYCACADIAI2AgAgAUHY0ABqIAFBzNAAaiICNgIAIAIgAzYCACABQdTQAGogAjYCACABQSBqIgFBgAJHDQALQXggAGtBD3EiASAAaiICIAZBOGsiAyABayIBQQFyNgIEQajQAEH00wAoAgA2AgBBmNAAIAE2AgBBpNAAIAI2AgAgACADakE4NgIEDAILIAAgAk0NACACIANJDQAgASgCDEEIcQ0AQXggAmtBD3EiACACaiIDQZjQACgCACAGaiIHIABrIgBBAXI2AgQgASAFIAZqNgIEQajQAEH00wAoAgA2AgBBmNAAIAA2AgBBpNAAIAM2AgAgAiAHakE4NgIEDAELIABBnNAAKAIASQRAQZzQACAANgIACyAAIAZqIQNBzNMAIQECQAJAAkADQCADIAEoAgBHBEAgASgCCCIBDQEMAgsLIAEtAAxBCHFFDQELQczTACEBA0AgASgCACIDIAJNBEAgAyABKAIEaiIFIAJLDQMLIAEoAgghAQwACwALIAEgADYCACABIAEoAgQgBmo2AgQgAEF4IABrQQ9xaiIJIARBA3I2AgQgA0F4IANrQQ9xaiIGIAQgCWoiBGshASACIAZGBEBBpNAAIAQ2AgBBmNAAQZjQACgCACABaiIANgIAIAQgAEEBcjYCBAwIC0Gg0AAoAgAgBkYEQEGg0AAgBDYCAEGU0ABBlNAAKAIAIAFqIgA2AgAgBCAAQQFyNgIEIAAgBGogADYCAAwICyAGKAIEIgVBA3FBAUcNBiAFQXhxIQggBUH/AU0EQCAFQQN2IQMgBigCCCIAIAYoAgwiAkYEQEGM0ABBjNAAKAIAQX4gA3dxNgIADAcLIAIgADYCCCAAIAI2AgwMBgsgBigCGCEHIAYgBigCDCIARwRAIAAgBigCCCICNgIIIAIgADYCDAwFCyAGQRRqIgIoAgAiBUUEQCAGKAIQIgVFDQQgBkEQaiECCwNAIAIhAyAFIgBBFGoiAigCACIFDQAgAEEQaiECIAAoAhAiBQ0ACyADQQA2AgAMBAtBeCAAa0EPcSIBIABqIgcgBkE4ayIDIAFrIgFBAXI2AgQgACADakE4NgIEIAIgBUE3IAVrQQ9xakE/ayIDIAMgAkEQakkbIgNBIzYCBEGo0ABB9NMAKAIANgIAQZjQACABNgIAQaTQACAHNgIAIANBEGpB1NMAKQIANwIAIANBzNMAKQIANwIIQdTTACADQQhqNgIAQdDTACAGNgIAQczTACAANgIAQdjTAEEANgIAIANBJGohAQNAIAFBBzYCACAFIAFBBGoiAUsNAAsgAiADRg0AIAMgAygCBEF+cTYCBCADIAMgAmsiBTYCACACIAVBAXI2AgQgBUH/AU0EQCAFQXhxQbTQAGohAAJ/QYzQACgCACIBQQEgBUEDdnQiA3FFBEBBjNAAIAEgA3I2AgAgAAwBCyAAKAIICyIBIAI2AgwgACACNgIIIAIgADYCDCACIAE2AggMAQtBHyEBIAVB////B00EQCAFQSYgBUEIdmciAGt2QQFxIABBAXRrQT5qIQELIAIgATYCHCACQgA3AhAgAUECdEG80gBqIQBBkNAAKAIAIgNBASABdCIGcUUEQCAAIAI2AgBBkNAAIAMgBnI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEDAkADQCADIgAoAgRBeHEgBUYNASABQR12IQMgAUEBdCEBIAAgA0EEcWpBEGoiBigCACIDDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLQZjQACgCACIBIARNDQBBpNAAKAIAIgAgBGoiAiABIARrIgFBAXI2AgRBmNAAIAE2AgBBpNAAIAI2AgAgACAEQQNyNgIEIABBCGohAQwIC0EAIQFB/NMAQTA2AgAMBwtBACEACyAHRQ0AAkAgBigCHCICQQJ0QbzSAGoiAygCACAGRgRAIAMgADYCACAADQFBkNAAQZDQACgCAEF+IAJ3cTYCAAwCCyAHQRBBFCAHKAIQIAZGG2ogADYCACAARQ0BCyAAIAc2AhggBigCECICBEAgACACNgIQIAIgADYCGAsgBkEUaigCACICRQ0AIABBFGogAjYCACACIAA2AhgLIAEgCGohASAGIAhqIgYoAgQhBQsgBiAFQX5xNgIEIAEgBGogATYCACAEIAFBAXI2AgQgAUH/AU0EQCABQXhxQbTQAGohAAJ/QYzQACgCACICQQEgAUEDdnQiAXFFBEBBjNAAIAEgAnI2AgAgAAwBCyAAKAIICyIBIAQ2AgwgACAENgIIIAQgADYCDCAEIAE2AggMAQtBHyEFIAFB////B00EQCABQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qIQULIAQgBTYCHCAEQgA3AhAgBUECdEG80gBqIQBBkNAAKAIAIgJBASAFdCIDcUUEQCAAIAQ2AgBBkNAAIAIgA3I2AgAgBCAANgIYIAQgBDYCCCAEIAQ2AgwMAQsgAUEZIAVBAXZrQQAgBUEfRxt0IQUgACgCACEAAkADQCAAIgIoAgRBeHEgAUYNASAFQR12IQAgBUEBdCEFIAIgAEEEcWpBEGoiAygCACIADQALIAMgBDYCACAEIAI2AhggBCAENgIMIAQgBDYCCAwBCyACKAIIIgAgBDYCDCACIAQ2AgggBEEANgIYIAQgAjYCDCAEIAA2AggLIAlBCGohAQwCCwJAIAdFDQACQCADKAIcIgFBAnRBvNIAaiICKAIAIANGBEAgAiAANgIAIAANAUGQ0AAgCEF+IAF3cSIINgIADAILIAdBEEEUIAcoAhAgA0YbaiAANgIAIABFDQELIAAgBzYCGCADKAIQIgEEQCAAIAE2AhAgASAANgIYCyADQRRqKAIAIgFFDQAgAEEUaiABNgIAIAEgADYCGAsCQCAFQQ9NBEAgAyAEIAVqIgBBA3I2AgQgACADaiIAIAAoAgRBAXI2AgQMAQsgAyAEaiICIAVBAXI2AgQgAyAEQQNyNgIEIAIgBWogBTYCACAFQf8BTQRAIAVBeHFBtNAAaiEAAn9BjNAAKAIAIgFBASAFQQN2dCIFcUUEQEGM0AAgASAFcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbzSAGohAEEBIAF0IgQgCHFFBEAgACACNgIAQZDQACAEIAhyNgIAIAIgADYCGCACIAI2AgggAiACNgIMDAELIAVBGSABQQF2a0EAIAFBH0cbdCEBIAAoAgAhBAJAA0AgBCIAKAIEQXhxIAVGDQEgAUEddiEEIAFBAXQhASAAIARBBHFqQRBqIgYoAgAiBA0ACyAGIAI2AgAgAiAANgIYIAIgAjYCDCACIAI2AggMAQsgACgCCCIBIAI2AgwgACACNgIIIAJBADYCGCACIAA2AgwgAiABNgIICyADQQhqIQEMAQsCQCAJRQ0AAkAgACgCHCIBQQJ0QbzSAGoiAigCACAARgRAIAIgAzYCACADDQFBkNAAIAtBfiABd3E2AgAMAgsgCUEQQRQgCSgCECAARhtqIAM2AgAgA0UNAQsgAyAJNgIYIAAoAhAiAQRAIAMgATYCECABIAM2AhgLIABBFGooAgAiAUUNACADQRRqIAE2AgAgASADNgIYCwJAIAVBD00EQCAAIAQgBWoiAUEDcjYCBCAAIAFqIgEgASgCBEEBcjYCBAwBCyAAIARqIgcgBUEBcjYCBCAAIARBA3I2AgQgBSAHaiAFNgIAIAgEQCAIQXhxQbTQAGohAUGg0AAoAgAhAwJ/QQEgCEEDdnQiAiAGcUUEQEGM0AAgAiAGcjYCACABDAELIAEoAggLIgIgAzYCDCABIAM2AgggAyABNgIMIAMgAjYCCAtBoNAAIAc2AgBBlNAAIAU2AgALIABBCGohAQsgCkEQaiQAIAELQwAgAEUEQD8AQRB0DwsCQCAAQf//A3ENACAAQQBIDQAgAEEQdkAAIgBBf0YEQEH80wBBMDYCAEF/DwsgAEEQdA8LAAsL3D8iAEGACAsJAQAAAAIAAAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4otSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwBB+TULAQEAQZA2C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQf03CwEBAEGROAteAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgBB/TkLAQEAQZE6C14CAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEHwOwsNbG9zZWVlcC1hbGl2ZQBBiTwLAQEAQaA8C+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQYk+CwEBAEGgPgvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBsMAAC18BAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBBkMIACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQcDCAAstcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAEH5wgALBQECAAEDAEGQwwAL4AEEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cQACwUBAgABAwBBkMUAC+ABBAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnGAAsEAQAAAQBBkccAC98BAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+sgACwQBAAACAEGQyQALXwMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAEH6ygALBAEAAAEAQZDLAAsBAQBBqssAC0ECAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB+swACwQBAAABAEGQzQALAQEAQZrNAAsGAgAAAAACAEGxzQALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQfDOAAuWAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==",
    "base64",
  )
})
var hE = _((ADt, jre) => {
  "use strict"
  var Wre = ["GET", "HEAD", "POST"],
    d4e = new Set(Wre),
    f4e = [101, 204, 205, 304],
    Gre = [301, 302, 303, 307, 308],
    h4e = new Set(Gre),
    $re = [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "4190",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6679",
      "6697",
      "10080",
    ],
    g4e = new Set($re),
    Yre = [
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url",
    ],
    p4e = new Set(Yre),
    m4e = ["follow", "manual", "error"],
    Kre = ["GET", "HEAD", "OPTIONS", "TRACE"],
    A4e = new Set(Kre),
    y4e = ["navigate", "same-origin", "no-cors", "cors"],
    v4e = ["omit", "same-origin", "include"],
    C4e = [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached",
    ],
    b4e = [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type",
      "content-length",
    ],
    E4e = ["half"],
    zre = ["CONNECT", "TRACE", "TRACK"],
    _4e = new Set(zre),
    Jre = [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      "",
    ],
    x4e = new Set(Jre)
  jre.exports = {
    subresource: Jre,
    forbiddenMethods: zre,
    requestBodyHeader: b4e,
    referrerPolicy: Yre,
    requestRedirect: m4e,
    requestMode: y4e,
    requestCredentials: v4e,
    requestCache: C4e,
    redirectStatus: Gre,
    corsSafeListedMethods: Wre,
    nullBodyStatus: f4e,
    safeMethods: Kre,
    badPorts: $re,
    requestDuplex: E4e,
    subresourceSet: x4e,
    badPortsSet: g4e,
    redirectStatusSet: h4e,
    corsSafeListedMethodsSet: d4e,
    safeMethodsSet: A4e,
    forbiddenMethodsSet: _4e,
    referrerPolicySet: p4e,
  }
})
var Yq = _((yDt, Zre) => {
  "use strict"
  var $q = Symbol.for("undici.globalOrigin.1")
  function w4e() {
    return globalThis[$q]
  }
  function S4e(e) {
    if (e === undefined) {
      Object.defineProperty(globalThis, $q, {
        value: undefined,
        writable: true,
        enumerable: false,
        configurable: false,
      })
      return
    }
    let t = new URL(e)
    if (t.protocol !== "http:" && t.protocol !== "https:")
      throw new TypeError(
        `Only http & https urls are allowed, received ${t.protocol}`,
      )
    Object.defineProperty(globalThis, $q, {
      value: t,
      writable: true,
      enumerable: false,
      configurable: false,
    })
  }
  Zre.exports = { getGlobalOrigin: w4e, setGlobalOrigin: S4e }
})
var zo = _((vDt, sne) => {
  "use strict"
  var bR = require("assert"),
    I4e = new TextEncoder(),
    gE = /^[!#$%&'*+\-.^_|~A-Za-z0-9]+$/,
    B4e = /[\u000A\u000D\u0009\u0020]/,
    R4e = /[\u0009\u000A\u000C\u000D\u0020]/g,
    D4e = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/
  function T4e(e) {
    bR(e.protocol === "data:")
    let t = tne(e, true)
    t = t.slice(5)
    let r = { position: 0 },
      n = D0(",", t, r),
      i = n.length
    if (((n = P4e(n, true, true)), r.position >= t.length)) return "failure"
    r.position++
    let s = t.slice(i + 1),
      o = rne(s)
    if (/;(\u0020){0,}base64$/i.test(n)) {
      let l = ine(o)
      if (((o = M4e(l)), o === "failure")) return "failure"
      ;(n = n.slice(0, -6)),
        (n = n.replace(/(\u0020)+$/, "")),
        (n = n.slice(0, -1))
    }
    n.startsWith(";") && (n = "text/plain" + n)
    let a = Kq(n)
    return (
      a === "failure" && (a = Kq("text/plain;charset=US-ASCII")),
      { mimeType: a, body: o }
    )
  }
  function tne(e, t = false) {
    if (!t) return e.href
    let r = e.href,
      n = e.hash.length,
      i = n === 0 ? r : r.substring(0, r.length - n)
    return !n && r.endsWith("#") ? i.slice(0, -1) : i
  }
  function ER(e, t, r) {
    let n = ""
    for (; r.position < t.length && e(t[r.position]); )
      (n += t[r.position]), r.position++
    return n
  }
  function D0(e, t, r) {
    let n = t.indexOf(e, r.position),
      i = r.position
    return n === -1
      ? ((r.position = t.length), t.slice(i))
      : ((r.position = n), t.slice(i, r.position))
  }
  function rne(e) {
    let t = I4e.encode(e)
    return k4e(t)
  }
  function Xre(e) {
    return (e >= 48 && e <= 57) || (e >= 65 && e <= 70) || (e >= 97 && e <= 102)
  }
  function ene(e) {
    return e >= 48 && e <= 57 ? e - 48 : (e & 223) - 55
  }
  function k4e(e) {
    let t = e.length,
      r = new Uint8Array(t),
      n = 0
    for (let i = 0; i < t; ++i) {
      let s = e[i]
      s !== 37
        ? (r[n++] = s)
        : s === 37 && !(Xre(e[i + 1]) && Xre(e[i + 2]))
          ? (r[n++] = 37)
          : ((r[n++] = (ene(e[i + 1]) << 4) | ene(e[i + 2])), (i += 2))
    }
    return t === n ? r : r.subarray(0, n)
  }
  function Kq(e) {
    e = CR(e, true, true)
    let t = { position: 0 },
      r = D0("/", e, t)
    if (r.length === 0 || !gE.test(r) || t.position > e.length) return "failure"
    t.position++
    let n = D0(";", e, t)
    if (((n = CR(n, false, true)), n.length === 0 || !gE.test(n))) return "failure"
    let i = r.toLowerCase(),
      s = n.toLowerCase(),
      o = { type: i, subtype: s, parameters: new Map(), essence: `${i}/${s}` }
    for (; t.position < e.length; ) {
      t.position++, ER((c) => B4e.test(c), e, t)
      let a = ER((c) => c !== ";" && c !== "=", e, t)
      if (((a = a.toLowerCase()), t.position < e.length)) {
        if (e[t.position] === ";") continue
        t.position++
      }
      if (t.position > e.length) break
      let l = null
      if (e[t.position] === '"') (l = nne(e, t, true)), D0(";", e, t)
      else if (((l = D0(";", e, t)), (l = CR(l, false, true)), l.length === 0))
        continue
      a.length !== 0 &&
        gE.test(a) &&
        (l.length === 0 || D4e.test(l)) &&
        !o.parameters.has(a) &&
        o.parameters.set(a, l)
    }
    return o
  }
  function M4e(e) {
    e = e.replace(R4e, "")
    let t = e.length
    if (
      (t % 4 === 0 &&
        e.charCodeAt(t - 1) === 61 &&
        (--t, e.charCodeAt(t - 1) === 61 && --t),
      t % 4 === 1 ||
        /[^+/0-9A-Za-z]/.test(e.length === t ? e : e.substring(0, t)))
    )
      return "failure"
    let r = Buffer.from(e, "base64")
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength)
  }
  function nne(e, t, r) {
    let n = t.position,
      i = ""
    for (
      bR(e[t.position] === '"'), t.position++;
      (i += ER((o) => o !== '"' && o !== "\\", e, t)),
        !(t.position >= e.length);

    ) {
      let s = e[t.position]
      if ((t.position++, s === "\\")) {
        if (t.position >= e.length) {
          i += "\\"
          break
        }
        ;(i += e[t.position]), t.position++
      } else {
        bR(s === '"')
        break
      }
    }
    return r ? i : e.slice(n, t.position)
  }
  function F4e(e) {
    bR(e !== "failure")
    let { parameters: t, essence: r } = e,
      n = r
    for (let [i, s] of t.entries())
      (n += ";"),
        (n += i),
        (n += "="),
        gE.test(s) ||
          ((s = s.replace(/(\\|")/g, "\\$1")), (s = '"' + s), (s += '"')),
        (n += s)
    return n
  }
  function Q4e(e) {
    return e === 13 || e === 10 || e === 9 || e === 32
  }
  function CR(e, t = true, r = true) {
    return zq(e, t, r, Q4e)
  }
  function N4e(e) {
    return e === 13 || e === 10 || e === 9 || e === 12 || e === 32
  }
  function P4e(e, t = true, r = true) {
    return zq(e, t, r, N4e)
  }
  function zq(e, t, r, n) {
    let i = 0,
      s = e.length - 1
    if (t) for (; i < e.length && n(e.charCodeAt(i)); ) i++
    if (r) for (; s > 0 && n(e.charCodeAt(s)); ) s--
    return i === 0 && s === e.length - 1 ? e : e.slice(i, s + 1)
  }
  function ine(e) {
    let t = e.length
    if (65535 > t) return String.fromCharCode.apply(null, e)
    let r = "",
      n = 0,
      i = 65535
    for (; n < t; )
      n + i > t && (i = t - n),
        (r += String.fromCharCode.apply(null, e.subarray(n, (n += i))))
    return r
  }
  function L4e(e) {
    switch (e.essence) {
      case "application/ecmascript":
      case "application/javascript":
      case "application/x-ecmascript":
      case "application/x-javascript":
      case "text/ecmascript":
      case "text/javascript":
      case "text/javascript1.0":
      case "text/javascript1.1":
      case "text/javascript1.2":
      case "text/javascript1.3":
      case "text/javascript1.4":
      case "text/javascript1.5":
      case "text/jscript":
      case "text/livescript":
      case "text/x-ecmascript":
      case "text/x-javascript":
        return "text/javascript"
      case "application/json":
      case "text/json":
        return "application/json"
      case "image/svg+xml":
        return "image/svg+xml"
      case "text/xml":
      case "application/xml":
        return "application/xml"
    }
    return e.subtype.endsWith("+json")
      ? "application/json"
      : e.subtype.endsWith("+xml")
        ? "application/xml"
        : ""
  }
  sne.exports = {
    dataURLProcessor: T4e,
    URLSerializer: tne,
    collectASequenceOfCodePoints: ER,
    collectASequenceOfCodePointsFast: D0,
    stringPercentDecode: rne,
    parseMIMEType: Kq,
    collectAnHTTPQuotedString: nne,
    serializeAMimeType: F4e,
    removeChars: zq,
    removeHTTPWhitespace: CR,
    minimizeSupportedMimeType: L4e,
    HTTP_TOKEN_CODEPOINTS: gE,
    isomorphicDecode: ine,
  }
})
var Is = _((CDt, one) => {
  "use strict"
  var { types: bu, inspect: U4e } = require("util"),
    { markAsUncloneable: O4e } = require("worker_threads"),
    { toUSVString: q4e } = ir(),
    _e = {}
  _e.converters = {}
  _e.util = {}
  _e.errors = {}
  _e.errors.exception = function (e) {
    return new TypeError(`${e.header}: ${e.message}`)
  }
  _e.errors.conversionFailed = function (e) {
    let t = e.types.length === 1 ? "" : " one of",
      r = `${e.argument} could not be converted to${t}: ${e.types.join(", ")}.`
    return _e.errors.exception({ header: e.prefix, message: r })
  }
  _e.errors.invalidArgument = function (e) {
    return _e.errors.exception({
      header: e.prefix,
      message: `"${e.value}" is an invalid ${e.type}.`,
    })
  }
  _e.brandCheck = function (e, t, r) {
    if (r?.strict !== false) {
      if (!(e instanceof t)) {
        let n = new TypeError("Illegal invocation")
        throw ((n.code = "ERR_INVALID_THIS"), n)
      }
    } else if (e?.[Symbol.toStringTag] !== t.prototype[Symbol.toStringTag]) {
      let n = new TypeError("Illegal invocation")
      throw ((n.code = "ERR_INVALID_THIS"), n)
    }
  }
  _e.argumentLengthCheck = function ({ length: e }, t, r) {
    if (e < t)
      throw _e.errors.exception({
        message: `${t} argument${t !== 1 ? "s" : ""} required, but${e ? " only" : ""} ${e} found.`,
        header: r,
      })
  }
  _e.illegalConstructor = function () {
    throw _e.errors.exception({
      header: "TypeError",
      message: "Illegal constructor",
    })
  }
  _e.util.Type = function (e) {
    switch (typeof e) {
      case "undefined":
        return "Undefined"
      case "boolean":
        return "Boolean"
      case "string":
        return "String"
      case "symbol":
        return "Symbol"
      case "number":
        return "Number"
      case "bigint":
        return "BigInt"
      case "function":
      case "object":
        return e === null ? "Null" : "Object"
    }
  }
  _e.util.markAsUncloneable = O4e || (() => {})
  _e.util.ConvertToInt = function (e, t, r, n) {
    let i, s
    t === 64
      ? ((i = Math.pow(2, 53) - 1),
        r === "unsigned" ? (s = 0) : (s = Math.pow(-2, 53) + 1))
      : r === "unsigned"
        ? ((s = 0), (i = Math.pow(2, t) - 1))
        : ((s = Math.pow(-2, t) - 1), (i = Math.pow(2, t - 1) - 1))
    let o = Number(e)
    if ((o === 0 && (o = 0), n?.enforceRange === true)) {
      if (
        Number.isNaN(o) ||
        o === Number.POSITIVE_INFINITY ||
        o === Number.NEGATIVE_INFINITY
      )
        throw _e.errors.exception({
          header: "Integer conversion",
          message: `Could not convert ${_e.util.Stringify(e)} to an integer.`,
        })
      if (((o = _e.util.IntegerPart(o)), o < s || o > i))
        throw _e.errors.exception({
          header: "Integer conversion",
          message: `Value must be between ${s}-${i}, got ${o}.`,
        })
      return o
    }
    return !Number.isNaN(o) && n?.clamp === true
      ? ((o = Math.min(Math.max(o, s), i)),
        Math.floor(o) % 2 === 0 ? (o = Math.floor(o)) : (o = Math.ceil(o)),
        o)
      : Number.isNaN(o) ||
          (o === 0 && Object.is(0, o)) ||
          o === Number.POSITIVE_INFINITY ||
          o === Number.NEGATIVE_INFINITY
        ? 0
        : ((o = _e.util.IntegerPart(o)),
          (o = o % Math.pow(2, t)),
          r === "signed" && o >= Math.pow(2, t) - 1 ? o - Math.pow(2, t) : o)
  }
  _e.util.IntegerPart = function (e) {
    let t = Math.floor(Math.abs(e))
    return e < 0 ? -1 * t : t
  }
  _e.util.Stringify = function (e) {
    switch (_e.util.Type(e)) {
      case "Symbol":
        return `Symbol(${e.description})`
      case "Object":
        return U4e(e)
      case "String":
        return `"${e}"`
      default:
        return `${e}`
    }
  }
  _e.sequenceConverter = function (e) {
    return (t, r, n, i) => {
      if (_e.util.Type(t) !== "Object")
        throw _e.errors.exception({
          header: r,
          message: `${n} (${_e.util.Stringify(t)}) is not iterable.`,
        })
      let s = typeof i == "function" ? i() : t?.[Symbol.iterator]?.(),
        o = [],
        a = 0
      if (s === undefined || typeof s.next != "function")
        throw _e.errors.exception({
          header: r,
          message: `${n} is not iterable.`,
        })
      for (;;) {
        let { done: l, value: c } = s.next()
        if (l) break
        o.push(e(c, r, `${n}[${a++}]`))
      }
      return o
    }
  }
  _e.recordConverter = function (e, t) {
    return (r, n, i) => {
      if (_e.util.Type(r) !== "Object")
        throw _e.errors.exception({
          header: n,
          message: `${i} ("${_e.util.Type(r)}") is not an Object.`,
        })
      let s = {}
      if (!bu.isProxy(r)) {
        let a = [
          ...Object.getOwnPropertyNames(r),
          ...Object.getOwnPropertySymbols(r),
        ]
        for (let l of a) {
          let c = e(l, n, i),
            u = t(r[l], n, i)
          s[c] = u
        }
        return s
      }
      let o = Reflect.ownKeys(r)
      for (let a of o)
        if (Reflect.getOwnPropertyDescriptor(r, a)?.enumerable) {
          let c = e(a, n, i),
            u = t(r[a], n, i)
          s[c] = u
        }
      return s
    }
  }
  _e.interfaceConverter = function (e) {
    return (t, r, n, i) => {
      if (i?.strict !== false && !(t instanceof e))
        throw _e.errors.exception({
          header: r,
          message: `Expected ${n} ("${_e.util.Stringify(t)}") to be an instance of ${e.name}.`,
        })
      return t
    }
  }
  _e.dictionaryConverter = function (e) {
    return (t, r, n) => {
      let i = _e.util.Type(t),
        s = {}
      if (i === "Null" || i === "Undefined") return s
      if (i !== "Object")
        throw _e.errors.exception({
          header: r,
          message: `Expected ${t} to be one of: Null, Undefined, Object.`,
        })
      for (let o of e) {
        let { key: a, defaultValue: l, required: c, converter: u } = o
        if (c === true && !Object.hasOwn(t, a))
          throw _e.errors.exception({
            header: r,
            message: `Missing required key "${a}".`,
          })
        let f = t[a],
          p = Object.hasOwn(o, "defaultValue")
        if ((p && f !== null && (f ??= l()), c || p || f !== undefined)) {
          if (
            ((f = u(f, r, `${n}.${a}`)),
            o.allowedValues && !o.allowedValues.includes(f))
          )
            throw _e.errors.exception({
              header: r,
              message: `${f} is not an accepted type. Expected one of ${o.allowedValues.join(", ")}.`,
            })
          s[a] = f
        }
      }
      return s
    }
  }
  _e.nullableConverter = function (e) {
    return (t, r, n) => (t === null ? t : e(t, r, n))
  }
  _e.converters.DOMString = function (e, t, r, n) {
    if (e === null && n?.legacyNullToEmptyString) return ""
    if (typeof e == "symbol")
      throw _e.errors.exception({
        header: t,
        message: `${r} is a symbol, which cannot be converted to a DOMString.`,
      })
    return String(e)
  }
  _e.converters.ByteString = function (e, t, r) {
    let n = _e.converters.DOMString(e, t, r)
    for (let i = 0; i < n.length; i++)
      if (n.charCodeAt(i) > 255)
        throw new TypeError(
          `Cannot convert argument to a ByteString because the character at index ${i} has a value of ${n.charCodeAt(i)} which is greater than 255.`,
        )
    return n
  }
  _e.converters.USVString = q4e
  _e.converters.boolean = function (e) {
    return !!e
  }
  _e.converters.any = function (e) {
    return e
  }
  _e.converters["long long"] = function (e, t, r) {
    return _e.util.ConvertToInt(e, 64, "signed", undefined, t, r)
  }
  _e.converters["unsigned long long"] = function (e, t, r) {
    return _e.util.ConvertToInt(e, 64, "unsigned", undefined, t, r)
  }
  _e.converters["unsigned long"] = function (e, t, r) {
    return _e.util.ConvertToInt(e, 32, "unsigned", undefined, t, r)
  }
  _e.converters["unsigned short"] = function (e, t, r, n) {
    return _e.util.ConvertToInt(e, 16, "unsigned", n, t, r)
  }
  _e.converters.ArrayBuffer = function (e, t, r, n) {
    if (_e.util.Type(e) !== "Object" || !bu.isAnyArrayBuffer(e))
      throw _e.errors.conversionFailed({
        prefix: t,
        argument: `${r} ("${_e.util.Stringify(e)}")`,
        types: ["ArrayBuffer"],
      })
    if (n?.allowShared === false && bu.isSharedArrayBuffer(e))
      throw _e.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed.",
      })
    if (e.resizable || e.growable)
      throw _e.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer.",
      })
    return e
  }
  _e.converters.TypedArray = function (e, t, r, n, i) {
    if (
      _e.util.Type(e) !== "Object" ||
      !bu.isTypedArray(e) ||
      e.constructor.name !== t.name
    )
      throw _e.errors.conversionFailed({
        prefix: r,
        argument: `${n} ("${_e.util.Stringify(e)}")`,
        types: [t.name],
      })
    if (i?.allowShared === false && bu.isSharedArrayBuffer(e.buffer))
      throw _e.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed.",
      })
    if (e.buffer.resizable || e.buffer.growable)
      throw _e.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer.",
      })
    return e
  }
  _e.converters.DataView = function (e, t, r, n) {
    if (_e.util.Type(e) !== "Object" || !bu.isDataView(e))
      throw _e.errors.exception({
        header: t,
        message: `${r} is not a DataView.`,
      })
    if (n?.allowShared === false && bu.isSharedArrayBuffer(e.buffer))
      throw _e.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed.",
      })
    if (e.buffer.resizable || e.buffer.growable)
      throw _e.errors.exception({
        header: "ArrayBuffer",
        message: "Received a resizable ArrayBuffer.",
      })
    return e
  }
  _e.converters.BufferSource = function (e, t, r, n) {
    if (bu.isAnyArrayBuffer(e))
      return _e.converters.ArrayBuffer(e, t, r, { ...n, allowShared: false })
    if (bu.isTypedArray(e))
      return _e.converters.TypedArray(e, e.constructor, t, r, {
        ...n,
        allowShared: false,
      })
    if (bu.isDataView(e))
      return _e.converters.DataView(e, t, r, { ...n, allowShared: false })
    throw _e.errors.conversionFailed({
      prefix: t,
      argument: `${r} ("${_e.util.Stringify(e)}")`,
      types: ["BufferSource"],
    })
  }
  _e.converters["sequence<ByteString>"] = _e.sequenceConverter(
    _e.converters.ByteString,
  )
  _e.converters["sequence<sequence<ByteString>>"] = _e.sequenceConverter(
    _e.converters["sequence<ByteString>"],
  )
  _e.converters["record<ByteString, ByteString>"] = _e.recordConverter(
    _e.converters.ByteString,
    _e.converters.ByteString,
  )
  one.exports = { webidl: _e }
})
var Ba = _((bDt, Cne) => {
  "use strict"
  var { Transform: V4e } = require("stream"),
    ane = require("zlib"),
    { redirectStatusSet: H4e, referrerPolicySet: W4e, badPortsSet: G4e } = hE(),
    { getGlobalOrigin: lne } = Yq(),
    {
      collectASequenceOfCodePoints: Ep,
      collectAnHTTPQuotedString: $4e,
      removeChars: Y4e,
      parseMIMEType: K4e,
    } = zo(),
    { performance: z4e } = require("perf_hooks"),
    {
      isBlobLike: J4e,
      ReadableStreamFrom: j4e,
      isValidHTTPToken: cne,
      normalizedMethodRecordsBase: Z4e,
    } = ir(),
    _p = require("assert"),
    { isUint8Array: X4e } = require("util/types"),
    { webidl: pE } = Is(),
    une = [],
    xR
  try {
    xR = require("crypto")
    let e = ["sha256", "sha384", "sha512"]
    une = xR.getHashes().filter((t) => e.includes(t))
  } catch {}
  function dne(e) {
    let t = e.urlList,
      r = t.length
    return r === 0 ? null : t[r - 1].toString()
  }
  function e8e(e, t) {
    if (!H4e.has(e.status)) return null
    let r = e.headersList.get("location", true)
    return (
      r !== null &&
        hne(r) &&
        (fne(r) || (r = t8e(r)), (r = new URL(r, dne(e)))),
      r && !r.hash && (r.hash = t),
      r
    )
  }
  function fne(e) {
    for (let t = 0; t < e.length; ++t) {
      let r = e.charCodeAt(t)
      if (r > 126 || r < 32) return false
    }
    return true
  }
  function t8e(e) {
    return Buffer.from(e, "binary").toString("utf8")
  }
  function AE(e) {
    return e.urlList[e.urlList.length - 1]
  }
  function r8e(e) {
    let t = AE(e)
    return yne(t) && G4e.has(t.port) ? "blocked" : "allowed"
  }
  function n8e(e) {
    return (
      e instanceof Error ||
      e?.constructor?.name === "Error" ||
      e?.constructor?.name === "DOMException"
    )
  }
  function i8e(e) {
    for (let t = 0; t < e.length; ++t) {
      let r = e.charCodeAt(t)
      if (!(r === 9 || (r >= 32 && r <= 126) || (r >= 128 && r <= 255)))
        return false
    }
    return true
  }
  var s8e = cne
  function hne(e) {
    return (
      (e[0] === "	" ||
        e[0] === " " ||
        e[e.length - 1] === "	" ||
        e[e.length - 1] === " " ||
        e.includes(`
`) ||
        e.includes("\r") ||
        e.includes("\0")) === false
    )
  }
  function o8e(e, t) {
    let { headersList: r } = t,
      n = (r.get("referrer-policy", true) ?? "").split(","),
      i = ""
    if (n.length > 0)
      for (let s = n.length; s !== 0; s--) {
        let o = n[s - 1].trim()
        if (W4e.has(o)) {
          i = o
          break
        }
      }
    i !== "" && (e.referrerPolicy = i)
  }
  function a8e() {
    return "allowed"
  }
  function l8e() {
    return "success"
  }
  function c8e() {
    return "success"
  }
  function u8e(e) {
    let t = null
    ;(t = e.mode), e.headersList.set("sec-fetch-mode", t, true)
  }
  function d8e(e) {
    let t = e.origin
    if (!(t === "client" || t === undefined)) {
      if (e.responseTainting === "cors" || e.mode === "websocket")
        e.headersList.append("origin", t, true)
      else if (e.method !== "GET" && e.method !== "HEAD") {
        switch (e.referrerPolicy) {
          case "no-referrer":
            t = null
            break
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            e.origin && jq(e.origin) && !jq(AE(e)) && (t = null)
            break
          case "same-origin":
            wR(e, AE(e)) || (t = null)
            break
          default:
        }
        e.headersList.append("origin", t, true)
      }
    }
  }
  function T0(e, t) {
    return e
  }
  function f8e(e, t, r) {
    return !e?.startTime || e.startTime < t
      ? {
          domainLookupStartTime: t,
          domainLookupEndTime: t,
          connectionStartTime: t,
          connectionEndTime: t,
          secureConnectionStartTime: t,
          ALPNNegotiatedProtocol: e?.ALPNNegotiatedProtocol,
        }
      : {
          domainLookupStartTime: T0(e.domainLookupStartTime, r),
          domainLookupEndTime: T0(e.domainLookupEndTime, r),
          connectionStartTime: T0(e.connectionStartTime, r),
          connectionEndTime: T0(e.connectionEndTime, r),
          secureConnectionStartTime: T0(e.secureConnectionStartTime, r),
          ALPNNegotiatedProtocol: e.ALPNNegotiatedProtocol,
        }
  }
  function h8e(e) {
    return T0(z4e.now(), e)
  }
  function g8e(e) {
    return {
      startTime: e.startTime ?? 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: e.startTime ?? 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null,
    }
  }
  function gne() {
    return { referrerPolicy: "strict-origin-when-cross-origin" }
  }
  function p8e(e) {
    return { referrerPolicy: e.referrerPolicy }
  }
  function m8e(e) {
    let t = e.referrerPolicy
    _p(t)
    let r = null
    if (e.referrer === "client") {
      let a = lne()
      if (!a || a.origin === "null") return "no-referrer"
      r = new URL(a)
    } else e.referrer instanceof URL && (r = e.referrer)
    let n = Jq(r),
      i = Jq(r, true)
    n.toString().length > 4096 && (n = i)
    let s = wR(e, n),
      o = mE(n) && !mE(e.url)
    switch (t) {
      case "origin":
        return i ?? Jq(r, true)
      case "unsafe-url":
        return n
      case "same-origin":
        return s ? i : "no-referrer"
      case "origin-when-cross-origin":
        return s ? n : i
      case "strict-origin-when-cross-origin": {
        let a = AE(e)
        return wR(n, a) ? n : mE(n) && !mE(a) ? "no-referrer" : i
      }
      case "strict-origin":
      case "no-referrer-when-downgrade":
      default:
        return o ? "no-referrer" : i
    }
  }
  function Jq(e, t) {
    return (
      _p(e instanceof URL),
      (e = new URL(e)),
      e.protocol === "file:" ||
      e.protocol === "about:" ||
      e.protocol === "blank:"
        ? "no-referrer"
        : ((e.username = ""),
          (e.password = ""),
          (e.hash = ""),
          t && ((e.pathname = ""), (e.search = "")),
          e)
    )
  }
  function mE(e) {
    if (!(e instanceof URL)) return false
    if (
      e.href === "about:blank" ||
      e.href === "about:srcdoc" ||
      e.protocol === "data:" ||
      e.protocol === "file:"
    )
      return true
    return t(e.origin)
    function t(r) {
      if (r == null || r === "null") return false
      let n = new URL(r)
      return !!(
        n.protocol === "https:" ||
        n.protocol === "wss:" ||
        /^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(
          n.hostname,
        ) ||
        n.hostname === "localhost" ||
        n.hostname.includes("localhost.") ||
        n.hostname.endsWith(".localhost")
      )
    }
  }
  function A8e(e, t) {
    if (xR === undefined) return true
    let r = pne(t)
    if (r === "no metadata" || r.length === 0) return true
    let n = v8e(r),
      i = C8e(r, n)
    for (let s of i) {
      let o = s.algo,
        a = s.hash,
        l = xR.createHash(o).update(e).digest("base64")
      if (
        (l[l.length - 1] === "=" &&
          (l[l.length - 2] === "="
            ? (l = l.slice(0, -2))
            : (l = l.slice(0, -1))),
        b8e(l, a))
      )
        return true
    }
    return false
  }
  var y8e =
    /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i
  function pne(e) {
    let t = [],
      r = true
    for (let n of e.split(" ")) {
      r = false
      let i = y8e.exec(n)
      if (i === null || i.groups === undefined || i.groups.algo === undefined)
        continue
      let s = i.groups.algo.toLowerCase()
      une.includes(s) && t.push(i.groups)
    }
    return r === true ? "no metadata" : t
  }
  function v8e(e) {
    let t = e[0].algo
    if (t[3] === "5") return t
    for (let r = 1; r < e.length; ++r) {
      let n = e[r]
      if (n.algo[3] === "5") {
        t = "sha512"
        break
      } else {
        if (t[3] === "3") continue
        n.algo[3] === "3" && (t = "sha384")
      }
    }
    return t
  }
  function C8e(e, t) {
    if (e.length === 1) return e
    let r = 0
    for (let n = 0; n < e.length; ++n) e[n].algo === t && (e[r++] = e[n])
    return (e.length = r), e
  }
  function b8e(e, t) {
    if (e.length !== t.length) return false
    for (let r = 0; r < e.length; ++r)
      if (e[r] !== t[r]) {
        if ((e[r] === "+" && t[r] === "-") || (e[r] === "/" && t[r] === "_"))
          continue
        return false
      }
    return true
  }
  function E8e(e) {}
  function wR(e, t) {
    return (
      (e.origin === t.origin && e.origin === "null") ||
      (e.protocol === t.protocol &&
        e.hostname === t.hostname &&
        e.port === t.port)
    )
  }
  function _8e() {
    let e, t
    return {
      promise: new Promise((n, i) => {
        ;(e = n), (t = i)
      }),
      resolve: e,
      reject: t,
    }
  }
  function x8e(e) {
    return e.controller.state === "aborted"
  }
  function w8e(e) {
    return (
      e.controller.state === "aborted" || e.controller.state === "terminated"
    )
  }
  function S8e(e) {
    return Z4e[e.toLowerCase()] ?? e
  }
  function I8e(e) {
    let t = JSON.stringify(e)
    if (t === undefined) throw new TypeError("Value is not JSON serializable")
    return _p(typeof t == "string"), t
  }
  var B8e = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))
  function mne(e, t, r = 0, n = 1) {
    class i {
      #e
      #t
      #i
      constructor(o, a) {
        ;(this.#e = o), (this.#t = a), (this.#i = 0)
      }
      next() {
        if (typeof this != "object" || this === null || !(#e in this))
          throw new TypeError(
            `'next' called on an object that does not implement interface ${e} Iterator.`,
          )
        let o = this.#i,
          a = this.#e[t],
          l = a.length
        if (o >= l) return { value: undefined, done: true }
        let { [r]: c, [n]: u } = a[o]
        this.#i = o + 1
        let f
        switch (this.#t) {
          case "key":
            f = c
            break
          case "value":
            f = u
            break
          case "key+value":
            f = [c, u]
            break
        }
        return { value: f, done: false }
      }
    }
    return (
      delete i.prototype.constructor,
      Object.setPrototypeOf(i.prototype, B8e),
      Object.defineProperties(i.prototype, {
        [Symbol.toStringTag]: {
          writable: false,
          enumerable: false,
          configurable: true,
          value: `${e} Iterator`,
        },
        next: { writable: true, enumerable: true, configurable: true },
      }),
      function (s, o) {
        return new i(s, o)
      }
    )
  }
  function R8e(e, t, r, n = 0, i = 1) {
    let s = mne(e, r, n, i),
      o = {
        keys: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function () {
            return pE.brandCheck(this, t), s(this, "key")
          },
        },
        values: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function () {
            return pE.brandCheck(this, t), s(this, "value")
          },
        },
        entries: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function () {
            return pE.brandCheck(this, t), s(this, "key+value")
          },
        },
        forEach: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function (l, c = globalThis) {
            if (
              (pE.brandCheck(this, t),
              pE.argumentLengthCheck(arguments, 1, `${e}.forEach`),
              typeof l != "function")
            )
              throw new TypeError(
                `Failed to execute 'forEach' on '${e}': parameter 1 is not of type 'Function'.`,
              )
            for (let { 0: u, 1: f } of s(this, "key+value"))
              l.call(c, f, u, this)
          },
        },
      }
    return Object.defineProperties(t.prototype, {
      ...o,
      [Symbol.iterator]: {
        writable: true,
        enumerable: false,
        configurable: true,
        value: o.entries.value,
      },
    })
  }
  async function D8e(e, t, r) {
    let n = t,
      i = r,
      s
    try {
      s = e.stream.getReader()
    } catch (o) {
      i(o)
      return
    }
    try {
      n(await Ane(s))
    } catch (o) {
      i(o)
    }
  }
  function T8e(e) {
    return (
      e instanceof ReadableStream ||
      (e[Symbol.toStringTag] === "ReadableStream" && typeof e.tee == "function")
    )
  }
  function k8e(e) {
    try {
      e.close(), e.byobRequest?.respond(0)
    } catch (t) {
      if (
        !t.message.includes("Controller is already closed") &&
        !t.message.includes("ReadableStream is already closed")
      )
        throw t
    }
  }
  var M8e = /[^\x00-\xFF]/
  function _R(e) {
    return _p(!M8e.test(e)), e
  }
  async function Ane(e) {
    let t = [],
      r = 0
    for (;;) {
      let { done: n, value: i } = await e.read()
      if (n) return Buffer.concat(t, r)
      if (!X4e(i)) throw new TypeError("Received non-Uint8Array chunk")
      t.push(i), (r += i.length)
    }
  }
  function F8e(e) {
    _p("protocol" in e)
    let t = e.protocol
    return t === "about:" || t === "blob:" || t === "data:"
  }
  function jq(e) {
    return (
      (typeof e == "string" &&
        e[5] === ":" &&
        e[0] === "h" &&
        e[1] === "t" &&
        e[2] === "t" &&
        e[3] === "p" &&
        e[4] === "s") ||
      e.protocol === "https:"
    )
  }
  function yne(e) {
    _p("protocol" in e)
    let t = e.protocol
    return t === "http:" || t === "https:"
  }
  function Q8e(e, t) {
    let r = e
    if (!r.startsWith("bytes")) return "failure"
    let n = { position: 5 }
    if (
      (t && Ep((l) => l === "	" || l === " ", r, n),
      r.charCodeAt(n.position) !== 61)
    )
      return "failure"
    n.position++, t && Ep((l) => l === "	" || l === " ", r, n)
    let i = Ep(
        (l) => {
          let c = l.charCodeAt(0)
          return c >= 48 && c <= 57
        },
        r,
        n,
      ),
      s = i.length ? Number(i) : null
    if (
      (t && Ep((l) => l === "	" || l === " ", r, n),
      r.charCodeAt(n.position) !== 45)
    )
      return "failure"
    n.position++, t && Ep((l) => l === "	" || l === " ", r, n)
    let o = Ep(
        (l) => {
          let c = l.charCodeAt(0)
          return c >= 48 && c <= 57
        },
        r,
        n,
      ),
      a = o.length ? Number(o) : null
    return n.position < r.length || (a === null && s === null) || s > a
      ? "failure"
      : { rangeStartValue: s, rangeEndValue: a }
  }
  function N8e(e, t, r) {
    let n = "bytes "
    return (
      (n += _R(`${e}`)),
      (n += "-"),
      (n += _R(`${t}`)),
      (n += "/"),
      (n += _R(`${r}`)),
      n
    )
  }
  var Zq = class extends V4e {
    #e
    constructor(t) {
      super(), (this.#e = t)
    }
    _transform(t, r, n) {
      if (!this._inflateStream) {
        if (t.length === 0) {
          n()
          return
        }
        ;(this._inflateStream =
          (t[0] & 15) === 8
            ? ane.createInflate(this.#e)
            : ane.createInflateRaw(this.#e)),
          this._inflateStream.on("data", this.push.bind(this)),
          this._inflateStream.on("end", () => this.push(null)),
          this._inflateStream.on("error", (i) => this.destroy(i))
      }
      this._inflateStream.write(t, r, n)
    }
    _final(t) {
      this._inflateStream &&
        (this._inflateStream.end(), (this._inflateStream = null)),
        t()
    }
  }
  function P8e(e) {
    return new Zq(e)
  }
  function L8e(e) {
    let t = null,
      r = null,
      n = null,
      i = vne("content-type", e)
    if (i === null) return "failure"
    for (let s of i) {
      let o = K4e(s)
      o === "failure" ||
        o.essence === "*/*" ||
        ((n = o),
        n.essence !== r
          ? ((t = null),
            n.parameters.has("charset") && (t = n.parameters.get("charset")),
            (r = n.essence))
          : !n.parameters.has("charset") &&
            t !== null &&
            n.parameters.set("charset", t))
    }
    return n ?? "failure"
  }
  function U8e(e) {
    let t = e,
      r = { position: 0 },
      n = [],
      i = ""
    for (; r.position < t.length; ) {
      if (
        ((i += Ep((s) => s !== '"' && s !== ",", t, r)), r.position < t.length)
      )
        if (t.charCodeAt(r.position) === 34) {
          if (((i += $4e(t, r)), r.position < t.length)) continue
        } else _p(t.charCodeAt(r.position) === 44), r.position++
      ;(i = Y4e(i, true, true, (s) => s === 9 || s === 32)), n.push(i), (i = "")
    }
    return n
  }
  function vne(e, t) {
    let r = t.get(e, true)
    return r === null ? null : U8e(r)
  }
  var O8e = new TextDecoder()
  function q8e(e) {
    return e.length === 0
      ? ""
      : (e[0] === 239 && e[1] === 187 && e[2] === 191 && (e = e.subarray(3)),
        O8e.decode(e))
  }
  var Xq = class {
      get baseUrl() {
        return lne()
      }
      get origin() {
        return this.baseUrl?.origin
      }
      policyContainer = gne()
    },
    eV = class {
      settingsObject = new Xq()
    },
    V8e = new eV()
  Cne.exports = {
    isAborted: x8e,
    isCancelled: w8e,
    isValidEncodedURL: fne,
    createDeferredPromise: _8e,
    ReadableStreamFrom: j4e,
    tryUpgradeRequestToAPotentiallyTrustworthyURL: E8e,
    clampAndCoarsenConnectionTimingInfo: f8e,
    coarsenedSharedCurrentTime: h8e,
    determineRequestsReferrer: m8e,
    makePolicyContainer: gne,
    clonePolicyContainer: p8e,
    appendFetchMetadata: u8e,
    appendRequestOriginHeader: d8e,
    TAOCheck: c8e,
    corsCheck: l8e,
    crossOriginResourcePolicyCheck: a8e,
    createOpaqueTimingInfo: g8e,
    setRequestReferrerPolicyOnRedirect: o8e,
    isValidHTTPToken: cne,
    requestBadPort: r8e,
    requestCurrentURL: AE,
    responseURL: dne,
    responseLocationURL: e8e,
    isBlobLike: J4e,
    isURLPotentiallyTrustworthy: mE,
    isValidReasonPhrase: i8e,
    sameOrigin: wR,
    normalizeMethod: S8e,
    serializeJavascriptValueToJSONString: I8e,
    iteratorMixin: R8e,
    createIterator: mne,
    isValidHeaderName: s8e,
    isValidHeaderValue: hne,
    isErrorLike: n8e,
    fullyReadBody: D8e,
    bytesMatch: A8e,
    isReadableStreamLike: T8e,
    readableStreamClose: k8e,
    isomorphicEncode: _R,
    urlIsLocal: F8e,
    urlHasHttpsScheme: jq,
    urlIsHttpHttpsScheme: yne,
    readAllBytes: Ane,
    simpleRangeHeaderValue: Q8e,
    buildContentRange: N8e,
    parseMetadata: pne,
    createInflate: P8e,
    extractMimeType: L8e,
    getDecodeSplit: vne,
    utf8DecodeBytes: q8e,
    environmentSettingsObject: V8e,
  }
})
var uh = _((EDt, bne) => {
  "use strict"
  bne.exports = {
    kUrl: Symbol("url"),
    kHeaders: Symbol("headers"),
    kSignal: Symbol("signal"),
    kState: Symbol("state"),
    kDispatcher: Symbol("dispatcher"),
  }
})
var rV = _((_Dt, Ene) => {
  "use strict"
  var { Blob: H8e, File: W8e } = require("buffer"),
    { kState: Vd } = uh(),
    { webidl: Eu } = Is(),
    tV = class e {
      constructor(t, r, n = {}) {
        let i = r,
          s = n.type,
          o = n.lastModified ?? Date.now()
        this[Vd] = { blobLike: t, name: i, type: s, lastModified: o }
      }
      stream(...t) {
        return Eu.brandCheck(this, e), this[Vd].blobLike.stream(...t)
      }
      arrayBuffer(...t) {
        return Eu.brandCheck(this, e), this[Vd].blobLike.arrayBuffer(...t)
      }
      slice(...t) {
        return Eu.brandCheck(this, e), this[Vd].blobLike.slice(...t)
      }
      text(...t) {
        return Eu.brandCheck(this, e), this[Vd].blobLike.text(...t)
      }
      get size() {
        return Eu.brandCheck(this, e), this[Vd].blobLike.size
      }
      get type() {
        return Eu.brandCheck(this, e), this[Vd].blobLike.type
      }
      get name() {
        return Eu.brandCheck(this, e), this[Vd].name
      }
      get lastModified() {
        return Eu.brandCheck(this, e), this[Vd].lastModified
      }
      get [Symbol.toStringTag]() {
        return "File"
      }
    }
  Eu.converters.Blob = Eu.interfaceConverter(H8e)
  function G8e(e) {
    return (
      e instanceof W8e ||
      (e &&
        (typeof e.stream == "function" || typeof e.arrayBuffer == "function") &&
        e[Symbol.toStringTag] === "File")
    )
  }
  Ene.exports = { FileLike: tV, isFileLike: G8e }
})
var vE = _((xDt, Ine) => {
  "use strict"
  var { isBlobLike: SR, iteratorMixin: $8e } = Ba(),
    { kState: Ao } = uh(),
    { kEnumerableProperty: k0 } = ir(),
    { FileLike: _ne, isFileLike: Y8e } = rV(),
    { webidl: _n } = Is(),
    { File: Sne } = require("buffer"),
    xne = require("util"),
    wne = globalThis.File ?? Sne,
    yE = class e {
      constructor(t) {
        if ((_n.util.markAsUncloneable(this), t !== undefined))
          throw _n.errors.conversionFailed({
            prefix: "FormData constructor",
            argument: "Argument 1",
            types: ["undefined"],
          })
        this[Ao] = []
      }
      append(t, r, n = undefined) {
        _n.brandCheck(this, e)
        let i = "FormData.append"
        if (
          (_n.argumentLengthCheck(arguments, 2, i),
          arguments.length === 3 && !SR(r))
        )
          throw new TypeError(
            "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'",
          )
        ;(t = _n.converters.USVString(t, i, "name")),
          (r = SR(r)
            ? _n.converters.Blob(r, i, "value", { strict: false })
            : _n.converters.USVString(r, i, "value")),
          (n =
            arguments.length === 3
              ? _n.converters.USVString(n, i, "filename")
              : undefined)
        let s = nV(t, r, n)
        this[Ao].push(s)
      }
      delete(t) {
        _n.brandCheck(this, e)
        let r = "FormData.delete"
        _n.argumentLengthCheck(arguments, 1, r),
          (t = _n.converters.USVString(t, r, "name")),
          (this[Ao] = this[Ao].filter((n) => n.name !== t))
      }
      get(t) {
        _n.brandCheck(this, e)
        let r = "FormData.get"
        _n.argumentLengthCheck(arguments, 1, r),
          (t = _n.converters.USVString(t, r, "name"))
        let n = this[Ao].findIndex((i) => i.name === t)
        return n === -1 ? null : this[Ao][n].value
      }
      getAll(t) {
        _n.brandCheck(this, e)
        let r = "FormData.getAll"
        return (
          _n.argumentLengthCheck(arguments, 1, r),
          (t = _n.converters.USVString(t, r, "name")),
          this[Ao].filter((n) => n.name === t).map((n) => n.value)
        )
      }
      has(t) {
        _n.brandCheck(this, e)
        let r = "FormData.has"
        return (
          _n.argumentLengthCheck(arguments, 1, r),
          (t = _n.converters.USVString(t, r, "name")),
          this[Ao].findIndex((n) => n.name === t) !== -1
        )
      }
      set(t, r, n = undefined) {
        _n.brandCheck(this, e)
        let i = "FormData.set"
        if (
          (_n.argumentLengthCheck(arguments, 2, i),
          arguments.length === 3 && !SR(r))
        )
          throw new TypeError(
            "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'",
          )
        ;(t = _n.converters.USVString(t, i, "name")),
          (r = SR(r)
            ? _n.converters.Blob(r, i, "name", { strict: false })
            : _n.converters.USVString(r, i, "name")),
          (n =
            arguments.length === 3
              ? _n.converters.USVString(n, i, "name")
              : undefined)
        let s = nV(t, r, n),
          o = this[Ao].findIndex((a) => a.name === t)
        o !== -1
          ? (this[Ao] = [
              ...this[Ao].slice(0, o),
              s,
              ...this[Ao].slice(o + 1).filter((a) => a.name !== t),
            ])
          : this[Ao].push(s)
      }
      [xne.inspect.custom](t, r) {
        let n = this[Ao].reduce(
          (s, o) => (
            s[o.name]
              ? Array.isArray(s[o.name])
                ? s[o.name].push(o.value)
                : (s[o.name] = [s[o.name], o.value])
              : (s[o.name] = o.value),
            s
          ),
          { __proto__: null },
        )
        ;(r.depth ??= t), (r.colors ??= true)
        let i = xne.formatWithOptions(r, n)
        return `FormData ${i.slice(i.indexOf("]") + 2)}`
      }
    }
  $8e("FormData", yE, Ao, "name", "value")
  Object.defineProperties(yE.prototype, {
    append: k0,
    delete: k0,
    get: k0,
    getAll: k0,
    has: k0,
    set: k0,
    [Symbol.toStringTag]: { value: "FormData", configurable: true },
  })
  function nV(e, t, r) {
    if (typeof t != "string") {
      if (
        (Y8e(t) ||
          (t =
            t instanceof Blob
              ? new wne([t], "blob", { type: t.type })
              : new _ne(t, "blob", { type: t.type })),
        r !== undefined)
      ) {
        let n = { type: t.type, lastModified: t.lastModified }
        t = t instanceof Sne ? new wne([t], r, n) : new _ne(t, r, n)
      }
    }
    return { name: e, value: t }
  }
  Ine.exports = { FormData: yE, makeEntry: nV }
})
var Mne = _((wDt, kne) => {
  "use strict"
  var { isUSVString: Bne, bufferToLowerCasedHeaderName: K8e } = ir(),
    { utf8DecodeBytes: z8e } = Ba(),
    { HTTP_TOKEN_CODEPOINTS: J8e, isomorphicDecode: Rne } = zo(),
    { isFileLike: j8e } = rV(),
    { makeEntry: Z8e } = vE(),
    IR = require("assert"),
    { File: X8e } = require("buffer"),
    e6e = globalThis.File ?? X8e,
    t6e = Buffer.from('form-data; name="'),
    Dne = Buffer.from("; filename"),
    r6e = Buffer.from("--"),
    n6e = Buffer.from(`--\r
`)
  function i6e(e) {
    for (let t = 0; t < e.length; ++t) if (e.charCodeAt(t) & -128) return false
    return true
  }
  function s6e(e) {
    let t = e.length
    if (t < 27 || t > 70) return false
    for (let r = 0; r < t; ++r) {
      let n = e.charCodeAt(r)
      if (
        !(
          (n >= 48 && n <= 57) ||
          (n >= 65 && n <= 90) ||
          (n >= 97 && n <= 122) ||
          n === 39 ||
          n === 45 ||
          n === 95
        )
      )
        return false
    }
    return true
  }
  function o6e(e, t) {
    IR(t !== "failure" && t.essence === "multipart/form-data")
    let r = t.parameters.get("boundary")
    if (r === undefined) return "failure"
    let n = Buffer.from(`--${r}`, "utf8"),
      i = [],
      s = { position: 0 }
    for (; e[s.position] === 13 && e[s.position + 1] === 10; ) s.position += 2
    let o = e.length
    for (; e[o - 1] === 10 && e[o - 2] === 13; ) o -= 2
    for (o !== e.length && (e = e.subarray(0, o)); ; ) {
      if (e.subarray(s.position, s.position + n.length).equals(n))
        s.position += n.length
      else return "failure"
      if (
        (s.position === e.length - 2 && BR(e, r6e, s)) ||
        (s.position === e.length - 4 && BR(e, n6e, s))
      )
        return i
      if (e[s.position] !== 13 || e[s.position + 1] !== 10) return "failure"
      s.position += 2
      let a = a6e(e, s)
      if (a === "failure") return "failure"
      let { name: l, filename: c, contentType: u, encoding: f } = a
      s.position += 2
      let p
      {
        let m = e.indexOf(n.subarray(2), s.position)
        if (m === -1) return "failure"
        ;(p = e.subarray(s.position, m - 4)),
          (s.position += p.length),
          f === "base64" && (p = Buffer.from(p.toString(), "base64"))
      }
      if (e[s.position] !== 13 || e[s.position + 1] !== 10) return "failure"
      s.position += 2
      let g
      c !== null
        ? ((u ??= "text/plain"),
          i6e(u) || (u = ""),
          (g = new e6e([p], c, { type: u })))
        : (g = z8e(Buffer.from(p))),
        IR(Bne(l)),
        IR((typeof g == "string" && Bne(g)) || j8e(g)),
        i.push(Z8e(l, g, c))
    }
  }
  function a6e(e, t) {
    let r = null,
      n = null,
      i = null,
      s = null
    for (;;) {
      if (e[t.position] === 13 && e[t.position + 1] === 10)
        return r === null
          ? "failure"
          : { name: r, filename: n, contentType: i, encoding: s }
      let o = M0((a) => a !== 10 && a !== 13 && a !== 58, e, t)
      if (
        ((o = iV(o, true, true, (a) => a === 9 || a === 32)),
        !J8e.test(o.toString()) || e[t.position] !== 58)
      )
        return "failure"
      switch ((t.position++, M0((a) => a === 32 || a === 9, e, t), K8e(o))) {
        case "content-disposition": {
          if (
            ((r = n = null),
            !BR(e, t6e, t) || ((t.position += 17), (r = Tne(e, t)), r === null))
          )
            return "failure"
          if (BR(e, Dne, t)) {
            let a = t.position + Dne.length
            if (
              (e[a] === 42 && ((t.position += 1), (a += 1)),
              e[a] !== 61 ||
                e[a + 1] !== 34 ||
                ((t.position += 12), (n = Tne(e, t)), n === null))
            )
              return "failure"
          }
          break
        }
        case "content-type": {
          let a = M0((l) => l !== 10 && l !== 13, e, t)
          ;(a = iV(a, false, true, (l) => l === 9 || l === 32)), (i = Rne(a))
          break
        }
        case "content-transfer-encoding": {
          let a = M0((l) => l !== 10 && l !== 13, e, t)
          ;(a = iV(a, false, true, (l) => l === 9 || l === 32)), (s = Rne(a))
          break
        }
        default:
          M0((a) => a !== 10 && a !== 13, e, t)
      }
      if (e[t.position] !== 13 && e[t.position + 1] !== 10) return "failure"
      t.position += 2
    }
  }
  function Tne(e, t) {
    IR(e[t.position - 1] === 34)
    let r = M0((n) => n !== 10 && n !== 13 && n !== 34, e, t)
    return e[t.position] !== 34
      ? null
      : (t.position++,
        (r = new TextDecoder()
          .decode(r)
          .replace(
            /%0A/gi,
            `
`,
          )
          .replace(/%0D/gi, "\r")
          .replace(/%22/g, '"')),
        r)
  }
  function M0(e, t, r) {
    let n = r.position
    for (; n < t.length && e(t[n]); ) ++n
    return t.subarray(r.position, (r.position = n))
  }
  function iV(e, t, r, n) {
    let i = 0,
      s = e.length - 1
    if (t) for (; i < e.length && n(e[i]); ) i++
    if (r) for (; s > 0 && n(e[s]); ) s--
    return i === 0 && s === e.length - 1 ? e : e.subarray(i, s + 1)
  }
  function BR(e, t, r) {
    if (e.length < t.length) return false
    for (let n = 0; n < t.length; n++) if (t[n] !== e[r.position + n]) return false
    return true
  }
  kne.exports = { multipartFormDataParser: o6e, validateBoundary: s6e }
})
var N0 = _((SDt, qne) => {
  "use strict"
  var CE = ir(),
    {
      ReadableStreamFrom: l6e,
      isBlobLike: Fne,
      isReadableStreamLike: c6e,
      readableStreamClose: u6e,
      createDeferredPromise: d6e,
      fullyReadBody: f6e,
      extractMimeType: h6e,
      utf8DecodeBytes: Pne,
    } = Ba(),
    { FormData: Qne } = vE(),
    { kState: Q0 } = uh(),
    { webidl: g6e } = Is(),
    { Blob: p6e } = require("buffer"),
    sV = require("assert"),
    { isErrored: Lne, isDisturbed: m6e } = require("stream"),
    { isArrayBuffer: A6e } = require("util/types"),
    { serializeAMimeType: y6e } = zo(),
    { multipartFormDataParser: v6e } = Mne(),
    oV
  try {
    let e = require("crypto")
    oV = (t) => e.randomInt(0, t)
  } catch {
    oV = (e) => Math.floor(Math.random(e))
  }
  var RR = new TextEncoder()
  function C6e() {}
  var aV =
      globalThis.FinalizationRegistry && process.version.indexOf("v18") !== 0,
    lV
  aV &&
    (lV = new FinalizationRegistry((e) => {
      let t = e.deref()
      t &&
        !t.locked &&
        !m6e(t) &&
        !Lne(t) &&
        t.cancel("Response object has been garbage collected").catch(C6e)
    }))
  function Une(e, t = false) {
    let r = null
    e instanceof ReadableStream
      ? (r = e)
      : Fne(e)
        ? (r = e.stream())
        : (r = new ReadableStream({
            async pull(l) {
              let c = typeof i == "string" ? RR.encode(i) : i
              c.byteLength && l.enqueue(c), queueMicrotask(() => u6e(l))
            },
            start() {},
            type: "bytes",
          })),
      sV(c6e(r))
    let n = null,
      i = null,
      s = null,
      o = null
    if (typeof e == "string") (i = e), (o = "text/plain;charset=UTF-8")
    else if (e instanceof URLSearchParams)
      (i = e.toString()),
        (o = "application/x-www-form-urlencoded;charset=UTF-8")
    else if (A6e(e)) i = new Uint8Array(e.slice())
    else if (ArrayBuffer.isView(e))
      i = new Uint8Array(
        e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength),
      )
    else if (CE.isFormDataLike(e)) {
      let l = `----formdata-undici-0${`${oV(1e11)}`.padStart(11, "0")}`,
        c = `--${l}\r
Content-Disposition: form-data`
      let u = (v) =>
          v.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"),
        f = (v) =>
          v.replace(
            /\r?\n|\r/g,
            `\r
`,
          ),
        p = [],
        g = new Uint8Array([13, 10])
      s = 0
      let m = false
      for (let [v, C] of e)
        if (typeof C == "string") {
          let E = RR.encode(
            c +
              `; name="${u(f(v))}"\r
\r
${f(C)}\r
`,
          )
          p.push(E), (s += E.byteLength)
        } else {
          let E = RR.encode(
            `${c}; name="${u(f(v))}"` +
              (C.name ? `; filename="${u(C.name)}"` : "") +
              `\r
Content-Type: ${C.type || "application/octet-stream"}\r
\r
`,
          )
          p.push(E, C, g),
            typeof C.size == "number"
              ? (s += E.byteLength + C.size + g.byteLength)
              : (m = true)
        }
      let y = RR.encode(`--${l}--`)
      p.push(y),
        (s += y.byteLength),
        m && (s = null),
        (i = e),
        (n = async function* () {
          for (let v of p) v.stream ? yield* v.stream() : yield v
        }),
        (o = `multipart/form-data; boundary=${l}`)
    } else if (Fne(e)) (i = e), (s = e.size), e.type && (o = e.type)
    else if (typeof e[Symbol.asyncIterator] == "function") {
      if (t) throw new TypeError("keepalive")
      if (CE.isDisturbed(e) || e.locked)
        throw new TypeError(
          "Response body object should not be disturbed or locked",
        )
      r = e instanceof ReadableStream ? e : l6e(e)
    }
    if (
      ((typeof i == "string" || CE.isBuffer(i)) && (s = Buffer.byteLength(i)),
      n != null)
    ) {
      let l
      r = new ReadableStream({
        async start() {
          l = n(e)[Symbol.asyncIterator]()
        },
        async pull(c) {
          let { value: u, done: f } = await l.next()
          if (f)
            queueMicrotask(() => {
              c.close(), c.byobRequest?.respond(0)
            })
          else if (!Lne(r)) {
            let p = new Uint8Array(u)
            p.byteLength && c.enqueue(p)
          }
          return c.desiredSize > 0
        },
        async cancel(c) {
          await l.return()
        },
        type: "bytes",
      })
    }
    return [{ stream: r, source: i, length: s }, o]
  }
  function b6e(e, t = false) {
    return (
      e instanceof ReadableStream &&
        (sV(!CE.isDisturbed(e), "The body has already been consumed."),
        sV(!e.locked, "The stream is locked.")),
      Une(e, t)
    )
  }
  function E6e(e, t) {
    let [r, n] = t.stream.tee()
    return (
      aV && lV.register(e, new WeakRef(r)),
      (t.stream = r),
      { stream: n, length: t.length, source: t.source }
    )
  }
  function _6e(e) {
    if (e.aborted)
      throw new DOMException("The operation was aborted.", "AbortError")
  }
  function x6e(e) {
    return {
      blob() {
        return F0(
          this,
          (r) => {
            let n = Nne(this)
            return (
              n === null ? (n = "") : n && (n = y6e(n)),
              new p6e([r], { type: n })
            )
          },
          e,
        )
      },
      arrayBuffer() {
        return F0(this, (r) => new Uint8Array(r).buffer, e)
      },
      text() {
        return F0(this, Pne, e)
      },
      json() {
        return F0(this, S6e, e)
      },
      formData() {
        return F0(
          this,
          (r) => {
            let n = Nne(this)
            if (n !== null)
              switch (n.essence) {
                case "multipart/form-data": {
                  let i = v6e(r, n)
                  if (i === "failure")
                    throw new TypeError("Failed to parse body as FormData.")
                  let s = new Qne()
                  return (s[Q0] = i), s
                }
                case "application/x-www-form-urlencoded": {
                  let i = new URLSearchParams(r.toString()),
                    s = new Qne()
                  for (let [o, a] of i) s.append(o, a)
                  return s
                }
              }
            throw new TypeError(
              'Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".',
            )
          },
          e,
        )
      },
      bytes() {
        return F0(this, (r) => new Uint8Array(r), e)
      },
    }
  }
  function w6e(e) {
    Object.assign(e.prototype, x6e(e))
  }
  async function F0(e, t, r) {
    if ((g6e.brandCheck(e, r), One(e)))
      throw new TypeError("Body is unusable: Body has already been read")
    _6e(e[Q0])
    let n = d6e(),
      i = (o) => n.reject(o),
      s = (o) => {
        try {
          n.resolve(t(o))
        } catch (a) {
          i(a)
        }
      }
    return e[Q0].body == null
      ? (s(Buffer.allocUnsafe(0)), n.promise)
      : (await f6e(e[Q0].body, s, i), n.promise)
  }
  function One(e) {
    let t = e[Q0].body
    return t != null && (t.stream.locked || CE.isDisturbed(t.stream))
  }
  function S6e(e) {
    return JSON.parse(Pne(e))
  }
  function Nne(e) {
    let t = e[Q0].headersList,
      r = h6e(t)
    return r === "failure" ? null : r
  }
  qne.exports = {
    extractBody: Une,
    safelyExtractBody: b6e,
    cloneBody: E6e,
    mixinBody: w6e,
    streamRegistry: lV,
    hasFinalizationRegistry: aV,
    bodyUnusable: One,
  }
})
var Zne = _((IDt, jne) => {
  "use strict"
  var ht = require("assert"),
    Bt = ir(),
    { channels: Vne } = _0(),
    cV = Vq(),
    {
      RequestContentLengthMismatchError: xp,
      ResponseContentLengthMismatchError: I6e,
      RequestAbortedError: Kne,
      HeadersTimeoutError: B6e,
      HeadersOverflowError: R6e,
      SocketError: QR,
      InformationalError: P0,
      BodyTimeoutError: D6e,
      HTTPParserError: T6e,
      ResponseExceededMaxSizeError: k6e,
    } = Jr(),
    {
      kUrl: zne,
      kReset: Jo,
      kClient: hV,
      kParser: li,
      kBlocking: _E,
      kRunning: zs,
      kPending: M6e,
      kSize: Hne,
      kWriting: fh,
      kQueue: Ec,
      kNoRef: bE,
      kKeepAliveDefaultTimeout: F6e,
      kHostHeader: Q6e,
      kPendingIdx: N6e,
      kRunningIdx: xl,
      kError: wl,
      kPipelining: MR,
      kSocket: L0,
      kKeepAliveTimeoutValue: NR,
      kMaxHeadersSize: uV,
      kKeepAliveMaxTimeout: P6e,
      kKeepAliveTimeoutThreshold: L6e,
      kHeadersTimeout: U6e,
      kBodyTimeout: O6e,
      kStrictContentLength: gV,
      kMaxRequests: Wne,
      kCounter: q6e,
      kMaxResponseSize: V6e,
      kOnError: H6e,
      kResume: dh,
      kHTTPContext: Jne,
    } = Wn(),
    _u = Ore(),
    W6e = Buffer.alloc(0),
    DR = Buffer[Symbol.species],
    TR = Bt.addListener,
    G6e = Bt.removeAllListeners,
    dV
  async function $6e() {
    let e = process.env.JEST_WORKER_ID ? Gq() : undefined,
      t
    try {
      t = await WebAssembly.compile(Hre())
    } catch {
      t = await WebAssembly.compile(e || Gq())
    }
    return await WebAssembly.instantiate(t, {
      env: {
        wasm_on_url: (r, n, i) => 0,
        wasm_on_status: (r, n, i) => {
          ht(Yi.ptr === r)
          let s = n - wu + xu.byteOffset
          return Yi.onStatus(new DR(xu.buffer, s, i)) || 0
        },
        wasm_on_message_begin: (r) => (
          ht(Yi.ptr === r), Yi.onMessageBegin() || 0
        ),
        wasm_on_header_field: (r, n, i) => {
          ht(Yi.ptr === r)
          let s = n - wu + xu.byteOffset
          return Yi.onHeaderField(new DR(xu.buffer, s, i)) || 0
        },
        wasm_on_header_value: (r, n, i) => {
          ht(Yi.ptr === r)
          let s = n - wu + xu.byteOffset
          return Yi.onHeaderValue(new DR(xu.buffer, s, i)) || 0
        },
        wasm_on_headers_complete: (r, n, i, s) => (
          ht(Yi.ptr === r), Yi.onHeadersComplete(n, !!i, !!s) || 0
        ),
        wasm_on_body: (r, n, i) => {
          ht(Yi.ptr === r)
          let s = n - wu + xu.byteOffset
          return Yi.onBody(new DR(xu.buffer, s, i)) || 0
        },
        wasm_on_message_complete: (r) => (
          ht(Yi.ptr === r), Yi.onMessageComplete() || 0
        ),
      },
    })
  }
  var fV = null,
    pV = $6e()
  pV.catch()
  var Yi = null,
    xu = null,
    kR = 0,
    wu = null,
    Y6e = 0,
    EE = 1,
    U0 = 2 | EE,
    FR = 4 | EE,
    mV = 8 | Y6e,
    AV = class {
      constructor(t, r, { exports: n }) {
        ht(Number.isFinite(t[uV]) && t[uV] > 0),
          (this.llhttp = n),
          (this.ptr = this.llhttp.llhttp_alloc(_u.TYPE.RESPONSE)),
          (this.client = t),
          (this.socket = r),
          (this.timeout = null),
          (this.timeoutValue = null),
          (this.timeoutType = null),
          (this.statusCode = null),
          (this.statusText = ""),
          (this.upgrade = false),
          (this.headers = []),
          (this.headersSize = 0),
          (this.headersMaxSize = t[uV]),
          (this.shouldKeepAlive = false),
          (this.paused = false),
          (this.resume = this.resume.bind(this)),
          (this.bytesRead = 0),
          (this.keepAlive = ""),
          (this.contentLength = ""),
          (this.connection = ""),
          (this.maxResponseSize = t[V6e])
      }
      setTimeout(t, r) {
        t !== this.timeoutValue || (r & EE) ^ (this.timeoutType & EE)
          ? (this.timeout &&
              (cV.clearTimeout(this.timeout), (this.timeout = null)),
            t &&
              (r & EE
                ? (this.timeout = cV.setFastTimeout(Gne, t, new WeakRef(this)))
                : ((this.timeout = setTimeout(Gne, t, new WeakRef(this))),
                  this.timeout.unref())),
            (this.timeoutValue = t))
          : this.timeout && this.timeout.refresh && this.timeout.refresh(),
          (this.timeoutType = r)
      }
      resume() {
        this.socket.destroyed ||
          !this.paused ||
          (ht(this.ptr != null),
          ht(Yi == null),
          this.llhttp.llhttp_resume(this.ptr),
          ht(this.timeoutType === FR),
          this.timeout && this.timeout.refresh && this.timeout.refresh(),
          (this.paused = false),
          this.execute(this.socket.read() || W6e),
          this.readMore())
      }
      readMore() {
        for (; !this.paused && this.ptr; ) {
          let t = this.socket.read()
          if (t === null) break
          this.execute(t)
        }
      }
      execute(t) {
        ht(this.ptr != null), ht(Yi == null), ht(!this.paused)
        let { socket: r, llhttp: n } = this
        t.length > kR &&
          (wu && n.free(wu),
          (kR = Math.ceil(t.length / 4096) * 4096),
          (wu = n.malloc(kR))),
          new Uint8Array(n.memory.buffer, wu, kR).set(t)
        try {
          let i
          try {
            ;(xu = t),
              (Yi = this),
              (i = n.llhttp_execute(this.ptr, wu, t.length))
          } catch (o) {
            throw o
          } finally {
            ;(Yi = null), (xu = null)
          }
          let s = n.llhttp_get_error_pos(this.ptr) - wu
          if (i === _u.ERROR.PAUSED_UPGRADE) this.onUpgrade(t.slice(s))
          else if (i === _u.ERROR.PAUSED)
            (this.paused = true), r.unshift(t.slice(s))
          else if (i !== _u.ERROR.OK) {
            let o = n.llhttp_get_error_reason(this.ptr),
              a = ""
            if (o) {
              let l = new Uint8Array(n.memory.buffer, o).indexOf(0)
              a =
                "Response does not match the HTTP/1.1 protocol (" +
                Buffer.from(n.memory.buffer, o, l).toString() +
                ")"
            }
            throw new T6e(a, _u.ERROR[i], t.slice(s))
          }
        } catch (i) {
          Bt.destroy(r, i)
        }
      }
      destroy() {
        ht(this.ptr != null),
          ht(Yi == null),
          this.llhttp.llhttp_free(this.ptr),
          (this.ptr = null),
          this.timeout && cV.clearTimeout(this.timeout),
          (this.timeout = null),
          (this.timeoutValue = null),
          (this.timeoutType = null),
          (this.paused = false)
      }
      onStatus(t) {
        this.statusText = t.toString()
      }
      onMessageBegin() {
        let { socket: t, client: r } = this
        if (t.destroyed) return -1
        let n = r[Ec][r[xl]]
        if (!n) return -1
        n.onResponseStarted()
      }
      onHeaderField(t) {
        let r = this.headers.length
        r & 1
          ? (this.headers[r - 1] = Buffer.concat([this.headers[r - 1], t]))
          : this.headers.push(t),
          this.trackHeader(t.length)
      }
      onHeaderValue(t) {
        let r = this.headers.length
        ;(r & 1) === 1
          ? (this.headers.push(t), (r += 1))
          : (this.headers[r - 1] = Buffer.concat([this.headers[r - 1], t]))
        let n = this.headers[r - 2]
        if (n.length === 10) {
          let i = Bt.bufferToLowerCasedHeaderName(n)
          i === "keep-alive"
            ? (this.keepAlive += t.toString())
            : i === "connection" && (this.connection += t.toString())
        } else
          n.length === 14 &&
            Bt.bufferToLowerCasedHeaderName(n) === "content-length" &&
            (this.contentLength += t.toString())
        this.trackHeader(t.length)
      }
      trackHeader(t) {
        ;(this.headersSize += t),
          this.headersSize >= this.headersMaxSize &&
            Bt.destroy(this.socket, new R6e())
      }
      onUpgrade(t) {
        let {
          upgrade: r,
          client: n,
          socket: i,
          headers: s,
          statusCode: o,
        } = this
        ht(r),
          ht(n[L0] === i),
          ht(!i.destroyed),
          ht(!this.paused),
          ht((s.length & 1) === 0)
        let a = n[Ec][n[xl]]
        ht(a),
          ht(a.upgrade || a.method === "CONNECT"),
          (this.statusCode = null),
          (this.statusText = ""),
          (this.shouldKeepAlive = null),
          (this.headers = []),
          (this.headersSize = 0),
          i.unshift(t),
          i[li].destroy(),
          (i[li] = null),
          (i[hV] = null),
          (i[wl] = null),
          G6e(i),
          (n[L0] = null),
          (n[Jne] = null),
          (n[Ec][n[xl]++] = null),
          n.emit("disconnect", n[zne], [n], new P0("upgrade"))
        try {
          a.onUpgrade(o, s, i)
        } catch (l) {
          Bt.destroy(i, l)
        }
        n[dh]()
      }
      onHeadersComplete(t, r, n) {
        let { client: i, socket: s, headers: o, statusText: a } = this
        if (s.destroyed) return -1
        let l = i[Ec][i[xl]]
        if (!l) return -1
        if ((ht(!this.upgrade), ht(this.statusCode < 200), t === 100))
          return Bt.destroy(s, new QR("bad response", Bt.getSocketInfo(s))), -1
        if (r && !l.upgrade)
          return Bt.destroy(s, new QR("bad upgrade", Bt.getSocketInfo(s))), -1
        if (
          (ht(this.timeoutType === U0),
          (this.statusCode = t),
          (this.shouldKeepAlive =
            n ||
            (l.method === "HEAD" &&
              !s[Jo] &&
              this.connection.toLowerCase() === "keep-alive")),
          this.statusCode >= 200)
        ) {
          let u = l.bodyTimeout != null ? l.bodyTimeout : i[O6e]
          this.setTimeout(u, FR)
        } else this.timeout && this.timeout.refresh && this.timeout.refresh()
        if (l.method === "CONNECT")
          return ht(i[zs] === 1), (this.upgrade = true), 2
        if (r) return ht(i[zs] === 1), (this.upgrade = true), 2
        if (
          (ht((this.headers.length & 1) === 0),
          (this.headers = []),
          (this.headersSize = 0),
          this.shouldKeepAlive && i[MR])
        ) {
          let u = this.keepAlive
            ? Bt.parseKeepAliveTimeout(this.keepAlive)
            : null
          if (u != null) {
            let f = Math.min(u - i[L6e], i[P6e])
            f <= 0 ? (s[Jo] = true) : (i[NR] = f)
          } else i[NR] = i[F6e]
        } else s[Jo] = true
        let c = l.onHeaders(t, o, this.resume, a) === false
        return l.aborted
          ? -1
          : l.method === "HEAD" || t < 200
            ? 1
            : (s[_E] && ((s[_E] = false), i[dh]()), c ? _u.ERROR.PAUSED : 0)
      }
      onBody(t) {
        let { client: r, socket: n, statusCode: i, maxResponseSize: s } = this
        if (n.destroyed) return -1
        let o = r[Ec][r[xl]]
        if (
          (ht(o),
          ht(this.timeoutType === FR),
          this.timeout && this.timeout.refresh && this.timeout.refresh(),
          ht(i >= 200),
          s > -1 && this.bytesRead + t.length > s)
        )
          return Bt.destroy(n, new k6e()), -1
        if (((this.bytesRead += t.length), o.onData(t) === false))
          return _u.ERROR.PAUSED
      }
      onMessageComplete() {
        let {
          client: t,
          socket: r,
          statusCode: n,
          upgrade: i,
          headers: s,
          contentLength: o,
          bytesRead: a,
          shouldKeepAlive: l,
        } = this
        if (r.destroyed && (!n || l)) return -1
        if (i) return
        ht(n >= 100), ht((this.headers.length & 1) === 0)
        let c = t[Ec][t[xl]]
        if (
          (ht(c),
          (this.statusCode = null),
          (this.statusText = ""),
          (this.bytesRead = 0),
          (this.contentLength = ""),
          (this.keepAlive = ""),
          (this.connection = ""),
          (this.headers = []),
          (this.headersSize = 0),
          !(n < 200))
        ) {
          if (c.method !== "HEAD" && o && a !== parseInt(o, 10))
            return Bt.destroy(r, new I6e()), -1
          if ((c.onComplete(s), (t[Ec][t[xl]++] = null), r[fh]))
            return (
              ht(t[zs] === 0), Bt.destroy(r, new P0("reset")), _u.ERROR.PAUSED
            )
          if (l) {
            if (r[Jo] && t[zs] === 0)
              return Bt.destroy(r, new P0("reset")), _u.ERROR.PAUSED
            t[MR] == null || t[MR] === 1 ? setImmediate(() => t[dh]()) : t[dh]()
          } else return Bt.destroy(r, new P0("reset")), _u.ERROR.PAUSED
        }
      }
    }
  function Gne(e) {
    let { socket: t, timeoutType: r, client: n, paused: i } = e.deref()
    r === U0
      ? (!t[fh] || t.writableNeedDrain || n[zs] > 1) &&
        (ht(!i, "cannot be paused while waiting for headers"),
        Bt.destroy(t, new B6e()))
      : r === FR
        ? i || Bt.destroy(t, new D6e())
        : r === mV &&
          (ht(n[zs] === 0 && n[NR]),
          Bt.destroy(t, new P0("socket idle timeout")))
  }
  async function K6e(e, t) {
    ;(e[L0] = t),
      fV || ((fV = await pV), (pV = null)),
      (t[bE] = false),
      (t[fh] = false),
      (t[Jo] = false),
      (t[_E] = false),
      (t[li] = new AV(e, t, fV)),
      TR(t, "error", function (n) {
        ht(n.code !== "ERR_TLS_CERT_ALTNAME_INVALID")
        let i = this[li]
        if (n.code === "ECONNRESET" && i.statusCode && !i.shouldKeepAlive) {
          i.onMessageComplete()
          return
        }
        ;(this[wl] = n), this[hV][H6e](n)
      }),
      TR(t, "readable", function () {
        let n = this[li]
        n && n.readMore()
      }),
      TR(t, "end", function () {
        let n = this[li]
        if (n.statusCode && !n.shouldKeepAlive) {
          n.onMessageComplete()
          return
        }
        Bt.destroy(this, new QR("other side closed", Bt.getSocketInfo(this)))
      }),
      TR(t, "close", function () {
        let n = this[hV],
          i = this[li]
        i &&
          (!this[wl] &&
            i.statusCode &&
            !i.shouldKeepAlive &&
            i.onMessageComplete(),
          this[li].destroy(),
          (this[li] = null))
        let s = this[wl] || new QR("closed", Bt.getSocketInfo(this))
        if (((n[L0] = null), (n[Jne] = null), n.destroyed)) {
          ht(n[M6e] === 0)
          let o = n[Ec].splice(n[xl])
          for (let a = 0; a < o.length; a++) {
            let l = o[a]
            Bt.errorRequest(n, l, s)
          }
        } else if (n[zs] > 0 && s.code !== "UND_ERR_INFO") {
          let o = n[Ec][n[xl]]
          ;(n[Ec][n[xl]++] = null), Bt.errorRequest(n, o, s)
        }
        ;(n[N6e] = n[xl]),
          ht(n[zs] === 0),
          n.emit("disconnect", n[zne], [n], s),
          n[dh]()
      })
    let r = false
    return (
      t.on("close", () => {
        r = true
      }),
      {
        version: "h1",
        defaultPipelining: 1,
        write(...n) {
          return j6e(e, ...n)
        },
        resume() {
          z6e(e)
        },
        destroy(n, i) {
          r ? queueMicrotask(i) : t.destroy(n).on("close", i)
        },
        get destroyed() {
          return t.destroyed
        },
        busy(n) {
          return !!(
            t[fh] ||
            t[Jo] ||
            t[_E] ||
            (n &&
              ((e[zs] > 0 && !n.idempotent) ||
                (e[zs] > 0 && (n.upgrade || n.method === "CONNECT")) ||
                (e[zs] > 0 &&
                  Bt.bodyLength(n.body) !== 0 &&
                  (Bt.isStream(n.body) ||
                    Bt.isAsyncIterable(n.body) ||
                    Bt.isFormDataLike(n.body)))))
          )
        },
      }
    )
  }
  function z6e(e) {
    let t = e[L0]
    if (t && !t.destroyed) {
      if (
        (e[Hne] === 0
          ? !t[bE] && t.unref && (t.unref(), (t[bE] = true))
          : t[bE] && t.ref && (t.ref(), (t[bE] = false)),
        e[Hne] === 0)
      )
        t[li].timeoutType !== mV && t[li].setTimeout(e[NR], mV)
      else if (
        e[zs] > 0 &&
        t[li].statusCode < 200 &&
        t[li].timeoutType !== U0
      ) {
        let r = e[Ec][e[xl]],
          n = r.headersTimeout != null ? r.headersTimeout : e[U6e]
        t[li].setTimeout(n, U0)
      }
    }
  }
  function J6e(e) {
    return (
      e !== "GET" &&
      e !== "HEAD" &&
      e !== "OPTIONS" &&
      e !== "TRACE" &&
      e !== "CONNECT"
    )
  }
  function j6e(e, t) {
    let { method: r, path: n, host: i, upgrade: s, blocking: o, reset: a } = t,
      { body: l, headers: c, contentLength: u } = t,
      f =
        r === "PUT" ||
        r === "POST" ||
        r === "PATCH" ||
        r === "QUERY" ||
        r === "PROPFIND" ||
        r === "PROPPATCH"
    if (Bt.isFormDataLike(l)) {
      dV || (dV = N0().extractBody)
      let [v, C] = dV(l)
      t.contentType == null && c.push("content-type", C),
        (l = v.stream),
        (u = v.length)
    } else
      Bt.isBlobLike(l) &&
        t.contentType == null &&
        l.type &&
        c.push("content-type", l.type)
    l && typeof l.read == "function" && l.read(0)
    let p = Bt.bodyLength(l)
    if (
      ((u = p ?? u),
      u === null && (u = t.contentLength),
      u === 0 && !f && (u = null),
      J6e(r) && u > 0 && t.contentLength !== null && t.contentLength !== u)
    ) {
      if (e[gV]) return Bt.errorRequest(e, t, new xp()), false
      process.emitWarning(new xp())
    }
    let g = e[L0],
      m = (v) => {
        t.aborted ||
          t.completed ||
          (Bt.errorRequest(e, t, v || new Kne()),
          Bt.destroy(l),
          Bt.destroy(g, new P0("aborted")))
      }
    try {
      t.onConnect(m)
    } catch (v) {
      Bt.errorRequest(e, t, v)
    }
    if (t.aborted) return false
    r === "HEAD" && (g[Jo] = true),
      (s || r === "CONNECT") && (g[Jo] = true),
      a != null && (g[Jo] = a),
      e[Wne] && g[q6e]++ >= e[Wne] && (g[Jo] = true),
      o && (g[_E] = true)
    let y = `${r} ${n} HTTP/1.1\r
`
    if (
      (typeof i == "string"
        ? (y += `host: ${i}\r
`)
        : (y += e[Q6e]),
      s
        ? (y += `connection: upgrade\r
upgrade: ${s}\r
`)
        : e[MR] && !g[Jo]
          ? (y += `connection: keep-alive\r
`)
          : (y += `connection: close\r
`),
      Array.isArray(c))
    )
      for (let v = 0; v < c.length; v += 2) {
        let C = c[v + 0],
          E = c[v + 1]
        if (Array.isArray(E))
          for (let w = 0; w < E.length; w++)
            y += `${C}: ${E[w]}\r
`
        else
          y += `${C}: ${E}\r
`
      }
    return (
      Vne.sendHeaders.hasSubscribers &&
        Vne.sendHeaders.publish({ request: t, headers: y, socket: g }),
      !l || p === 0
        ? $ne(m, null, e, t, g, u, y, f)
        : Bt.isBuffer(l)
          ? $ne(m, l, e, t, g, u, y, f)
          : Bt.isBlobLike(l)
            ? typeof l.stream == "function"
              ? Yne(m, l.stream(), e, t, g, u, y, f)
              : X6e(m, l, e, t, g, u, y, f)
            : Bt.isStream(l)
              ? Z6e(m, l, e, t, g, u, y, f)
              : Bt.isIterable(l)
                ? Yne(m, l, e, t, g, u, y, f)
                : ht(false),
      true
    )
  }
  function Z6e(e, t, r, n, i, s, o, a) {
    ht(s !== 0 || r[zs] === 0, "stream body cannot be pipelined")
    let l = false,
      c = new PR({
        abort: e,
        socket: i,
        request: n,
        contentLength: s,
        client: r,
        expectsPayload: a,
        header: o,
      }),
      u = function (m) {
        if (!l)
          try {
            !c.write(m) && this.pause && this.pause()
          } catch (y) {
            Bt.destroy(this, y)
          }
      },
      f = function () {
        l || (t.resume && t.resume())
      },
      p = function () {
        if (
          (queueMicrotask(() => {
            t.removeListener("error", g)
          }),
          !l)
        ) {
          let m = new Kne()
          queueMicrotask(() => g(m))
        }
      },
      g = function (m) {
        if (!l) {
          if (
            ((l = true),
            ht(i.destroyed || (i[fh] && r[zs] <= 1)),
            i.off("drain", f).off("error", g),
            t
              .removeListener("data", u)
              .removeListener("end", g)
              .removeListener("close", p),
            !m)
          )
            try {
              c.end()
            } catch (y) {
              m = y
            }
          c.destroy(m),
            m && (m.code !== "UND_ERR_INFO" || m.message !== "reset")
              ? Bt.destroy(t, m)
              : Bt.destroy(t)
        }
      }
    t.on("data", u).on("end", g).on("error", g).on("close", p),
      t.resume && t.resume(),
      i.on("drain", f).on("error", g),
      (t.errorEmitted ?? t.errored)
        ? setImmediate(() => g(t.errored))
        : (t.endEmitted ?? t.readableEnded) && setImmediate(() => g(null)),
      (t.closeEmitted ?? t.closed) && setImmediate(p)
  }
  function $ne(e, t, r, n, i, s, o, a) {
    try {
      t
        ? Bt.isBuffer(t) &&
          (ht(s === t.byteLength, "buffer body must have content length"),
          i.cork(),
          i.write(
            `${o}content-length: ${s}\r
\r
`,
            "latin1",
          ),
          i.write(t),
          i.uncork(),
          n.onBodySent(t),
          !a && n.reset !== false && (i[Jo] = true))
        : s === 0
          ? i.write(
              `${o}content-length: 0\r
\r
`,
              "latin1",
            )
          : (ht(s === null, "no body must not have content length"),
            i.write(
              `${o}\r
`,
              "latin1",
            )),
        n.onRequestSent(),
        r[dh]()
    } catch (l) {
      e(l)
    }
  }
  async function X6e(e, t, r, n, i, s, o, a) {
    ht(s === t.size, "blob body must have content length")
    try {
      if (s != null && s !== t.size) throw new xp()
      let l = Buffer.from(await t.arrayBuffer())
      i.cork(),
        i.write(
          `${o}content-length: ${s}\r
\r
`,
          "latin1",
        ),
        i.write(l),
        i.uncork(),
        n.onBodySent(l),
        n.onRequestSent(),
        !a && n.reset !== false && (i[Jo] = true),
        r[dh]()
    } catch (l) {
      e(l)
    }
  }
  async function Yne(e, t, r, n, i, s, o, a) {
    ht(s !== 0 || r[zs] === 0, "iterator body cannot be pipelined")
    let l = null
    function c() {
      if (l) {
        let p = l
        ;(l = null), p()
      }
    }
    let u = () =>
      new Promise((p, g) => {
        ht(l === null), i[wl] ? g(i[wl]) : (l = p)
      })
    i.on("close", c).on("drain", c)
    let f = new PR({
      abort: e,
      socket: i,
      request: n,
      contentLength: s,
      client: r,
      expectsPayload: a,
      header: o,
    })
    try {
      for await (let p of t) {
        if (i[wl]) throw i[wl]
        f.write(p) || (await u())
      }
      f.end()
    } catch (p) {
      f.destroy(p)
    } finally {
      i.off("close", c).off("drain", c)
    }
  }
  var PR = class {
    constructor({
      abort: t,
      socket: r,
      request: n,
      contentLength: i,
      client: s,
      expectsPayload: o,
      header: a,
    }) {
      ;(this.socket = r),
        (this.request = n),
        (this.contentLength = i),
        (this.client = s),
        (this.bytesWritten = 0),
        (this.expectsPayload = o),
        (this.header = a),
        (this.abort = t),
        (r[fh] = true)
    }
    write(t) {
      let {
        socket: r,
        request: n,
        contentLength: i,
        client: s,
        bytesWritten: o,
        expectsPayload: a,
        header: l,
      } = this
      if (r[wl]) throw r[wl]
      if (r.destroyed) return false
      let c = Buffer.byteLength(t)
      if (!c) return true
      if (i !== null && o + c > i) {
        if (s[gV]) throw new xp()
        process.emitWarning(new xp())
      }
      r.cork(),
        o === 0 &&
          (!a && n.reset !== false && (r[Jo] = true),
          i === null
            ? r.write(
                `${l}transfer-encoding: chunked\r
`,
                "latin1",
              )
            : r.write(
                `${l}content-length: ${i}\r
\r
`,
                "latin1",
              )),
        i === null &&
          r.write(
            `\r
${c.toString(16)}\r
`,
            "latin1",
          ),
        (this.bytesWritten += c)
      let u = r.write(t)
      return (
        r.uncork(),
        n.onBodySent(t),
        u ||
          (r[li].timeout &&
            r[li].timeoutType === U0 &&
            r[li].timeout.refresh &&
            r[li].timeout.refresh()),
        u
      )
    }
    end() {
      let {
        socket: t,
        contentLength: r,
        client: n,
        bytesWritten: i,
        expectsPayload: s,
        header: o,
        request: a,
      } = this
      if ((a.onRequestSent(), (t[fh] = false), t[wl])) throw t[wl]
      if (!t.destroyed) {
        if (
          (i === 0
            ? s
              ? t.write(
                  `${o}content-length: 0\r
\r
`,
                  "latin1",
                )
              : t.write(
                  `${o}\r
`,
                  "latin1",
                )
            : r === null &&
              t.write(
                `\r
0\r
\r
`,
                "latin1",
              ),
          r !== null && i !== r)
        ) {
          if (n[gV]) throw new xp()
          process.emitWarning(new xp())
        }
        t[li].timeout &&
          t[li].timeoutType === U0 &&
          t[li].timeout.refresh &&
          t[li].timeout.refresh(),
          n[dh]()
      }
    }
    destroy(t) {
      let { socket: r, client: n, abort: i } = this
      ;(r[fh] = false),
        t && (ht(n[zs] <= 1, "pipeline should only contain this request"), i(t))
    }
  }
  jne.exports = K6e
})
var oie = _((BDt, sie) => {
  "use strict"
  var Sl = require("assert"),
    { pipeline: e9e } = require("stream"),
    Ar = ir(),
    {
      RequestContentLengthMismatchError: yV,
      RequestAbortedError: Xne,
      SocketError: xE,
      InformationalError: vV,
    } = Jr(),
    {
      kUrl: LR,
      kReset: OR,
      kClient: O0,
      kRunning: qR,
      kPending: t9e,
      kQueue: hh,
      kPendingIdx: CV,
      kRunningIdx: _c,
      kError: wc,
      kSocket: rs,
      kStrictContentLength: r9e,
      kOnError: bV,
      kMaxConcurrentStreams: iie,
      kHTTP2Session: xc,
      kResume: gh,
      kSize: n9e,
      kHTTPContext: i9e,
    } = Wn(),
    Hd = Symbol("open streams"),
    eie,
    tie = false,
    UR
  try {
    UR = require("http2")
  } catch {
    UR = { constants: {} }
  }
  var {
    constants: {
      HTTP2_HEADER_AUTHORITY: s9e,
      HTTP2_HEADER_METHOD: o9e,
      HTTP2_HEADER_PATH: a9e,
      HTTP2_HEADER_SCHEME: l9e,
      HTTP2_HEADER_CONTENT_LENGTH: c9e,
      HTTP2_HEADER_EXPECT: u9e,
      HTTP2_HEADER_STATUS: d9e,
    },
  } = UR
  function f9e(e) {
    let t = []
    for (let [r, n] of Object.entries(e))
      if (Array.isArray(n))
        for (let i of n) t.push(Buffer.from(r), Buffer.from(i))
      else t.push(Buffer.from(r), Buffer.from(n))
    return t
  }
  async function h9e(e, t) {
    ;(e[rs] = t),
      tie ||
        ((tie = true),
        process.emitWarning(
          "H2 support is experimental, expect them to change at any time.",
          { code: "UNDICI-H2" },
        ))
    let r = UR.connect(e[LR], {
      createConnection: () => t,
      peerMaxConcurrentStreams: e[iie],
    })
    ;(r[Hd] = 0),
      (r[O0] = e),
      (r[rs] = t),
      Ar.addListener(r, "error", p9e),
      Ar.addListener(r, "frameError", m9e),
      Ar.addListener(r, "end", A9e),
      Ar.addListener(r, "goaway", y9e),
      Ar.addListener(r, "close", function () {
        let { [O0]: i } = this,
          { [rs]: s } = i,
          o = this[rs][wc] || this[wc] || new xE("closed", Ar.getSocketInfo(s))
        if (((i[xc] = null), i.destroyed)) {
          Sl(i[t9e] === 0)
          let a = i[hh].splice(i[_c])
          for (let l = 0; l < a.length; l++) {
            let c = a[l]
            Ar.errorRequest(i, c, o)
          }
        }
      }),
      r.unref(),
      (e[xc] = r),
      (t[xc] = r),
      Ar.addListener(t, "error", function (i) {
        Sl(i.code !== "ERR_TLS_CERT_ALTNAME_INVALID"),
          (this[wc] = i),
          this[O0][bV](i)
      }),
      Ar.addListener(t, "end", function () {
        Ar.destroy(this, new xE("other side closed", Ar.getSocketInfo(this)))
      }),
      Ar.addListener(t, "close", function () {
        let i = this[wc] || new xE("closed", Ar.getSocketInfo(this))
        ;(e[rs] = null),
          this[xc] != null && this[xc].destroy(i),
          (e[CV] = e[_c]),
          Sl(e[qR] === 0),
          e.emit("disconnect", e[LR], [e], i),
          e[gh]()
      })
    let n = false
    return (
      t.on("close", () => {
        n = true
      }),
      {
        version: "h2",
        defaultPipelining: 1 / 0,
        write(...i) {
          return C9e(e, ...i)
        },
        resume() {
          g9e(e)
        },
        destroy(i, s) {
          n ? queueMicrotask(s) : t.destroy(i).on("close", s)
        },
        get destroyed() {
          return t.destroyed
        },
        busy() {
          return false
        },
      }
    )
  }
  function g9e(e) {
    let t = e[rs]
    t?.destroyed === false &&
      (e[n9e] === 0 && e[iie] === 0
        ? (t.unref(), e[xc].unref())
        : (t.ref(), e[xc].ref()))
  }
  function p9e(e) {
    Sl(e.code !== "ERR_TLS_CERT_ALTNAME_INVALID"),
      (this[rs][wc] = e),
      this[O0][bV](e)
  }
  function m9e(e, t, r) {
    if (r === 0) {
      let n = new vV(`HTTP/2: "frameError" received - type ${e}, code ${t}`)
      ;(this[rs][wc] = n), this[O0][bV](n)
    }
  }
  function A9e() {
    let e = new xE("other side closed", Ar.getSocketInfo(this[rs]))
    this.destroy(e), Ar.destroy(this[rs], e)
  }
  function y9e(e) {
    let t =
        this[wc] ||
        new xE(
          `HTTP/2: "GOAWAY" frame received with code ${e}`,
          Ar.getSocketInfo(this),
        ),
      r = this[O0]
    if (
      ((r[rs] = null),
      (r[i9e] = null),
      this[xc] != null && (this[xc].destroy(t), (this[xc] = null)),
      Ar.destroy(this[rs], t),
      r[_c] < r[hh].length)
    ) {
      let n = r[hh][r[_c]]
      ;(r[hh][r[_c]++] = null), Ar.errorRequest(r, n, t), (r[CV] = r[_c])
    }
    Sl(r[qR] === 0), r.emit("disconnect", r[LR], [r], t), r[gh]()
  }
  function v9e(e) {
    return (
      e !== "GET" &&
      e !== "HEAD" &&
      e !== "OPTIONS" &&
      e !== "TRACE" &&
      e !== "CONNECT"
    )
  }
  function C9e(e, t) {
    let r = e[xc],
      {
        method: n,
        path: i,
        host: s,
        upgrade: o,
        expectContinue: a,
        signal: l,
        headers: c,
      } = t,
      { body: u } = t
    if (o)
      return (
        Ar.errorRequest(e, t, new Error("Upgrade not supported for H2")), false
      )
    let f = {}
    for (let B = 0; B < c.length; B += 2) {
      let T = c[B + 0],
        N = c[B + 1]
      if (Array.isArray(N))
        for (let W = 0; W < N.length; W++)
          f[T] ? (f[T] += `,${N[W]}`) : (f[T] = N[W])
      else f[T] = N
    }
    let p,
      { hostname: g, port: m } = e[LR]
    ;(f[s9e] = s || `${g}${m ? `:${m}` : ""}`), (f[o9e] = n)
    let y = (B) => {
      t.aborted ||
        t.completed ||
        ((B = B || new Xne()),
        Ar.errorRequest(e, t, B),
        p != null && Ar.destroy(p, B),
        Ar.destroy(u, B),
        (e[hh][e[_c]++] = null),
        e[gh]())
    }
    try {
      t.onConnect(y)
    } catch (B) {
      Ar.errorRequest(e, t, B)
    }
    if (t.aborted) return false
    if (n === "CONNECT")
      return (
        r.ref(),
        (p = r.request(f, { endStream: false, signal: l })),
        p.id && !p.pending
          ? (t.onUpgrade(null, null, p), ++r[Hd], (e[hh][e[_c]++] = null))
          : p.once("ready", () => {
              t.onUpgrade(null, null, p), ++r[Hd], (e[hh][e[_c]++] = null)
            }),
        p.once("close", () => {
          ;(r[Hd] -= 1), r[Hd] === 0 && r.unref()
        }),
        true
      )
    ;(f[a9e] = i), (f[l9e] = "https")
    let v = n === "PUT" || n === "POST" || n === "PATCH"
    u && typeof u.read == "function" && u.read(0)
    let C = Ar.bodyLength(u)
    if (Ar.isFormDataLike(u)) {
      eie ??= N0().extractBody
      let [B, T] = eie(u)
      ;(f["content-type"] = T), (u = B.stream), (C = B.length)
    }
    if (
      (C == null && (C = t.contentLength),
      (C === 0 || !v) && (C = null),
      v9e(n) && C > 0 && t.contentLength != null && t.contentLength !== C)
    ) {
      if (e[r9e]) return Ar.errorRequest(e, t, new yV()), false
      process.emitWarning(new yV())
    }
    C != null &&
      (Sl(u, "no body must not have content length"), (f[c9e] = `${C}`)),
      r.ref()
    let E = n === "GET" || n === "HEAD" || u === null
    return (
      a
        ? ((f[u9e] = "100-continue"),
          (p = r.request(f, { endStream: E, signal: l })),
          p.once("continue", w))
        : ((p = r.request(f, { endStream: E, signal: l })), w()),
      ++r[Hd],
      p.once("response", (B) => {
        let { [d9e]: T, ...N } = B
        if ((t.onResponseStarted(), t.aborted)) {
          let W = new Xne()
          Ar.errorRequest(e, t, W), Ar.destroy(p, W)
          return
        }
        t.onHeaders(Number(T), f9e(N), p.resume.bind(p), "") === false &&
          p.pause(),
          p.on("data", (W) => {
            t.onData(W) === false && p.pause()
          })
      }),
      p.once("end", () => {
        ;(p.state?.state == null || p.state.state < 6) && t.onComplete([]),
          r[Hd] === 0 && r.unref(),
          y(new vV("HTTP/2: stream half-closed (remote)")),
          (e[hh][e[_c]++] = null),
          (e[CV] = e[_c]),
          e[gh]()
      }),
      p.once("close", () => {
        ;(r[Hd] -= 1), r[Hd] === 0 && r.unref()
      }),
      p.once("error", function (B) {
        y(B)
      }),
      p.once("frameError", (B, T) => {
        y(new vV(`HTTP/2: "frameError" received - type ${B}, code ${T}`))
      }),
      true
    )
    function w() {
      !u || C === 0
        ? rie(y, p, null, e, t, e[rs], C, v)
        : Ar.isBuffer(u)
          ? rie(y, p, u, e, t, e[rs], C, v)
          : Ar.isBlobLike(u)
            ? typeof u.stream == "function"
              ? nie(y, p, u.stream(), e, t, e[rs], C, v)
              : E9e(y, p, u, e, t, e[rs], C, v)
            : Ar.isStream(u)
              ? b9e(y, e[rs], v, p, u, e, t, C)
              : Ar.isIterable(u)
                ? nie(y, p, u, e, t, e[rs], C, v)
                : Sl(false)
    }
  }
  function rie(e, t, r, n, i, s, o, a) {
    try {
      r != null &&
        Ar.isBuffer(r) &&
        (Sl(o === r.byteLength, "buffer body must have content length"),
        t.cork(),
        t.write(r),
        t.uncork(),
        t.end(),
        i.onBodySent(r)),
        a || (s[OR] = true),
        i.onRequestSent(),
        n[gh]()
    } catch (l) {
      e(l)
    }
  }
  function b9e(e, t, r, n, i, s, o, a) {
    Sl(a !== 0 || s[qR] === 0, "stream body cannot be pipelined")
    let l = e9e(i, n, (u) => {
      u
        ? (Ar.destroy(l, u), e(u))
        : (Ar.removeAllListeners(l),
          o.onRequestSent(),
          r || (t[OR] = true),
          s[gh]())
    })
    Ar.addListener(l, "data", c)
    function c(u) {
      o.onBodySent(u)
    }
  }
  async function E9e(e, t, r, n, i, s, o, a) {
    Sl(o === r.size, "blob body must have content length")
    try {
      if (o != null && o !== r.size) throw new yV()
      let l = Buffer.from(await r.arrayBuffer())
      t.cork(),
        t.write(l),
        t.uncork(),
        t.end(),
        i.onBodySent(l),
        i.onRequestSent(),
        a || (s[OR] = true),
        n[gh]()
    } catch (l) {
      e(l)
    }
  }
  async function nie(e, t, r, n, i, s, o, a) {
    Sl(o !== 0 || n[qR] === 0, "iterator body cannot be pipelined")
    let l = null
    function c() {
      if (l) {
        let f = l
        ;(l = null), f()
      }
    }
    let u = () =>
      new Promise((f, p) => {
        Sl(l === null), s[wc] ? p(s[wc]) : (l = f)
      })
    t.on("close", c).on("drain", c)
    try {
      for await (let f of r) {
        if (s[wc]) throw s[wc]
        let p = t.write(f)
        i.onBodySent(f), p || (await u())
      }
      t.end(), i.onRequestSent(), a || (s[OR] = true), n[gh]()
    } catch (f) {
      e(f)
    } finally {
      t.off("close", c).off("drain", c)
    }
  }
  sie.exports = h9e
})
var HR = _((RDt, cie) => {
  "use strict"
  var Su = ir(),
    { kBodyUsed: wE } = Wn(),
    _V = require("assert"),
    { InvalidArgumentError: _9e } = Jr(),
    x9e = require("events"),
    w9e = [300, 301, 302, 303, 307, 308],
    aie = Symbol("body"),
    VR = class {
      constructor(t) {
        ;(this[aie] = t), (this[wE] = false)
      }
      async *[Symbol.asyncIterator]() {
        _V(!this[wE], "disturbed"), (this[wE] = true), yield* this[aie]
      }
    },
    EV = class {
      constructor(t, r, n, i) {
        if (r != null && (!Number.isInteger(r) || r < 0))
          throw new _9e("maxRedirections must be a positive number")
        Su.validateHandler(i, n.method, n.upgrade),
          (this.dispatch = t),
          (this.location = null),
          (this.abort = null),
          (this.opts = { ...n, maxRedirections: 0 }),
          (this.maxRedirections = r),
          (this.handler = i),
          (this.history = []),
          (this.redirectionLimitReached = false),
          Su.isStream(this.opts.body)
            ? (Su.bodyLength(this.opts.body) === 0 &&
                this.opts.body.on("data", function () {
                  _V(false)
                }),
              typeof this.opts.body.readableDidRead != "boolean" &&
                ((this.opts.body[wE] = false),
                x9e.prototype.on.call(this.opts.body, "data", function () {
                  this[wE] = true
                })))
            : this.opts.body && typeof this.opts.body.pipeTo == "function"
              ? (this.opts.body = new VR(this.opts.body))
              : this.opts.body &&
                typeof this.opts.body != "string" &&
                !ArrayBuffer.isView(this.opts.body) &&
                Su.isIterable(this.opts.body) &&
                (this.opts.body = new VR(this.opts.body))
      }
      onConnect(t) {
        ;(this.abort = t), this.handler.onConnect(t, { history: this.history })
      }
      onUpgrade(t, r, n) {
        this.handler.onUpgrade(t, r, n)
      }
      onError(t) {
        this.handler.onError(t)
      }
      onHeaders(t, r, n, i) {
        if (
          ((this.location =
            this.history.length >= this.maxRedirections ||
            Su.isDisturbed(this.opts.body)
              ? null
              : S9e(t, r)),
          this.opts.throwOnMaxRedirect &&
            this.history.length >= this.maxRedirections)
        ) {
          this.request && this.request.abort(new Error("max redirects")),
            (this.redirectionLimitReached = true),
            this.abort(new Error("max redirects"))
          return
        }
        if (
          (this.opts.origin &&
            this.history.push(new URL(this.opts.path, this.opts.origin)),
          !this.location)
        )
          return this.handler.onHeaders(t, r, n, i)
        let {
            origin: s,
            pathname: o,
            search: a,
          } = Su.parseURL(
            new URL(
              this.location,
              this.opts.origin && new URL(this.opts.path, this.opts.origin),
            ),
          ),
          l = a ? `${o}${a}` : o
        ;(this.opts.headers = I9e(
          this.opts.headers,
          t === 303,
          this.opts.origin !== s,
        )),
          (this.opts.path = l),
          (this.opts.origin = s),
          (this.opts.maxRedirections = 0),
          (this.opts.query = null),
          t === 303 &&
            this.opts.method !== "HEAD" &&
            ((this.opts.method = "GET"), (this.opts.body = null))
      }
      onData(t) {
        if (!this.location) return this.handler.onData(t)
      }
      onComplete(t) {
        this.location
          ? ((this.location = null),
            (this.abort = null),
            this.dispatch(this.opts, this))
          : this.handler.onComplete(t)
      }
      onBodySent(t) {
        this.handler.onBodySent && this.handler.onBodySent(t)
      }
    }
  function S9e(e, t) {
    if (w9e.indexOf(e) === -1) return null
    for (let r = 0; r < t.length; r += 2)
      if (t[r].length === 8 && Su.headerNameToString(t[r]) === "location")
        return t[r + 1]
  }
  function lie(e, t, r) {
    if (e.length === 4) return Su.headerNameToString(e) === "host"
    if (t && Su.headerNameToString(e).startsWith("content-")) return true
    if (r && (e.length === 13 || e.length === 6 || e.length === 19)) {
      let n = Su.headerNameToString(e)
      return (
        n === "authorization" || n === "cookie" || n === "proxy-authorization"
      )
    }
    return false
  }
  function I9e(e, t, r) {
    let n = []
    if (Array.isArray(e))
      for (let i = 0; i < e.length; i += 2)
        lie(e[i], t, r) || n.push(e[i], e[i + 1])
    else if (e && typeof e == "object")
      for (let i of Object.keys(e)) lie(i, t, r) || n.push(i, e[i])
    else _V(e == null, "headers must be an object or an array")
    return n
  }
  cie.exports = EV
})
var WR = _((DDt, uie) => {
  "use strict"
  var B9e = HR()
  function R9e({ maxRedirections: e }) {
    return (t) =>
      function (n, i) {
        let { maxRedirections: s = e } = n
        if (!s) return t(n, i)
        let o = new B9e(t, s, n, i)
        return (n = { ...n, maxRedirections: 0 }), t(n, o)
      }
  }
  uie.exports = R9e
})
var kE = _((TDt, Cie) => {
  "use strict"
  var Wd = require("assert"),
    mie = require("net"),
    D9e = require("http"),
    wp = ir(),
    { channels: q0 } = _0(),
    T9e = Ire(),
    k9e = I0(),
    {
      InvalidArgumentError: _i,
      InformationalError: M9e,
      ClientDestroyedError: F9e,
    } = Jr(),
    Q9e = fE(),
    {
      kUrl: Iu,
      kServerName: ph,
      kClient: N9e,
      kBusy: xV,
      kConnect: P9e,
      kResuming: Sp,
      kRunning: DE,
      kPending: TE,
      kSize: RE,
      kQueue: Sc,
      kConnected: L9e,
      kConnecting: V0,
      kNeedDrain: Ah,
      kKeepAliveDefaultTimeout: die,
      kHostHeader: U9e,
      kPendingIdx: Ic,
      kRunningIdx: Gd,
      kError: O9e,
      kPipelining: GR,
      kKeepAliveTimeoutValue: q9e,
      kMaxHeadersSize: V9e,
      kKeepAliveMaxTimeout: H9e,
      kKeepAliveTimeoutThreshold: W9e,
      kHeadersTimeout: G9e,
      kBodyTimeout: $9e,
      kStrictContentLength: Y9e,
      kConnector: SE,
      kMaxRedirections: K9e,
      kMaxRequests: wV,
      kCounter: z9e,
      kClose: J9e,
      kDestroy: j9e,
      kDispatch: Z9e,
      kInterceptors: fie,
      kLocalAddress: IE,
      kMaxResponseSize: X9e,
      kOnError: e$e,
      kHTTPContext: xi,
      kMaxConcurrentStreams: t$e,
      kResume: BE,
    } = Wn(),
    r$e = Zne(),
    n$e = oie(),
    hie = false,
    mh = Symbol("kClosedResolve"),
    gie = () => {}
  function Aie(e) {
    return e[GR] ?? e[xi]?.defaultPipelining ?? 1
  }
  var SV = class extends k9e {
      constructor(
        t,
        {
          interceptors: r,
          maxHeaderSize: n,
          headersTimeout: i,
          socketTimeout: s,
          requestTimeout: o,
          connectTimeout: a,
          bodyTimeout: l,
          idleTimeout: c,
          keepAlive: u,
          keepAliveTimeout: f,
          maxKeepAliveTimeout: p,
          keepAliveMaxTimeout: g,
          keepAliveTimeoutThreshold: m,
          socketPath: y,
          pipelining: v,
          tls: C,
          strictContentLength: E,
          maxCachedSessions: w,
          maxRedirections: B,
          connect: T,
          maxRequestsPerClient: N,
          localAddress: W,
          maxResponseSize: Z,
          autoSelectFamily: te,
          autoSelectFamilyAttemptTimeout: Y,
          maxConcurrentStreams: U,
          allowH2: ce,
        } = {},
      ) {
        if ((super(), u !== undefined))
          throw new _i("unsupported keepAlive, use pipelining=0 instead")
        if (s !== undefined)
          throw new _i(
            "unsupported socketTimeout, use headersTimeout & bodyTimeout instead",
          )
        if (o !== undefined)
          throw new _i(
            "unsupported requestTimeout, use headersTimeout & bodyTimeout instead",
          )
        if (c !== undefined)
          throw new _i("unsupported idleTimeout, use keepAliveTimeout instead")
        if (p !== undefined)
          throw new _i(
            "unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead",
          )
        if (n != null && !Number.isFinite(n))
          throw new _i("invalid maxHeaderSize")
        if (y != null && typeof y != "string")
          throw new _i("invalid socketPath")
        if (a != null && (!Number.isFinite(a) || a < 0))
          throw new _i("invalid connectTimeout")
        if (f != null && (!Number.isFinite(f) || f <= 0))
          throw new _i("invalid keepAliveTimeout")
        if (g != null && (!Number.isFinite(g) || g <= 0))
          throw new _i("invalid keepAliveMaxTimeout")
        if (m != null && !Number.isFinite(m))
          throw new _i("invalid keepAliveTimeoutThreshold")
        if (i != null && (!Number.isInteger(i) || i < 0))
          throw new _i("headersTimeout must be a positive integer or zero")
        if (l != null && (!Number.isInteger(l) || l < 0))
          throw new _i("bodyTimeout must be a positive integer or zero")
        if (T != null && typeof T != "function" && typeof T != "object")
          throw new _i("connect must be a function or an object")
        if (B != null && (!Number.isInteger(B) || B < 0))
          throw new _i("maxRedirections must be a positive number")
        if (N != null && (!Number.isInteger(N) || N < 0))
          throw new _i("maxRequestsPerClient must be a positive number")
        if (W != null && (typeof W != "string" || mie.isIP(W) === 0))
          throw new _i("localAddress must be valid string IP address")
        if (Z != null && (!Number.isInteger(Z) || Z < -1))
          throw new _i("maxResponseSize must be a positive number")
        if (Y != null && (!Number.isInteger(Y) || Y < -1))
          throw new _i(
            "autoSelectFamilyAttemptTimeout must be a positive number",
          )
        if (ce != null && typeof ce != "boolean")
          throw new _i("allowH2 must be a valid boolean value")
        if (U != null && (typeof U != "number" || U < 1))
          throw new _i(
            "maxConcurrentStreams must be a positive integer, greater than 0",
          )
        typeof T != "function" &&
          (T = Q9e({
            ...C,
            maxCachedSessions: w,
            allowH2: ce,
            socketPath: y,
            timeout: a,
            ...(te
              ? { autoSelectFamily: te, autoSelectFamilyAttemptTimeout: Y }
              : undefined),
            ...T,
          })),
          r?.Client && Array.isArray(r.Client)
            ? ((this[fie] = r.Client),
              hie ||
                ((hie = true),
                process.emitWarning(
                  "Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.",
                  { code: "UNDICI-CLIENT-INTERCEPTOR-DEPRECATED" },
                )))
            : (this[fie] = [i$e({ maxRedirections: B })]),
          (this[Iu] = wp.parseOrigin(t)),
          (this[SE] = T),
          (this[GR] = v ?? 1),
          (this[V9e] = n || D9e.maxHeaderSize),
          (this[die] = f ?? 4e3),
          (this[H9e] = g ?? 6e5),
          (this[W9e] = m ?? 2e3),
          (this[q9e] = this[die]),
          (this[ph] = null),
          (this[IE] = W ?? null),
          (this[Sp] = 0),
          (this[Ah] = 0),
          (this[U9e] =
            `host: ${this[Iu].hostname}${this[Iu].port ? `:${this[Iu].port}` : ""}\r
`),
          (this[$9e] = l ?? 3e5),
          (this[G9e] = i ?? 3e5),
          (this[Y9e] = E ?? true),
          (this[K9e] = B),
          (this[wV] = N),
          (this[mh] = null),
          (this[X9e] = Z > -1 ? Z : -1),
          (this[t$e] = U ?? 100),
          (this[xi] = null),
          (this[Sc] = []),
          (this[Gd] = 0),
          (this[Ic] = 0),
          (this[BE] = (Ie) => IV(this, Ie)),
          (this[e$e] = (Ie) => yie(this, Ie))
      }
      get pipelining() {
        return this[GR]
      }
      set pipelining(t) {
        ;(this[GR] = t), this[BE](true)
      }
      get [TE]() {
        return this[Sc].length - this[Ic]
      }
      get [DE]() {
        return this[Ic] - this[Gd]
      }
      get [RE]() {
        return this[Sc].length - this[Gd]
      }
      get [L9e]() {
        return !!this[xi] && !this[V0] && !this[xi].destroyed
      }
      get [xV]() {
        return !!(
          this[xi]?.busy(null) ||
          this[RE] >= (Aie(this) || 1) ||
          this[TE] > 0
        )
      }
      [P9e](t) {
        vie(this), this.once("connect", t)
      }
      [Z9e](t, r) {
        let n = t.origin || this[Iu].origin,
          i = new T9e(n, t, r)
        return (
          this[Sc].push(i),
          this[Sp] ||
            (wp.bodyLength(i.body) == null && wp.isIterable(i.body)
              ? ((this[Sp] = 1), queueMicrotask(() => IV(this)))
              : this[BE](true)),
          this[Sp] && this[Ah] !== 2 && this[xV] && (this[Ah] = 2),
          this[Ah] < 2
        )
      }
      async [J9e]() {
        return new Promise((t) => {
          this[RE] ? (this[mh] = t) : t(null)
        })
      }
      async [j9e](t) {
        return new Promise((r) => {
          let n = this[Sc].splice(this[Ic])
          for (let s = 0; s < n.length; s++) {
            let o = n[s]
            wp.errorRequest(this, o, t)
          }
          let i = () => {
            this[mh] && (this[mh](), (this[mh] = null)), r(null)
          }
          this[xi]
            ? (this[xi].destroy(t, i), (this[xi] = null))
            : queueMicrotask(i),
            this[BE]()
        })
      }
    },
    i$e = WR()
  function yie(e, t) {
    if (
      e[DE] === 0 &&
      t.code !== "UND_ERR_INFO" &&
      t.code !== "UND_ERR_SOCKET"
    ) {
      Wd(e[Ic] === e[Gd])
      let r = e[Sc].splice(e[Gd])
      for (let n = 0; n < r.length; n++) {
        let i = r[n]
        wp.errorRequest(e, i, t)
      }
      Wd(e[RE] === 0)
    }
  }
  async function vie(e) {
    Wd(!e[V0]), Wd(!e[xi])
    let { host: t, hostname: r, protocol: n, port: i } = e[Iu]
    if (r[0] === "[") {
      let s = r.indexOf("]")
      Wd(s !== -1)
      let o = r.substring(1, s)
      Wd(mie.isIP(o)), (r = o)
    }
    ;(e[V0] = true),
      q0.beforeConnect.hasSubscribers &&
        q0.beforeConnect.publish({
          connectParams: {
            host: t,
            hostname: r,
            protocol: n,
            port: i,
            version: e[xi]?.version,
            servername: e[ph],
            localAddress: e[IE],
          },
          connector: e[SE],
        })
    try {
      let s = await new Promise((o, a) => {
        e[SE](
          {
            host: t,
            hostname: r,
            protocol: n,
            port: i,
            servername: e[ph],
            localAddress: e[IE],
          },
          (l, c) => {
            l ? a(l) : o(c)
          },
        )
      })
      if (e.destroyed) {
        wp.destroy(s.on("error", gie), new F9e())
        return
      }
      Wd(s)
      try {
        e[xi] = s.alpnProtocol === "h2" ? await n$e(e, s) : await r$e(e, s)
      } catch (o) {
        throw (s.destroy().on("error", gie), o)
      }
      ;(e[V0] = false),
        (s[z9e] = 0),
        (s[wV] = e[wV]),
        (s[N9e] = e),
        (s[O9e] = null),
        q0.connected.hasSubscribers &&
          q0.connected.publish({
            connectParams: {
              host: t,
              hostname: r,
              protocol: n,
              port: i,
              version: e[xi]?.version,
              servername: e[ph],
              localAddress: e[IE],
            },
            connector: e[SE],
            socket: s,
          }),
        e.emit("connect", e[Iu], [e])
    } catch (s) {
      if (e.destroyed) return
      if (
        ((e[V0] = false),
        q0.connectError.hasSubscribers &&
          q0.connectError.publish({
            connectParams: {
              host: t,
              hostname: r,
              protocol: n,
              port: i,
              version: e[xi]?.version,
              servername: e[ph],
              localAddress: e[IE],
            },
            connector: e[SE],
            error: s,
          }),
        s.code === "ERR_TLS_CERT_ALTNAME_INVALID")
      )
        for (
          Wd(e[DE] === 0);
          e[TE] > 0 && e[Sc][e[Ic]].servername === e[ph];

        ) {
          let o = e[Sc][e[Ic]++]
          wp.errorRequest(e, o, s)
        }
      else yie(e, s)
      e.emit("connectionError", e[Iu], [e], s)
    }
    e[BE]()
  }
  function pie(e) {
    ;(e[Ah] = 0), e.emit("drain", e[Iu], [e])
  }
  function IV(e, t) {
    e[Sp] !== 2 &&
      ((e[Sp] = 2),
      s$e(e, t),
      (e[Sp] = 0),
      e[Gd] > 256 && (e[Sc].splice(0, e[Gd]), (e[Ic] -= e[Gd]), (e[Gd] = 0)))
  }
  function s$e(e, t) {
    for (;;) {
      if (e.destroyed) {
        Wd(e[TE] === 0)
        return
      }
      if (e[mh] && !e[RE]) {
        e[mh](), (e[mh] = null)
        return
      }
      if ((e[xi] && e[xi].resume(), e[xV])) e[Ah] = 2
      else if (e[Ah] === 2) {
        t ? ((e[Ah] = 1), queueMicrotask(() => pie(e))) : pie(e)
        continue
      }
      if (e[TE] === 0 || e[DE] >= (Aie(e) || 1)) return
      let r = e[Sc][e[Ic]]
      if (e[Iu].protocol === "https:" && e[ph] !== r.servername) {
        if (e[DE] > 0) return
        ;(e[ph] = r.servername),
          e[xi]?.destroy(new M9e("servername changed"), () => {
            ;(e[xi] = null), IV(e)
          })
      }
      if (e[V0]) return
      if (!e[xi]) {
        vie(e)
        return
      }
      if (e[xi].destroyed || e[xi].busy(r)) return
      !r.aborted && e[xi].write(r) ? e[Ic]++ : e[Sc].splice(e[Ic], 1)
    }
  }
  Cie.exports = SV
})
var BV = _((MDt, bie) => {
  "use strict"
  var $R = class {
    constructor() {
      ;(this.bottom = 0),
        (this.top = 0),
        (this.list = new Array(2048)),
        (this.next = null)
    }
    isEmpty() {
      return this.top === this.bottom
    }
    isFull() {
      return ((this.top + 1) & 2047) === this.bottom
    }
    push(t) {
      ;(this.list[this.top] = t), (this.top = (this.top + 1) & 2047)
    }
    shift() {
      let t = this.list[this.bottom]
      return t === undefined
        ? null
        : ((this.list[this.bottom] = undefined),
          (this.bottom = (this.bottom + 1) & 2047),
          t)
    }
  }
  bie.exports = class {
    constructor() {
      this.head = this.tail = new $R()
    }
    isEmpty() {
      return this.head.isEmpty()
    }
    push(t) {
      this.head.isFull() && (this.head = this.head.next = new $R()),
        this.head.push(t)
    }
    shift() {
      let t = this.tail,
        r = t.shift()
      return t.isEmpty() && t.next !== null && (this.tail = t.next), r
    }
  }
})
var _ie = _((FDt, Eie) => {
  "use strict"
  var {
      kFree: o$e,
      kConnected: a$e,
      kPending: l$e,
      kQueued: c$e,
      kRunning: u$e,
      kSize: d$e,
    } = Wn(),
    Ip = Symbol("pool"),
    RV = class {
      constructor(t) {
        this[Ip] = t
      }
      get connected() {
        return this[Ip][a$e]
      }
      get free() {
        return this[Ip][o$e]
      }
      get pending() {
        return this[Ip][l$e]
      }
      get queued() {
        return this[Ip][c$e]
      }
      get running() {
        return this[Ip][u$e]
      }
      get size() {
        return this[Ip][d$e]
      }
    }
  Eie.exports = RV
})
var QV = _((QDt, Mie) => {
  "use strict"
  var f$e = I0(),
    h$e = BV(),
    {
      kConnected: DV,
      kSize: xie,
      kRunning: wie,
      kPending: Sie,
      kQueued: ME,
      kBusy: g$e,
      kFree: p$e,
      kUrl: m$e,
      kClose: A$e,
      kDestroy: y$e,
      kDispatch: v$e,
    } = Wn(),
    C$e = _ie(),
    jo = Symbol("clients"),
    yo = Symbol("needDrain"),
    FE = Symbol("queue"),
    TV = Symbol("closed resolve"),
    kV = Symbol("onDrain"),
    Iie = Symbol("onConnect"),
    Bie = Symbol("onDisconnect"),
    Rie = Symbol("onConnectionError"),
    MV = Symbol("get dispatcher"),
    Tie = Symbol("add client"),
    kie = Symbol("remove client"),
    Die = Symbol("stats"),
    FV = class extends f$e {
      constructor() {
        super(), (this[FE] = new h$e()), (this[jo] = []), (this[ME] = 0)
        let t = this
        ;(this[kV] = function (n, i) {
          let s = t[FE],
            o = false
          for (; !o; ) {
            let a = s.shift()
            if (!a) break
            t[ME]--, (o = !this.dispatch(a.opts, a.handler))
          }
          ;(this[yo] = o),
            !this[yo] && t[yo] && ((t[yo] = false), t.emit("drain", n, [t, ...i])),
            t[TV] &&
              s.isEmpty() &&
              Promise.all(t[jo].map((a) => a.close())).then(t[TV])
        }),
          (this[Iie] = (r, n) => {
            t.emit("connect", r, [t, ...n])
          }),
          (this[Bie] = (r, n, i) => {
            t.emit("disconnect", r, [t, ...n], i)
          }),
          (this[Rie] = (r, n, i) => {
            t.emit("connectionError", r, [t, ...n], i)
          }),
          (this[Die] = new C$e(this))
      }
      get [g$e]() {
        return this[yo]
      }
      get [DV]() {
        return this[jo].filter((t) => t[DV]).length
      }
      get [p$e]() {
        return this[jo].filter((t) => t[DV] && !t[yo]).length
      }
      get [Sie]() {
        let t = this[ME]
        for (let { [Sie]: r } of this[jo]) t += r
        return t
      }
      get [wie]() {
        let t = 0
        for (let { [wie]: r } of this[jo]) t += r
        return t
      }
      get [xie]() {
        let t = this[ME]
        for (let { [xie]: r } of this[jo]) t += r
        return t
      }
      get stats() {
        return this[Die]
      }
      async [A$e]() {
        this[FE].isEmpty()
          ? await Promise.all(this[jo].map((t) => t.close()))
          : await new Promise((t) => {
              this[TV] = t
            })
      }
      async [y$e](t) {
        for (;;) {
          let r = this[FE].shift()
          if (!r) break
          r.handler.onError(t)
        }
        await Promise.all(this[jo].map((r) => r.destroy(t)))
      }
      [v$e](t, r) {
        let n = this[MV]()
        return (
          n
            ? n.dispatch(t, r) || ((n[yo] = true), (this[yo] = !this[MV]()))
            : ((this[yo] = true),
              this[FE].push({ opts: t, handler: r }),
              this[ME]++),
          !this[yo]
        )
      }
      [Tie](t) {
        return (
          t
            .on("drain", this[kV])
            .on("connect", this[Iie])
            .on("disconnect", this[Bie])
            .on("connectionError", this[Rie]),
          this[jo].push(t),
          this[yo] &&
            queueMicrotask(() => {
              this[yo] && this[kV](t[m$e], [this, t])
            }),
          this
        )
      }
      [kie](t) {
        t.close(() => {
          let r = this[jo].indexOf(t)
          r !== -1 && this[jo].splice(r, 1)
        }),
          (this[yo] = this[jo].some(
            (r) => !r[yo] && r.closed !== true && r.destroyed !== true,
          ))
      }
    }
  Mie.exports = {
    PoolBase: FV,
    kClients: jo,
    kNeedDrain: yo,
    kAddClient: Tie,
    kRemoveClient: kie,
    kGetDispatcher: MV,
  }
})
var H0 = _((NDt, Lie) => {
  "use strict"
  var {
      PoolBase: b$e,
      kClients: Fie,
      kNeedDrain: E$e,
      kAddClient: _$e,
      kGetDispatcher: x$e,
    } = QV(),
    w$e = kE(),
    { InvalidArgumentError: NV } = Jr(),
    Qie = ir(),
    { kUrl: Nie, kInterceptors: S$e } = Wn(),
    I$e = fE(),
    PV = Symbol("options"),
    LV = Symbol("connections"),
    Pie = Symbol("factory")
  function B$e(e, t) {
    return new w$e(e, t)
  }
  var UV = class extends b$e {
    constructor(
      t,
      {
        connections: r,
        factory: n = B$e,
        connect: i,
        connectTimeout: s,
        tls: o,
        maxCachedSessions: a,
        socketPath: l,
        autoSelectFamily: c,
        autoSelectFamilyAttemptTimeout: u,
        allowH2: f,
        ...p
      } = {},
    ) {
      if ((super(), r != null && (!Number.isFinite(r) || r < 0)))
        throw new NV("invalid connections")
      if (typeof n != "function") throw new NV("factory must be a function.")
      if (i != null && typeof i != "function" && typeof i != "object")
        throw new NV("connect must be a function or an object")
      typeof i != "function" &&
        (i = I$e({
          ...o,
          maxCachedSessions: a,
          allowH2: f,
          socketPath: l,
          timeout: s,
          ...(c
            ? { autoSelectFamily: c, autoSelectFamilyAttemptTimeout: u }
            : undefined),
          ...i,
        })),
        (this[S$e] =
          p.interceptors?.Pool && Array.isArray(p.interceptors.Pool)
            ? p.interceptors.Pool
            : []),
        (this[LV] = r || null),
        (this[Nie] = Qie.parseOrigin(t)),
        (this[PV] = { ...Qie.deepClone(p), connect: i, allowH2: f }),
        (this[PV].interceptors = p.interceptors
          ? { ...p.interceptors }
          : undefined),
        (this[Pie] = n)
    }
    [x$e]() {
      for (let t of this[Fie]) if (!t[E$e]) return t
      if (!this[LV] || this[Fie].length < this[LV]) {
        let t = this[Pie](this[Nie], this[PV])
        return this[_$e](t), t
      }
    }
  }
  Lie.exports = UV
})
var Hie = _((PDt, Vie) => {
  "use strict"
  var { BalancedPoolMissingUpstreamError: R$e, InvalidArgumentError: D$e } =
      Jr(),
    {
      PoolBase: T$e,
      kClients: Js,
      kNeedDrain: QE,
      kAddClient: k$e,
      kRemoveClient: M$e,
      kGetDispatcher: F$e,
    } = QV(),
    Q$e = H0(),
    { kUrl: OV, kInterceptors: N$e } = Wn(),
    { parseOrigin: Uie } = ir(),
    Oie = Symbol("factory"),
    YR = Symbol("options"),
    qie = Symbol("kGreatestCommonDivisor"),
    Bp = Symbol("kCurrentWeight"),
    Rp = Symbol("kIndex"),
    Il = Symbol("kWeight"),
    KR = Symbol("kMaxWeightPerServer"),
    zR = Symbol("kErrorPenalty")
  function P$e(e, t) {
    if (e === 0) return t
    for (; t !== 0; ) {
      let r = t
      ;(t = e % t), (e = r)
    }
    return e
  }
  function L$e(e, t) {
    return new Q$e(e, t)
  }
  var qV = class extends T$e {
    constructor(t = [], { factory: r = L$e, ...n } = {}) {
      if (
        (super(),
        (this[YR] = n),
        (this[Rp] = -1),
        (this[Bp] = 0),
        (this[KR] = this[YR].maxWeightPerServer || 100),
        (this[zR] = this[YR].errorPenalty || 15),
        Array.isArray(t) || (t = [t]),
        typeof r != "function")
      )
        throw new D$e("factory must be a function.")
      ;(this[N$e] =
        n.interceptors?.BalancedPool &&
        Array.isArray(n.interceptors.BalancedPool)
          ? n.interceptors.BalancedPool
          : []),
        (this[Oie] = r)
      for (let i of t) this.addUpstream(i)
      this._updateBalancedPoolStats()
    }
    addUpstream(t) {
      let r = Uie(t).origin
      if (
        this[Js].find(
          (i) => i[OV].origin === r && i.closed !== true && i.destroyed !== true,
        )
      )
        return this
      let n = this[Oie](r, Object.assign({}, this[YR]))
      this[k$e](n),
        n.on("connect", () => {
          n[Il] = Math.min(this[KR], n[Il] + this[zR])
        }),
        n.on("connectionError", () => {
          ;(n[Il] = Math.max(1, n[Il] - this[zR])),
            this._updateBalancedPoolStats()
        }),
        n.on("disconnect", (...i) => {
          let s = i[2]
          s &&
            s.code === "UND_ERR_SOCKET" &&
            ((n[Il] = Math.max(1, n[Il] - this[zR])),
            this._updateBalancedPoolStats())
        })
      for (let i of this[Js]) i[Il] = this[KR]
      return this._updateBalancedPoolStats(), this
    }
    _updateBalancedPoolStats() {
      let t = 0
      for (let r = 0; r < this[Js].length; r++) t = P$e(this[Js][r][Il], t)
      this[qie] = t
    }
    removeUpstream(t) {
      let r = Uie(t).origin,
        n = this[Js].find(
          (i) => i[OV].origin === r && i.closed !== true && i.destroyed !== true,
        )
      return n && this[M$e](n), this
    }
    get upstreams() {
      return this[Js].filter((t) => t.closed !== true && t.destroyed !== true).map(
        (t) => t[OV].origin,
      )
    }
    [F$e]() {
      if (this[Js].length === 0) throw new R$e()
      if (
        !this[Js].find(
          (s) => !s[QE] && s.closed !== true && s.destroyed !== true,
        ) ||
        this[Js].map((s) => s[QE]).reduce((s, o) => s && o, true)
      )
        return
      let n = 0,
        i = this[Js].findIndex((s) => !s[QE])
      for (; n++ < this[Js].length; ) {
        this[Rp] = (this[Rp] + 1) % this[Js].length
        let s = this[Js][this[Rp]]
        if (
          (s[Il] > this[Js][i][Il] && !s[QE] && (i = this[Rp]),
          this[Rp] === 0 &&
            ((this[Bp] = this[Bp] - this[qie]),
            this[Bp] <= 0 && (this[Bp] = this[KR])),
          s[Il] >= this[Bp] && !s[QE])
        )
          return s
      }
      return (this[Bp] = this[Js][i][Il]), (this[Rp] = i), this[Js][i]
    }
  }
  Vie.exports = qV
})
var W0 = _((LDt, Jie) => {
  "use strict"
  var { InvalidArgumentError: JR } = Jr(),
    {
      kClients: yh,
      kRunning: Wie,
      kClose: U$e,
      kDestroy: O$e,
      kDispatch: q$e,
      kInterceptors: V$e,
    } = Wn(),
    H$e = I0(),
    W$e = H0(),
    G$e = kE(),
    $$e = ir(),
    Y$e = WR(),
    Gie = Symbol("onConnect"),
    $ie = Symbol("onDisconnect"),
    Yie = Symbol("onConnectionError"),
    K$e = Symbol("maxRedirections"),
    Kie = Symbol("onDrain"),
    zie = Symbol("factory"),
    VV = Symbol("options")
  function z$e(e, t) {
    return t && t.connections === 1 ? new G$e(e, t) : new W$e(e, t)
  }
  var HV = class extends H$e {
    constructor({
      factory: t = z$e,
      maxRedirections: r = 0,
      connect: n,
      ...i
    } = {}) {
      if ((super(), typeof t != "function"))
        throw new JR("factory must be a function.")
      if (n != null && typeof n != "function" && typeof n != "object")
        throw new JR("connect must be a function or an object")
      if (!Number.isInteger(r) || r < 0)
        throw new JR("maxRedirections must be a positive number")
      n && typeof n != "function" && (n = { ...n }),
        (this[V$e] =
          i.interceptors?.Agent && Array.isArray(i.interceptors.Agent)
            ? i.interceptors.Agent
            : [Y$e({ maxRedirections: r })]),
        (this[VV] = { ...$$e.deepClone(i), connect: n }),
        (this[VV].interceptors = i.interceptors
          ? { ...i.interceptors }
          : undefined),
        (this[K$e] = r),
        (this[zie] = t),
        (this[yh] = new Map()),
        (this[Kie] = (s, o) => {
          this.emit("drain", s, [this, ...o])
        }),
        (this[Gie] = (s, o) => {
          this.emit("connect", s, [this, ...o])
        }),
        (this[$ie] = (s, o, a) => {
          this.emit("disconnect", s, [this, ...o], a)
        }),
        (this[Yie] = (s, o, a) => {
          this.emit("connectionError", s, [this, ...o], a)
        })
    }
    get [Wie]() {
      let t = 0
      for (let r of this[yh].values()) t += r[Wie]
      return t
    }
    [q$e](t, r) {
      let n
      if (t.origin && (typeof t.origin == "string" || t.origin instanceof URL))
        n = String(t.origin)
      else throw new JR("opts.origin must be a non-empty string or URL.")
      let i = this[yh].get(n)
      return (
        i ||
          ((i = this[zie](t.origin, this[VV])
            .on("drain", this[Kie])
            .on("connect", this[Gie])
            .on("disconnect", this[$ie])
            .on("connectionError", this[Yie])),
          this[yh].set(n, i)),
        i.dispatch(t, r)
      )
    }
    async [U$e]() {
      let t = []
      for (let r of this[yh].values()) t.push(r.close())
      this[yh].clear(), await Promise.all(t)
    }
    async [O$e](t) {
      let r = []
      for (let n of this[yh].values()) r.push(n.destroy(t))
      this[yh].clear(), await Promise.all(r)
    }
  }
  Jie.exports = HV
})
var $V = _((UDt, ese) => {
  "use strict"
  var { kProxy: J$e, kClose: j$e, kDestroy: Z$e, kInterceptors: X$e } = Wn(),
    { URL: NE } = require("url"),
    eYe = W0(),
    tYe = H0(),
    rYe = I0(),
    {
      InvalidArgumentError: XR,
      RequestAbortedError: nYe,
      SecureProxyConnectionError: iYe,
    } = Jr(),
    jie = fE(),
    jR = Symbol("proxy agent"),
    ZR = Symbol("proxy client"),
    PE = Symbol("proxy headers"),
    WV = Symbol("request tls settings"),
    Zie = Symbol("proxy tls settings"),
    Xie = Symbol("connect endpoint function")
  function sYe(e) {
    return e === "https:" ? 443 : 80
  }
  function oYe(e, t) {
    return new tYe(e, t)
  }
  var aYe = () => {},
    GV = class extends rYe {
      constructor(t) {
        if (
          (super(),
          !t || (typeof t == "object" && !(t instanceof NE) && !t.uri))
        )
          throw new XR("Proxy uri is mandatory")
        let { clientFactory: r = oYe } = t
        if (typeof r != "function")
          throw new XR("Proxy opts.clientFactory must be a function.")
        let n = this.#e(t),
          {
            href: i,
            origin: s,
            port: o,
            protocol: a,
            username: l,
            password: c,
            hostname: u,
          } = n
        if (
          ((this[J$e] = { uri: i, protocol: a }),
          (this[X$e] =
            t.interceptors?.ProxyAgent &&
            Array.isArray(t.interceptors.ProxyAgent)
              ? t.interceptors.ProxyAgent
              : []),
          (this[WV] = t.requestTls),
          (this[Zie] = t.proxyTls),
          (this[PE] = t.headers || {}),
          t.auth && t.token)
        )
          throw new XR(
            "opts.auth cannot be used in combination with opts.token",
          )
        t.auth
          ? (this[PE]["proxy-authorization"] = `Basic ${t.auth}`)
          : t.token
            ? (this[PE]["proxy-authorization"] = t.token)
            : l &&
              c &&
              (this[PE]["proxy-authorization"] =
                `Basic ${Buffer.from(`${decodeURIComponent(l)}:${decodeURIComponent(c)}`).toString("base64")}`)
        let f = jie({ ...t.proxyTls })
        ;(this[Xie] = jie({ ...t.requestTls })),
          (this[ZR] = r(n, { connect: f })),
          (this[jR] = new eYe({
            ...t,
            connect: async (p, g) => {
              let m = p.host
              p.port || (m += `:${sYe(p.protocol)}`)
              try {
                let { socket: y, statusCode: v } = await this[ZR].connect({
                  origin: s,
                  port: o,
                  path: m,
                  signal: p.signal,
                  headers: { ...this[PE], host: p.host },
                  servername: this[Zie]?.servername || u,
                })
                if (
                  (v !== 200 &&
                    (y.on("error", aYe).destroy(),
                    g(
                      new nYe(
                        `Proxy response (${v}) !== 200 when HTTP Tunneling`,
                      ),
                    )),
                  p.protocol !== "https:")
                ) {
                  g(null, y)
                  return
                }
                let C
                this[WV] ? (C = this[WV].servername) : (C = p.servername),
                  this[Xie]({ ...p, servername: C, httpSocket: y }, g)
              } catch (y) {
                y.code === "ERR_TLS_CERT_ALTNAME_INVALID" ? g(new iYe(y)) : g(y)
              }
            },
          }))
      }
      dispatch(t, r) {
        let n = lYe(t.headers)
        if ((cYe(n), n && !("host" in n) && !("Host" in n))) {
          let { host: i } = new NE(t.origin)
          n.host = i
        }
        return this[jR].dispatch({ ...t, headers: n }, r)
      }
      #e(t) {
        return typeof t == "string"
          ? new NE(t)
          : t instanceof NE
            ? t
            : new NE(t.uri)
      }
      async [j$e]() {
        await this[jR].close(), await this[ZR].close()
      }
      async [Z$e]() {
        await this[jR].destroy(), await this[ZR].destroy()
      }
    }
  function lYe(e) {
    if (Array.isArray(e)) {
      let t = {}
      for (let r = 0; r < e.length; r += 2) t[e[r]] = e[r + 1]
      return t
    }
    return e
  }
  function cYe(e) {
    if (
      e &&
      Object.keys(e).find((r) => r.toLowerCase() === "proxy-authorization")
    )
      throw new XR(
        "Proxy-Authorization should be sent in ProxyAgent constructor",
      )
  }
  ese.exports = GV
})
var ose = _((ODt, sse) => {
  "use strict"
  var uYe = I0(),
    {
      kClose: dYe,
      kDestroy: fYe,
      kClosed: tse,
      kDestroyed: rse,
      kDispatch: hYe,
      kNoProxyAgent: LE,
      kHttpProxyAgent: vh,
      kHttpsProxyAgent: Dp,
    } = Wn(),
    nse = $V(),
    gYe = W0(),
    pYe = { "http:": 80, "https:": 443 },
    ise = false,
    YV = class extends uYe {
      #e = null
      #t = null
      #i = null
      constructor(t = {}) {
        super(),
          (this.#i = t),
          ise ||
            ((ise = true),
            process.emitWarning(
              "EnvHttpProxyAgent is experimental, expect them to change at any time.",
              { code: "UNDICI-EHPA" },
            ))
        let { httpProxy: r, httpsProxy: n, noProxy: i, ...s } = t
        this[LE] = new gYe(s)
        let o = r ?? process.env.http_proxy ?? process.env.HTTP_PROXY
        o ? (this[vh] = new nse({ ...s, uri: o })) : (this[vh] = this[LE])
        let a = n ?? process.env.https_proxy ?? process.env.HTTPS_PROXY
        a ? (this[Dp] = new nse({ ...s, uri: a })) : (this[Dp] = this[vh]),
          this.#l()
      }
      [hYe](t, r) {
        let n = new URL(t.origin)
        return this.#n(n).dispatch(t, r)
      }
      async [dYe]() {
        await this[LE].close(),
          this[vh][tse] || (await this[vh].close()),
          this[Dp][tse] || (await this[Dp].close())
      }
      async [fYe](t) {
        await this[LE].destroy(t),
          this[vh][rse] || (await this[vh].destroy(t)),
          this[Dp][rse] || (await this[Dp].destroy(t))
      }
      #n(t) {
        let { protocol: r, host: n, port: i } = t
        return (
          (n = n.replace(/:\d*$/, "").toLowerCase()),
          (i = Number.parseInt(i, 10) || pYe[r] || 0),
          this.#r(n, i) ? (r === "https:" ? this[Dp] : this[vh]) : this[LE]
        )
      }
      #r(t, r) {
        if ((this.#o && this.#l(), this.#t.length === 0)) return true
        if (this.#e === "*") return false
        for (let n = 0; n < this.#t.length; n++) {
          let i = this.#t[n]
          if (!(i.port && i.port !== r)) {
            if (/^[.*]/.test(i.hostname)) {
              if (t.endsWith(i.hostname.replace(/^\*/, ""))) return false
            } else if (t === i.hostname) return false
          }
        }
        return true
      }
      #l() {
        let t = this.#i.noProxy ?? this.#u,
          r = t.split(/[,\s]/),
          n = []
        for (let i = 0; i < r.length; i++) {
          let s = r[i]
          if (!s) continue
          let o = s.match(/^(.+):(\d+)$/)
          n.push({
            hostname: (o ? o[1] : s).toLowerCase(),
            port: o ? Number.parseInt(o[2], 10) : 0,
          })
        }
        ;(this.#e = t), (this.#t = n)
      }
      get #o() {
        return this.#i.noProxy !== undefined ? false : this.#e !== this.#u
      }
      get #u() {
        return process.env.no_proxy ?? process.env.NO_PROXY ?? ""
      }
    }
  sse.exports = YV
})
var eD = _((qDt, use) => {
  "use strict"
  var G0 = require("assert"),
    { kRetryHandlerDefaultRetry: ase } = Wn(),
    { RequestRetryError: UE } = Jr(),
    {
      isDisturbed: lse,
      parseHeaders: mYe,
      parseRangeHeader: cse,
      wrapRequestBody: AYe,
    } = ir()
  function yYe(e) {
    let t = Date.now()
    return new Date(e).getTime() - t
  }
  var KV = class e {
    constructor(t, r) {
      let { retryOptions: n, ...i } = t,
        {
          retry: s,
          maxRetries: o,
          maxTimeout: a,
          minTimeout: l,
          timeoutFactor: c,
          methods: u,
          errorCodes: f,
          retryAfter: p,
          statusCodes: g,
        } = n ?? {}
      ;(this.dispatch = r.dispatch),
        (this.handler = r.handler),
        (this.opts = { ...i, body: AYe(t.body) }),
        (this.abort = null),
        (this.aborted = false),
        (this.retryOpts = {
          retry: s ?? e[ase],
          retryAfter: p ?? true,
          maxTimeout: a ?? 30 * 1e3,
          minTimeout: l ?? 500,
          timeoutFactor: c ?? 2,
          maxRetries: o ?? 5,
          methods: u ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
          statusCodes: g ?? [500, 502, 503, 504, 429],
          errorCodes: f ?? [
            "ECONNRESET",
            "ECONNREFUSED",
            "ENOTFOUND",
            "ENETDOWN",
            "ENETUNREACH",
            "EHOSTDOWN",
            "EHOSTUNREACH",
            "EPIPE",
            "UND_ERR_SOCKET",
          ],
        }),
        (this.retryCount = 0),
        (this.retryCountCheckpoint = 0),
        (this.start = 0),
        (this.end = null),
        (this.etag = null),
        (this.resume = null),
        this.handler.onConnect((m) => {
          ;(this.aborted = true), this.abort ? this.abort(m) : (this.reason = m)
        })
    }
    onRequestSent() {
      this.handler.onRequestSent && this.handler.onRequestSent()
    }
    onUpgrade(t, r, n) {
      this.handler.onUpgrade && this.handler.onUpgrade(t, r, n)
    }
    onConnect(t) {
      this.aborted ? t(this.reason) : (this.abort = t)
    }
    onBodySent(t) {
      if (this.handler.onBodySent) return this.handler.onBodySent(t)
    }
    static [ase](t, { state: r, opts: n }, i) {
      let { statusCode: s, code: o, headers: a } = t,
        { method: l, retryOptions: c } = n,
        {
          maxRetries: u,
          minTimeout: f,
          maxTimeout: p,
          timeoutFactor: g,
          statusCodes: m,
          errorCodes: y,
          methods: v,
        } = c,
        { counter: C } = r
      if (o && o !== "UND_ERR_REQ_RETRY" && !y.includes(o)) {
        i(t)
        return
      }
      if (Array.isArray(v) && !v.includes(l)) {
        i(t)
        return
      }
      if (s != null && Array.isArray(m) && !m.includes(s)) {
        i(t)
        return
      }
      if (C > u) {
        i(t)
        return
      }
      let E = a?.["retry-after"]
      E && ((E = Number(E)), (E = Number.isNaN(E) ? yYe(E) : E * 1e3))
      let w = E > 0 ? Math.min(E, p) : Math.min(f * g ** (C - 1), p)
      setTimeout(() => i(null), w)
    }
    onHeaders(t, r, n, i) {
      let s = mYe(r)
      if (((this.retryCount += 1), t >= 300))
        return this.retryOpts.statusCodes.includes(t) === false
          ? this.handler.onHeaders(t, r, n, i)
          : (this.abort(
              new UE("Request failed", t, {
                headers: s,
                data: { count: this.retryCount },
              }),
            ),
            false)
      if (this.resume != null) {
        if (((this.resume = null), t !== 206 && (this.start > 0 || t !== 200)))
          return (
            this.abort(
              new UE(
                "server does not support the range header and the payload was partially consumed",
                t,
                { headers: s, data: { count: this.retryCount } },
              ),
            ),
            false
          )
        let a = cse(s["content-range"])
        if (!a)
          return (
            this.abort(
              new UE("Content-Range mismatch", t, {
                headers: s,
                data: { count: this.retryCount },
              }),
            ),
            false
          )
        if (this.etag != null && this.etag !== s.etag)
          return (
            this.abort(
              new UE("ETag mismatch", t, {
                headers: s,
                data: { count: this.retryCount },
              }),
            ),
            false
          )
        let { start: l, size: c, end: u = c - 1 } = a
        return (
          G0(this.start === l, "content-range mismatch"),
          G0(this.end == null || this.end === u, "content-range mismatch"),
          (this.resume = n),
          true
        )
      }
      if (this.end == null) {
        if (t === 206) {
          let a = cse(s["content-range"])
          if (a == null) return this.handler.onHeaders(t, r, n, i)
          let { start: l, size: c, end: u = c - 1 } = a
          G0(l != null && Number.isFinite(l), "content-range mismatch"),
            G0(u != null && Number.isFinite(u), "invalid content-length"),
            (this.start = l),
            (this.end = u)
        }
        if (this.end == null) {
          let a = s["content-length"]
          this.end = a != null ? Number(a) - 1 : null
        }
        return (
          G0(Number.isFinite(this.start)),
          G0(
            this.end == null || Number.isFinite(this.end),
            "invalid content-length",
          ),
          (this.resume = n),
          (this.etag = s.etag != null ? s.etag : null),
          this.etag != null && this.etag.startsWith("W/") && (this.etag = null),
          this.handler.onHeaders(t, r, n, i)
        )
      }
      let o = new UE("Request failed", t, {
        headers: s,
        data: { count: this.retryCount },
      })
      return this.abort(o), false
    }
    onData(t) {
      return (this.start += t.length), this.handler.onData(t)
    }
    onComplete(t) {
      return (this.retryCount = 0), this.handler.onComplete(t)
    }
    onError(t) {
      if (this.aborted || lse(this.opts.body)) return this.handler.onError(t)
      this.retryCount - this.retryCountCheckpoint > 0
        ? (this.retryCount =
            this.retryCountCheckpoint +
            (this.retryCount - this.retryCountCheckpoint))
        : (this.retryCount += 1),
        this.retryOpts.retry(
          t,
          {
            state: { counter: this.retryCount },
            opts: { retryOptions: this.retryOpts, ...this.opts },
          },
          r.bind(this),
        )
      function r(n) {
        if (n != null || this.aborted || lse(this.opts.body))
          return this.handler.onError(n)
        if (this.start !== 0) {
          let i = { range: `bytes=${this.start}-${this.end ?? ""}` }
          this.etag != null && (i["if-match"] = this.etag),
            (this.opts = {
              ...this.opts,
              headers: { ...this.opts.headers, ...i },
            })
        }
        try {
          ;(this.retryCountCheckpoint = this.retryCount),
            this.dispatch(this.opts, this)
        } catch (i) {
          this.handler.onError(i)
        }
      }
    }
  }
  use.exports = KV
})
var fse = _((VDt, dse) => {
  "use strict"
  var vYe = uE(),
    CYe = eD(),
    zV = class extends vYe {
      #e = null
      #t = null
      constructor(t, r = {}) {
        super(r), (this.#e = t), (this.#t = r)
      }
      dispatch(t, r) {
        let n = new CYe(
          { ...t, retryOptions: this.#t },
          { dispatch: this.#e.dispatch.bind(this.#e), handler: r },
        )
        return this.#e.dispatch(t, n)
      }
      close() {
        return this.#e.close()
      }
      destroy() {
        return this.#e.destroy()
      }
    }
  dse.exports = zV
})
var tH = _((HDt, bse) => {
  "use strict"
  var Ase = require("assert"),
    { Readable: bYe } = require("stream"),
    {
      RequestAbortedError: yse,
      NotSupportedError: EYe,
      InvalidArgumentError: _Ye,
      AbortError: JV,
    } = Jr(),
    vse = ir(),
    { ReadableStreamFrom: xYe } = ir(),
    Ra = Symbol("kConsume"),
    OE = Symbol("kReading"),
    Ch = Symbol("kBody"),
    hse = Symbol("kAbort"),
    Cse = Symbol("kContentType"),
    gse = Symbol("kContentLength"),
    wYe = () => {},
    jV = class extends bYe {
      constructor({
        resume: t,
        abort: r,
        contentType: n = "",
        contentLength: i,
        highWaterMark: s = 64 * 1024,
      }) {
        super({ autoDestroy: true, read: t, highWaterMark: s }),
          (this._readableState.dataEmitted = false),
          (this[hse] = r),
          (this[Ra] = null),
          (this[Ch] = null),
          (this[Cse] = n),
          (this[gse] = i),
          (this[OE] = false)
      }
      destroy(t) {
        return (
          !t && !this._readableState.endEmitted && (t = new yse()),
          t && this[hse](),
          super.destroy(t)
        )
      }
      _destroy(t, r) {
        this[OE]
          ? r(t)
          : setImmediate(() => {
              r(t)
            })
      }
      on(t, ...r) {
        return (
          (t === "data" || t === "readable") && (this[OE] = true),
          super.on(t, ...r)
        )
      }
      addListener(t, ...r) {
        return this.on(t, ...r)
      }
      off(t, ...r) {
        let n = super.off(t, ...r)
        return (
          (t === "data" || t === "readable") &&
            (this[OE] =
              this.listenerCount("data") > 0 ||
              this.listenerCount("readable") > 0),
          n
        )
      }
      removeListener(t, ...r) {
        return this.off(t, ...r)
      }
      push(t) {
        return this[Ra] && t !== null
          ? (XV(this[Ra], t), this[OE] ? super.push(t) : true)
          : super.push(t)
      }
      async text() {
        return qE(this, "text")
      }
      async json() {
        return qE(this, "json")
      }
      async blob() {
        return qE(this, "blob")
      }
      async bytes() {
        return qE(this, "bytes")
      }
      async arrayBuffer() {
        return qE(this, "arrayBuffer")
      }
      async formData() {
        throw new EYe()
      }
      get bodyUsed() {
        return vse.isDisturbed(this)
      }
      get body() {
        return (
          this[Ch] ||
            ((this[Ch] = xYe(this)),
            this[Ra] && (this[Ch].getReader(), Ase(this[Ch].locked))),
          this[Ch]
        )
      }
      async dump(t) {
        let r = Number.isFinite(t?.limit) ? t.limit : 131072,
          n = t?.signal
        if (n != null && (typeof n != "object" || !("aborted" in n)))
          throw new _Ye("signal must be an AbortSignal")
        return (
          n?.throwIfAborted(),
          this._readableState.closeEmitted
            ? null
            : await new Promise((i, s) => {
                this[gse] > r && this.destroy(new JV())
                let o = () => {
                  this.destroy(n.reason ?? new JV())
                }
                n?.addEventListener("abort", o),
                  this.on("close", function () {
                    n?.removeEventListener("abort", o),
                      n?.aborted ? s(n.reason ?? new JV()) : i(null)
                  })
                    .on("error", wYe)
                    .on("data", function (a) {
                      ;(r -= a.length), r <= 0 && this.destroy()
                    })
                    .resume()
              })
        )
      }
    }
  function SYe(e) {
    return (e[Ch] && e[Ch].locked === true) || e[Ra]
  }
  function IYe(e) {
    return vse.isDisturbed(e) || SYe(e)
  }
  async function qE(e, t) {
    return (
      Ase(!e[Ra]),
      new Promise((r, n) => {
        if (IYe(e)) {
          let i = e._readableState
          i.destroyed && i.closeEmitted === false
            ? e
                .on("error", (s) => {
                  n(s)
                })
                .on("close", () => {
                  n(new TypeError("unusable"))
                })
            : n(i.errored ?? new TypeError("unusable"))
        } else
          queueMicrotask(() => {
            ;(e[Ra] = {
              type: t,
              stream: e,
              resolve: r,
              reject: n,
              length: 0,
              body: [],
            }),
              e
                .on("error", function (i) {
                  eH(this[Ra], i)
                })
                .on("close", function () {
                  this[Ra].body !== null && eH(this[Ra], new yse())
                }),
              BYe(e[Ra])
          })
      })
    )
  }
  function BYe(e) {
    if (e.body === null) return
    let { _readableState: t } = e.stream
    if (t.bufferIndex) {
      let r = t.bufferIndex,
        n = t.buffer.length
      for (let i = r; i < n; i++) XV(e, t.buffer[i])
    } else for (let r of t.buffer) XV(e, r)
    for (
      t.endEmitted
        ? mse(this[Ra])
        : e.stream.on("end", function () {
            mse(this[Ra])
          }),
        e.stream.resume();
      e.stream.read() != null;

    );
  }
  function ZV(e, t) {
    if (e.length === 0 || t === 0) return ""
    let r = e.length === 1 ? e[0] : Buffer.concat(e, t),
      n = r.length,
      i = n > 2 && r[0] === 239 && r[1] === 187 && r[2] === 191 ? 3 : 0
    return r.utf8Slice(i, n)
  }
  function pse(e, t) {
    if (e.length === 0 || t === 0) return new Uint8Array(0)
    if (e.length === 1) return new Uint8Array(e[0])
    let r = new Uint8Array(Buffer.allocUnsafeSlow(t).buffer),
      n = 0
    for (let i = 0; i < e.length; ++i) {
      let s = e[i]
      r.set(s, n), (n += s.length)
    }
    return r
  }
  function mse(e) {
    let { type: t, body: r, resolve: n, stream: i, length: s } = e
    try {
      t === "text"
        ? n(ZV(r, s))
        : t === "json"
          ? n(JSON.parse(ZV(r, s)))
          : t === "arrayBuffer"
            ? n(pse(r, s).buffer)
            : t === "blob"
              ? n(new Blob(r, { type: i[Cse] }))
              : t === "bytes" && n(pse(r, s)),
        eH(e)
    } catch (o) {
      i.destroy(o)
    }
  }
  function XV(e, t) {
    ;(e.length += t.length), e.body.push(t)
  }
  function eH(e, t) {
    e.body !== null &&
      (t ? e.reject(t) : e.resolve(),
      (e.type = null),
      (e.stream = null),
      (e.resolve = null),
      (e.reject = null),
      (e.length = 0),
      (e.body = null))
  }
  bse.exports = { Readable: jV, chunksDecode: ZV }
})
var rH = _((WDt, Sse) => {
  "use strict"
  var RYe = require("assert"),
    { ResponseStatusCodeError: Ese } = Jr(),
    { chunksDecode: _se } = tH(),
    DYe = 128 * 1024
  async function TYe({
    callback: e,
    body: t,
    contentType: r,
    statusCode: n,
    statusMessage: i,
    headers: s,
  }) {
    RYe(t)
    let o = [],
      a = 0
    try {
      for await (let f of t)
        if ((o.push(f), (a += f.length), a > DYe)) {
          ;(o = []), (a = 0)
          break
        }
    } catch {
      ;(o = []), (a = 0)
    }
    let l = `Response status code ${n}${i ? `: ${i}` : ""}`
    if (n === 204 || !r || !a) {
      queueMicrotask(() => e(new Ese(l, n, s)))
      return
    }
    let c = Error.stackTraceLimit
    Error.stackTraceLimit = 0
    let u
    try {
      xse(r) ? (u = JSON.parse(_se(o, a))) : wse(r) && (u = _se(o, a))
    } catch {
    } finally {
      Error.stackTraceLimit = c
    }
    queueMicrotask(() => e(new Ese(l, n, s, u)))
  }
  var xse = (e) =>
      e.length > 15 &&
      e[11] === "/" &&
      e[0] === "a" &&
      e[1] === "p" &&
      e[2] === "p" &&
      e[3] === "l" &&
      e[4] === "i" &&
      e[5] === "c" &&
      e[6] === "a" &&
      e[7] === "t" &&
      e[8] === "i" &&
      e[9] === "o" &&
      e[10] === "n" &&
      e[12] === "j" &&
      e[13] === "s" &&
      e[14] === "o" &&
      e[15] === "n",
    wse = (e) =>
      e.length > 4 &&
      e[4] === "/" &&
      e[0] === "t" &&
      e[1] === "e" &&
      e[2] === "x" &&
      e[3] === "t"
  Sse.exports = {
    getResolveErrorBodyCallback: TYe,
    isContentTypeApplicationJson: xse,
    isContentTypeText: wse,
  }
})
var Rse = _((GDt, nH) => {
  "use strict"
  var kYe = require("assert"),
    { Readable: MYe } = tH(),
    { InvalidArgumentError: $0, RequestAbortedError: Ise } = Jr(),
    Da = ir(),
    { getResolveErrorBodyCallback: FYe } = rH(),
    { AsyncResource: QYe } = require("async_hooks"),
    tD = class extends QYe {
      constructor(t, r) {
        if (!t || typeof t != "object") throw new $0("invalid opts")
        let {
          signal: n,
          method: i,
          opaque: s,
          body: o,
          onInfo: a,
          responseHeaders: l,
          throwOnError: c,
          highWaterMark: u,
        } = t
        try {
          if (typeof r != "function") throw new $0("invalid callback")
          if (u && (typeof u != "number" || u < 0))
            throw new $0("invalid highWaterMark")
          if (
            n &&
            typeof n.on != "function" &&
            typeof n.addEventListener != "function"
          )
            throw new $0("signal must be an EventEmitter or EventTarget")
          if (i === "CONNECT") throw new $0("invalid method")
          if (a && typeof a != "function")
            throw new $0("invalid onInfo callback")
          super("UNDICI_REQUEST")
        } catch (f) {
          throw (Da.isStream(o) && Da.destroy(o.on("error", Da.nop), f), f)
        }
        ;(this.method = i),
          (this.responseHeaders = l || null),
          (this.opaque = s || null),
          (this.callback = r),
          (this.res = null),
          (this.abort = null),
          (this.body = o),
          (this.trailers = {}),
          (this.context = null),
          (this.onInfo = a || null),
          (this.throwOnError = c),
          (this.highWaterMark = u),
          (this.signal = n),
          (this.reason = null),
          (this.removeAbortListener = null),
          Da.isStream(o) &&
            o.on("error", (f) => {
              this.onError(f)
            }),
          this.signal &&
            (this.signal.aborted
              ? (this.reason = this.signal.reason ?? new Ise())
              : (this.removeAbortListener = Da.addAbortListener(
                  this.signal,
                  () => {
                    ;(this.reason = this.signal.reason ?? new Ise()),
                      this.res
                        ? Da.destroy(this.res.on("error", Da.nop), this.reason)
                        : this.abort && this.abort(this.reason),
                      this.removeAbortListener &&
                        (this.res?.off("close", this.removeAbortListener),
                        this.removeAbortListener(),
                        (this.removeAbortListener = null))
                  },
                )))
      }
      onConnect(t, r) {
        if (this.reason) {
          t(this.reason)
          return
        }
        kYe(this.callback), (this.abort = t), (this.context = r)
      }
      onHeaders(t, r, n, i) {
        let {
            callback: s,
            opaque: o,
            abort: a,
            context: l,
            responseHeaders: c,
            highWaterMark: u,
          } = this,
          f = c === "raw" ? Da.parseRawHeaders(r) : Da.parseHeaders(r)
        if (t < 200) {
          this.onInfo && this.onInfo({ statusCode: t, headers: f })
          return
        }
        let p = c === "raw" ? Da.parseHeaders(r) : f,
          g = p["content-type"],
          m = p["content-length"],
          y = new MYe({
            resume: n,
            abort: a,
            contentType: g,
            contentLength: this.method !== "HEAD" && m ? Number(m) : null,
            highWaterMark: u,
          })
        this.removeAbortListener && y.on("close", this.removeAbortListener),
          (this.callback = null),
          (this.res = y),
          s !== null &&
            (this.throwOnError && t >= 400
              ? this.runInAsyncScope(FYe, null, {
                  callback: s,
                  body: y,
                  contentType: g,
                  statusCode: t,
                  statusMessage: i,
                  headers: f,
                })
              : this.runInAsyncScope(s, null, null, {
                  statusCode: t,
                  headers: f,
                  trailers: this.trailers,
                  opaque: o,
                  body: y,
                  context: l,
                }))
      }
      onData(t) {
        return this.res.push(t)
      }
      onComplete(t) {
        Da.parseHeaders(t, this.trailers), this.res.push(null)
      }
      onError(t) {
        let { res: r, callback: n, body: i, opaque: s } = this
        n &&
          ((this.callback = null),
          queueMicrotask(() => {
            this.runInAsyncScope(n, null, t, { opaque: s })
          })),
          r &&
            ((this.res = null),
            queueMicrotask(() => {
              Da.destroy(r, t)
            })),
          i && ((this.body = null), Da.destroy(i, t)),
          this.removeAbortListener &&
            (r?.off("close", this.removeAbortListener),
            this.removeAbortListener(),
            (this.removeAbortListener = null))
      }
    }
  function Bse(e, t) {
    if (t === undefined)
      return new Promise((r, n) => {
        Bse.call(this, e, (i, s) => (i ? n(i) : r(s)))
      })
    try {
      this.dispatch(e, new tD(e, t))
    } catch (r) {
      if (typeof t != "function") throw r
      let n = e?.opaque
      queueMicrotask(() => t(r, { opaque: n }))
    }
  }
  nH.exports = Bse
  nH.exports.RequestHandler = tD
})
var VE = _(($Dt, kse) => {
  "use strict"
  var { addAbortListener: NYe } = ir(),
    { RequestAbortedError: PYe } = Jr(),
    Y0 = Symbol("kListener"),
    Bu = Symbol("kSignal")
  function Dse(e) {
    e.abort ? e.abort(e[Bu]?.reason) : (e.reason = e[Bu]?.reason ?? new PYe()),
      Tse(e)
  }
  function LYe(e, t) {
    if (((e.reason = null), (e[Bu] = null), (e[Y0] = null), !!t)) {
      if (t.aborted) {
        Dse(e)
        return
      }
      ;(e[Bu] = t),
        (e[Y0] = () => {
          Dse(e)
        }),
        NYe(e[Bu], e[Y0])
    }
  }
  function Tse(e) {
    e[Bu] &&
      ("removeEventListener" in e[Bu]
        ? e[Bu].removeEventListener("abort", e[Y0])
        : e[Bu].removeListener("abort", e[Y0]),
      (e[Bu] = null),
      (e[Y0] = null))
  }
  kse.exports = { addSignal: LYe, removeSignal: Tse }
})
var Nse = _((YDt, Qse) => {
  "use strict"
  var UYe = require("assert"),
    { finished: OYe, PassThrough: qYe } = require("stream"),
    { InvalidArgumentError: K0, InvalidReturnValueError: VYe } = Jr(),
    Bc = ir(),
    { getResolveErrorBodyCallback: HYe } = rH(),
    { AsyncResource: WYe } = require("async_hooks"),
    { addSignal: GYe, removeSignal: Mse } = VE(),
    iH = class extends WYe {
      constructor(t, r, n) {
        if (!t || typeof t != "object") throw new K0("invalid opts")
        let {
          signal: i,
          method: s,
          opaque: o,
          body: a,
          onInfo: l,
          responseHeaders: c,
          throwOnError: u,
        } = t
        try {
          if (typeof n != "function") throw new K0("invalid callback")
          if (typeof r != "function") throw new K0("invalid factory")
          if (
            i &&
            typeof i.on != "function" &&
            typeof i.addEventListener != "function"
          )
            throw new K0("signal must be an EventEmitter or EventTarget")
          if (s === "CONNECT") throw new K0("invalid method")
          if (l && typeof l != "function")
            throw new K0("invalid onInfo callback")
          super("UNDICI_STREAM")
        } catch (f) {
          throw (Bc.isStream(a) && Bc.destroy(a.on("error", Bc.nop), f), f)
        }
        ;(this.responseHeaders = c || null),
          (this.opaque = o || null),
          (this.factory = r),
          (this.callback = n),
          (this.res = null),
          (this.abort = null),
          (this.context = null),
          (this.trailers = null),
          (this.body = a),
          (this.onInfo = l || null),
          (this.throwOnError = u || false),
          Bc.isStream(a) &&
            a.on("error", (f) => {
              this.onError(f)
            }),
          GYe(this, i)
      }
      onConnect(t, r) {
        if (this.reason) {
          t(this.reason)
          return
        }
        UYe(this.callback), (this.abort = t), (this.context = r)
      }
      onHeaders(t, r, n, i) {
        let {
            factory: s,
            opaque: o,
            context: a,
            callback: l,
            responseHeaders: c,
          } = this,
          u = c === "raw" ? Bc.parseRawHeaders(r) : Bc.parseHeaders(r)
        if (t < 200) {
          this.onInfo && this.onInfo({ statusCode: t, headers: u })
          return
        }
        this.factory = null
        let f
        if (this.throwOnError && t >= 400) {
          let m = (c === "raw" ? Bc.parseHeaders(r) : u)["content-type"]
          ;(f = new qYe()),
            (this.callback = null),
            this.runInAsyncScope(HYe, null, {
              callback: l,
              body: f,
              contentType: m,
              statusCode: t,
              statusMessage: i,
              headers: u,
            })
        } else {
          if (s === null) return
          if (
            ((f = this.runInAsyncScope(s, null, {
              statusCode: t,
              headers: u,
              opaque: o,
              context: a,
            })),
            !f ||
              typeof f.write != "function" ||
              typeof f.end != "function" ||
              typeof f.on != "function")
          )
            throw new VYe("expected Writable")
          OYe(f, { readable: false }, (g) => {
            let { callback: m, res: y, opaque: v, trailers: C, abort: E } = this
            ;(this.res = null),
              (g || !y.readable) && Bc.destroy(y, g),
              (this.callback = null),
              this.runInAsyncScope(m, null, g || null, {
                opaque: v,
                trailers: C,
              }),
              g && E()
          })
        }
        return (
          f.on("drain", n),
          (this.res = f),
          (f.writableNeedDrain !== undefined
            ? f.writableNeedDrain
            : f._writableState?.needDrain) !== true
        )
      }
      onData(t) {
        let { res: r } = this
        return r ? r.write(t) : true
      }
      onComplete(t) {
        let { res: r } = this
        Mse(this), r && ((this.trailers = Bc.parseHeaders(t)), r.end())
      }
      onError(t) {
        let { res: r, callback: n, opaque: i, body: s } = this
        Mse(this),
          (this.factory = null),
          r
            ? ((this.res = null), Bc.destroy(r, t))
            : n &&
              ((this.callback = null),
              queueMicrotask(() => {
                this.runInAsyncScope(n, null, t, { opaque: i })
              })),
          s && ((this.body = null), Bc.destroy(s, t))
      }
    }
  function Fse(e, t, r) {
    if (r === undefined)
      return new Promise((n, i) => {
        Fse.call(this, e, t, (s, o) => (s ? i(s) : n(o)))
      })
    try {
      this.dispatch(e, new iH(e, t, r))
    } catch (n) {
      if (typeof r != "function") throw n
      let i = e?.opaque
      queueMicrotask(() => r(n, { opaque: i }))
    }
  }
  Qse.exports = Fse
})
var Ose = _((KDt, Use) => {
  "use strict"
  var { Readable: Lse, Duplex: $Ye, PassThrough: YYe } = require("stream"),
    {
      InvalidArgumentError: HE,
      InvalidReturnValueError: KYe,
      RequestAbortedError: sH,
    } = Jr(),
    Bl = ir(),
    { AsyncResource: zYe } = require("async_hooks"),
    { addSignal: JYe, removeSignal: jYe } = VE(),
    Pse = require("assert"),
    z0 = Symbol("resume"),
    oH = class extends Lse {
      constructor() {
        super({ autoDestroy: true }), (this[z0] = null)
      }
      _read() {
        let { [z0]: t } = this
        t && ((this[z0] = null), t())
      }
      _destroy(t, r) {
        this._read(), r(t)
      }
    },
    aH = class extends Lse {
      constructor(t) {
        super({ autoDestroy: true }), (this[z0] = t)
      }
      _read() {
        this[z0]()
      }
      _destroy(t, r) {
        !t && !this._readableState.endEmitted && (t = new sH()), r(t)
      }
    },
    lH = class extends zYe {
      constructor(t, r) {
        if (!t || typeof t != "object") throw new HE("invalid opts")
        if (typeof r != "function") throw new HE("invalid handler")
        let {
          signal: n,
          method: i,
          opaque: s,
          onInfo: o,
          responseHeaders: a,
        } = t
        if (
          n &&
          typeof n.on != "function" &&
          typeof n.addEventListener != "function"
        )
          throw new HE("signal must be an EventEmitter or EventTarget")
        if (i === "CONNECT") throw new HE("invalid method")
        if (o && typeof o != "function") throw new HE("invalid onInfo callback")
        super("UNDICI_PIPELINE"),
          (this.opaque = s || null),
          (this.responseHeaders = a || null),
          (this.handler = r),
          (this.abort = null),
          (this.context = null),
          (this.onInfo = o || null),
          (this.req = new oH().on("error", Bl.nop)),
          (this.ret = new $Ye({
            readableObjectMode: t.objectMode,
            autoDestroy: true,
            read: () => {
              let { body: l } = this
              l?.resume && l.resume()
            },
            write: (l, c, u) => {
              let { req: f } = this
              f.push(l, c) || f._readableState.destroyed ? u() : (f[z0] = u)
            },
            destroy: (l, c) => {
              let { body: u, req: f, res: p, ret: g, abort: m } = this
              !l && !g._readableState.endEmitted && (l = new sH()),
                m && l && m(),
                Bl.destroy(u, l),
                Bl.destroy(f, l),
                Bl.destroy(p, l),
                jYe(this),
                c(l)
            },
          }).on("prefinish", () => {
            let { req: l } = this
            l.push(null)
          })),
          (this.res = null),
          JYe(this, n)
      }
      onConnect(t, r) {
        let { ret: n, res: i } = this
        if (this.reason) {
          t(this.reason)
          return
        }
        Pse(!i, "pipeline cannot be retried"),
          Pse(!n.destroyed),
          (this.abort = t),
          (this.context = r)
      }
      onHeaders(t, r, n) {
        let { opaque: i, handler: s, context: o } = this
        if (t < 200) {
          if (this.onInfo) {
            let l =
              this.responseHeaders === "raw"
                ? Bl.parseRawHeaders(r)
                : Bl.parseHeaders(r)
            this.onInfo({ statusCode: t, headers: l })
          }
          return
        }
        this.res = new aH(n)
        let a
        try {
          this.handler = null
          let l =
            this.responseHeaders === "raw"
              ? Bl.parseRawHeaders(r)
              : Bl.parseHeaders(r)
          a = this.runInAsyncScope(s, null, {
            statusCode: t,
            headers: l,
            opaque: i,
            body: this.res,
            context: o,
          })
        } catch (l) {
          throw (this.res.on("error", Bl.nop), l)
        }
        if (!a || typeof a.on != "function") throw new KYe("expected Readable")
        a
          .on("data", (l) => {
            let { ret: c, body: u } = this
            !c.push(l) && u.pause && u.pause()
          })
          .on("error", (l) => {
            let { ret: c } = this
            Bl.destroy(c, l)
          })
          .on("end", () => {
            let { ret: l } = this
            l.push(null)
          })
          .on("close", () => {
            let { ret: l } = this
            l._readableState.ended || Bl.destroy(l, new sH())
          }),
          (this.body = a)
      }
      onData(t) {
        let { res: r } = this
        return r.push(t)
      }
      onComplete(t) {
        let { res: r } = this
        r.push(null)
      }
      onError(t) {
        let { ret: r } = this
        ;(this.handler = null), Bl.destroy(r, t)
      }
    }
  function ZYe(e, t) {
    try {
      let r = new lH(e, t)
      return this.dispatch({ ...e, body: r.req }, r), r.ret
    } catch (r) {
      return new YYe().destroy(r)
    }
  }
  Use.exports = ZYe
})
var $se = _((zDt, Gse) => {
  "use strict"
  var { InvalidArgumentError: cH, SocketError: XYe } = Jr(),
    { AsyncResource: eKe } = require("async_hooks"),
    qse = ir(),
    { addSignal: tKe, removeSignal: Vse } = VE(),
    Hse = require("assert"),
    uH = class extends eKe {
      constructor(t, r) {
        if (!t || typeof t != "object") throw new cH("invalid opts")
        if (typeof r != "function") throw new cH("invalid callback")
        let { signal: n, opaque: i, responseHeaders: s } = t
        if (
          n &&
          typeof n.on != "function" &&
          typeof n.addEventListener != "function"
        )
          throw new cH("signal must be an EventEmitter or EventTarget")
        super("UNDICI_UPGRADE"),
          (this.responseHeaders = s || null),
          (this.opaque = i || null),
          (this.callback = r),
          (this.abort = null),
          (this.context = null),
          tKe(this, n)
      }
      onConnect(t, r) {
        if (this.reason) {
          t(this.reason)
          return
        }
        Hse(this.callback), (this.abort = t), (this.context = null)
      }
      onHeaders() {
        throw new XYe("bad upgrade", null)
      }
      onUpgrade(t, r, n) {
        Hse(t === 101)
        let { callback: i, opaque: s, context: o } = this
        Vse(this), (this.callback = null)
        let a =
          this.responseHeaders === "raw"
            ? qse.parseRawHeaders(r)
            : qse.parseHeaders(r)
        this.runInAsyncScope(i, null, null, {
          headers: a,
          socket: n,
          opaque: s,
          context: o,
        })
      }
      onError(t) {
        let { callback: r, opaque: n } = this
        Vse(this),
          r &&
            ((this.callback = null),
            queueMicrotask(() => {
              this.runInAsyncScope(r, null, t, { opaque: n })
            }))
      }
    }
  function Wse(e, t) {
    if (t === undefined)
      return new Promise((r, n) => {
        Wse.call(this, e, (i, s) => (i ? n(i) : r(s)))
      })
    try {
      let r = new uH(e, t)
      this.dispatch(
        { ...e, method: e.method || "GET", upgrade: e.protocol || "Websocket" },
        r,
      )
    } catch (r) {
      if (typeof t != "function") throw r
      let n = e?.opaque
      queueMicrotask(() => t(r, { opaque: n }))
    }
  }
  Gse.exports = Wse
})
var jse = _((JDt, Jse) => {
  "use strict"
  var rKe = require("assert"),
    { AsyncResource: nKe } = require("async_hooks"),
    { InvalidArgumentError: dH, SocketError: iKe } = Jr(),
    Yse = ir(),
    { addSignal: sKe, removeSignal: Kse } = VE(),
    fH = class extends nKe {
      constructor(t, r) {
        if (!t || typeof t != "object") throw new dH("invalid opts")
        if (typeof r != "function") throw new dH("invalid callback")
        let { signal: n, opaque: i, responseHeaders: s } = t
        if (
          n &&
          typeof n.on != "function" &&
          typeof n.addEventListener != "function"
        )
          throw new dH("signal must be an EventEmitter or EventTarget")
        super("UNDICI_CONNECT"),
          (this.opaque = i || null),
          (this.responseHeaders = s || null),
          (this.callback = r),
          (this.abort = null),
          sKe(this, n)
      }
      onConnect(t, r) {
        if (this.reason) {
          t(this.reason)
          return
        }
        rKe(this.callback), (this.abort = t), (this.context = r)
      }
      onHeaders() {
        throw new iKe("bad connect", null)
      }
      onUpgrade(t, r, n) {
        let { callback: i, opaque: s, context: o } = this
        Kse(this), (this.callback = null)
        let a = r
        a != null &&
          (a =
            this.responseHeaders === "raw"
              ? Yse.parseRawHeaders(r)
              : Yse.parseHeaders(r)),
          this.runInAsyncScope(i, null, null, {
            statusCode: t,
            headers: a,
            socket: n,
            opaque: s,
            context: o,
          })
      }
      onError(t) {
        let { callback: r, opaque: n } = this
        Kse(this),
          r &&
            ((this.callback = null),
            queueMicrotask(() => {
              this.runInAsyncScope(r, null, t, { opaque: n })
            }))
      }
    }
  function zse(e, t) {
    if (t === undefined)
      return new Promise((r, n) => {
        zse.call(this, e, (i, s) => (i ? n(i) : r(s)))
      })
    try {
      let r = new fH(e, t)
      this.dispatch({ ...e, method: "CONNECT" }, r)
    } catch (r) {
      if (typeof t != "function") throw r
      let n = e?.opaque
      queueMicrotask(() => t(r, { opaque: n }))
    }
  }
  Jse.exports = zse
})
var Zse = _((jDt, J0) => {
  "use strict"
  J0.exports.request = Rse()
  J0.exports.stream = Nse()
  J0.exports.pipeline = Ose()
  J0.exports.upgrade = $se()
  J0.exports.connect = jse()
})
var gH = _((ZDt, Xse) => {
  "use strict"
  var { UndiciError: oKe } = Jr(),
    hH = class e extends oKe {
      constructor(t) {
        super(t),
          Error.captureStackTrace(this, e),
          (this.name = "MockNotMatchedError"),
          (this.message =
            t || "The request does not match any registered mock dispatches"),
          (this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED")
      }
    }
  Xse.exports = { MockNotMatchedError: hH }
})
var j0 = _((XDt, eoe) => {
  "use strict"
  eoe.exports = {
    kAgent: Symbol("agent"),
    kOptions: Symbol("options"),
    kFactory: Symbol("factory"),
    kDispatches: Symbol("dispatches"),
    kDispatchKey: Symbol("dispatch key"),
    kDefaultHeaders: Symbol("default headers"),
    kDefaultTrailers: Symbol("default trailers"),
    kContentLength: Symbol("content length"),
    kMockAgent: Symbol("mock agent"),
    kMockAgentSet: Symbol("mock agent set"),
    kMockAgentGet: Symbol("mock agent get"),
    kMockDispatch: Symbol("mock dispatch"),
    kClose: Symbol("close"),
    kOriginalClose: Symbol("original agent close"),
    kOrigin: Symbol("origin"),
    kIsMockActive: Symbol("is mock active"),
    kNetConnect: Symbol("net connect"),
    kGetNetConnect: Symbol("get net connect"),
    kConnected: Symbol("connected"),
  }
})
var WE = _((eTt, doe) => {
  "use strict"
  var { MockNotMatchedError: Tp } = gH(),
    {
      kDispatches: rD,
      kMockAgent: aKe,
      kOriginalDispatch: lKe,
      kOrigin: cKe,
      kGetNetConnect: uKe,
    } = j0(),
    { buildURL: dKe } = ir(),
    { STATUS_CODES: fKe } = require("http"),
    {
      types: { isPromise: hKe },
    } = require("util")
  function $d(e, t) {
    return typeof e == "string"
      ? e === t
      : e instanceof RegExp
        ? e.test(t)
        : typeof e == "function"
          ? e(t) === true
          : false
  }
  function roe(e) {
    return Object.fromEntries(
      Object.entries(e).map(([t, r]) => [t.toLocaleLowerCase(), r]),
    )
  }
  function noe(e, t) {
    if (Array.isArray(e)) {
      for (let r = 0; r < e.length; r += 2)
        if (e[r].toLocaleLowerCase() === t.toLocaleLowerCase()) return e[r + 1]
      return
    } else
      return typeof e.get == "function"
        ? e.get(t)
        : roe(e)[t.toLocaleLowerCase()]
  }
  function AH(e) {
    let t = e.slice(),
      r = []
    for (let n = 0; n < t.length; n += 2) r.push([t[n], t[n + 1]])
    return Object.fromEntries(r)
  }
  function ioe(e, t) {
    if (typeof e.headers == "function")
      return Array.isArray(t) && (t = AH(t)), e.headers(t ? roe(t) : {})
    if (typeof e.headers > "u") return true
    if (typeof t != "object" || typeof e.headers != "object") return false
    for (let [r, n] of Object.entries(e.headers)) {
      let i = noe(t, r)
      if (!$d(n, i)) return false
    }
    return true
  }
  function toe(e) {
    if (typeof e != "string") return e
    let t = e.split("?")
    if (t.length !== 2) return e
    let r = new URLSearchParams(t.pop())
    return r.sort(), [...t, r.toString()].join("?")
  }
  function gKe(e, { path: t, method: r, body: n, headers: i }) {
    let s = $d(e.path, t),
      o = $d(e.method, r),
      a = typeof e.body < "u" ? $d(e.body, n) : true,
      l = ioe(e, i)
    return s && o && a && l
  }
  function soe(e) {
    return Buffer.isBuffer(e) ||
      e instanceof Uint8Array ||
      e instanceof ArrayBuffer
      ? e
      : typeof e == "object"
        ? JSON.stringify(e)
        : e.toString()
  }
  function ooe(e, t) {
    let r = t.query ? dKe(t.path, t.query) : t.path,
      n = typeof r == "string" ? toe(r) : r,
      i = e
        .filter(({ consumed: s }) => !s)
        .filter(({ path: s }) => $d(toe(s), n))
    if (i.length === 0)
      throw new Tp(`Mock dispatch not matched for path '${n}'`)
    if (((i = i.filter(({ method: s }) => $d(s, t.method))), i.length === 0))
      throw new Tp(
        `Mock dispatch not matched for method '${t.method}' on path '${n}'`,
      )
    if (
      ((i = i.filter(({ body: s }) => (typeof s < "u" ? $d(s, t.body) : true))),
      i.length === 0)
    )
      throw new Tp(
        `Mock dispatch not matched for body '${t.body}' on path '${n}'`,
      )
    if (((i = i.filter((s) => ioe(s, t.headers))), i.length === 0)) {
      let s =
        typeof t.headers == "object" ? JSON.stringify(t.headers) : t.headers
      throw new Tp(
        `Mock dispatch not matched for headers '${s}' on path '${n}'`,
      )
    }
    return i[0]
  }
  function pKe(e, t, r) {
    let n = { timesInvoked: 0, times: 1, persist: false, consumed: false },
      i = typeof r == "function" ? { callback: r } : { ...r },
      s = { ...n, ...t, pending: true, data: { error: null, ...i } }
    return e.push(s), s
  }
  function pH(e, t) {
    let r = e.findIndex((n) => (n.consumed ? gKe(n, t) : false))
    r !== -1 && e.splice(r, 1)
  }
  function aoe(e) {
    let { path: t, method: r, body: n, headers: i, query: s } = e
    return { path: t, method: r, body: n, headers: i, query: s }
  }
  function mH(e) {
    let t = Object.keys(e),
      r = []
    for (let n = 0; n < t.length; ++n) {
      let i = t[n],
        s = e[i],
        o = Buffer.from(`${i}`)
      if (Array.isArray(s))
        for (let a = 0; a < s.length; ++a) r.push(o, Buffer.from(`${s[a]}`))
      else r.push(o, Buffer.from(`${s}`))
    }
    return r
  }
  function loe(e) {
    return fKe[e] || "unknown"
  }
  async function mKe(e) {
    let t = []
    for await (let r of e) t.push(r)
    return Buffer.concat(t).toString("utf8")
  }
  function coe(e, t) {
    let r = aoe(e),
      n = ooe(this[rD], r)
    n.timesInvoked++,
      n.data.callback && (n.data = { ...n.data, ...n.data.callback(e) })
    let {
        data: { statusCode: i, data: s, headers: o, trailers: a, error: l },
        delay: c,
        persist: u,
      } = n,
      { timesInvoked: f, times: p } = n
    if (((n.consumed = !u && f >= p), (n.pending = f < p), l !== null))
      return pH(this[rD], r), t.onError(l), true
    typeof c == "number" && c > 0
      ? setTimeout(() => {
          g(this[rD])
        }, c)
      : g(this[rD])
    function g(y, v = s) {
      let C = Array.isArray(e.headers) ? AH(e.headers) : e.headers,
        E = typeof v == "function" ? v({ ...e, headers: C }) : v
      if (hKe(E)) {
        E.then((N) => g(y, N))
        return
      }
      let w = soe(E),
        B = mH(o),
        T = mH(a)
      t.onConnect?.((N) => t.onError(N), null),
        t.onHeaders?.(i, B, m, loe(i)),
        t.onData?.(Buffer.from(w)),
        t.onComplete?.(T),
        pH(y, r)
    }
    function m() {}
    return true
  }
  function AKe() {
    let e = this[aKe],
      t = this[cKe],
      r = this[lKe]
    return function (i, s) {
      if (e.isMockActive)
        try {
          coe.call(this, i, s)
        } catch (o) {
          if (o instanceof Tp) {
            let a = e[uKe]()
            if (a === false)
              throw new Tp(
                `${o.message}: subsequent request to origin ${t} was not allowed (net.connect disabled)`,
              )
            if (uoe(a, t)) r.call(this, i, s)
            else
              throw new Tp(
                `${o.message}: subsequent request to origin ${t} was not allowed (net.connect is not enabled for this origin)`,
              )
          } else throw o
        }
      else r.call(this, i, s)
    }
  }
  function uoe(e, t) {
    let r = new URL(t)
    return e === true ? true : !!(Array.isArray(e) && e.some((n) => $d(n, r.host)))
  }
  function yKe(e) {
    if (e) {
      let { agent: t, ...r } = e
      return r
    }
  }
  doe.exports = {
    getResponseData: soe,
    getMockDispatch: ooe,
    addMockDispatch: pKe,
    deleteMockDispatch: pH,
    buildKey: aoe,
    generateKeyValues: mH,
    matchValue: $d,
    getResponse: mKe,
    getStatusText: loe,
    mockDispatch: coe,
    buildMockDispatch: AKe,
    checkNetConnect: uoe,
    buildMockOptions: yKe,
    getHeaderByName: noe,
    buildHeadersFromArray: AH,
  }
})
var xH = _((tTt, _H) => {
  "use strict"
  var { getResponseData: vKe, buildKey: CKe, addMockDispatch: yH } = WE(),
    {
      kDispatches: nD,
      kDispatchKey: iD,
      kDefaultHeaders: vH,
      kDefaultTrailers: CH,
      kContentLength: bH,
      kMockDispatch: sD,
    } = j0(),
    { InvalidArgumentError: Ru } = Jr(),
    { buildURL: bKe } = ir(),
    Z0 = class {
      constructor(t) {
        this[sD] = t
      }
      delay(t) {
        if (typeof t != "number" || !Number.isInteger(t) || t <= 0)
          throw new Ru("waitInMs must be a valid integer > 0")
        return (this[sD].delay = t), this
      }
      persist() {
        return (this[sD].persist = true), this
      }
      times(t) {
        if (typeof t != "number" || !Number.isInteger(t) || t <= 0)
          throw new Ru("repeatTimes must be a valid integer > 0")
        return (this[sD].times = t), this
      }
    },
    EH = class {
      constructor(t, r) {
        if (typeof t != "object") throw new Ru("opts must be an object")
        if (typeof t.path > "u") throw new Ru("opts.path must be defined")
        if (
          (typeof t.method > "u" && (t.method = "GET"),
          typeof t.path == "string")
        )
          if (t.query) t.path = bKe(t.path, t.query)
          else {
            let n = new URL(t.path, "data://")
            t.path = n.pathname + n.search
          }
        typeof t.method == "string" && (t.method = t.method.toUpperCase()),
          (this[iD] = CKe(t)),
          (this[nD] = r),
          (this[vH] = {}),
          (this[CH] = {}),
          (this[bH] = false)
      }
      createMockScopeDispatchData({
        statusCode: t,
        data: r,
        responseOptions: n,
      }) {
        let i = vKe(r),
          s = this[bH] ? { "content-length": i.length } : {},
          o = { ...this[vH], ...s, ...n.headers },
          a = { ...this[CH], ...n.trailers }
        return { statusCode: t, data: r, headers: o, trailers: a }
      }
      validateReplyParameters(t) {
        if (typeof t.statusCode > "u")
          throw new Ru("statusCode must be defined")
        if (typeof t.responseOptions != "object" || t.responseOptions === null)
          throw new Ru("responseOptions must be an object")
      }
      reply(t) {
        if (typeof t == "function") {
          let s = (a) => {
              let l = t(a)
              if (typeof l != "object" || l === null)
                throw new Ru("reply options callback must return an object")
              let c = { data: "", responseOptions: {}, ...l }
              return (
                this.validateReplyParameters(c),
                { ...this.createMockScopeDispatchData(c) }
              )
            },
            o = yH(this[nD], this[iD], s)
          return new Z0(o)
        }
        let r = {
          statusCode: t,
          data: arguments[1] === undefined ? "" : arguments[1],
          responseOptions: arguments[2] === undefined ? {} : arguments[2],
        }
        this.validateReplyParameters(r)
        let n = this.createMockScopeDispatchData(r),
          i = yH(this[nD], this[iD], n)
        return new Z0(i)
      }
      replyWithError(t) {
        if (typeof t > "u") throw new Ru("error must be defined")
        let r = yH(this[nD], this[iD], { error: t })
        return new Z0(r)
      }
      defaultReplyHeaders(t) {
        if (typeof t > "u") throw new Ru("headers must be defined")
        return (this[vH] = t), this
      }
      defaultReplyTrailers(t) {
        if (typeof t > "u") throw new Ru("trailers must be defined")
        return (this[CH] = t), this
      }
      replyContentLength() {
        return (this[bH] = true), this
      }
    }
  _H.exports.MockInterceptor = EH
  _H.exports.MockScope = Z0
})
var IH = _((rTt, yoe) => {
  "use strict"
  var { promisify: EKe } = require("util"),
    _Ke = kE(),
    { buildMockDispatch: xKe } = WE(),
    {
      kDispatches: foe,
      kMockAgent: hoe,
      kClose: goe,
      kOriginalClose: poe,
      kOrigin: moe,
      kOriginalDispatch: wKe,
      kConnected: wH,
    } = j0(),
    { MockInterceptor: SKe } = xH(),
    Aoe = Wn(),
    { InvalidArgumentError: IKe } = Jr(),
    SH = class extends _Ke {
      constructor(t, r) {
        if (
          (super(t, r), !r || !r.agent || typeof r.agent.dispatch != "function")
        )
          throw new IKe("Argument opts.agent must implement Agent")
        ;(this[hoe] = r.agent),
          (this[moe] = t),
          (this[foe] = []),
          (this[wH] = 1),
          (this[wKe] = this.dispatch),
          (this[poe] = this.close.bind(this)),
          (this.dispatch = xKe.call(this)),
          (this.close = this[goe])
      }
      get [Aoe.kConnected]() {
        return this[wH]
      }
      intercept(t) {
        return new SKe(t, this[foe])
      }
      async [goe]() {
        await EKe(this[poe])(),
          (this[wH] = 0),
          this[hoe][Aoe.kClients].delete(this[moe])
      }
    }
  yoe.exports = SH
})
var DH = _((nTt, woe) => {
  "use strict"
  var { promisify: BKe } = require("util"),
    RKe = H0(),
    { buildMockDispatch: DKe } = WE(),
    {
      kDispatches: voe,
      kMockAgent: Coe,
      kClose: boe,
      kOriginalClose: Eoe,
      kOrigin: _oe,
      kOriginalDispatch: TKe,
      kConnected: BH,
    } = j0(),
    { MockInterceptor: kKe } = xH(),
    xoe = Wn(),
    { InvalidArgumentError: MKe } = Jr(),
    RH = class extends RKe {
      constructor(t, r) {
        if (
          (super(t, r), !r || !r.agent || typeof r.agent.dispatch != "function")
        )
          throw new MKe("Argument opts.agent must implement Agent")
        ;(this[Coe] = r.agent),
          (this[_oe] = t),
          (this[voe] = []),
          (this[BH] = 1),
          (this[TKe] = this.dispatch),
          (this[Eoe] = this.close.bind(this)),
          (this.dispatch = DKe.call(this)),
          (this.close = this[boe])
      }
      get [xoe.kConnected]() {
        return this[BH]
      }
      intercept(t) {
        return new kKe(t, this[voe])
      }
      async [boe]() {
        await BKe(this[Eoe])(),
          (this[BH] = 0),
          this[Coe][xoe.kClients].delete(this[_oe])
      }
    }
  woe.exports = RH
})
var Ioe = _((sTt, Soe) => {
  "use strict"
  var FKe = { pronoun: "it", is: "is", was: "was", this: "this" },
    QKe = { pronoun: "they", is: "are", was: "were", this: "these" }
  Soe.exports = class {
    constructor(t, r) {
      ;(this.singular = t), (this.plural = r)
    }
    pluralize(t) {
      let r = t === 1,
        n = r ? FKe : QKe,
        i = r ? this.singular : this.plural
      return { ...n, count: t, noun: i }
    }
  }
})
var Roe = _((aTt, Boe) => {
  "use strict"
  var { Transform: NKe } = require("stream"),
    { Console: PKe } = require("console"),
    LKe = process.versions.icu ? "\u2705" : "Y ",
    UKe = process.versions.icu ? "\u274C" : "N "
  Boe.exports = class {
    constructor({ disableColors: t } = {}) {
      ;(this.transform = new NKe({
        transform(r, n, i) {
          i(null, r)
        },
      })),
        (this.logger = new PKe({
          stdout: this.transform,
          inspectOptions: { colors: !t && !process.env.CI },
        }))
    }
    format(t) {
      let r = t.map(
        ({
          method: n,
          path: i,
          data: { statusCode: s },
          persist: o,
          times: a,
          timesInvoked: l,
          origin: c,
        }) => ({
          Method: n,
          Origin: c,
          Path: i,
          "Status code": s,
          Persistent: o ? LKe : UKe,
          Invocations: l,
          Remaining: o ? 1 / 0 : a - l,
        }),
      )
      return this.logger.table(r), this.transform.read().toString()
    }
  }
})
var Moe = _((lTt, koe) => {
  "use strict"
  var { kClients: kp } = Wn(),
    OKe = W0(),
    {
      kAgent: TH,
      kMockAgentSet: oD,
      kMockAgentGet: Doe,
      kDispatches: kH,
      kIsMockActive: aD,
      kNetConnect: Mp,
      kGetNetConnect: qKe,
      kOptions: lD,
      kFactory: cD,
    } = j0(),
    VKe = IH(),
    HKe = DH(),
    { matchValue: WKe, buildMockOptions: GKe } = WE(),
    { InvalidArgumentError: Toe, UndiciError: $Ke } = Jr(),
    YKe = uE(),
    KKe = Ioe(),
    zKe = Roe(),
    MH = class extends YKe {
      constructor(t) {
        if (
          (super(t),
          (this[Mp] = true),
          (this[aD] = true),
          t?.agent && typeof t.agent.dispatch != "function")
        )
          throw new Toe("Argument opts.agent must implement Agent")
        let r = t?.agent ? t.agent : new OKe(t)
        ;(this[TH] = r), (this[kp] = r[kp]), (this[lD] = GKe(t))
      }
      get(t) {
        let r = this[Doe](t)
        return r || ((r = this[cD](t)), this[oD](t, r)), r
      }
      dispatch(t, r) {
        return this.get(t.origin), this[TH].dispatch(t, r)
      }
      async close() {
        await this[TH].close(), this[kp].clear()
      }
      deactivate() {
        this[aD] = false
      }
      activate() {
        this[aD] = true
      }
      enableNetConnect(t) {
        if (
          typeof t == "string" ||
          typeof t == "function" ||
          t instanceof RegExp
        )
          Array.isArray(this[Mp]) ? this[Mp].push(t) : (this[Mp] = [t])
        else if (typeof t > "u") this[Mp] = true
        else
          throw new Toe(
            "Unsupported matcher. Must be one of String|Function|RegExp.",
          )
      }
      disableNetConnect() {
        this[Mp] = false
      }
      get isMockActive() {
        return this[aD]
      }
      [oD](t, r) {
        this[kp].set(t, r)
      }
      [cD](t) {
        let r = Object.assign({ agent: this }, this[lD])
        return this[lD] && this[lD].connections === 1
          ? new VKe(t, r)
          : new HKe(t, r)
      }
      [Doe](t) {
        let r = this[kp].get(t)
        if (r) return r
        if (typeof t != "string") {
          let n = this[cD]("http://localhost:9999")
          return this[oD](t, n), n
        }
        for (let [n, i] of Array.from(this[kp]))
          if (i && typeof n != "string" && WKe(n, t)) {
            let s = this[cD](t)
            return this[oD](t, s), (s[kH] = i[kH]), s
          }
      }
      [qKe]() {
        return this[Mp]
      }
      pendingInterceptors() {
        let t = this[kp]
        return Array.from(t.entries())
          .flatMap(([r, n]) => n[kH].map((i) => ({ ...i, origin: r })))
          .filter(({ pending: r }) => r)
      }
      assertNoPendingInterceptors({
        pendingInterceptorsFormatter: t = new zKe(),
      } = {}) {
        let r = this.pendingInterceptors()
        if (r.length === 0) return
        let n = new KKe("interceptor", "interceptors").pluralize(r.length)
        throw new $Ke(
          `
${n.count} ${n.noun} ${n.is} pending:

${t.format(r)}
`.trim(),
        )
      }
    }
  koe.exports = MH
})
var uD = _((cTt, Poe) => {
  "use strict"
  var Foe = Symbol.for("undici.globalDispatcher.1"),
    { InvalidArgumentError: JKe } = Jr(),
    jKe = W0()
  Noe() === undefined && Qoe(new jKe())
  function Qoe(e) {
    if (!e || typeof e.dispatch != "function")
      throw new JKe("Argument agent must implement Agent")
    Object.defineProperty(globalThis, Foe, {
      value: e,
      writable: true,
      enumerable: false,
      configurable: false,
    })
  }
  function Noe() {
    return globalThis[Foe]
  }
  Poe.exports = { setGlobalDispatcher: Qoe, getGlobalDispatcher: Noe }
})
var dD = _((dTt, Loe) => {
  "use strict"
  Loe.exports = class {
    #e
    constructor(t) {
      if (typeof t != "object" || t === null)
        throw new TypeError("handler must be an object")
      this.#e = t
    }
    onConnect(...t) {
      return this.#e.onConnect?.(...t)
    }
    onError(...t) {
      return this.#e.onError?.(...t)
    }
    onUpgrade(...t) {
      return this.#e.onUpgrade?.(...t)
    }
    onResponseStarted(...t) {
      return this.#e.onResponseStarted?.(...t)
    }
    onHeaders(...t) {
      return this.#e.onHeaders?.(...t)
    }
    onData(...t) {
      return this.#e.onData?.(...t)
    }
    onComplete(...t) {
      return this.#e.onComplete?.(...t)
    }
    onBodySent(...t) {
      return this.#e.onBodySent?.(...t)
    }
  }
})
var Ooe = _((fTt, Uoe) => {
  "use strict"
  var ZKe = HR()
  Uoe.exports = (e) => {
    let t = e?.maxRedirections
    return (r) =>
      function (i, s) {
        let { maxRedirections: o = t, ...a } = i
        if (!o) return r(i, s)
        let l = new ZKe(r, o, i, s)
        return r(a, l)
      }
  }
})
var Voe = _((hTt, qoe) => {
  "use strict"
  var XKe = eD()
  qoe.exports = (e) => (t) =>
    function (n, i) {
      return t(
        n,
        new XKe(
          { ...n, retryOptions: { ...e, ...n.retryOptions } },
          { handler: i, dispatch: t },
        ),
      )
    }
})
var Woe = _((gTt, Hoe) => {
  "use strict"
  var eze = ir(),
    { InvalidArgumentError: tze, RequestAbortedError: rze } = Jr(),
    nze = dD(),
    FH = class extends nze {
      #e = 1024 * 1024
      #t = null
      #i = false
      #n = false
      #r = 0
      #l = null
      #o = null
      constructor({ maxSize: t }, r) {
        if ((super(r), t != null && (!Number.isFinite(t) || t < 1)))
          throw new tze("maxSize must be a number greater than 0")
        ;(this.#e = t ?? this.#e), (this.#o = r)
      }
      onConnect(t) {
        ;(this.#t = t), this.#o.onConnect(this.#u.bind(this))
      }
      #u(t) {
        ;(this.#n = true), (this.#l = t)
      }
      onHeaders(t, r, n, i) {
        let o = eze.parseHeaders(r)["content-length"]
        if (o != null && o > this.#e)
          throw new rze(`Response size (${o}) larger than maxSize (${this.#e})`)
        return this.#n ? true : this.#o.onHeaders(t, r, n, i)
      }
      onError(t) {
        this.#i || ((t = this.#l ?? t), this.#o.onError(t))
      }
      onData(t) {
        return (
          (this.#r = this.#r + t.length),
          this.#r >= this.#e &&
            ((this.#i = true),
            this.#n ? this.#o.onError(this.#l) : this.#o.onComplete([])),
          true
        )
      }
      onComplete(t) {
        if (!this.#i) {
          if (this.#n) {
            this.#o.onError(this.reason)
            return
          }
          this.#o.onComplete(t)
        }
      }
    }
  function ize({ maxSize: e } = { maxSize: 1024 * 1024 }) {
    return (t) =>
      function (n, i) {
        let { dumpMaxSize: s = e } = n,
          o = new FH({ maxSize: s }, i)
        return t(n, o)
      }
  }
  Hoe.exports = ize
})
var Yoe = _((pTt, $oe) => {
  "use strict"
  var { isIP: sze } = require("net"),
    { lookup: oze } = require("dns"),
    aze = dD(),
    { InvalidArgumentError: X0, InformationalError: lze } = Jr(),
    Goe = Math.pow(2, 31) - 1,
    QH = class {
      #e = 0
      #t = 0
      #i = new Map()
      dualStack = true
      affinity = null
      lookup = null
      pick = null
      constructor(t) {
        ;(this.#e = t.maxTTL),
          (this.#t = t.maxItems),
          (this.dualStack = t.dualStack),
          (this.affinity = t.affinity),
          (this.lookup = t.lookup ?? this.#n),
          (this.pick = t.pick ?? this.#r)
      }
      get full() {
        return this.#i.size === this.#t
      }
      runLookup(t, r, n) {
        let i = this.#i.get(t.hostname)
        if (i == null && this.full) {
          n(null, t.origin)
          return
        }
        let s = {
          affinity: this.affinity,
          dualStack: this.dualStack,
          lookup: this.lookup,
          pick: this.pick,
          ...r.dns,
          maxTTL: this.#e,
          maxItems: this.#t,
        }
        if (i == null)
          this.lookup(t, s, (o, a) => {
            if (o || a == null || a.length === 0) {
              n(o ?? new lze("No DNS entries found"))
              return
            }
            this.setRecords(t, a)
            let l = this.#i.get(t.hostname),
              c = this.pick(t, l, s.affinity),
              u
            typeof c.port == "number"
              ? (u = `:${c.port}`)
              : t.port !== ""
                ? (u = `:${t.port}`)
                : (u = ""),
              n(
                null,
                `${t.protocol}//${c.family === 6 ? `[${c.address}]` : c.address}${u}`,
              )
          })
        else {
          let o = this.pick(t, i, s.affinity)
          if (o == null) {
            this.#i.delete(t.hostname), this.runLookup(t, r, n)
            return
          }
          let a
          typeof o.port == "number"
            ? (a = `:${o.port}`)
            : t.port !== ""
              ? (a = `:${t.port}`)
              : (a = ""),
            n(
              null,
              `${t.protocol}//${o.family === 6 ? `[${o.address}]` : o.address}${a}`,
            )
        }
      }
      #n(t, r, n) {
        oze(
          t.hostname,
          {
            all: true,
            family: this.dualStack === false ? this.affinity : 0,
            order: "ipv4first",
          },
          (i, s) => {
            if (i) return n(i)
            let o = new Map()
            for (let a of s) o.set(`${a.address}:${a.family}`, a)
            n(null, o.values())
          },
        )
      }
      #r(t, r, n) {
        let i = null,
          { records: s, offset: o } = r,
          a
        if (
          (this.dualStack
            ? (n == null &&
                (o == null || o === Goe
                  ? ((r.offset = 0), (n = 4))
                  : (r.offset++, (n = (r.offset & 1) === 1 ? 6 : 4))),
              s[n] != null && s[n].ips.length > 0
                ? (a = s[n])
                : (a = s[n === 4 ? 6 : 4]))
            : (a = s[n]),
          a == null || a.ips.length === 0)
        )
          return i
        a.offset == null || a.offset === Goe ? (a.offset = 0) : a.offset++
        let l = a.offset % a.ips.length
        return (
          (i = a.ips[l] ?? null),
          i == null
            ? i
            : Date.now() - i.timestamp > i.ttl
              ? (a.ips.splice(l, 1), this.pick(t, r, n))
              : i
        )
      }
      setRecords(t, r) {
        let n = Date.now(),
          i = { records: { 4: null, 6: null } }
        for (let s of r) {
          ;(s.timestamp = n),
            typeof s.ttl == "number"
              ? (s.ttl = Math.min(s.ttl, this.#e))
              : (s.ttl = this.#e)
          let o = i.records[s.family] ?? { ips: [] }
          o.ips.push(s), (i.records[s.family] = o)
        }
        this.#i.set(t.hostname, i)
      }
      getHandler(t, r) {
        return new NH(this, t, r)
      }
    },
    NH = class extends aze {
      #e = null
      #t = null
      #i = null
      #n = null
      #r = null
      constructor(t, { origin: r, handler: n, dispatch: i }, s) {
        super(n),
          (this.#r = r),
          (this.#n = n),
          (this.#t = { ...s }),
          (this.#e = t),
          (this.#i = i)
      }
      onError(t) {
        switch (t.code) {
          case "ETIMEDOUT":
          case "ECONNREFUSED": {
            if (this.#e.dualStack) {
              this.#e.runLookup(this.#r, this.#t, (r, n) => {
                if (r) return this.#n.onError(r)
                let i = { ...this.#t, origin: n }
                this.#i(i, this)
              })
              return
            }
            this.#n.onError(t)
            return
          }
          case "ENOTFOUND":
            this.#e.deleteRecord(this.#r)
          default:
            this.#n.onError(t)
            break
        }
      }
    }
  $oe.exports = (e) => {
    if (e?.maxTTL != null && (typeof e?.maxTTL != "number" || e?.maxTTL < 0))
      throw new X0("Invalid maxTTL. Must be a positive number")
    if (
      e?.maxItems != null &&
      (typeof e?.maxItems != "number" || e?.maxItems < 1)
    )
      throw new X0(
        "Invalid maxItems. Must be a positive number and greater than zero",
      )
    if (e?.affinity != null && e?.affinity !== 4 && e?.affinity !== 6)
      throw new X0("Invalid affinity. Must be either 4 or 6")
    if (e?.dualStack != null && typeof e?.dualStack != "boolean")
      throw new X0("Invalid dualStack. Must be a boolean")
    if (e?.lookup != null && typeof e?.lookup != "function")
      throw new X0("Invalid lookup. Must be a function")
    if (e?.pick != null && typeof e?.pick != "function")
      throw new X0("Invalid pick. Must be a function")
    let t = e?.dualStack ?? true,
      r
    t ? (r = e?.affinity ?? null) : (r = e?.affinity ?? 4)
    let n = {
        maxTTL: e?.maxTTL ?? 1e4,
        lookup: e?.lookup ?? null,
        pick: e?.pick ?? null,
        dualStack: t,
        affinity: r,
        maxItems: e?.maxItems ?? 1 / 0,
      },
      i = new QH(n)
    return (s) =>
      function (a, l) {
        let c = a.origin.constructor === URL ? a.origin : new URL(a.origin)
        return sze(c.hostname) !== 0
          ? s(a, l)
          : (i.runLookup(c, a, (u, f) => {
              if (u) return l.onError(u)
              let p = null
              ;(p = {
                ...a,
                servername: c.hostname,
                origin: f,
                headers: { host: c.hostname, ...a.headers },
              }),
                s(p, i.getHandler({ origin: c, dispatch: s, handler: l }, a))
            }),
            true)
      }
  }
})
var Fp = _((mTt, eae) => {
  "use strict"
  var { kConstruct: cze } = Wn(),
    { kEnumerableProperty: ey } = ir(),
    {
      iteratorMixin: uze,
      isValidHeaderName: GE,
      isValidHeaderValue: zoe,
    } = Ba(),
    { webidl: Br } = Is(),
    PH = require("assert"),
    fD = require("util"),
    Ti = Symbol("headers map"),
    Ta = Symbol("headers map sorted")
  function Koe(e) {
    return e === 10 || e === 13 || e === 9 || e === 32
  }
  function Joe(e) {
    let t = 0,
      r = e.length
    for (; r > t && Koe(e.charCodeAt(r - 1)); ) --r
    for (; r > t && Koe(e.charCodeAt(t)); ) ++t
    return t === 0 && r === e.length ? e : e.substring(t, r)
  }
  function joe(e, t) {
    if (Array.isArray(t))
      for (let r = 0; r < t.length; ++r) {
        let n = t[r]
        if (n.length !== 2)
          throw Br.errors.exception({
            header: "Headers constructor",
            message: `expected name/value pair to be length 2, found ${n.length}.`,
          })
        LH(e, n[0], n[1])
      }
    else if (typeof t == "object" && t !== null) {
      let r = Object.keys(t)
      for (let n = 0; n < r.length; ++n) LH(e, r[n], t[r[n]])
    } else
      throw Br.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: [
          "sequence<sequence<ByteString>>",
          "record<ByteString, ByteString>",
        ],
      })
  }
  function LH(e, t, r) {
    if (((r = Joe(r)), GE(t))) {
      if (!zoe(r))
        throw Br.errors.invalidArgument({
          prefix: "Headers.append",
          value: r,
          type: "header value",
        })
    } else
      throw Br.errors.invalidArgument({
        prefix: "Headers.append",
        value: t,
        type: "header name",
      })
    if (Xoe(e) === "immutable") throw new TypeError("immutable")
    return UH(e).append(t, r, false)
  }
  function Zoe(e, t) {
    return e[0] < t[0] ? -1 : 1
  }
  var hD = class e {
      cookies = null
      constructor(t) {
        t instanceof e
          ? ((this[Ti] = new Map(t[Ti])),
            (this[Ta] = t[Ta]),
            (this.cookies = t.cookies === null ? null : [...t.cookies]))
          : ((this[Ti] = new Map(t)), (this[Ta] = null))
      }
      contains(t, r) {
        return this[Ti].has(r ? t : t.toLowerCase())
      }
      clear() {
        this[Ti].clear(), (this[Ta] = null), (this.cookies = null)
      }
      append(t, r, n) {
        this[Ta] = null
        let i = n ? t : t.toLowerCase(),
          s = this[Ti].get(i)
        if (s) {
          let o = i === "cookie" ? "; " : ", "
          this[Ti].set(i, { name: s.name, value: `${s.value}${o}${r}` })
        } else this[Ti].set(i, { name: t, value: r })
        i === "set-cookie" && (this.cookies ??= []).push(r)
      }
      set(t, r, n) {
        this[Ta] = null
        let i = n ? t : t.toLowerCase()
        i === "set-cookie" && (this.cookies = [r]),
          this[Ti].set(i, { name: t, value: r })
      }
      delete(t, r) {
        ;(this[Ta] = null),
          r || (t = t.toLowerCase()),
          t === "set-cookie" && (this.cookies = null),
          this[Ti].delete(t)
      }
      get(t, r) {
        return this[Ti].get(r ? t : t.toLowerCase())?.value ?? null
      }
      *[Symbol.iterator]() {
        for (let {
          0: t,
          1: { value: r },
        } of this[Ti])
          yield [t, r]
      }
      get entries() {
        let t = {}
        if (this[Ti].size !== 0)
          for (let { name: r, value: n } of this[Ti].values()) t[r] = n
        return t
      }
      rawValues() {
        return this[Ti].values()
      }
      get entriesList() {
        let t = []
        if (this[Ti].size !== 0)
          for (let {
            0: r,
            1: { name: n, value: i },
          } of this[Ti])
            if (r === "set-cookie") for (let s of this.cookies) t.push([n, s])
            else t.push([n, i])
        return t
      }
      toSortedArray() {
        let t = this[Ti].size,
          r = new Array(t)
        if (t <= 32) {
          if (t === 0) return r
          let n = this[Ti][Symbol.iterator](),
            i = n.next().value
          ;(r[0] = [i[0], i[1].value]), PH(i[1].value !== null)
          for (let s = 1, o = 0, a = 0, l = 0, c = 0, u, f; s < t; ++s) {
            for (
              f = n.next().value,
                u = r[s] = [f[0], f[1].value],
                PH(u[1] !== null),
                l = 0,
                a = s;
              l < a;

            )
              (c = l + ((a - l) >> 1)), r[c][0] <= u[0] ? (l = c + 1) : (a = c)
            if (s !== c) {
              for (o = s; o > l; ) r[o] = r[--o]
              r[l] = u
            }
          }
          if (!n.next().done) throw new TypeError("Unreachable")
          return r
        } else {
          let n = 0
          for (let {
            0: i,
            1: { value: s },
          } of this[Ti])
            (r[n++] = [i, s]), PH(s !== null)
          return r.sort(Zoe)
        }
      }
    },
    Rc = class e {
      #e
      #t
      constructor(t = undefined) {
        Br.util.markAsUncloneable(this),
          t !== cze &&
            ((this.#t = new hD()),
            (this.#e = "none"),
            t !== undefined &&
              ((t = Br.converters.HeadersInit(t, "Headers contructor", "init")),
              joe(this, t)))
      }
      append(t, r) {
        Br.brandCheck(this, e),
          Br.argumentLengthCheck(arguments, 2, "Headers.append")
        let n = "Headers.append"
        return (
          (t = Br.converters.ByteString(t, n, "name")),
          (r = Br.converters.ByteString(r, n, "value")),
          LH(this, t, r)
        )
      }
      delete(t) {
        Br.brandCheck(this, e),
          Br.argumentLengthCheck(arguments, 1, "Headers.delete")
        let r = "Headers.delete"
        if (((t = Br.converters.ByteString(t, r, "name")), !GE(t)))
          throw Br.errors.invalidArgument({
            prefix: "Headers.delete",
            value: t,
            type: "header name",
          })
        if (this.#e === "immutable") throw new TypeError("immutable")
        this.#t.contains(t, false) && this.#t.delete(t, false)
      }
      get(t) {
        Br.brandCheck(this, e),
          Br.argumentLengthCheck(arguments, 1, "Headers.get")
        let r = "Headers.get"
        if (((t = Br.converters.ByteString(t, r, "name")), !GE(t)))
          throw Br.errors.invalidArgument({
            prefix: r,
            value: t,
            type: "header name",
          })
        return this.#t.get(t, false)
      }
      has(t) {
        Br.brandCheck(this, e),
          Br.argumentLengthCheck(arguments, 1, "Headers.has")
        let r = "Headers.has"
        if (((t = Br.converters.ByteString(t, r, "name")), !GE(t)))
          throw Br.errors.invalidArgument({
            prefix: r,
            value: t,
            type: "header name",
          })
        return this.#t.contains(t, false)
      }
      set(t, r) {
        Br.brandCheck(this, e),
          Br.argumentLengthCheck(arguments, 2, "Headers.set")
        let n = "Headers.set"
        if (
          ((t = Br.converters.ByteString(t, n, "name")),
          (r = Br.converters.ByteString(r, n, "value")),
          (r = Joe(r)),
          GE(t))
        ) {
          if (!zoe(r))
            throw Br.errors.invalidArgument({
              prefix: n,
              value: r,
              type: "header value",
            })
        } else
          throw Br.errors.invalidArgument({
            prefix: n,
            value: t,
            type: "header name",
          })
        if (this.#e === "immutable") throw new TypeError("immutable")
        this.#t.set(t, r, false)
      }
      getSetCookie() {
        Br.brandCheck(this, e)
        let t = this.#t.cookies
        return t ? [...t] : []
      }
      get [Ta]() {
        if (this.#t[Ta]) return this.#t[Ta]
        let t = [],
          r = this.#t.toSortedArray(),
          n = this.#t.cookies
        if (n === null || n.length === 1) return (this.#t[Ta] = r)
        for (let i = 0; i < r.length; ++i) {
          let { 0: s, 1: o } = r[i]
          if (s === "set-cookie")
            for (let a = 0; a < n.length; ++a) t.push([s, n[a]])
          else t.push([s, o])
        }
        return (this.#t[Ta] = t)
      }
      [fD.inspect.custom](t, r) {
        return (
          (r.depth ??= t), `Headers ${fD.formatWithOptions(r, this.#t.entries)}`
        )
      }
      static getHeadersGuard(t) {
        return t.#e
      }
      static setHeadersGuard(t, r) {
        t.#e = r
      }
      static getHeadersList(t) {
        return t.#t
      }
      static setHeadersList(t, r) {
        t.#t = r
      }
    },
    {
      getHeadersGuard: Xoe,
      setHeadersGuard: dze,
      getHeadersList: UH,
      setHeadersList: fze,
    } = Rc
  Reflect.deleteProperty(Rc, "getHeadersGuard")
  Reflect.deleteProperty(Rc, "setHeadersGuard")
  Reflect.deleteProperty(Rc, "getHeadersList")
  Reflect.deleteProperty(Rc, "setHeadersList")
  uze("Headers", Rc, Ta, 0, 1)
  Object.defineProperties(Rc.prototype, {
    append: ey,
    delete: ey,
    get: ey,
    has: ey,
    set: ey,
    getSetCookie: ey,
    [Symbol.toStringTag]: { value: "Headers", configurable: true },
    [fD.inspect.custom]: { enumerable: false },
  })
  Br.converters.HeadersInit = function (e, t, r) {
    if (Br.util.Type(e) === "Object") {
      let n = Reflect.get(e, Symbol.iterator)
      if (!fD.types.isProxy(e) && n === Rc.prototype.entries)
        try {
          return UH(e).entriesList
        } catch {}
      return typeof n == "function"
        ? Br.converters["sequence<sequence<ByteString>>"](e, t, r, n.bind(e))
        : Br.converters["record<ByteString, ByteString>"](e, t, r)
    }
    throw Br.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: [
        "sequence<sequence<ByteString>>",
        "record<ByteString, ByteString>",
      ],
    })
  }
  eae.exports = {
    fill: joe,
    compareHeaderName: Zoe,
    Headers: Rc,
    HeadersList: hD,
    getHeadersGuard: Xoe,
    setHeadersGuard: dze,
    setHeadersList: fze,
    getHeadersList: UH,
  }
})
var YE = _((ATt, uae) => {
  "use strict"
  var {
      Headers: oae,
      HeadersList: tae,
      fill: hze,
      getHeadersGuard: gze,
      setHeadersGuard: aae,
      setHeadersList: lae,
    } = Fp(),
    {
      extractBody: rae,
      cloneBody: pze,
      mixinBody: mze,
      hasFinalizationRegistry: Aze,
      streamRegistry: yze,
      bodyUnusable: vze,
    } = N0(),
    OH = ir(),
    nae = require("util"),
    { kEnumerableProperty: ka } = OH,
    {
      isValidReasonPhrase: Cze,
      isCancelled: bze,
      isAborted: Eze,
      isBlobLike: _ze,
      serializeJavascriptValueToJSONString: xze,
      isErrorLike: wze,
      isomorphicEncode: Sze,
      environmentSettingsObject: Ize,
    } = Ba(),
    { redirectStatusSet: Bze, nullBodyStatus: Rze } = hE(),
    { kState: ci, kHeaders: Yd } = uh(),
    { webidl: Kt } = Is(),
    { FormData: Dze } = vE(),
    { URLSerializer: iae } = zo(),
    { kConstruct: pD } = Wn(),
    qH = require("assert"),
    { types: Tze } = require("util"),
    kze = new TextEncoder("utf-8"),
    Qp = class e {
      static error() {
        return $E(mD(), "immutable")
      }
      static json(t, r = {}) {
        Kt.argumentLengthCheck(arguments, 1, "Response.json"),
          r !== null && (r = Kt.converters.ResponseInit(r))
        let n = kze.encode(xze(t)),
          i = rae(n),
          s = $E(ty({}), "response")
        return sae(s, r, { body: i[0], type: "application/json" }), s
      }
      static redirect(t, r = 302) {
        Kt.argumentLengthCheck(arguments, 1, "Response.redirect"),
          (t = Kt.converters.USVString(t)),
          (r = Kt.converters["unsigned short"](r))
        let n
        try {
          n = new URL(t, Ize.settingsObject.baseUrl)
        } catch (o) {
          throw new TypeError(`Failed to parse URL from ${t}`, { cause: o })
        }
        if (!Bze.has(r)) throw new RangeError(`Invalid status code ${r}`)
        let i = $E(ty({}), "immutable")
        i[ci].status = r
        let s = Sze(iae(n))
        return i[ci].headersList.append("location", s, true), i
      }
      constructor(t = null, r = {}) {
        if ((Kt.util.markAsUncloneable(this), t === pD)) return
        t !== null && (t = Kt.converters.BodyInit(t)),
          (r = Kt.converters.ResponseInit(r)),
          (this[ci] = ty({})),
          (this[Yd] = new oae(pD)),
          aae(this[Yd], "response"),
          lae(this[Yd], this[ci].headersList)
        let n = null
        if (t != null) {
          let [i, s] = rae(t)
          n = { body: i, type: s }
        }
        sae(this, r, n)
      }
      get type() {
        return Kt.brandCheck(this, e), this[ci].type
      }
      get url() {
        Kt.brandCheck(this, e)
        let t = this[ci].urlList,
          r = t[t.length - 1] ?? null
        return r === null ? "" : iae(r, true)
      }
      get redirected() {
        return Kt.brandCheck(this, e), this[ci].urlList.length > 1
      }
      get status() {
        return Kt.brandCheck(this, e), this[ci].status
      }
      get ok() {
        return (
          Kt.brandCheck(this, e),
          this[ci].status >= 200 && this[ci].status <= 299
        )
      }
      get statusText() {
        return Kt.brandCheck(this, e), this[ci].statusText
      }
      get headers() {
        return Kt.brandCheck(this, e), this[Yd]
      }
      get body() {
        return (
          Kt.brandCheck(this, e), this[ci].body ? this[ci].body.stream : null
        )
      }
      get bodyUsed() {
        return (
          Kt.brandCheck(this, e),
          !!this[ci].body && OH.isDisturbed(this[ci].body.stream)
        )
      }
      clone() {
        if ((Kt.brandCheck(this, e), vze(this)))
          throw Kt.errors.exception({
            header: "Response.clone",
            message: "Body has already been consumed.",
          })
        let t = VH(this[ci])
        return $E(t, gze(this[Yd]))
      }
      [nae.inspect.custom](t, r) {
        r.depth === null && (r.depth = 2), (r.colors ??= true)
        let n = {
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          body: this.body,
          bodyUsed: this.bodyUsed,
          ok: this.ok,
          redirected: this.redirected,
          type: this.type,
          url: this.url,
        }
        return `Response ${nae.formatWithOptions(r, n)}`
      }
    }
  mze(Qp)
  Object.defineProperties(Qp.prototype, {
    type: ka,
    url: ka,
    status: ka,
    ok: ka,
    redirected: ka,
    statusText: ka,
    headers: ka,
    clone: ka,
    body: ka,
    bodyUsed: ka,
    [Symbol.toStringTag]: { value: "Response", configurable: true },
  })
  Object.defineProperties(Qp, { json: ka, redirect: ka, error: ka })
  function VH(e) {
    if (e.internalResponse) return cae(VH(e.internalResponse), e.type)
    let t = ty({ ...e, body: null })
    return e.body != null && (t.body = pze(t, e.body)), t
  }
  function ty(e) {
    return {
      aborted: false,
      rangeRequested: false,
      timingAllowPassed: false,
      requestIncludesCredentials: false,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...e,
      headersList: e?.headersList ? new tae(e?.headersList) : new tae(),
      urlList: e?.urlList ? [...e.urlList] : [],
    }
  }
  function mD(e) {
    let t = wze(e)
    return ty({
      type: "error",
      status: 0,
      error: t ? e : new Error(e && String(e)),
      aborted: e && e.name === "AbortError",
    })
  }
  function Mze(e) {
    return e.type === "error" && e.status === 0
  }
  function gD(e, t) {
    return (
      (t = { internalResponse: e, ...t }),
      new Proxy(e, {
        get(r, n) {
          return n in t ? t[n] : r[n]
        },
        set(r, n, i) {
          return qH(!(n in t)), (r[n] = i), true
        },
      })
    )
  }
  function cae(e, t) {
    if (t === "basic")
      return gD(e, { type: "basic", headersList: e.headersList })
    if (t === "cors") return gD(e, { type: "cors", headersList: e.headersList })
    if (t === "opaque")
      return gD(e, {
        type: "opaque",
        urlList: Object.freeze([]),
        status: 0,
        statusText: "",
        body: null,
      })
    if (t === "opaqueredirect")
      return gD(e, {
        type: "opaqueredirect",
        status: 0,
        statusText: "",
        headersList: [],
        body: null,
      })
    qH(false)
  }
  function Fze(e, t = null) {
    return (
      qH(bze(e)),
      Eze(e)
        ? mD(
            Object.assign(
              new DOMException("The operation was aborted.", "AbortError"),
              { cause: t },
            ),
          )
        : mD(
            Object.assign(new DOMException("Request was cancelled."), {
              cause: t,
            }),
          )
    )
  }
  function sae(e, t, r) {
    if (t.status !== null && (t.status < 200 || t.status > 599))
      throw new RangeError(
        'init["status"] must be in the range of 200 to 599, inclusive.',
      )
    if ("statusText" in t && t.statusText != null && !Cze(String(t.statusText)))
      throw new TypeError("Invalid statusText")
    if (
      ("status" in t && t.status != null && (e[ci].status = t.status),
      "statusText" in t &&
        t.statusText != null &&
        (e[ci].statusText = t.statusText),
      "headers" in t && t.headers != null && hze(e[Yd], t.headers),
      r)
    ) {
      if (Rze.includes(e.status))
        throw Kt.errors.exception({
          header: "Response constructor",
          message: `Invalid response status code ${e.status}`,
        })
      ;(e[ci].body = r.body),
        r.type != null &&
          !e[ci].headersList.contains("content-type", true) &&
          e[ci].headersList.append("content-type", r.type, true)
    }
  }
  function $E(e, t) {
    let r = new Qp(pD)
    return (
      (r[ci] = e),
      (r[Yd] = new oae(pD)),
      lae(r[Yd], e.headersList),
      aae(r[Yd], t),
      Aze && e.body?.stream && yze.register(r, new WeakRef(e.body.stream)),
      r
    )
  }
  Kt.converters.ReadableStream = Kt.interfaceConverter(ReadableStream)
  Kt.converters.FormData = Kt.interfaceConverter(Dze)
  Kt.converters.URLSearchParams = Kt.interfaceConverter(URLSearchParams)
  Kt.converters.XMLHttpRequestBodyInit = function (e, t, r) {
    return typeof e == "string"
      ? Kt.converters.USVString(e, t, r)
      : _ze(e)
        ? Kt.converters.Blob(e, t, r, { strict: false })
        : ArrayBuffer.isView(e) || Tze.isArrayBuffer(e)
          ? Kt.converters.BufferSource(e, t, r)
          : OH.isFormDataLike(e)
            ? Kt.converters.FormData(e, t, r, { strict: false })
            : e instanceof URLSearchParams
              ? Kt.converters.URLSearchParams(e, t, r)
              : Kt.converters.DOMString(e, t, r)
  }
  Kt.converters.BodyInit = function (e, t, r) {
    return e instanceof ReadableStream
      ? Kt.converters.ReadableStream(e, t, r)
      : e?.[Symbol.asyncIterator]
        ? e
        : Kt.converters.XMLHttpRequestBodyInit(e, t, r)
  }
  Kt.converters.ResponseInit = Kt.dictionaryConverter([
    {
      key: "status",
      converter: Kt.converters["unsigned short"],
      defaultValue: () => 200,
    },
    {
      key: "statusText",
      converter: Kt.converters.ByteString,
      defaultValue: () => "",
    },
    { key: "headers", converter: Kt.converters.HeadersInit },
  ])
  uae.exports = {
    isNetworkError: Mze,
    makeNetworkError: mD,
    makeResponse: ty,
    makeAppropriateNetworkError: Fze,
    filterResponse: cae,
    Response: Qp,
    cloneResponse: VH,
    fromInnerResponse: $E,
  }
})
var gae = _((yTt, hae) => {
  "use strict"
  var { kConnected: dae, kSize: fae } = Wn(),
    HH = class {
      constructor(t) {
        this.value = t
      }
      deref() {
        return this.value[dae] === 0 && this.value[fae] === 0
          ? undefined
          : this.value
      }
    },
    WH = class {
      constructor(t) {
        this.finalizer = t
      }
      register(t, r) {
        t.on &&
          t.on("disconnect", () => {
            t[dae] === 0 && t[fae] === 0 && this.finalizer(r)
          })
      }
      unregister(t) {}
    }
  hae.exports = function () {
    return process.env.NODE_V8_COVERAGE && process.version.startsWith("v18")
      ? (process._rawDebug(
          "Using compatibility WeakRef and FinalizationRegistry",
        ),
        { WeakRef: HH, FinalizationRegistry: WH })
      : { WeakRef, FinalizationRegistry }
  }
})
var ry = _((vTt, Rae) => {
  "use strict"
  var {
      extractBody: Qze,
      mixinBody: Nze,
      cloneBody: Pze,
      bodyUnusable: pae,
    } = N0(),
    {
      Headers: xae,
      fill: Lze,
      HeadersList: CD,
      setHeadersGuard: $H,
      getHeadersGuard: Uze,
      setHeadersList: wae,
      getHeadersList: mae,
    } = Fp(),
    { FinalizationRegistry: Oze } = gae()(),
    yD = ir(),
    Aae = require("util"),
    {
      isValidHTTPToken: qze,
      sameOrigin: yae,
      environmentSettingsObject: AD,
    } = Ba(),
    {
      forbiddenMethodsSet: Vze,
      corsSafeListedMethodsSet: Hze,
      referrerPolicy: Wze,
      requestRedirect: Gze,
      requestMode: $ze,
      requestCredentials: Yze,
      requestCache: Kze,
      requestDuplex: zze,
    } = hE(),
    {
      kEnumerableProperty: ki,
      normalizedMethodRecordsBase: Jze,
      normalizedMethodRecords: jze,
    } = yD,
    { kHeaders: Ma, kSignal: vD, kState: Fn, kDispatcher: GH } = uh(),
    { webidl: gt } = Is(),
    { URLSerializer: Zze } = zo(),
    { kConstruct: bD } = Wn(),
    Xze = require("assert"),
    {
      getMaxListeners: vae,
      setMaxListeners: Cae,
      getEventListeners: eJe,
      defaultMaxListeners: bae,
    } = require("events"),
    tJe = Symbol("abortController"),
    Sae = new Oze(({ signal: e, abort: t }) => {
      e.removeEventListener("abort", t)
    }),
    ED = new WeakMap()
  function Eae(e) {
    return t
    function t() {
      let r = e.deref()
      if (r !== undefined) {
        Sae.unregister(t),
          this.removeEventListener("abort", t),
          r.abort(this.reason)
        let n = ED.get(r.signal)
        if (n !== undefined) {
          if (n.size !== 0) {
            for (let i of n) {
              let s = i.deref()
              s !== undefined && s.abort(this.reason)
            }
            n.clear()
          }
          ED.delete(r.signal)
        }
      }
    }
  }
  var _ae = false,
    bh = class e {
      constructor(t, r = {}) {
        if ((gt.util.markAsUncloneable(this), t === bD)) return
        let n = "Request constructor"
        gt.argumentLengthCheck(arguments, 1, n),
          (t = gt.converters.RequestInfo(t, n, "input")),
          (r = gt.converters.RequestInit(r, n, "init"))
        let i = null,
          s = null,
          o = AD.settingsObject.baseUrl,
          a = null
        if (typeof t == "string") {
          this[GH] = r.dispatcher
          let C
          try {
            C = new URL(t, o)
          } catch (E) {
            throw new TypeError("Failed to parse URL from " + t, { cause: E })
          }
          if (C.username || C.password)
            throw new TypeError(
              "Request cannot be constructed from a URL that includes credentials: " +
                t,
            )
          ;(i = _D({ urlList: [C] })), (s = "cors")
        } else
          (this[GH] = r.dispatcher || t[GH]),
            Xze(t instanceof e),
            (i = t[Fn]),
            (a = t[vD])
        let l = AD.settingsObject.origin,
          c = "client"
        if (
          (i.window?.constructor?.name === "EnvironmentSettingsObject" &&
            yae(i.window, l) &&
            (c = i.window),
          r.window != null)
        )
          throw new TypeError(`'window' option '${c}' must be null`)
        "window" in r && (c = "no-window"),
          (i = _D({
            method: i.method,
            headersList: i.headersList,
            unsafeRequest: i.unsafeRequest,
            client: AD.settingsObject,
            window: c,
            priority: i.priority,
            origin: i.origin,
            referrer: i.referrer,
            referrerPolicy: i.referrerPolicy,
            mode: i.mode,
            credentials: i.credentials,
            cache: i.cache,
            redirect: i.redirect,
            integrity: i.integrity,
            keepalive: i.keepalive,
            reloadNavigation: i.reloadNavigation,
            historyNavigation: i.historyNavigation,
            urlList: [...i.urlList],
          }))
        let u = Object.keys(r).length !== 0
        if (
          (u &&
            (i.mode === "navigate" && (i.mode = "same-origin"),
            (i.reloadNavigation = false),
            (i.historyNavigation = false),
            (i.origin = "client"),
            (i.referrer = "client"),
            (i.referrerPolicy = ""),
            (i.url = i.urlList[i.urlList.length - 1]),
            (i.urlList = [i.url])),
          r.referrer !== undefined)
        ) {
          let C = r.referrer
          if (C === "") i.referrer = "no-referrer"
          else {
            let E
            try {
              E = new URL(C, o)
            } catch (w) {
              throw new TypeError(`Referrer "${C}" is not a valid URL.`, {
                cause: w,
              })
            }
            ;(E.protocol === "about:" && E.hostname === "client") ||
            (l && !yae(E, AD.settingsObject.baseUrl))
              ? (i.referrer = "client")
              : (i.referrer = E)
          }
        }
        r.referrerPolicy !== undefined && (i.referrerPolicy = r.referrerPolicy)
        let f
        if ((r.mode !== undefined ? (f = r.mode) : (f = s), f === "navigate"))
          throw gt.errors.exception({
            header: "Request constructor",
            message: "invalid request mode navigate.",
          })
        if (
          (f != null && (i.mode = f),
          r.credentials !== undefined && (i.credentials = r.credentials),
          r.cache !== undefined && (i.cache = r.cache),
          i.cache === "only-if-cached" && i.mode !== "same-origin")
        )
          throw new TypeError(
            "'only-if-cached' can be set only with 'same-origin' mode",
          )
        if (
          (r.redirect !== undefined && (i.redirect = r.redirect),
          r.integrity != null && (i.integrity = String(r.integrity)),
          r.keepalive !== undefined && (i.keepalive = !!r.keepalive),
          r.method !== undefined)
        ) {
          let C = r.method,
            E = jze[C]
          if (E !== undefined) i.method = E
          else {
            if (!qze(C))
              throw new TypeError(`'${C}' is not a valid HTTP method.`)
            let w = C.toUpperCase()
            if (Vze.has(w))
              throw new TypeError(`'${C}' HTTP method is unsupported.`)
            ;(C = Jze[w] ?? C), (i.method = C)
          }
          !_ae &&
            i.method === "patch" &&
            (process.emitWarning(
              "Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.",
              { code: "UNDICI-FETCH-patch" },
            ),
            (_ae = true))
        }
        r.signal !== undefined && (a = r.signal), (this[Fn] = i)
        let p = new AbortController()
        if (((this[vD] = p.signal), a != null)) {
          if (
            !a ||
            typeof a.aborted != "boolean" ||
            typeof a.addEventListener != "function"
          )
            throw new TypeError(
              "Failed to construct 'Request': member signal is not of type AbortSignal.",
            )
          if (a.aborted) p.abort(a.reason)
          else {
            this[tJe] = p
            let C = new WeakRef(p),
              E = Eae(C)
            try {
              ;((typeof vae == "function" && vae(a) === bae) ||
                eJe(a, "abort").length >= bae) &&
                Cae(1500, a)
            } catch {}
            yD.addAbortListener(a, E),
              Sae.register(p, { signal: a, abort: E }, E)
          }
        }
        if (
          ((this[Ma] = new xae(bD)),
          wae(this[Ma], i.headersList),
          $H(this[Ma], "request"),
          f === "no-cors")
        ) {
          if (!Hze.has(i.method))
            throw new TypeError(`'${i.method} is unsupported in no-cors mode.`)
          $H(this[Ma], "request-no-cors")
        }
        if (u) {
          let C = mae(this[Ma]),
            E = r.headers !== undefined ? r.headers : new CD(C)
          if ((C.clear(), E instanceof CD)) {
            for (let { name: w, value: B } of E.rawValues()) C.append(w, B, false)
            C.cookies = E.cookies
          } else Lze(this[Ma], E)
        }
        let g = t instanceof e ? t[Fn].body : null
        if (
          (r.body != null || g != null) &&
          (i.method === "GET" || i.method === "HEAD")
        )
          throw new TypeError("Request with GET/HEAD method cannot have body.")
        let m = null
        if (r.body != null) {
          let [C, E] = Qze(r.body, i.keepalive)
          ;(m = C),
            E &&
              !mae(this[Ma]).contains("content-type", true) &&
              this[Ma].append("content-type", E)
        }
        let y = m ?? g
        if (y != null && y.source == null) {
          if (m != null && r.duplex == null)
            throw new TypeError(
              "RequestInit: duplex option is required when sending a body.",
            )
          if (i.mode !== "same-origin" && i.mode !== "cors")
            throw new TypeError(
              'If request is made from ReadableStream, mode should be "same-origin" or "cors"',
            )
          i.useCORSPreflightFlag = true
        }
        let v = y
        if (m == null && g != null) {
          if (pae(t))
            throw new TypeError(
              "Cannot construct a Request with a Request object that has already been used.",
            )
          let C = new TransformStream()
          g.stream.pipeThrough(C),
            (v = { source: g.source, length: g.length, stream: C.readable })
        }
        this[Fn].body = v
      }
      get method() {
        return gt.brandCheck(this, e), this[Fn].method
      }
      get url() {
        return gt.brandCheck(this, e), Zze(this[Fn].url)
      }
      get headers() {
        return gt.brandCheck(this, e), this[Ma]
      }
      get destination() {
        return gt.brandCheck(this, e), this[Fn].destination
      }
      get referrer() {
        return (
          gt.brandCheck(this, e),
          this[Fn].referrer === "no-referrer"
            ? ""
            : this[Fn].referrer === "client"
              ? "about:client"
              : this[Fn].referrer.toString()
        )
      }
      get referrerPolicy() {
        return gt.brandCheck(this, e), this[Fn].referrerPolicy
      }
      get mode() {
        return gt.brandCheck(this, e), this[Fn].mode
      }
      get credentials() {
        return this[Fn].credentials
      }
      get cache() {
        return gt.brandCheck(this, e), this[Fn].cache
      }
      get redirect() {
        return gt.brandCheck(this, e), this[Fn].redirect
      }
      get integrity() {
        return gt.brandCheck(this, e), this[Fn].integrity
      }
      get keepalive() {
        return gt.brandCheck(this, e), this[Fn].keepalive
      }
      get isReloadNavigation() {
        return gt.brandCheck(this, e), this[Fn].reloadNavigation
      }
      get isHistoryNavigation() {
        return gt.brandCheck(this, e), this[Fn].historyNavigation
      }
      get signal() {
        return gt.brandCheck(this, e), this[vD]
      }
      get body() {
        return (
          gt.brandCheck(this, e), this[Fn].body ? this[Fn].body.stream : null
        )
      }
      get bodyUsed() {
        return (
          gt.brandCheck(this, e),
          !!this[Fn].body && yD.isDisturbed(this[Fn].body.stream)
        )
      }
      get duplex() {
        return gt.brandCheck(this, e), "half"
      }
      clone() {
        if ((gt.brandCheck(this, e), pae(this))) throw new TypeError("unusable")
        let t = Iae(this[Fn]),
          r = new AbortController()
        if (this.signal.aborted) r.abort(this.signal.reason)
        else {
          let n = ED.get(this.signal)
          n === undefined && ((n = new Set()), ED.set(this.signal, n))
          let i = new WeakRef(r)
          n.add(i), yD.addAbortListener(r.signal, Eae(i))
        }
        return Bae(t, r.signal, Uze(this[Ma]))
      }
      [Aae.inspect.custom](t, r) {
        r.depth === null && (r.depth = 2), (r.colors ??= true)
        let n = {
          method: this.method,
          url: this.url,
          headers: this.headers,
          destination: this.destination,
          referrer: this.referrer,
          referrerPolicy: this.referrerPolicy,
          mode: this.mode,
          credentials: this.credentials,
          cache: this.cache,
          redirect: this.redirect,
          integrity: this.integrity,
          keepalive: this.keepalive,
          isReloadNavigation: this.isReloadNavigation,
          isHistoryNavigation: this.isHistoryNavigation,
          signal: this.signal,
        }
        return `Request ${Aae.formatWithOptions(r, n)}`
      }
    }
  Nze(bh)
  function _D(e) {
    return {
      method: e.method ?? "GET",
      localURLsOnly: e.localURLsOnly ?? false,
      unsafeRequest: e.unsafeRequest ?? false,
      body: e.body ?? null,
      client: e.client ?? null,
      reservedClient: e.reservedClient ?? null,
      replacesClientId: e.replacesClientId ?? "",
      window: e.window ?? "client",
      keepalive: e.keepalive ?? false,
      serviceWorkers: e.serviceWorkers ?? "all",
      initiator: e.initiator ?? "",
      destination: e.destination ?? "",
      priority: e.priority ?? null,
      origin: e.origin ?? "client",
      policyContainer: e.policyContainer ?? "client",
      referrer: e.referrer ?? "client",
      referrerPolicy: e.referrerPolicy ?? "",
      mode: e.mode ?? "no-cors",
      useCORSPreflightFlag: e.useCORSPreflightFlag ?? false,
      credentials: e.credentials ?? "same-origin",
      useCredentials: e.useCredentials ?? false,
      cache: e.cache ?? "default",
      redirect: e.redirect ?? "follow",
      integrity: e.integrity ?? "",
      cryptoGraphicsNonceMetadata: e.cryptoGraphicsNonceMetadata ?? "",
      parserMetadata: e.parserMetadata ?? "",
      reloadNavigation: e.reloadNavigation ?? false,
      historyNavigation: e.historyNavigation ?? false,
      userActivation: e.userActivation ?? false,
      taintedOrigin: e.taintedOrigin ?? false,
      redirectCount: e.redirectCount ?? 0,
      responseTainting: e.responseTainting ?? "basic",
      preventNoCacheCacheControlHeaderModification:
        e.preventNoCacheCacheControlHeaderModification ?? false,
      done: e.done ?? false,
      timingAllowFailed: e.timingAllowFailed ?? false,
      urlList: e.urlList,
      url: e.urlList[0],
      headersList: e.headersList ? new CD(e.headersList) : new CD(),
    }
  }
  function Iae(e) {
    let t = _D({ ...e, body: null })
    return e.body != null && (t.body = Pze(t, e.body)), t
  }
  function Bae(e, t, r) {
    let n = new bh(bD)
    return (
      (n[Fn] = e),
      (n[vD] = t),
      (n[Ma] = new xae(bD)),
      wae(n[Ma], e.headersList),
      $H(n[Ma], r),
      n
    )
  }
  Object.defineProperties(bh.prototype, {
    method: ki,
    url: ki,
    headers: ki,
    redirect: ki,
    clone: ki,
    signal: ki,
    duplex: ki,
    destination: ki,
    body: ki,
    bodyUsed: ki,
    isHistoryNavigation: ki,
    isReloadNavigation: ki,
    keepalive: ki,
    integrity: ki,
    cache: ki,
    credentials: ki,
    attribute: ki,
    referrerPolicy: ki,
    referrer: ki,
    mode: ki,
    [Symbol.toStringTag]: { value: "Request", configurable: true },
  })
  gt.converters.Request = gt.interfaceConverter(bh)
  gt.converters.RequestInfo = function (e, t, r) {
    return typeof e == "string"
      ? gt.converters.USVString(e, t, r)
      : e instanceof bh
        ? gt.converters.Request(e, t, r)
        : gt.converters.USVString(e, t, r)
  }
  gt.converters.AbortSignal = gt.interfaceConverter(AbortSignal)
  gt.converters.RequestInit = gt.dictionaryConverter([
    { key: "method", converter: gt.converters.ByteString },
    { key: "headers", converter: gt.converters.HeadersInit },
    { key: "body", converter: gt.nullableConverter(gt.converters.BodyInit) },
    { key: "referrer", converter: gt.converters.USVString },
    {
      key: "referrerPolicy",
      converter: gt.converters.DOMString,
      allowedValues: Wze,
    },
    { key: "mode", converter: gt.converters.DOMString, allowedValues: $ze },
    {
      key: "credentials",
      converter: gt.converters.DOMString,
      allowedValues: Yze,
    },
    { key: "cache", converter: gt.converters.DOMString, allowedValues: Kze },
    { key: "redirect", converter: gt.converters.DOMString, allowedValues: Gze },
    { key: "integrity", converter: gt.converters.DOMString },
    { key: "keepalive", converter: gt.converters.boolean },
    {
      key: "signal",
      converter: gt.nullableConverter((e) =>
        gt.converters.AbortSignal(e, "RequestInit", "signal", { strict: false }),
      ),
    },
    { key: "window", converter: gt.converters.any },
    { key: "duplex", converter: gt.converters.DOMString, allowedValues: zze },
    { key: "dispatcher", converter: gt.converters.any },
  ])
  Rae.exports = {
    Request: bh,
    makeRequest: _D,
    fromInnerRequest: Bae,
    cloneRequest: Iae,
  }
})
var zE = _((CTt, Wae) => {
  "use strict"
  var {
      makeNetworkError: dn,
      makeAppropriateNetworkError: xD,
      filterResponse: YH,
      makeResponse: wD,
      fromInnerResponse: rJe,
    } = YE(),
    { HeadersList: Dae } = Fp(),
    { Request: nJe, cloneRequest: iJe } = ry(),
    Eh = require("zlib"),
    {
      bytesMatch: sJe,
      makePolicyContainer: oJe,
      clonePolicyContainer: aJe,
      requestBadPort: lJe,
      TAOCheck: cJe,
      appendRequestOriginHeader: uJe,
      responseLocationURL: dJe,
      requestCurrentURL: Du,
      setRequestReferrerPolicyOnRedirect: fJe,
      tryUpgradeRequestToAPotentiallyTrustworthyURL: hJe,
      createOpaqueTimingInfo: ZH,
      appendFetchMetadata: gJe,
      corsCheck: pJe,
      crossOriginResourcePolicyCheck: mJe,
      determineRequestsReferrer: AJe,
      coarsenedSharedCurrentTime: KE,
      createDeferredPromise: yJe,
      isBlobLike: vJe,
      sameOrigin: jH,
      isCancelled: Np,
      isAborted: Tae,
      isErrorLike: CJe,
      fullyReadBody: bJe,
      readableStreamClose: EJe,
      isomorphicEncode: SD,
      urlIsLocal: _Je,
      urlIsHttpHttpsScheme: XH,
      urlHasHttpsScheme: xJe,
      clampAndCoarsenConnectionTimingInfo: wJe,
      simpleRangeHeaderValue: SJe,
      buildContentRange: IJe,
      createInflate: BJe,
      extractMimeType: RJe,
    } = Ba(),
    { kState: Qae, kDispatcher: DJe } = uh(),
    Pp = require("assert"),
    { safelyExtractBody: eW, extractBody: kae } = N0(),
    {
      redirectStatusSet: Nae,
      nullBodyStatus: Pae,
      safeMethodsSet: TJe,
      requestBodyHeader: kJe,
      subresourceSet: MJe,
    } = hE(),
    FJe = require("events"),
    { Readable: QJe, pipeline: NJe, finished: PJe } = require("stream"),
    {
      addAbortListener: LJe,
      isErrored: UJe,
      isReadable: ID,
      bufferToLowerCasedHeaderName: Mae,
    } = ir(),
    {
      dataURLProcessor: OJe,
      serializeAMimeType: qJe,
      minimizeSupportedMimeType: VJe,
    } = zo(),
    { getGlobalDispatcher: HJe } = uD(),
    { webidl: WJe } = Is(),
    { STATUS_CODES: GJe } = require("http"),
    $Je = ["GET", "HEAD"],
    YJe =
      typeof __UNDICI_IS_NODE__ < "u" || typeof esbuildDetection < "u"
        ? "node"
        : "undici",
    KH,
    BD = class extends FJe {
      constructor(t) {
        super(),
          (this.dispatcher = t),
          (this.connection = null),
          (this.dump = false),
          (this.state = "ongoing")
      }
      terminate(t) {
        this.state === "ongoing" &&
          ((this.state = "terminated"),
          this.connection?.destroy(t),
          this.emit("terminated", t))
      }
      abort(t) {
        this.state === "ongoing" &&
          ((this.state = "aborted"),
          t ||
            (t = new DOMException("The operation was aborted.", "AbortError")),
          (this.serializedAbortReason = t),
          this.connection?.destroy(t),
          this.emit("terminated", t))
      }
    }
  function KJe(e) {
    Lae(e, "fetch")
  }
  function zJe(e, t = undefined) {
    WJe.argumentLengthCheck(arguments, 1, "globalThis.fetch")
    let r = yJe(),
      n
    try {
      n = new nJe(e, t)
    } catch (u) {
      return r.reject(u), r.promise
    }
    let i = n[Qae]
    if (n.signal.aborted) return zH(r, i, null, n.signal.reason), r.promise
    i.client.globalObject?.constructor?.name === "ServiceWorkerGlobalScope" &&
      (i.serviceWorkers = "none")
    let o = null,
      a = false,
      l = null
    return (
      LJe(n.signal, () => {
        ;(a = true), Pp(l != null), l.abort(n.signal.reason)
        let u = o?.deref()
        zH(r, i, u, n.signal.reason)
      }),
      (l = Oae({
        request: i,
        processResponseEndOfBody: KJe,
        processResponse: (u) => {
          if (!a) {
            if (u.aborted) {
              zH(r, i, o, l.serializedAbortReason)
              return
            }
            if (u.type === "error") {
              r.reject(new TypeError("fetch failed", { cause: u.error }))
              return
            }
            ;(o = new WeakRef(rJe(u, "immutable"))),
              r.resolve(o.deref()),
              (r = null)
          }
        },
        dispatcher: n[DJe],
      })),
      r.promise
    )
  }
  function Lae(e, t = "other") {
    if ((e.type === "error" && e.aborted) || !e.urlList?.length) return
    let r = e.urlList[0],
      n = e.timingInfo,
      i = e.cacheState
    XH(r) &&
      n !== null &&
      (e.timingAllowPassed || ((n = ZH({ startTime: n.startTime })), (i = "")),
      (n.endTime = KE()),
      (e.timingInfo = n),
      Uae(n, r.href, t, globalThis, i))
  }
  var Uae = performance.markResourceTiming
  function zH(e, t, r, n) {
    if (
      (e && e.reject(n),
      t.body != null &&
        ID(t.body?.stream) &&
        t.body.stream.cancel(n).catch((s) => {
          if (s.code !== "ERR_INVALID_STATE") throw s
        }),
      r == null)
    )
      return
    let i = r[Qae]
    i.body != null &&
      ID(i.body?.stream) &&
      i.body.stream.cancel(n).catch((s) => {
        if (s.code !== "ERR_INVALID_STATE") throw s
      })
  }
  function Oae({
    request: e,
    processRequestBodyChunkLength: t,
    processRequestEndOfBody: r,
    processResponse: n,
    processResponseEndOfBody: i,
    processResponseConsumeBody: s,
    useParallelQueue: o = false,
    dispatcher: a = HJe(),
  }) {
    Pp(a)
    let l = null,
      c = false
    e.client != null &&
      ((l = e.client.globalObject),
      (c = e.client.crossOriginIsolatedCapability))
    let u = KE(c),
      f = ZH({ startTime: u }),
      p = {
        controller: new BD(a),
        request: e,
        timingInfo: f,
        processRequestBodyChunkLength: t,
        processRequestEndOfBody: r,
        processResponse: n,
        processResponseConsumeBody: s,
        processResponseEndOfBody: i,
        taskDestination: l,
        crossOriginIsolatedCapability: c,
      }
    if (
      (Pp(!e.body || e.body.stream),
      e.window === "client" &&
        (e.window =
          e.client?.globalObject?.constructor?.name === "Window"
            ? e.client
            : "no-window"),
      e.origin === "client" && (e.origin = e.client.origin),
      e.policyContainer === "client" &&
        (e.client != null
          ? (e.policyContainer = aJe(e.client.policyContainer))
          : (e.policyContainer = oJe())),
      !e.headersList.contains("accept", true))
    ) {
      let g = "*/*"
      e.headersList.append("accept", g, true)
    }
    return (
      e.headersList.contains("accept-language", true) ||
        e.headersList.append("accept-language", "*", true),
      e.priority,
      MJe.has(e.destination),
      qae(p).catch((g) => {
        p.controller.terminate(g)
      }),
      p.controller
    )
  }
  async function qae(e, t = false) {
    let r = e.request,
      n = null
    if (
      (r.localURLsOnly && !_Je(Du(r)) && (n = dn("local URLs only")),
      hJe(r),
      lJe(r) === "blocked" && (n = dn("bad port")),
      r.referrerPolicy === "" &&
        (r.referrerPolicy = r.policyContainer.referrerPolicy),
      r.referrer !== "no-referrer" && (r.referrer = AJe(r)),
      n === null &&
        (n = await (async () => {
          let s = Du(r)
          return (jH(s, r.url) && r.responseTainting === "basic") ||
            s.protocol === "data:" ||
            r.mode === "navigate" ||
            r.mode === "websocket"
            ? ((r.responseTainting = "basic"), await Fae(e))
            : r.mode === "same-origin"
              ? dn('request mode cannot be "same-origin"')
              : r.mode === "no-cors"
                ? r.redirect !== "follow"
                  ? dn('redirect mode cannot be "follow" for "no-cors" request')
                  : ((r.responseTainting = "opaque"), await Fae(e))
                : XH(Du(r))
                  ? ((r.responseTainting = "cors"), await Vae(e))
                  : dn("URL scheme must be a HTTP(S) scheme")
        })()),
      t)
    )
      return n
    n.status !== 0 &&
      !n.internalResponse &&
      (r.responseTainting,
      r.responseTainting === "basic"
        ? (n = YH(n, "basic"))
        : r.responseTainting === "cors"
          ? (n = YH(n, "cors"))
          : r.responseTainting === "opaque"
            ? (n = YH(n, "opaque"))
            : Pp(false))
    let i = n.status === 0 ? n : n.internalResponse
    if (
      (i.urlList.length === 0 && i.urlList.push(...r.urlList),
      r.timingAllowFailed || (n.timingAllowPassed = true),
      n.type === "opaque" &&
        i.status === 206 &&
        i.rangeRequested &&
        !r.headers.contains("range", true) &&
        (n = i = dn()),
      n.status !== 0 &&
        (r.method === "HEAD" ||
          r.method === "CONNECT" ||
          Pae.includes(i.status)) &&
        ((i.body = null), (e.controller.dump = true)),
      r.integrity)
    ) {
      let s = (a) => JH(e, dn(a))
      if (r.responseTainting === "opaque" || n.body == null) {
        s(n.error)
        return
      }
      let o = (a) => {
        if (!sJe(a, r.integrity)) {
          s("integrity mismatch")
          return
        }
        ;(n.body = eW(a)[0]), JH(e, n)
      }
      await bJe(n.body, o, s)
    } else JH(e, n)
  }
  function Fae(e) {
    if (Np(e) && e.request.redirectCount === 0) return Promise.resolve(xD(e))
    let { request: t } = e,
      { protocol: r } = Du(t)
    switch (r) {
      case "about:":
        return Promise.resolve(dn("about scheme is not supported"))
      case "blob:": {
        KH || (KH = require("buffer").resolveObjectURL)
        let n = Du(t)
        if (n.search.length !== 0)
          return Promise.resolve(
            dn("NetworkError when attempting to fetch resource."),
          )
        let i = KH(n.toString())
        if (t.method !== "GET" || !vJe(i))
          return Promise.resolve(dn("invalid method"))
        let s = wD(),
          o = i.size,
          a = SD(`${o}`),
          l = i.type
        if (t.headersList.contains("range", true)) {
          s.rangeRequested = true
          let c = t.headersList.get("range", true),
            u = SJe(c, true)
          if (u === "failure")
            return Promise.resolve(dn("failed to fetch the data URL"))
          let { rangeStartValue: f, rangeEndValue: p } = u
          if (f === null) (f = o - p), (p = f + p - 1)
          else {
            if (f >= o)
              return Promise.resolve(
                dn("Range start is greater than the blob's size."),
              )
            ;(p === null || p >= o) && (p = o - 1)
          }
          let g = i.slice(f, p, l),
            m = kae(g)
          s.body = m[0]
          let y = SD(`${g.size}`),
            v = IJe(f, p, o)
          ;(s.status = 206),
            (s.statusText = "Partial Content"),
            s.headersList.set("content-length", y, true),
            s.headersList.set("content-type", l, true),
            s.headersList.set("content-range", v, true)
        } else {
          let c = kae(i)
          ;(s.statusText = "OK"),
            (s.body = c[0]),
            s.headersList.set("content-length", a, true),
            s.headersList.set("content-type", l, true)
        }
        return Promise.resolve(s)
      }
      case "data:": {
        let n = Du(t),
          i = OJe(n)
        if (i === "failure")
          return Promise.resolve(dn("failed to fetch the data URL"))
        let s = qJe(i.mimeType)
        return Promise.resolve(
          wD({
            statusText: "OK",
            headersList: [["content-type", { name: "Content-Type", value: s }]],
            body: eW(i.body)[0],
          }),
        )
      }
      case "file:":
        return Promise.resolve(dn("not implemented... yet..."))
      case "http:":
      case "https:":
        return Vae(e).catch((n) => dn(n))
      default:
        return Promise.resolve(dn("unknown scheme"))
    }
  }
  function JJe(e, t) {
    ;(e.request.done = true),
      e.processResponseDone != null &&
        queueMicrotask(() => e.processResponseDone(t))
  }
  function JH(e, t) {
    let r = e.timingInfo,
      n = () => {
        let s = Date.now()
        e.request.destination === "document" &&
          (e.controller.fullTimingInfo = r),
          (e.controller.reportTimingSteps = () => {
            if (e.request.url.protocol !== "https:") return
            r.endTime = s
            let a = t.cacheState,
              l = t.bodyInfo
            t.timingAllowPassed || ((r = ZH(r)), (a = ""))
            let c = 0
            if (e.request.mode !== "navigator" || !t.hasCrossOriginRedirects) {
              c = t.status
              let u = RJe(t.headersList)
              u !== "failure" && (l.contentType = VJe(u))
            }
            e.request.initiatorType != null &&
              Uae(
                r,
                e.request.url.href,
                e.request.initiatorType,
                globalThis,
                a,
                l,
                c,
              )
          })
        let o = () => {
          ;(e.request.done = true),
            e.processResponseEndOfBody != null &&
              queueMicrotask(() => e.processResponseEndOfBody(t)),
            e.request.initiatorType != null && e.controller.reportTimingSteps()
        }
        queueMicrotask(() => o())
      }
    e.processResponse != null &&
      queueMicrotask(() => {
        e.processResponse(t), (e.processResponse = null)
      })
    let i = t.type === "error" ? t : (t.internalResponse ?? t)
    i.body == null
      ? n()
      : PJe(i.body.stream, () => {
          n()
        })
  }
  async function Vae(e) {
    let t = e.request,
      r = null,
      n = null,
      i = e.timingInfo
    if ((t.serviceWorkers, r === null)) {
      if (
        (t.redirect === "follow" && (t.serviceWorkers = "none"),
        (n = r = await Hae(e)),
        t.responseTainting === "cors" && pJe(t, r) === "failure")
      )
        return dn("cors failure")
      cJe(t, r) === "failure" && (t.timingAllowFailed = true)
    }
    return (t.responseTainting === "opaque" || r.type === "opaque") &&
      mJe(t.origin, t.client, t.destination, n) === "blocked"
      ? dn("blocked")
      : (Nae.has(n.status) &&
          (t.redirect !== "manual" &&
            e.controller.connection.destroy(undefined, false),
          t.redirect === "error"
            ? (r = dn("unexpected redirect"))
            : t.redirect === "manual"
              ? (r = n)
              : t.redirect === "follow"
                ? (r = await jJe(e, r))
                : Pp(false)),
        (r.timingInfo = i),
        r)
  }
  function jJe(e, t) {
    let r = e.request,
      n = t.internalResponse ? t.internalResponse : t,
      i
    try {
      if (((i = dJe(n, Du(r).hash)), i == null)) return t
    } catch (o) {
      return Promise.resolve(dn(o))
    }
    if (!XH(i))
      return Promise.resolve(dn("URL scheme must be a HTTP(S) scheme"))
    if (r.redirectCount === 20)
      return Promise.resolve(dn("redirect count exceeded"))
    if (
      ((r.redirectCount += 1),
      r.mode === "cors" && (i.username || i.password) && !jH(r, i))
    )
      return Promise.resolve(
        dn('cross origin not allowed for request mode "cors"'),
      )
    if (r.responseTainting === "cors" && (i.username || i.password))
      return Promise.resolve(
        dn('URL cannot contain credentials for request mode "cors"'),
      )
    if (n.status !== 303 && r.body != null && r.body.source == null)
      return Promise.resolve(dn())
    if (
      ([301, 302].includes(n.status) && r.method === "POST") ||
      (n.status === 303 && !$Je.includes(r.method))
    ) {
      ;(r.method = "GET"), (r.body = null)
      for (let o of kJe) r.headersList.delete(o)
    }
    jH(Du(r), i) ||
      (r.headersList.delete("authorization", true),
      r.headersList.delete("proxy-authorization", true),
      r.headersList.delete("cookie", true),
      r.headersList.delete("host", true)),
      r.body != null &&
        (Pp(r.body.source != null), (r.body = eW(r.body.source)[0]))
    let s = e.timingInfo
    return (
      (s.redirectEndTime = s.postRedirectStartTime =
        KE(e.crossOriginIsolatedCapability)),
      s.redirectStartTime === 0 && (s.redirectStartTime = s.startTime),
      r.urlList.push(i),
      fJe(r, n),
      qae(e, true)
    )
  }
  async function Hae(e, t = false, r = false) {
    let n = e.request,
      i = null,
      s = null,
      o = null,
      a = null,
      l = false
    n.window === "no-window" && n.redirect === "error"
      ? ((i = e), (s = n))
      : ((s = iJe(n)), (i = { ...e }), (i.request = s))
    let c =
        n.credentials === "include" ||
        (n.credentials === "same-origin" && n.responseTainting === "basic"),
      u = s.body ? s.body.length : null,
      f = null
    if (
      (s.body == null && ["POST", "PUT"].includes(s.method) && (f = "0"),
      u != null && (f = SD(`${u}`)),
      f != null && s.headersList.append("content-length", f, true),
      u != null && s.keepalive,
      s.referrer instanceof URL &&
        s.headersList.append("referer", SD(s.referrer.href), true),
      uJe(s),
      gJe(s),
      s.headersList.contains("user-agent", true) ||
        s.headersList.append("user-agent", YJe),
      s.cache === "default" &&
        (s.headersList.contains("if-modified-since", true) ||
          s.headersList.contains("if-none-match", true) ||
          s.headersList.contains("if-unmodified-since", true) ||
          s.headersList.contains("if-match", true) ||
          s.headersList.contains("if-range", true)) &&
        (s.cache = "no-store"),
      s.cache === "no-cache" &&
        !s.preventNoCacheCacheControlHeaderModification &&
        !s.headersList.contains("cache-control", true) &&
        s.headersList.append("cache-control", "max-age=0", true),
      (s.cache === "no-store" || s.cache === "reload") &&
        (s.headersList.contains("pragma", true) ||
          s.headersList.append("pragma", "no-cache", true),
        s.headersList.contains("cache-control", true) ||
          s.headersList.append("cache-control", "no-cache", true)),
      s.headersList.contains("range", true) &&
        s.headersList.append("accept-encoding", "identity", true),
      s.headersList.contains("accept-encoding", true) ||
        (xJe(Du(s))
          ? s.headersList.append("accept-encoding", "br, gzip, deflate", true)
          : s.headersList.append("accept-encoding", "gzip, deflate", true)),
      s.headersList.delete("host", true),
      a == null && (s.cache = "no-store"),
      s.cache !== "no-store" && s.cache,
      o == null)
    ) {
      if (s.cache === "only-if-cached") return dn("only if cached")
      let p = await ZJe(i, c, r)
      !TJe.has(s.method) && p.status >= 200 && p.status <= 399,
        l && p.status,
        o == null && (o = p)
    }
    if (
      ((o.urlList = [...s.urlList]),
      s.headersList.contains("range", true) && (o.rangeRequested = true),
      (o.requestIncludesCredentials = c),
      o.status === 407)
    )
      return n.window === "no-window"
        ? dn()
        : Np(e)
          ? xD(e)
          : dn("proxy authentication required")
    if (o.status === 421 && !r && (n.body == null || n.body.source != null)) {
      if (Np(e)) return xD(e)
      e.controller.connection.destroy(), (o = await Hae(e, t, true))
    }
    return o
  }
  async function ZJe(e, t = false, r = false) {
    Pp(!e.controller.connection || e.controller.connection.destroyed),
      (e.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(m, y = true) {
          this.destroyed ||
            ((this.destroyed = true),
            y &&
              this.abort?.(
                m ??
                  new DOMException("The operation was aborted.", "AbortError"),
              ))
        },
      })
    let n = e.request,
      i = null,
      s = e.timingInfo
    null == null && (n.cache = "no-store")
    let a = r ? "yes" : "no"
    n.mode
    let l = null
    if (n.body == null && e.processRequestEndOfBody)
      queueMicrotask(() => e.processRequestEndOfBody())
    else if (n.body != null) {
      let m = async function* (C) {
          Np(e) || (yield C, e.processRequestBodyChunkLength?.(C.byteLength))
        },
        y = () => {
          Np(e) || (e.processRequestEndOfBody && e.processRequestEndOfBody())
        },
        v = (C) => {
          Np(e) ||
            (C.name === "AbortError"
              ? e.controller.abort()
              : e.controller.terminate(C))
        }
      l = (async function* () {
        try {
          for await (let C of n.body.stream) yield* m(C)
          y()
        } catch (C) {
          v(C)
        }
      })()
    }
    try {
      let {
        body: m,
        status: y,
        statusText: v,
        headersList: C,
        socket: E,
      } = await g({ body: l })
      if (E) i = wD({ status: y, statusText: v, headersList: C, socket: E })
      else {
        let w = m[Symbol.asyncIterator]()
        ;(e.controller.next = () => w.next()),
          (i = wD({ status: y, statusText: v, headersList: C }))
      }
    } catch (m) {
      return m.name === "AbortError"
        ? (e.controller.connection.destroy(), xD(e, m))
        : dn(m)
    }
    let c = async () => {
        await e.controller.resume()
      },
      u = (m) => {
        Np(e) || e.controller.abort(m)
      },
      f = new ReadableStream({
        async start(m) {
          e.controller.controller = m
        },
        async pull(m) {
          await c(m)
        },
        async cancel(m) {
          await u(m)
        },
        type: "bytes",
      })
    ;(i.body = { stream: f, source: null, length: null }),
      (e.controller.onAborted = p),
      e.controller.on("terminated", p),
      (e.controller.resume = async () => {
        for (;;) {
          let m, y
          try {
            let { done: C, value: E } = await e.controller.next()
            if (Tae(e)) break
            m = C ? undefined : E
          } catch (C) {
            e.controller.ended && !s.encodedBodySize
              ? (m = undefined)
              : ((m = C), (y = true))
          }
          if (m === undefined) {
            EJe(e.controller.controller), JJe(e, i)
            return
          }
          if (((s.decodedBodySize += m?.byteLength ?? 0), y)) {
            e.controller.terminate(m)
            return
          }
          let v = new Uint8Array(m)
          if ((v.byteLength && e.controller.controller.enqueue(v), UJe(f))) {
            e.controller.terminate()
            return
          }
          if (e.controller.controller.desiredSize <= 0) return
        }
      })
    function p(m) {
      Tae(e)
        ? ((i.aborted = true),
          ID(f) &&
            e.controller.controller.error(e.controller.serializedAbortReason))
        : ID(f) &&
          e.controller.controller.error(
            new TypeError("terminated", { cause: CJe(m) ? m : undefined }),
          ),
        e.controller.connection.destroy()
    }
    return i
    function g({ body: m }) {
      let y = Du(n),
        v = e.controller.dispatcher
      return new Promise((C, E) =>
        v.dispatch(
          {
            path: y.pathname + y.search,
            origin: y.origin,
            method: n.method,
            body: v.isMockActive
              ? n.body && (n.body.source || n.body.stream)
              : m,
            headers: n.headersList.entries,
            maxRedirections: 0,
            upgrade: n.mode === "websocket" ? "websocket" : undefined,
          },
          {
            body: null,
            abort: null,
            onConnect(w) {
              let { connection: B } = e.controller
              ;(s.finalConnectionTimingInfo = wJe(
                undefined,
                s.postRedirectStartTime,
                e.crossOriginIsolatedCapability,
              )),
                B.destroyed
                  ? w(
                      new DOMException(
                        "The operation was aborted.",
                        "AbortError",
                      ),
                    )
                  : (e.controller.on("terminated", w),
                    (this.abort = B.abort = w)),
                (s.finalNetworkRequestStartTime = KE(
                  e.crossOriginIsolatedCapability,
                ))
            },
            onResponseStarted() {
              s.finalNetworkResponseStartTime = KE(
                e.crossOriginIsolatedCapability,
              )
            },
            onHeaders(w, B, T, N) {
              if (w < 200) return
              let W = [],
                Z = "",
                te = new Dae()
              for (let Q = 0; Q < B.length; Q += 2)
                te.append(Mae(B[Q]), B[Q + 1].toString("latin1"), true)
              let Y = te.get("content-encoding", true)
              Y &&
                (W = Y.toLowerCase()
                  .split(",")
                  .map((Q) => Q.trim())),
                (Z = te.get("location", true)),
                (this.body = new QJe({ read: T }))
              let U = [],
                ce = Z && n.redirect === "follow" && Nae.has(w)
              if (
                W.length !== 0 &&
                n.method !== "HEAD" &&
                n.method !== "CONNECT" &&
                !Pae.includes(w) &&
                !ce
              )
                for (let Q = W.length - 1; Q >= 0; --Q) {
                  let se = W[Q]
                  if (se === "x-gzip" || se === "gzip")
                    U.push(
                      Eh.createGunzip({
                        flush: Eh.constants.Z_SYNC_FLUSH,
                        finishFlush: Eh.constants.Z_SYNC_FLUSH,
                      }),
                    )
                  else if (se === "deflate")
                    U.push(
                      BJe({
                        flush: Eh.constants.Z_SYNC_FLUSH,
                        finishFlush: Eh.constants.Z_SYNC_FLUSH,
                      }),
                    )
                  else if (se === "br")
                    U.push(
                      Eh.createBrotliDecompress({
                        flush: Eh.constants.BROTLI_OPERATION_FLUSH,
                        finishFlush: Eh.constants.BROTLI_OPERATION_FLUSH,
                      }),
                    )
                  else {
                    U.length = 0
                    break
                  }
                }
              let Ie = this.onError.bind(this)
              return (
                C({
                  status: w,
                  statusText: N,
                  headersList: te,
                  body: U.length
                    ? NJe(this.body, ...U, (Q) => {
                        Q && this.onError(Q)
                      }).on("error", Ie)
                    : this.body.on("error", Ie),
                }),
                true
              )
            },
            onData(w) {
              if (e.controller.dump) return
              let B = w
              return (s.encodedBodySize += B.byteLength), this.body.push(B)
            },
            onComplete() {
              this.abort && e.controller.off("terminated", this.abort),
                e.controller.onAborted &&
                  e.controller.off("terminated", e.controller.onAborted),
                (e.controller.ended = true),
                this.body.push(null)
            },
            onError(w) {
              this.abort && e.controller.off("terminated", this.abort),
                this.body?.destroy(w),
                e.controller.terminate(w),
                E(w)
            },
            onUpgrade(w, B, T) {
              if (w !== 101) return
              let N = new Dae()
              for (let W = 0; W < B.length; W += 2)
                N.append(Mae(B[W]), B[W + 1].toString("latin1"), true)
              return (
                C({ status: w, statusText: GJe[w], headersList: N, socket: T }),
                true
              )
            },
          },
        ),
      )
    }
  }
  Wae.exports = {
    fetch: zJe,
    Fetch: BD,
    fetching: Oae,
    finalizeAndReportTiming: Lae,
  }
})
var tW = _((bTt, Gae) => {
  "use strict"
  Gae.exports = {
    kState: Symbol("FileReader state"),
    kResult: Symbol("FileReader result"),
    kError: Symbol("FileReader error"),
    kLastProgressEventFired: Symbol(
      "FileReader last progress event fired timestamp",
    ),
    kEvents: Symbol("FileReader events"),
    kAborted: Symbol("FileReader aborted"),
  }
})
var Yae = _((ETt, $ae) => {
  "use strict"
  var { webidl: Fa } = Is(),
    RD = Symbol("ProgressEvent state"),
    rW = class e extends Event {
      constructor(t, r = {}) {
        ;(t = Fa.converters.DOMString(t, "ProgressEvent constructor", "type")),
          (r = Fa.converters.ProgressEventInit(r ?? {})),
          super(t, r),
          (this[RD] = {
            lengthComputable: r.lengthComputable,
            loaded: r.loaded,
            total: r.total,
          })
      }
      get lengthComputable() {
        return Fa.brandCheck(this, e), this[RD].lengthComputable
      }
      get loaded() {
        return Fa.brandCheck(this, e), this[RD].loaded
      }
      get total() {
        return Fa.brandCheck(this, e), this[RD].total
      }
    }
  Fa.converters.ProgressEventInit = Fa.dictionaryConverter([
    {
      key: "lengthComputable",
      converter: Fa.converters.boolean,
      defaultValue: () => false,
    },
    {
      key: "loaded",
      converter: Fa.converters["unsigned long long"],
      defaultValue: () => 0,
    },
    {
      key: "total",
      converter: Fa.converters["unsigned long long"],
      defaultValue: () => 0,
    },
    {
      key: "bubbles",
      converter: Fa.converters.boolean,
      defaultValue: () => false,
    },
    {
      key: "cancelable",
      converter: Fa.converters.boolean,
      defaultValue: () => false,
    },
    {
      key: "composed",
      converter: Fa.converters.boolean,
      defaultValue: () => false,
    },
  ])
  $ae.exports = { ProgressEvent: rW }
})
var zae = _((_Tt, Kae) => {
  "use strict"
  function XJe(e) {
    if (!e) return "failure"
    switch (e.trim().toLowerCase()) {
      case "unicode-1-1-utf-8":
      case "unicode11utf8":
      case "unicode20utf8":
      case "utf-8":
      case "utf8":
      case "x-unicode20utf8":
        return "UTF-8"
      case "866":
      case "cp866":
      case "csibm866":
      case "ibm866":
        return "IBM866"
      case "csisolatin2":
      case "iso-8859-2":
      case "iso-ir-101":
      case "iso8859-2":
      case "iso88592":
      case "iso_8859-2":
      case "iso_8859-2:1987":
      case "l2":
      case "latin2":
        return "ISO-8859-2"
      case "csisolatin3":
      case "iso-8859-3":
      case "iso-ir-109":
      case "iso8859-3":
      case "iso88593":
      case "iso_8859-3":
      case "iso_8859-3:1988":
      case "l3":
      case "latin3":
        return "ISO-8859-3"
      case "csisolatin4":
      case "iso-8859-4":
      case "iso-ir-110":
      case "iso8859-4":
      case "iso88594":
      case "iso_8859-4":
      case "iso_8859-4:1988":
      case "l4":
      case "latin4":
        return "ISO-8859-4"
      case "csisolatincyrillic":
      case "cyrillic":
      case "iso-8859-5":
      case "iso-ir-144":
      case "iso8859-5":
      case "iso88595":
      case "iso_8859-5":
      case "iso_8859-5:1988":
        return "ISO-8859-5"
      case "arabic":
      case "asmo-708":
      case "csiso88596e":
      case "csiso88596i":
      case "csisolatinarabic":
      case "ecma-114":
      case "iso-8859-6":
      case "iso-8859-6-e":
      case "iso-8859-6-i":
      case "iso-ir-127":
      case "iso8859-6":
      case "iso88596":
      case "iso_8859-6":
      case "iso_8859-6:1987":
        return "ISO-8859-6"
      case "csisolatingreek":
      case "ecma-118":
      case "elot_928":
      case "greek":
      case "greek8":
      case "iso-8859-7":
      case "iso-ir-126":
      case "iso8859-7":
      case "iso88597":
      case "iso_8859-7":
      case "iso_8859-7:1987":
      case "sun_eu_greek":
        return "ISO-8859-7"
      case "csiso88598e":
      case "csisolatinhebrew":
      case "hebrew":
      case "iso-8859-8":
      case "iso-8859-8-e":
      case "iso-ir-138":
      case "iso8859-8":
      case "iso88598":
      case "iso_8859-8":
      case "iso_8859-8:1988":
      case "visual":
        return "ISO-8859-8"
      case "csiso88598i":
      case "iso-8859-8-i":
      case "logical":
        return "ISO-8859-8-I"
      case "csisolatin6":
      case "iso-8859-10":
      case "iso-ir-157":
      case "iso8859-10":
      case "iso885910":
      case "l6":
      case "latin6":
        return "ISO-8859-10"
      case "iso-8859-13":
      case "iso8859-13":
      case "iso885913":
        return "ISO-8859-13"
      case "iso-8859-14":
      case "iso8859-14":
      case "iso885914":
        return "ISO-8859-14"
      case "csisolatin9":
      case "iso-8859-15":
      case "iso8859-15":
      case "iso885915":
      case "iso_8859-15":
      case "l9":
        return "ISO-8859-15"
      case "iso-8859-16":
        return "ISO-8859-16"
      case "cskoi8r":
      case "koi":
      case "koi8":
      case "koi8-r":
      case "koi8_r":
        return "KOI8-R"
      case "koi8-ru":
      case "koi8-u":
        return "KOI8-U"
      case "csmacintosh":
      case "mac":
      case "macintosh":
      case "x-mac-roman":
        return "macintosh"
      case "iso-8859-11":
      case "iso8859-11":
      case "iso885911":
      case "tis-620":
      case "windows-874":
        return "windows-874"
      case "cp1250":
      case "windows-1250":
      case "x-cp1250":
        return "windows-1250"
      case "cp1251":
      case "windows-1251":
      case "x-cp1251":
        return "windows-1251"
      case "ansi_x3.4-1968":
      case "ascii":
      case "cp1252":
      case "cp819":
      case "csisolatin1":
      case "ibm819":
      case "iso-8859-1":
      case "iso-ir-100":
      case "iso8859-1":
      case "iso88591":
      case "iso_8859-1":
      case "iso_8859-1:1987":
      case "l1":
      case "latin1":
      case "us-ascii":
      case "windows-1252":
      case "x-cp1252":
        return "windows-1252"
      case "cp1253":
      case "windows-1253":
      case "x-cp1253":
        return "windows-1253"
      case "cp1254":
      case "csisolatin5":
      case "iso-8859-9":
      case "iso-ir-148":
      case "iso8859-9":
      case "iso88599":
      case "iso_8859-9":
      case "iso_8859-9:1989":
      case "l5":
      case "latin5":
      case "windows-1254":
      case "x-cp1254":
        return "windows-1254"
      case "cp1255":
      case "windows-1255":
      case "x-cp1255":
        return "windows-1255"
      case "cp1256":
      case "windows-1256":
      case "x-cp1256":
        return "windows-1256"
      case "cp1257":
      case "windows-1257":
      case "x-cp1257":
        return "windows-1257"
      case "cp1258":
      case "windows-1258":
      case "x-cp1258":
        return "windows-1258"
      case "x-mac-cyrillic":
      case "x-mac-ukrainian":
        return "x-mac-cyrillic"
      case "chinese":
      case "csgb2312":
      case "csiso58gb231280":
      case "gb2312":
      case "gb_2312":
      case "gb_2312-80":
      case "gbk":
      case "iso-ir-58":
      case "x-gbk":
        return "GBK"
      case "gb18030":
        return "gb18030"
      case "big5":
      case "big5-hkscs":
      case "cn-big5":
      case "csbig5":
      case "x-x-big5":
        return "Big5"
      case "cseucpkdfmtjapanese":
      case "euc-jp":
      case "x-euc-jp":
        return "EUC-JP"
      case "csiso2022jp":
      case "iso-2022-jp":
        return "ISO-2022-JP"
      case "csshiftjis":
      case "ms932":
      case "ms_kanji":
      case "shift-jis":
      case "shift_jis":
      case "sjis":
      case "windows-31j":
      case "x-sjis":
        return "Shift_JIS"
      case "cseuckr":
      case "csksc56011987":
      case "euc-kr":
      case "iso-ir-149":
      case "korean":
      case "ks_c_5601-1987":
      case "ks_c_5601-1989":
      case "ksc5601":
      case "ksc_5601":
      case "windows-949":
        return "EUC-KR"
      case "csiso2022kr":
      case "hz-gb-2312":
      case "iso-2022-cn":
      case "iso-2022-cn-ext":
      case "iso-2022-kr":
      case "replacement":
        return "replacement"
      case "unicodefffe":
      case "utf-16be":
        return "UTF-16BE"
      case "csunicode":
      case "iso-10646-ucs-2":
      case "ucs-2":
      case "unicode":
      case "unicodefeff":
      case "utf-16":
      case "utf-16le":
        return "UTF-16LE"
      case "x-user-defined":
        return "x-user-defined"
      default:
        return "failure"
    }
  }
  Kae.exports = { getEncoding: XJe }
})
var nle = _((xTt, rle) => {
  "use strict"
  var {
      kState: ny,
      kError: nW,
      kResult: Jae,
      kAborted: JE,
      kLastProgressEventFired: iW,
    } = tW(),
    { ProgressEvent: eje } = Yae(),
    { getEncoding: jae } = zae(),
    { serializeAMimeType: tje, parseMIMEType: Zae } = zo(),
    { types: rje } = require("util"),
    { StringDecoder: Xae } = require("string_decoder"),
    { btoa: ele } = require("buffer"),
    nje = { enumerable: true, writable: false, configurable: false }
  function ije(e, t, r, n) {
    if (e[ny] === "loading")
      throw new DOMException("Invalid state", "InvalidStateError")
    ;(e[ny] = "loading"), (e[Jae] = null), (e[nW] = null)
    let s = t.stream().getReader(),
      o = [],
      a = s.read(),
      l = true
    ;(async () => {
      for (; !e[JE]; )
        try {
          let { done: c, value: u } = await a
          if (
            (l &&
              !e[JE] &&
              queueMicrotask(() => {
                _h("loadstart", e)
              }),
            (l = false),
            !c && rje.isUint8Array(u))
          )
            o.push(u),
              (e[iW] === undefined || Date.now() - e[iW] >= 50) &&
                !e[JE] &&
                ((e[iW] = Date.now()),
                queueMicrotask(() => {
                  _h("progress", e)
                })),
              (a = s.read())
          else if (c) {
            queueMicrotask(() => {
              e[ny] = "done"
              try {
                let f = sje(o, r, t.type, n)
                if (e[JE]) return
                ;(e[Jae] = f), _h("load", e)
              } catch (f) {
                ;(e[nW] = f), _h("error", e)
              }
              e[ny] !== "loading" && _h("loadend", e)
            })
            break
          }
        } catch (c) {
          if (e[JE]) return
          queueMicrotask(() => {
            ;(e[ny] = "done"),
              (e[nW] = c),
              _h("error", e),
              e[ny] !== "loading" && _h("loadend", e)
          })
          break
        }
    })()
  }
  function _h(e, t) {
    let r = new eje(e, { bubbles: false, cancelable: false })
    t.dispatchEvent(r)
  }
  function sje(e, t, r, n) {
    switch (t) {
      case "DataURL": {
        let i = "data:",
          s = Zae(r || "application/octet-stream")
        s !== "failure" && (i += tje(s)), (i += ";base64,")
        let o = new Xae("latin1")
        for (let a of e) i += ele(o.write(a))
        return (i += ele(o.end())), i
      }
      case "Text": {
        let i = "failure"
        if ((n && (i = jae(n)), i === "failure" && r)) {
          let s = Zae(r)
          s !== "failure" && (i = jae(s.parameters.get("charset")))
        }
        return i === "failure" && (i = "UTF-8"), oje(e, i)
      }
      case "ArrayBuffer":
        return tle(e).buffer
      case "BinaryString": {
        let i = "",
          s = new Xae("latin1")
        for (let o of e) i += s.write(o)
        return (i += s.end()), i
      }
    }
  }
  function oje(e, t) {
    let r = tle(e),
      n = aje(r),
      i = 0
    n !== null && ((t = n), (i = n === "UTF-8" ? 3 : 2))
    let s = r.slice(i)
    return new TextDecoder(t).decode(s)
  }
  function aje(e) {
    let [t, r, n] = e
    return t === 239 && r === 187 && n === 191
      ? "UTF-8"
      : t === 254 && r === 255
        ? "UTF-16BE"
        : t === 255 && r === 254
          ? "UTF-16LE"
          : null
  }
  function tle(e) {
    let t = e.reduce((n, i) => n + i.byteLength, 0),
      r = 0
    return e.reduce(
      (n, i) => (n.set(i, r), (r += i.byteLength), n),
      new Uint8Array(t),
    )
  }
  rle.exports = {
    staticPropertyDescriptors: nje,
    readOperation: ije,
    fireAProgressEvent: _h,
  }
})
var ale = _((wTt, ole) => {
  "use strict"
  var {
      staticPropertyDescriptors: iy,
      readOperation: DD,
      fireAProgressEvent: ile,
    } = nle(),
    { kState: Lp, kError: sle, kResult: TD, kEvents: jr, kAborted: lje } = tW(),
    { webidl: gn } = Is(),
    { kEnumerableProperty: Zo } = ir(),
    Dc = class e extends EventTarget {
      constructor() {
        super(),
          (this[Lp] = "empty"),
          (this[TD] = null),
          (this[sle] = null),
          (this[jr] = {
            loadend: null,
            error: null,
            abort: null,
            load: null,
            progress: null,
            loadstart: null,
          })
      }
      readAsArrayBuffer(t) {
        gn.brandCheck(this, e),
          gn.argumentLengthCheck(arguments, 1, "FileReader.readAsArrayBuffer"),
          (t = gn.converters.Blob(t, { strict: false })),
          DD(this, t, "ArrayBuffer")
      }
      readAsBinaryString(t) {
        gn.brandCheck(this, e),
          gn.argumentLengthCheck(arguments, 1, "FileReader.readAsBinaryString"),
          (t = gn.converters.Blob(t, { strict: false })),
          DD(this, t, "BinaryString")
      }
      readAsText(t, r = undefined) {
        gn.brandCheck(this, e),
          gn.argumentLengthCheck(arguments, 1, "FileReader.readAsText"),
          (t = gn.converters.Blob(t, { strict: false })),
          r !== undefined &&
            (r = gn.converters.DOMString(
              r,
              "FileReader.readAsText",
              "encoding",
            )),
          DD(this, t, "Text", r)
      }
      readAsDataURL(t) {
        gn.brandCheck(this, e),
          gn.argumentLengthCheck(arguments, 1, "FileReader.readAsDataURL"),
          (t = gn.converters.Blob(t, { strict: false })),
          DD(this, t, "DataURL")
      }
      abort() {
        if (this[Lp] === "empty" || this[Lp] === "done") {
          this[TD] = null
          return
        }
        this[Lp] === "loading" && ((this[Lp] = "done"), (this[TD] = null)),
          (this[lje] = true),
          ile("abort", this),
          this[Lp] !== "loading" && ile("loadend", this)
      }
      get readyState() {
        switch ((gn.brandCheck(this, e), this[Lp])) {
          case "empty":
            return this.EMPTY
          case "loading":
            return this.LOADING
          case "done":
            return this.DONE
        }
      }
      get result() {
        return gn.brandCheck(this, e), this[TD]
      }
      get error() {
        return gn.brandCheck(this, e), this[sle]
      }
      get onloadend() {
        return gn.brandCheck(this, e), this[jr].loadend
      }
      set onloadend(t) {
        gn.brandCheck(this, e),
          this[jr].loadend &&
            this.removeEventListener("loadend", this[jr].loadend),
          typeof t == "function"
            ? ((this[jr].loadend = t), this.addEventListener("loadend", t))
            : (this[jr].loadend = null)
      }
      get onerror() {
        return gn.brandCheck(this, e), this[jr].error
      }
      set onerror(t) {
        gn.brandCheck(this, e),
          this[jr].error && this.removeEventListener("error", this[jr].error),
          typeof t == "function"
            ? ((this[jr].error = t), this.addEventListener("error", t))
            : (this[jr].error = null)
      }
      get onloadstart() {
        return gn.brandCheck(this, e), this[jr].loadstart
      }
      set onloadstart(t) {
        gn.brandCheck(this, e),
          this[jr].loadstart &&
            this.removeEventListener("loadstart", this[jr].loadstart),
          typeof t == "function"
            ? ((this[jr].loadstart = t), this.addEventListener("loadstart", t))
            : (this[jr].loadstart = null)
      }
      get onprogress() {
        return gn.brandCheck(this, e), this[jr].progress
      }
      set onprogress(t) {
        gn.brandCheck(this, e),
          this[jr].progress &&
            this.removeEventListener("progress", this[jr].progress),
          typeof t == "function"
            ? ((this[jr].progress = t), this.addEventListener("progress", t))
            : (this[jr].progress = null)
      }
      get onload() {
        return gn.brandCheck(this, e), this[jr].load
      }
      set onload(t) {
        gn.brandCheck(this, e),
          this[jr].load && this.removeEventListener("load", this[jr].load),
          typeof t == "function"
            ? ((this[jr].load = t), this.addEventListener("load", t))
            : (this[jr].load = null)
      }
      get onabort() {
        return gn.brandCheck(this, e), this[jr].abort
      }
      set onabort(t) {
        gn.brandCheck(this, e),
          this[jr].abort && this.removeEventListener("abort", this[jr].abort),
          typeof t == "function"
            ? ((this[jr].abort = t), this.addEventListener("abort", t))
            : (this[jr].abort = null)
      }
    }
  Dc.EMPTY = Dc.prototype.EMPTY = 0
  Dc.LOADING = Dc.prototype.LOADING = 1
  Dc.DONE = Dc.prototype.DONE = 2
  Object.defineProperties(Dc.prototype, {
    EMPTY: iy,
    LOADING: iy,
    DONE: iy,
    readAsArrayBuffer: Zo,
    readAsBinaryString: Zo,
    readAsText: Zo,
    readAsDataURL: Zo,
    abort: Zo,
    readyState: Zo,
    result: Zo,
    error: Zo,
    onloadstart: Zo,
    onprogress: Zo,
    onload: Zo,
    onabort: Zo,
    onerror: Zo,
    onloadend: Zo,
    [Symbol.toStringTag]: {
      value: "FileReader",
      writable: false,
      enumerable: false,
      configurable: true,
    },
  })
  Object.defineProperties(Dc, { EMPTY: iy, LOADING: iy, DONE: iy })
  ole.exports = { FileReader: Dc }
})
var kD = _((STt, lle) => {
  "use strict"
  lle.exports = { kConstruct: Wn().kConstruct }
})
var dle = _((ITt, ule) => {
  "use strict"
  var cje = require("assert"),
    { URLSerializer: cle } = zo(),
    { isValidHeaderName: uje } = Ba()
  function dje(e, t, r = false) {
    let n = cle(e, r),
      i = cle(t, r)
    return n === i
  }
  function fje(e) {
    cje(e !== null)
    let t = []
    for (let r of e.split(",")) (r = r.trim()), uje(r) && t.push(r)
    return t
  }
  ule.exports = { urlEquals: dje, getFieldValues: fje }
})
var gle = _((BTt, hle) => {
  "use strict"
  var { kConstruct: hje } = kD(),
    { urlEquals: gje, getFieldValues: sW } = dle(),
    { kEnumerableProperty: Up, isDisturbed: pje } = ir(),
    { webidl: tt } = Is(),
    { Response: mje, cloneResponse: Aje, fromInnerResponse: yje } = YE(),
    { Request: Kd, fromInnerRequest: vje } = ry(),
    { kState: Tc } = uh(),
    { fetching: Cje } = zE(),
    {
      urlIsHttpHttpsScheme: MD,
      createDeferredPromise: sy,
      readAllBytes: bje,
    } = Ba(),
    oW = require("assert"),
    FD = class e {
      #e
      constructor() {
        arguments[0] !== hje && tt.illegalConstructor(),
          tt.util.markAsUncloneable(this),
          (this.#e = arguments[1])
      }
      async match(t, r = {}) {
        tt.brandCheck(this, e)
        let n = "Cache.match"
        tt.argumentLengthCheck(arguments, 1, n),
          (t = tt.converters.RequestInfo(t, n, "request")),
          (r = tt.converters.CacheQueryOptions(r, n, "options"))
        let i = this.#r(t, r, 1)
        if (i.length !== 0) return i[0]
      }
      async matchAll(t = undefined, r = {}) {
        tt.brandCheck(this, e)
        let n = "Cache.matchAll"
        return (
          t !== undefined && (t = tt.converters.RequestInfo(t, n, "request")),
          (r = tt.converters.CacheQueryOptions(r, n, "options")),
          this.#r(t, r)
        )
      }
      async add(t) {
        tt.brandCheck(this, e)
        let r = "Cache.add"
        tt.argumentLengthCheck(arguments, 1, r),
          (t = tt.converters.RequestInfo(t, r, "request"))
        let n = [t]
        return await this.addAll(n)
      }
      async addAll(t) {
        tt.brandCheck(this, e)
        let r = "Cache.addAll"
        tt.argumentLengthCheck(arguments, 1, r)
        let n = [],
          i = []
        for (let p of t) {
          if (p === undefined)
            throw tt.errors.conversionFailed({
              prefix: r,
              argument: "Argument 1",
              types: ["undefined is not allowed"],
            })
          if (((p = tt.converters.RequestInfo(p)), typeof p == "string"))
            continue
          let g = p[Tc]
          if (!MD(g.url) || g.method !== "GET")
            throw tt.errors.exception({
              header: r,
              message: "Expected http/s scheme when method is not GET.",
            })
        }
        let s = []
        for (let p of t) {
          let g = new Kd(p)[Tc]
          if (!MD(g.url))
            throw tt.errors.exception({
              header: r,
              message: "Expected http/s scheme.",
            })
          ;(g.initiator = "fetch"), (g.destination = "subresource"), i.push(g)
          let m = sy()
          s.push(
            Cje({
              request: g,
              processResponse(y) {
                if (
                  y.type === "error" ||
                  y.status === 206 ||
                  y.status < 200 ||
                  y.status > 299
                )
                  m.reject(
                    tt.errors.exception({
                      header: "Cache.addAll",
                      message:
                        "Received an invalid status code or the request failed.",
                    }),
                  )
                else if (y.headersList.contains("vary")) {
                  let v = sW(y.headersList.get("vary"))
                  for (let C of v)
                    if (C === "*") {
                      m.reject(
                        tt.errors.exception({
                          header: "Cache.addAll",
                          message: "invalid vary field value",
                        }),
                      )
                      for (let E of s) E.abort()
                      return
                    }
                }
              },
              processResponseEndOfBody(y) {
                if (y.aborted) {
                  m.reject(new DOMException("aborted", "AbortError"))
                  return
                }
                m.resolve(y)
              },
            }),
          ),
            n.push(m.promise)
        }
        let a = await Promise.all(n),
          l = [],
          c = 0
        for (let p of a) {
          let g = { type: "put", request: i[c], response: p }
          l.push(g), c++
        }
        let u = sy(),
          f = null
        try {
          this.#t(l)
        } catch (p) {
          f = p
        }
        return (
          queueMicrotask(() => {
            f === null ? u.resolve(undefined) : u.reject(f)
          }),
          u.promise
        )
      }
      async put(t, r) {
        tt.brandCheck(this, e)
        let n = "Cache.put"
        tt.argumentLengthCheck(arguments, 2, n),
          (t = tt.converters.RequestInfo(t, n, "request")),
          (r = tt.converters.Response(r, n, "response"))
        let i = null
        if (
          (t instanceof Kd ? (i = t[Tc]) : (i = new Kd(t)[Tc]),
          !MD(i.url) || i.method !== "GET")
        )
          throw tt.errors.exception({
            header: n,
            message: "Expected an http/s scheme when method is not GET",
          })
        let s = r[Tc]
        if (s.status === 206)
          throw tt.errors.exception({ header: n, message: "Got 206 status" })
        if (s.headersList.contains("vary")) {
          let g = sW(s.headersList.get("vary"))
          for (let m of g)
            if (m === "*")
              throw tt.errors.exception({
                header: n,
                message: "Got * vary field value",
              })
        }
        if (s.body && (pje(s.body.stream) || s.body.stream.locked))
          throw tt.errors.exception({
            header: n,
            message: "Response body is locked or disturbed",
          })
        let o = Aje(s),
          a = sy()
        if (s.body != null) {
          let m = s.body.stream.getReader()
          bje(m).then(a.resolve, a.reject)
        } else a.resolve(undefined)
        let l = [],
          c = { type: "put", request: i, response: o }
        l.push(c)
        let u = await a.promise
        o.body != null && (o.body.source = u)
        let f = sy(),
          p = null
        try {
          this.#t(l)
        } catch (g) {
          p = g
        }
        return (
          queueMicrotask(() => {
            p === null ? f.resolve() : f.reject(p)
          }),
          f.promise
        )
      }
      async delete(t, r = {}) {
        tt.brandCheck(this, e)
        let n = "Cache.delete"
        tt.argumentLengthCheck(arguments, 1, n),
          (t = tt.converters.RequestInfo(t, n, "request")),
          (r = tt.converters.CacheQueryOptions(r, n, "options"))
        let i = null
        if (t instanceof Kd) {
          if (((i = t[Tc]), i.method !== "GET" && !r.ignoreMethod)) return false
        } else oW(typeof t == "string"), (i = new Kd(t)[Tc])
        let s = [],
          o = { type: "delete", request: i, options: r }
        s.push(o)
        let a = sy(),
          l = null,
          c
        try {
          c = this.#t(s)
        } catch (u) {
          l = u
        }
        return (
          queueMicrotask(() => {
            l === null ? a.resolve(!!c?.length) : a.reject(l)
          }),
          a.promise
        )
      }
      async keys(t = undefined, r = {}) {
        tt.brandCheck(this, e)
        let n = "Cache.keys"
        t !== undefined && (t = tt.converters.RequestInfo(t, n, "request")),
          (r = tt.converters.CacheQueryOptions(r, n, "options"))
        let i = null
        if (t !== undefined)
          if (t instanceof Kd) {
            if (((i = t[Tc]), i.method !== "GET" && !r.ignoreMethod)) return []
          } else typeof t == "string" && (i = new Kd(t)[Tc])
        let s = sy(),
          o = []
        if (t === undefined) for (let a of this.#e) o.push(a[0])
        else {
          let a = this.#i(i, r)
          for (let l of a) o.push(l[0])
        }
        return (
          queueMicrotask(() => {
            let a = []
            for (let l of o) {
              let c = vje(l, new AbortController().signal, "immutable")
              a.push(c)
            }
            s.resolve(Object.freeze(a))
          }),
          s.promise
        )
      }
      #t(t) {
        let r = this.#e,
          n = [...r],
          i = [],
          s = []
        try {
          for (let o of t) {
            if (o.type !== "delete" && o.type !== "put")
              throw tt.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: 'operation type does not match "delete" or "put"',
              })
            if (o.type === "delete" && o.response != null)
              throw tt.errors.exception({
                header: "Cache.#batchCacheOperations",
                message:
                  "delete operation should not have an associated response",
              })
            if (this.#i(o.request, o.options, i).length)
              throw new DOMException("???", "InvalidStateError")
            let a
            if (o.type === "delete") {
              if (((a = this.#i(o.request, o.options)), a.length === 0))
                return []
              for (let l of a) {
                let c = r.indexOf(l)
                oW(c !== -1), r.splice(c, 1)
              }
            } else if (o.type === "put") {
              if (o.response == null)
                throw tt.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "put operation should have an associated response",
                })
              let l = o.request
              if (!MD(l.url))
                throw tt.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "expected http or https scheme",
                })
              if (l.method !== "GET")
                throw tt.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "not get method",
                })
              if (o.options != null)
                throw tt.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "options must not be defined",
                })
              a = this.#i(o.request)
              for (let c of a) {
                let u = r.indexOf(c)
                oW(u !== -1), r.splice(u, 1)
              }
              r.push([o.request, o.response]), i.push([o.request, o.response])
            }
            s.push([o.request, o.response])
          }
          return s
        } catch (o) {
          throw ((this.#e.length = 0), (this.#e = n), o)
        }
      }
      #i(t, r, n) {
        let i = [],
          s = n ?? this.#e
        for (let o of s) {
          let [a, l] = o
          this.#n(t, a, l, r) && i.push(o)
        }
        return i
      }
      #n(t, r, n = null, i) {
        let s = new URL(t.url),
          o = new URL(r.url)
        if (
          (i?.ignoreSearch && ((o.search = ""), (s.search = "")),
          !gje(s, o, true))
        )
          return false
        if (n == null || i?.ignoreVary || !n.headersList.contains("vary"))
          return true
        let a = sW(n.headersList.get("vary"))
        for (let l of a) {
          if (l === "*") return false
          let c = r.headersList.get(l),
            u = t.headersList.get(l)
          if (c !== u) return false
        }
        return true
      }
      #r(t, r, n = 1 / 0) {
        let i = null
        if (t !== undefined)
          if (t instanceof Kd) {
            if (((i = t[Tc]), i.method !== "GET" && !r.ignoreMethod)) return []
          } else typeof t == "string" && (i = new Kd(t)[Tc])
        let s = []
        if (t === undefined) for (let a of this.#e) s.push(a[1])
        else {
          let a = this.#i(i, r)
          for (let l of a) s.push(l[1])
        }
        let o = []
        for (let a of s) {
          let l = yje(a, "immutable")
          if ((o.push(l.clone()), o.length >= n)) break
        }
        return Object.freeze(o)
      }
    }
  Object.defineProperties(FD.prototype, {
    [Symbol.toStringTag]: { value: "Cache", configurable: true },
    match: Up,
    matchAll: Up,
    add: Up,
    addAll: Up,
    put: Up,
    delete: Up,
    keys: Up,
  })
  var fle = [
    {
      key: "ignoreSearch",
      converter: tt.converters.boolean,
      defaultValue: () => false,
    },
    {
      key: "ignoreMethod",
      converter: tt.converters.boolean,
      defaultValue: () => false,
    },
    {
      key: "ignoreVary",
      converter: tt.converters.boolean,
      defaultValue: () => false,
    },
  ]
  tt.converters.CacheQueryOptions = tt.dictionaryConverter(fle)
  tt.converters.MultiCacheQueryOptions = tt.dictionaryConverter([
    ...fle,
    { key: "cacheName", converter: tt.converters.DOMString },
  ])
  tt.converters.Response = tt.interfaceConverter(mje)
  tt.converters["sequence<RequestInfo>"] = tt.sequenceConverter(
    tt.converters.RequestInfo,
  )
  hle.exports = { Cache: FD }
})
var mle = _((RTt, ple) => {
  "use strict"
  var { kConstruct: jE } = kD(),
    { Cache: QD } = gle(),
    { webidl: js } = Is(),
    { kEnumerableProperty: ZE } = ir(),
    ND = class e {
      #e = new Map()
      constructor() {
        arguments[0] !== jE && js.illegalConstructor(),
          js.util.markAsUncloneable(this)
      }
      async match(t, r = {}) {
        if (
          (js.brandCheck(this, e),
          js.argumentLengthCheck(arguments, 1, "CacheStorage.match"),
          (t = js.converters.RequestInfo(t)),
          (r = js.converters.MultiCacheQueryOptions(r)),
          r.cacheName != null)
        ) {
          if (this.#e.has(r.cacheName)) {
            let n = this.#e.get(r.cacheName)
            return await new QD(jE, n).match(t, r)
          }
        } else
          for (let n of this.#e.values()) {
            let s = await new QD(jE, n).match(t, r)
            if (s !== undefined) return s
          }
      }
      async has(t) {
        js.brandCheck(this, e)
        let r = "CacheStorage.has"
        return (
          js.argumentLengthCheck(arguments, 1, r),
          (t = js.converters.DOMString(t, r, "cacheName")),
          this.#e.has(t)
        )
      }
      async open(t) {
        js.brandCheck(this, e)
        let r = "CacheStorage.open"
        if (
          (js.argumentLengthCheck(arguments, 1, r),
          (t = js.converters.DOMString(t, r, "cacheName")),
          this.#e.has(t))
        ) {
          let i = this.#e.get(t)
          return new QD(jE, i)
        }
        let n = []
        return this.#e.set(t, n), new QD(jE, n)
      }
      async delete(t) {
        js.brandCheck(this, e)
        let r = "CacheStorage.delete"
        return (
          js.argumentLengthCheck(arguments, 1, r),
          (t = js.converters.DOMString(t, r, "cacheName")),
          this.#e.delete(t)
        )
      }
      async keys() {
        return js.brandCheck(this, e), [...this.#e.keys()]
      }
    }
  Object.defineProperties(ND.prototype, {
    [Symbol.toStringTag]: { value: "CacheStorage", configurable: true },
    match: ZE,
    has: ZE,
    open: ZE,
    delete: ZE,
    keys: ZE,
  })
  ple.exports = { CacheStorage: ND }
})
var yle = _((DTt, Ale) => {
  "use strict"
  Ale.exports = { maxAttributeValueSize: 1024, maxNameValuePairSize: 4096 }
})
var aW = _((TTt, _le) => {
  "use strict"
  function Eje(e) {
    for (let t = 0; t < e.length; ++t) {
      let r = e.charCodeAt(t)
      if ((r >= 0 && r <= 8) || (r >= 10 && r <= 31) || r === 127) return true
    }
    return false
  }
  function vle(e) {
    for (let t = 0; t < e.length; ++t) {
      let r = e.charCodeAt(t)
      if (
        r < 33 ||
        r > 126 ||
        r === 34 ||
        r === 40 ||
        r === 41 ||
        r === 60 ||
        r === 62 ||
        r === 64 ||
        r === 44 ||
        r === 59 ||
        r === 58 ||
        r === 92 ||
        r === 47 ||
        r === 91 ||
        r === 93 ||
        r === 63 ||
        r === 61 ||
        r === 123 ||
        r === 125
      )
        throw new Error("Invalid cookie name")
    }
  }
  function Cle(e) {
    let t = e.length,
      r = 0
    if (e[0] === '"') {
      if (t === 1 || e[t - 1] !== '"') throw new Error("Invalid cookie value")
      --t, ++r
    }
    for (; r < t; ) {
      let n = e.charCodeAt(r++)
      if (n < 33 || n > 126 || n === 34 || n === 44 || n === 59 || n === 92)
        throw new Error("Invalid cookie value")
    }
  }
  function ble(e) {
    for (let t = 0; t < e.length; ++t) {
      let r = e.charCodeAt(t)
      if (r < 32 || r === 127 || r === 59)
        throw new Error("Invalid cookie path")
    }
  }
  function _je(e) {
    if (e.startsWith("-") || e.endsWith(".") || e.endsWith("-"))
      throw new Error("Invalid cookie domain")
  }
  var xje = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wje = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
    ],
    PD = Array(61)
      .fill(0)
      .map((e, t) => t.toString().padStart(2, "0"))
  function Ele(e) {
    return (
      typeof e == "number" && (e = new Date(e)),
      `${xje[e.getUTCDay()]}, ${PD[e.getUTCDate()]} ${wje[e.getUTCMonth()]} ${e.getUTCFullYear()} ${PD[e.getUTCHours()]}:${PD[e.getUTCMinutes()]}:${PD[e.getUTCSeconds()]} GMT`
    )
  }
  function Sje(e) {
    if (e < 0) throw new Error("Invalid cookie max-age")
  }
  function Ije(e) {
    if (e.name.length === 0) return null
    vle(e.name), Cle(e.value)
    let t = [`${e.name}=${e.value}`]
    e.name.startsWith("__Secure-") && (e.secure = true),
      e.name.startsWith("__Host-") &&
        ((e.secure = true), (e.domain = null), (e.path = "/")),
      e.secure && t.push("Secure"),
      e.httpOnly && t.push("HttpOnly"),
      typeof e.maxAge == "number" &&
        (Sje(e.maxAge), t.push(`Max-Age=${e.maxAge}`)),
      e.domain && (_je(e.domain), t.push(`Domain=${e.domain}`)),
      e.path && (ble(e.path), t.push(`Path=${e.path}`)),
      e.expires &&
        e.expires.toString() !== "Invalid Date" &&
        t.push(`Expires=${Ele(e.expires)}`),
      e.sameSite && t.push(`SameSite=${e.sameSite}`)
    for (let r of e.unparsed) {
      if (!r.includes("=")) throw new Error("Invalid unparsed")
      let [n, ...i] = r.split("=")
      t.push(`${n.trim()}=${i.join("=")}`)
    }
    return t.join("; ")
  }
  _le.exports = {
    isCTLExcludingHtab: Eje,
    validateCookieName: vle,
    validateCookiePath: ble,
    validateCookieValue: Cle,
    toIMFDate: Ele,
    stringify: Ije,
  }
})
var wle = _((kTt, xle) => {
  "use strict"
  var { maxNameValuePairSize: Bje, maxAttributeValueSize: Rje } = yle(),
    { isCTLExcludingHtab: Dje } = aW(),
    { collectASequenceOfCodePointsFast: LD } = zo(),
    Tje = require("assert")
  function kje(e) {
    if (Dje(e)) return null
    let t = "",
      r = "",
      n = "",
      i = ""
    if (e.includes(";")) {
      let s = { position: 0 }
      ;(t = LD(";", e, s)), (r = e.slice(s.position))
    } else t = e
    if (!t.includes("=")) i = t
    else {
      let s = { position: 0 }
      ;(n = LD("=", t, s)), (i = t.slice(s.position + 1))
    }
    return (
      (n = n.trim()),
      (i = i.trim()),
      n.length + i.length > Bje ? null : { name: n, value: i, ...oy(r) }
    )
  }
  function oy(e, t = {}) {
    if (e.length === 0) return t
    Tje(e[0] === ";"), (e = e.slice(1))
    let r = ""
    e.includes(";")
      ? ((r = LD(";", e, { position: 0 })), (e = e.slice(r.length)))
      : ((r = e), (e = ""))
    let n = "",
      i = ""
    if (r.includes("=")) {
      let o = { position: 0 }
      ;(n = LD("=", r, o)), (i = r.slice(o.position + 1))
    } else n = r
    if (((n = n.trim()), (i = i.trim()), i.length > Rje)) return oy(e, t)
    let s = n.toLowerCase()
    if (s === "expires") {
      let o = new Date(i)
      t.expires = o
    } else if (s === "max-age") {
      let o = i.charCodeAt(0)
      if (((o < 48 || o > 57) && i[0] !== "-") || !/^\d+$/.test(i))
        return oy(e, t)
      let a = Number(i)
      t.maxAge = a
    } else if (s === "domain") {
      let o = i
      o[0] === "." && (o = o.slice(1)), (o = o.toLowerCase()), (t.domain = o)
    } else if (s === "path") {
      let o = ""
      i.length === 0 || i[0] !== "/" ? (o = "/") : (o = i), (t.path = o)
    } else if (s === "secure") t.secure = true
    else if (s === "httponly") t.httpOnly = true
    else if (s === "samesite") {
      let o = "Default",
        a = i.toLowerCase()
      a.includes("none") && (o = "None"),
        a.includes("strict") && (o = "Strict"),
        a.includes("lax") && (o = "Lax"),
        (t.sameSite = o)
    } else (t.unparsed ??= []), t.unparsed.push(`${n}=${i}`)
    return oy(e, t)
  }
  xle.exports = { parseSetCookie: kje, parseUnparsedAttributes: oy }
})
var Ble = _((MTt, Ile) => {
  "use strict"
  var { parseSetCookie: Mje } = wle(),
    { stringify: Fje } = aW(),
    { webidl: yr } = Is(),
    { Headers: UD } = Fp()
  function Qje(e) {
    yr.argumentLengthCheck(arguments, 1, "getCookies"),
      yr.brandCheck(e, UD, { strict: false })
    let t = e.get("cookie"),
      r = {}
    if (!t) return r
    for (let n of t.split(";")) {
      let [i, ...s] = n.split("=")
      r[i.trim()] = s.join("=")
    }
    return r
  }
  function Nje(e, t, r) {
    yr.brandCheck(e, UD, { strict: false })
    let n = "deleteCookie"
    yr.argumentLengthCheck(arguments, 2, n),
      (t = yr.converters.DOMString(t, n, "name")),
      (r = yr.converters.DeleteCookieAttributes(r)),
      Sle(e, { name: t, value: "", expires: new Date(0), ...r })
  }
  function Pje(e) {
    yr.argumentLengthCheck(arguments, 1, "getSetCookies"),
      yr.brandCheck(e, UD, { strict: false })
    let t = e.getSetCookie()
    return t ? t.map((r) => Mje(r)) : []
  }
  function Sle(e, t) {
    yr.argumentLengthCheck(arguments, 2, "setCookie"),
      yr.brandCheck(e, UD, { strict: false }),
      (t = yr.converters.Cookie(t))
    let r = Fje(t)
    r && e.append("Set-Cookie", r)
  }
  yr.converters.DeleteCookieAttributes = yr.dictionaryConverter([
    {
      converter: yr.nullableConverter(yr.converters.DOMString),
      key: "path",
      defaultValue: () => null,
    },
    {
      converter: yr.nullableConverter(yr.converters.DOMString),
      key: "domain",
      defaultValue: () => null,
    },
  ])
  yr.converters.Cookie = yr.dictionaryConverter([
    { converter: yr.converters.DOMString, key: "name" },
    { converter: yr.converters.DOMString, key: "value" },
    {
      converter: yr.nullableConverter((e) =>
        typeof e == "number"
          ? yr.converters["unsigned long long"](e)
          : new Date(e),
      ),
      key: "expires",
      defaultValue: () => null,
    },
    {
      converter: yr.nullableConverter(yr.converters["long long"]),
      key: "maxAge",
      defaultValue: () => null,
    },
    {
      converter: yr.nullableConverter(yr.converters.DOMString),
      key: "domain",
      defaultValue: () => null,
    },
    {
      converter: yr.nullableConverter(yr.converters.DOMString),
      key: "path",
      defaultValue: () => null,
    },
    {
      converter: yr.nullableConverter(yr.converters.boolean),
      key: "secure",
      defaultValue: () => null,
    },
    {
      converter: yr.nullableConverter(yr.converters.boolean),
      key: "httpOnly",
      defaultValue: () => null,
    },
    {
      converter: yr.converters.USVString,
      key: "sameSite",
      allowedValues: ["Strict", "Lax", "None"],
    },
    {
      converter: yr.sequenceConverter(yr.converters.DOMString),
      key: "unparsed",
      defaultValue: () => new Array(0),
    },
  ])
  Ile.exports = {
    getCookies: Qje,
    deleteCookie: Nje,
    getSetCookies: Pje,
    setCookie: Sle,
  }
})
var ly = _((FTt, Dle) => {
  "use strict"
  var { webidl: et } = Is(),
    { kEnumerableProperty: Xo } = ir(),
    { kConstruct: Rle } = Wn(),
    { MessagePort: Lje } = require("worker_threads"),
    ay = class e extends Event {
      #e
      constructor(t, r = {}) {
        if (t === Rle) {
          super(arguments[1], arguments[2]), et.util.markAsUncloneable(this)
          return
        }
        let n = "MessageEvent constructor"
        et.argumentLengthCheck(arguments, 1, n),
          (t = et.converters.DOMString(t, n, "type")),
          (r = et.converters.MessageEventInit(r, n, "eventInitDict")),
          super(t, r),
          (this.#e = r),
          et.util.markAsUncloneable(this)
      }
      get data() {
        return et.brandCheck(this, e), this.#e.data
      }
      get origin() {
        return et.brandCheck(this, e), this.#e.origin
      }
      get lastEventId() {
        return et.brandCheck(this, e), this.#e.lastEventId
      }
      get source() {
        return et.brandCheck(this, e), this.#e.source
      }
      get ports() {
        return (
          et.brandCheck(this, e),
          Object.isFrozen(this.#e.ports) || Object.freeze(this.#e.ports),
          this.#e.ports
        )
      }
      initMessageEvent(
        t,
        r = false,
        n = false,
        i = null,
        s = "",
        o = "",
        a = null,
        l = [],
      ) {
        return (
          et.brandCheck(this, e),
          et.argumentLengthCheck(arguments, 1, "MessageEvent.initMessageEvent"),
          new e(t, {
            bubbles: r,
            cancelable: n,
            data: i,
            origin: s,
            lastEventId: o,
            source: a,
            ports: l,
          })
        )
      }
      static createFastMessageEvent(t, r) {
        let n = new e(Rle, t, r)
        return (
          (n.#e = r),
          (n.#e.data ??= null),
          (n.#e.origin ??= ""),
          (n.#e.lastEventId ??= ""),
          (n.#e.source ??= null),
          (n.#e.ports ??= []),
          n
        )
      }
    },
    { createFastMessageEvent: Uje } = ay
  delete ay.createFastMessageEvent
  var OD = class e extends Event {
      #e
      constructor(t, r = {}) {
        let n = "CloseEvent constructor"
        et.argumentLengthCheck(arguments, 1, n),
          (t = et.converters.DOMString(t, n, "type")),
          (r = et.converters.CloseEventInit(r)),
          super(t, r),
          (this.#e = r),
          et.util.markAsUncloneable(this)
      }
      get wasClean() {
        return et.brandCheck(this, e), this.#e.wasClean
      }
      get code() {
        return et.brandCheck(this, e), this.#e.code
      }
      get reason() {
        return et.brandCheck(this, e), this.#e.reason
      }
    },
    qD = class e extends Event {
      #e
      constructor(t, r) {
        let n = "ErrorEvent constructor"
        et.argumentLengthCheck(arguments, 1, n),
          super(t, r),
          et.util.markAsUncloneable(this),
          (t = et.converters.DOMString(t, n, "type")),
          (r = et.converters.ErrorEventInit(r ?? {})),
          (this.#e = r)
      }
      get message() {
        return et.brandCheck(this, e), this.#e.message
      }
      get filename() {
        return et.brandCheck(this, e), this.#e.filename
      }
      get lineno() {
        return et.brandCheck(this, e), this.#e.lineno
      }
      get colno() {
        return et.brandCheck(this, e), this.#e.colno
      }
      get error() {
        return et.brandCheck(this, e), this.#e.error
      }
    }
  Object.defineProperties(ay.prototype, {
    [Symbol.toStringTag]: { value: "MessageEvent", configurable: true },
    data: Xo,
    origin: Xo,
    lastEventId: Xo,
    source: Xo,
    ports: Xo,
    initMessageEvent: Xo,
  })
  Object.defineProperties(OD.prototype, {
    [Symbol.toStringTag]: { value: "CloseEvent", configurable: true },
    reason: Xo,
    code: Xo,
    wasClean: Xo,
  })
  Object.defineProperties(qD.prototype, {
    [Symbol.toStringTag]: { value: "ErrorEvent", configurable: true },
    message: Xo,
    filename: Xo,
    lineno: Xo,
    colno: Xo,
    error: Xo,
  })
  et.converters.MessagePort = et.interfaceConverter(Lje)
  et.converters["sequence<MessagePort>"] = et.sequenceConverter(
    et.converters.MessagePort,
  )
  var lW = [
    {
      key: "bubbles",
      converter: et.converters.boolean,
      defaultValue: () => false,
    },
    {
      key: "cancelable",
      converter: et.converters.boolean,
      defaultValue: () => false,
    },
    {
      key: "composed",
      converter: et.converters.boolean,
      defaultValue: () => false,
    },
  ]
  et.converters.MessageEventInit = et.dictionaryConverter([
    ...lW,
    { key: "data", converter: et.converters.any, defaultValue: () => null },
    {
      key: "origin",
      converter: et.converters.USVString,
      defaultValue: () => "",
    },
    {
      key: "lastEventId",
      converter: et.converters.DOMString,
      defaultValue: () => "",
    },
    {
      key: "source",
      converter: et.nullableConverter(et.converters.MessagePort),
      defaultValue: () => null,
    },
    {
      key: "ports",
      converter: et.converters["sequence<MessagePort>"],
      defaultValue: () => new Array(0),
    },
  ])
  et.converters.CloseEventInit = et.dictionaryConverter([
    ...lW,
    {
      key: "wasClean",
      converter: et.converters.boolean,
      defaultValue: () => false,
    },
    {
      key: "code",
      converter: et.converters["unsigned short"],
      defaultValue: () => 0,
    },
    {
      key: "reason",
      converter: et.converters.USVString,
      defaultValue: () => "",
    },
  ])
  et.converters.ErrorEventInit = et.dictionaryConverter([
    ...lW,
    {
      key: "message",
      converter: et.converters.DOMString,
      defaultValue: () => "",
    },
    {
      key: "filename",
      converter: et.converters.USVString,
      defaultValue: () => "",
    },
    {
      key: "lineno",
      converter: et.converters["unsigned long"],
      defaultValue: () => 0,
    },
    {
      key: "colno",
      converter: et.converters["unsigned long"],
      defaultValue: () => 0,
    },
    { key: "error", converter: et.converters.any },
  ])
  Dle.exports = {
    MessageEvent: ay,
    CloseEvent: OD,
    ErrorEvent: qD,
    createFastMessageEvent: Uje,
  }
})
var Op = _((QTt, Tle) => {
  "use strict"
  var Oje = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    qje = { enumerable: true, writable: false, configurable: false },
    Vje = { CONNECTING: 0, OPEN: 1, CLOSING: 2, CLOSED: 3 },
    Hje = { NOT_SENT: 0, PROCESSING: 1, SENT: 2 },
    Wje = { CONTINUATION: 0, TEXT: 1, BINARY: 2, CLOSE: 8, PING: 9, PONG: 10 },
    Gje = 2 ** 16 - 1,
    $je = { INFO: 0, PAYLOADLENGTH_16: 2, PAYLOADLENGTH_64: 3, READ_DATA: 4 },
    Yje = Buffer.allocUnsafe(0),
    Kje = { string: 1, typedArray: 2, arrayBuffer: 3, blob: 4 }
  Tle.exports = {
    uid: Oje,
    sentCloseFrameState: Hje,
    staticPropertyDescriptors: qje,
    states: Vje,
    opcodes: Wje,
    maxUnsigned16Bit: Gje,
    parserStates: $je,
    emptyBuffer: Yje,
    sendHints: Kje,
  }
})
var XE = _((NTt, kle) => {
  "use strict"
  kle.exports = {
    kWebSocketURL: Symbol("url"),
    kReadyState: Symbol("ready state"),
    kController: Symbol("controller"),
    kResponse: Symbol("response"),
    kBinaryType: Symbol("binary type"),
    kSentClose: Symbol("sent close"),
    kReceivedClose: Symbol("received close"),
    kByteParser: Symbol("byte parser"),
  }
})
var r_ = _((PTt, qle) => {
  "use strict"
  var {
      kReadyState: e_,
      kController: zje,
      kResponse: Jje,
      kBinaryType: jje,
      kWebSocketURL: Zje,
    } = XE(),
    { states: t_, opcodes: xh } = Op(),
    { ErrorEvent: Xje, createFastMessageEvent: e7e } = ly(),
    { isUtf8: t7e } = require("buffer"),
    { collectASequenceOfCodePointsFast: r7e, removeHTTPWhitespace: Mle } = zo()
  function n7e(e) {
    return e[e_] === t_.CONNECTING
  }
  function i7e(e) {
    return e[e_] === t_.OPEN
  }
  function s7e(e) {
    return e[e_] === t_.CLOSING
  }
  function o7e(e) {
    return e[e_] === t_.CLOSED
  }
  function cW(e, t, r = (i, s) => new Event(i, s), n = {}) {
    let i = r(e, n)
    t.dispatchEvent(i)
  }
  function a7e(e, t, r) {
    if (e[e_] !== t_.OPEN) return
    let n
    if (t === xh.TEXT)
      try {
        n = Ole(r)
      } catch {
        Qle(e, "Received invalid UTF-8 in text frame.")
        return
      }
    else
      t === xh.BINARY &&
        (e[jje] === "blob" ? (n = new Blob([r])) : (n = l7e(r)))
    cW("message", e, e7e, { origin: e[Zje].origin, data: n })
  }
  function l7e(e) {
    return e.byteLength === e.buffer.byteLength
      ? e.buffer
      : e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength)
  }
  function c7e(e) {
    if (e.length === 0) return false
    for (let t = 0; t < e.length; ++t) {
      let r = e.charCodeAt(t)
      if (
        r < 33 ||
        r > 126 ||
        r === 34 ||
        r === 40 ||
        r === 41 ||
        r === 44 ||
        r === 47 ||
        r === 58 ||
        r === 59 ||
        r === 60 ||
        r === 61 ||
        r === 62 ||
        r === 63 ||
        r === 64 ||
        r === 91 ||
        r === 92 ||
        r === 93 ||
        r === 123 ||
        r === 125
      )
        return false
    }
    return true
  }
  function u7e(e) {
    return e >= 1e3 && e < 1015
      ? e !== 1004 && e !== 1005 && e !== 1006
      : e >= 3e3 && e <= 4999
  }
  function Qle(e, t) {
    let { [zje]: r, [Jje]: n } = e
    r.abort(),
      n?.socket && !n.socket.destroyed && n.socket.destroy(),
      t &&
        cW("error", e, (i, s) => new Xje(i, s), {
          error: new Error(t),
          message: t,
        })
  }
  function Nle(e) {
    return e === xh.CLOSE || e === xh.PING || e === xh.PONG
  }
  function Ple(e) {
    return e === xh.CONTINUATION
  }
  function Lle(e) {
    return e === xh.TEXT || e === xh.BINARY
  }
  function d7e(e) {
    return Lle(e) || Ple(e) || Nle(e)
  }
  function f7e(e) {
    let t = { position: 0 },
      r = new Map()
    for (; t.position < e.length; ) {
      let n = r7e(";", e, t),
        [i, s = ""] = n.split("=")
      r.set(Mle(i, true, false), Mle(s, false, true)), t.position++
    }
    return r
  }
  function h7e(e) {
    for (let t = 0; t < e.length; t++) {
      let r = e.charCodeAt(t)
      if (r < 48 || r > 57) return false
    }
    return true
  }
  var Ule = typeof process.versions.icu == "string",
    Fle = Ule ? new TextDecoder("utf-8", { fatal: true }) : undefined,
    Ole = Ule
      ? Fle.decode.bind(Fle)
      : function (e) {
          if (t7e(e)) return e.toString("utf-8")
          throw new TypeError("Invalid utf-8 received.")
        }
  qle.exports = {
    isConnecting: n7e,
    isEstablished: i7e,
    isClosing: s7e,
    isClosed: o7e,
    fireEvent: cW,
    isValidSubprotocol: c7e,
    isValidStatusCode: u7e,
    failWebsocketConnection: Qle,
    websocketMessageReceived: a7e,
    utf8Decode: Ole,
    isControlFrame: Nle,
    isContinuationFrame: Ple,
    isTextBinaryFrame: Lle,
    isValidOpcode: d7e,
    parseExtensions: f7e,
    isValidClientWindowBits: h7e,
  }
})
var HD = _((LTt, Vle) => {
  "use strict"
  var { maxUnsigned16Bit: g7e } = Op(),
    VD = 16386,
    uW,
    n_ = null,
    cy = VD
  try {
    uW = require("crypto")
  } catch {
    uW = {
      randomFillSync: function (t, r, n) {
        for (let i = 0; i < t.length; ++i) t[i] = (Math.random() * 255) | 0
        return t
      },
    }
  }
  function p7e() {
    return (
      cy === VD &&
        ((cy = 0), uW.randomFillSync((n_ ??= Buffer.allocUnsafe(VD)), 0, VD)),
      [n_[cy++], n_[cy++], n_[cy++], n_[cy++]]
    )
  }
  var dW = class {
    constructor(t) {
      this.frameData = t
    }
    createFrame(t) {
      let r = this.frameData,
        n = p7e(),
        i = r?.byteLength ?? 0,
        s = i,
        o = 6
      i > g7e ? ((o += 8), (s = 127)) : i > 125 && ((o += 2), (s = 126))
      let a = Buffer.allocUnsafe(i + o)
      ;(a[0] = a[1] = 0), (a[0] |= 128), (a[0] = (a[0] & 240) + t)
      ;(a[o - 4] = n[0]),
        (a[o - 3] = n[1]),
        (a[o - 2] = n[2]),
        (a[o - 1] = n[3]),
        (a[1] = s),
        s === 126
          ? a.writeUInt16BE(i, 2)
          : s === 127 && ((a[2] = a[3] = 0), a.writeUIntBE(i, 4, 6)),
        (a[1] |= 128)
      for (let l = 0; l < i; ++l) a[o + l] = r[l] ^ n[l & 3]
      return a
    }
  }
  Vle.exports = { WebsocketFrameSend: dW }
})
var hW = _((UTt, zle) => {
  "use strict"
  var {
      uid: m7e,
      states: i_,
      sentCloseFrameState: WD,
      emptyBuffer: A7e,
      opcodes: y7e,
    } = Op(),
    {
      kReadyState: s_,
      kSentClose: GD,
      kByteParser: Wle,
      kReceivedClose: Hle,
      kResponse: Gle,
    } = XE(),
    {
      fireEvent: v7e,
      failWebsocketConnection: wh,
      isClosing: C7e,
      isClosed: b7e,
      isEstablished: E7e,
      parseExtensions: _7e,
    } = r_(),
    { channels: uy } = _0(),
    { CloseEvent: x7e } = ly(),
    { makeRequest: w7e } = ry(),
    { fetching: S7e } = zE(),
    { Headers: I7e, getHeadersList: B7e } = Fp(),
    { getDecodeSplit: R7e } = Ba(),
    { WebsocketFrameSend: D7e } = HD(),
    fW
  try {
    fW = require("crypto")
  } catch {}
  function T7e(e, t, r, n, i, s) {
    let o = e
    o.protocol = e.protocol === "ws:" ? "http:" : "https:"
    let a = w7e({
      urlList: [o],
      client: r,
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error",
    })
    if (s.headers) {
      let f = B7e(new I7e(s.headers))
      a.headersList = f
    }
    let l = fW.randomBytes(16).toString("base64")
    a.headersList.append("sec-websocket-key", l),
      a.headersList.append("sec-websocket-version", "13")
    for (let f of t) a.headersList.append("sec-websocket-protocol", f)
    let c = "permessage-deflate; client_max_window_bits"
    return (
      a.headersList.append("sec-websocket-extensions", c),
      S7e({
        request: a,
        useParallelQueue: true,
        dispatcher: s.dispatcher,
        processResponse(f) {
          if (f.type === "error" || f.status !== 101) {
            wh(n, "Received network error or non-101 status code.")
            return
          }
          if (t.length !== 0 && !f.headersList.get("Sec-WebSocket-Protocol")) {
            wh(n, "Server did not respond with sent protocols.")
            return
          }
          if (f.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
            wh(n, 'Server did not set Upgrade header to "websocket".')
            return
          }
          if (f.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
            wh(n, 'Server did not set Connection header to "upgrade".')
            return
          }
          let p = f.headersList.get("Sec-WebSocket-Accept"),
            g = fW
              .createHash("sha1")
              .update(l + m7e)
              .digest("base64")
          if (p !== g) {
            wh(n, "Incorrect hash received in Sec-WebSocket-Accept header.")
            return
          }
          let m = f.headersList.get("Sec-WebSocket-Extensions"),
            y
          if (m !== null && ((y = _7e(m)), !y.has("permessage-deflate"))) {
            wh(n, "Sec-WebSocket-Extensions header does not match.")
            return
          }
          let v = f.headersList.get("Sec-WebSocket-Protocol")
          if (
            v !== null &&
            !R7e("sec-websocket-protocol", a.headersList).includes(v)
          ) {
            wh(n, "Protocol was not set in the opening handshake.")
            return
          }
          f.socket.on("data", $le),
            f.socket.on("close", Yle),
            f.socket.on("error", Kle),
            uy.open.hasSubscribers &&
              uy.open.publish({
                address: f.socket.address(),
                protocol: v,
                extensions: m,
              }),
            i(f, y)
        },
      })
    )
  }
  function k7e(e, t, r, n) {
    if (!(C7e(e) || b7e(e)))
      if (!E7e(e))
        wh(e, "Connection was closed before it was established."),
          (e[s_] = i_.CLOSING)
      else if (e[GD] === WD.NOT_SENT) {
        e[GD] = WD.PROCESSING
        let i = new D7e()
        t !== undefined && r === undefined
          ? ((i.frameData = Buffer.allocUnsafe(2)),
            i.frameData.writeUInt16BE(t, 0))
          : t !== undefined && r !== undefined
            ? ((i.frameData = Buffer.allocUnsafe(2 + n)),
              i.frameData.writeUInt16BE(t, 0),
              i.frameData.write(r, 2, "utf-8"))
            : (i.frameData = A7e),
          e[Gle].socket.write(i.createFrame(y7e.CLOSE)),
          (e[GD] = WD.SENT),
          (e[s_] = i_.CLOSING)
      } else e[s_] = i_.CLOSING
  }
  function $le(e) {
    this.ws[Wle].write(e) || this.pause()
  }
  function Yle() {
    let { ws: e } = this,
      { [Gle]: t } = e
    t.socket.off("data", $le),
      t.socket.off("close", Yle),
      t.socket.off("error", Kle)
    let r = e[GD] === WD.SENT && e[Hle],
      n = 1005,
      i = "",
      s = e[Wle].closingInfo
    s && !s.error
      ? ((n = s.code ?? 1005), (i = s.reason))
      : e[Hle] || (n = 1006),
      (e[s_] = i_.CLOSED),
      v7e("close", e, (o, a) => new x7e(o, a), {
        wasClean: r,
        code: n,
        reason: i,
      }),
      uy.close.hasSubscribers &&
        uy.close.publish({ websocket: e, code: n, reason: i })
  }
  function Kle(e) {
    let { ws: t } = this
    ;(t[s_] = i_.CLOSING),
      uy.socketError.hasSubscribers && uy.socketError.publish(e),
      this.destroy()
  }
  zle.exports = {
    establishWebSocketConnection: T7e,
    closeWebSocketConnection: k7e,
  }
})
var jle = _((OTt, Jle) => {
  "use strict"
  var { createInflateRaw: M7e, Z_DEFAULT_WINDOWBITS: F7e } = require("zlib"),
    { isValidClientWindowBits: Q7e } = r_(),
    N7e = Buffer.from([0, 0, 255, 255]),
    $D = Symbol("kBuffer"),
    YD = Symbol("kLength"),
    gW = class {
      #e
      #t = {}
      constructor(t) {
        ;(this.#t.serverNoContextTakeover = t.has(
          "server_no_context_takeover",
        )),
          (this.#t.serverMaxWindowBits = t.get("server_max_window_bits"))
      }
      decompress(t, r, n) {
        if (!this.#e) {
          let i = F7e
          if (this.#t.serverMaxWindowBits) {
            if (!Q7e(this.#t.serverMaxWindowBits)) {
              n(new Error("Invalid server_max_window_bits"))
              return
            }
            i = Number.parseInt(this.#t.serverMaxWindowBits)
          }
          ;(this.#e = M7e({ windowBits: i })),
            (this.#e[$D] = []),
            (this.#e[YD] = 0),
            this.#e.on("data", (s) => {
              this.#e[$D].push(s), (this.#e[YD] += s.length)
            }),
            this.#e.on("error", (s) => {
              ;(this.#e = null), n(s)
            })
        }
        this.#e.write(t),
          r && this.#e.write(N7e),
          this.#e.flush(() => {
            let i = Buffer.concat(this.#e[$D], this.#e[YD])
            ;(this.#e[$D].length = 0), (this.#e[YD] = 0), n(null, i)
          })
      }
    }
  Jle.exports = { PerMessageDeflate: gW }
})
var lce = _((qTt, ace) => {
  "use strict"
  var { Writable: P7e } = require("stream"),
    L7e = require("assert"),
    {
      parserStates: ea,
      opcodes: dy,
      states: U7e,
      emptyBuffer: Zle,
      sentCloseFrameState: Xle,
    } = Op(),
    {
      kReadyState: O7e,
      kSentClose: ece,
      kResponse: tce,
      kReceivedClose: rce,
    } = XE(),
    { channels: KD } = _0(),
    {
      isValidStatusCode: q7e,
      isValidOpcode: V7e,
      failWebsocketConnection: Rl,
      websocketMessageReceived: nce,
      utf8Decode: H7e,
      isControlFrame: ice,
      isTextBinaryFrame: pW,
      isContinuationFrame: W7e,
    } = r_(),
    { WebsocketFrameSend: sce } = HD(),
    { closeWebSocketConnection: oce } = hW(),
    { PerMessageDeflate: G7e } = jle(),
    mW = class extends P7e {
      #e = []
      #t = 0
      #i = false
      #n = ea.INFO
      #r = {}
      #l = []
      #o
      constructor(t, r) {
        super(),
          (this.ws = t),
          (this.#o = r ?? new Map()),
          this.#o.has("permessage-deflate") &&
            this.#o.set("permessage-deflate", new G7e(r))
      }
      _write(t, r, n) {
        this.#e.push(t), (this.#t += t.length), (this.#i = true), this.run(n)
      }
      run(t) {
        for (; this.#i; )
          if (this.#n === ea.INFO) {
            if (this.#t < 2) return t()
            let r = this.consume(2),
              n = (r[0] & 128) !== 0,
              i = r[0] & 15,
              s = (r[1] & 128) === 128,
              o = !n && i !== dy.CONTINUATION,
              a = r[1] & 127,
              l = r[0] & 64,
              c = r[0] & 32,
              u = r[0] & 16
            if (!V7e(i)) return Rl(this.ws, "Invalid opcode received"), t()
            if (s) return Rl(this.ws, "Frame cannot be masked"), t()
            if (l !== 0 && !this.#o.has("permessage-deflate")) {
              Rl(this.ws, "Expected RSV1 to be clear.")
              return
            }
            if (c !== 0 || u !== 0) {
              Rl(this.ws, "RSV1, RSV2, RSV3 must be clear")
              return
            }
            if (o && !pW(i)) {
              Rl(this.ws, "Invalid frame type was fragmented.")
              return
            }
            if (pW(i) && this.#l.length > 0) {
              Rl(this.ws, "Expected continuation frame")
              return
            }
            if (this.#r.fragmented && o) {
              Rl(this.ws, "Fragmented frame exceeded 125 bytes.")
              return
            }
            if ((a > 125 || o) && ice(i)) {
              Rl(this.ws, "Control frame either too large or fragmented")
              return
            }
            if (W7e(i) && this.#l.length === 0 && !this.#r.compressed) {
              Rl(this.ws, "Unexpected continuation frame")
              return
            }
            a <= 125
              ? ((this.#r.payloadLength = a), (this.#n = ea.READ_DATA))
              : a === 126
                ? (this.#n = ea.PAYLOADLENGTH_16)
                : a === 127 && (this.#n = ea.PAYLOADLENGTH_64),
              pW(i) &&
                ((this.#r.binaryType = i), (this.#r.compressed = l !== 0)),
              (this.#r.opcode = i),
              (this.#r.masked = s),
              (this.#r.fin = n),
              (this.#r.fragmented = o)
          } else if (this.#n === ea.PAYLOADLENGTH_16) {
            if (this.#t < 2) return t()
            let r = this.consume(2)
            ;(this.#r.payloadLength = r.readUInt16BE(0)),
              (this.#n = ea.READ_DATA)
          } else if (this.#n === ea.PAYLOADLENGTH_64) {
            if (this.#t < 8) return t()
            let r = this.consume(8),
              n = r.readUInt32BE(0)
            if (n > 2 ** 31 - 1) {
              Rl(this.ws, "Received payload length > 2^31 bytes.")
              return
            }
            let i = r.readUInt32BE(4)
            ;(this.#r.payloadLength = (n << 8) + i), (this.#n = ea.READ_DATA)
          } else if (this.#n === ea.READ_DATA) {
            if (this.#t < this.#r.payloadLength) return t()
            let r = this.consume(this.#r.payloadLength)
            if (ice(this.#r.opcode))
              (this.#i = this.parseControlFrame(r)), (this.#n = ea.INFO)
            else if (this.#r.compressed) {
              this.#o
                .get("permessage-deflate")
                .decompress(r, this.#r.fin, (n, i) => {
                  if (n) {
                    oce(this.ws, 1007, n.message, n.message.length)
                    return
                  }
                  if ((this.#l.push(i), !this.#r.fin)) {
                    ;(this.#n = ea.INFO), (this.#i = true), this.run(t)
                    return
                  }
                  nce(this.ws, this.#r.binaryType, Buffer.concat(this.#l)),
                    (this.#i = true),
                    (this.#n = ea.INFO),
                    (this.#l.length = 0),
                    this.run(t)
                }),
                (this.#i = false)
              break
            } else {
              if ((this.#l.push(r), !this.#r.fragmented && this.#r.fin)) {
                let n = Buffer.concat(this.#l)
                nce(this.ws, this.#r.binaryType, n), (this.#l.length = 0)
              }
              this.#n = ea.INFO
            }
          }
      }
      consume(t) {
        if (t > this.#t)
          throw new Error("Called consume() before buffers satiated.")
        if (t === 0) return Zle
        if (this.#e[0].length === t)
          return (this.#t -= this.#e[0].length), this.#e.shift()
        let r = Buffer.allocUnsafe(t),
          n = 0
        for (; n !== t; ) {
          let i = this.#e[0],
            { length: s } = i
          if (s + n === t) {
            r.set(this.#e.shift(), n)
            break
          } else if (s + n > t) {
            r.set(i.subarray(0, t - n), n), (this.#e[0] = i.subarray(t - n))
            break
          } else r.set(this.#e.shift(), n), (n += i.length)
        }
        return (this.#t -= t), r
      }
      parseCloseBody(t) {
        L7e(t.length !== 1)
        let r
        if ((t.length >= 2 && (r = t.readUInt16BE(0)), r !== undefined && !q7e(r)))
          return { code: 1002, reason: "Invalid status code", error: true }
        let n = t.subarray(2)
        n[0] === 239 && n[1] === 187 && n[2] === 191 && (n = n.subarray(3))
        try {
          n = H7e(n)
        } catch {
          return { code: 1007, reason: "Invalid UTF-8", error: true }
        }
        return { code: r, reason: n, error: false }
      }
      parseControlFrame(t) {
        let { opcode: r, payloadLength: n } = this.#r
        if (r === dy.CLOSE) {
          if (n === 1)
            return Rl(this.ws, "Received close frame with a 1-byte body."), false
          if (
            ((this.#r.closeInfo = this.parseCloseBody(t)),
            this.#r.closeInfo.error)
          ) {
            let { code: i, reason: s } = this.#r.closeInfo
            return oce(this.ws, i, s, s.length), Rl(this.ws, s), false
          }
          if (this.ws[ece] !== Xle.SENT) {
            let i = Zle
            this.#r.closeInfo.code &&
              ((i = Buffer.allocUnsafe(2)),
              i.writeUInt16BE(this.#r.closeInfo.code, 0))
            let s = new sce(i)
            this.ws[tce].socket.write(s.createFrame(dy.CLOSE), (o) => {
              o || (this.ws[ece] = Xle.SENT)
            })
          }
          return (this.ws[O7e] = U7e.CLOSING), (this.ws[rce] = true), false
        } else if (r === dy.PING) {
          if (!this.ws[rce]) {
            let i = new sce(t)
            this.ws[tce].socket.write(i.createFrame(dy.PONG)),
              KD.ping.hasSubscribers && KD.ping.publish({ payload: t })
          }
        } else
          r === dy.PONG &&
            KD.pong.hasSubscribers &&
            KD.pong.publish({ payload: t })
        return true
      }
      get closingInfo() {
        return this.#r.closeInfo
      }
    }
  ace.exports = { ByteParser: mW }
})
var hce = _((VTt, fce) => {
  "use strict"
  var { WebsocketFrameSend: $7e } = HD(),
    { opcodes: cce, sendHints: fy } = Op(),
    Y7e = BV(),
    uce = Buffer[Symbol.species],
    AW = class {
      #e = new Y7e()
      #t = false
      #i
      constructor(t) {
        this.#i = t
      }
      add(t, r, n) {
        if (n !== fy.blob) {
          let s = dce(t, n)
          if (!this.#t) this.#i.write(s, r)
          else {
            let o = { promise: null, callback: r, frame: s }
            this.#e.push(o)
          }
          return
        }
        let i = {
          promise: t.arrayBuffer().then((s) => {
            ;(i.promise = null), (i.frame = dce(s, n))
          }),
          callback: r,
          frame: null,
        }
        this.#e.push(i), this.#t || this.#n()
      }
      async #n() {
        this.#t = true
        let t = this.#e
        for (; !t.isEmpty(); ) {
          let r = t.shift()
          r.promise !== null && (await r.promise),
            this.#i.write(r.frame, r.callback),
            (r.callback = r.frame = null)
        }
        this.#t = false
      }
    }
  function dce(e, t) {
    return new $7e(K7e(e, t)).createFrame(
      t === fy.string ? cce.TEXT : cce.BINARY,
    )
  }
  function K7e(e, t) {
    switch (t) {
      case fy.string:
        return Buffer.from(e)
      case fy.arrayBuffer:
      case fy.blob:
        return new uce(e)
      case fy.typedArray:
        return new uce(e.buffer, e.byteOffset, e.byteLength)
    }
  }
  fce.exports = { SendQueue: AW }
})
var Ece = _((HTt, bce) => {
  "use strict"
  var { webidl: xt } = Is(),
    { URLSerializer: z7e } = zo(),
    { environmentSettingsObject: gce } = Ba(),
    {
      staticPropertyDescriptors: Sh,
      states: o_,
      sentCloseFrameState: J7e,
      sendHints: zD,
    } = Op(),
    {
      kWebSocketURL: pce,
      kReadyState: yW,
      kController: j7e,
      kBinaryType: JD,
      kResponse: mce,
      kSentClose: Z7e,
      kByteParser: X7e,
    } = XE(),
    {
      isConnecting: eZe,
      isEstablished: tZe,
      isClosing: rZe,
      isValidSubprotocol: nZe,
      fireEvent: Ace,
    } = r_(),
    { establishWebSocketConnection: iZe, closeWebSocketConnection: yce } = hW(),
    { ByteParser: sZe } = lce(),
    { kEnumerableProperty: Dl, isBlobLike: vce } = ir(),
    { getGlobalDispatcher: oZe } = uD(),
    { types: Cce } = require("util"),
    { ErrorEvent: aZe, CloseEvent: lZe } = ly(),
    { SendQueue: cZe } = hce(),
    Qa = class e extends EventTarget {
      #e = { open: null, error: null, close: null, message: null }
      #t = 0
      #i = ""
      #n = ""
      #r
      constructor(t, r = []) {
        super(), xt.util.markAsUncloneable(this)
        let n = "WebSocket constructor"
        xt.argumentLengthCheck(arguments, 1, n)
        let i = xt.converters[
          "DOMString or sequence<DOMString> or WebSocketInit"
        ](r, n, "options")
        ;(t = xt.converters.USVString(t, n, "url")), (r = i.protocols)
        let s = gce.settingsObject.baseUrl,
          o
        try {
          o = new URL(t, s)
        } catch (l) {
          throw new DOMException(l, "SyntaxError")
        }
        if (
          (o.protocol === "http:"
            ? (o.protocol = "ws:")
            : o.protocol === "https:" && (o.protocol = "wss:"),
          o.protocol !== "ws:" && o.protocol !== "wss:")
        )
          throw new DOMException(
            `Expected a ws: or wss: protocol, got ${o.protocol}`,
            "SyntaxError",
          )
        if (o.hash || o.href.endsWith("#"))
          throw new DOMException("Got fragment", "SyntaxError")
        if (
          (typeof r == "string" && (r = [r]),
          r.length !== new Set(r.map((l) => l.toLowerCase())).size)
        )
          throw new DOMException(
            "Invalid Sec-WebSocket-Protocol value",
            "SyntaxError",
          )
        if (r.length > 0 && !r.every((l) => nZe(l)))
          throw new DOMException(
            "Invalid Sec-WebSocket-Protocol value",
            "SyntaxError",
          )
        this[pce] = new URL(o.href)
        let a = gce.settingsObject
        ;(this[j7e] = iZe(o, r, a, this, (l, c) => this.#l(l, c), i)),
          (this[yW] = e.CONNECTING),
          (this[Z7e] = J7e.NOT_SENT),
          (this[JD] = "blob")
      }
      close(t = undefined, r = undefined) {
        xt.brandCheck(this, e)
        let n = "WebSocket.close"
        if (
          (t !== undefined &&
            (t = xt.converters["unsigned short"](t, n, "code", { clamp: true })),
          r !== undefined && (r = xt.converters.USVString(r, n, "reason")),
          t !== undefined && t !== 1e3 && (t < 3e3 || t > 4999))
        )
          throw new DOMException("invalid code", "InvalidAccessError")
        let i = 0
        if (r !== undefined && ((i = Buffer.byteLength(r)), i > 123))
          throw new DOMException(
            `Reason must be less than 123 bytes; received ${i}`,
            "SyntaxError",
          )
        yce(this, t, r, i)
      }
      send(t) {
        xt.brandCheck(this, e)
        let r = "WebSocket.send"
        if (
          (xt.argumentLengthCheck(arguments, 1, r),
          (t = xt.converters.WebSocketSendData(t, r, "data")),
          eZe(this))
        )
          throw new DOMException("Sent before connected.", "InvalidStateError")
        if (!(!tZe(this) || rZe(this)))
          if (typeof t == "string") {
            let n = Buffer.byteLength(t)
            ;(this.#t += n),
              this.#r.add(
                t,
                () => {
                  this.#t -= n
                },
                zD.string,
              )
          } else
            Cce.isArrayBuffer(t)
              ? ((this.#t += t.byteLength),
                this.#r.add(
                  t,
                  () => {
                    this.#t -= t.byteLength
                  },
                  zD.arrayBuffer,
                ))
              : ArrayBuffer.isView(t)
                ? ((this.#t += t.byteLength),
                  this.#r.add(
                    t,
                    () => {
                      this.#t -= t.byteLength
                    },
                    zD.typedArray,
                  ))
                : vce(t) &&
                  ((this.#t += t.size),
                  this.#r.add(
                    t,
                    () => {
                      this.#t -= t.size
                    },
                    zD.blob,
                  ))
      }
      get readyState() {
        return xt.brandCheck(this, e), this[yW]
      }
      get bufferedAmount() {
        return xt.brandCheck(this, e), this.#t
      }
      get url() {
        return xt.brandCheck(this, e), z7e(this[pce])
      }
      get extensions() {
        return xt.brandCheck(this, e), this.#n
      }
      get protocol() {
        return xt.brandCheck(this, e), this.#i
      }
      get onopen() {
        return xt.brandCheck(this, e), this.#e.open
      }
      set onopen(t) {
        xt.brandCheck(this, e),
          this.#e.open && this.removeEventListener("open", this.#e.open),
          typeof t == "function"
            ? ((this.#e.open = t), this.addEventListener("open", t))
            : (this.#e.open = null)
      }
      get onerror() {
        return xt.brandCheck(this, e), this.#e.error
      }
      set onerror(t) {
        xt.brandCheck(this, e),
          this.#e.error && this.removeEventListener("error", this.#e.error),
          typeof t == "function"
            ? ((this.#e.error = t), this.addEventListener("error", t))
            : (this.#e.error = null)
      }
      get onclose() {
        return xt.brandCheck(this, e), this.#e.close
      }
      set onclose(t) {
        xt.brandCheck(this, e),
          this.#e.close && this.removeEventListener("close", this.#e.close),
          typeof t == "function"
            ? ((this.#e.close = t), this.addEventListener("close", t))
            : (this.#e.close = null)
      }
      get onmessage() {
        return xt.brandCheck(this, e), this.#e.message
      }
      set onmessage(t) {
        xt.brandCheck(this, e),
          this.#e.message &&
            this.removeEventListener("message", this.#e.message),
          typeof t == "function"
            ? ((this.#e.message = t), this.addEventListener("message", t))
            : (this.#e.message = null)
      }
      get binaryType() {
        return xt.brandCheck(this, e), this[JD]
      }
      set binaryType(t) {
        xt.brandCheck(this, e),
          t !== "blob" && t !== "arraybuffer"
            ? (this[JD] = "blob")
            : (this[JD] = t)
      }
      #l(t, r) {
        this[mce] = t
        let n = new sZe(this, r)
        n.on("drain", uZe),
          n.on("error", dZe.bind(this)),
          (t.socket.ws = this),
          (this[X7e] = n),
          (this.#r = new cZe(t.socket)),
          (this[yW] = o_.OPEN)
        let i = t.headersList.get("sec-websocket-extensions")
        i !== null && (this.#n = i)
        let s = t.headersList.get("sec-websocket-protocol")
        s !== null && (this.#i = s), Ace("open", this)
      }
    }
  Qa.CONNECTING = Qa.prototype.CONNECTING = o_.CONNECTING
  Qa.OPEN = Qa.prototype.OPEN = o_.OPEN
  Qa.CLOSING = Qa.prototype.CLOSING = o_.CLOSING
  Qa.CLOSED = Qa.prototype.CLOSED = o_.CLOSED
  Object.defineProperties(Qa.prototype, {
    CONNECTING: Sh,
    OPEN: Sh,
    CLOSING: Sh,
    CLOSED: Sh,
    url: Dl,
    readyState: Dl,
    bufferedAmount: Dl,
    onopen: Dl,
    onerror: Dl,
    onclose: Dl,
    close: Dl,
    onmessage: Dl,
    binaryType: Dl,
    send: Dl,
    extensions: Dl,
    protocol: Dl,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: false,
      enumerable: false,
      configurable: true,
    },
  })
  Object.defineProperties(Qa, {
    CONNECTING: Sh,
    OPEN: Sh,
    CLOSING: Sh,
    CLOSED: Sh,
  })
  xt.converters["sequence<DOMString>"] = xt.sequenceConverter(
    xt.converters.DOMString,
  )
  xt.converters["DOMString or sequence<DOMString>"] = function (e, t, r) {
    return xt.util.Type(e) === "Object" && Symbol.iterator in e
      ? xt.converters["sequence<DOMString>"](e)
      : xt.converters.DOMString(e, t, r)
  }
  xt.converters.WebSocketInit = xt.dictionaryConverter([
    {
      key: "protocols",
      converter: xt.converters["DOMString or sequence<DOMString>"],
      defaultValue: () => new Array(0),
    },
    {
      key: "dispatcher",
      converter: xt.converters.any,
      defaultValue: () => oZe(),
    },
    {
      key: "headers",
      converter: xt.nullableConverter(xt.converters.HeadersInit),
    },
  ])
  xt.converters["DOMString or sequence<DOMString> or WebSocketInit"] =
    function (e) {
      return xt.util.Type(e) === "Object" && !(Symbol.iterator in e)
        ? xt.converters.WebSocketInit(e)
        : { protocols: xt.converters["DOMString or sequence<DOMString>"](e) }
    }
  xt.converters.WebSocketSendData = function (e) {
    if (xt.util.Type(e) === "Object") {
      if (vce(e)) return xt.converters.Blob(e, { strict: false })
      if (ArrayBuffer.isView(e) || Cce.isArrayBuffer(e))
        return xt.converters.BufferSource(e)
    }
    return xt.converters.USVString(e)
  }
  function uZe() {
    this.ws[mce].socket.resume()
  }
  function dZe(e) {
    let t, r
    e instanceof lZe ? ((t = e.reason), (r = e.code)) : (t = e.message),
      Ace("error", this, () => new aZe("error", { error: e, message: t })),
      yce(this, r)
  }
  bce.exports = { WebSocket: Qa }
})
var vW = _((WTt, _ce) => {
  "use strict"
  function fZe(e) {
    return e.indexOf("\0") === -1
  }
  function hZe(e) {
    if (e.length === 0) return false
    for (let t = 0; t < e.length; t++)
      if (e.charCodeAt(t) < 48 || e.charCodeAt(t) > 57) return false
    return true
  }
  function gZe(e) {
    return new Promise((t) => {
      setTimeout(t, e).unref()
    })
  }
  _ce.exports = { isValidLastEventId: fZe, isASCIINumber: hZe, delay: gZe }
})
var Ice = _((GTt, Sce) => {
  "use strict"
  var { Transform: pZe } = require("stream"),
    { isASCIINumber: xce, isValidLastEventId: wce } = vW(),
    zd = [239, 187, 191],
    CW = 10,
    jD = 13,
    mZe = 58,
    AZe = 32,
    bW = class extends pZe {
      state = null
      checkBOM = true
      crlfCheck = false
      eventEndCheck = false
      buffer = null
      pos = 0
      event = { data: undefined, event: undefined, id: undefined, retry: undefined }
      constructor(t = {}) {
        ;(t.readableObjectMode = true),
          super(t),
          (this.state = t.eventSourceSettings || {}),
          t.push && (this.push = t.push)
      }
      _transform(t, r, n) {
        if (t.length === 0) {
          n()
          return
        }
        if (
          (this.buffer
            ? (this.buffer = Buffer.concat([this.buffer, t]))
            : (this.buffer = t),
          this.checkBOM)
        )
          switch (this.buffer.length) {
            case 1:
              if (this.buffer[0] === zd[0]) {
                n()
                return
              }
              ;(this.checkBOM = false), n()
              return
            case 2:
              if (this.buffer[0] === zd[0] && this.buffer[1] === zd[1]) {
                n()
                return
              }
              this.checkBOM = false
              break
            case 3:
              if (
                this.buffer[0] === zd[0] &&
                this.buffer[1] === zd[1] &&
                this.buffer[2] === zd[2]
              ) {
                ;(this.buffer = Buffer.alloc(0)), (this.checkBOM = false), n()
                return
              }
              this.checkBOM = false
              break
            default:
              this.buffer[0] === zd[0] &&
                this.buffer[1] === zd[1] &&
                this.buffer[2] === zd[2] &&
                (this.buffer = this.buffer.subarray(3)),
                (this.checkBOM = false)
              break
          }
        for (; this.pos < this.buffer.length; ) {
          if (this.eventEndCheck) {
            if (this.crlfCheck) {
              if (this.buffer[this.pos] === CW) {
                ;(this.buffer = this.buffer.subarray(this.pos + 1)),
                  (this.pos = 0),
                  (this.crlfCheck = false)
                continue
              }
              this.crlfCheck = false
            }
            if (this.buffer[this.pos] === CW || this.buffer[this.pos] === jD) {
              this.buffer[this.pos] === jD && (this.crlfCheck = true),
                (this.buffer = this.buffer.subarray(this.pos + 1)),
                (this.pos = 0),
                (this.event.data !== undefined ||
                  this.event.event ||
                  this.event.id ||
                  this.event.retry) &&
                  this.processEvent(this.event),
                this.clearEvent()
              continue
            }
            this.eventEndCheck = false
            continue
          }
          if (this.buffer[this.pos] === CW || this.buffer[this.pos] === jD) {
            this.buffer[this.pos] === jD && (this.crlfCheck = true),
              this.parseLine(this.buffer.subarray(0, this.pos), this.event),
              (this.buffer = this.buffer.subarray(this.pos + 1)),
              (this.pos = 0),
              (this.eventEndCheck = true)
            continue
          }
          this.pos++
        }
        n()
      }
      parseLine(t, r) {
        if (t.length === 0) return
        let n = t.indexOf(mZe)
        if (n === 0) return
        let i = "",
          s = ""
        if (n !== -1) {
          i = t.subarray(0, n).toString("utf8")
          let o = n + 1
          t[o] === AZe && ++o, (s = t.subarray(o).toString("utf8"))
        } else (i = t.toString("utf8")), (s = "")
        switch (i) {
          case "data":
            r[i] === undefined
              ? (r[i] = s)
              : (r[i] += `
${s}`)
            break
          case "retry":
            xce(s) && (r[i] = s)
            break
          case "id":
            wce(s) && (r[i] = s)
            break
          case "event":
            s.length > 0 && (r[i] = s)
            break
        }
      }
      processEvent(t) {
        t.retry &&
          xce(t.retry) &&
          (this.state.reconnectionTime = parseInt(t.retry, 10)),
          t.id && wce(t.id) && (this.state.lastEventId = t.id),
          t.data !== undefined &&
            this.push({
              type: t.event || "message",
              options: {
                data: t.data,
                lastEventId: this.state.lastEventId,
                origin: this.state.origin,
              },
            })
      }
      clearEvent() {
        this.event = { data: undefined, event: undefined, id: undefined, retry: undefined }
      }
    }
  Sce.exports = { EventSourceStream: bW }
})
var Qce = _(($Tt, Fce) => {
  "use strict"
  var { pipeline: yZe } = require("stream"),
    { fetching: vZe } = zE(),
    { makeRequest: CZe } = ry(),
    { webidl: Jd } = Is(),
    { EventSourceStream: bZe } = Ice(),
    { parseMIMEType: EZe } = zo(),
    { createFastMessageEvent: _Ze } = ly(),
    { isNetworkError: Bce } = YE(),
    { delay: xZe } = vW(),
    { kEnumerableProperty: qp } = ir(),
    { environmentSettingsObject: Rce } = Ba(),
    Dce = false,
    Tce = 3e3,
    a_ = 0,
    kce = 1,
    l_ = 2,
    wZe = "anonymous",
    SZe = "use-credentials",
    hy = class e extends EventTarget {
      #e = { open: null, error: null, message: null }
      #t = null
      #i = false
      #n = a_
      #r = null
      #l = null
      #o
      #u
      constructor(t, r = {}) {
        super(), Jd.util.markAsUncloneable(this)
        let n = "EventSource constructor"
        Jd.argumentLengthCheck(arguments, 1, n),
          Dce ||
            ((Dce = true),
            process.emitWarning(
              "EventSource is experimental, expect them to change at any time.",
              { code: "UNDICI-ES" },
            )),
          (t = Jd.converters.USVString(t, n, "url")),
          (r = Jd.converters.EventSourceInitDict(r, n, "eventSourceInitDict")),
          (this.#o = r.dispatcher),
          (this.#u = { lastEventId: "", reconnectionTime: Tce })
        let i = Rce,
          s
        try {
          ;(s = new URL(t, i.settingsObject.baseUrl)),
            (this.#u.origin = s.origin)
        } catch (l) {
          throw new DOMException(l, "SyntaxError")
        }
        this.#t = s.href
        let o = wZe
        r.withCredentials && ((o = SZe), (this.#i = true))
        let a = {
          redirect: "follow",
          keepalive: true,
          mode: "cors",
          credentials: o === "anonymous" ? "same-origin" : "omit",
          referrer: "no-referrer",
        }
        ;(a.client = Rce.settingsObject),
          (a.headersList = [
            ["accept", { name: "accept", value: "text/event-stream" }],
          ]),
          (a.cache = "no-store"),
          (a.initiator = "other"),
          (a.urlList = [new URL(this.#t)]),
          (this.#r = CZe(a)),
          this.#d()
      }
      get readyState() {
        return this.#n
      }
      get url() {
        return this.#t
      }
      get withCredentials() {
        return this.#i
      }
      #d() {
        if (this.#n === l_) return
        this.#n = a_
        let t = { request: this.#r, dispatcher: this.#o },
          r = (n) => {
            Bce(n) && (this.dispatchEvent(new Event("error")), this.close()),
              this.#a()
          }
        ;(t.processResponseEndOfBody = r),
          (t.processResponse = (n) => {
            if (Bce(n))
              if (n.aborted) {
                this.close(), this.dispatchEvent(new Event("error"))
                return
              } else {
                this.#a()
                return
              }
            let i = n.headersList.get("content-type", true),
              s = i !== null ? EZe(i) : "failure",
              o = s !== "failure" && s.essence === "text/event-stream"
            if (n.status !== 200 || o === false) {
              this.close(), this.dispatchEvent(new Event("error"))
              return
            }
            ;(this.#n = kce),
              this.dispatchEvent(new Event("open")),
              (this.#u.origin = n.urlList[n.urlList.length - 1].origin)
            let a = new bZe({
              eventSourceSettings: this.#u,
              push: (l) => {
                this.dispatchEvent(_Ze(l.type, l.options))
              },
            })
            yZe(n.body.stream, a, (l) => {
              l?.aborted === false &&
                (this.close(), this.dispatchEvent(new Event("error")))
            })
          }),
          (this.#l = vZe(t))
      }
      async #a() {
        this.#n !== l_ &&
          ((this.#n = a_),
          this.dispatchEvent(new Event("error")),
          await xZe(this.#u.reconnectionTime),
          this.#n === a_ &&
            (this.#u.lastEventId.length &&
              this.#r.headersList.set("last-event-id", this.#u.lastEventId, true),
            this.#d()))
      }
      close() {
        Jd.brandCheck(this, e),
          this.#n !== l_ && ((this.#n = l_), this.#l.abort(), (this.#r = null))
      }
      get onopen() {
        return this.#e.open
      }
      set onopen(t) {
        this.#e.open && this.removeEventListener("open", this.#e.open),
          typeof t == "function"
            ? ((this.#e.open = t), this.addEventListener("open", t))
            : (this.#e.open = null)
      }
      get onmessage() {
        return this.#e.message
      }
      set onmessage(t) {
        this.#e.message && this.removeEventListener("message", this.#e.message),
          typeof t == "function"
            ? ((this.#e.message = t), this.addEventListener("message", t))
            : (this.#e.message = null)
      }
      get onerror() {
        return this.#e.error
      }
      set onerror(t) {
        this.#e.error && this.removeEventListener("error", this.#e.error),
          typeof t == "function"
            ? ((this.#e.error = t), this.addEventListener("error", t))
            : (this.#e.error = null)
      }
    },
    Mce = {
      CONNECTING: {
        __proto__: null,
        configurable: false,
        enumerable: true,
        value: a_,
        writable: false,
      },
      OPEN: {
        __proto__: null,
        configurable: false,
        enumerable: true,
        value: kce,
        writable: false,
      },
      CLOSED: {
        __proto__: null,
        configurable: false,
        enumerable: true,
        value: l_,
        writable: false,
      },
    }
  Object.defineProperties(hy, Mce)
  Object.defineProperties(hy.prototype, Mce)
  Object.defineProperties(hy.prototype, {
    close: qp,
    onerror: qp,
    onmessage: qp,
    onopen: qp,
    readyState: qp,
    url: qp,
    withCredentials: qp,
  })
  Jd.converters.EventSourceInitDict = Jd.dictionaryConverter([
    {
      key: "withCredentials",
      converter: Jd.converters.boolean,
      defaultValue: () => false,
    },
    { key: "dispatcher", converter: Jd.converters.any },
  ])
  Fce.exports = { EventSource: hy, defaultReconnectionTime: Tce }
})
var Uce = _((YTt, Ct) => {
  "use strict"
  var IZe = kE(),
    Nce = uE(),
    BZe = H0(),
    RZe = Hie(),
    DZe = W0(),
    TZe = $V(),
    kZe = ose(),
    MZe = fse(),
    Pce = Jr(),
    XD = ir(),
    { InvalidArgumentError: ZD } = Pce,
    gy = Zse(),
    FZe = fE(),
    QZe = IH(),
    NZe = Moe(),
    PZe = DH(),
    LZe = gH(),
    UZe = eD(),
    { getGlobalDispatcher: Lce, setGlobalDispatcher: OZe } = uD(),
    qZe = dD(),
    VZe = HR(),
    HZe = WR()
  Object.assign(Nce.prototype, gy)
  Ct.exports.Dispatcher = Nce
  Ct.exports.Client = IZe
  Ct.exports.Pool = BZe
  Ct.exports.BalancedPool = RZe
  Ct.exports.Agent = DZe
  Ct.exports.ProxyAgent = TZe
  Ct.exports.EnvHttpProxyAgent = kZe
  Ct.exports.RetryAgent = MZe
  Ct.exports.RetryHandler = UZe
  Ct.exports.DecoratorHandler = qZe
  Ct.exports.RedirectHandler = VZe
  Ct.exports.createRedirectInterceptor = HZe
  Ct.exports.interceptors = {
    redirect: Ooe(),
    retry: Voe(),
    dump: Woe(),
    dns: Yoe(),
  }
  Ct.exports.buildConnector = FZe
  Ct.exports.errors = Pce
  Ct.exports.util = {
    parseHeaders: XD.parseHeaders,
    headerNameToString: XD.headerNameToString,
  }
  function c_(e) {
    return (t, r, n) => {
      if (
        (typeof r == "function" && ((n = r), (r = null)),
        !t ||
          (typeof t != "string" && typeof t != "object" && !(t instanceof URL)))
      )
        throw new ZD("invalid url")
      if (r != null && typeof r != "object") throw new ZD("invalid opts")
      if (r && r.path != null) {
        if (typeof r.path != "string") throw new ZD("invalid opts.path")
        let o = r.path
        r.path.startsWith("/") || (o = `/${o}`),
          (t = new URL(XD.parseOrigin(t).origin + o))
      } else r || (r = typeof t == "object" ? t : {}), (t = XD.parseURL(t))
      let { agent: i, dispatcher: s = Lce() } = r
      if (i) throw new ZD("unsupported opts.agent. Did you mean opts.client?")
      return e.call(
        s,
        {
          ...r,
          origin: t.origin,
          path: t.search ? `${t.pathname}${t.search}` : t.pathname,
          method: r.method || (r.body ? "PUT" : "GET"),
        },
        n,
      )
    }
  }
  Ct.exports.setGlobalDispatcher = OZe
  Ct.exports.getGlobalDispatcher = Lce
  var WZe = zE().fetch
  Ct.exports.fetch = async function (t, r = undefined) {
    try {
      return await WZe(t, r)
    } catch (n) {
      throw (n && typeof n == "object" && Error.captureStackTrace(n), n)
    }
  }
  Ct.exports.Headers = Fp().Headers
  Ct.exports.Response = YE().Response
  Ct.exports.Request = ry().Request
  Ct.exports.FormData = vE().FormData
  Ct.exports.File = globalThis.File ?? require("buffer").File
  Ct.exports.FileReader = ale().FileReader
  var { setGlobalOrigin: GZe, getGlobalOrigin: $Ze } = Yq()
  Ct.exports.setGlobalOrigin = GZe
  Ct.exports.getGlobalOrigin = $Ze
  var { CacheStorage: YZe } = mle(),
    { kConstruct: KZe } = kD()
  Ct.exports.caches = new YZe(KZe)
  var {
    deleteCookie: zZe,
    getCookies: JZe,
    getSetCookies: jZe,
    setCookie: ZZe,
  } = Ble()
  Ct.exports.deleteCookie = zZe
  Ct.exports.getCookies = JZe
  Ct.exports.getSetCookies = jZe
  Ct.exports.setCookie = ZZe
  var { parseMIMEType: XZe, serializeAMimeType: eXe } = zo()
  Ct.exports.parseMIMEType = XZe
  Ct.exports.serializeAMimeType = eXe
  var { CloseEvent: tXe, ErrorEvent: rXe, MessageEvent: nXe } = ly()
  Ct.exports.WebSocket = Ece().WebSocket
  Ct.exports.CloseEvent = tXe
  Ct.exports.ErrorEvent = rXe
  Ct.exports.MessageEvent = nXe
  Ct.exports.request = c_(gy.request)
  Ct.exports.stream = c_(gy.stream)
  Ct.exports.pipeline = c_(gy.pipeline)
  Ct.exports.connect = c_(gy.connect)
  Ct.exports.upgrade = c_(gy.upgrade)
  Ct.exports.MockClient = QZe
  Ct.exports.MockPool = PZe
  Ct.exports.MockAgent = NZe
  Ct.exports.mockErrors = LZe
  var { EventSource: iXe } = Qce()
  Ct.exports.EventSource = iXe
})
var jt = _((KTt, Oce) => {
  "use strict"
  Oce.exports = { options: { usePureJavaScript: false } }
})
var Hce = _((zTt, Vce) => {
  "use strict"
  var EW = {}
  Vce.exports = EW
  var qce = {}
  EW.encode = function (e, t, r) {
    if (typeof t != "string")
      throw new TypeError('"alphabet" must be a string.')
    if (r !== undefined && typeof r != "number")
      throw new TypeError('"maxline" must be a number.')
    var n = ""
    if (!(e instanceof Uint8Array)) n = sXe(e, t)
    else {
      var i = 0,
        s = t.length,
        o = t.charAt(0),
        a = [0]
      for (i = 0; i < e.length; ++i) {
        for (var l = 0, c = e[i]; l < a.length; ++l)
          (c += a[l] << 8), (a[l] = c % s), (c = (c / s) | 0)
        for (; c > 0; ) a.push(c % s), (c = (c / s) | 0)
      }
      for (i = 0; e[i] === 0 && i < e.length - 1; ++i) n += o
      for (i = a.length - 1; i >= 0; --i) n += t[a[i]]
    }
    if (r) {
      var u = new RegExp(".{1," + r + "}", "g")
      n = n.match(u).join(`\r
`)
    }
    return n
  }
  EW.decode = function (e, t) {
    if (typeof e != "string") throw new TypeError('"input" must be a string.')
    if (typeof t != "string")
      throw new TypeError('"alphabet" must be a string.')
    var r = qce[t]
    if (!r) {
      r = qce[t] = []
      for (var n = 0; n < t.length; ++n) r[t.charCodeAt(n)] = n
    }
    e = e.replace(/\s/g, "")
    for (var i = t.length, s = t.charAt(0), o = [0], n = 0; n < e.length; n++) {
      var a = r[e.charCodeAt(n)]
      if (a === undefined) return
      for (var l = 0, c = a; l < o.length; ++l)
        (c += o[l] * i), (o[l] = c & 255), (c >>= 8)
      for (; c > 0; ) o.push(c & 255), (c >>= 8)
    }
    for (var u = 0; e[u] === s && u < e.length - 1; ++u) o.push(0)
    return typeof Buffer < "u"
      ? Buffer.from(o.reverse())
      : new Uint8Array(o.reverse())
  }
  function sXe(e, t) {
    var r = 0,
      n = t.length,
      i = t.charAt(0),
      s = [0]
    for (r = 0; r < e.length(); ++r) {
      for (var o = 0, a = e.at(r); o < s.length; ++o)
        (a += s[o] << 8), (s[o] = a % n), (a = (a / n) | 0)
      for (; a > 0; ) s.push(a % n), (a = (a / n) | 0)
    }
    var l = ""
    for (r = 0; e.at(r) === 0 && r < e.length() - 1; ++r) l += i
    for (r = s.length - 1; r >= 0; --r) l += t[s[r]]
    return l
  }
})
var Pr = _((JTt, Yce) => {
  "use strict"
  var Wce = jt(),
    Gce = Hce(),
    $ = (Yce.exports = Wce.util = Wce.util || {})
  ;(function () {
    if (typeof process < "u" && process.nextTick && !process.browser) {
      ;($.nextTick = process.nextTick),
        typeof setImmediate == "function"
          ? ($.setImmediate = setImmediate)
          : ($.setImmediate = $.nextTick)
      return
    }
    if (typeof setImmediate == "function") {
      ;($.setImmediate = function () {
        return setImmediate.apply(undefined, arguments)
      }),
        ($.nextTick = function (a) {
          return setImmediate(a)
        })
      return
    }
    if (
      (($.setImmediate = function (a) {
        setTimeout(a, 0)
      }),
      typeof window < "u" && typeof window.postMessage == "function")
    ) {
      let a = function (l) {
        if (l.source === window && l.data === e) {
          l.stopPropagation()
          var c = t.slice()
          ;(t.length = 0),
            c.forEach(function (u) {
              u()
            })
        }
      }
      var o = a,
        e = "forge.setImmediate",
        t = []
      ;($.setImmediate = function (l) {
        t.push(l), t.length === 1 && window.postMessage(e, "*")
      }),
        window.addEventListener("message", a, true)
    }
    if (typeof MutationObserver < "u") {
      var r = Date.now(),
        n = true,
        i = document.createElement("div"),
        t = []
      new MutationObserver(function () {
        var l = t.slice()
        ;(t.length = 0),
          l.forEach(function (c) {
            c()
          })
      }).observe(i, { attributes: true })
      var s = $.setImmediate
      $.setImmediate = function (l) {
        Date.now() - r > 15
          ? ((r = Date.now()), s(l))
          : (t.push(l), t.length === 1 && i.setAttribute("a", (n = !n)))
      }
    }
    $.nextTick = $.setImmediate
  })()
  $.isNodejs = typeof process < "u" && process.versions && process.versions.node
  $.globalScope = (function () {
    return $.isNodejs ? global : typeof self > "u" ? window : self
  })()
  $.isArray =
    Array.isArray ||
    function (e) {
      return Object.prototype.toString.call(e) === "[object Array]"
    }
  $.isArrayBuffer = function (e) {
    return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer
  }
  $.isArrayBufferView = function (e) {
    return e && $.isArrayBuffer(e.buffer) && e.byteLength !== undefined
  }
  function u_(e) {
    if (!(e === 8 || e === 16 || e === 24 || e === 32))
      throw new Error("Only 8, 16, 24, or 32 bits supported: " + e)
  }
  $.ByteBuffer = _W
  function _W(e) {
    if (((this.data = ""), (this.read = 0), typeof e == "string")) this.data = e
    else if ($.isArrayBuffer(e) || $.isArrayBufferView(e))
      if (typeof Buffer < "u" && e instanceof Buffer)
        this.data = e.toString("binary")
      else {
        var t = new Uint8Array(e)
        try {
          this.data = String.fromCharCode.apply(null, t)
        } catch {
          for (var r = 0; r < t.length; ++r) this.putByte(t[r])
        }
      }
    else
      (e instanceof _W ||
        (typeof e == "object" &&
          typeof e.data == "string" &&
          typeof e.read == "number")) &&
        ((this.data = e.data), (this.read = e.read))
    this._constructedStringLength = 0
  }
  $.ByteStringBuffer = _W
  var oXe = 4096
  $.ByteStringBuffer.prototype._optimizeConstructedString = function (e) {
    ;(this._constructedStringLength += e),
      this._constructedStringLength > oXe &&
        (this.data.substr(0, 1), (this._constructedStringLength = 0))
  }
  $.ByteStringBuffer.prototype.length = function () {
    return this.data.length - this.read
  }
  $.ByteStringBuffer.prototype.isEmpty = function () {
    return this.length() <= 0
  }
  $.ByteStringBuffer.prototype.putByte = function (e) {
    return this.putBytes(String.fromCharCode(e))
  }
  $.ByteStringBuffer.prototype.fillWithByte = function (e, t) {
    e = String.fromCharCode(e)
    for (var r = this.data; t > 0; )
      t & 1 && (r += e), (t >>>= 1), t > 0 && (e += e)
    return (this.data = r), this._optimizeConstructedString(t), this
  }
  $.ByteStringBuffer.prototype.putBytes = function (e) {
    return (this.data += e), this._optimizeConstructedString(e.length), this
  }
  $.ByteStringBuffer.prototype.putString = function (e) {
    return this.putBytes($.encodeUtf8(e))
  }
  $.ByteStringBuffer.prototype.putInt16 = function (e) {
    return this.putBytes(
      String.fromCharCode((e >> 8) & 255) + String.fromCharCode(e & 255),
    )
  }
  $.ByteStringBuffer.prototype.putInt24 = function (e) {
    return this.putBytes(
      String.fromCharCode((e >> 16) & 255) +
        String.fromCharCode((e >> 8) & 255) +
        String.fromCharCode(e & 255),
    )
  }
  $.ByteStringBuffer.prototype.putInt32 = function (e) {
    return this.putBytes(
      String.fromCharCode((e >> 24) & 255) +
        String.fromCharCode((e >> 16) & 255) +
        String.fromCharCode((e >> 8) & 255) +
        String.fromCharCode(e & 255),
    )
  }
  $.ByteStringBuffer.prototype.putInt16Le = function (e) {
    return this.putBytes(
      String.fromCharCode(e & 255) + String.fromCharCode((e >> 8) & 255),
    )
  }
  $.ByteStringBuffer.prototype.putInt24Le = function (e) {
    return this.putBytes(
      String.fromCharCode(e & 255) +
        String.fromCharCode((e >> 8) & 255) +
        String.fromCharCode((e >> 16) & 255),
    )
  }
  $.ByteStringBuffer.prototype.putInt32Le = function (e) {
    return this.putBytes(
      String.fromCharCode(e & 255) +
        String.fromCharCode((e >> 8) & 255) +
        String.fromCharCode((e >> 16) & 255) +
        String.fromCharCode((e >> 24) & 255),
    )
  }
  $.ByteStringBuffer.prototype.putInt = function (e, t) {
    u_(t)
    var r = ""
    do (t -= 8), (r += String.fromCharCode((e >> t) & 255))
    while (t > 0)
    return this.putBytes(r)
  }
  $.ByteStringBuffer.prototype.putSignedInt = function (e, t) {
    return e < 0 && (e += 2 << (t - 1)), this.putInt(e, t)
  }
  $.ByteStringBuffer.prototype.putBuffer = function (e) {
    return this.putBytes(e.getBytes())
  }
  $.ByteStringBuffer.prototype.getByte = function () {
    return this.data.charCodeAt(this.read++)
  }
  $.ByteStringBuffer.prototype.getInt16 = function () {
    var e =
      (this.data.charCodeAt(this.read) << 8) ^
      this.data.charCodeAt(this.read + 1)
    return (this.read += 2), e
  }
  $.ByteStringBuffer.prototype.getInt24 = function () {
    var e =
      (this.data.charCodeAt(this.read) << 16) ^
      (this.data.charCodeAt(this.read + 1) << 8) ^
      this.data.charCodeAt(this.read + 2)
    return (this.read += 3), e
  }
  $.ByteStringBuffer.prototype.getInt32 = function () {
    var e =
      (this.data.charCodeAt(this.read) << 24) ^
      (this.data.charCodeAt(this.read + 1) << 16) ^
      (this.data.charCodeAt(this.read + 2) << 8) ^
      this.data.charCodeAt(this.read + 3)
    return (this.read += 4), e
  }
  $.ByteStringBuffer.prototype.getInt16Le = function () {
    var e =
      this.data.charCodeAt(this.read) ^
      (this.data.charCodeAt(this.read + 1) << 8)
    return (this.read += 2), e
  }
  $.ByteStringBuffer.prototype.getInt24Le = function () {
    var e =
      this.data.charCodeAt(this.read) ^
      (this.data.charCodeAt(this.read + 1) << 8) ^
      (this.data.charCodeAt(this.read + 2) << 16)
    return (this.read += 3), e
  }
  $.ByteStringBuffer.prototype.getInt32Le = function () {
    var e =
      this.data.charCodeAt(this.read) ^
      (this.data.charCodeAt(this.read + 1) << 8) ^
      (this.data.charCodeAt(this.read + 2) << 16) ^
      (this.data.charCodeAt(this.read + 3) << 24)
    return (this.read += 4), e
  }
  $.ByteStringBuffer.prototype.getInt = function (e) {
    u_(e)
    var t = 0
    do (t = (t << 8) + this.data.charCodeAt(this.read++)), (e -= 8)
    while (e > 0)
    return t
  }
  $.ByteStringBuffer.prototype.getSignedInt = function (e) {
    var t = this.getInt(e),
      r = 2 << (e - 2)
    return t >= r && (t -= r << 1), t
  }
  $.ByteStringBuffer.prototype.getBytes = function (e) {
    var t
    return (
      e
        ? ((e = Math.min(this.length(), e)),
          (t = this.data.slice(this.read, this.read + e)),
          (this.read += e))
        : e === 0
          ? (t = "")
          : ((t = this.read === 0 ? this.data : this.data.slice(this.read)),
            this.clear()),
      t
    )
  }
  $.ByteStringBuffer.prototype.bytes = function (e) {
    return typeof e > "u"
      ? this.data.slice(this.read)
      : this.data.slice(this.read, this.read + e)
  }
  $.ByteStringBuffer.prototype.at = function (e) {
    return this.data.charCodeAt(this.read + e)
  }
  $.ByteStringBuffer.prototype.setAt = function (e, t) {
    return (
      (this.data =
        this.data.substr(0, this.read + e) +
        String.fromCharCode(t) +
        this.data.substr(this.read + e + 1)),
      this
    )
  }
  $.ByteStringBuffer.prototype.last = function () {
    return this.data.charCodeAt(this.data.length - 1)
  }
  $.ByteStringBuffer.prototype.copy = function () {
    var e = $.createBuffer(this.data)
    return (e.read = this.read), e
  }
  $.ByteStringBuffer.prototype.compact = function () {
    return (
      this.read > 0 &&
        ((this.data = this.data.slice(this.read)), (this.read = 0)),
      this
    )
  }
  $.ByteStringBuffer.prototype.clear = function () {
    return (this.data = ""), (this.read = 0), this
  }
  $.ByteStringBuffer.prototype.truncate = function (e) {
    var t = Math.max(0, this.length() - e)
    return (this.data = this.data.substr(this.read, t)), (this.read = 0), this
  }
  $.ByteStringBuffer.prototype.toHex = function () {
    for (var e = "", t = this.read; t < this.data.length; ++t) {
      var r = this.data.charCodeAt(t)
      r < 16 && (e += "0"), (e += r.toString(16))
    }
    return e
  }
  $.ByteStringBuffer.prototype.toString = function () {
    return $.decodeUtf8(this.bytes())
  }
  function aXe(e, t) {
    ;(t = t || {}),
      (this.read = t.readOffset || 0),
      (this.growSize = t.growSize || 1024)
    var r = $.isArrayBuffer(e),
      n = $.isArrayBufferView(e)
    if (r || n) {
      r
        ? (this.data = new DataView(e))
        : (this.data = new DataView(e.buffer, e.byteOffset, e.byteLength)),
        (this.write = "writeOffset" in t ? t.writeOffset : this.data.byteLength)
      return
    }
    ;(this.data = new DataView(new ArrayBuffer(0))),
      (this.write = 0),
      e != null && this.putBytes(e),
      "writeOffset" in t && (this.write = t.writeOffset)
  }
  $.DataBuffer = aXe
  $.DataBuffer.prototype.length = function () {
    return this.write - this.read
  }
  $.DataBuffer.prototype.isEmpty = function () {
    return this.length() <= 0
  }
  $.DataBuffer.prototype.accommodate = function (e, t) {
    if (this.length() >= e) return this
    t = Math.max(t || this.growSize, e)
    var r = new Uint8Array(
        this.data.buffer,
        this.data.byteOffset,
        this.data.byteLength,
      ),
      n = new Uint8Array(this.length() + t)
    return n.set(r), (this.data = new DataView(n.buffer)), this
  }
  $.DataBuffer.prototype.putByte = function (e) {
    return this.accommodate(1), this.data.setUint8(this.write++, e), this
  }
  $.DataBuffer.prototype.fillWithByte = function (e, t) {
    this.accommodate(t)
    for (var r = 0; r < t; ++r) this.data.setUint8(e)
    return this
  }
  $.DataBuffer.prototype.putBytes = function (e, t) {
    if ($.isArrayBufferView(e)) {
      var r = new Uint8Array(e.buffer, e.byteOffset, e.byteLength),
        n = r.byteLength - r.byteOffset
      this.accommodate(n)
      var i = new Uint8Array(this.data.buffer, this.write)
      return i.set(r), (this.write += n), this
    }
    if ($.isArrayBuffer(e)) {
      var r = new Uint8Array(e)
      this.accommodate(r.byteLength)
      var i = new Uint8Array(this.data.buffer)
      return i.set(r, this.write), (this.write += r.byteLength), this
    }
    if (
      e instanceof $.DataBuffer ||
      (typeof e == "object" &&
        typeof e.read == "number" &&
        typeof e.write == "number" &&
        $.isArrayBufferView(e.data))
    ) {
      var r = new Uint8Array(e.data.byteLength, e.read, e.length())
      this.accommodate(r.byteLength)
      var i = new Uint8Array(e.data.byteLength, this.write)
      return i.set(r), (this.write += r.byteLength), this
    }
    if (
      (e instanceof $.ByteStringBuffer && ((e = e.data), (t = "binary")),
      (t = t || "binary"),
      typeof e == "string")
    ) {
      var s
      if (t === "hex")
        return (
          this.accommodate(Math.ceil(e.length / 2)),
          (s = new Uint8Array(this.data.buffer, this.write)),
          (this.write += $.binary.hex.decode(e, s, this.write)),
          this
        )
      if (t === "base64")
        return (
          this.accommodate(Math.ceil(e.length / 4) * 3),
          (s = new Uint8Array(this.data.buffer, this.write)),
          (this.write += $.binary.base64.decode(e, s, this.write)),
          this
        )
      if (
        (t === "utf8" && ((e = $.encodeUtf8(e)), (t = "binary")),
        t === "binary" || t === "raw")
      )
        return (
          this.accommodate(e.length),
          (s = new Uint8Array(this.data.buffer, this.write)),
          (this.write += $.binary.raw.decode(s)),
          this
        )
      if (t === "utf16")
        return (
          this.accommodate(e.length * 2),
          (s = new Uint16Array(this.data.buffer, this.write)),
          (this.write += $.text.utf16.encode(s)),
          this
        )
      throw new Error("Invalid encoding: " + t)
    }
    throw Error("Invalid parameter: " + e)
  }
  $.DataBuffer.prototype.putBuffer = function (e) {
    return this.putBytes(e), e.clear(), this
  }
  $.DataBuffer.prototype.putString = function (e) {
    return this.putBytes(e, "utf16")
  }
  $.DataBuffer.prototype.putInt16 = function (e) {
    return (
      this.accommodate(2),
      this.data.setInt16(this.write, e),
      (this.write += 2),
      this
    )
  }
  $.DataBuffer.prototype.putInt24 = function (e) {
    return (
      this.accommodate(3),
      this.data.setInt16(this.write, (e >> 8) & 65535),
      this.data.setInt8(this.write, (e >> 16) & 255),
      (this.write += 3),
      this
    )
  }
  $.DataBuffer.prototype.putInt32 = function (e) {
    return (
      this.accommodate(4),
      this.data.setInt32(this.write, e),
      (this.write += 4),
      this
    )
  }
  $.DataBuffer.prototype.putInt16Le = function (e) {
    return (
      this.accommodate(2),
      this.data.setInt16(this.write, e, true),
      (this.write += 2),
      this
    )
  }
  $.DataBuffer.prototype.putInt24Le = function (e) {
    return (
      this.accommodate(3),
      this.data.setInt8(this.write, (e >> 16) & 255),
      this.data.setInt16(this.write, (e >> 8) & 65535, true),
      (this.write += 3),
      this
    )
  }
  $.DataBuffer.prototype.putInt32Le = function (e) {
    return (
      this.accommodate(4),
      this.data.setInt32(this.write, e, true),
      (this.write += 4),
      this
    )
  }
  $.DataBuffer.prototype.putInt = function (e, t) {
    u_(t), this.accommodate(t / 8)
    do (t -= 8), this.data.setInt8(this.write++, (e >> t) & 255)
    while (t > 0)
    return this
  }
  $.DataBuffer.prototype.putSignedInt = function (e, t) {
    return (
      u_(t),
      this.accommodate(t / 8),
      e < 0 && (e += 2 << (t - 1)),
      this.putInt(e, t)
    )
  }
  $.DataBuffer.prototype.getByte = function () {
    return this.data.getInt8(this.read++)
  }
  $.DataBuffer.prototype.getInt16 = function () {
    var e = this.data.getInt16(this.read)
    return (this.read += 2), e
  }
  $.DataBuffer.prototype.getInt24 = function () {
    var e =
      (this.data.getInt16(this.read) << 8) ^ this.data.getInt8(this.read + 2)
    return (this.read += 3), e
  }
  $.DataBuffer.prototype.getInt32 = function () {
    var e = this.data.getInt32(this.read)
    return (this.read += 4), e
  }
  $.DataBuffer.prototype.getInt16Le = function () {
    var e = this.data.getInt16(this.read, true)
    return (this.read += 2), e
  }
  $.DataBuffer.prototype.getInt24Le = function () {
    var e =
      this.data.getInt8(this.read) ^
      (this.data.getInt16(this.read + 1, true) << 8)
    return (this.read += 3), e
  }
  $.DataBuffer.prototype.getInt32Le = function () {
    var e = this.data.getInt32(this.read, true)
    return (this.read += 4), e
  }
  $.DataBuffer.prototype.getInt = function (e) {
    u_(e)
    var t = 0
    do (t = (t << 8) + this.data.getInt8(this.read++)), (e -= 8)
    while (e > 0)
    return t
  }
  $.DataBuffer.prototype.getSignedInt = function (e) {
    var t = this.getInt(e),
      r = 2 << (e - 2)
    return t >= r && (t -= r << 1), t
  }
  $.DataBuffer.prototype.getBytes = function (e) {
    var t
    return (
      e
        ? ((e = Math.min(this.length(), e)),
          (t = this.data.slice(this.read, this.read + e)),
          (this.read += e))
        : e === 0
          ? (t = "")
          : ((t = this.read === 0 ? this.data : this.data.slice(this.read)),
            this.clear()),
      t
    )
  }
  $.DataBuffer.prototype.bytes = function (e) {
    return typeof e > "u"
      ? this.data.slice(this.read)
      : this.data.slice(this.read, this.read + e)
  }
  $.DataBuffer.prototype.at = function (e) {
    return this.data.getUint8(this.read + e)
  }
  $.DataBuffer.prototype.setAt = function (e, t) {
    return this.data.setUint8(e, t), this
  }
  $.DataBuffer.prototype.last = function () {
    return this.data.getUint8(this.write - 1)
  }
  $.DataBuffer.prototype.copy = function () {
    return new $.DataBuffer(this)
  }
  $.DataBuffer.prototype.compact = function () {
    if (this.read > 0) {
      var e = new Uint8Array(this.data.buffer, this.read),
        t = new Uint8Array(e.byteLength)
      t.set(e),
        (this.data = new DataView(t)),
        (this.write -= this.read),
        (this.read = 0)
    }
    return this
  }
  $.DataBuffer.prototype.clear = function () {
    return (
      (this.data = new DataView(new ArrayBuffer(0))),
      (this.read = this.write = 0),
      this
    )
  }
  $.DataBuffer.prototype.truncate = function (e) {
    return (
      (this.write = Math.max(0, this.length() - e)),
      (this.read = Math.min(this.read, this.write)),
      this
    )
  }
  $.DataBuffer.prototype.toHex = function () {
    for (var e = "", t = this.read; t < this.data.byteLength; ++t) {
      var r = this.data.getUint8(t)
      r < 16 && (e += "0"), (e += r.toString(16))
    }
    return e
  }
  $.DataBuffer.prototype.toString = function (e) {
    var t = new Uint8Array(this.data, this.read, this.length())
    if (((e = e || "utf8"), e === "binary" || e === "raw"))
      return $.binary.raw.encode(t)
    if (e === "hex") return $.binary.hex.encode(t)
    if (e === "base64") return $.binary.base64.encode(t)
    if (e === "utf8") return $.text.utf8.decode(t)
    if (e === "utf16") return $.text.utf16.decode(t)
    throw new Error("Invalid encoding: " + e)
  }
  $.createBuffer = function (e, t) {
    return (
      (t = t || "raw"),
      e !== undefined && t === "utf8" && (e = $.encodeUtf8(e)),
      new $.ByteBuffer(e)
    )
  }
  $.fillString = function (e, t) {
    for (var r = ""; t > 0; ) t & 1 && (r += e), (t >>>= 1), t > 0 && (e += e)
    return r
  }
  $.xorBytes = function (e, t, r) {
    for (var n = "", i = "", s = "", o = 0, a = 0; r > 0; --r, ++o)
      (i = e.charCodeAt(o) ^ t.charCodeAt(o)),
        a >= 10 && ((n += s), (s = ""), (a = 0)),
        (s += String.fromCharCode(i)),
        ++a
    return (n += s), n
  }
  $.hexToBytes = function (e) {
    var t = "",
      r = 0
    for (
      e.length & true &&
      ((r = 1), (t += String.fromCharCode(parseInt(e[0], 16))));
      r < e.length;
      r += 2
    )
      t += String.fromCharCode(parseInt(e.substr(r, 2), 16))
    return t
  }
  $.bytesToHex = function (e) {
    return $.createBuffer(e).toHex()
  }
  $.int32ToBytes = function (e) {
    return (
      String.fromCharCode((e >> 24) & 255) +
      String.fromCharCode((e >> 16) & 255) +
      String.fromCharCode((e >> 8) & 255) +
      String.fromCharCode(e & 255)
    )
  }
  var Ih = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    Bh = [
      62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1,
      64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
      17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28,
      29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,
      47, 48, 49, 50, 51,
    ],
    $ce = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  $.encode64 = function (e, t) {
    for (var r = "", n = "", i, s, o, a = 0; a < e.length; )
      (i = e.charCodeAt(a++)),
        (s = e.charCodeAt(a++)),
        (o = e.charCodeAt(a++)),
        (r += Ih.charAt(i >> 2)),
        (r += Ih.charAt(((i & 3) << 4) | (s >> 4))),
        isNaN(s)
          ? (r += "==")
          : ((r += Ih.charAt(((s & 15) << 2) | (o >> 6))),
            (r += isNaN(o) ? "=" : Ih.charAt(o & 63))),
        t &&
          r.length > t &&
          ((n +=
            r.substr(0, t) +
            `\r
`),
          (r = r.substr(t)))
    return (n += r), n
  }
  $.decode64 = function (e) {
    e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "")
    for (var t = "", r, n, i, s, o = 0; o < e.length; )
      (r = Bh[e.charCodeAt(o++) - 43]),
        (n = Bh[e.charCodeAt(o++) - 43]),
        (i = Bh[e.charCodeAt(o++) - 43]),
        (s = Bh[e.charCodeAt(o++) - 43]),
        (t += String.fromCharCode((r << 2) | (n >> 4))),
        i !== 64 &&
          ((t += String.fromCharCode(((n & 15) << 4) | (i >> 2))),
          s !== 64 && (t += String.fromCharCode(((i & 3) << 6) | s)))
    return t
  }
  $.encodeUtf8 = function (e) {
    return unescape(encodeURIComponent(e))
  }
  $.decodeUtf8 = function (e) {
    return decodeURIComponent(escape(e))
  }
  $.binary = {
    raw: {},
    hex: {},
    base64: {},
    base58: {},
    baseN: { encode: Gce.encode, decode: Gce.decode },
  }
  $.binary.raw.encode = function (e) {
    return String.fromCharCode.apply(null, e)
  }
  $.binary.raw.decode = function (e, t, r) {
    var n = t
    n || (n = new Uint8Array(e.length)), (r = r || 0)
    for (var i = r, s = 0; s < e.length; ++s) n[i++] = e.charCodeAt(s)
    return t ? i - r : n
  }
  $.binary.hex.encode = $.bytesToHex
  $.binary.hex.decode = function (e, t, r) {
    var n = t
    n || (n = new Uint8Array(Math.ceil(e.length / 2))), (r = r || 0)
    var i = 0,
      s = r
    for (
      e.length & 1 && ((i = 1), (n[s++] = parseInt(e[0], 16)));
      i < e.length;
      i += 2
    )
      n[s++] = parseInt(e.substr(i, 2), 16)
    return t ? s - r : n
  }
  $.binary.base64.encode = function (e, t) {
    for (var r = "", n = "", i, s, o, a = 0; a < e.byteLength; )
      (i = e[a++]),
        (s = e[a++]),
        (o = e[a++]),
        (r += Ih.charAt(i >> 2)),
        (r += Ih.charAt(((i & 3) << 4) | (s >> 4))),
        isNaN(s)
          ? (r += "==")
          : ((r += Ih.charAt(((s & 15) << 2) | (o >> 6))),
            (r += isNaN(o) ? "=" : Ih.charAt(o & 63))),
        t &&
          r.length > t &&
          ((n +=
            r.substr(0, t) +
            `\r
`),
          (r = r.substr(t)))
    return (n += r), n
  }
  $.binary.base64.decode = function (e, t, r) {
    var n = t
    n || (n = new Uint8Array(Math.ceil(e.length / 4) * 3)),
      (e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "")),
      (r = r || 0)
    for (var i, s, o, a, l = 0, c = r; l < e.length; )
      (i = Bh[e.charCodeAt(l++) - 43]),
        (s = Bh[e.charCodeAt(l++) - 43]),
        (o = Bh[e.charCodeAt(l++) - 43]),
        (a = Bh[e.charCodeAt(l++) - 43]),
        (n[c++] = (i << 2) | (s >> 4)),
        o !== 64 &&
          ((n[c++] = ((s & 15) << 4) | (o >> 2)),
          a !== 64 && (n[c++] = ((o & 3) << 6) | a))
    return t ? c - r : n.subarray(0, c)
  }
  $.binary.base58.encode = function (e, t) {
    return $.binary.baseN.encode(e, $ce, t)
  }
  $.binary.base58.decode = function (e, t) {
    return $.binary.baseN.decode(e, $ce, t)
  }
  $.text = { utf8: {}, utf16: {} }
  $.text.utf8.encode = function (e, t, r) {
    e = $.encodeUtf8(e)
    var n = t
    n || (n = new Uint8Array(e.length)), (r = r || 0)
    for (var i = r, s = 0; s < e.length; ++s) n[i++] = e.charCodeAt(s)
    return t ? i - r : n
  }
  $.text.utf8.decode = function (e) {
    return $.decodeUtf8(String.fromCharCode.apply(null, e))
  }
  $.text.utf16.encode = function (e, t, r) {
    var n = t
    n || (n = new Uint8Array(e.length * 2))
    var i = new Uint16Array(n.buffer)
    r = r || 0
    for (var s = r, o = r, a = 0; a < e.length; ++a)
      (i[o++] = e.charCodeAt(a)), (s += 2)
    return t ? s - r : n
  }
  $.text.utf16.decode = function (e) {
    return String.fromCharCode.apply(null, new Uint16Array(e.buffer))
  }
  $.deflate = function (e, t, r) {
    if (((t = $.decode64(e.deflate($.encode64(t)).rval)), r)) {
      var n = 2,
        i = t.charCodeAt(1)
      i & 32 && (n = 6), (t = t.substring(n, t.length - 4))
    }
    return t
  }
  $.inflate = function (e, t, r) {
    var n = e.inflate($.encode64(t)).rval
    return n === null ? null : $.decode64(n)
  }
  var xW = function (e, t, r) {
      if (!e) throw new Error("WebStorage not available.")
      var n
      if (
        (r === null
          ? (n = e.removeItem(t))
          : ((r = $.encode64(JSON.stringify(r))), (n = e.setItem(t, r))),
        typeof n < "u" && n.rval !== true)
      ) {
        var i = new Error(n.error.message)
        throw ((i.id = n.error.id), (i.name = n.error.name), i)
      }
    },
    wW = function (e, t) {
      if (!e) throw new Error("WebStorage not available.")
      var r = e.getItem(t)
      if (e.init)
        if (r.rval === null) {
          if (r.error) {
            var n = new Error(r.error.message)
            throw ((n.id = r.error.id), (n.name = r.error.name), n)
          }
          r = null
        } else r = r.rval
      return r !== null && (r = JSON.parse($.decode64(r))), r
    },
    lXe = function (e, t, r, n) {
      var i = wW(e, t)
      i === null && (i = {}), (i[r] = n), xW(e, t, i)
    },
    cXe = function (e, t, r) {
      var n = wW(e, t)
      return n !== null && (n = r in n ? n[r] : null), n
    },
    uXe = function (e, t, r) {
      var n = wW(e, t)
      if (n !== null && r in n) {
        delete n[r]
        var i = true
        for (var s in n) {
          i = false
          break
        }
        i && (n = null), xW(e, t, n)
      }
    },
    dXe = function (e, t) {
      xW(e, t, null)
    },
    eT = function (e, t, r) {
      var n = null
      typeof r > "u" && (r = ["web", "flash"])
      var i,
        s = false,
        o = null
      for (var a in r) {
        i = r[a]
        try {
          if (i === "flash" || i === "both") {
            if (t[0] === null)
              throw new Error("Flash local storage not available.")
            ;(n = e.apply(this, t)), (s = i === "flash")
          }
          ;(i === "web" || i === "both") &&
            ((t[0] = localStorage), (n = e.apply(this, t)), (s = true))
        } catch (l) {
          o = l
        }
        if (s) break
      }
      if (!s) throw o
      return n
    }
  $.setItem = function (e, t, r, n, i) {
    eT(lXe, arguments, i)
  }
  $.getItem = function (e, t, r, n) {
    return eT(cXe, arguments, n)
  }
  $.removeItem = function (e, t, r, n) {
    eT(uXe, arguments, n)
  }
  $.clearItems = function (e, t, r) {
    eT(dXe, arguments, r)
  }
  $.isEmpty = function (e) {
    for (var t in e) if (e.hasOwnProperty(t)) return false
    return true
  }
  $.format = function (e) {
    for (var t = /%./g, r, n, i = 0, s = [], o = 0; (r = t.exec(e)); ) {
      ;(n = e.substring(o, t.lastIndex - 2)),
        n.length > 0 && s.push(n),
        (o = t.lastIndex)
      var a = r[0][1]
      switch (a) {
        case "s":
        case "o":
          i < arguments.length ? s.push(arguments[i++ + 1]) : s.push("<?>")
          break
        case "%":
          s.push("%")
          break
        default:
          s.push("<%" + a + "?>")
      }
    }
    return s.push(e.substring(o)), s.join("")
  }
  $.formatNumber = function (e, t, r, n) {
    var i = e,
      s = isNaN((t = Math.abs(t))) ? 2 : t,
      o = r === undefined ? "," : r,
      a = n === undefined ? "." : n,
      l = i < 0 ? "-" : "",
      c = parseInt((i = Math.abs(+i || 0).toFixed(s)), 10) + "",
      u = c.length > 3 ? c.length % 3 : 0
    return (
      l +
      (u ? c.substr(0, u) + a : "") +
      c.substr(u).replace(/(\d{3})(?=\d)/g, "$1" + a) +
      (s
        ? o +
          Math.abs(i - c)
            .toFixed(s)
            .slice(2)
        : "")
    )
  }
  $.formatSize = function (e) {
    return (
      e >= 1073741824
        ? (e = $.formatNumber(e / 1073741824, 2, ".", "") + " GiB")
        : e >= 1048576
          ? (e = $.formatNumber(e / 1048576, 2, ".", "") + " MiB")
          : e >= 1024
            ? (e = $.formatNumber(e / 1024, 0) + " KiB")
            : (e = $.formatNumber(e, 0) + " bytes"),
      e
    )
  }
  $.bytesFromIP = function (e) {
    return e.indexOf(".") !== -1
      ? $.bytesFromIPv4(e)
      : e.indexOf(":") !== -1
        ? $.bytesFromIPv6(e)
        : null
  }
  $.bytesFromIPv4 = function (e) {
    if (((e = e.split(".")), e.length !== 4)) return null
    for (var t = $.createBuffer(), r = 0; r < e.length; ++r) {
      var n = parseInt(e[r], 10)
      if (isNaN(n)) return null
      t.putByte(n)
    }
    return t.getBytes()
  }
  $.bytesFromIPv6 = function (e) {
    var t = 0
    e = e.split(":").filter(function (o) {
      return o.length === 0 && ++t, true
    })
    for (
      var r = (8 - e.length + t) * 2, n = $.createBuffer(), i = 0;
      i < 8;
      ++i
    ) {
      if (!e[i] || e[i].length === 0) {
        n.fillWithByte(0, r), (r = 0)
        continue
      }
      var s = $.hexToBytes(e[i])
      s.length < 2 && n.putByte(0), n.putBytes(s)
    }
    return n.getBytes()
  }
  $.bytesToIP = function (e) {
    return e.length === 4
      ? $.bytesToIPv4(e)
      : e.length === 16
        ? $.bytesToIPv6(e)
        : null
  }
  $.bytesToIPv4 = function (e) {
    if (e.length !== 4) return null
    for (var t = [], r = 0; r < e.length; ++r) t.push(e.charCodeAt(r))
    return t.join(".")
  }
  $.bytesToIPv6 = function (e) {
    if (e.length !== 16) return null
    for (var t = [], r = [], n = 0, i = 0; i < e.length; i += 2) {
      for (var s = $.bytesToHex(e[i] + e[i + 1]); s[0] === "0" && s !== "0"; )
        s = s.substr(1)
      if (s === "0") {
        var o = r[r.length - 1],
          a = t.length
        !o || a !== o.end + 1
          ? r.push({ start: a, end: a })
          : ((o.end = a),
            o.end - o.start > r[n].end - r[n].start && (n = r.length - 1))
      }
      t.push(s)
    }
    if (r.length > 0) {
      var l = r[n]
      l.end - l.start > 0 &&
        (t.splice(l.start, l.end - l.start + 1, ""),
        l.start === 0 && t.unshift(""),
        l.end === 7 && t.push(""))
    }
    return t.join(":")
  }
  $.estimateCores = function (e, t) {
    if (
      (typeof e == "function" && ((t = e), (e = {})),
      (e = e || {}),
      "cores" in $ && !e.update)
    )
      return t(null, $.cores)
    if (
      typeof navigator < "u" &&
      "hardwareConcurrency" in navigator &&
      navigator.hardwareConcurrency > 0
    )
      return ($.cores = navigator.hardwareConcurrency), t(null, $.cores)
    if (typeof Worker > "u") return ($.cores = 1), t(null, $.cores)
    if (typeof Blob > "u") return ($.cores = 2), t(null, $.cores)
    var r = URL.createObjectURL(
      new Blob(
        [
          "(",
          function () {
            self.addEventListener("message", function (o) {
              for (var a = Date.now(), l = a + 4; Date.now() < l; );
              self.postMessage({ st: a, et: l })
            })
          }.toString(),
          ")()",
        ],
        { type: "application/javascript" },
      ),
    )
    n([], 5, 16)
    function n(o, a, l) {
      if (a === 0) {
        var c = Math.floor(
          o.reduce(function (u, f) {
            return u + f
          }, 0) / o.length,
        )
        return (
          ($.cores = Math.max(1, c)), URL.revokeObjectURL(r), t(null, $.cores)
        )
      }
      i(l, function (u, f) {
        o.push(s(l, f)), n(o, a - 1, l)
      })
    }
    function i(o, a) {
      for (var l = [], c = [], u = 0; u < o; ++u) {
        var f = new Worker(r)
        f.addEventListener("message", function (p) {
          if ((c.push(p.data), c.length === o)) {
            for (var g = 0; g < o; ++g) l[g].terminate()
            a(null, c)
          }
        }),
          l.push(f)
      }
      for (var u = 0; u < o; ++u) l[u].postMessage(u)
    }
    function s(o, a) {
      for (var l = [], c = 0; c < o; ++c)
        for (var u = a[c], f = (l[c] = []), p = 0; p < o; ++p)
          if (c !== p) {
            var g = a[p]
            ;((u.st > g.st && u.st < g.et) || (g.st > u.st && g.st < u.et)) &&
              f.push(p)
          }
      return l.reduce(function (m, y) {
        return Math.max(m, y.length)
      }, 0)
    }
  }
})
var tT = _((jTt, Kce) => {
  "use strict"
  var ns = jt()
  Pr()
  Kce.exports = ns.cipher = ns.cipher || {}
  ns.cipher.algorithms = ns.cipher.algorithms || {}
  ns.cipher.createCipher = function (e, t) {
    var r = e
    if (
      (typeof r == "string" &&
        ((r = ns.cipher.getAlgorithm(r)), r && (r = r())),
      !r)
    )
      throw new Error("Unsupported algorithm: " + e)
    return new ns.cipher.BlockCipher({ algorithm: r, key: t, decrypt: false })
  }
  ns.cipher.createDecipher = function (e, t) {
    var r = e
    if (
      (typeof r == "string" &&
        ((r = ns.cipher.getAlgorithm(r)), r && (r = r())),
      !r)
    )
      throw new Error("Unsupported algorithm: " + e)
    return new ns.cipher.BlockCipher({ algorithm: r, key: t, decrypt: true })
  }
  ns.cipher.registerAlgorithm = function (e, t) {
    ;(e = e.toUpperCase()), (ns.cipher.algorithms[e] = t)
  }
  ns.cipher.getAlgorithm = function (e) {
    return (
      (e = e.toUpperCase()),
      e in ns.cipher.algorithms ? ns.cipher.algorithms[e] : null
    )
  }
  var SW = (ns.cipher.BlockCipher = function (e) {
    ;(this.algorithm = e.algorithm),
      (this.mode = this.algorithm.mode),
      (this.blockSize = this.mode.blockSize),
      (this._finish = false),
      (this._input = null),
      (this.output = null),
      (this._op = e.decrypt ? this.mode.decrypt : this.mode.encrypt),
      (this._decrypt = e.decrypt),
      this.algorithm.initialize(e)
  })
  SW.prototype.start = function (e) {
    e = e || {}
    var t = {}
    for (var r in e) t[r] = e[r]
    ;(t.decrypt = this._decrypt),
      (this._finish = false),
      (this._input = ns.util.createBuffer()),
      (this.output = e.output || ns.util.createBuffer()),
      this.mode.start(t)
  }
  SW.prototype.update = function (e) {
    for (
      e && this._input.putBuffer(e);
      !this._op.call(this.mode, this._input, this.output, this._finish) &&
      !this._finish;

    );
    this._input.compact()
  }
  SW.prototype.finish = function (e) {
    e &&
      (this.mode.name === "ECB" || this.mode.name === "CBC") &&
      ((this.mode.pad = function (r) {
        return e(this.blockSize, r, false)
      }),
      (this.mode.unpad = function (r) {
        return e(this.blockSize, r, true)
      }))
    var t = {}
    return (
      (t.decrypt = this._decrypt),
      (t.overflow = this._input.length() % this.blockSize),
      !(
        (!this._decrypt && this.mode.pad && !this.mode.pad(this._input, t)) ||
        ((this._finish = true),
        this.update(),
        this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, t)) ||
        (this.mode.afterFinish && !this.mode.afterFinish(this.output, t))
      )
    )
  }
})
var BW = _((ZTt, zce) => {
  "use strict"
  var is = jt()
  Pr()
  is.cipher = is.cipher || {}
  var dr = (zce.exports = is.cipher.modes = is.cipher.modes || {})
  dr.ecb = function (e) {
    ;(e = e || {}),
      (this.name = "ECB"),
      (this.cipher = e.cipher),
      (this.blockSize = e.blockSize || 16),
      (this._ints = this.blockSize / 4),
      (this._inBlock = new Array(this._ints)),
      (this._outBlock = new Array(this._ints))
  }
  dr.ecb.prototype.start = function (e) {}
  dr.ecb.prototype.encrypt = function (e, t, r) {
    if (e.length() < this.blockSize && !(r && e.length() > 0)) return true
    for (var n = 0; n < this._ints; ++n) this._inBlock[n] = e.getInt32()
    this.cipher.encrypt(this._inBlock, this._outBlock)
    for (var n = 0; n < this._ints; ++n) t.putInt32(this._outBlock[n])
  }
  dr.ecb.prototype.decrypt = function (e, t, r) {
    if (e.length() < this.blockSize && !(r && e.length() > 0)) return true
    for (var n = 0; n < this._ints; ++n) this._inBlock[n] = e.getInt32()
    this.cipher.decrypt(this._inBlock, this._outBlock)
    for (var n = 0; n < this._ints; ++n) t.putInt32(this._outBlock[n])
  }
  dr.ecb.prototype.pad = function (e, t) {
    var r =
      e.length() === this.blockSize
        ? this.blockSize
        : this.blockSize - e.length()
    return e.fillWithByte(r, r), true
  }
  dr.ecb.prototype.unpad = function (e, t) {
    if (t.overflow > 0) return false
    var r = e.length(),
      n = e.at(r - 1)
    return n > this.blockSize << 2 ? false : (e.truncate(n), true)
  }
  dr.cbc = function (e) {
    ;(e = e || {}),
      (this.name = "CBC"),
      (this.cipher = e.cipher),
      (this.blockSize = e.blockSize || 16),
      (this._ints = this.blockSize / 4),
      (this._inBlock = new Array(this._ints)),
      (this._outBlock = new Array(this._ints))
  }
  dr.cbc.prototype.start = function (e) {
    if (e.iv === null) {
      if (!this._prev) throw new Error("Invalid IV parameter.")
      this._iv = this._prev.slice(0)
    } else if ("iv" in e)
      (this._iv = rT(e.iv, this.blockSize)), (this._prev = this._iv.slice(0))
    else throw new Error("Invalid IV parameter.")
  }
  dr.cbc.prototype.encrypt = function (e, t, r) {
    if (e.length() < this.blockSize && !(r && e.length() > 0)) return true
    for (var n = 0; n < this._ints; ++n)
      this._inBlock[n] = this._prev[n] ^ e.getInt32()
    this.cipher.encrypt(this._inBlock, this._outBlock)
    for (var n = 0; n < this._ints; ++n) t.putInt32(this._outBlock[n])
    this._prev = this._outBlock
  }
  dr.cbc.prototype.decrypt = function (e, t, r) {
    if (e.length() < this.blockSize && !(r && e.length() > 0)) return true
    for (var n = 0; n < this._ints; ++n) this._inBlock[n] = e.getInt32()
    this.cipher.decrypt(this._inBlock, this._outBlock)
    for (var n = 0; n < this._ints; ++n)
      t.putInt32(this._prev[n] ^ this._outBlock[n])
    this._prev = this._inBlock.slice(0)
  }
  dr.cbc.prototype.pad = function (e, t) {
    var r =
      e.length() === this.blockSize
        ? this.blockSize
        : this.blockSize - e.length()
    return e.fillWithByte(r, r), true
  }
  dr.cbc.prototype.unpad = function (e, t) {
    if (t.overflow > 0) return false
    var r = e.length(),
      n = e.at(r - 1)
    return n > this.blockSize << 2 ? false : (e.truncate(n), true)
  }
  dr.cfb = function (e) {
    ;(e = e || {}),
      (this.name = "CFB"),
      (this.cipher = e.cipher),
      (this.blockSize = e.blockSize || 16),
      (this._ints = this.blockSize / 4),
      (this._inBlock = null),
      (this._outBlock = new Array(this._ints)),
      (this._partialBlock = new Array(this._ints)),
      (this._partialOutput = is.util.createBuffer()),
      (this._partialBytes = 0)
  }
  dr.cfb.prototype.start = function (e) {
    if (!("iv" in e)) throw new Error("Invalid IV parameter.")
    ;(this._iv = rT(e.iv, this.blockSize)),
      (this._inBlock = this._iv.slice(0)),
      (this._partialBytes = 0)
  }
  dr.cfb.prototype.encrypt = function (e, t, r) {
    var n = e.length()
    if (n === 0) return true
    if (
      (this.cipher.encrypt(this._inBlock, this._outBlock),
      this._partialBytes === 0 && n >= this.blockSize)
    ) {
      for (var i = 0; i < this._ints; ++i)
        (this._inBlock[i] = e.getInt32() ^ this._outBlock[i]),
          t.putInt32(this._inBlock[i])
      return
    }
    var s = (this.blockSize - n) % this.blockSize
    s > 0 && (s = this.blockSize - s), this._partialOutput.clear()
    for (var i = 0; i < this._ints; ++i)
      (this._partialBlock[i] = e.getInt32() ^ this._outBlock[i]),
        this._partialOutput.putInt32(this._partialBlock[i])
    if (s > 0) e.read -= this.blockSize
    else
      for (var i = 0; i < this._ints; ++i)
        this._inBlock[i] = this._partialBlock[i]
    if (
      (this._partialBytes > 0 &&
        this._partialOutput.getBytes(this._partialBytes),
      s > 0 && !r)
    )
      return (
        t.putBytes(this._partialOutput.getBytes(s - this._partialBytes)),
        (this._partialBytes = s),
        true
      )
    t.putBytes(this._partialOutput.getBytes(n - this._partialBytes)),
      (this._partialBytes = 0)
  }
  dr.cfb.prototype.decrypt = function (e, t, r) {
    var n = e.length()
    if (n === 0) return true
    if (
      (this.cipher.encrypt(this._inBlock, this._outBlock),
      this._partialBytes === 0 && n >= this.blockSize)
    ) {
      for (var i = 0; i < this._ints; ++i)
        (this._inBlock[i] = e.getInt32()),
          t.putInt32(this._inBlock[i] ^ this._outBlock[i])
      return
    }
    var s = (this.blockSize - n) % this.blockSize
    s > 0 && (s = this.blockSize - s), this._partialOutput.clear()
    for (var i = 0; i < this._ints; ++i)
      (this._partialBlock[i] = e.getInt32()),
        this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i])
    if (s > 0) e.read -= this.blockSize
    else
      for (var i = 0; i < this._ints; ++i)
        this._inBlock[i] = this._partialBlock[i]
    if (
      (this._partialBytes > 0 &&
        this._partialOutput.getBytes(this._partialBytes),
      s > 0 && !r)
    )
      return (
        t.putBytes(this._partialOutput.getBytes(s - this._partialBytes)),
        (this._partialBytes = s),
        true
      )
    t.putBytes(this._partialOutput.getBytes(n - this._partialBytes)),
      (this._partialBytes = 0)
  }
  dr.ofb = function (e) {
    ;(e = e || {}),
      (this.name = "OFB"),
      (this.cipher = e.cipher),
      (this.blockSize = e.blockSize || 16),
      (this._ints = this.blockSize / 4),
      (this._inBlock = null),
      (this._outBlock = new Array(this._ints)),
      (this._partialOutput = is.util.createBuffer()),
      (this._partialBytes = 0)
  }
  dr.ofb.prototype.start = function (e) {
    if (!("iv" in e)) throw new Error("Invalid IV parameter.")
    ;(this._iv = rT(e.iv, this.blockSize)),
      (this._inBlock = this._iv.slice(0)),
      (this._partialBytes = 0)
  }
  dr.ofb.prototype.encrypt = function (e, t, r) {
    var n = e.length()
    if (e.length() === 0) return true
    if (
      (this.cipher.encrypt(this._inBlock, this._outBlock),
      this._partialBytes === 0 && n >= this.blockSize)
    ) {
      for (var i = 0; i < this._ints; ++i)
        t.putInt32(e.getInt32() ^ this._outBlock[i]),
          (this._inBlock[i] = this._outBlock[i])
      return
    }
    var s = (this.blockSize - n) % this.blockSize
    s > 0 && (s = this.blockSize - s), this._partialOutput.clear()
    for (var i = 0; i < this._ints; ++i)
      this._partialOutput.putInt32(e.getInt32() ^ this._outBlock[i])
    if (s > 0) e.read -= this.blockSize
    else
      for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._outBlock[i]
    if (
      (this._partialBytes > 0 &&
        this._partialOutput.getBytes(this._partialBytes),
      s > 0 && !r)
    )
      return (
        t.putBytes(this._partialOutput.getBytes(s - this._partialBytes)),
        (this._partialBytes = s),
        true
      )
    t.putBytes(this._partialOutput.getBytes(n - this._partialBytes)),
      (this._partialBytes = 0)
  }
  dr.ofb.prototype.decrypt = dr.ofb.prototype.encrypt
  dr.ctr = function (e) {
    ;(e = e || {}),
      (this.name = "CTR"),
      (this.cipher = e.cipher),
      (this.blockSize = e.blockSize || 16),
      (this._ints = this.blockSize / 4),
      (this._inBlock = null),
      (this._outBlock = new Array(this._ints)),
      (this._partialOutput = is.util.createBuffer()),
      (this._partialBytes = 0)
  }
  dr.ctr.prototype.start = function (e) {
    if (!("iv" in e)) throw new Error("Invalid IV parameter.")
    ;(this._iv = rT(e.iv, this.blockSize)),
      (this._inBlock = this._iv.slice(0)),
      (this._partialBytes = 0)
  }
  dr.ctr.prototype.encrypt = function (e, t, r) {
    var n = e.length()
    if (n === 0) return true
    if (
      (this.cipher.encrypt(this._inBlock, this._outBlock),
      this._partialBytes === 0 && n >= this.blockSize)
    )
      for (var i = 0; i < this._ints; ++i)
        t.putInt32(e.getInt32() ^ this._outBlock[i])
    else {
      var s = (this.blockSize - n) % this.blockSize
      s > 0 && (s = this.blockSize - s), this._partialOutput.clear()
      for (var i = 0; i < this._ints; ++i)
        this._partialOutput.putInt32(e.getInt32() ^ this._outBlock[i])
      if (
        (s > 0 && (e.read -= this.blockSize),
        this._partialBytes > 0 &&
          this._partialOutput.getBytes(this._partialBytes),
        s > 0 && !r)
      )
        return (
          t.putBytes(this._partialOutput.getBytes(s - this._partialBytes)),
          (this._partialBytes = s),
          true
        )
      t.putBytes(this._partialOutput.getBytes(n - this._partialBytes)),
        (this._partialBytes = 0)
    }
    nT(this._inBlock)
  }
  dr.ctr.prototype.decrypt = dr.ctr.prototype.encrypt
  dr.gcm = function (e) {
    ;(e = e || {}),
      (this.name = "GCM"),
      (this.cipher = e.cipher),
      (this.blockSize = e.blockSize || 16),
      (this._ints = this.blockSize / 4),
      (this._inBlock = new Array(this._ints)),
      (this._outBlock = new Array(this._ints)),
      (this._partialOutput = is.util.createBuffer()),
      (this._partialBytes = 0),
      (this._R = 3774873600)
  }
  dr.gcm.prototype.start = function (e) {
    if (!("iv" in e)) throw new Error("Invalid IV parameter.")
    var t = is.util.createBuffer(e.iv)
    this._cipherLength = 0
    var r
    if (
      ("additionalData" in e
        ? (r = is.util.createBuffer(e.additionalData))
        : (r = is.util.createBuffer()),
      "tagLength" in e
        ? (this._tagLength = e.tagLength)
        : (this._tagLength = 128),
      (this._tag = null),
      e.decrypt &&
        ((this._tag = is.util.createBuffer(e.tag).getBytes()),
        this._tag.length !== this._tagLength / 8))
    )
      throw new Error("Authentication tag does not match tag length.")
    ;(this._hashBlock = new Array(this._ints)),
      (this.tag = null),
      (this._hashSubkey = new Array(this._ints)),
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey),
      (this.componentBits = 4),
      (this._m = this.generateHashTable(this._hashSubkey, this.componentBits))
    var n = t.length()
    if (n === 12) this._j0 = [t.getInt32(), t.getInt32(), t.getInt32(), 1]
    else {
      for (this._j0 = [0, 0, 0, 0]; t.length() > 0; )
        this._j0 = this.ghash(this._hashSubkey, this._j0, [
          t.getInt32(),
          t.getInt32(),
          t.getInt32(),
          t.getInt32(),
        ])
      this._j0 = this.ghash(
        this._hashSubkey,
        this._j0,
        [0, 0].concat(IW(n * 8)),
      )
    }
    ;(this._inBlock = this._j0.slice(0)),
      nT(this._inBlock),
      (this._partialBytes = 0),
      (r = is.util.createBuffer(r)),
      (this._aDataLength = IW(r.length() * 8))
    var i = r.length() % this.blockSize
    for (
      i && r.fillWithByte(0, this.blockSize - i), this._s = [0, 0, 0, 0];
      r.length() > 0;

    )
      this._s = this.ghash(this._hashSubkey, this._s, [
        r.getInt32(),
        r.getInt32(),
        r.getInt32(),
        r.getInt32(),
      ])
  }
  dr.gcm.prototype.encrypt = function (e, t, r) {
    var n = e.length()
    if (n === 0) return true
    if (
      (this.cipher.encrypt(this._inBlock, this._outBlock),
      this._partialBytes === 0 && n >= this.blockSize)
    ) {
      for (var i = 0; i < this._ints; ++i)
        t.putInt32((this._outBlock[i] ^= e.getInt32()))
      this._cipherLength += this.blockSize
    } else {
      var s = (this.blockSize - n) % this.blockSize
      s > 0 && (s = this.blockSize - s), this._partialOutput.clear()
      for (var i = 0; i < this._ints; ++i)
        this._partialOutput.putInt32(e.getInt32() ^ this._outBlock[i])
      if (s <= 0 || r) {
        if (r) {
          var o = n % this.blockSize
          ;(this._cipherLength += o),
            this._partialOutput.truncate(this.blockSize - o)
        } else this._cipherLength += this.blockSize
        for (var i = 0; i < this._ints; ++i)
          this._outBlock[i] = this._partialOutput.getInt32()
        this._partialOutput.read -= this.blockSize
      }
      if (
        (this._partialBytes > 0 &&
          this._partialOutput.getBytes(this._partialBytes),
        s > 0 && !r)
      )
        return (
          (e.read -= this.blockSize),
          t.putBytes(this._partialOutput.getBytes(s - this._partialBytes)),
          (this._partialBytes = s),
          true
        )
      t.putBytes(this._partialOutput.getBytes(n - this._partialBytes)),
        (this._partialBytes = 0)
    }
    ;(this._s = this.ghash(this._hashSubkey, this._s, this._outBlock)),
      nT(this._inBlock)
  }
  dr.gcm.prototype.decrypt = function (e, t, r) {
    var n = e.length()
    if (n < this.blockSize && !(r && n > 0)) return true
    this.cipher.encrypt(this._inBlock, this._outBlock),
      nT(this._inBlock),
      (this._hashBlock[0] = e.getInt32()),
      (this._hashBlock[1] = e.getInt32()),
      (this._hashBlock[2] = e.getInt32()),
      (this._hashBlock[3] = e.getInt32()),
      (this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock))
    for (var i = 0; i < this._ints; ++i)
      t.putInt32(this._outBlock[i] ^ this._hashBlock[i])
    n < this.blockSize
      ? (this._cipherLength += n % this.blockSize)
      : (this._cipherLength += this.blockSize)
  }
  dr.gcm.prototype.afterFinish = function (e, t) {
    var r = true
    t.decrypt && t.overflow && e.truncate(this.blockSize - t.overflow),
      (this.tag = is.util.createBuffer())
    var n = this._aDataLength.concat(IW(this._cipherLength * 8))
    this._s = this.ghash(this._hashSubkey, this._s, n)
    var i = []
    this.cipher.encrypt(this._j0, i)
    for (var s = 0; s < this._ints; ++s) this.tag.putInt32(this._s[s] ^ i[s])
    return (
      this.tag.truncate(this.tag.length() % (this._tagLength / 8)),
      t.decrypt && this.tag.bytes() !== this._tag && (r = false),
      r
    )
  }
  dr.gcm.prototype.multiply = function (e, t) {
    for (var r = [0, 0, 0, 0], n = t.slice(0), i = 0; i < 128; ++i) {
      var s = e[(i / 32) | 0] & (1 << (31 - (i % 32)))
      s && ((r[0] ^= n[0]), (r[1] ^= n[1]), (r[2] ^= n[2]), (r[3] ^= n[3])),
        this.pow(n, n)
    }
    return r
  }
  dr.gcm.prototype.pow = function (e, t) {
    for (var r = e[3] & 1, n = 3; n > 0; --n)
      t[n] = (e[n] >>> 1) | ((e[n - 1] & 1) << 31)
    ;(t[0] = e[0] >>> 1), r && (t[0] ^= this._R)
  }
  dr.gcm.prototype.tableMultiply = function (e) {
    for (var t = [0, 0, 0, 0], r = 0; r < 32; ++r) {
      var n = (r / 8) | 0,
        i = (e[n] >>> ((7 - (r % 8)) * 4)) & 15,
        s = this._m[r][i]
      ;(t[0] ^= s[0]), (t[1] ^= s[1]), (t[2] ^= s[2]), (t[3] ^= s[3])
    }
    return t
  }
  dr.gcm.prototype.ghash = function (e, t, r) {
    return (
      (t[0] ^= r[0]),
      (t[1] ^= r[1]),
      (t[2] ^= r[2]),
      (t[3] ^= r[3]),
      this.tableMultiply(t)
    )
  }
  dr.gcm.prototype.generateHashTable = function (e, t) {
    for (
      var r = 8 / t, n = 4 * r, i = 16 * r, s = new Array(i), o = 0;
      o < i;
      ++o
    ) {
      var a = [0, 0, 0, 0],
        l = (o / n) | 0,
        c = (n - 1 - (o % n)) * t
      ;(a[l] = (1 << (t - 1)) << c),
        (s[o] = this.generateSubHashTable(this.multiply(a, e), t))
    }
    return s
  }
  dr.gcm.prototype.generateSubHashTable = function (e, t) {
    var r = 1 << t,
      n = r >>> 1,
      i = new Array(r)
    i[n] = e.slice(0)
    for (var s = n >>> 1; s > 0; ) this.pow(i[2 * s], (i[s] = [])), (s >>= 1)
    for (s = 2; s < n; ) {
      for (var o = 1; o < s; ++o) {
        var a = i[s],
          l = i[o]
        i[s + o] = [a[0] ^ l[0], a[1] ^ l[1], a[2] ^ l[2], a[3] ^ l[3]]
      }
      s *= 2
    }
    for (i[0] = [0, 0, 0, 0], s = n + 1; s < r; ++s) {
      var c = i[s ^ n]
      i[s] = [e[0] ^ c[0], e[1] ^ c[1], e[2] ^ c[2], e[3] ^ c[3]]
    }
    return i
  }
  function rT(e, t) {
    if (
      (typeof e == "string" && (e = is.util.createBuffer(e)),
      is.util.isArray(e) && e.length > 4)
    ) {
      var r = e
      e = is.util.createBuffer()
      for (var n = 0; n < r.length; ++n) e.putByte(r[n])
    }
    if (e.length() < t)
      throw new Error(
        "Invalid IV length; got " +
          e.length() +
          " bytes and expected " +
          t +
          " bytes.",
      )
    if (!is.util.isArray(e)) {
      for (var i = [], s = t / 4, n = 0; n < s; ++n) i.push(e.getInt32())
      e = i
    }
    return e
  }
  function nT(e) {
    e[e.length - 1] = (e[e.length - 1] + 1) & 4294967295
  }
  function IW(e) {
    return [(e / 4294967296) | 0, e & 4294967295]
  }
})
var Rh = _((XTt, Xce) => {
  "use strict"
  var xn = jt()
  tT()
  BW()
  Pr()
  Xce.exports = xn.aes = xn.aes || {}
  xn.aes.startEncrypting = function (e, t, r, n) {
    var i = iT({ key: e, output: r, decrypt: false, mode: n })
    return i.start(t), i
  }
  xn.aes.createEncryptionCipher = function (e, t) {
    return iT({ key: e, output: null, decrypt: false, mode: t })
  }
  xn.aes.startDecrypting = function (e, t, r, n) {
    var i = iT({ key: e, output: r, decrypt: true, mode: n })
    return i.start(t), i
  }
  xn.aes.createDecryptionCipher = function (e, t) {
    return iT({ key: e, output: null, decrypt: true, mode: t })
  }
  xn.aes.Algorithm = function (e, t) {
    TW || jce()
    var r = this
    ;(r.name = e),
      (r.mode = new t({
        blockSize: 16,
        cipher: {
          encrypt: function (n, i) {
            return DW(r._w, n, i, false)
          },
          decrypt: function (n, i) {
            return DW(r._w, n, i, true)
          },
        },
      })),
      (r._init = false)
  }
  xn.aes.Algorithm.prototype.initialize = function (e) {
    if (!this._init) {
      var t = e.key,
        r
      if (
        typeof t == "string" &&
        (t.length === 16 || t.length === 24 || t.length === 32)
      )
        t = xn.util.createBuffer(t)
      else if (
        xn.util.isArray(t) &&
        (t.length === 16 || t.length === 24 || t.length === 32)
      ) {
        ;(r = t), (t = xn.util.createBuffer())
        for (var n = 0; n < r.length; ++n) t.putByte(r[n])
      }
      if (!xn.util.isArray(t)) {
        ;(r = t), (t = [])
        var i = r.length()
        if (i === 16 || i === 24 || i === 32) {
          i = i >>> 2
          for (var n = 0; n < i; ++n) t.push(r.getInt32())
        }
      }
      if (
        !xn.util.isArray(t) ||
        !(t.length === 4 || t.length === 6 || t.length === 8)
      )
        throw new Error("Invalid key parameter.")
      var s = this.mode.name,
        o = ["CFB", "OFB", "CTR", "GCM"].indexOf(s) !== -1
      ;(this._w = Zce(t, e.decrypt && !o)), (this._init = true)
    }
  }
  xn.aes._expandKey = function (e, t) {
    return TW || jce(), Zce(e, t)
  }
  xn.aes._updateBlock = DW
  my("AES-ECB", xn.cipher.modes.ecb)
  my("AES-CBC", xn.cipher.modes.cbc)
  my("AES-CFB", xn.cipher.modes.cfb)
  my("AES-OFB", xn.cipher.modes.ofb)
  my("AES-CTR", xn.cipher.modes.ctr)
  my("AES-GCM", xn.cipher.modes.gcm)
  function my(e, t) {
    var r = function () {
      return new xn.aes.Algorithm(e, t)
    }
    xn.cipher.registerAlgorithm(e, r)
  }
  var TW = false,
    py = 4,
    vo,
    RW,
    Jce,
    Vp,
    kc
  function jce() {
    ;(TW = true), (Jce = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54])
    for (var e = new Array(256), t = 0; t < 128; ++t)
      (e[t] = t << 1), (e[t + 128] = ((t + 128) << 1) ^ 283)
    ;(vo = new Array(256)),
      (RW = new Array(256)),
      (Vp = new Array(4)),
      (kc = new Array(4))
    for (var t = 0; t < 4; ++t)
      (Vp[t] = new Array(256)), (kc[t] = new Array(256))
    for (var r = 0, n = 0, i, s, o, a, l, c, u, t = 0; t < 256; ++t) {
      ;(a = n ^ (n << 1) ^ (n << 2) ^ (n << 3) ^ (n << 4)),
        (a = (a >> 8) ^ (a & 255) ^ 99),
        (vo[r] = a),
        (RW[a] = r),
        (l = e[a]),
        (i = e[r]),
        (s = e[i]),
        (o = e[s]),
        (c = (l << 24) ^ (a << 16) ^ (a << 8) ^ (a ^ l)),
        (u =
          ((i ^ s ^ o) << 24) ^
          ((r ^ o) << 16) ^
          ((r ^ s ^ o) << 8) ^
          (r ^ i ^ o))
      for (var f = 0; f < 4; ++f)
        (Vp[f][r] = c),
          (kc[f][a] = u),
          (c = (c << 24) | (c >>> 8)),
          (u = (u << 24) | (u >>> 8))
      r === 0 ? (r = n = 1) : ((r = i ^ e[e[e[i ^ o]]]), (n ^= e[e[n]]))
    }
  }
  function Zce(e, t) {
    for (
      var r = e.slice(0),
        n,
        i = 1,
        s = r.length,
        o = s + 6 + 1,
        a = py * o,
        l = s;
      l < a;
      ++l
    )
      (n = r[l - 1]),
        l % s === 0
          ? ((n =
              (vo[(n >>> 16) & 255] << 24) ^
              (vo[(n >>> 8) & 255] << 16) ^
              (vo[n & 255] << 8) ^
              vo[n >>> 24] ^
              (Jce[i] << 24)),
            i++)
          : s > 6 &&
            l % s === 4 &&
            (n =
              (vo[n >>> 24] << 24) ^
              (vo[(n >>> 16) & 255] << 16) ^
              (vo[(n >>> 8) & 255] << 8) ^
              vo[n & 255]),
        (r[l] = r[l - s] ^ n)
    if (t) {
      var c,
        u = kc[0],
        f = kc[1],
        p = kc[2],
        g = kc[3],
        m = r.slice(0)
      a = r.length
      for (var l = 0, y = a - py; l < a; l += py, y -= py)
        if (l === 0 || l === a - py)
          (m[l] = r[y]),
            (m[l + 1] = r[y + 3]),
            (m[l + 2] = r[y + 2]),
            (m[l + 3] = r[y + 1])
        else
          for (var v = 0; v < py; ++v)
            (c = r[y + v]),
              (m[l + (3 & -v)] =
                u[vo[c >>> 24]] ^
                f[vo[(c >>> 16) & 255]] ^
                p[vo[(c >>> 8) & 255]] ^
                g[vo[c & 255]])
      r = m
    }
    return r
  }
  function DW(e, t, r, n) {
    var i = e.length / 4 - 1,
      s,
      o,
      a,
      l,
      c
    n
      ? ((s = kc[0]), (o = kc[1]), (a = kc[2]), (l = kc[3]), (c = RW))
      : ((s = Vp[0]), (o = Vp[1]), (a = Vp[2]), (l = Vp[3]), (c = vo))
    var u, f, p, g, m, y, v
    ;(u = t[0] ^ e[0]),
      (f = t[n ? 3 : 1] ^ e[1]),
      (p = t[2] ^ e[2]),
      (g = t[n ? 1 : 3] ^ e[3])
    for (var C = 3, E = 1; E < i; ++E)
      (m =
        s[u >>> 24] ^
        o[(f >>> 16) & 255] ^
        a[(p >>> 8) & 255] ^
        l[g & 255] ^
        e[++C]),
        (y =
          s[f >>> 24] ^
          o[(p >>> 16) & 255] ^
          a[(g >>> 8) & 255] ^
          l[u & 255] ^
          e[++C]),
        (v =
          s[p >>> 24] ^
          o[(g >>> 16) & 255] ^
          a[(u >>> 8) & 255] ^
          l[f & 255] ^
          e[++C]),
        (g =
          s[g >>> 24] ^
          o[(u >>> 16) & 255] ^
          a[(f >>> 8) & 255] ^
          l[p & 255] ^
          e[++C]),
        (u = m),
        (f = y),
        (p = v)
    ;(r[0] =
      (c[u >>> 24] << 24) ^
      (c[(f >>> 16) & 255] << 16) ^
      (c[(p >>> 8) & 255] << 8) ^
      c[g & 255] ^
      e[++C]),
      (r[n ? 3 : 1] =
        (c[f >>> 24] << 24) ^
        (c[(p >>> 16) & 255] << 16) ^
        (c[(g >>> 8) & 255] << 8) ^
        c[u & 255] ^
        e[++C]),
      (r[2] =
        (c[p >>> 24] << 24) ^
        (c[(g >>> 16) & 255] << 16) ^
        (c[(u >>> 8) & 255] << 8) ^
        c[f & 255] ^
        e[++C]),
      (r[n ? 1 : 3] =
        (c[g >>> 24] << 24) ^
        (c[(u >>> 16) & 255] << 16) ^
        (c[(f >>> 8) & 255] << 8) ^
        c[p & 255] ^
        e[++C])
  }
  function iT(e) {
    e = e || {}
    var t = (e.mode || "CBC").toUpperCase(),
      r = "AES-" + t,
      n
    e.decrypt
      ? (n = xn.cipher.createDecipher(r, e.key))
      : (n = xn.cipher.createCipher(r, e.key))
    var i = n.start
    return (
      (n.start = function (s, o) {
        var a = null
        o instanceof xn.util.ByteBuffer && ((a = o), (o = {})),
          (o = o || {}),
          (o.output = a),
          (o.iv = s),
          i.call(n, o)
      }),
      n
    )
  }
})
var Dh = _((ekt, eue) => {
  "use strict"
  var d_ = jt()
  d_.pki = d_.pki || {}
  var kW = (eue.exports = d_.pki.oids = d_.oids = d_.oids || {})
  function ye(e, t) {
    ;(kW[e] = t), (kW[t] = e)
  }
  function sn(e, t) {
    kW[e] = t
  }
  ye("1.2.840.113549.1.1.1", "rsaEncryption")
  ye("1.2.840.113549.1.1.4", "md5WithRSAEncryption")
  ye("1.2.840.113549.1.1.5", "sha1WithRSAEncryption")
  ye("1.2.840.113549.1.1.7", "RSAES-OAEP")
  ye("1.2.840.113549.1.1.8", "mgf1")
  ye("1.2.840.113549.1.1.9", "pSpecified")
  ye("1.2.840.113549.1.1.10", "RSASSA-PSS")
  ye("1.2.840.113549.1.1.11", "sha256WithRSAEncryption")
  ye("1.2.840.113549.1.1.12", "sha384WithRSAEncryption")
  ye("1.2.840.113549.1.1.13", "sha512WithRSAEncryption")
  ye("1.3.101.112", "EdDSA25519")
  ye("1.2.840.10040.4.3", "dsa-with-sha1")
  ye("1.3.14.3.2.7", "desCBC")
  ye("1.3.14.3.2.26", "sha1")
  ye("1.3.14.3.2.29", "sha1WithRSASignature")
  ye("2.16.840.1.101.3.4.2.1", "sha256")
  ye("2.16.840.1.101.3.4.2.2", "sha384")
  ye("2.16.840.1.101.3.4.2.3", "sha512")
  ye("2.16.840.1.101.3.4.2.4", "sha224")
  ye("2.16.840.1.101.3.4.2.5", "sha512-224")
  ye("2.16.840.1.101.3.4.2.6", "sha512-256")
  ye("1.2.840.113549.2.2", "md2")
  ye("1.2.840.113549.2.5", "md5")
  ye("1.2.840.113549.1.7.1", "data")
  ye("1.2.840.113549.1.7.2", "signedData")
  ye("1.2.840.113549.1.7.3", "envelopedData")
  ye("1.2.840.113549.1.7.4", "signedAndEnvelopedData")
  ye("1.2.840.113549.1.7.5", "digestedData")
  ye("1.2.840.113549.1.7.6", "encryptedData")
  ye("1.2.840.113549.1.9.1", "emailAddress")
  ye("1.2.840.113549.1.9.2", "unstructuredName")
  ye("1.2.840.113549.1.9.3", "contentType")
  ye("1.2.840.113549.1.9.4", "messageDigest")
  ye("1.2.840.113549.1.9.5", "signingTime")
  ye("1.2.840.113549.1.9.6", "counterSignature")
  ye("1.2.840.113549.1.9.7", "challengePassword")
  ye("1.2.840.113549.1.9.8", "unstructuredAddress")
  ye("1.2.840.113549.1.9.14", "extensionRequest")
  ye("1.2.840.113549.1.9.20", "friendlyName")
  ye("1.2.840.113549.1.9.21", "localKeyId")
  ye("1.2.840.113549.1.9.22.1", "x509Certificate")
  ye("1.2.840.113549.1.12.10.1.1", "keyBag")
  ye("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag")
  ye("1.2.840.113549.1.12.10.1.3", "certBag")
  ye("1.2.840.113549.1.12.10.1.4", "crlBag")
  ye("1.2.840.113549.1.12.10.1.5", "secretBag")
  ye("1.2.840.113549.1.12.10.1.6", "safeContentsBag")
  ye("1.2.840.113549.1.5.13", "pkcs5PBES2")
  ye("1.2.840.113549.1.5.12", "pkcs5PBKDF2")
  ye("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4")
  ye("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4")
  ye("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC")
  ye("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC")
  ye("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC")
  ye("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC")
  ye("1.2.840.113549.2.7", "hmacWithSHA1")
  ye("1.2.840.113549.2.8", "hmacWithSHA224")
  ye("1.2.840.113549.2.9", "hmacWithSHA256")
  ye("1.2.840.113549.2.10", "hmacWithSHA384")
  ye("1.2.840.113549.2.11", "hmacWithSHA512")
  ye("1.2.840.113549.3.7", "des-EDE3-CBC")
  ye("2.16.840.1.101.3.4.1.2", "aes128-CBC")
  ye("2.16.840.1.101.3.4.1.22", "aes192-CBC")
  ye("2.16.840.1.101.3.4.1.42", "aes256-CBC")
  ye("2.5.4.3", "commonName")
  ye("2.5.4.4", "surname")
  ye("2.5.4.5", "serialNumber")
  ye("2.5.4.6", "countryName")
  ye("2.5.4.7", "localityName")
  ye("2.5.4.8", "stateOrProvinceName")
  ye("2.5.4.9", "streetAddress")
  ye("2.5.4.10", "organizationName")
  ye("2.5.4.11", "organizationalUnitName")
  ye("2.5.4.12", "title")
  ye("2.5.4.13", "description")
  ye("2.5.4.15", "businessCategory")
  ye("2.5.4.17", "postalCode")
  ye("2.5.4.42", "givenName")
  ye(
    "1.3.6.1.4.1.311.60.2.1.2",
    "jurisdictionOfIncorporationStateOrProvinceName",
  )
  ye("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName")
  ye("2.16.840.1.113730.1.1", "nsCertType")
  ye("2.16.840.1.113730.1.13", "nsComment")
  sn("2.5.29.1", "authorityKeyIdentifier")
  sn("2.5.29.2", "keyAttributes")
  sn("2.5.29.3", "certificatePolicies")
  sn("2.5.29.4", "keyUsageRestriction")
  sn("2.5.29.5", "policyMapping")
  sn("2.5.29.6", "subtreesConstraint")
  sn("2.5.29.7", "subjectAltName")
  sn("2.5.29.8", "issuerAltName")
  sn("2.5.29.9", "subjectDirectoryAttributes")
  sn("2.5.29.10", "basicConstraints")
  sn("2.5.29.11", "nameConstraints")
  sn("2.5.29.12", "policyConstraints")
  sn("2.5.29.13", "basicConstraints")
  ye("2.5.29.14", "subjectKeyIdentifier")
  ye("2.5.29.15", "keyUsage")
  sn("2.5.29.16", "privateKeyUsagePeriod")
  ye("2.5.29.17", "subjectAltName")
  ye("2.5.29.18", "issuerAltName")
  ye("2.5.29.19", "basicConstraints")
  sn("2.5.29.20", "cRLNumber")
  sn("2.5.29.21", "cRLReason")
  sn("2.5.29.22", "expirationDate")
  sn("2.5.29.23", "instructionCode")
  sn("2.5.29.24", "invalidityDate")
  sn("2.5.29.25", "cRLDistributionPoints")
  sn("2.5.29.26", "issuingDistributionPoint")
  sn("2.5.29.27", "deltaCRLIndicator")
  sn("2.5.29.28", "issuingDistributionPoint")
  sn("2.5.29.29", "certificateIssuer")
  sn("2.5.29.30", "nameConstraints")
  ye("2.5.29.31", "cRLDistributionPoints")
  ye("2.5.29.32", "certificatePolicies")
  sn("2.5.29.33", "policyMappings")
  sn("2.5.29.34", "policyConstraints")
  ye("2.5.29.35", "authorityKeyIdentifier")
  sn("2.5.29.36", "policyConstraints")
  ye("2.5.29.37", "extKeyUsage")
  sn("2.5.29.46", "freshestCRL")
  sn("2.5.29.54", "inhibitAnyPolicy")
  ye("1.3.6.1.4.1.11129.2.4.2", "timestampList")
  ye("1.3.6.1.5.5.7.1.1", "authorityInfoAccess")
  ye("1.3.6.1.5.5.7.3.1", "serverAuth")
  ye("1.3.6.1.5.5.7.3.2", "clientAuth")
  ye("1.3.6.1.5.5.7.3.3", "codeSigning")
  ye("1.3.6.1.5.5.7.3.4", "emailProtection")
  ye("1.3.6.1.5.5.7.3.8", "timeStamping")
})
var Mc = _((tkt, rue) => {
  "use strict"
  var Qn = jt()
  Pr()
  Dh()
  var Me = (rue.exports = Qn.asn1 = Qn.asn1 || {})
  Me.Class = {
    UNIVERSAL: 0,
    APPLICATION: 64,
    CONTEXT_SPECIFIC: 128,
    PRIVATE: 192,
  }
  Me.Type = {
    NONE: 0,
    BOOLEAN: 1,
    INTEGER: 2,
    BITSTRING: 3,
    OCTETSTRING: 4,
    NULL: 5,
    OID: 6,
    ODESC: 7,
    EXTERNAL: 8,
    REAL: 9,
    ENUMERATED: 10,
    EMBEDDED: 11,
    UTF8: 12,
    ROID: 13,
    SEQUENCE: 16,
    SET: 17,
    PRINTABLESTRING: 19,
    IA5STRING: 22,
    UTCTIME: 23,
    GENERALIZEDTIME: 24,
    BMPSTRING: 30,
  }
  Me.create = function (e, t, r, n, i) {
    if (Qn.util.isArray(n)) {
      for (var s = [], o = 0; o < n.length; ++o) n[o] !== undefined && s.push(n[o])
      n = s
    }
    var a = {
      tagClass: e,
      type: t,
      constructed: r,
      composed: r || Qn.util.isArray(n),
      value: n,
    }
    return (
      i &&
        "bitStringContents" in i &&
        ((a.bitStringContents = i.bitStringContents),
        (a.original = Me.copy(a))),
      a
    )
  }
  Me.copy = function (e, t) {
    var r
    if (Qn.util.isArray(e)) {
      r = []
      for (var n = 0; n < e.length; ++n) r.push(Me.copy(e[n], t))
      return r
    }
    return typeof e == "string"
      ? e
      : ((r = {
          tagClass: e.tagClass,
          type: e.type,
          constructed: e.constructed,
          composed: e.composed,
          value: Me.copy(e.value, t),
        }),
        t &&
          !t.excludeBitStringContents &&
          (r.bitStringContents = e.bitStringContents),
        r)
  }
  Me.equals = function (e, t, r) {
    if (Qn.util.isArray(e)) {
      if (!Qn.util.isArray(t) || e.length !== t.length) return false
      for (var n = 0; n < e.length; ++n) if (!Me.equals(e[n], t[n])) return false
      return true
    }
    if (typeof e != typeof t) return false
    if (typeof e == "string") return e === t
    var i =
      e.tagClass === t.tagClass &&
      e.type === t.type &&
      e.constructed === t.constructed &&
      e.composed === t.composed &&
      Me.equals(e.value, t.value)
    return (
      r &&
        r.includeBitStringContents &&
        (i = i && e.bitStringContents === t.bitStringContents),
      i
    )
  }
  Me.getBerValueLength = function (e) {
    var t = e.getByte()
    if (t !== 128) {
      var r,
        n = t & 128
      return n ? (r = e.getInt((t & 127) << 3)) : (r = t), r
    }
  }
  function f_(e, t, r) {
    if (r > t) {
      var n = new Error("Too few bytes to parse DER.")
      throw (
        ((n.available = e.length()), (n.remaining = t), (n.requested = r), n)
      )
    }
  }
  var fXe = function (e, t) {
    var r = e.getByte()
    if ((t--, r !== 128)) {
      var n,
        i = r & 128
      if (!i) n = r
      else {
        var s = r & 127
        f_(e, t, s), (n = e.getInt(s << 3))
      }
      if (n < 0) throw new Error("Negative length: " + n)
      return n
    }
  }
  Me.fromDer = function (e, t) {
    t === undefined &&
      (t = { strict: true, parseAllBytes: true, decodeBitStrings: true }),
      typeof t == "boolean" &&
        (t = { strict: t, parseAllBytes: true, decodeBitStrings: true }),
      "strict" in t || (t.strict = true),
      "parseAllBytes" in t || (t.parseAllBytes = true),
      "decodeBitStrings" in t || (t.decodeBitStrings = true),
      typeof e == "string" && (e = Qn.util.createBuffer(e))
    var r = e.length(),
      n = sT(e, e.length(), 0, t)
    if (t.parseAllBytes && e.length() !== 0) {
      var i = new Error("Unparsed DER bytes remain after ASN.1 parsing.")
      throw ((i.byteCount = r), (i.remaining = e.length()), i)
    }
    return n
  }
  function sT(e, t, r, n) {
    var i
    f_(e, t, 2)
    var s = e.getByte()
    t--
    var o = s & 192,
      a = s & 31
    i = e.length()
    var l = fXe(e, t)
    if (((t -= i - e.length()), l !== undefined && l > t)) {
      if (n.strict) {
        var c = new Error("Too few bytes to read ASN.1 value.")
        throw (
          ((c.available = e.length()), (c.remaining = t), (c.requested = l), c)
        )
      }
      l = t
    }
    var u,
      f,
      p = (s & 32) === 32
    if (p)
      if (((u = []), l === undefined))
        for (;;) {
          if ((f_(e, t, 2), e.bytes(2) === "\0\0")) {
            e.getBytes(2), (t -= 2)
            break
          }
          ;(i = e.length()), u.push(sT(e, t, r + 1, n)), (t -= i - e.length())
        }
      else
        for (; l > 0; )
          (i = e.length()),
            u.push(sT(e, l, r + 1, n)),
            (t -= i - e.length()),
            (l -= i - e.length())
    if (
      (u === undefined &&
        o === Me.Class.UNIVERSAL &&
        a === Me.Type.BITSTRING &&
        (f = e.bytes(l)),
      u === undefined &&
        n.decodeBitStrings &&
        o === Me.Class.UNIVERSAL &&
        a === Me.Type.BITSTRING &&
        l > 1)
    ) {
      var g = e.read,
        m = t,
        y = 0
      if (
        (a === Me.Type.BITSTRING && (f_(e, t, 1), (y = e.getByte()), t--),
        y === 0)
      )
        try {
          i = e.length()
          var v = { strict: true, decodeBitStrings: true },
            C = sT(e, t, r + 1, v),
            E = i - e.length()
          ;(t -= E), a == Me.Type.BITSTRING && E++
          var w = C.tagClass
          E === l &&
            (w === Me.Class.UNIVERSAL || w === Me.Class.CONTEXT_SPECIFIC) &&
            (u = [C])
        } catch {}
      u === undefined && ((e.read = g), (t = m))
    }
    if (u === undefined) {
      if (l === undefined) {
        if (n.strict)
          throw new Error("Non-constructed ASN.1 object of indefinite length.")
        l = t
      }
      if (a === Me.Type.BMPSTRING)
        for (u = ""; l > 0; l -= 2)
          f_(e, t, 2), (u += String.fromCharCode(e.getInt16())), (t -= 2)
      else (u = e.getBytes(l)), (t -= l)
    }
    var B = f === undefined ? null : { bitStringContents: f }
    return Me.create(o, a, p, u, B)
  }
  Me.toDer = function (e) {
    var t = Qn.util.createBuffer(),
      r = e.tagClass | e.type,
      n = Qn.util.createBuffer(),
      i = false
    if (
      ("bitStringContents" in e &&
        ((i = true), e.original && (i = Me.equals(e, e.original))),
      i)
    )
      n.putBytes(e.bitStringContents)
    else if (e.composed) {
      e.constructed ? (r |= 32) : n.putByte(0)
      for (var s = 0; s < e.value.length; ++s)
        e.value[s] !== undefined && n.putBuffer(Me.toDer(e.value[s]))
    } else if (e.type === Me.Type.BMPSTRING)
      for (var s = 0; s < e.value.length; ++s) n.putInt16(e.value.charCodeAt(s))
    else
      e.type === Me.Type.INTEGER &&
      e.value.length > 1 &&
      ((e.value.charCodeAt(0) === 0 && !(e.value.charCodeAt(1) & 128)) ||
        (e.value.charCodeAt(0) === 255 &&
          (e.value.charCodeAt(1) & 128) === 128))
        ? n.putBytes(e.value.substr(1))
        : n.putBytes(e.value)
    if ((t.putByte(r), n.length() <= 127)) t.putByte(n.length() & 127)
    else {
      var o = n.length(),
        a = ""
      do (a += String.fromCharCode(o & 255)), (o = o >>> 8)
      while (o > 0)
      t.putByte(a.length | 128)
      for (var s = a.length - 1; s >= 0; --s) t.putByte(a.charCodeAt(s))
    }
    return t.putBuffer(n), t
  }
  Me.oidToDer = function (e) {
    var t = e.split("."),
      r = Qn.util.createBuffer()
    r.putByte(40 * parseInt(t[0], 10) + parseInt(t[1], 10))
    for (var n, i, s, o, a = 2; a < t.length; ++a) {
      ;(n = true), (i = []), (s = parseInt(t[a], 10))
      do (o = s & 127), (s = s >>> 7), n || (o |= 128), i.push(o), (n = false)
      while (s > 0)
      for (var l = i.length - 1; l >= 0; --l) r.putByte(i[l])
    }
    return r
  }
  Me.derToOid = function (e) {
    var t
    typeof e == "string" && (e = Qn.util.createBuffer(e))
    var r = e.getByte()
    t = Math.floor(r / 40) + "." + (r % 40)
    for (var n = 0; e.length() > 0; )
      (r = e.getByte()),
        (n = n << 7),
        r & 128 ? (n += r & 127) : ((t += "." + (n + r)), (n = 0))
    return t
  }
  Me.utcTimeToDate = function (e) {
    var t = new Date(),
      r = parseInt(e.substr(0, 2), 10)
    r = r >= 50 ? 1900 + r : 2e3 + r
    var n = parseInt(e.substr(2, 2), 10) - 1,
      i = parseInt(e.substr(4, 2), 10),
      s = parseInt(e.substr(6, 2), 10),
      o = parseInt(e.substr(8, 2), 10),
      a = 0
    if (e.length > 11) {
      var l = e.charAt(10),
        c = 10
      l !== "+" && l !== "-" && ((a = parseInt(e.substr(10, 2), 10)), (c += 2))
    }
    if (
      (t.setUTCFullYear(r, n, i),
      t.setUTCHours(s, o, a, 0),
      c && ((l = e.charAt(c)), l === "+" || l === "-"))
    ) {
      var u = parseInt(e.substr(c + 1, 2), 10),
        f = parseInt(e.substr(c + 4, 2), 10),
        p = u * 60 + f
      ;(p *= 6e4), l === "+" ? t.setTime(+t - p) : t.setTime(+t + p)
    }
    return t
  }
  Me.generalizedTimeToDate = function (e) {
    var t = new Date(),
      r = parseInt(e.substr(0, 4), 10),
      n = parseInt(e.substr(4, 2), 10) - 1,
      i = parseInt(e.substr(6, 2), 10),
      s = parseInt(e.substr(8, 2), 10),
      o = parseInt(e.substr(10, 2), 10),
      a = parseInt(e.substr(12, 2), 10),
      l = 0,
      c = 0,
      u = false
    e.charAt(e.length - 1) === "Z" && (u = true)
    var f = e.length - 5,
      p = e.charAt(f)
    if (p === "+" || p === "-") {
      var g = parseInt(e.substr(f + 1, 2), 10),
        m = parseInt(e.substr(f + 4, 2), 10)
      ;(c = g * 60 + m), (c *= 6e4), p === "+" && (c *= -1), (u = true)
    }
    return (
      e.charAt(14) === "." && (l = parseFloat(e.substr(14), 10) * 1e3),
      u
        ? (t.setUTCFullYear(r, n, i),
          t.setUTCHours(s, o, a, l),
          t.setTime(+t + c))
        : (t.setFullYear(r, n, i), t.setHours(s, o, a, l)),
      t
    )
  }
  Me.dateToUtcTime = function (e) {
    if (typeof e == "string") return e
    var t = "",
      r = []
    r.push(("" + e.getUTCFullYear()).substr(2)),
      r.push("" + (e.getUTCMonth() + 1)),
      r.push("" + e.getUTCDate()),
      r.push("" + e.getUTCHours()),
      r.push("" + e.getUTCMinutes()),
      r.push("" + e.getUTCSeconds())
    for (var n = 0; n < r.length; ++n)
      r[n].length < 2 && (t += "0"), (t += r[n])
    return (t += "Z"), t
  }
  Me.dateToGeneralizedTime = function (e) {
    if (typeof e == "string") return e
    var t = "",
      r = []
    r.push("" + e.getUTCFullYear()),
      r.push("" + (e.getUTCMonth() + 1)),
      r.push("" + e.getUTCDate()),
      r.push("" + e.getUTCHours()),
      r.push("" + e.getUTCMinutes()),
      r.push("" + e.getUTCSeconds())
    for (var n = 0; n < r.length; ++n)
      r[n].length < 2 && (t += "0"), (t += r[n])
    return (t += "Z"), t
  }
  Me.integerToDer = function (e) {
    var t = Qn.util.createBuffer()
    if (e >= -128 && e < 128) return t.putSignedInt(e, 8)
    if (e >= -32768 && e < 32768) return t.putSignedInt(e, 16)
    if (e >= -8388608 && e < 8388608) return t.putSignedInt(e, 24)
    if (e >= -2147483648 && e < 2147483648) return t.putSignedInt(e, 32)
    var r = new Error("Integer too large; max is 32-bits.")
    throw ((r.integer = e), r)
  }
  Me.derToInteger = function (e) {
    typeof e == "string" && (e = Qn.util.createBuffer(e))
    var t = e.length() * 8
    if (t > 32) throw new Error("Integer too large; max is 32-bits.")
    return e.getSignedInt(t)
  }
  Me.validate = function (e, t, r, n) {
    var i = false
    if (
      (e.tagClass === t.tagClass || typeof t.tagClass > "u") &&
      (e.type === t.type || typeof t.type > "u")
    )
      if (e.constructed === t.constructed || typeof t.constructed > "u") {
        if (((i = true), t.value && Qn.util.isArray(t.value)))
          for (var s = 0, o = 0; i && o < t.value.length; ++o)
            (i = t.value[o].optional || false),
              e.value[s] &&
                ((i = Me.validate(e.value[s], t.value[o], r, n)),
                i ? ++s : t.value[o].optional && (i = true)),
              !i &&
                n &&
                n.push(
                  "[" +
                    t.name +
                    '] Tag class "' +
                    t.tagClass +
                    '", type "' +
                    t.type +
                    '" expected value length "' +
                    t.value.length +
                    '", got "' +
                    e.value.length +
                    '"',
                )
        if (
          i &&
          r &&
          (t.capture && (r[t.capture] = e.value),
          t.captureAsn1 && (r[t.captureAsn1] = e),
          t.captureBitStringContents &&
            "bitStringContents" in e &&
            (r[t.captureBitStringContents] = e.bitStringContents),
          t.captureBitStringValue && "bitStringContents" in e)
        ) {
          var a
          if (e.bitStringContents.length < 2) r[t.captureBitStringValue] = ""
          else {
            var l = e.bitStringContents.charCodeAt(0)
            if (l !== 0)
              throw new Error(
                "captureBitStringValue only supported for zero unused bits",
              )
            r[t.captureBitStringValue] = e.bitStringContents.slice(1)
          }
        }
      } else
        n &&
          n.push(
            "[" +
              t.name +
              '] Expected constructed "' +
              t.constructed +
              '", got "' +
              e.constructed +
              '"',
          )
    else
      n &&
        (e.tagClass !== t.tagClass &&
          n.push(
            "[" +
              t.name +
              '] Expected tag class "' +
              t.tagClass +
              '", got "' +
              e.tagClass +
              '"',
          ),
        e.type !== t.type &&
          n.push(
            "[" +
              t.name +
              '] Expected type "' +
              t.type +
              '", got "' +
              e.type +
              '"',
          ))
    return i
  }
  var tue = /[^\\u0000-\\u00ff]/
  Me.prettyPrint = function (e, t, r) {
    var n = ""
    ;(t = t || 0),
      (r = r || 2),
      t > 0 &&
        (n += `
`)
    for (var i = "", s = 0; s < t * r; ++s) i += " "
    switch (((n += i + "Tag: "), e.tagClass)) {
      case Me.Class.UNIVERSAL:
        n += "Universal:"
        break
      case Me.Class.APPLICATION:
        n += "Application:"
        break
      case Me.Class.CONTEXT_SPECIFIC:
        n += "Context-Specific:"
        break
      case Me.Class.PRIVATE:
        n += "Private:"
        break
    }
    if (e.tagClass === Me.Class.UNIVERSAL)
      switch (((n += e.type), e.type)) {
        case Me.Type.NONE:
          n += " (None)"
          break
        case Me.Type.BOOLEAN:
          n += " (Boolean)"
          break
        case Me.Type.INTEGER:
          n += " (Integer)"
          break
        case Me.Type.BITSTRING:
          n += " (Bit string)"
          break
        case Me.Type.OCTETSTRING:
          n += " (Octet string)"
          break
        case Me.Type.NULL:
          n += " (Null)"
          break
        case Me.Type.OID:
          n += " (Object Identifier)"
          break
        case Me.Type.ODESC:
          n += " (Object Descriptor)"
          break
        case Me.Type.EXTERNAL:
          n += " (External or Instance of)"
          break
        case Me.Type.REAL:
          n += " (Real)"
          break
        case Me.Type.ENUMERATED:
          n += " (Enumerated)"
          break
        case Me.Type.EMBEDDED:
          n += " (Embedded PDV)"
          break
        case Me.Type.UTF8:
          n += " (UTF8)"
          break
        case Me.Type.ROID:
          n += " (Relative Object Identifier)"
          break
        case Me.Type.SEQUENCE:
          n += " (Sequence)"
          break
        case Me.Type.SET:
          n += " (Set)"
          break
        case Me.Type.PRINTABLESTRING:
          n += " (Printable String)"
          break
        case Me.Type.IA5String:
          n += " (IA5String (ASCII))"
          break
        case Me.Type.UTCTIME:
          n += " (UTC time)"
          break
        case Me.Type.GENERALIZEDTIME:
          n += " (Generalized time)"
          break
        case Me.Type.BMPSTRING:
          n += " (BMP String)"
          break
      }
    else n += e.type
    if (
      ((n += `
`),
      (n +=
        i +
        "Constructed: " +
        e.constructed +
        `
`),
      e.composed)
    ) {
      for (var o = 0, a = "", s = 0; s < e.value.length; ++s)
        e.value[s] !== undefined &&
          ((o += 1),
          (a += Me.prettyPrint(e.value[s], t + 1, r)),
          s + 1 < e.value.length && (a += ","))
      n += i + "Sub values: " + o + a
    } else {
      if (((n += i + "Value: "), e.type === Me.Type.OID)) {
        var l = Me.derToOid(e.value)
        ;(n += l),
          Qn.pki &&
            Qn.pki.oids &&
            l in Qn.pki.oids &&
            (n += " (" + Qn.pki.oids[l] + ") ")
      }
      if (e.type === Me.Type.INTEGER)
        try {
          n += Me.derToInteger(e.value)
        } catch {
          n += "0x" + Qn.util.bytesToHex(e.value)
        }
      else if (e.type === Me.Type.BITSTRING) {
        if (
          (e.value.length > 1
            ? (n += "0x" + Qn.util.bytesToHex(e.value.slice(1)))
            : (n += "(none)"),
          e.value.length > 0)
        ) {
          var c = e.value.charCodeAt(0)
          c == 1
            ? (n += " (1 unused bit shown)")
            : c > 1 && (n += " (" + c + " unused bits shown)")
        }
      } else if (e.type === Me.Type.OCTETSTRING)
        tue.test(e.value) || (n += "(" + e.value + ") "),
          (n += "0x" + Qn.util.bytesToHex(e.value))
      else if (e.type === Me.Type.UTF8)
        try {
          n += Qn.util.decodeUtf8(e.value)
        } catch (u) {
          if (u.message === "URI malformed")
            n += "0x" + Qn.util.bytesToHex(e.value) + " (malformed UTF8)"
          else throw u
        }
      else
        e.type === Me.Type.PRINTABLESTRING || e.type === Me.Type.IA5String
          ? (n += e.value)
          : tue.test(e.value)
            ? (n += "0x" + Qn.util.bytesToHex(e.value))
            : e.value.length === 0
              ? (n += "[null]")
              : (n += e.value)
    }
    return n
  }
})
var Tu = _((rkt, nue) => {
  "use strict"
  var oT = jt()
  nue.exports = oT.md = oT.md || {}
  oT.md.algorithms = oT.md.algorithms || {}
})
var Ay = _((nkt, iue) => {
  "use strict"
  var jd = jt()
  Tu()
  Pr()
  var hXe = (iue.exports = jd.hmac = jd.hmac || {})
  hXe.create = function () {
    var e = null,
      t = null,
      r = null,
      n = null,
      i = {}
    return (
      (i.start = function (s, o) {
        if (s !== null)
          if (typeof s == "string")
            if (((s = s.toLowerCase()), s in jd.md.algorithms))
              t = jd.md.algorithms[s].create()
            else throw new Error('Unknown hash algorithm "' + s + '"')
          else t = s
        if (o === null) o = e
        else {
          if (typeof o == "string") o = jd.util.createBuffer(o)
          else if (jd.util.isArray(o)) {
            var a = o
            o = jd.util.createBuffer()
            for (var l = 0; l < a.length; ++l) o.putByte(a[l])
          }
          var c = o.length()
          c > t.blockLength &&
            (t.start(), t.update(o.bytes()), (o = t.digest())),
            (r = jd.util.createBuffer()),
            (n = jd.util.createBuffer()),
            (c = o.length())
          for (var l = 0; l < c; ++l) {
            var a = o.at(l)
            r.putByte(54 ^ a), n.putByte(92 ^ a)
          }
          if (c < t.blockLength)
            for (var a = t.blockLength - c, l = 0; l < a; ++l)
              r.putByte(54), n.putByte(92)
          ;(e = o), (r = r.bytes()), (n = n.bytes())
        }
        t.start(), t.update(r)
      }),
      (i.update = function (s) {
        t.update(s)
      }),
      (i.getMac = function () {
        var s = t.digest().bytes()
        return t.start(), t.update(n), t.update(s), t.digest()
      }),
      (i.digest = i.getMac),
      i
    )
  }
})
var lT = _((ikt, lue) => {
  "use strict"
  var ku = jt()
  Tu()
  Pr()
  var oue = (lue.exports = ku.md5 = ku.md5 || {})
  ku.md.md5 = ku.md.algorithms.md5 = oue
  oue.create = function () {
    aue || gXe()
    var e = null,
      t = ku.util.createBuffer(),
      r = new Array(16),
      n = {
        algorithm: "md5",
        blockLength: 64,
        digestLength: 16,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8,
      }
    return (
      (n.start = function () {
        ;(n.messageLength = 0), (n.fullMessageLength = n.messageLength64 = [])
        for (var i = n.messageLengthSize / 4, s = 0; s < i; ++s)
          n.fullMessageLength.push(0)
        return (
          (t = ku.util.createBuffer()),
          (e = {
            h0: 1732584193,
            h1: 4023233417,
            h2: 2562383102,
            h3: 271733878,
          }),
          n
        )
      }),
      n.start(),
      (n.update = function (i, s) {
        s === "utf8" && (i = ku.util.encodeUtf8(i))
        var o = i.length
        ;(n.messageLength += o), (o = [(o / 4294967296) >>> 0, o >>> 0])
        for (var a = n.fullMessageLength.length - 1; a >= 0; --a)
          (n.fullMessageLength[a] += o[1]),
            (o[1] = o[0] + ((n.fullMessageLength[a] / 4294967296) >>> 0)),
            (n.fullMessageLength[a] = n.fullMessageLength[a] >>> 0),
            (o[0] = (o[1] / 4294967296) >>> 0)
        return (
          t.putBytes(i),
          sue(e, r, t),
          (t.read > 2048 || t.length() === 0) && t.compact(),
          n
        )
      }),
      (n.digest = function () {
        var i = ku.util.createBuffer()
        i.putBytes(t.bytes())
        var s =
            n.fullMessageLength[n.fullMessageLength.length - 1] +
            n.messageLengthSize,
          o = s & (n.blockLength - 1)
        i.putBytes(MW.substr(0, n.blockLength - o))
        for (var a, l = 0, c = n.fullMessageLength.length - 1; c >= 0; --c)
          (a = n.fullMessageLength[c] * 8 + l),
            (l = (a / 4294967296) >>> 0),
            i.putInt32Le(a >>> 0)
        var u = { h0: e.h0, h1: e.h1, h2: e.h2, h3: e.h3 }
        sue(u, r, i)
        var f = ku.util.createBuffer()
        return (
          f.putInt32Le(u.h0),
          f.putInt32Le(u.h1),
          f.putInt32Le(u.h2),
          f.putInt32Le(u.h3),
          f
        )
      }),
      n
    )
  }
  var MW = null,
    aT = null,
    h_ = null,
    yy = null,
    aue = false
  function gXe() {
    ;(MW = "\x80"),
      (MW += ku.util.fillString("\0", 64)),
      (aT = [
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 6, 11, 0, 5,
        10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 5, 8, 11, 14, 1, 4, 7, 10, 13, 0,
        3, 6, 9, 12, 15, 2, 0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2,
        9,
      ]),
      (h_ = [
        7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14,
        20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16,
        23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10,
        15, 21, 6, 10, 15, 21,
      ]),
      (yy = new Array(64))
    for (var e = 0; e < 64; ++e)
      yy[e] = Math.floor(Math.abs(Math.sin(e + 1)) * 4294967296)
    aue = true
  }
  function sue(e, t, r) {
    for (var n, i, s, o, a, l, c, u, f = r.length(); f >= 64; ) {
      for (i = e.h0, s = e.h1, o = e.h2, a = e.h3, u = 0; u < 16; ++u)
        (t[u] = r.getInt32Le()),
          (l = a ^ (s & (o ^ a))),
          (n = i + l + yy[u] + t[u]),
          (c = h_[u]),
          (i = a),
          (a = o),
          (o = s),
          (s += (n << c) | (n >>> (32 - c)))
      for (; u < 32; ++u)
        (l = o ^ (a & (s ^ o))),
          (n = i + l + yy[u] + t[aT[u]]),
          (c = h_[u]),
          (i = a),
          (a = o),
          (o = s),
          (s += (n << c) | (n >>> (32 - c)))
      for (; u < 48; ++u)
        (l = s ^ o ^ a),
          (n = i + l + yy[u] + t[aT[u]]),
          (c = h_[u]),
          (i = a),
          (a = o),
          (o = s),
          (s += (n << c) | (n >>> (32 - c)))
      for (; u < 64; ++u)
        (l = o ^ (s | ~a)),
          (n = i + l + yy[u] + t[aT[u]]),
          (c = h_[u]),
          (i = a),
          (a = o),
          (o = s),
          (s += (n << c) | (n >>> (32 - c)))
      ;(e.h0 = (e.h0 + i) | 0),
        (e.h1 = (e.h1 + s) | 0),
        (e.h2 = (e.h2 + o) | 0),
        (e.h3 = (e.h3 + a) | 0),
        (f -= 64)
    }
  }
})
var Hp = _((skt, uue) => {
  "use strict"
  var uT = jt()
  Pr()
  var cue = (uue.exports = uT.pem = uT.pem || {})
  cue.encode = function (e, t) {
    t = t || {}
    var r =
        "-----BEGIN " +
        e.type +
        `-----\r
`,
      n
    if (
      (e.procType &&
        ((n = {
          name: "Proc-Type",
          values: [String(e.procType.version), e.procType.type],
        }),
        (r += cT(n))),
      e.contentDomain &&
        ((n = { name: "Content-Domain", values: [e.contentDomain] }),
        (r += cT(n))),
      e.dekInfo &&
        ((n = { name: "DEK-Info", values: [e.dekInfo.algorithm] }),
        e.dekInfo.parameters && n.values.push(e.dekInfo.parameters),
        (r += cT(n))),
      e.headers)
    )
      for (var i = 0; i < e.headers.length; ++i) r += cT(e.headers[i])
    return (
      e.procType &&
        (r += `\r
`),
      (r +=
        uT.util.encode64(e.body, t.maxline || 64) +
        `\r
`),
      (r +=
        "-----END " +
        e.type +
        `-----\r
`),
      r
    )
  }
  cue.decode = function (e) {
    for (
      var t = [],
        r =
          /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g,
        n = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/,
        i = /\r?\n/,
        s;
      (s = r.exec(e)), !!s;

    ) {
      var o = s[1]
      o === "NEW CERTIFICATE REQUEST" && (o = "CERTIFICATE REQUEST")
      var a = {
        type: o,
        procType: null,
        contentDomain: null,
        dekInfo: null,
        headers: [],
        body: uT.util.decode64(s[3]),
      }
      if ((t.push(a), !!s[2])) {
        for (var l = s[2].split(i), c = 0; s && c < l.length; ) {
          for (var u = l[c].replace(/\s+$/, ""), f = c + 1; f < l.length; ++f) {
            var p = l[f]
            if (!/\s/.test(p[0])) break
            ;(u += p), (c = f)
          }
          if (((s = u.match(n)), s)) {
            for (
              var g = { name: s[1], values: [] }, m = s[2].split(","), y = 0;
              y < m.length;
              ++y
            )
              g.values.push(pXe(m[y]))
            if (a.procType)
              if (!a.contentDomain && g.name === "Content-Domain")
                a.contentDomain = m[0] || ""
              else if (!a.dekInfo && g.name === "DEK-Info") {
                if (g.values.length === 0)
                  throw new Error(
                    'Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.',
                  )
                a.dekInfo = { algorithm: m[0], parameters: m[1] || null }
              } else a.headers.push(g)
            else {
              if (g.name !== "Proc-Type")
                throw new Error(
                  'Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".',
                )
              if (g.values.length !== 2)
                throw new Error(
                  'Invalid PEM formatted message. The "Proc-Type" header must have two subfields.',
                )
              a.procType = { version: m[0], type: m[1] }
            }
          }
          ++c
        }
        if (a.procType === "ENCRYPTED" && !a.dekInfo)
          throw new Error(
            'Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".',
          )
      }
    }
    if (t.length === 0) throw new Error("Invalid PEM formatted message.")
    return t
  }
  function cT(e) {
    for (
      var t = e.name + ": ",
        r = [],
        n = function (l, c) {
          return " " + c
        },
        i = 0;
      i < e.values.length;
      ++i
    )
      r.push(e.values[i].replace(/^(\S+\r\n)/, n))
    t +=
      r.join(",") +
      `\r
`
    for (var s = 0, o = -1, i = 0; i < t.length; ++i, ++s)
      if (s > 65 && o !== -1) {
        var a = t[o]
        a === ","
          ? (++o,
            (t =
              t.substr(0, o) +
              `\r
 ` +
              t.substr(o)))
          : (t =
              t.substr(0, o) +
              `\r
` +
              a +
              t.substr(o + 1)),
          (s = i - o - 1),
          (o = -1),
          ++i
      } else (t[i] === " " || t[i] === "	" || t[i] === ",") && (o = i)
    return t
  }
  function pXe(e) {
    return e.replace(/^\s+/, "")
  }
})
var g_ = _((okt, fue) => {
  "use strict"
  var Gn = jt()
  tT()
  BW()
  Pr()
  fue.exports = Gn.des = Gn.des || {}
  Gn.des.startEncrypting = function (e, t, r, n) {
    var i = dT({
      key: e,
      output: r,
      decrypt: false,
      mode: n || (t === null ? "ECB" : "CBC"),
    })
    return i.start(t), i
  }
  Gn.des.createEncryptionCipher = function (e, t) {
    return dT({ key: e, output: null, decrypt: false, mode: t })
  }
  Gn.des.startDecrypting = function (e, t, r, n) {
    var i = dT({
      key: e,
      output: r,
      decrypt: true,
      mode: n || (t === null ? "ECB" : "CBC"),
    })
    return i.start(t), i
  }
  Gn.des.createDecryptionCipher = function (e, t) {
    return dT({ key: e, output: null, decrypt: true, mode: t })
  }
  Gn.des.Algorithm = function (e, t) {
    var r = this
    ;(r.name = e),
      (r.mode = new t({
        blockSize: 8,
        cipher: {
          encrypt: function (n, i) {
            return due(r._keys, n, i, false)
          },
          decrypt: function (n, i) {
            return due(r._keys, n, i, true)
          },
        },
      })),
      (r._init = false)
  }
  Gn.des.Algorithm.prototype.initialize = function (e) {
    if (!this._init) {
      var t = Gn.util.createBuffer(e.key)
      if (this.name.indexOf("3DES") === 0 && t.length() !== 24)
        throw new Error("Invalid Triple-DES key size: " + t.length() * 8)
      ;(this._keys = xXe(t)), (this._init = true)
    }
  }
  Mu("DES-ECB", Gn.cipher.modes.ecb)
  Mu("DES-CBC", Gn.cipher.modes.cbc)
  Mu("DES-CFB", Gn.cipher.modes.cfb)
  Mu("DES-OFB", Gn.cipher.modes.ofb)
  Mu("DES-CTR", Gn.cipher.modes.ctr)
  Mu("3DES-ECB", Gn.cipher.modes.ecb)
  Mu("3DES-CBC", Gn.cipher.modes.cbc)
  Mu("3DES-CFB", Gn.cipher.modes.cfb)
  Mu("3DES-OFB", Gn.cipher.modes.ofb)
  Mu("3DES-CTR", Gn.cipher.modes.ctr)
  function Mu(e, t) {
    var r = function () {
      return new Gn.des.Algorithm(e, t)
    }
    Gn.cipher.registerAlgorithm(e, r)
  }
  var mXe = [
      16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776,
      16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240,
      66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220,
      65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776,
      16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4,
      16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028,
      66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756,
    ],
    AXe = [
      -2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040,
      -2147450848, -2147483616, -2146402272, -2146402304, -2147483648,
      -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0,
      -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0,
      1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040,
      1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072,
      -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800,
      -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616,
      1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040,
      -2146402272, 1081344,
    ],
    yXe = [
      520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080,
      134217736, 134217736, 131072, 134349320, 131080, 134348800, 520,
      134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592,
      134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728,
      134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512,
      131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248,
      131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800,
      134218248, 520, 134348800, 131592, 8, 134348808, 131584,
    ],
    vXe = [
      8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800,
      8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801,
      128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928,
      8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800,
      8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1,
      8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128,
      8388608, 8192, 8396928,
    ],
    CXe = [
      256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720,
      1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544,
      1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800,
      1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976,
      33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432,
      1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824,
      1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800,
      524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256,
      524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080,
    ],
    bXe = [
      536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304,
      536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912,
      16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232,
      541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912,
      536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928,
      4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688,
      541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216,
      4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320,
      536887312,
    ],
    EXe = [
      2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064,
      69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912,
      2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154,
      69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864,
      2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154,
      67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050,
      67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202,
      69206016, 2048, 67108866, 67110912, 2048, 2097154,
    ],
    _Xe = [
      268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456,
      262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64,
      268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664,
      268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144,
      266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552,
      64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0,
      268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0,
      268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696,
    ]
  function xXe(e) {
    for (
      var t = [
          0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512,
          516, 536871424, 536871428, 66048, 66052, 536936960, 536936964,
        ],
        r = [
          0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256,
          257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697,
        ],
        n = [
          0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048,
          2056, 16777216, 16777224, 16779264, 16779272,
        ],
        i = [
          0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072,
          131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992,
          136454144,
        ],
        s = [
          0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112,
          266256, 4096, 266240, 4112, 266256,
        ],
        o = [
          0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464,
          33555488, 33554432, 33555456, 33554464, 33555488,
        ],
        a = [
          0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0,
          268435456, 524288, 268959744, 2, 268435458, 524290, 268959746,
        ],
        l = [
          0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496,
          131072, 196608, 133120, 198656, 537001984, 537067520, 537004032,
          537069568,
        ],
        c = [
          0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576,
          33554432, 33816576, 33554434, 33816578, 33554434, 33816578,
        ],
        u = [
          0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024,
          268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488,
        ],
        f = [
          0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192,
          8224, 1056768, 1056800, 1056768, 1056800,
        ],
        p = [
          0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880,
          67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528,
          85983744,
        ],
        g = [
          0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112,
          16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128,
        ],
        m = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261],
        y = e.length() > 8 ? 3 : 1,
        v = [],
        C = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0],
        E = 0,
        w,
        B = 0;
      B < y;
      B++
    ) {
      var T = e.getInt32(),
        N = e.getInt32()
      ;(w = ((T >>> 4) ^ N) & 252645135),
        (N ^= w),
        (T ^= w << 4),
        (w = ((N >>> -16) ^ T) & 65535),
        (T ^= w),
        (N ^= w << -16),
        (w = ((T >>> 2) ^ N) & 858993459),
        (N ^= w),
        (T ^= w << 2),
        (w = ((N >>> -16) ^ T) & 65535),
        (T ^= w),
        (N ^= w << -16),
        (w = ((T >>> 1) ^ N) & 1431655765),
        (N ^= w),
        (T ^= w << 1),
        (w = ((N >>> 8) ^ T) & 16711935),
        (T ^= w),
        (N ^= w << 8),
        (w = ((T >>> 1) ^ N) & 1431655765),
        (N ^= w),
        (T ^= w << 1),
        (w = (T << 8) | ((N >>> 20) & 240)),
        (T =
          (N << 24) |
          ((N << 8) & 16711680) |
          ((N >>> 8) & 65280) |
          ((N >>> 24) & 240)),
        (N = w)
      for (var W = 0; W < C.length; ++W) {
        C[W]
          ? ((T = (T << 2) | (T >>> 26)), (N = (N << 2) | (N >>> 26)))
          : ((T = (T << 1) | (T >>> 27)), (N = (N << 1) | (N >>> 27))),
          (T &= -15),
          (N &= -15)
        var Z =
            t[T >>> 28] |
            r[(T >>> 24) & 15] |
            n[(T >>> 20) & 15] |
            i[(T >>> 16) & 15] |
            s[(T >>> 12) & 15] |
            o[(T >>> 8) & 15] |
            a[(T >>> 4) & 15],
          te =
            l[N >>> 28] |
            c[(N >>> 24) & 15] |
            u[(N >>> 20) & 15] |
            f[(N >>> 16) & 15] |
            p[(N >>> 12) & 15] |
            g[(N >>> 8) & 15] |
            m[(N >>> 4) & 15]
        ;(w = ((te >>> 16) ^ Z) & 65535),
          (v[E++] = Z ^ w),
          (v[E++] = te ^ (w << 16))
      }
    }
    return v
  }
  function due(e, t, r, n) {
    var i = e.length === 32 ? 3 : 9,
      s
    i === 3
      ? (s = n ? [30, -2, -2] : [0, 32, 2])
      : (s = n
          ? [94, 62, -2, 32, 64, 2, 30, -2, -2]
          : [0, 32, 2, 62, 30, -2, 64, 96, 2])
    var o,
      a = t[0],
      l = t[1]
    ;(o = ((a >>> 4) ^ l) & 252645135),
      (l ^= o),
      (a ^= o << 4),
      (o = ((a >>> 16) ^ l) & 65535),
      (l ^= o),
      (a ^= o << 16),
      (o = ((l >>> 2) ^ a) & 858993459),
      (a ^= o),
      (l ^= o << 2),
      (o = ((l >>> 8) ^ a) & 16711935),
      (a ^= o),
      (l ^= o << 8),
      (o = ((a >>> 1) ^ l) & 1431655765),
      (l ^= o),
      (a ^= o << 1),
      (a = (a << 1) | (a >>> 31)),
      (l = (l << 1) | (l >>> 31))
    for (var c = 0; c < i; c += 3) {
      for (var u = s[c + 1], f = s[c + 2], p = s[c]; p != u; p += f) {
        var g = l ^ e[p],
          m = ((l >>> 4) | (l << 28)) ^ e[p + 1]
        ;(o = a),
          (a = l),
          (l =
            o ^
            (AXe[(g >>> 24) & 63] |
              vXe[(g >>> 16) & 63] |
              bXe[(g >>> 8) & 63] |
              _Xe[g & 63] |
              mXe[(m >>> 24) & 63] |
              yXe[(m >>> 16) & 63] |
              CXe[(m >>> 8) & 63] |
              EXe[m & 63]))
      }
      ;(o = a), (a = l), (l = o)
    }
    ;(a = (a >>> 1) | (a << 31)),
      (l = (l >>> 1) | (l << 31)),
      (o = ((a >>> 1) ^ l) & 1431655765),
      (l ^= o),
      (a ^= o << 1),
      (o = ((l >>> 8) ^ a) & 16711935),
      (a ^= o),
      (l ^= o << 8),
      (o = ((l >>> 2) ^ a) & 858993459),
      (a ^= o),
      (l ^= o << 2),
      (o = ((a >>> 16) ^ l) & 65535),
      (l ^= o),
      (a ^= o << 16),
      (o = ((a >>> 4) ^ l) & 252645135),
      (l ^= o),
      (a ^= o << 4),
      (r[0] = a),
      (r[1] = l)
  }
  function dT(e) {
    e = e || {}
    var t = (e.mode || "CBC").toUpperCase(),
      r = "DES-" + t,
      n
    e.decrypt
      ? (n = Gn.cipher.createDecipher(r, e.key))
      : (n = Gn.cipher.createCipher(r, e.key))
    var i = n.start
    return (
      (n.start = function (s, o) {
        var a = null
        o instanceof Gn.util.ByteBuffer && ((a = o), (o = {})),
          (o = o || {}),
          (o.output = a),
          (o.iv = s),
          i.call(n, o)
      }),
      n
    )
  }
})
var fT = _((akt, hue) => {
  "use strict"
  var Co = jt()
  Ay()
  Tu()
  Pr()
  var wXe = (Co.pkcs5 = Co.pkcs5 || {}),
    Zd
  Co.util.isNodejs && !Co.options.usePureJavaScript && (Zd = require("crypto"))
  hue.exports =
    Co.pbkdf2 =
    wXe.pbkdf2 =
      function (e, t, r, n, i, s) {
        if (
          (typeof i == "function" && ((s = i), (i = null)),
          Co.util.isNodejs &&
            !Co.options.usePureJavaScript &&
            Zd.pbkdf2 &&
            (i === null || typeof i != "object") &&
            (Zd.pbkdf2Sync.length > 4 || !i || i === "sha1"))
        )
          return (
            typeof i != "string" && (i = "sha1"),
            (e = Buffer.from(e, "binary")),
            (t = Buffer.from(t, "binary")),
            s
              ? Zd.pbkdf2Sync.length === 4
                ? Zd.pbkdf2(e, t, r, n, function (w, B) {
                    if (w) return s(w)
                    s(null, B.toString("binary"))
                  })
                : Zd.pbkdf2(e, t, r, n, i, function (w, B) {
                    if (w) return s(w)
                    s(null, B.toString("binary"))
                  })
              : Zd.pbkdf2Sync.length === 4
                ? Zd.pbkdf2Sync(e, t, r, n).toString("binary")
                : Zd.pbkdf2Sync(e, t, r, n, i).toString("binary")
          )
        if (
          ((typeof i > "u" || i === null) && (i = "sha1"), typeof i == "string")
        ) {
          if (!(i in Co.md.algorithms))
            throw new Error("Unknown hash algorithm: " + i)
          i = Co.md[i].create()
        }
        var o = i.digestLength
        if (n > 4294967295 * o) {
          var a = new Error("Derived key is too long.")
          if (s) return s(a)
          throw a
        }
        var l = Math.ceil(n / o),
          c = n - (l - 1) * o,
          u = Co.hmac.create()
        u.start(i, e)
        var f = "",
          p,
          g,
          m
        if (!s) {
          for (var y = 1; y <= l; ++y) {
            u.start(null, null),
              u.update(t),
              u.update(Co.util.int32ToBytes(y)),
              (p = m = u.digest().getBytes())
            for (var v = 2; v <= r; ++v)
              u.start(null, null),
                u.update(m),
                (g = u.digest().getBytes()),
                (p = Co.util.xorBytes(p, g, o)),
                (m = g)
            f += y < l ? p : p.substr(0, c)
          }
          return f
        }
        var y = 1,
          v
        function C() {
          if (y > l) return s(null, f)
          u.start(null, null),
            u.update(t),
            u.update(Co.util.int32ToBytes(y)),
            (p = m = u.digest().getBytes()),
            (v = 2),
            E()
        }
        function E() {
          if (v <= r)
            return (
              u.start(null, null),
              u.update(m),
              (g = u.digest().getBytes()),
              (p = Co.util.xorBytes(p, g, o)),
              (m = g),
              ++v,
              Co.util.setImmediate(E)
            )
          ;(f += y < l ? p : p.substr(0, c)), ++y, C()
        }
        C()
      }
})
var QW = _((lkt, yue) => {
  "use strict"
  var Fu = jt()
  Tu()
  Pr()
  var pue = (yue.exports = Fu.sha256 = Fu.sha256 || {})
  Fu.md.sha256 = Fu.md.algorithms.sha256 = pue
  pue.create = function () {
    mue || SXe()
    var e = null,
      t = Fu.util.createBuffer(),
      r = new Array(64),
      n = {
        algorithm: "sha256",
        blockLength: 64,
        digestLength: 32,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8,
      }
    return (
      (n.start = function () {
        ;(n.messageLength = 0), (n.fullMessageLength = n.messageLength64 = [])
        for (var i = n.messageLengthSize / 4, s = 0; s < i; ++s)
          n.fullMessageLength.push(0)
        return (
          (t = Fu.util.createBuffer()),
          (e = {
            h0: 1779033703,
            h1: 3144134277,
            h2: 1013904242,
            h3: 2773480762,
            h4: 1359893119,
            h5: 2600822924,
            h6: 528734635,
            h7: 1541459225,
          }),
          n
        )
      }),
      n.start(),
      (n.update = function (i, s) {
        s === "utf8" && (i = Fu.util.encodeUtf8(i))
        var o = i.length
        ;(n.messageLength += o), (o = [(o / 4294967296) >>> 0, o >>> 0])
        for (var a = n.fullMessageLength.length - 1; a >= 0; --a)
          (n.fullMessageLength[a] += o[1]),
            (o[1] = o[0] + ((n.fullMessageLength[a] / 4294967296) >>> 0)),
            (n.fullMessageLength[a] = n.fullMessageLength[a] >>> 0),
            (o[0] = (o[1] / 4294967296) >>> 0)
        return (
          t.putBytes(i),
          gue(e, r, t),
          (t.read > 2048 || t.length() === 0) && t.compact(),
          n
        )
      }),
      (n.digest = function () {
        var i = Fu.util.createBuffer()
        i.putBytes(t.bytes())
        var s =
            n.fullMessageLength[n.fullMessageLength.length - 1] +
            n.messageLengthSize,
          o = s & (n.blockLength - 1)
        i.putBytes(FW.substr(0, n.blockLength - o))
        for (
          var a, l, c = n.fullMessageLength[0] * 8, u = 0;
          u < n.fullMessageLength.length - 1;
          ++u
        )
          (a = n.fullMessageLength[u + 1] * 8),
            (l = (a / 4294967296) >>> 0),
            (c += l),
            i.putInt32(c >>> 0),
            (c = a >>> 0)
        i.putInt32(c)
        var f = {
          h0: e.h0,
          h1: e.h1,
          h2: e.h2,
          h3: e.h3,
          h4: e.h4,
          h5: e.h5,
          h6: e.h6,
          h7: e.h7,
        }
        gue(f, r, i)
        var p = Fu.util.createBuffer()
        return (
          p.putInt32(f.h0),
          p.putInt32(f.h1),
          p.putInt32(f.h2),
          p.putInt32(f.h3),
          p.putInt32(f.h4),
          p.putInt32(f.h5),
          p.putInt32(f.h6),
          p.putInt32(f.h7),
          p
        )
      }),
      n
    )
  }
  var FW = null,
    mue = false,
    Aue = null
  function SXe() {
    ;(FW = "\x80"),
      (FW += Fu.util.fillString("\0", 64)),
      (Aue = [
        1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
        2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
        1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
        264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
        2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
        113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
        1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
        3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
        430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
        1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
        2428436474, 2756734187, 3204031479, 3329325298,
      ]),
      (mue = true)
  }
  function gue(e, t, r) {
    for (
      var n, i, s, o, a, l, c, u, f, p, g, m, y, v, C, E = r.length();
      E >= 64;

    ) {
      for (c = 0; c < 16; ++c) t[c] = r.getInt32()
      for (; c < 64; ++c)
        (n = t[c - 2]),
          (n =
            ((n >>> 17) | (n << 15)) ^ ((n >>> 19) | (n << 13)) ^ (n >>> 10)),
          (i = t[c - 15]),
          (i = ((i >>> 7) | (i << 25)) ^ ((i >>> 18) | (i << 14)) ^ (i >>> 3)),
          (t[c] = (n + t[c - 7] + i + t[c - 16]) | 0)
      for (
        u = e.h0,
          f = e.h1,
          p = e.h2,
          g = e.h3,
          m = e.h4,
          y = e.h5,
          v = e.h6,
          C = e.h7,
          c = 0;
        c < 64;
        ++c
      )
        (o =
          ((m >>> 6) | (m << 26)) ^
          ((m >>> 11) | (m << 21)) ^
          ((m >>> 25) | (m << 7))),
          (a = v ^ (m & (y ^ v))),
          (s =
            ((u >>> 2) | (u << 30)) ^
            ((u >>> 13) | (u << 19)) ^
            ((u >>> 22) | (u << 10))),
          (l = (u & f) | (p & (u ^ f))),
          (n = C + o + a + Aue[c] + t[c]),
          (i = s + l),
          (C = v),
          (v = y),
          (y = m),
          (m = (g + n) >>> 0),
          (g = p),
          (p = f),
          (f = u),
          (u = (n + i) >>> 0)
      ;(e.h0 = (e.h0 + u) | 0),
        (e.h1 = (e.h1 + f) | 0),
        (e.h2 = (e.h2 + p) | 0),
        (e.h3 = (e.h3 + g) | 0),
        (e.h4 = (e.h4 + m) | 0),
        (e.h5 = (e.h5 + y) | 0),
        (e.h6 = (e.h6 + v) | 0),
        (e.h7 = (e.h7 + C) | 0),
        (E -= 64)
    }
  }
})
var NW = _((ckt, vue) => {
  "use strict"
  var Qu = jt()
  Pr()
  var hT = null
  Qu.util.isNodejs &&
    !Qu.options.usePureJavaScript &&
    !process.versions["node-webkit"] &&
    (hT = require("crypto"))
  var IXe = (vue.exports = Qu.prng = Qu.prng || {})
  IXe.create = function (e) {
    for (
      var t = {
          plugin: e,
          key: null,
          seed: null,
          time: null,
          reseeds: 0,
          generated: 0,
          keyBytes: "",
        },
        r = e.md,
        n = new Array(32),
        i = 0;
      i < 32;
      ++i
    )
      n[i] = r.create()
    ;(t.pools = n),
      (t.pool = 0),
      (t.generate = function (c, u) {
        if (!u) return t.generateSync(c)
        var f = t.plugin.cipher,
          p = t.plugin.increment,
          g = t.plugin.formatKey,
          m = t.plugin.formatSeed,
          y = Qu.util.createBuffer()
        ;(t.key = null), v()
        function v(C) {
          if (C) return u(C)
          if (y.length() >= c) return u(null, y.getBytes(c))
          if ((t.generated > 1048575 && (t.key = null), t.key === null))
            return Qu.util.nextTick(function () {
              s(v)
            })
          var E = f(t.key, t.seed)
          ;(t.generated += E.length),
            y.putBytes(E),
            (t.key = g(f(t.key, p(t.seed)))),
            (t.seed = m(f(t.key, t.seed))),
            Qu.util.setImmediate(v)
        }
      }),
      (t.generateSync = function (c) {
        var u = t.plugin.cipher,
          f = t.plugin.increment,
          p = t.plugin.formatKey,
          g = t.plugin.formatSeed
        t.key = null
        for (var m = Qu.util.createBuffer(); m.length() < c; ) {
          t.generated > 1048575 && (t.key = null), t.key === null && o()
          var y = u(t.key, t.seed)
          ;(t.generated += y.length),
            m.putBytes(y),
            (t.key = p(u(t.key, f(t.seed)))),
            (t.seed = g(u(t.key, t.seed)))
        }
        return m.getBytes(c)
      })
    function s(c) {
      if (t.pools[0].messageLength >= 32) return a(), c()
      var u = (32 - t.pools[0].messageLength) << 5
      t.seedFile(u, function (f, p) {
        if (f) return c(f)
        t.collect(p), a(), c()
      })
    }
    function o() {
      if (t.pools[0].messageLength >= 32) return a()
      var c = (32 - t.pools[0].messageLength) << 5
      t.collect(t.seedFileSync(c)), a()
    }
    function a() {
      t.reseeds = t.reseeds === 4294967295 ? 0 : t.reseeds + 1
      var c = t.plugin.md.create()
      c.update(t.keyBytes)
      for (var u = 1, f = 0; f < 32; ++f)
        t.reseeds % u === 0 &&
          (c.update(t.pools[f].digest().getBytes()), t.pools[f].start()),
          (u = u << 1)
      ;(t.keyBytes = c.digest().getBytes()), c.start(), c.update(t.keyBytes)
      var p = c.digest().getBytes()
      ;(t.key = t.plugin.formatKey(t.keyBytes)),
        (t.seed = t.plugin.formatSeed(p)),
        (t.generated = 0)
    }
    function l(c) {
      var u = null,
        f = Qu.util.globalScope,
        p = f.crypto || f.msCrypto
      p &&
        p.getRandomValues &&
        (u = function (T) {
          return p.getRandomValues(T)
        })
      var g = Qu.util.createBuffer()
      if (u)
        for (; g.length() < c; ) {
          var m = Math.max(1, Math.min(c - g.length(), 65536) / 4),
            y = new Uint32Array(Math.floor(m))
          try {
            u(y)
            for (var v = 0; v < y.length; ++v) g.putInt32(y[v])
          } catch (T) {
            if (
              !(
                typeof QuotaExceededError < "u" &&
                T instanceof QuotaExceededError
              )
            )
              throw T
          }
        }
      if (g.length() < c)
        for (
          var C, E, w, B = Math.floor(Math.random() * 65536);
          g.length() < c;

        ) {
          ;(E = 16807 * (B & 65535)),
            (C = 16807 * (B >> 16)),
            (E += (C & 32767) << 16),
            (E += C >> 15),
            (E = (E & 2147483647) + (E >> 31)),
            (B = E & 4294967295)
          for (var v = 0; v < 3; ++v)
            (w = B >>> (v << 3)),
              (w ^= Math.floor(Math.random() * 256)),
              g.putByte(w & 255)
        }
      return g.getBytes(c)
    }
    return (
      hT
        ? ((t.seedFile = function (c, u) {
            hT.randomBytes(c, function (f, p) {
              if (f) return u(f)
              u(null, p.toString())
            })
          }),
          (t.seedFileSync = function (c) {
            return hT.randomBytes(c).toString()
          }))
        : ((t.seedFile = function (c, u) {
            try {
              u(null, l(c))
            } catch (f) {
              u(f)
            }
          }),
          (t.seedFileSync = l)),
      (t.collect = function (c) {
        for (var u = c.length, f = 0; f < u; ++f)
          t.pools[t.pool].update(c.substr(f, 1)),
            (t.pool = t.pool === 31 ? 0 : t.pool + 1)
      }),
      (t.collectInt = function (c, u) {
        for (var f = "", p = 0; p < u; p += 8)
          f += String.fromCharCode((c >> p) & 255)
        t.collect(f)
      }),
      (t.registerWorker = function (c) {
        if (c === self)
          t.seedFile = function (f, p) {
            function g(m) {
              var y = m.data
              y.forge &&
                y.forge.prng &&
                (self.removeEventListener("message", g),
                p(y.forge.prng.err, y.forge.prng.bytes))
            }
            self.addEventListener("message", g),
              self.postMessage({ forge: { prng: { needed: f } } })
          }
        else {
          var u = function (f) {
            var p = f.data
            p.forge &&
              p.forge.prng &&
              t.seedFile(p.forge.prng.needed, function (g, m) {
                c.postMessage({ forge: { prng: { err: g, bytes: m } } })
              })
          }
          c.addEventListener("message", u)
        }
      }),
      t
    )
  }
})
var Tl = _((ukt, PW) => {
  "use strict"
  var ss = jt()
  Rh()
  QW()
  NW()
  Pr()
  ;(function () {
    if (ss.random && ss.random.getBytes) {
      PW.exports = ss.random
      return
    }
    ;(function (e) {
      var t = {},
        r = new Array(4),
        n = ss.util.createBuffer()
      ;(t.formatKey = function (f) {
        var p = ss.util.createBuffer(f)
        return (
          (f = new Array(4)),
          (f[0] = p.getInt32()),
          (f[1] = p.getInt32()),
          (f[2] = p.getInt32()),
          (f[3] = p.getInt32()),
          ss.aes._expandKey(f, false)
        )
      }),
        (t.formatSeed = function (f) {
          var p = ss.util.createBuffer(f)
          return (
            (f = new Array(4)),
            (f[0] = p.getInt32()),
            (f[1] = p.getInt32()),
            (f[2] = p.getInt32()),
            (f[3] = p.getInt32()),
            f
          )
        }),
        (t.cipher = function (f, p) {
          return (
            ss.aes._updateBlock(f, p, r, false),
            n.putInt32(r[0]),
            n.putInt32(r[1]),
            n.putInt32(r[2]),
            n.putInt32(r[3]),
            n.getBytes()
          )
        }),
        (t.increment = function (f) {
          return ++f[3], f
        }),
        (t.md = ss.md.sha256)
      function i() {
        var f = ss.prng.create(t)
        return (
          (f.getBytes = function (p, g) {
            return f.generate(p, g)
          }),
          (f.getBytesSync = function (p) {
            return f.generate(p)
          }),
          f
        )
      }
      var s = i(),
        o = null,
        a = ss.util.globalScope,
        l = a.crypto || a.msCrypto
      if (
        (l &&
          l.getRandomValues &&
          (o = function (f) {
            return l.getRandomValues(f)
          }),
        ss.options.usePureJavaScript || (!ss.util.isNodejs && !o))
      ) {
        if (
          (typeof window > "u" || window.document,
          s.collectInt(+new Date(), 32),
          typeof navigator < "u")
        ) {
          var c = ""
          for (var u in navigator)
            try {
              typeof navigator[u] == "string" && (c += navigator[u])
            } catch {}
          s.collect(c), (c = null)
        }
        e &&
          (e().mousemove(function (f) {
            s.collectInt(f.clientX, 16), s.collectInt(f.clientY, 16)
          }),
          e().keypress(function (f) {
            s.collectInt(f.charCode, 8)
          }))
      }
      if (!ss.random) ss.random = s
      else for (var u in s) ss.random[u] = s[u]
      ;(ss.random.createInstance = i), (PW.exports = ss.random)
    })(typeof jQuery < "u" ? jQuery : null)
  })()
})
var UW = _((dkt, Eue) => {
  "use strict"
  var ta = jt()
  Pr()
  var LW = [
      217, 120, 249, 196, 25, 221, 181, 237, 40, 233, 253, 121, 74, 160, 216,
      157, 198, 126, 55, 131, 43, 118, 83, 142, 98, 76, 100, 136, 68, 139, 251,
      162, 23, 154, 89, 245, 135, 179, 79, 19, 97, 69, 109, 141, 9, 129, 125,
      50, 189, 143, 64, 235, 134, 183, 123, 11, 240, 149, 33, 34, 92, 107, 78,
      130, 84, 214, 101, 147, 206, 96, 178, 28, 115, 86, 192, 20, 167, 140, 241,
      220, 18, 117, 202, 31, 59, 190, 228, 209, 66, 61, 212, 48, 163, 60, 182,
      38, 111, 191, 14, 218, 70, 105, 7, 87, 39, 242, 29, 155, 188, 148, 67, 3,
      248, 17, 199, 246, 144, 239, 62, 231, 6, 195, 213, 47, 200, 102, 30, 215,
      8, 232, 234, 222, 128, 82, 238, 247, 132, 170, 114, 172, 53, 77, 106, 42,
      150, 26, 210, 113, 90, 21, 73, 116, 75, 159, 208, 94, 4, 24, 164, 236,
      194, 224, 65, 110, 15, 81, 203, 204, 36, 145, 175, 80, 161, 244, 112, 57,
      153, 124, 58, 133, 35, 184, 180, 122, 252, 2, 54, 91, 37, 85, 151, 49, 45,
      93, 250, 152, 227, 138, 146, 174, 5, 223, 41, 16, 103, 108, 186, 201, 211,
      0, 230, 207, 225, 158, 168, 44, 99, 22, 1, 63, 88, 226, 137, 169, 13, 56,
      52, 27, 171, 51, 255, 176, 187, 72, 12, 95, 185, 177, 205, 46, 197, 243,
      219, 71, 229, 165, 156, 119, 10, 166, 32, 104, 254, 127, 193, 173,
    ],
    Cue = [1, 2, 3, 5],
    BXe = function (e, t) {
      return ((e << t) & 65535) | ((e & 65535) >> (16 - t))
    },
    RXe = function (e, t) {
      return ((e & 65535) >> t) | ((e << (16 - t)) & 65535)
    }
  Eue.exports = ta.rc2 = ta.rc2 || {}
  ta.rc2.expandKey = function (e, t) {
    typeof e == "string" && (e = ta.util.createBuffer(e)), (t = t || 128)
    var r = e,
      n = e.length(),
      i = t,
      s = Math.ceil(i / 8),
      o = 255 >> (i & 7),
      a
    for (a = n; a < 128; a++) r.putByte(LW[(r.at(a - 1) + r.at(a - n)) & 255])
    for (r.setAt(128 - s, LW[r.at(128 - s) & o]), a = 127 - s; a >= 0; a--)
      r.setAt(a, LW[r.at(a + 1) ^ r.at(a + s)])
    return r
  }
  var bue = function (e, t, r) {
    var n = false,
      i = null,
      s = null,
      o = null,
      a,
      l,
      c,
      u,
      f = []
    for (e = ta.rc2.expandKey(e, t), c = 0; c < 64; c++) f.push(e.getInt16Le())
    r
      ? ((a = function (m) {
          for (c = 0; c < 4; c++)
            (m[c] +=
              f[u] +
              (m[(c + 3) % 4] & m[(c + 2) % 4]) +
              (~m[(c + 3) % 4] & m[(c + 1) % 4])),
              (m[c] = BXe(m[c], Cue[c])),
              u++
        }),
        (l = function (m) {
          for (c = 0; c < 4; c++) m[c] += f[m[(c + 3) % 4] & 63]
        }))
      : ((a = function (m) {
          for (c = 3; c >= 0; c--)
            (m[c] = RXe(m[c], Cue[c])),
              (m[c] -=
                f[u] +
                (m[(c + 3) % 4] & m[(c + 2) % 4]) +
                (~m[(c + 3) % 4] & m[(c + 1) % 4])),
              u--
        }),
        (l = function (m) {
          for (c = 3; c >= 0; c--) m[c] -= f[m[(c + 3) % 4] & 63]
        }))
    var p = function (m) {
        var y = []
        for (c = 0; c < 4; c++) {
          var v = i.getInt16Le()
          o !== null && (r ? (v ^= o.getInt16Le()) : o.putInt16Le(v)),
            y.push(v & 65535)
        }
        u = r ? 0 : 63
        for (var C = 0; C < m.length; C++)
          for (var E = 0; E < m[C][0]; E++) m[C][1](y)
        for (c = 0; c < 4; c++)
          o !== null && (r ? o.putInt16Le(y[c]) : (y[c] ^= o.getInt16Le())),
            s.putInt16Le(y[c])
      },
      g = null
    return (
      (g = {
        start: function (m, y) {
          m && typeof m == "string" && (m = ta.util.createBuffer(m)),
            (n = false),
            (i = ta.util.createBuffer()),
            (s = y || new ta.util.createBuffer()),
            (o = m),
            (g.output = s)
        },
        update: function (m) {
          for (n || i.putBuffer(m); i.length() >= 8; )
            p([
              [5, a],
              [1, l],
              [6, a],
              [1, l],
              [5, a],
            ])
        },
        finish: function (m) {
          var y = true
          if (r)
            if (m) y = m(8, i, !r)
            else {
              var v = i.length() === 8 ? 8 : 8 - i.length()
              i.fillWithByte(v, v)
            }
          if ((y && ((n = true), g.update()), !r && ((y = i.length() === 0), y)))
            if (m) y = m(8, s, !r)
            else {
              var C = s.length(),
                E = s.at(C - 1)
              E > C ? (y = false) : s.truncate(E)
            }
          return y
        },
      }),
      g
    )
  }
  ta.rc2.startEncrypting = function (e, t, r) {
    var n = ta.rc2.createEncryptionCipher(e, 128)
    return n.start(t, r), n
  }
  ta.rc2.createEncryptionCipher = function (e, t) {
    return bue(e, t, true)
  }
  ta.rc2.startDecrypting = function (e, t, r) {
    var n = ta.rc2.createDecryptionCipher(e, 128)
    return n.start(t, r), n
  }
  ta.rc2.createDecryptionCipher = function (e, t) {
    return bue(e, t, false)
  }
})
var m_ = _((fkt, Due) => {
  "use strict"
  var OW = jt()
  Due.exports = OW.jsbn = OW.jsbn || {}
  var Xd,
    DXe = 0xdeadbeefcafe,
    _ue = (DXe & 16777215) == 15715070
  function pe(e, t, r) {
    ;(this.data = []),
      e != null &&
        (typeof e == "number"
          ? this.fromNumber(e, t, r)
          : t == null && typeof e != "string"
            ? this.fromString(e, 256)
            : this.fromString(e, t))
  }
  OW.jsbn.BigInteger = pe
  function Lr() {
    return new pe(null)
  }
  function TXe(e, t, r, n, i, s) {
    for (; --s >= 0; ) {
      var o = t * this.data[e++] + r.data[n] + i
      ;(i = Math.floor(o / 67108864)), (r.data[n++] = o & 67108863)
    }
    return i
  }
  function kXe(e, t, r, n, i, s) {
    for (var o = t & 32767, a = t >> 15; --s >= 0; ) {
      var l = this.data[e] & 32767,
        c = this.data[e++] >> 15,
        u = a * l + c * o
      ;(l = o * l + ((u & 32767) << 15) + r.data[n] + (i & 1073741823)),
        (i = (l >>> 30) + (u >>> 15) + a * c + (i >>> 30)),
        (r.data[n++] = l & 1073741823)
    }
    return i
  }
  function xue(e, t, r, n, i, s) {
    for (var o = t & 16383, a = t >> 14; --s >= 0; ) {
      var l = this.data[e] & 16383,
        c = this.data[e++] >> 14,
        u = a * l + c * o
      ;(l = o * l + ((u & 16383) << 14) + r.data[n] + i),
        (i = (l >> 28) + (u >> 14) + a * c),
        (r.data[n++] = l & 268435455)
    }
    return i
  }
  typeof navigator > "u"
    ? ((pe.prototype.am = xue), (Xd = 28))
    : _ue && navigator.appName == "Microsoft Internet Explorer"
      ? ((pe.prototype.am = kXe), (Xd = 30))
      : _ue && navigator.appName != "Netscape"
        ? ((pe.prototype.am = TXe), (Xd = 26))
        : ((pe.prototype.am = xue), (Xd = 28))
  pe.prototype.DB = Xd
  pe.prototype.DM = (1 << Xd) - 1
  pe.prototype.DV = 1 << Xd
  var qW = 52
  pe.prototype.FV = Math.pow(2, qW)
  pe.prototype.F1 = qW - Xd
  pe.prototype.F2 = 2 * Xd - qW
  var MXe = "0123456789abcdefghijklmnopqrstuvwxyz",
    gT = new Array(),
    vy,
    kl
  vy = 48
  for (kl = 0; kl <= 9; ++kl) gT[vy++] = kl
  vy = 97
  for (kl = 10; kl < 36; ++kl) gT[vy++] = kl
  vy = 65
  for (kl = 10; kl < 36; ++kl) gT[vy++] = kl
  function wue(e) {
    return MXe.charAt(e)
  }
  function Sue(e, t) {
    var r = gT[e.charCodeAt(t)]
    return r ?? -1
  }
  function FXe(e) {
    for (var t = this.t - 1; t >= 0; --t) e.data[t] = this.data[t]
    ;(e.t = this.t), (e.s = this.s)
  }
  function QXe(e) {
    ;(this.t = 1),
      (this.s = e < 0 ? -1 : 0),
      e > 0
        ? (this.data[0] = e)
        : e < -1
          ? (this.data[0] = e + this.DV)
          : (this.t = 0)
  }
  function Th(e) {
    var t = Lr()
    return t.fromInt(e), t
  }
  function NXe(e, t) {
    var r
    if (t == 16) r = 4
    else if (t == 8) r = 3
    else if (t == 256) r = 8
    else if (t == 2) r = 1
    else if (t == 32) r = 5
    else if (t == 4) r = 2
    else {
      this.fromRadix(e, t)
      return
    }
    ;(this.t = 0), (this.s = 0)
    for (var n = e.length, i = false, s = 0; --n >= 0; ) {
      var o = r == 8 ? e[n] & 255 : Sue(e, n)
      if (o < 0) {
        e.charAt(n) == "-" && (i = true)
        continue
      }
      ;(i = false),
        s == 0
          ? (this.data[this.t++] = o)
          : s + r > this.DB
            ? ((this.data[this.t - 1] |= (o & ((1 << (this.DB - s)) - 1)) << s),
              (this.data[this.t++] = o >> (this.DB - s)))
            : (this.data[this.t - 1] |= o << s),
        (s += r),
        s >= this.DB && (s -= this.DB)
    }
    r == 8 &&
      e[0] & 128 &&
      ((this.s = -1),
      s > 0 && (this.data[this.t - 1] |= ((1 << (this.DB - s)) - 1) << s)),
      this.clamp(),
      i && pe.ZERO.subTo(this, this)
  }
  function PXe() {
    for (var e = this.s & this.DM; this.t > 0 && this.data[this.t - 1] == e; )
      --this.t
  }
  function LXe(e) {
    if (this.s < 0) return "-" + this.negate().toString(e)
    var t
    if (e == 16) t = 4
    else if (e == 8) t = 3
    else if (e == 2) t = 1
    else if (e == 32) t = 5
    else if (e == 4) t = 2
    else return this.toRadix(e)
    var r = (1 << t) - 1,
      n,
      i = false,
      s = "",
      o = this.t,
      a = this.DB - ((o * this.DB) % t)
    if (o-- > 0)
      for (
        a < this.DB && (n = this.data[o] >> a) > 0 && ((i = true), (s = wue(n)));
        o >= 0;

      )
        a < t
          ? ((n = (this.data[o] & ((1 << a) - 1)) << (t - a)),
            (n |= this.data[--o] >> (a += this.DB - t)))
          : ((n = (this.data[o] >> (a -= t)) & r),
            a <= 0 && ((a += this.DB), --o)),
          n > 0 && (i = true),
          i && (s += wue(n))
    return i ? s : "0"
  }
  function UXe() {
    var e = Lr()
    return pe.ZERO.subTo(this, e), e
  }
  function OXe() {
    return this.s < 0 ? this.negate() : this
  }
  function qXe(e) {
    var t = this.s - e.s
    if (t != 0) return t
    var r = this.t
    if (((t = r - e.t), t != 0)) return this.s < 0 ? -t : t
    for (; --r >= 0; ) if ((t = this.data[r] - e.data[r]) != 0) return t
    return 0
  }
  function pT(e) {
    var t = 1,
      r
    return (
      (r = e >>> 16) != 0 && ((e = r), (t += 16)),
      (r = e >> 8) != 0 && ((e = r), (t += 8)),
      (r = e >> 4) != 0 && ((e = r), (t += 4)),
      (r = e >> 2) != 0 && ((e = r), (t += 2)),
      (r = e >> 1) != 0 && ((e = r), (t += 1)),
      t
    )
  }
  function VXe() {
    return this.t <= 0
      ? 0
      : this.DB * (this.t - 1) + pT(this.data[this.t - 1] ^ (this.s & this.DM))
  }
  function HXe(e, t) {
    var r
    for (r = this.t - 1; r >= 0; --r) t.data[r + e] = this.data[r]
    for (r = e - 1; r >= 0; --r) t.data[r] = 0
    ;(t.t = this.t + e), (t.s = this.s)
  }
  function WXe(e, t) {
    for (var r = e; r < this.t; ++r) t.data[r - e] = this.data[r]
    ;(t.t = Math.max(this.t - e, 0)), (t.s = this.s)
  }
  function GXe(e, t) {
    var r = e % this.DB,
      n = this.DB - r,
      i = (1 << n) - 1,
      s = Math.floor(e / this.DB),
      o = (this.s << r) & this.DM,
      a
    for (a = this.t - 1; a >= 0; --a)
      (t.data[a + s + 1] = (this.data[a] >> n) | o),
        (o = (this.data[a] & i) << r)
    for (a = s - 1; a >= 0; --a) t.data[a] = 0
    ;(t.data[s] = o), (t.t = this.t + s + 1), (t.s = this.s), t.clamp()
  }
  function $Xe(e, t) {
    t.s = this.s
    var r = Math.floor(e / this.DB)
    if (r >= this.t) {
      t.t = 0
      return
    }
    var n = e % this.DB,
      i = this.DB - n,
      s = (1 << n) - 1
    t.data[0] = this.data[r] >> n
    for (var o = r + 1; o < this.t; ++o)
      (t.data[o - r - 1] |= (this.data[o] & s) << i),
        (t.data[o - r] = this.data[o] >> n)
    n > 0 && (t.data[this.t - r - 1] |= (this.s & s) << i),
      (t.t = this.t - r),
      t.clamp()
  }
  function YXe(e, t) {
    for (var r = 0, n = 0, i = Math.min(e.t, this.t); r < i; )
      (n += this.data[r] - e.data[r]),
        (t.data[r++] = n & this.DM),
        (n >>= this.DB)
    if (e.t < this.t) {
      for (n -= e.s; r < this.t; )
        (n += this.data[r]), (t.data[r++] = n & this.DM), (n >>= this.DB)
      n += this.s
    } else {
      for (n += this.s; r < e.t; )
        (n -= e.data[r]), (t.data[r++] = n & this.DM), (n >>= this.DB)
      n -= e.s
    }
    ;(t.s = n < 0 ? -1 : 0),
      n < -1 ? (t.data[r++] = this.DV + n) : n > 0 && (t.data[r++] = n),
      (t.t = r),
      t.clamp()
  }
  function KXe(e, t) {
    var r = this.abs(),
      n = e.abs(),
      i = r.t
    for (t.t = i + n.t; --i >= 0; ) t.data[i] = 0
    for (i = 0; i < n.t; ++i) t.data[i + r.t] = r.am(0, n.data[i], t, i, 0, r.t)
    ;(t.s = 0), t.clamp(), this.s != e.s && pe.ZERO.subTo(t, t)
  }
  function zXe(e) {
    for (var t = this.abs(), r = (e.t = 2 * t.t); --r >= 0; ) e.data[r] = 0
    for (r = 0; r < t.t - 1; ++r) {
      var n = t.am(r, t.data[r], e, 2 * r, 0, 1)
      ;(e.data[r + t.t] += t.am(
        r + 1,
        2 * t.data[r],
        e,
        2 * r + 1,
        n,
        t.t - r - 1,
      )) >= t.DV && ((e.data[r + t.t] -= t.DV), (e.data[r + t.t + 1] = 1))
    }
    e.t > 0 && (e.data[e.t - 1] += t.am(r, t.data[r], e, 2 * r, 0, 1)),
      (e.s = 0),
      e.clamp()
  }
  function JXe(e, t, r) {
    var n = e.abs()
    if (!(n.t <= 0)) {
      var i = this.abs()
      if (i.t < n.t) {
        t?.fromInt(0), r != null && this.copyTo(r)
        return
      }
      r == null && (r = Lr())
      var s = Lr(),
        o = this.s,
        a = e.s,
        l = this.DB - pT(n.data[n.t - 1])
      l > 0 ? (n.lShiftTo(l, s), i.lShiftTo(l, r)) : (n.copyTo(s), i.copyTo(r))
      var c = s.t,
        u = s.data[c - 1]
      if (u != 0) {
        var f = u * (1 << this.F1) + (c > 1 ? s.data[c - 2] >> this.F2 : 0),
          p = this.FV / f,
          g = (1 << this.F1) / f,
          m = 1 << this.F2,
          y = r.t,
          v = y - c,
          C = t ?? Lr()
        for (
          s.dlShiftTo(v, C),
            r.compareTo(C) >= 0 && ((r.data[r.t++] = 1), r.subTo(C, r)),
            pe.ONE.dlShiftTo(c, C),
            C.subTo(s, s);
          s.t < c;

        )
          s.data[s.t++] = 0
        for (; --v >= 0; ) {
          var E =
            r.data[--y] == u
              ? this.DM
              : Math.floor(r.data[y] * p + (r.data[y - 1] + m) * g)
          if ((r.data[y] += s.am(0, E, r, v, 0, c)) < E)
            for (s.dlShiftTo(v, C), r.subTo(C, r); r.data[y] < --E; )
              r.subTo(C, r)
        }
        t != null && (r.drShiftTo(c, t), o != a && pe.ZERO.subTo(t, t)),
          (r.t = c),
          r.clamp(),
          l > 0 && r.rShiftTo(l, r),
          o < 0 && pe.ZERO.subTo(r, r)
      }
    }
  }
  function jXe(e) {
    var t = Lr()
    return (
      this.abs().divRemTo(e, null, t),
      this.s < 0 && t.compareTo(pe.ZERO) > 0 && e.subTo(t, t),
      t
    )
  }
  function Wp(e) {
    this.m = e
  }
  function ZXe(e) {
    return e.s < 0 || e.compareTo(this.m) >= 0 ? e.mod(this.m) : e
  }
  function XXe(e) {
    return e
  }
  function eet(e) {
    e.divRemTo(this.m, null, e)
  }
  function tet(e, t, r) {
    e.multiplyTo(t, r), this.reduce(r)
  }
  function ret(e, t) {
    e.squareTo(t), this.reduce(t)
  }
  Wp.prototype.convert = ZXe
  Wp.prototype.revert = XXe
  Wp.prototype.reduce = eet
  Wp.prototype.mulTo = tet
  Wp.prototype.sqrTo = ret
  function net() {
    if (this.t < 1) return 0
    var e = this.data[0]
    if (!(e & 1)) return 0
    var t = e & 3
    return (
      (t = (t * (2 - (e & 15) * t)) & 15),
      (t = (t * (2 - (e & 255) * t)) & 255),
      (t = (t * (2 - (((e & 65535) * t) & 65535))) & 65535),
      (t = (t * (2 - ((e * t) % this.DV))) % this.DV),
      t > 0 ? this.DV - t : -t
    )
  }
  function Gp(e) {
    ;(this.m = e),
      (this.mp = e.invDigit()),
      (this.mpl = this.mp & 32767),
      (this.mph = this.mp >> 15),
      (this.um = (1 << (e.DB - 15)) - 1),
      (this.mt2 = 2 * e.t)
  }
  function iet(e) {
    var t = Lr()
    return (
      e.abs().dlShiftTo(this.m.t, t),
      t.divRemTo(this.m, null, t),
      e.s < 0 && t.compareTo(pe.ZERO) > 0 && this.m.subTo(t, t),
      t
    )
  }
  function set(e) {
    var t = Lr()
    return e.copyTo(t), this.reduce(t), t
  }
  function oet(e) {
    for (; e.t <= this.mt2; ) e.data[e.t++] = 0
    for (var t = 0; t < this.m.t; ++t) {
      var r = e.data[t] & 32767,
        n =
          (r * this.mpl +
            (((r * this.mph + (e.data[t] >> 15) * this.mpl) & this.um) << 15)) &
          e.DM
      for (
        r = t + this.m.t, e.data[r] += this.m.am(0, n, e, t, 0, this.m.t);
        e.data[r] >= e.DV;

      )
        (e.data[r] -= e.DV), e.data[++r]++
    }
    e.clamp(),
      e.drShiftTo(this.m.t, e),
      e.compareTo(this.m) >= 0 && e.subTo(this.m, e)
  }
  function aet(e, t) {
    e.squareTo(t), this.reduce(t)
  }
  function cet(e, t, r) {
    e.multiplyTo(t, r), this.reduce(r)
  }
  Gp.prototype.convert = iet
  Gp.prototype.revert = set
  Gp.prototype.reduce = oet
  Gp.prototype.mulTo = cet
  Gp.prototype.sqrTo = aet
  function uet() {
    return (this.t > 0 ? this.data[0] & 1 : this.s) == 0
  }
  function det(e, t) {
    if (e > 4294967295 || e < 1) return pe.ONE
    var r = Lr(),
      n = Lr(),
      i = t.convert(this),
      s = pT(e) - 1
    for (i.copyTo(r); --s >= 0; )
      if ((t.sqrTo(r, n), (e & (1 << s)) > 0)) t.mulTo(n, i, r)
      else {
        var o = r
        ;(r = n), (n = o)
      }
    return t.revert(r)
  }
  function fet(e, t) {
    var r
    return (
      e < 256 || t.isEven() ? (r = new Wp(t)) : (r = new Gp(t)), this.exp(e, r)
    )
  }
  pe.prototype.copyTo = FXe
  pe.prototype.fromInt = QXe
  pe.prototype.fromString = NXe
  pe.prototype.clamp = PXe
  pe.prototype.dlShiftTo = HXe
  pe.prototype.drShiftTo = WXe
  pe.prototype.lShiftTo = GXe
  pe.prototype.rShiftTo = $Xe
  pe.prototype.subTo = YXe
  pe.prototype.multiplyTo = KXe
  pe.prototype.squareTo = zXe
  pe.prototype.divRemTo = JXe
  pe.prototype.invDigit = net
  pe.prototype.isEven = uet
  pe.prototype.exp = det
  pe.prototype.toString = LXe
  pe.prototype.negate = UXe
  pe.prototype.abs = OXe
  pe.prototype.compareTo = qXe
  pe.prototype.bitLength = VXe
  pe.prototype.mod = jXe
  pe.prototype.modPowInt = fet
  pe.ZERO = Th(0)
  pe.ONE = Th(1)
  function het() {
    var e = Lr()
    return this.copyTo(e), e
  }
  function get() {
    if (this.s < 0) {
      if (this.t == 1) return this.data[0] - this.DV
      if (this.t == 0) return -1
    } else {
      if (this.t == 1) return this.data[0]
      if (this.t == 0) return 0
    }
    return (
      ((this.data[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this.data[0]
    )
  }
  function pet() {
    return this.t == 0 ? this.s : (this.data[0] << 24) >> 24
  }
  function met() {
    return this.t == 0 ? this.s : (this.data[0] << 16) >> 16
  }
  function Aet(e) {
    return Math.floor((Math.LN2 * this.DB) / Math.log(e))
  }
  function yet() {
    return this.s < 0
      ? -1
      : this.t <= 0 || (this.t == 1 && this.data[0] <= 0)
        ? 0
        : 1
  }
  function vet(e) {
    if ((e == null && (e = 10), this.signum() == 0 || e < 2 || e > 36))
      return "0"
    var t = this.chunkSize(e),
      r = Math.pow(e, t),
      n = Th(r),
      i = Lr(),
      s = Lr(),
      o = ""
    for (this.divRemTo(n, i, s); i.signum() > 0; )
      (o = (r + s.intValue()).toString(e).substr(1) + o), i.divRemTo(n, i, s)
    return s.intValue().toString(e) + o
  }
  function Cet(e, t) {
    this.fromInt(0), t == null && (t = 10)
    for (
      var r = this.chunkSize(t),
        n = Math.pow(t, r),
        i = false,
        s = 0,
        o = 0,
        a = 0;
      a < e.length;
      ++a
    ) {
      var l = Sue(e, a)
      if (l < 0) {
        e.charAt(a) == "-" && this.signum() == 0 && (i = true)
        continue
      }
      ;(o = t * o + l),
        ++s >= r && (this.dMultiply(n), this.dAddOffset(o, 0), (s = 0), (o = 0))
    }
    s > 0 && (this.dMultiply(Math.pow(t, s)), this.dAddOffset(o, 0)),
      i && pe.ZERO.subTo(this, this)
  }
  function bet(e, t, r) {
    if (typeof t == "number")
      if (e < 2) this.fromInt(1)
      else
        for (
          this.fromNumber(e, r),
            this.testBit(e - 1) ||
              this.bitwiseTo(pe.ONE.shiftLeft(e - 1), VW, this),
            this.isEven() && this.dAddOffset(1, 0);
          !this.isProbablePrime(t);

        )
          this.dAddOffset(2, 0),
            this.bitLength() > e && this.subTo(pe.ONE.shiftLeft(e - 1), this)
    else {
      var n = new Array(),
        i = e & 7
      ;(n.length = (e >> 3) + 1),
        t.nextBytes(n),
        i > 0 ? (n[0] &= (1 << i) - 1) : (n[0] = 0),
        this.fromString(n, 256)
    }
  }
  function Eet() {
    var e = this.t,
      t = new Array()
    t[0] = this.s
    var r = this.DB - ((e * this.DB) % 8),
      n,
      i = 0
    if (e-- > 0)
      for (
        r < this.DB &&
        (n = this.data[e] >> r) != (this.s & this.DM) >> r &&
        (t[i++] = n | (this.s << (this.DB - r)));
        e >= 0;

      )
        r < 8
          ? ((n = (this.data[e] & ((1 << r) - 1)) << (8 - r)),
            (n |= this.data[--e] >> (r += this.DB - 8)))
          : ((n = (this.data[e] >> (r -= 8)) & 255),
            r <= 0 && ((r += this.DB), --e)),
          n & 128 && (n |= -256),
          i == 0 && (this.s & 128) != (n & 128) && ++i,
          (i > 0 || n != this.s) && (t[i++] = n)
    return t
  }
  function _et(e) {
    return this.compareTo(e) == 0
  }
  function xet(e) {
    return this.compareTo(e) < 0 ? this : e
  }
  function wet(e) {
    return this.compareTo(e) > 0 ? this : e
  }
  function Iet(e, t, r) {
    var n,
      i,
      s = Math.min(e.t, this.t)
    for (n = 0; n < s; ++n) r.data[n] = t(this.data[n], e.data[n])
    if (e.t < this.t) {
      for (i = e.s & this.DM, n = s; n < this.t; ++n)
        r.data[n] = t(this.data[n], i)
      r.t = this.t
    } else {
      for (i = this.s & this.DM, n = s; n < e.t; ++n)
        r.data[n] = t(i, e.data[n])
      r.t = e.t
    }
    ;(r.s = t(this.s, e.s)), r.clamp()
  }
  function Bet(e, t) {
    return e & t
  }
  function Ret(e) {
    var t = Lr()
    return this.bitwiseTo(e, Bet, t), t
  }
  function VW(e, t) {
    return e | t
  }
  function Det(e) {
    var t = Lr()
    return this.bitwiseTo(e, VW, t), t
  }
  function Iue(e, t) {
    return e ^ t
  }
  function Tet(e) {
    var t = Lr()
    return this.bitwiseTo(e, Iue, t), t
  }
  function Bue(e, t) {
    return e & ~t
  }
  function ket(e) {
    var t = Lr()
    return this.bitwiseTo(e, Bue, t), t
  }
  function Met() {
    for (var e = Lr(), t = 0; t < this.t; ++t)
      e.data[t] = this.DM & ~this.data[t]
    return (e.t = this.t), (e.s = ~this.s), e
  }
  function Fet(e) {
    var t = Lr()
    return e < 0 ? this.rShiftTo(-e, t) : this.lShiftTo(e, t), t
  }
  function Qet(e) {
    var t = Lr()
    return e < 0 ? this.lShiftTo(-e, t) : this.rShiftTo(e, t), t
  }
  function Net(e) {
    if (e == 0) return -1
    var t = 0
    return (
      e & 65535 || ((e >>= 16), (t += 16)),
      e & 255 || ((e >>= 8), (t += 8)),
      e & 15 || ((e >>= 4), (t += 4)),
      e & 3 || ((e >>= 2), (t += 2)),
      e & 1 || ++t,
      t
    )
  }
  function Pet() {
    for (var e = 0; e < this.t; ++e)
      if (this.data[e] != 0) return e * this.DB + Net(this.data[e])
    return this.s < 0 ? this.t * this.DB : -1
  }
  function Let(e) {
    for (var t = 0; e != 0; ) (e &= e - 1), ++t
    return t
  }
  function Uet() {
    for (var e = 0, t = this.s & this.DM, r = 0; r < this.t; ++r)
      e += Let(this.data[r] ^ t)
    return e
  }
  function Oet(e) {
    var t = Math.floor(e / this.DB)
    return t >= this.t ? this.s != 0 : (this.data[t] & (1 << e % this.DB)) != 0
  }
  function qet(e, t) {
    var r = pe.ONE.shiftLeft(e)
    return this.bitwiseTo(r, t, r), r
  }
  function Vet(e) {
    return this.changeBit(e, VW)
  }
  function Het(e) {
    return this.changeBit(e, Bue)
  }
  function Wet(e) {
    return this.changeBit(e, Iue)
  }
  function Get(e, t) {
    for (var r = 0, n = 0, i = Math.min(e.t, this.t); r < i; )
      (n += this.data[r] + e.data[r]),
        (t.data[r++] = n & this.DM),
        (n >>= this.DB)
    if (e.t < this.t) {
      for (n += e.s; r < this.t; )
        (n += this.data[r]), (t.data[r++] = n & this.DM), (n >>= this.DB)
      n += this.s
    } else {
      for (n += this.s; r < e.t; )
        (n += e.data[r]), (t.data[r++] = n & this.DM), (n >>= this.DB)
      n += e.s
    }
    ;(t.s = n < 0 ? -1 : 0),
      n > 0 ? (t.data[r++] = n) : n < -1 && (t.data[r++] = this.DV + n),
      (t.t = r),
      t.clamp()
  }
  function $et(e) {
    var t = Lr()
    return this.addTo(e, t), t
  }
  function Yet(e) {
    var t = Lr()
    return this.subTo(e, t), t
  }
  function Ket(e) {
    var t = Lr()
    return this.multiplyTo(e, t), t
  }
  function zet(e) {
    var t = Lr()
    return this.divRemTo(e, t, null), t
  }
  function Jet(e) {
    var t = Lr()
    return this.divRemTo(e, null, t), t
  }
  function jet(e) {
    var t = Lr(),
      r = Lr()
    return this.divRemTo(e, t, r), new Array(t, r)
  }
  function Zet(e) {
    ;(this.data[this.t] = this.am(0, e - 1, this, 0, 0, this.t)),
      ++this.t,
      this.clamp()
  }
  function Xet(e, t) {
    if (e != 0) {
      for (; this.t <= t; ) this.data[this.t++] = 0
      for (this.data[t] += e; this.data[t] >= this.DV; )
        (this.data[t] -= this.DV),
          ++t >= this.t && (this.data[this.t++] = 0),
          ++this.data[t]
    }
  }
  function p_() {}
  function Rue(e) {
    return e
  }
  function ett(e, t, r) {
    e.multiplyTo(t, r)
  }
  function ttt(e, t) {
    e.squareTo(t)
  }
  p_.prototype.convert = Rue
  p_.prototype.revert = Rue
  p_.prototype.mulTo = ett
  p_.prototype.sqrTo = ttt
  function rtt(e) {
    return this.exp(e, new p_())
  }
  function ntt(e, t, r) {
    var n = Math.min(this.t + e.t, t)
    for (r.s = 0, r.t = n; n > 0; ) r.data[--n] = 0
    var i
    for (i = r.t - this.t; n < i; ++n)
      r.data[n + this.t] = this.am(0, e.data[n], r, n, 0, this.t)
    for (i = Math.min(e.t, t); n < i; ++n) this.am(0, e.data[n], r, n, 0, t - n)
    r.clamp()
  }
  function itt(e, t, r) {
    --t
    var n = (r.t = this.t + e.t - t)
    for (r.s = 0; --n >= 0; ) r.data[n] = 0
    for (n = Math.max(t - this.t, 0); n < e.t; ++n)
      r.data[this.t + n - t] = this.am(
        t - n,
        e.data[n],
        r,
        0,
        0,
        this.t + n - t,
      )
    r.clamp(), r.drShiftTo(1, r)
  }
  function Cy(e) {
    ;(this.r2 = Lr()),
      (this.q3 = Lr()),
      pe.ONE.dlShiftTo(2 * e.t, this.r2),
      (this.mu = this.r2.divide(e)),
      (this.m = e)
  }
  function stt(e) {
    if (e.s < 0 || e.t > 2 * this.m.t) return e.mod(this.m)
    if (e.compareTo(this.m) < 0) return e
    var t = Lr()
    return e.copyTo(t), this.reduce(t), t
  }
  function ott(e) {
    return e
  }
  function att(e) {
    for (
      e.drShiftTo(this.m.t - 1, this.r2),
        e.t > this.m.t + 1 && ((e.t = this.m.t + 1), e.clamp()),
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3),
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      e.compareTo(this.r2) < 0;

    )
      e.dAddOffset(1, this.m.t + 1)
    for (e.subTo(this.r2, e); e.compareTo(this.m) >= 0; ) e.subTo(this.m, e)
  }
  function ltt(e, t) {
    e.squareTo(t), this.reduce(t)
  }
  function ctt(e, t, r) {
    e.multiplyTo(t, r), this.reduce(r)
  }
  Cy.prototype.convert = stt
  Cy.prototype.revert = ott
  Cy.prototype.reduce = att
  Cy.prototype.mulTo = ctt
  Cy.prototype.sqrTo = ltt
  function utt(e, t) {
    var r = e.bitLength(),
      n,
      i = Th(1),
      s
    if (r <= 0) return i
    r < 18
      ? (n = 1)
      : r < 48
        ? (n = 3)
        : r < 144
          ? (n = 4)
          : r < 768
            ? (n = 5)
            : (n = 6),
      r < 8 ? (s = new Wp(t)) : t.isEven() ? (s = new Cy(t)) : (s = new Gp(t))
    var o = new Array(),
      a = 3,
      l = n - 1,
      c = (1 << n) - 1
    if (((o[1] = s.convert(this)), n > 1)) {
      var u = Lr()
      for (s.sqrTo(o[1], u); a <= c; )
        (o[a] = Lr()), s.mulTo(u, o[a - 2], o[a]), (a += 2)
    }
    var f = e.t - 1,
      p,
      g = true,
      m = Lr(),
      y
    for (r = pT(e.data[f]) - 1; f >= 0; ) {
      for (
        r >= l
          ? (p = (e.data[f] >> (r - l)) & c)
          : ((p = (e.data[f] & ((1 << (r + 1)) - 1)) << (l - r)),
            f > 0 && (p |= e.data[f - 1] >> (this.DB + r - l))),
          a = n;
        !(p & 1);

      )
        (p >>= 1), --a
      if (((r -= a) < 0 && ((r += this.DB), --f), g)) o[p].copyTo(i), (g = false)
      else {
        for (; a > 1; ) s.sqrTo(i, m), s.sqrTo(m, i), (a -= 2)
        a > 0 ? s.sqrTo(i, m) : ((y = i), (i = m), (m = y)), s.mulTo(m, o[p], i)
      }
      for (; f >= 0 && !(e.data[f] & (1 << r)); )
        s.sqrTo(i, m),
          (y = i),
          (i = m),
          (m = y),
          --r < 0 && ((r = this.DB - 1), --f)
    }
    return s.revert(i)
  }
  function dtt(e) {
    var t = this.s < 0 ? this.negate() : this.clone(),
      r = e.s < 0 ? e.negate() : e.clone()
    if (t.compareTo(r) < 0) {
      var n = t
      ;(t = r), (r = n)
    }
    var i = t.getLowestSetBit(),
      s = r.getLowestSetBit()
    if (s < 0) return t
    for (
      i < s && (s = i), s > 0 && (t.rShiftTo(s, t), r.rShiftTo(s, r));
      t.signum() > 0;

    )
      (i = t.getLowestSetBit()) > 0 && t.rShiftTo(i, t),
        (i = r.getLowestSetBit()) > 0 && r.rShiftTo(i, r),
        t.compareTo(r) >= 0
          ? (t.subTo(r, t), t.rShiftTo(1, t))
          : (r.subTo(t, r), r.rShiftTo(1, r))
    return s > 0 && r.lShiftTo(s, r), r
  }
  function ftt(e) {
    if (e <= 0) return 0
    var t = this.DV % e,
      r = this.s < 0 ? e - 1 : 0
    if (this.t > 0)
      if (t == 0) r = this.data[0] % e
      else for (var n = this.t - 1; n >= 0; --n) r = (t * r + this.data[n]) % e
    return r
  }
  function htt(e) {
    var t = e.isEven()
    if ((this.isEven() && t) || e.signum() == 0) return pe.ZERO
    for (
      var r = e.clone(),
        n = this.clone(),
        i = Th(1),
        s = Th(0),
        o = Th(0),
        a = Th(1);
      r.signum() != 0;

    ) {
      for (; r.isEven(); )
        r.rShiftTo(1, r),
          t
            ? ((!i.isEven() || !s.isEven()) &&
                (i.addTo(this, i), s.subTo(e, s)),
              i.rShiftTo(1, i))
            : s.isEven() || s.subTo(e, s),
          s.rShiftTo(1, s)
      for (; n.isEven(); )
        n.rShiftTo(1, n),
          t
            ? ((!o.isEven() || !a.isEven()) &&
                (o.addTo(this, o), a.subTo(e, a)),
              o.rShiftTo(1, o))
            : a.isEven() || a.subTo(e, a),
          a.rShiftTo(1, a)
      r.compareTo(n) >= 0
        ? (r.subTo(n, r), t && i.subTo(o, i), s.subTo(a, s))
        : (n.subTo(r, n), t && o.subTo(i, o), a.subTo(s, a))
    }
    if (n.compareTo(pe.ONE) != 0) return pe.ZERO
    if (a.compareTo(e) >= 0) return a.subtract(e)
    if (a.signum() < 0) a.addTo(e, a)
    else return a
    return a.signum() < 0 ? a.add(e) : a
  }
  var Fc = [
      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,
      71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149,
      151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229,
      233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313,
      317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409,
      419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,
      503, 509,
    ],
    gtt = (1 << 26) / Fc[Fc.length - 1]
  function ptt(e) {
    var t,
      r = this.abs()
    if (r.t == 1 && r.data[0] <= Fc[Fc.length - 1]) {
      for (t = 0; t < Fc.length; ++t) if (r.data[0] == Fc[t]) return true
      return false
    }
    if (r.isEven()) return false
    for (t = 1; t < Fc.length; ) {
      for (var n = Fc[t], i = t + 1; i < Fc.length && n < gtt; ) n *= Fc[i++]
      for (n = r.modInt(n); t < i; ) if (n % Fc[t++] == 0) return false
    }
    return r.millerRabin(e)
  }
  function mtt(e) {
    var t = this.subtract(pe.ONE),
      r = t.getLowestSetBit()
    if (r <= 0) return false
    for (var n = t.shiftRight(r), i = Att(), s, o = 0; o < e; ++o) {
      do s = new pe(this.bitLength(), i)
      while (s.compareTo(pe.ONE) <= 0 || s.compareTo(t) >= 0)
      var a = s.modPow(n, this)
      if (a.compareTo(pe.ONE) != 0 && a.compareTo(t) != 0) {
        for (var l = 1; l++ < r && a.compareTo(t) != 0; )
          if (((a = a.modPowInt(2, this)), a.compareTo(pe.ONE) == 0)) return false
        if (a.compareTo(t) != 0) return false
      }
    }
    return true
  }
  function Att() {
    return {
      nextBytes: function (e) {
        for (var t = 0; t < e.length; ++t)
          e[t] = Math.floor(Math.random() * 256)
      },
    }
  }
  pe.prototype.chunkSize = Aet
  pe.prototype.toRadix = vet
  pe.prototype.fromRadix = Cet
  pe.prototype.fromNumber = bet
  pe.prototype.bitwiseTo = Iet
  pe.prototype.changeBit = qet
  pe.prototype.addTo = Get
  pe.prototype.dMultiply = Zet
  pe.prototype.dAddOffset = Xet
  pe.prototype.multiplyLowerTo = ntt
  pe.prototype.multiplyUpperTo = itt
  pe.prototype.modInt = ftt
  pe.prototype.millerRabin = mtt
  pe.prototype.clone = het
  pe.prototype.intValue = get
  pe.prototype.byteValue = pet
  pe.prototype.shortValue = met
  pe.prototype.signum = yet
  pe.prototype.toByteArray = Eet
  pe.prototype.equals = _et
  pe.prototype.min = xet
  pe.prototype.max = wet
  pe.prototype.and = Ret
  pe.prototype.or = Det
  pe.prototype.xor = Tet
  pe.prototype.andNot = ket
  pe.prototype.not = Met
  pe.prototype.shiftLeft = Fet
  pe.prototype.shiftRight = Qet
  pe.prototype.getLowestSetBit = Pet
  pe.prototype.bitCount = Uet
  pe.prototype.testBit = Oet
  pe.prototype.setBit = Vet
  pe.prototype.clearBit = Het
  pe.prototype.flipBit = Wet
  pe.prototype.add = $et
  pe.prototype.subtract = Yet
  pe.prototype.multiply = Ket
  pe.prototype.divide = zet
  pe.prototype.remainder = Jet
  pe.prototype.divideAndRemainder = jet
  pe.prototype.modPow = utt
  pe.prototype.modInverse = htt
  pe.prototype.pow = rtt
  pe.prototype.gcd = dtt
  pe.prototype.isProbablePrime = ptt
})
var by = _((hkt, Fue) => {
  "use strict"
  var Nu = jt()
  Tu()
  Pr()
  var kue = (Fue.exports = Nu.sha1 = Nu.sha1 || {})
  Nu.md.sha1 = Nu.md.algorithms.sha1 = kue
  kue.create = function () {
    Mue || ytt()
    var e = null,
      t = Nu.util.createBuffer(),
      r = new Array(80),
      n = {
        algorithm: "sha1",
        blockLength: 64,
        digestLength: 20,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8,
      }
    return (
      (n.start = function () {
        ;(n.messageLength = 0), (n.fullMessageLength = n.messageLength64 = [])
        for (var i = n.messageLengthSize / 4, s = 0; s < i; ++s)
          n.fullMessageLength.push(0)
        return (
          (t = Nu.util.createBuffer()),
          (e = {
            h0: 1732584193,
            h1: 4023233417,
            h2: 2562383102,
            h3: 271733878,
            h4: 3285377520,
          }),
          n
        )
      }),
      n.start(),
      (n.update = function (i, s) {
        s === "utf8" && (i = Nu.util.encodeUtf8(i))
        var o = i.length
        ;(n.messageLength += o), (o = [(o / 4294967296) >>> 0, o >>> 0])
        for (var a = n.fullMessageLength.length - 1; a >= 0; --a)
          (n.fullMessageLength[a] += o[1]),
            (o[1] = o[0] + ((n.fullMessageLength[a] / 4294967296) >>> 0)),
            (n.fullMessageLength[a] = n.fullMessageLength[a] >>> 0),
            (o[0] = (o[1] / 4294967296) >>> 0)
        return (
          t.putBytes(i),
          Tue(e, r, t),
          (t.read > 2048 || t.length() === 0) && t.compact(),
          n
        )
      }),
      (n.digest = function () {
        var i = Nu.util.createBuffer()
        i.putBytes(t.bytes())
        var s =
            n.fullMessageLength[n.fullMessageLength.length - 1] +
            n.messageLengthSize,
          o = s & (n.blockLength - 1)
        i.putBytes(HW.substr(0, n.blockLength - o))
        for (
          var a, l, c = n.fullMessageLength[0] * 8, u = 0;
          u < n.fullMessageLength.length - 1;
          ++u
        )
          (a = n.fullMessageLength[u + 1] * 8),
            (l = (a / 4294967296) >>> 0),
            (c += l),
            i.putInt32(c >>> 0),
            (c = a >>> 0)
        i.putInt32(c)
        var f = { h0: e.h0, h1: e.h1, h2: e.h2, h3: e.h3, h4: e.h4 }
        Tue(f, r, i)
        var p = Nu.util.createBuffer()
        return (
          p.putInt32(f.h0),
          p.putInt32(f.h1),
          p.putInt32(f.h2),
          p.putInt32(f.h3),
          p.putInt32(f.h4),
          p
        )
      }),
      n
    )
  }
  var HW = null,
    Mue = false
  function ytt() {
    ;(HW = "\x80"), (HW += Nu.util.fillString("\0", 64)), (Mue = true)
  }
  function Tue(e, t, r) {
    for (var n, i, s, o, a, l, c, u, f = r.length(); f >= 64; ) {
      for (i = e.h0, s = e.h1, o = e.h2, a = e.h3, l = e.h4, u = 0; u < 16; ++u)
        (n = r.getInt32()),
          (t[u] = n),
          (c = a ^ (s & (o ^ a))),
          (n = ((i << 5) | (i >>> 27)) + c + l + 1518500249 + n),
          (l = a),
          (a = o),
          (o = ((s << 30) | (s >>> 2)) >>> 0),
          (s = i),
          (i = n)
      for (; u < 20; ++u)
        (n = t[u - 3] ^ t[u - 8] ^ t[u - 14] ^ t[u - 16]),
          (n = (n << 1) | (n >>> 31)),
          (t[u] = n),
          (c = a ^ (s & (o ^ a))),
          (n = ((i << 5) | (i >>> 27)) + c + l + 1518500249 + n),
          (l = a),
          (a = o),
          (o = ((s << 30) | (s >>> 2)) >>> 0),
          (s = i),
          (i = n)
      for (; u < 32; ++u)
        (n = t[u - 3] ^ t[u - 8] ^ t[u - 14] ^ t[u - 16]),
          (n = (n << 1) | (n >>> 31)),
          (t[u] = n),
          (c = s ^ o ^ a),
          (n = ((i << 5) | (i >>> 27)) + c + l + 1859775393 + n),
          (l = a),
          (a = o),
          (o = ((s << 30) | (s >>> 2)) >>> 0),
          (s = i),
          (i = n)
      for (; u < 40; ++u)
        (n = t[u - 6] ^ t[u - 16] ^ t[u - 28] ^ t[u - 32]),
          (n = (n << 2) | (n >>> 30)),
          (t[u] = n),
          (c = s ^ o ^ a),
          (n = ((i << 5) | (i >>> 27)) + c + l + 1859775393 + n),
          (l = a),
          (a = o),
          (o = ((s << 30) | (s >>> 2)) >>> 0),
          (s = i),
          (i = n)
      for (; u < 60; ++u)
        (n = t[u - 6] ^ t[u - 16] ^ t[u - 28] ^ t[u - 32]),
          (n = (n << 2) | (n >>> 30)),
          (t[u] = n),
          (c = (s & o) | (a & (s ^ o))),
          (n = ((i << 5) | (i >>> 27)) + c + l + 2400959708 + n),
          (l = a),
          (a = o),
          (o = ((s << 30) | (s >>> 2)) >>> 0),
          (s = i),
          (i = n)
      for (; u < 80; ++u)
        (n = t[u - 6] ^ t[u - 16] ^ t[u - 28] ^ t[u - 32]),
          (n = (n << 2) | (n >>> 30)),
          (t[u] = n),
          (c = s ^ o ^ a),
          (n = ((i << 5) | (i >>> 27)) + c + l + 3395469782 + n),
          (l = a),
          (a = o),
          (o = ((s << 30) | (s >>> 2)) >>> 0),
          (s = i),
          (i = n)
      ;(e.h0 = (e.h0 + i) | 0),
        (e.h1 = (e.h1 + s) | 0),
        (e.h2 = (e.h2 + o) | 0),
        (e.h3 = (e.h3 + a) | 0),
        (e.h4 = (e.h4 + l) | 0),
        (f -= 64)
    }
  }
})
var WW = _((gkt, Nue) => {
  "use strict"
  var Pu = jt()
  Pr()
  Tl()
  by()
  var Que = (Nue.exports = Pu.pkcs1 = Pu.pkcs1 || {})
  Que.encode_rsa_oaep = function (e, t, r) {
    var n, i, s, o
    typeof r == "string"
      ? ((n = r), (i = arguments[3] || undefined), (s = arguments[4] || undefined))
      : r &&
        ((n = r.label || undefined),
        (i = r.seed || undefined),
        (s = r.md || undefined),
        r.mgf1 && r.mgf1.md && (o = r.mgf1.md)),
      s ? s.start() : (s = Pu.md.sha1.create()),
      o || (o = s)
    var a = Math.ceil(e.n.bitLength() / 8),
      l = a - 2 * s.digestLength - 2
    if (t.length > l) {
      var c = new Error("RSAES-OAEP input message length is too long.")
      throw ((c.length = t.length), (c.maxLength = l), c)
    }
    n || (n = ""), s.update(n, "raw")
    for (var u = s.digest(), f = "", p = l - t.length, g = 0; g < p; g++)
      f += "\0"
    var m = u.getBytes() + f + "" + t
    if (!i) i = Pu.random.getBytes(s.digestLength)
    else if (i.length !== s.digestLength) {
      var c = new Error(
        "Invalid RSAES-OAEP seed. The seed length must match the digest length.",
      )
      throw ((c.seedLength = i.length), (c.digestLength = s.digestLength), c)
    }
    var y = mT(i, a - s.digestLength - 1, o),
      v = Pu.util.xorBytes(m, y, m.length),
      C = mT(v, s.digestLength, o),
      E = Pu.util.xorBytes(i, C, i.length)
    return "\0" + E + v
  }
  Que.decode_rsa_oaep = function (e, t, r) {
    var n, i, s
    typeof r == "string"
      ? ((n = r), (i = arguments[3] || undefined))
      : r &&
        ((n = r.label || undefined),
        (i = r.md || undefined),
        r.mgf1 && r.mgf1.md && (s = r.mgf1.md))
    var o = Math.ceil(e.n.bitLength() / 8)
    if (t.length !== o) {
      var v = new Error("RSAES-OAEP encoded message length is invalid.")
      throw ((v.length = t.length), (v.expectedLength = o), v)
    }
    if (
      (i === undefined ? (i = Pu.md.sha1.create()) : i.start(),
      s || (s = i),
      o < 2 * i.digestLength + 2)
    )
      throw new Error("RSAES-OAEP key is too short for the hash function.")
    n || (n = ""), i.update(n, "raw")
    for (
      var a = i.digest().getBytes(),
        l = t.charAt(0),
        c = t.substring(1, i.digestLength + 1),
        u = t.substring(1 + i.digestLength),
        f = mT(u, i.digestLength, s),
        p = Pu.util.xorBytes(c, f, c.length),
        g = mT(p, o - i.digestLength - 1, s),
        m = Pu.util.xorBytes(u, g, u.length),
        y = m.substring(0, i.digestLength),
        v = l !== "\0",
        C = 0;
      C < i.digestLength;
      ++C
    )
      v |= a.charAt(C) !== y.charAt(C)
    for (var E = 1, w = i.digestLength, B = i.digestLength; B < m.length; B++) {
      var T = m.charCodeAt(B),
        N = (T & 1) ^ 1,
        W = E ? 65534 : 0
      ;(v |= T & W), (E = E & N), (w += E)
    }
    if (v || m.charCodeAt(w) !== 1)
      throw new Error("Invalid RSAES-OAEP padding.")
    return m.substring(w + 1)
  }
  function mT(e, t, r) {
    r || (r = Pu.md.sha1.create())
    for (var n = "", i = Math.ceil(t / r.digestLength), s = 0; s < i; ++s) {
      var o = String.fromCharCode(
        (s >> 24) & 255,
        (s >> 16) & 255,
        (s >> 8) & 255,
        s & 255,
      )
      r.start(), r.update(e + o), (n += r.digest().getBytes())
    }
    return n.substring(0, t)
  }
})
var $W = _((pkt, GW) => {
  "use strict"
  var kh = jt()
  Pr()
  m_()
  Tl()
  ;(function () {
    if (kh.prime) {
      GW.exports = kh.prime
      return
    }
    var e = (GW.exports = kh.prime = kh.prime || {}),
      t = kh.jsbn.BigInteger,
      r = [6, 4, 2, 4, 2, 4, 6, 2],
      n = new t(null)
    n.fromInt(30)
    var i = function (f, p) {
      return f | p
    }
    e.generateProbablePrime = function (f, p, g) {
      typeof p == "function" && ((g = p), (p = {})), (p = p || {})
      var m = p.algorithm || "PRIMEINC"
      typeof m == "string" && (m = { name: m }), (m.options = m.options || {})
      var y = p.prng || kh.random,
        v = {
          nextBytes: function (C) {
            for (var E = y.getBytesSync(C.length), w = 0; w < C.length; ++w)
              C[w] = E.charCodeAt(w)
          },
        }
      if (m.name === "PRIMEINC") return s(f, v, m.options, g)
      throw new Error("Invalid prime generation algorithm: " + m.name)
    }
    function s(f, p, g, m) {
      return "workers" in g ? l(f, p, g, m) : o(f, p, g, m)
    }
    function o(f, p, g, m) {
      var y = c(f, p),
        v = 0,
        C = u(y.bitLength())
      "millerRabinTests" in g && (C = g.millerRabinTests)
      var E = 10
      "maxBlockTime" in g && (E = g.maxBlockTime), a(y, f, p, v, C, E, m)
    }
    function a(f, p, g, m, y, v, C) {
      var E = +new Date()
      do {
        if ((f.bitLength() > p && (f = c(p, g)), f.isProbablePrime(y)))
          return C(null, f)
        f.dAddOffset(r[m++ % 8], 0)
      } while (v < 0 || +new Date() - E < v)
      kh.util.setImmediate(function () {
        a(f, p, g, m, y, v, C)
      })
    }
    function l(f, p, g, m) {
      if (typeof Worker > "u") return o(f, p, g, m)
      var y = c(f, p),
        v = g.workers,
        C = g.workLoad || 100,
        E = (C * 30) / 8,
        w = g.workerScript || "forge/prime.worker.js"
      if (v === -1)
        return kh.util.estimateCores(function (T, N) {
          T && (N = 2), (v = N - 1), B()
        })
      B()
      function B() {
        v = Math.max(1, v)
        for (var T = [], N = 0; N < v; ++N) T[N] = new Worker(w)
        for (var W = v, N = 0; N < v; ++N) T[N].addEventListener("message", te)
        var Z = false
        function te(Y) {
          if (!Z) {
            --W
            var U = Y.data
            if (U.found) {
              for (var ce = 0; ce < T.length; ++ce) T[ce].terminate()
              return (Z = true), m(null, new t(U.prime, 16))
            }
            y.bitLength() > f && (y = c(f, p))
            var Ie = y.toString(16)
            Y.target.postMessage({ hex: Ie, workLoad: C }), y.dAddOffset(E, 0)
          }
        }
      }
    }
    function c(f, p) {
      var g = new t(f, p),
        m = f - 1
      return (
        g.testBit(m) || g.bitwiseTo(t.ONE.shiftLeft(m), i, g),
        g.dAddOffset(31 - g.mod(n).byteValue(), 0),
        g
      )
    }
    function u(f) {
      return f <= 100
        ? 27
        : f <= 150
          ? 18
          : f <= 200
            ? 15
            : f <= 250
              ? 12
              : f <= 300
                ? 9
                : f <= 350
                  ? 8
                  : f <= 400
                    ? 7
                    : f <= 500
                      ? 6
                      : f <= 600
                        ? 5
                        : f <= 800
                          ? 4
                          : f <= 1250
                            ? 3
                            : 2
    }
  })()
})
var A_ = _((mkt, Hue) => {
  "use strict"
  var rt = jt()
  Mc()
  m_()
  Dh()
  WW()
  $W()
  Tl()
  Pr()
  typeof Rr > "u" && (Rr = rt.jsbn.BigInteger)
  var Rr,
    YW = rt.util.isNodejs ? require("crypto") : null,
    ee = rt.asn1,
    Ml = rt.util
  rt.pki = rt.pki || {}
  Hue.exports = rt.pki.rsa = rt.rsa = rt.rsa || {}
  var Pt = rt.pki,
    vtt = [6, 4, 2, 4, 2, 4, 6, 2],
    Ctt = {
      name: "PrivateKeyInfo",
      tagClass: ee.Class.UNIVERSAL,
      type: ee.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "PrivateKeyInfo.version",
          tagClass: ee.Class.UNIVERSAL,
          type: ee.Type.INTEGER,
          constructed: false,
          capture: "privateKeyVersion",
        },
        {
          name: "PrivateKeyInfo.privateKeyAlgorithm",
          tagClass: ee.Class.UNIVERSAL,
          type: ee.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "AlgorithmIdentifier.algorithm",
              tagClass: ee.Class.UNIVERSAL,
              type: ee.Type.OID,
              constructed: false,
              capture: "privateKeyOid",
            },
          ],
        },
        {
          name: "PrivateKeyInfo",
          tagClass: ee.Class.UNIVERSAL,
          type: ee.Type.OCTETSTRING,
          constructed: false,
          capture: "privateKey",
        },
      ],
    },
    btt = {
      name: "RSAPrivateKey",
      tagClass: ee.Class.UNIVERSAL,
      type: ee.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "RSAPrivateKey.version",
          tagClass: ee.Class.UNIVERSAL,
          type: ee.Type.INTEGER,
          constructed: false,
          capture: "privateKeyVersion",
        },
        {
          name: "RSAPrivateKey.modulus",
          tagClass: ee.Class.UNIVERSAL,
          type: ee.Type.INTEGER,
          constructed: false,
          capture: "privateKeyModulus",
        },
        {
          name: "RSAPrivateKey.publicExponent",
          tagClass: ee.Class.UNIVERSAL,
          type: ee.Type.INTEGER,
          constructed: false,
          capture: "privateKeyPublicExponent",
        },
        {
          name: "RSAPrivateKey.privateExponent",
          tagClass: ee.Class.UNIVERSAL,
          type: ee.Type.INTEGER,
          constructed: false,
          capture: "privateKeyPrivateExponent",
        },
        {
          name: "RSAPrivateKey.prime1",
          tagClass: ee.Class.UNIVERSAL,
          type: ee.Type.INTEGER,
          constructed: false,
          capture: "privateKeyPrime1",
        },
        {
          name: "RSAPrivateKey.prime2",
          tagClass: ee.Class.UNIVERSAL,
          type: ee.Type.INTEGER,
          constructed: false,
          capture: "privateKeyPrime2",
        },
        {
          name: "RSAPrivateKey.exponent1",
          tagClass: ee.Class.UNIVERSAL,
          type: ee.Type.INTEGER,
          constructed: false,
          capture: "privateKeyExponent1",
        },
        {
          name: "RSAPrivateKey.exponent2",
          tagClass: ee.Class.UNIVERSAL,
          type: ee.Type.INTEGER,
          constructed: false,
          capture: "privateKeyExponent2",
        },
        {
          name: "RSAPrivateKey.coefficient",
          tagClass: ee.Class.UNIVERSAL,
          type: ee.Type.INTEGER,
          constructed: false,
          capture: "privateKeyCoefficient",
        },
      ],
    },
    Ett = {
      name: "RSAPublicKey",
      tagClass: ee.Class.UNIVERSAL,
      type: ee.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "RSAPublicKey.modulus",
          tagClass: ee.Class.UNIVERSAL,
          type: ee.Type.INTEGER,
          constructed: false,
          capture: "publicKeyModulus",
        },
        {
          name: "RSAPublicKey.exponent",
          tagClass: ee.Class.UNIVERSAL,
          type: ee.Type.INTEGER,
          constructed: false,
          capture: "publicKeyExponent",
        },
      ],
    },
    _tt = (rt.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: ee.Class.UNIVERSAL,
      type: ee.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [
        {
          name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
          tagClass: ee.Class.UNIVERSAL,
          type: ee.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "AlgorithmIdentifier.algorithm",
              tagClass: ee.Class.UNIVERSAL,
              type: ee.Type.OID,
              constructed: false,
              capture: "publicKeyOid",
            },
          ],
        },
        {
          name: "SubjectPublicKeyInfo.subjectPublicKey",
          tagClass: ee.Class.UNIVERSAL,
          type: ee.Type.BITSTRING,
          constructed: false,
          value: [
            {
              name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
              tagClass: ee.Class.UNIVERSAL,
              type: ee.Type.SEQUENCE,
              constructed: true,
              optional: true,
              captureAsn1: "rsaPublicKey",
            },
          ],
        },
      ],
    }),
    xtt = {
      name: "DigestInfo",
      tagClass: ee.Class.UNIVERSAL,
      type: ee.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "DigestInfo.DigestAlgorithm",
          tagClass: ee.Class.UNIVERSAL,
          type: ee.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
              tagClass: ee.Class.UNIVERSAL,
              type: ee.Type.OID,
              constructed: false,
              capture: "algorithmIdentifier",
            },
            {
              name: "DigestInfo.DigestAlgorithm.parameters",
              tagClass: ee.Class.UNIVERSAL,
              type: ee.Type.NULL,
              capture: "parameters",
              optional: true,
              constructed: false,
            },
          ],
        },
        {
          name: "DigestInfo.digest",
          tagClass: ee.Class.UNIVERSAL,
          type: ee.Type.OCTETSTRING,
          constructed: false,
          capture: "digest",
        },
      ],
    },
    wtt = function (e) {
      var t
      if (e.algorithm in Pt.oids) t = Pt.oids[e.algorithm]
      else {
        var r = new Error("Unknown message digest algorithm.")
        throw ((r.algorithm = e.algorithm), r)
      }
      var n = ee.oidToDer(t).getBytes(),
        i = ee.create(ee.Class.UNIVERSAL, ee.Type.SEQUENCE, true, []),
        s = ee.create(ee.Class.UNIVERSAL, ee.Type.SEQUENCE, true, [])
      s.value.push(ee.create(ee.Class.UNIVERSAL, ee.Type.OID, false, n)),
        s.value.push(ee.create(ee.Class.UNIVERSAL, ee.Type.NULL, false, ""))
      var o = ee.create(
        ee.Class.UNIVERSAL,
        ee.Type.OCTETSTRING,
        false,
        e.digest().getBytes(),
      )
      return i.value.push(s), i.value.push(o), ee.toDer(i).getBytes()
    },
    que = function (e, t, r) {
      if (r) return e.modPow(t.e, t.n)
      if (!t.p || !t.q) return e.modPow(t.d, t.n)
      t.dP || (t.dP = t.d.mod(t.p.subtract(Rr.ONE))),
        t.dQ || (t.dQ = t.d.mod(t.q.subtract(Rr.ONE))),
        t.qInv || (t.qInv = t.q.modInverse(t.p))
      var n
      do
        n = new Rr(
          rt.util.bytesToHex(rt.random.getBytes(t.n.bitLength() / 8)),
          16,
        )
      while (n.compareTo(t.n) >= 0 || !n.gcd(t.n).equals(Rr.ONE))
      e = e.multiply(n.modPow(t.e, t.n)).mod(t.n)
      for (
        var i = e.mod(t.p).modPow(t.dP, t.p), s = e.mod(t.q).modPow(t.dQ, t.q);
        i.compareTo(s) < 0;

      )
        i = i.add(t.p)
      var o = i.subtract(s).multiply(t.qInv).mod(t.p).multiply(t.q).add(s)
      return (o = o.multiply(n.modInverse(t.n)).mod(t.n)), o
    }
  Pt.rsa.encrypt = function (e, t, r) {
    var n = r,
      i,
      s = Math.ceil(t.n.bitLength() / 8)
    r !== false && r !== true
      ? ((n = r === 2), (i = Vue(e, t, r)))
      : ((i = rt.util.createBuffer()), i.putBytes(e))
    for (
      var o = new Rr(i.toHex(), 16),
        a = que(o, t, n),
        l = a.toString(16),
        c = rt.util.createBuffer(),
        u = s - Math.ceil(l.length / 2);
      u > 0;

    )
      c.putByte(0), --u
    return c.putBytes(rt.util.hexToBytes(l)), c.getBytes()
  }
  Pt.rsa.decrypt = function (e, t, r, n) {
    var i = Math.ceil(t.n.bitLength() / 8)
    if (e.length !== i) {
      var s = new Error("Encrypted message length is invalid.")
      throw ((s.length = e.length), (s.expected = i), s)
    }
    var o = new Rr(rt.util.createBuffer(e).toHex(), 16)
    if (o.compareTo(t.n) >= 0) throw new Error("Encrypted message is invalid.")
    for (
      var a = que(o, t, r),
        l = a.toString(16),
        c = rt.util.createBuffer(),
        u = i - Math.ceil(l.length / 2);
      u > 0;

    )
      c.putByte(0), --u
    return (
      c.putBytes(rt.util.hexToBytes(l)),
      n !== false ? AT(c.getBytes(), t, r) : c.getBytes()
    )
  }
  Pt.rsa.createKeyPairGenerationState = function (e, t, r) {
    typeof e == "string" && (e = parseInt(e, 10)),
      (e = e || 2048),
      (r = r || {})
    var n = r.prng || rt.random,
      i = {
        nextBytes: function (a) {
          for (var l = n.getBytesSync(a.length), c = 0; c < a.length; ++c)
            a[c] = l.charCodeAt(c)
        },
      },
      s = r.algorithm || "PRIMEINC",
      o
    if (s === "PRIMEINC")
      (o = {
        algorithm: s,
        state: 0,
        bits: e,
        rng: i,
        eInt: t || 65537,
        e: new Rr(null),
        p: null,
        q: null,
        qBits: e >> 1,
        pBits: e - (e >> 1),
        pqState: 0,
        num: null,
        keys: null,
      }),
        o.e.fromInt(o.eInt)
    else throw new Error("Invalid key generation algorithm: " + s)
    return o
  }
  Pt.rsa.stepKeyPairGenerationState = function (e, t) {
    "algorithm" in e || (e.algorithm = "PRIMEINC")
    var r = new Rr(null)
    r.fromInt(30)
    for (
      var n = 0,
        i = function (f, p) {
          return f | p
        },
        s = +new Date(),
        o,
        a = 0;
      e.keys === null && (t <= 0 || a < t);

    ) {
      if (e.state === 0) {
        var l = e.p === null ? e.pBits : e.qBits,
          c = l - 1
        e.pqState === 0
          ? ((e.num = new Rr(l, e.rng)),
            e.num.testBit(c) || e.num.bitwiseTo(Rr.ONE.shiftLeft(c), i, e.num),
            e.num.dAddOffset(31 - e.num.mod(r).byteValue(), 0),
            (n = 0),
            ++e.pqState)
          : e.pqState === 1
            ? e.num.bitLength() > l
              ? (e.pqState = 0)
              : e.num.isProbablePrime(Itt(e.num.bitLength()))
                ? ++e.pqState
                : e.num.dAddOffset(vtt[n++ % 8], 0)
            : e.pqState === 2
              ? (e.pqState =
                  e.num.subtract(Rr.ONE).gcd(e.e).compareTo(Rr.ONE) === 0
                    ? 3
                    : 0)
              : e.pqState === 3 &&
                ((e.pqState = 0),
                e.p === null ? (e.p = e.num) : (e.q = e.num),
                e.p !== null && e.q !== null && ++e.state,
                (e.num = null))
      } else if (e.state === 1)
        e.p.compareTo(e.q) < 0 && ((e.num = e.p), (e.p = e.q), (e.q = e.num)),
          ++e.state
      else if (e.state === 2)
        (e.p1 = e.p.subtract(Rr.ONE)),
          (e.q1 = e.q.subtract(Rr.ONE)),
          (e.phi = e.p1.multiply(e.q1)),
          ++e.state
      else if (e.state === 3)
        e.phi.gcd(e.e).compareTo(Rr.ONE) === 0
          ? ++e.state
          : ((e.p = null), (e.q = null), (e.state = 0))
      else if (e.state === 4)
        (e.n = e.p.multiply(e.q)),
          e.n.bitLength() === e.bits ? ++e.state : ((e.q = null), (e.state = 0))
      else if (e.state === 5) {
        var u = e.e.modInverse(e.phi)
        e.keys = {
          privateKey: Pt.rsa.setPrivateKey(
            e.n,
            e.e,
            u,
            e.p,
            e.q,
            u.mod(e.p1),
            u.mod(e.q1),
            e.q.modInverse(e.p),
          ),
          publicKey: Pt.rsa.setPublicKey(e.n, e.e),
        }
      }
      ;(o = +new Date()), (a += o - s), (s = o)
    }
    return e.keys !== null
  }
  Pt.rsa.generateKeyPair = function (e, t, r, n) {
    if (
      (arguments.length === 1
        ? typeof e == "object"
          ? ((r = e), (e = undefined))
          : typeof e == "function" && ((n = e), (e = undefined))
        : arguments.length === 2
          ? typeof e == "number"
            ? typeof t == "function"
              ? ((n = t), (t = undefined))
              : typeof t != "number" && ((r = t), (t = undefined))
            : ((r = e), (n = t), (e = undefined), (t = undefined))
          : arguments.length === 3 &&
            (typeof t == "number"
              ? typeof r == "function" && ((n = r), (r = undefined))
              : ((n = r), (r = t), (t = undefined))),
      (r = r || {}),
      e === undefined && (e = r.bits || 2048),
      t === undefined && (t = r.e || 65537),
      !rt.options.usePureJavaScript &&
        !r.prng &&
        e >= 256 &&
        e <= 16384 &&
        (t === 65537 || t === 3))
    ) {
      if (n) {
        if (Pue("generateKeyPair"))
          return YW.generateKeyPair(
            "rsa",
            {
              modulusLength: e,
              publicExponent: t,
              publicKeyEncoding: { type: "spki", format: "pem" },
              privateKeyEncoding: { type: "pkcs8", format: "pem" },
            },
            function (a, l, c) {
              if (a) return n(a)
              n(null, {
                privateKey: Pt.privateKeyFromPem(c),
                publicKey: Pt.publicKeyFromPem(l),
              })
            },
          )
        if (Lue("generateKey") && Lue("exportKey"))
          return Ml.globalScope.crypto.subtle
            .generateKey(
              {
                name: "RSASSA-PKCS1-v1_5",
                modulusLength: e,
                publicExponent: Oue(t),
                hash: { name: "SHA-256" },
              },
              true,
              ["sign", "verify"],
            )
            .then(function (a) {
              return Ml.globalScope.crypto.subtle.exportKey(
                "pkcs8",
                a.privateKey,
              )
            })
            .then(undefined, function (a) {
              n(a)
            })
            .then(function (a) {
              if (a) {
                var l = Pt.privateKeyFromAsn1(
                  ee.fromDer(rt.util.createBuffer(a)),
                )
                n(null, {
                  privateKey: l,
                  publicKey: Pt.setRsaPublicKey(l.n, l.e),
                })
              }
            })
        if (Uue("generateKey") && Uue("exportKey")) {
          var i = Ml.globalScope.msCrypto.subtle.generateKey(
            {
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: e,
              publicExponent: Oue(t),
              hash: { name: "SHA-256" },
            },
            true,
            ["sign", "verify"],
          )
          ;(i.oncomplete = function (a) {
            var l = a.target.result,
              c = Ml.globalScope.msCrypto.subtle.exportKey(
                "pkcs8",
                l.privateKey,
              )
            ;(c.oncomplete = function (u) {
              var f = u.target.result,
                p = Pt.privateKeyFromAsn1(ee.fromDer(rt.util.createBuffer(f)))
              n(null, {
                privateKey: p,
                publicKey: Pt.setRsaPublicKey(p.n, p.e),
              })
            }),
              (c.onerror = function (u) {
                n(u)
              })
          }),
            (i.onerror = function (a) {
              n(a)
            })
          return
        }
      } else if (Pue("generateKeyPairSync")) {
        var s = YW.generateKeyPairSync("rsa", {
          modulusLength: e,
          publicExponent: t,
          publicKeyEncoding: { type: "spki", format: "pem" },
          privateKeyEncoding: { type: "pkcs8", format: "pem" },
        })
        return {
          privateKey: Pt.privateKeyFromPem(s.privateKey),
          publicKey: Pt.publicKeyFromPem(s.publicKey),
        }
      }
    }
    var o = Pt.rsa.createKeyPairGenerationState(e, t, r)
    if (!n) return Pt.rsa.stepKeyPairGenerationState(o, 0), o.keys
    Stt(o, r, n)
  }
  Pt.setRsaPublicKey = Pt.rsa.setPublicKey = function (e, t) {
    var r = { n: e, e: t }
    return (
      (r.encrypt = function (n, i, s) {
        if (
          (typeof i == "string"
            ? (i = i.toUpperCase())
            : i === undefined && (i = "RSAES-PKCS1-V1_5"),
          i === "RSAES-PKCS1-V1_5")
        )
          i = {
            encode: function (a, l, c) {
              return Vue(a, l, 2).getBytes()
            },
          }
        else if (i === "RSA-OAEP" || i === "RSAES-OAEP")
          i = {
            encode: function (a, l) {
              return rt.pkcs1.encode_rsa_oaep(l, a, s)
            },
          }
        else if (["RAW", "NONE", "NULL", null].indexOf(i) !== -1)
          i = {
            encode: function (a) {
              return a
            },
          }
        else if (typeof i == "string")
          throw new Error('Unsupported encryption scheme: "' + i + '".')
        var o = i.encode(n, r, true)
        return Pt.rsa.encrypt(o, r, true)
      }),
      (r.verify = function (n, i, s, o) {
        typeof s == "string"
          ? (s = s.toUpperCase())
          : s === undefined && (s = "RSASSA-PKCS1-V1_5"),
          o === undefined && (o = { _parseAllDigestBytes: true }),
          "_parseAllDigestBytes" in o || (o._parseAllDigestBytes = true),
          s === "RSASSA-PKCS1-V1_5"
            ? (s = {
                verify: function (l, c) {
                  c = AT(c, r, true)
                  var u = ee.fromDer(c, {
                      parseAllBytes: o._parseAllDigestBytes,
                    }),
                    f = {},
                    p = []
                  if (!ee.validate(u, xtt, f, p)) {
                    var g = new Error(
                      "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value.",
                    )
                    throw ((g.errors = p), g)
                  }
                  var m = ee.derToOid(f.algorithmIdentifier)
                  if (
                    !(
                      m === rt.oids.md2 ||
                      m === rt.oids.md5 ||
                      m === rt.oids.sha1 ||
                      m === rt.oids.sha224 ||
                      m === rt.oids.sha256 ||
                      m === rt.oids.sha384 ||
                      m === rt.oids.sha512 ||
                      m === rt.oids["sha512-224"] ||
                      m === rt.oids["sha512-256"]
                    )
                  ) {
                    var g = new Error(
                      "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.",
                    )
                    throw ((g.oid = m), g)
                  }
                  if (
                    (m === rt.oids.md2 || m === rt.oids.md5) &&
                    !("parameters" in f)
                  )
                    throw new Error(
                      "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters.",
                    )
                  return l === f.digest
                },
              })
            : (s === "NONE" || s === "NULL" || s === null) &&
              (s = {
                verify: function (l, c) {
                  return (c = AT(c, r, true)), l === c
                },
              })
        var a = Pt.rsa.decrypt(i, r, true, false)
        return s.verify(n, a, r.n.bitLength())
      }),
      r
    )
  }
  Pt.setRsaPrivateKey = Pt.rsa.setPrivateKey = function (
    e,
    t,
    r,
    n,
    i,
    s,
    o,
    a,
  ) {
    var l = { n: e, e: t, d: r, p: n, q: i, dP: s, dQ: o, qInv: a }
    return (
      (l.decrypt = function (c, u, f) {
        typeof u == "string"
          ? (u = u.toUpperCase())
          : u === undefined && (u = "RSAES-PKCS1-V1_5")
        var p = Pt.rsa.decrypt(c, l, false, false)
        if (u === "RSAES-PKCS1-V1_5") u = { decode: AT }
        else if (u === "RSA-OAEP" || u === "RSAES-OAEP")
          u = {
            decode: function (g, m) {
              return rt.pkcs1.decode_rsa_oaep(m, g, f)
            },
          }
        else if (["RAW", "NONE", "NULL", null].indexOf(u) !== -1)
          u = {
            decode: function (g) {
              return g
            },
          }
        else throw new Error('Unsupported encryption scheme: "' + u + '".')
        return u.decode(p, l, false)
      }),
      (l.sign = function (c, u) {
        var f = false
        typeof u == "string" && (u = u.toUpperCase()),
          u === undefined || u === "RSASSA-PKCS1-V1_5"
            ? ((u = { encode: wtt }), (f = 1))
            : (u === "NONE" || u === "NULL" || u === null) &&
              ((u = {
                encode: function () {
                  return c
                },
              }),
              (f = 1))
        var p = u.encode(c, l.n.bitLength())
        return Pt.rsa.encrypt(p, l, f)
      }),
      l
    )
  }
  Pt.wrapRsaPrivateKey = function (e) {
    return ee.create(ee.Class.UNIVERSAL, ee.Type.SEQUENCE, true, [
      ee.create(
        ee.Class.UNIVERSAL,
        ee.Type.INTEGER,
        false,
        ee.integerToDer(0).getBytes(),
      ),
      ee.create(ee.Class.UNIVERSAL, ee.Type.SEQUENCE, true, [
        ee.create(
          ee.Class.UNIVERSAL,
          ee.Type.OID,
          false,
          ee.oidToDer(Pt.oids.rsaEncryption).getBytes(),
        ),
        ee.create(ee.Class.UNIVERSAL, ee.Type.NULL, false, ""),
      ]),
      ee.create(
        ee.Class.UNIVERSAL,
        ee.Type.OCTETSTRING,
        false,
        ee.toDer(e).getBytes(),
      ),
    ])
  }
  Pt.privateKeyFromAsn1 = function (e) {
    var t = {},
      r = []
    if (
      (ee.validate(e, Ctt, t, r) &&
        (e = ee.fromDer(rt.util.createBuffer(t.privateKey))),
      (t = {}),
      (r = []),
      !ee.validate(e, btt, t, r))
    ) {
      var n = new Error(
        "Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.",
      )
      throw ((n.errors = r), n)
    }
    var i, s, o, a, l, c, u, f
    return (
      (i = rt.util.createBuffer(t.privateKeyModulus).toHex()),
      (s = rt.util.createBuffer(t.privateKeyPublicExponent).toHex()),
      (o = rt.util.createBuffer(t.privateKeyPrivateExponent).toHex()),
      (a = rt.util.createBuffer(t.privateKeyPrime1).toHex()),
      (l = rt.util.createBuffer(t.privateKeyPrime2).toHex()),
      (c = rt.util.createBuffer(t.privateKeyExponent1).toHex()),
      (u = rt.util.createBuffer(t.privateKeyExponent2).toHex()),
      (f = rt.util.createBuffer(t.privateKeyCoefficient).toHex()),
      Pt.setRsaPrivateKey(
        new Rr(i, 16),
        new Rr(s, 16),
        new Rr(o, 16),
        new Rr(a, 16),
        new Rr(l, 16),
        new Rr(c, 16),
        new Rr(u, 16),
        new Rr(f, 16),
      )
    )
  }
  Pt.privateKeyToAsn1 = Pt.privateKeyToRSAPrivateKey = function (e) {
    return ee.create(ee.Class.UNIVERSAL, ee.Type.SEQUENCE, true, [
      ee.create(
        ee.Class.UNIVERSAL,
        ee.Type.INTEGER,
        false,
        ee.integerToDer(0).getBytes(),
      ),
      ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, false, Lu(e.n)),
      ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, false, Lu(e.e)),
      ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, false, Lu(e.d)),
      ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, false, Lu(e.p)),
      ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, false, Lu(e.q)),
      ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, false, Lu(e.dP)),
      ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, false, Lu(e.dQ)),
      ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, false, Lu(e.qInv)),
    ])
  }
  Pt.publicKeyFromAsn1 = function (e) {
    var t = {},
      r = []
    if (ee.validate(e, _tt, t, r)) {
      var n = ee.derToOid(t.publicKeyOid)
      if (n !== Pt.oids.rsaEncryption) {
        var i = new Error("Cannot read public key. Unknown OID.")
        throw ((i.oid = n), i)
      }
      e = t.rsaPublicKey
    }
    if (((r = []), !ee.validate(e, Ett, t, r))) {
      var i = new Error(
        "Cannot read public key. ASN.1 object does not contain an RSAPublicKey.",
      )
      throw ((i.errors = r), i)
    }
    var s = rt.util.createBuffer(t.publicKeyModulus).toHex(),
      o = rt.util.createBuffer(t.publicKeyExponent).toHex()
    return Pt.setRsaPublicKey(new Rr(s, 16), new Rr(o, 16))
  }
  Pt.publicKeyToAsn1 = Pt.publicKeyToSubjectPublicKeyInfo = function (e) {
    return ee.create(ee.Class.UNIVERSAL, ee.Type.SEQUENCE, true, [
      ee.create(ee.Class.UNIVERSAL, ee.Type.SEQUENCE, true, [
        ee.create(
          ee.Class.UNIVERSAL,
          ee.Type.OID,
          false,
          ee.oidToDer(Pt.oids.rsaEncryption).getBytes(),
        ),
        ee.create(ee.Class.UNIVERSAL, ee.Type.NULL, false, ""),
      ]),
      ee.create(ee.Class.UNIVERSAL, ee.Type.BITSTRING, false, [
        Pt.publicKeyToRSAPublicKey(e),
      ]),
    ])
  }
  Pt.publicKeyToRSAPublicKey = function (e) {
    return ee.create(ee.Class.UNIVERSAL, ee.Type.SEQUENCE, true, [
      ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, false, Lu(e.n)),
      ee.create(ee.Class.UNIVERSAL, ee.Type.INTEGER, false, Lu(e.e)),
    ])
  }
  function Vue(e, t, r) {
    var n = rt.util.createBuffer(),
      i = Math.ceil(t.n.bitLength() / 8)
    if (e.length > i - 11) {
      var s = new Error("Message is too long for PKCS#1 v1.5 padding.")
      throw ((s.length = e.length), (s.max = i - 11), s)
    }
    n.putByte(0), n.putByte(r)
    var o = i - 3 - e.length,
      a
    if (r === 0 || r === 1) {
      a = r === 0 ? 0 : 255
      for (var l = 0; l < o; ++l) n.putByte(a)
    } else
      for (; o > 0; ) {
        for (var c = 0, u = rt.random.getBytes(o), l = 0; l < o; ++l)
          (a = u.charCodeAt(l)), a === 0 ? ++c : n.putByte(a)
        o = c
      }
    return n.putByte(0), n.putBytes(e), n
  }
  function AT(e, t, r, n) {
    var i = Math.ceil(t.n.bitLength() / 8),
      s = rt.util.createBuffer(e),
      o = s.getByte(),
      a = s.getByte()
    if (
      o !== 0 ||
      (r && a !== 0 && a !== 1) ||
      (!r && a != 2) ||
      (r && a === 0 && typeof n > "u")
    )
      throw new Error("Encryption block is invalid.")
    var l = 0
    if (a === 0) {
      l = i - 3 - n
      for (var c = 0; c < l; ++c)
        if (s.getByte() !== 0) throw new Error("Encryption block is invalid.")
    } else if (a === 1)
      for (l = 0; s.length() > 1; ) {
        if (s.getByte() !== 255) {
          --s.read
          break
        }
        ++l
      }
    else if (a === 2)
      for (l = 0; s.length() > 1; ) {
        if (s.getByte() === 0) {
          --s.read
          break
        }
        ++l
      }
    var u = s.getByte()
    if (u !== 0 || l !== i - 3 - s.length())
      throw new Error("Encryption block is invalid.")
    return s.getBytes()
  }
  function Stt(e, t, r) {
    typeof t == "function" && ((r = t), (t = {})), (t = t || {})
    var n = {
      algorithm: {
        name: t.algorithm || "PRIMEINC",
        options: {
          workers: t.workers || 2,
          workLoad: t.workLoad || 100,
          workerScript: t.workerScript,
        },
      },
    }
    "prng" in t && (n.prng = t.prng), i()
    function i() {
      s(e.pBits, function (a, l) {
        if (a) return r(a)
        if (((e.p = l), e.q !== null)) return o(a, e.q)
        s(e.qBits, o)
      })
    }
    function s(a, l) {
      rt.prime.generateProbablePrime(a, n, l)
    }
    function o(a, l) {
      if (a) return r(a)
      if (((e.q = l), e.p.compareTo(e.q) < 0)) {
        var c = e.p
        ;(e.p = e.q), (e.q = c)
      }
      if (e.p.subtract(Rr.ONE).gcd(e.e).compareTo(Rr.ONE) !== 0) {
        ;(e.p = null), i()
        return
      }
      if (e.q.subtract(Rr.ONE).gcd(e.e).compareTo(Rr.ONE) !== 0) {
        ;(e.q = null), s(e.qBits, o)
        return
      }
      if (
        ((e.p1 = e.p.subtract(Rr.ONE)),
        (e.q1 = e.q.subtract(Rr.ONE)),
        (e.phi = e.p1.multiply(e.q1)),
        e.phi.gcd(e.e).compareTo(Rr.ONE) !== 0)
      ) {
        ;(e.p = e.q = null), i()
        return
      }
      if (((e.n = e.p.multiply(e.q)), e.n.bitLength() !== e.bits)) {
        ;(e.q = null), s(e.qBits, o)
        return
      }
      var u = e.e.modInverse(e.phi)
      ;(e.keys = {
        privateKey: Pt.rsa.setPrivateKey(
          e.n,
          e.e,
          u,
          e.p,
          e.q,
          u.mod(e.p1),
          u.mod(e.q1),
          e.q.modInverse(e.p),
        ),
        publicKey: Pt.rsa.setPublicKey(e.n, e.e),
      }),
        r(null, e.keys)
    }
  }
  function Lu(e) {
    var t = e.toString(16)
    t[0] >= "8" && (t = "00" + t)
    var r = rt.util.hexToBytes(t)
    return r.length > 1 &&
      ((r.charCodeAt(0) === 0 && !(r.charCodeAt(1) & 128)) ||
        (r.charCodeAt(0) === 255 && (r.charCodeAt(1) & 128) === 128))
      ? r.substr(1)
      : r
  }
  function Itt(e) {
    return e <= 100
      ? 27
      : e <= 150
        ? 18
        : e <= 200
          ? 15
          : e <= 250
            ? 12
            : e <= 300
              ? 9
              : e <= 350
                ? 8
                : e <= 400
                  ? 7
                  : e <= 500
                    ? 6
                    : e <= 600
                      ? 5
                      : e <= 800
                        ? 4
                        : e <= 1250
                          ? 3
                          : 2
  }
  function Pue(e) {
    return rt.util.isNodejs && typeof YW[e] == "function"
  }
  function Lue(e) {
    return (
      typeof Ml.globalScope < "u" &&
      typeof Ml.globalScope.crypto == "object" &&
      typeof Ml.globalScope.crypto.subtle == "object" &&
      typeof Ml.globalScope.crypto.subtle[e] == "function"
    )
  }
  function Uue(e) {
    return (
      typeof Ml.globalScope < "u" &&
      typeof Ml.globalScope.msCrypto == "object" &&
      typeof Ml.globalScope.msCrypto.subtle == "object" &&
      typeof Ml.globalScope.msCrypto.subtle[e] == "function"
    )
  }
  function Oue(e) {
    for (
      var t = rt.util.hexToBytes(e.toString(16)),
        r = new Uint8Array(t.length),
        n = 0;
      n < t.length;
      ++n
    )
      r[n] = t.charCodeAt(n)
    return r
  }
})
var KW = _((Akt, Kue) => {
  "use strict"
  var Ne = jt()
  Rh()
  Mc()
  g_()
  Tu()
  Dh()
  fT()
  Hp()
  Tl()
  UW()
  A_()
  Pr()
  typeof Wue > "u" && (Wue = Ne.jsbn.BigInteger)
  var Wue,
    ae = Ne.asn1,
    zt = (Ne.pki = Ne.pki || {})
  Kue.exports = zt.pbe = Ne.pbe = Ne.pbe || {}
  var $p = zt.oids,
    Btt = {
      name: "EncryptedPrivateKeyInfo",
      tagClass: ae.Class.UNIVERSAL,
      type: ae.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
          tagClass: ae.Class.UNIVERSAL,
          type: ae.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "AlgorithmIdentifier.algorithm",
              tagClass: ae.Class.UNIVERSAL,
              type: ae.Type.OID,
              constructed: false,
              capture: "encryptionOid",
            },
            {
              name: "AlgorithmIdentifier.parameters",
              tagClass: ae.Class.UNIVERSAL,
              type: ae.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "encryptionParams",
            },
          ],
        },
        {
          name: "EncryptedPrivateKeyInfo.encryptedData",
          tagClass: ae.Class.UNIVERSAL,
          type: ae.Type.OCTETSTRING,
          constructed: false,
          capture: "encryptedData",
        },
      ],
    },
    Rtt = {
      name: "PBES2Algorithms",
      tagClass: ae.Class.UNIVERSAL,
      type: ae.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "PBES2Algorithms.keyDerivationFunc",
          tagClass: ae.Class.UNIVERSAL,
          type: ae.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "PBES2Algorithms.keyDerivationFunc.oid",
              tagClass: ae.Class.UNIVERSAL,
              type: ae.Type.OID,
              constructed: false,
              capture: "kdfOid",
            },
            {
              name: "PBES2Algorithms.params",
              tagClass: ae.Class.UNIVERSAL,
              type: ae.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "PBES2Algorithms.params.salt",
                  tagClass: ae.Class.UNIVERSAL,
                  type: ae.Type.OCTETSTRING,
                  constructed: false,
                  capture: "kdfSalt",
                },
                {
                  name: "PBES2Algorithms.params.iterationCount",
                  tagClass: ae.Class.UNIVERSAL,
                  type: ae.Type.INTEGER,
                  constructed: false,
                  capture: "kdfIterationCount",
                },
                {
                  name: "PBES2Algorithms.params.keyLength",
                  tagClass: ae.Class.UNIVERSAL,
                  type: ae.Type.INTEGER,
                  constructed: false,
                  optional: true,
                  capture: "keyLength",
                },
                {
                  name: "PBES2Algorithms.params.prf",
                  tagClass: ae.Class.UNIVERSAL,
                  type: ae.Type.SEQUENCE,
                  constructed: true,
                  optional: true,
                  value: [
                    {
                      name: "PBES2Algorithms.params.prf.algorithm",
                      tagClass: ae.Class.UNIVERSAL,
                      type: ae.Type.OID,
                      constructed: false,
                      capture: "prfOid",
                    },
                  ],
                },
              ],
            },
          ],
        },
        {
          name: "PBES2Algorithms.encryptionScheme",
          tagClass: ae.Class.UNIVERSAL,
          type: ae.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "PBES2Algorithms.encryptionScheme.oid",
              tagClass: ae.Class.UNIVERSAL,
              type: ae.Type.OID,
              constructed: false,
              capture: "encOid",
            },
            {
              name: "PBES2Algorithms.encryptionScheme.iv",
              tagClass: ae.Class.UNIVERSAL,
              type: ae.Type.OCTETSTRING,
              constructed: false,
              capture: "encIv",
            },
          ],
        },
      ],
    },
    Dtt = {
      name: "pkcs-12PbeParams",
      tagClass: ae.Class.UNIVERSAL,
      type: ae.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "pkcs-12PbeParams.salt",
          tagClass: ae.Class.UNIVERSAL,
          type: ae.Type.OCTETSTRING,
          constructed: false,
          capture: "salt",
        },
        {
          name: "pkcs-12PbeParams.iterations",
          tagClass: ae.Class.UNIVERSAL,
          type: ae.Type.INTEGER,
          constructed: false,
          capture: "iterations",
        },
      ],
    }
  zt.encryptPrivateKeyInfo = function (e, t, r) {
    ;(r = r || {}),
      (r.saltSize = r.saltSize || 8),
      (r.count = r.count || 2048),
      (r.algorithm = r.algorithm || "aes128"),
      (r.prfAlgorithm = r.prfAlgorithm || "sha1")
    var n = Ne.random.getBytesSync(r.saltSize),
      i = r.count,
      s = ae.integerToDer(i),
      o,
      a,
      l
    if (r.algorithm.indexOf("aes") === 0 || r.algorithm === "des") {
      var c, u, f
      switch (r.algorithm) {
        case "aes128":
          ;(o = 16),
            (c = 16),
            (u = $p["aes128-CBC"]),
            (f = Ne.aes.createEncryptionCipher)
          break
        case "aes192":
          ;(o = 24),
            (c = 16),
            (u = $p["aes192-CBC"]),
            (f = Ne.aes.createEncryptionCipher)
          break
        case "aes256":
          ;(o = 32),
            (c = 16),
            (u = $p["aes256-CBC"]),
            (f = Ne.aes.createEncryptionCipher)
          break
        case "des":
          ;(o = 8),
            (c = 8),
            (u = $p.desCBC),
            (f = Ne.des.createEncryptionCipher)
          break
        default:
          var p = new Error(
            "Cannot encrypt private key. Unknown encryption algorithm.",
          )
          throw ((p.algorithm = r.algorithm), p)
      }
      var g = "hmacWith" + r.prfAlgorithm.toUpperCase(),
        m = Yue(g),
        y = Ne.pkcs5.pbkdf2(t, n, i, o, m),
        v = Ne.random.getBytesSync(c),
        C = f(y)
      C.start(v), C.update(ae.toDer(e)), C.finish(), (l = C.output.getBytes())
      var E = Ttt(n, s, o, g)
      a = ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, true, [
        ae.create(
          ae.Class.UNIVERSAL,
          ae.Type.OID,
          false,
          ae.oidToDer($p.pkcs5PBES2).getBytes(),
        ),
        ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, true, [
          ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, true, [
            ae.create(
              ae.Class.UNIVERSAL,
              ae.Type.OID,
              false,
              ae.oidToDer($p.pkcs5PBKDF2).getBytes(),
            ),
            E,
          ]),
          ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, true, [
            ae.create(
              ae.Class.UNIVERSAL,
              ae.Type.OID,
              false,
              ae.oidToDer(u).getBytes(),
            ),
            ae.create(ae.Class.UNIVERSAL, ae.Type.OCTETSTRING, false, v),
          ]),
        ]),
      ])
    } else if (r.algorithm === "3des") {
      o = 24
      var w = new Ne.util.ByteBuffer(n),
        y = zt.pbe.generatePkcs12Key(t, w, 1, i, o),
        v = zt.pbe.generatePkcs12Key(t, w, 2, i, o),
        C = Ne.des.createEncryptionCipher(y)
      C.start(v),
        C.update(ae.toDer(e)),
        C.finish(),
        (l = C.output.getBytes()),
        (a = ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, true, [
          ae.create(
            ae.Class.UNIVERSAL,
            ae.Type.OID,
            false,
            ae.oidToDer($p["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes(),
          ),
          ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, true, [
            ae.create(ae.Class.UNIVERSAL, ae.Type.OCTETSTRING, false, n),
            ae.create(ae.Class.UNIVERSAL, ae.Type.INTEGER, false, s.getBytes()),
          ]),
        ]))
    } else {
      var p = new Error(
        "Cannot encrypt private key. Unknown encryption algorithm.",
      )
      throw ((p.algorithm = r.algorithm), p)
    }
    var B = ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, true, [
      a,
      ae.create(ae.Class.UNIVERSAL, ae.Type.OCTETSTRING, false, l),
    ])
    return B
  }
  zt.decryptPrivateKeyInfo = function (e, t) {
    var r = null,
      n = {},
      i = []
    if (!ae.validate(e, Btt, n, i)) {
      var s = new Error(
        "Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.",
      )
      throw ((s.errors = i), s)
    }
    var o = ae.derToOid(n.encryptionOid),
      a = zt.pbe.getCipher(o, n.encryptionParams, t),
      l = Ne.util.createBuffer(n.encryptedData)
    return a.update(l), a.finish() && (r = ae.fromDer(a.output)), r
  }
  zt.encryptedPrivateKeyToPem = function (e, t) {
    var r = { type: "ENCRYPTED PRIVATE KEY", body: ae.toDer(e).getBytes() }
    return Ne.pem.encode(r, { maxline: t })
  }
  zt.encryptedPrivateKeyFromPem = function (e) {
    var t = Ne.pem.decode(e)[0]
    if (t.type !== "ENCRYPTED PRIVATE KEY") {
      var r = new Error(
        'Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".',
      )
      throw ((r.headerType = t.type), r)
    }
    if (t.procType && t.procType.type === "ENCRYPTED")
      throw new Error(
        "Could not convert encrypted private key from PEM; PEM is encrypted.",
      )
    return ae.fromDer(t.body)
  }
  zt.encryptRsaPrivateKey = function (e, t, r) {
    if (((r = r || {}), !r.legacy)) {
      var n = zt.wrapRsaPrivateKey(zt.privateKeyToAsn1(e))
      return (
        (n = zt.encryptPrivateKeyInfo(n, t, r)), zt.encryptedPrivateKeyToPem(n)
      )
    }
    var i, s, o, a
    switch (r.algorithm) {
      case "aes128":
        ;(i = "AES-128-CBC"),
          (o = 16),
          (s = Ne.random.getBytesSync(16)),
          (a = Ne.aes.createEncryptionCipher)
        break
      case "aes192":
        ;(i = "AES-192-CBC"),
          (o = 24),
          (s = Ne.random.getBytesSync(16)),
          (a = Ne.aes.createEncryptionCipher)
        break
      case "aes256":
        ;(i = "AES-256-CBC"),
          (o = 32),
          (s = Ne.random.getBytesSync(16)),
          (a = Ne.aes.createEncryptionCipher)
        break
      case "3des":
        ;(i = "DES-EDE3-CBC"),
          (o = 24),
          (s = Ne.random.getBytesSync(8)),
          (a = Ne.des.createEncryptionCipher)
        break
      case "des":
        ;(i = "DES-CBC"),
          (o = 8),
          (s = Ne.random.getBytesSync(8)),
          (a = Ne.des.createEncryptionCipher)
        break
      default:
        var l = new Error(
          'Could not encrypt RSA private key; unsupported encryption algorithm "' +
            r.algorithm +
            '".',
        )
        throw ((l.algorithm = r.algorithm), l)
    }
    var c = Ne.pbe.opensslDeriveBytes(t, s.substr(0, 8), o),
      u = a(c)
    u.start(s), u.update(ae.toDer(zt.privateKeyToAsn1(e))), u.finish()
    var f = {
      type: "RSA PRIVATE KEY",
      procType: { version: "4", type: "ENCRYPTED" },
      dekInfo: {
        algorithm: i,
        parameters: Ne.util.bytesToHex(s).toUpperCase(),
      },
      body: u.output.getBytes(),
    }
    return Ne.pem.encode(f)
  }
  zt.decryptRsaPrivateKey = function (e, t) {
    var r = null,
      n = Ne.pem.decode(e)[0]
    if (
      n.type !== "ENCRYPTED PRIVATE KEY" &&
      n.type !== "PRIVATE KEY" &&
      n.type !== "RSA PRIVATE KEY"
    ) {
      var i = new Error(
        'Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".',
      )
      throw ((i.headerType = i), i)
    }
    if (n.procType && n.procType.type === "ENCRYPTED") {
      var s, o
      switch (n.dekInfo.algorithm) {
        case "DES-CBC":
          ;(s = 8), (o = Ne.des.createDecryptionCipher)
          break
        case "DES-EDE3-CBC":
          ;(s = 24), (o = Ne.des.createDecryptionCipher)
          break
        case "AES-128-CBC":
          ;(s = 16), (o = Ne.aes.createDecryptionCipher)
          break
        case "AES-192-CBC":
          ;(s = 24), (o = Ne.aes.createDecryptionCipher)
          break
        case "AES-256-CBC":
          ;(s = 32), (o = Ne.aes.createDecryptionCipher)
          break
        case "RC2-40-CBC":
          ;(s = 5),
            (o = function (f) {
              return Ne.rc2.createDecryptionCipher(f, 40)
            })
          break
        case "RC2-64-CBC":
          ;(s = 8),
            (o = function (f) {
              return Ne.rc2.createDecryptionCipher(f, 64)
            })
          break
        case "RC2-128-CBC":
          ;(s = 16),
            (o = function (f) {
              return Ne.rc2.createDecryptionCipher(f, 128)
            })
          break
        default:
          var i = new Error(
            'Could not decrypt private key; unsupported encryption algorithm "' +
              n.dekInfo.algorithm +
              '".',
          )
          throw ((i.algorithm = n.dekInfo.algorithm), i)
      }
      var a = Ne.util.hexToBytes(n.dekInfo.parameters),
        l = Ne.pbe.opensslDeriveBytes(t, a.substr(0, 8), s),
        c = o(l)
      if ((c.start(a), c.update(Ne.util.createBuffer(n.body)), c.finish()))
        r = c.output.getBytes()
      else return r
    } else r = n.body
    return (
      n.type === "ENCRYPTED PRIVATE KEY"
        ? (r = zt.decryptPrivateKeyInfo(ae.fromDer(r), t))
        : (r = ae.fromDer(r)),
      r !== null && (r = zt.privateKeyFromAsn1(r)),
      r
    )
  }
  zt.pbe.generatePkcs12Key = function (e, t, r, n, i, s) {
    var o, a
    if (typeof s > "u" || s === null) {
      if (!("sha1" in Ne.md))
        throw new Error('"sha1" hash algorithm unavailable.')
      s = Ne.md.sha1.create()
    }
    var l = s.digestLength,
      c = s.blockLength,
      u = new Ne.util.ByteBuffer(),
      f = new Ne.util.ByteBuffer()
    if (e != null) {
      for (a = 0; a < e.length; a++) f.putInt16(e.charCodeAt(a))
      f.putInt16(0)
    }
    var p = f.length(),
      g = t.length(),
      m = new Ne.util.ByteBuffer()
    m.fillWithByte(r, c)
    var y = c * Math.ceil(g / c),
      v = new Ne.util.ByteBuffer()
    for (a = 0; a < y; a++) v.putByte(t.at(a % g))
    var C = c * Math.ceil(p / c),
      E = new Ne.util.ByteBuffer()
    for (a = 0; a < C; a++) E.putByte(f.at(a % p))
    var w = v
    w.putBuffer(E)
    for (var B = Math.ceil(i / l), T = 1; T <= B; T++) {
      var N = new Ne.util.ByteBuffer()
      N.putBytes(m.bytes()), N.putBytes(w.bytes())
      for (var W = 0; W < n; W++)
        s.start(), s.update(N.getBytes()), (N = s.digest())
      var Z = new Ne.util.ByteBuffer()
      for (a = 0; a < c; a++) Z.putByte(N.at(a % l))
      var te = Math.ceil(g / c) + Math.ceil(p / c),
        Y = new Ne.util.ByteBuffer()
      for (o = 0; o < te; o++) {
        var U = new Ne.util.ByteBuffer(w.getBytes(c)),
          ce = 511
        for (a = Z.length() - 1; a >= 0; a--)
          (ce = ce >> 8), (ce += Z.at(a) + U.at(a)), U.setAt(a, ce & 255)
        Y.putBuffer(U)
      }
      ;(w = Y), u.putBuffer(N)
    }
    return u.truncate(u.length() - i), u
  }
  zt.pbe.getCipher = function (e, t, r) {
    switch (e) {
      case zt.oids.pkcs5PBES2:
        return zt.pbe.getCipherForPBES2(e, t, r)
      case zt.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
      case zt.oids["pbewithSHAAnd40BitRC2-CBC"]:
        return zt.pbe.getCipherForPKCS12PBE(e, t, r)
      default:
        var n = new Error(
          "Cannot read encrypted PBE data block. Unsupported OID.",
        )
        throw (
          ((n.oid = e),
          (n.supportedOids = [
            "pkcs5PBES2",
            "pbeWithSHAAnd3-KeyTripleDES-CBC",
            "pbewithSHAAnd40BitRC2-CBC",
          ]),
          n)
        )
    }
  }
  zt.pbe.getCipherForPBES2 = function (e, t, r) {
    var n = {},
      i = []
    if (!ae.validate(t, Rtt, n, i)) {
      var s = new Error(
        "Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.",
      )
      throw ((s.errors = i), s)
    }
    if (((e = ae.derToOid(n.kdfOid)), e !== zt.oids.pkcs5PBKDF2)) {
      var s = new Error(
        "Cannot read encrypted private key. Unsupported key derivation function OID.",
      )
      throw ((s.oid = e), (s.supportedOids = ["pkcs5PBKDF2"]), s)
    }
    if (
      ((e = ae.derToOid(n.encOid)),
      e !== zt.oids["aes128-CBC"] &&
        e !== zt.oids["aes192-CBC"] &&
        e !== zt.oids["aes256-CBC"] &&
        e !== zt.oids["des-EDE3-CBC"] &&
        e !== zt.oids.desCBC)
    ) {
      var s = new Error(
        "Cannot read encrypted private key. Unsupported encryption scheme OID.",
      )
      throw (
        ((s.oid = e),
        (s.supportedOids = [
          "aes128-CBC",
          "aes192-CBC",
          "aes256-CBC",
          "des-EDE3-CBC",
          "desCBC",
        ]),
        s)
      )
    }
    var o = n.kdfSalt,
      a = Ne.util.createBuffer(n.kdfIterationCount)
    a = a.getInt(a.length() << 3)
    var l, c
    switch (zt.oids[e]) {
      case "aes128-CBC":
        ;(l = 16), (c = Ne.aes.createDecryptionCipher)
        break
      case "aes192-CBC":
        ;(l = 24), (c = Ne.aes.createDecryptionCipher)
        break
      case "aes256-CBC":
        ;(l = 32), (c = Ne.aes.createDecryptionCipher)
        break
      case "des-EDE3-CBC":
        ;(l = 24), (c = Ne.des.createDecryptionCipher)
        break
      case "desCBC":
        ;(l = 8), (c = Ne.des.createDecryptionCipher)
        break
    }
    var u = $ue(n.prfOid),
      f = Ne.pkcs5.pbkdf2(r, o, a, l, u),
      p = n.encIv,
      g = c(f)
    return g.start(p), g
  }
  zt.pbe.getCipherForPKCS12PBE = function (e, t, r) {
    var n = {},
      i = []
    if (!ae.validate(t, Dtt, n, i)) {
      var s = new Error(
        "Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.",
      )
      throw ((s.errors = i), s)
    }
    var o = Ne.util.createBuffer(n.salt),
      a = Ne.util.createBuffer(n.iterations)
    a = a.getInt(a.length() << 3)
    var l, c, u
    switch (e) {
      case zt.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        ;(l = 24), (c = 8), (u = Ne.des.startDecrypting)
        break
      case zt.oids["pbewithSHAAnd40BitRC2-CBC"]:
        ;(l = 5),
          (c = 8),
          (u = function (y, v) {
            var C = Ne.rc2.createDecryptionCipher(y, 40)
            return C.start(v, null), C
          })
        break
      default:
        var s = new Error(
          "Cannot read PKCS #12 PBE data block. Unsupported OID.",
        )
        throw ((s.oid = e), s)
    }
    var f = $ue(n.prfOid),
      p = zt.pbe.generatePkcs12Key(r, o, 1, a, l, f)
    f.start()
    var g = zt.pbe.generatePkcs12Key(r, o, 2, a, c, f)
    return u(p, g)
  }
  zt.pbe.opensslDeriveBytes = function (e, t, r, n) {
    if (typeof n > "u" || n === null) {
      if (!("md5" in Ne.md))
        throw new Error('"md5" hash algorithm unavailable.')
      n = Ne.md.md5.create()
    }
    t === null && (t = "")
    for (var i = [Gue(n, e + t)], s = 16, o = 1; s < r; ++o, s += 16)
      i.push(Gue(n, i[o - 1] + e + t))
    return i.join("").substr(0, r)
  }
  function Gue(e, t) {
    return e.start().update(t).digest().getBytes()
  }
  function $ue(e) {
    var t
    if (!e) t = "hmacWithSHA1"
    else if (((t = zt.oids[ae.derToOid(e)]), !t)) {
      var r = new Error("Unsupported PRF OID.")
      throw (
        ((r.oid = e),
        (r.supported = [
          "hmacWithSHA1",
          "hmacWithSHA224",
          "hmacWithSHA256",
          "hmacWithSHA384",
          "hmacWithSHA512",
        ]),
        r)
      )
    }
    return Yue(t)
  }
  function Yue(e) {
    var t = Ne.md
    switch (e) {
      case "hmacWithSHA224":
        t = Ne.md.sha512
      case "hmacWithSHA1":
      case "hmacWithSHA256":
      case "hmacWithSHA384":
      case "hmacWithSHA512":
        e = e.substr(8).toLowerCase()
        break
      default:
        var r = new Error("Unsupported PRF algorithm.")
        throw (
          ((r.algorithm = e),
          (r.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512",
          ]),
          r)
        )
    }
    if (!t || !(e in t)) throw new Error("Unknown hash algorithm: " + e)
    return t[e].create()
  }
  function Ttt(e, t, r, n) {
    var i = ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, true, [
      ae.create(ae.Class.UNIVERSAL, ae.Type.OCTETSTRING, false, e),
      ae.create(ae.Class.UNIVERSAL, ae.Type.INTEGER, false, t.getBytes()),
    ])
    return (
      n !== "hmacWithSHA1" &&
        i.value.push(
          ae.create(
            ae.Class.UNIVERSAL,
            ae.Type.INTEGER,
            false,
            Ne.util.hexToBytes(r.toString(16)),
          ),
          ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, true, [
            ae.create(
              ae.Class.UNIVERSAL,
              ae.Type.OID,
              false,
              ae.oidToDer(zt.oids[n]).getBytes(),
            ),
            ae.create(ae.Class.UNIVERSAL, ae.Type.NULL, false, ""),
          ]),
        ),
      i
    )
  }
})
var zW = _((ykt, jue) => {
  "use strict"
  var Ey = jt()
  Mc()
  Pr()
  var Qe = Ey.asn1,
    _y = (jue.exports = Ey.pkcs7asn1 = Ey.pkcs7asn1 || {})
  Ey.pkcs7 = Ey.pkcs7 || {}
  Ey.pkcs7.asn1 = _y
  var zue = {
    name: "ContentInfo",
    tagClass: Qe.Class.UNIVERSAL,
    type: Qe.Type.SEQUENCE,
    constructed: true,
    value: [
      {
        name: "ContentInfo.ContentType",
        tagClass: Qe.Class.UNIVERSAL,
        type: Qe.Type.OID,
        constructed: false,
        capture: "contentType",
      },
      {
        name: "ContentInfo.content",
        tagClass: Qe.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        captureAsn1: "content",
      },
    ],
  }
  _y.contentInfoValidator = zue
  var Jue = {
    name: "EncryptedContentInfo",
    tagClass: Qe.Class.UNIVERSAL,
    type: Qe.Type.SEQUENCE,
    constructed: true,
    value: [
      {
        name: "EncryptedContentInfo.contentType",
        tagClass: Qe.Class.UNIVERSAL,
        type: Qe.Type.OID,
        constructed: false,
        capture: "contentType",
      },
      {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm",
        tagClass: Qe.Class.UNIVERSAL,
        type: Qe.Type.SEQUENCE,
        constructed: true,
        value: [
          {
            name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
            tagClass: Qe.Class.UNIVERSAL,
            type: Qe.Type.OID,
            constructed: false,
            capture: "encAlgorithm",
          },
          {
            name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
            tagClass: Qe.Class.UNIVERSAL,
            captureAsn1: "encParameter",
          },
        ],
      },
      {
        name: "EncryptedContentInfo.encryptedContent",
        tagClass: Qe.Class.CONTEXT_SPECIFIC,
        type: 0,
        capture: "encryptedContent",
        captureAsn1: "encryptedContentAsn1",
      },
    ],
  }
  _y.envelopedDataValidator = {
    name: "EnvelopedData",
    tagClass: Qe.Class.UNIVERSAL,
    type: Qe.Type.SEQUENCE,
    constructed: true,
    value: [
      {
        name: "EnvelopedData.Version",
        tagClass: Qe.Class.UNIVERSAL,
        type: Qe.Type.INTEGER,
        constructed: false,
        capture: "version",
      },
      {
        name: "EnvelopedData.RecipientInfos",
        tagClass: Qe.Class.UNIVERSAL,
        type: Qe.Type.SET,
        constructed: true,
        captureAsn1: "recipientInfos",
      },
    ].concat(Jue),
  }
  _y.encryptedDataValidator = {
    name: "EncryptedData",
    tagClass: Qe.Class.UNIVERSAL,
    type: Qe.Type.SEQUENCE,
    constructed: true,
    value: [
      {
        name: "EncryptedData.Version",
        tagClass: Qe.Class.UNIVERSAL,
        type: Qe.Type.INTEGER,
        constructed: false,
        capture: "version",
      },
    ].concat(Jue),
  }
  var ktt = {
    name: "SignerInfo",
    tagClass: Qe.Class.UNIVERSAL,
    type: Qe.Type.SEQUENCE,
    constructed: true,
    value: [
      {
        name: "SignerInfo.version",
        tagClass: Qe.Class.UNIVERSAL,
        type: Qe.Type.INTEGER,
        constructed: false,
      },
      {
        name: "SignerInfo.issuerAndSerialNumber",
        tagClass: Qe.Class.UNIVERSAL,
        type: Qe.Type.SEQUENCE,
        constructed: true,
        value: [
          {
            name: "SignerInfo.issuerAndSerialNumber.issuer",
            tagClass: Qe.Class.UNIVERSAL,
            type: Qe.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "issuer",
          },
          {
            name: "SignerInfo.issuerAndSerialNumber.serialNumber",
            tagClass: Qe.Class.UNIVERSAL,
            type: Qe.Type.INTEGER,
            constructed: false,
            capture: "serial",
          },
        ],
      },
      {
        name: "SignerInfo.digestAlgorithm",
        tagClass: Qe.Class.UNIVERSAL,
        type: Qe.Type.SEQUENCE,
        constructed: true,
        value: [
          {
            name: "SignerInfo.digestAlgorithm.algorithm",
            tagClass: Qe.Class.UNIVERSAL,
            type: Qe.Type.OID,
            constructed: false,
            capture: "digestAlgorithm",
          },
          {
            name: "SignerInfo.digestAlgorithm.parameter",
            tagClass: Qe.Class.UNIVERSAL,
            constructed: false,
            captureAsn1: "digestParameter",
            optional: true,
          },
        ],
      },
      {
        name: "SignerInfo.authenticatedAttributes",
        tagClass: Qe.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: "authenticatedAttributes",
      },
      {
        name: "SignerInfo.digestEncryptionAlgorithm",
        tagClass: Qe.Class.UNIVERSAL,
        type: Qe.Type.SEQUENCE,
        constructed: true,
        capture: "signatureAlgorithm",
      },
      {
        name: "SignerInfo.encryptedDigest",
        tagClass: Qe.Class.UNIVERSAL,
        type: Qe.Type.OCTETSTRING,
        constructed: false,
        capture: "signature",
      },
      {
        name: "SignerInfo.unauthenticatedAttributes",
        tagClass: Qe.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        capture: "unauthenticatedAttributes",
      },
    ],
  }
  _y.signedDataValidator = {
    name: "SignedData",
    tagClass: Qe.Class.UNIVERSAL,
    type: Qe.Type.SEQUENCE,
    constructed: true,
    value: [
      {
        name: "SignedData.Version",
        tagClass: Qe.Class.UNIVERSAL,
        type: Qe.Type.INTEGER,
        constructed: false,
        capture: "version",
      },
      {
        name: "SignedData.DigestAlgorithms",
        tagClass: Qe.Class.UNIVERSAL,
        type: Qe.Type.SET,
        constructed: true,
        captureAsn1: "digestAlgorithms",
      },
      zue,
      {
        name: "SignedData.Certificates",
        tagClass: Qe.Class.CONTEXT_SPECIFIC,
        type: 0,
        optional: true,
        captureAsn1: "certificates",
      },
      {
        name: "SignedData.CertificateRevocationLists",
        tagClass: Qe.Class.CONTEXT_SPECIFIC,
        type: 1,
        optional: true,
        captureAsn1: "crls",
      },
      {
        name: "SignedData.SignerInfos",
        tagClass: Qe.Class.UNIVERSAL,
        type: Qe.Type.SET,
        capture: "signerInfos",
        optional: true,
        value: [ktt],
      },
    ],
  }
  _y.recipientInfoValidator = {
    name: "RecipientInfo",
    tagClass: Qe.Class.UNIVERSAL,
    type: Qe.Type.SEQUENCE,
    constructed: true,
    value: [
      {
        name: "RecipientInfo.version",
        tagClass: Qe.Class.UNIVERSAL,
        type: Qe.Type.INTEGER,
        constructed: false,
        capture: "version",
      },
      {
        name: "RecipientInfo.issuerAndSerial",
        tagClass: Qe.Class.UNIVERSAL,
        type: Qe.Type.SEQUENCE,
        constructed: true,
        value: [
          {
            name: "RecipientInfo.issuerAndSerial.issuer",
            tagClass: Qe.Class.UNIVERSAL,
            type: Qe.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "issuer",
          },
          {
            name: "RecipientInfo.issuerAndSerial.serialNumber",
            tagClass: Qe.Class.UNIVERSAL,
            type: Qe.Type.INTEGER,
            constructed: false,
            capture: "serial",
          },
        ],
      },
      {
        name: "RecipientInfo.keyEncryptionAlgorithm",
        tagClass: Qe.Class.UNIVERSAL,
        type: Qe.Type.SEQUENCE,
        constructed: true,
        value: [
          {
            name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
            tagClass: Qe.Class.UNIVERSAL,
            type: Qe.Type.OID,
            constructed: false,
            capture: "encAlgorithm",
          },
          {
            name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
            tagClass: Qe.Class.UNIVERSAL,
            constructed: false,
            captureAsn1: "encParameter",
            optional: true,
          },
        ],
      },
      {
        name: "RecipientInfo.encryptedKey",
        tagClass: Qe.Class.UNIVERSAL,
        type: Qe.Type.OCTETSTRING,
        constructed: false,
        capture: "encKey",
      },
    ],
  }
})
var JW = _((vkt, Zue) => {
  "use strict"
  var Yp = jt()
  Pr()
  Yp.mgf = Yp.mgf || {}
  var Mtt = (Zue.exports = Yp.mgf.mgf1 = Yp.mgf1 = Yp.mgf1 || {})
  Mtt.create = function (e) {
    var t = {
      generate: function (r, n) {
        for (
          var i = new Yp.util.ByteBuffer(),
            s = Math.ceil(n / e.digestLength),
            o = 0;
          o < s;
          o++
        ) {
          var a = new Yp.util.ByteBuffer()
          a.putInt32(o),
            e.start(),
            e.update(r + a.getBytes()),
            i.putBuffer(e.digest())
        }
        return i.truncate(i.length() - n), i.getBytes()
      },
    }
    return t
  }
})
var ede = _((Ckt, Xue) => {
  "use strict"
  var yT = jt()
  JW()
  Xue.exports = yT.mgf = yT.mgf || {}
  yT.mgf.mgf1 = yT.mgf1
})
var vT = _((bkt, tde) => {
  "use strict"
  var Kp = jt()
  Tl()
  Pr()
  var Ftt = (tde.exports = Kp.pss = Kp.pss || {})
  Ftt.create = function (e) {
    arguments.length === 3 &&
      (e = { md: arguments[0], mgf: arguments[1], saltLength: arguments[2] })
    var t = e.md,
      r = e.mgf,
      n = t.digestLength,
      i = e.salt || null
    typeof i == "string" && (i = Kp.util.createBuffer(i))
    var s
    if ("saltLength" in e) s = e.saltLength
    else if (i !== null) s = i.length()
    else
      throw new Error("Salt length not specified or specific salt not given.")
    if (i !== null && i.length() !== s)
      throw new Error("Given salt length does not match length of given salt.")
    var o = e.prng || Kp.random,
      a = {}
    return (
      (a.encode = function (l, c) {
        var u,
          f = c - 1,
          p = Math.ceil(f / 8),
          g = l.digest().getBytes()
        if (p < n + s + 2) throw new Error("Message is too long to encrypt.")
        var m
        i === null ? (m = o.getBytesSync(s)) : (m = i.bytes())
        var y = new Kp.util.ByteBuffer()
        y.fillWithByte(0, 8),
          y.putBytes(g),
          y.putBytes(m),
          t.start(),
          t.update(y.getBytes())
        var v = t.digest().getBytes(),
          C = new Kp.util.ByteBuffer()
        C.fillWithByte(0, p - s - n - 2), C.putByte(1), C.putBytes(m)
        var E = C.getBytes(),
          w = p - n - 1,
          B = r.generate(v, w),
          T = ""
        for (u = 0; u < w; u++)
          T += String.fromCharCode(E.charCodeAt(u) ^ B.charCodeAt(u))
        var N = (65280 >> (8 * p - f)) & 255
        return (
          (T = String.fromCharCode(T.charCodeAt(0) & ~N) + T.substr(1)),
          T + v + "\xBC"
        )
      }),
      (a.verify = function (l, c, u) {
        var f,
          p = u - 1,
          g = Math.ceil(p / 8)
        if (((c = c.substr(-g)), g < n + s + 2))
          throw new Error(
            "Inconsistent parameters to PSS signature verification.",
          )
        if (c.charCodeAt(g - 1) !== 188)
          throw new Error("Encoded message does not end in 0xBC.")
        var m = g - n - 1,
          y = c.substr(0, m),
          v = c.substr(m, n),
          C = (65280 >> (8 * g - p)) & 255
        if (y.charCodeAt(0) & C)
          throw new Error("Bits beyond keysize not zero as expected.")
        var E = r.generate(v, m),
          w = ""
        for (f = 0; f < m; f++)
          w += String.fromCharCode(y.charCodeAt(f) ^ E.charCodeAt(f))
        w = String.fromCharCode(w.charCodeAt(0) & ~C) + w.substr(1)
        var B = g - n - s - 2
        for (f = 0; f < B; f++)
          if (w.charCodeAt(f) !== 0)
            throw new Error("Leftmost octets not zero as expected")
        if (w.charCodeAt(B) !== 1)
          throw new Error("Inconsistent PSS signature, 0x01 marker not found")
        var T = w.substr(-s),
          N = new Kp.util.ByteBuffer()
        N.fillWithByte(0, 8),
          N.putBytes(l),
          N.putBytes(T),
          t.start(),
          t.update(N.getBytes())
        var W = t.digest().getBytes()
        return v === W
      }),
      a
    )
  }
})
var ET = _((Ekt, ode) => {
  "use strict"
  var nt = jt()
  Rh()
  Mc()
  g_()
  Tu()
  ede()
  Dh()
  Hp()
  vT()
  A_()
  Pr()
  var R = nt.asn1,
    we = (ode.exports = nt.pki = nt.pki || {}),
    Dr = we.oids,
    ui = {}
  ui.CN = Dr.commonName
  ui.commonName = "CN"
  ui.C = Dr.countryName
  ui.countryName = "C"
  ui.L = Dr.localityName
  ui.localityName = "L"
  ui.ST = Dr.stateOrProvinceName
  ui.stateOrProvinceName = "ST"
  ui.O = Dr.organizationName
  ui.organizationName = "O"
  ui.OU = Dr.organizationalUnitName
  ui.organizationalUnitName = "OU"
  ui.E = Dr.emailAddress
  ui.emailAddress = "E"
  var nde = nt.pki.rsa.publicKeyValidator,
    Qtt = {
      name: "Certificate",
      tagClass: R.Class.UNIVERSAL,
      type: R.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "Certificate.TBSCertificate",
          tagClass: R.Class.UNIVERSAL,
          type: R.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "tbsCertificate",
          value: [
            {
              name: "Certificate.TBSCertificate.version",
              tagClass: R.Class.CONTEXT_SPECIFIC,
              type: 0,
              constructed: true,
              optional: true,
              value: [
                {
                  name: "Certificate.TBSCertificate.version.integer",
                  tagClass: R.Class.UNIVERSAL,
                  type: R.Type.INTEGER,
                  constructed: false,
                  capture: "certVersion",
                },
              ],
            },
            {
              name: "Certificate.TBSCertificate.serialNumber",
              tagClass: R.Class.UNIVERSAL,
              type: R.Type.INTEGER,
              constructed: false,
              capture: "certSerialNumber",
            },
            {
              name: "Certificate.TBSCertificate.signature",
              tagClass: R.Class.UNIVERSAL,
              type: R.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "Certificate.TBSCertificate.signature.algorithm",
                  tagClass: R.Class.UNIVERSAL,
                  type: R.Type.OID,
                  constructed: false,
                  capture: "certinfoSignatureOid",
                },
                {
                  name: "Certificate.TBSCertificate.signature.parameters",
                  tagClass: R.Class.UNIVERSAL,
                  optional: true,
                  captureAsn1: "certinfoSignatureParams",
                },
              ],
            },
            {
              name: "Certificate.TBSCertificate.issuer",
              tagClass: R.Class.UNIVERSAL,
              type: R.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "certIssuer",
            },
            {
              name: "Certificate.TBSCertificate.validity",
              tagClass: R.Class.UNIVERSAL,
              type: R.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "Certificate.TBSCertificate.validity.notBefore (utc)",
                  tagClass: R.Class.UNIVERSAL,
                  type: R.Type.UTCTIME,
                  constructed: false,
                  optional: true,
                  capture: "certValidity1UTCTime",
                },
                {
                  name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
                  tagClass: R.Class.UNIVERSAL,
                  type: R.Type.GENERALIZEDTIME,
                  constructed: false,
                  optional: true,
                  capture: "certValidity2GeneralizedTime",
                },
                {
                  name: "Certificate.TBSCertificate.validity.notAfter (utc)",
                  tagClass: R.Class.UNIVERSAL,
                  type: R.Type.UTCTIME,
                  constructed: false,
                  optional: true,
                  capture: "certValidity3UTCTime",
                },
                {
                  name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
                  tagClass: R.Class.UNIVERSAL,
                  type: R.Type.GENERALIZEDTIME,
                  constructed: false,
                  optional: true,
                  capture: "certValidity4GeneralizedTime",
                },
              ],
            },
            {
              name: "Certificate.TBSCertificate.subject",
              tagClass: R.Class.UNIVERSAL,
              type: R.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "certSubject",
            },
            nde,
            {
              name: "Certificate.TBSCertificate.issuerUniqueID",
              tagClass: R.Class.CONTEXT_SPECIFIC,
              type: 1,
              constructed: true,
              optional: true,
              value: [
                {
                  name: "Certificate.TBSCertificate.issuerUniqueID.id",
                  tagClass: R.Class.UNIVERSAL,
                  type: R.Type.BITSTRING,
                  constructed: false,
                  captureBitStringValue: "certIssuerUniqueId",
                },
              ],
            },
            {
              name: "Certificate.TBSCertificate.subjectUniqueID",
              tagClass: R.Class.CONTEXT_SPECIFIC,
              type: 2,
              constructed: true,
              optional: true,
              value: [
                {
                  name: "Certificate.TBSCertificate.subjectUniqueID.id",
                  tagClass: R.Class.UNIVERSAL,
                  type: R.Type.BITSTRING,
                  constructed: false,
                  captureBitStringValue: "certSubjectUniqueId",
                },
              ],
            },
            {
              name: "Certificate.TBSCertificate.extensions",
              tagClass: R.Class.CONTEXT_SPECIFIC,
              type: 3,
              constructed: true,
              captureAsn1: "certExtensions",
              optional: true,
            },
          ],
        },
        {
          name: "Certificate.signatureAlgorithm",
          tagClass: R.Class.UNIVERSAL,
          type: R.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "Certificate.signatureAlgorithm.algorithm",
              tagClass: R.Class.UNIVERSAL,
              type: R.Type.OID,
              constructed: false,
              capture: "certSignatureOid",
            },
            {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: R.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "certSignatureParams",
            },
          ],
        },
        {
          name: "Certificate.signatureValue",
          tagClass: R.Class.UNIVERSAL,
          type: R.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "certSignature",
        },
      ],
    },
    Ntt = {
      name: "rsapss",
      tagClass: R.Class.UNIVERSAL,
      type: R.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "rsapss.hashAlgorithm",
          tagClass: R.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          value: [
            {
              name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
              tagClass: R.Class.UNIVERSAL,
              type: R.Class.SEQUENCE,
              constructed: true,
              optional: true,
              value: [
                {
                  name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
                  tagClass: R.Class.UNIVERSAL,
                  type: R.Type.OID,
                  constructed: false,
                  capture: "hashOid",
                },
              ],
            },
          ],
        },
        {
          name: "rsapss.maskGenAlgorithm",
          tagClass: R.Class.CONTEXT_SPECIFIC,
          type: 1,
          constructed: true,
          value: [
            {
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
              tagClass: R.Class.UNIVERSAL,
              type: R.Class.SEQUENCE,
              constructed: true,
              optional: true,
              value: [
                {
                  name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
                  tagClass: R.Class.UNIVERSAL,
                  type: R.Type.OID,
                  constructed: false,
                  capture: "maskGenOid",
                },
                {
                  name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
                  tagClass: R.Class.UNIVERSAL,
                  type: R.Type.SEQUENCE,
                  constructed: true,
                  value: [
                    {
                      name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
                      tagClass: R.Class.UNIVERSAL,
                      type: R.Type.OID,
                      constructed: false,
                      capture: "maskGenHashOid",
                    },
                  ],
                },
              ],
            },
          ],
        },
        {
          name: "rsapss.saltLength",
          tagClass: R.Class.CONTEXT_SPECIFIC,
          type: 2,
          optional: true,
          value: [
            {
              name: "rsapss.saltLength.saltLength",
              tagClass: R.Class.UNIVERSAL,
              type: R.Class.INTEGER,
              constructed: false,
              capture: "saltLength",
            },
          ],
        },
        {
          name: "rsapss.trailerField",
          tagClass: R.Class.CONTEXT_SPECIFIC,
          type: 3,
          optional: true,
          value: [
            {
              name: "rsapss.trailer.trailer",
              tagClass: R.Class.UNIVERSAL,
              type: R.Class.INTEGER,
              constructed: false,
              capture: "trailer",
            },
          ],
        },
      ],
    },
    Ptt = {
      name: "CertificationRequestInfo",
      tagClass: R.Class.UNIVERSAL,
      type: R.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "certificationRequestInfo",
      value: [
        {
          name: "CertificationRequestInfo.integer",
          tagClass: R.Class.UNIVERSAL,
          type: R.Type.INTEGER,
          constructed: false,
          capture: "certificationRequestInfoVersion",
        },
        {
          name: "CertificationRequestInfo.subject",
          tagClass: R.Class.UNIVERSAL,
          type: R.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfoSubject",
        },
        nde,
        {
          name: "CertificationRequestInfo.attributes",
          tagClass: R.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          capture: "certificationRequestInfoAttributes",
          value: [
            {
              name: "CertificationRequestInfo.attributes",
              tagClass: R.Class.UNIVERSAL,
              type: R.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "CertificationRequestInfo.attributes.type",
                  tagClass: R.Class.UNIVERSAL,
                  type: R.Type.OID,
                  constructed: false,
                },
                {
                  name: "CertificationRequestInfo.attributes.value",
                  tagClass: R.Class.UNIVERSAL,
                  type: R.Type.SET,
                  constructed: true,
                },
              ],
            },
          ],
        },
      ],
    },
    Ltt = {
      name: "CertificationRequest",
      tagClass: R.Class.UNIVERSAL,
      type: R.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "csr",
      value: [
        Ptt,
        {
          name: "CertificationRequest.signatureAlgorithm",
          tagClass: R.Class.UNIVERSAL,
          type: R.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "CertificationRequest.signatureAlgorithm.algorithm",
              tagClass: R.Class.UNIVERSAL,
              type: R.Type.OID,
              constructed: false,
              capture: "csrSignatureOid",
            },
            {
              name: "CertificationRequest.signatureAlgorithm.parameters",
              tagClass: R.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "csrSignatureParams",
            },
          ],
        },
        {
          name: "CertificationRequest.signature",
          tagClass: R.Class.UNIVERSAL,
          type: R.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "csrSignature",
        },
      ],
    }
  we.RDNAttributesAsArray = function (e, t) {
    for (var r = [], n, i, s, o = 0; o < e.value.length; ++o) {
      n = e.value[o]
      for (var a = 0; a < n.value.length; ++a)
        (s = {}),
          (i = n.value[a]),
          (s.type = R.derToOid(i.value[0].value)),
          (s.value = i.value[1].value),
          (s.valueTagClass = i.value[1].type),
          s.type in Dr &&
            ((s.name = Dr[s.type]), s.name in ui && (s.shortName = ui[s.name])),
          t && (t.update(s.type), t.update(s.value)),
          r.push(s)
    }
    return r
  }
  we.CRIAttributesAsArray = function (e) {
    for (var t = [], r = 0; r < e.length; ++r)
      for (
        var n = e[r],
          i = R.derToOid(n.value[0].value),
          s = n.value[1].value,
          o = 0;
        o < s.length;
        ++o
      ) {
        var a = {}
        if (
          ((a.type = i),
          (a.value = s[o].value),
          (a.valueTagClass = s[o].type),
          a.type in Dr &&
            ((a.name = Dr[a.type]), a.name in ui && (a.shortName = ui[a.name])),
          a.type === Dr.extensionRequest)
        ) {
          a.extensions = []
          for (var l = 0; l < a.value.length; ++l)
            a.extensions.push(we.certificateExtensionFromAsn1(a.value[l]))
        }
        t.push(a)
      }
    return t
  }
  function Mh(e, t) {
    typeof t == "string" && (t = { shortName: t })
    for (var r = null, n, i = 0; r === null && i < e.attributes.length; ++i)
      (n = e.attributes[i]),
        ((t.type && t.type === n.type) ||
          (t.name && t.name === n.name) ||
          (t.shortName && t.shortName === n.shortName)) &&
          (r = n)
    return r
  }
  var CT = function (e, t, r) {
      var n = {}
      if (e !== Dr["RSASSA-PSS"]) return n
      r &&
        (n = {
          hash: { algorithmOid: Dr.sha1 },
          mgf: { algorithmOid: Dr.mgf1, hash: { algorithmOid: Dr.sha1 } },
          saltLength: 20,
        })
      var i = {},
        s = []
      if (!R.validate(t, Ntt, i, s)) {
        var o = new Error("Cannot read RSASSA-PSS parameter block.")
        throw ((o.errors = s), o)
      }
      return (
        i.hashOid !== undefined &&
          ((n.hash = n.hash || {}),
          (n.hash.algorithmOid = R.derToOid(i.hashOid))),
        i.maskGenOid !== undefined &&
          ((n.mgf = n.mgf || {}),
          (n.mgf.algorithmOid = R.derToOid(i.maskGenOid)),
          (n.mgf.hash = n.mgf.hash || {}),
          (n.mgf.hash.algorithmOid = R.derToOid(i.maskGenHashOid))),
        i.saltLength !== undefined && (n.saltLength = i.saltLength.charCodeAt(0)),
        n
      )
    },
    bT = function (e) {
      switch (Dr[e.signatureOid]) {
        case "sha1WithRSAEncryption":
        case "sha1WithRSASignature":
          return nt.md.sha1.create()
        case "md5WithRSAEncryption":
          return nt.md.md5.create()
        case "sha256WithRSAEncryption":
          return nt.md.sha256.create()
        case "sha384WithRSAEncryption":
          return nt.md.sha384.create()
        case "sha512WithRSAEncryption":
          return nt.md.sha512.create()
        case "RSASSA-PSS":
          return nt.md.sha256.create()
        default:
          var t = new Error(
            "Could not compute " + e.type + " digest. Unknown signature OID.",
          )
          throw ((t.signatureOid = e.signatureOid), t)
      }
    },
    ide = function (e) {
      var t = e.certificate,
        r
      switch (t.signatureOid) {
        case Dr.sha1WithRSAEncryption:
        case Dr.sha1WithRSASignature:
          break
        case Dr["RSASSA-PSS"]:
          var n, i
          if (
            ((n = Dr[t.signatureParameters.mgf.hash.algorithmOid]),
            n === undefined || nt.md[n] === undefined)
          ) {
            var s = new Error("Unsupported MGF hash function.")
            throw (
              ((s.oid = t.signatureParameters.mgf.hash.algorithmOid),
              (s.name = n),
              s)
            )
          }
          if (
            ((i = Dr[t.signatureParameters.mgf.algorithmOid]),
            i === undefined || nt.mgf[i] === undefined)
          ) {
            var s = new Error("Unsupported MGF function.")
            throw (
              ((s.oid = t.signatureParameters.mgf.algorithmOid),
              (s.name = i),
              s)
            )
          }
          if (
            ((i = nt.mgf[i].create(nt.md[n].create())),
            (n = Dr[t.signatureParameters.hash.algorithmOid]),
            n === undefined || nt.md[n] === undefined)
          ) {
            var s = new Error("Unsupported RSASSA-PSS hash function.")
            throw (
              ((s.oid = t.signatureParameters.hash.algorithmOid),
              (s.name = n),
              s)
            )
          }
          r = nt.pss.create(
            nt.md[n].create(),
            i,
            t.signatureParameters.saltLength,
          )
          break
      }
      return t.publicKey.verify(e.md.digest().getBytes(), e.signature, r)
    }
  we.certificateFromPem = function (e, t, r) {
    var n = nt.pem.decode(e)[0]
    if (
      n.type !== "CERTIFICATE" &&
      n.type !== "X509 CERTIFICATE" &&
      n.type !== "TRUSTED CERTIFICATE"
    ) {
      var i = new Error(
        'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".',
      )
      throw ((i.headerType = n.type), i)
    }
    if (n.procType && n.procType.type === "ENCRYPTED")
      throw new Error(
        "Could not convert certificate from PEM; PEM is encrypted.",
      )
    var s = R.fromDer(n.body, r)
    return we.certificateFromAsn1(s, t)
  }
  we.certificateToPem = function (e, t) {
    var r = {
      type: "CERTIFICATE",
      body: R.toDer(we.certificateToAsn1(e)).getBytes(),
    }
    return nt.pem.encode(r, { maxline: t })
  }
  we.publicKeyFromPem = function (e) {
    var t = nt.pem.decode(e)[0]
    if (t.type !== "PUBLIC KEY" && t.type !== "RSA PUBLIC KEY") {
      var r = new Error(
        'Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".',
      )
      throw ((r.headerType = t.type), r)
    }
    if (t.procType && t.procType.type === "ENCRYPTED")
      throw new Error(
        "Could not convert public key from PEM; PEM is encrypted.",
      )
    var n = R.fromDer(t.body)
    return we.publicKeyFromAsn1(n)
  }
  we.publicKeyToPem = function (e, t) {
    var r = {
      type: "PUBLIC KEY",
      body: R.toDer(we.publicKeyToAsn1(e)).getBytes(),
    }
    return nt.pem.encode(r, { maxline: t })
  }
  we.publicKeyToRSAPublicKeyPem = function (e, t) {
    var r = {
      type: "RSA PUBLIC KEY",
      body: R.toDer(we.publicKeyToRSAPublicKey(e)).getBytes(),
    }
    return nt.pem.encode(r, { maxline: t })
  }
  we.getPublicKeyFingerprint = function (e, t) {
    t = t || {}
    var r = t.md || nt.md.sha1.create(),
      n = t.type || "RSAPublicKey",
      i
    switch (n) {
      case "RSAPublicKey":
        i = R.toDer(we.publicKeyToRSAPublicKey(e)).getBytes()
        break
      case "SubjectPublicKeyInfo":
        i = R.toDer(we.publicKeyToAsn1(e)).getBytes()
        break
      default:
        throw new Error('Unknown fingerprint type "' + t.type + '".')
    }
    r.start(), r.update(i)
    var s = r.digest()
    if (t.encoding === "hex") {
      var o = s.toHex()
      return t.delimiter ? o.match(/.{2}/g).join(t.delimiter) : o
    } else {
      if (t.encoding === "binary") return s.getBytes()
      if (t.encoding) throw new Error('Unknown encoding "' + t.encoding + '".')
    }
    return s
  }
  we.certificationRequestFromPem = function (e, t, r) {
    var n = nt.pem.decode(e)[0]
    if (n.type !== "CERTIFICATE REQUEST") {
      var i = new Error(
        'Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".',
      )
      throw ((i.headerType = n.type), i)
    }
    if (n.procType && n.procType.type === "ENCRYPTED")
      throw new Error(
        "Could not convert certification request from PEM; PEM is encrypted.",
      )
    var s = R.fromDer(n.body, r)
    return we.certificationRequestFromAsn1(s, t)
  }
  we.certificationRequestToPem = function (e, t) {
    var r = {
      type: "CERTIFICATE REQUEST",
      body: R.toDer(we.certificationRequestToAsn1(e)).getBytes(),
    }
    return nt.pem.encode(r, { maxline: t })
  }
  we.createCertificate = function () {
    var e = {}
    return (
      (e.version = 2),
      (e.serialNumber = "00"),
      (e.signatureOid = null),
      (e.signature = null),
      (e.siginfo = {}),
      (e.siginfo.algorithmOid = null),
      (e.validity = {}),
      (e.validity.notBefore = new Date()),
      (e.validity.notAfter = new Date()),
      (e.issuer = {}),
      (e.issuer.getField = function (t) {
        return Mh(e.issuer, t)
      }),
      (e.issuer.addField = function (t) {
        Fl([t]), e.issuer.attributes.push(t)
      }),
      (e.issuer.attributes = []),
      (e.issuer.hash = null),
      (e.subject = {}),
      (e.subject.getField = function (t) {
        return Mh(e.subject, t)
      }),
      (e.subject.addField = function (t) {
        Fl([t]), e.subject.attributes.push(t)
      }),
      (e.subject.attributes = []),
      (e.subject.hash = null),
      (e.extensions = []),
      (e.publicKey = null),
      (e.md = null),
      (e.setSubject = function (t, r) {
        Fl(t),
          (e.subject.attributes = t),
          delete e.subject.uniqueId,
          r && (e.subject.uniqueId = r),
          (e.subject.hash = null)
      }),
      (e.setIssuer = function (t, r) {
        Fl(t),
          (e.issuer.attributes = t),
          delete e.issuer.uniqueId,
          r && (e.issuer.uniqueId = r),
          (e.issuer.hash = null)
      }),
      (e.setExtensions = function (t) {
        for (var r = 0; r < t.length; ++r) sde(t[r], { cert: e })
        e.extensions = t
      }),
      (e.getExtension = function (t) {
        typeof t == "string" && (t = { name: t })
        for (var r = null, n, i = 0; r === null && i < e.extensions.length; ++i)
          (n = e.extensions[i]),
            ((t.id && n.id === t.id) || (t.name && n.name === t.name)) &&
              (r = n)
        return r
      }),
      (e.sign = function (t, r) {
        e.md = r || nt.md.sha1.create()
        var n = Dr[e.md.algorithm + "WithRSAEncryption"]
        if (!n) {
          var i = new Error(
            "Could not compute certificate digest. Unknown message digest algorithm OID.",
          )
          throw ((i.algorithm = e.md.algorithm), i)
        }
        ;(e.signatureOid = e.siginfo.algorithmOid = n),
          (e.tbsCertificate = we.getTBSCertificate(e))
        var s = R.toDer(e.tbsCertificate)
        e.md.update(s.getBytes()), (e.signature = t.sign(e.md))
      }),
      (e.verify = function (t) {
        var r = false
        if (!e.issued(t)) {
          var n = t.issuer,
            i = e.subject,
            s = new Error(
              "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.",
            )
          throw (
            ((s.expectedIssuer = i.attributes),
            (s.actualIssuer = n.attributes),
            s)
          )
        }
        var o = t.md
        if (o === null) {
          o = bT({ signatureOid: t.signatureOid, type: "certificate" })
          var a = t.tbsCertificate || we.getTBSCertificate(t),
            l = R.toDer(a)
          o.update(l.getBytes())
        }
        return (
          o !== null &&
            (r = ide({ certificate: e, md: o, signature: t.signature })),
          r
        )
      }),
      (e.isIssuer = function (t) {
        var r = false,
          n = e.issuer,
          i = t.subject
        if (n.hash && i.hash) r = n.hash === i.hash
        else if (n.attributes.length === i.attributes.length) {
          r = true
          for (var s, o, a = 0; r && a < n.attributes.length; ++a)
            (s = n.attributes[a]),
              (o = i.attributes[a]),
              (s.type !== o.type || s.value !== o.value) && (r = false)
        }
        return r
      }),
      (e.issued = function (t) {
        return t.isIssuer(e)
      }),
      (e.generateSubjectKeyIdentifier = function () {
        return we.getPublicKeyFingerprint(e.publicKey, { type: "RSAPublicKey" })
      }),
      (e.verifySubjectKeyIdentifier = function () {
        for (
          var t = Dr.subjectKeyIdentifier, r = 0;
          r < e.extensions.length;
          ++r
        ) {
          var n = e.extensions[r]
          if (n.id === t) {
            var i = e.generateSubjectKeyIdentifier().getBytes()
            return nt.util.hexToBytes(n.subjectKeyIdentifier) === i
          }
        }
        return false
      }),
      e
    )
  }
  we.certificateFromAsn1 = function (e, t) {
    var r = {},
      n = []
    if (!R.validate(e, Qtt, r, n)) {
      var i = new Error(
        "Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.",
      )
      throw ((i.errors = n), i)
    }
    var s = R.derToOid(r.publicKeyOid)
    if (s !== we.oids.rsaEncryption)
      throw new Error("Cannot read public key. OID is not RSA.")
    var o = we.createCertificate()
    o.version = r.certVersion ? r.certVersion.charCodeAt(0) : 0
    var a = nt.util.createBuffer(r.certSerialNumber)
    ;(o.serialNumber = a.toHex()),
      (o.signatureOid = nt.asn1.derToOid(r.certSignatureOid)),
      (o.signatureParameters = CT(o.signatureOid, r.certSignatureParams, true)),
      (o.siginfo.algorithmOid = nt.asn1.derToOid(r.certinfoSignatureOid)),
      (o.siginfo.parameters = CT(
        o.siginfo.algorithmOid,
        r.certinfoSignatureParams,
        false,
      )),
      (o.signature = r.certSignature)
    var l = []
    if (
      (r.certValidity1UTCTime !== undefined &&
        l.push(R.utcTimeToDate(r.certValidity1UTCTime)),
      r.certValidity2GeneralizedTime !== undefined &&
        l.push(R.generalizedTimeToDate(r.certValidity2GeneralizedTime)),
      r.certValidity3UTCTime !== undefined &&
        l.push(R.utcTimeToDate(r.certValidity3UTCTime)),
      r.certValidity4GeneralizedTime !== undefined &&
        l.push(R.generalizedTimeToDate(r.certValidity4GeneralizedTime)),
      l.length > 2)
    )
      throw new Error(
        "Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.",
      )
    if (l.length < 2)
      throw new Error(
        "Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.",
      )
    if (
      ((o.validity.notBefore = l[0]),
      (o.validity.notAfter = l[1]),
      (o.tbsCertificate = r.tbsCertificate),
      t)
    ) {
      o.md = bT({ signatureOid: o.signatureOid, type: "certificate" })
      var c = R.toDer(o.tbsCertificate)
      o.md.update(c.getBytes())
    }
    var u = nt.md.sha1.create(),
      f = R.toDer(r.certIssuer)
    u.update(f.getBytes()),
      (o.issuer.getField = function (m) {
        return Mh(o.issuer, m)
      }),
      (o.issuer.addField = function (m) {
        Fl([m]), o.issuer.attributes.push(m)
      }),
      (o.issuer.attributes = we.RDNAttributesAsArray(r.certIssuer)),
      r.certIssuerUniqueId && (o.issuer.uniqueId = r.certIssuerUniqueId),
      (o.issuer.hash = u.digest().toHex())
    var p = nt.md.sha1.create(),
      g = R.toDer(r.certSubject)
    return (
      p.update(g.getBytes()),
      (o.subject.getField = function (m) {
        return Mh(o.subject, m)
      }),
      (o.subject.addField = function (m) {
        Fl([m]), o.subject.attributes.push(m)
      }),
      (o.subject.attributes = we.RDNAttributesAsArray(r.certSubject)),
      r.certSubjectUniqueId && (o.subject.uniqueId = r.certSubjectUniqueId),
      (o.subject.hash = p.digest().toHex()),
      r.certExtensions
        ? (o.extensions = we.certificateExtensionsFromAsn1(r.certExtensions))
        : (o.extensions = []),
      (o.publicKey = we.publicKeyFromAsn1(r.subjectPublicKeyInfo)),
      o
    )
  }
  we.certificateExtensionsFromAsn1 = function (e) {
    for (var t = [], r = 0; r < e.value.length; ++r)
      for (var n = e.value[r], i = 0; i < n.value.length; ++i)
        t.push(we.certificateExtensionFromAsn1(n.value[i]))
    return t
  }
  we.certificateExtensionFromAsn1 = function (e) {
    var t = {}
    if (
      ((t.id = R.derToOid(e.value[0].value)),
      (t.critical = false),
      e.value[1].type === R.Type.BOOLEAN
        ? ((t.critical = e.value[1].value.charCodeAt(0) !== 0),
          (t.value = e.value[2].value))
        : (t.value = e.value[1].value),
      t.id in Dr)
    ) {
      if (((t.name = Dr[t.id]), t.name === "keyUsage")) {
        var r = R.fromDer(t.value),
          n = 0,
          i = 0
        r.value.length > 1 &&
          ((n = r.value.charCodeAt(1)),
          (i = r.value.length > 2 ? r.value.charCodeAt(2) : 0)),
          (t.digitalSignature = (n & 128) === 128),
          (t.nonRepudiation = (n & 64) === 64),
          (t.keyEncipherment = (n & 32) === 32),
          (t.dataEncipherment = (n & 16) === 16),
          (t.keyAgreement = (n & 8) === 8),
          (t.keyCertSign = (n & 4) === 4),
          (t.cRLSign = (n & 2) === 2),
          (t.encipherOnly = (n & 1) === 1),
          (t.decipherOnly = (i & 128) === 128)
      } else if (t.name === "basicConstraints") {
        var r = R.fromDer(t.value)
        r.value.length > 0 && r.value[0].type === R.Type.BOOLEAN
          ? (t.cA = r.value[0].value.charCodeAt(0) !== 0)
          : (t.cA = false)
        var s = null
        r.value.length > 0 && r.value[0].type === R.Type.INTEGER
          ? (s = r.value[0].value)
          : r.value.length > 1 && (s = r.value[1].value),
          s !== null && (t.pathLenConstraint = R.derToInteger(s))
      } else if (t.name === "extKeyUsage")
        for (var r = R.fromDer(t.value), o = 0; o < r.value.length; ++o) {
          var a = R.derToOid(r.value[o].value)
          a in Dr ? (t[Dr[a]] = true) : (t[a] = true)
        }
      else if (t.name === "nsCertType") {
        var r = R.fromDer(t.value),
          n = 0
        r.value.length > 1 && (n = r.value.charCodeAt(1)),
          (t.client = (n & 128) === 128),
          (t.server = (n & 64) === 64),
          (t.email = (n & 32) === 32),
          (t.objsign = (n & 16) === 16),
          (t.reserved = (n & 8) === 8),
          (t.sslCA = (n & 4) === 4),
          (t.emailCA = (n & 2) === 2),
          (t.objCA = (n & 1) === 1)
      } else if (t.name === "subjectAltName" || t.name === "issuerAltName") {
        t.altNames = []
        for (var l, r = R.fromDer(t.value), c = 0; c < r.value.length; ++c) {
          l = r.value[c]
          var u = { type: l.type, value: l.value }
          switch ((t.altNames.push(u), l.type)) {
            case 1:
            case 2:
            case 6:
              break
            case 7:
              u.ip = nt.util.bytesToIP(l.value)
              break
            case 8:
              u.oid = R.derToOid(l.value)
              break
            default:
          }
        }
      } else if (t.name === "subjectKeyIdentifier") {
        var r = R.fromDer(t.value)
        t.subjectKeyIdentifier = nt.util.bytesToHex(r.value)
      }
    }
    return t
  }
  we.certificationRequestFromAsn1 = function (e, t) {
    var r = {},
      n = []
    if (!R.validate(e, Ltt, r, n)) {
      var i = new Error(
        "Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.",
      )
      throw ((i.errors = n), i)
    }
    var s = R.derToOid(r.publicKeyOid)
    if (s !== we.oids.rsaEncryption)
      throw new Error("Cannot read public key. OID is not RSA.")
    var o = we.createCertificationRequest()
    if (
      ((o.version = r.csrVersion ? r.csrVersion.charCodeAt(0) : 0),
      (o.signatureOid = nt.asn1.derToOid(r.csrSignatureOid)),
      (o.signatureParameters = CT(o.signatureOid, r.csrSignatureParams, true)),
      (o.siginfo.algorithmOid = nt.asn1.derToOid(r.csrSignatureOid)),
      (o.siginfo.parameters = CT(
        o.siginfo.algorithmOid,
        r.csrSignatureParams,
        false,
      )),
      (o.signature = r.csrSignature),
      (o.certificationRequestInfo = r.certificationRequestInfo),
      t)
    ) {
      o.md = bT({ signatureOid: o.signatureOid, type: "certification request" })
      var a = R.toDer(o.certificationRequestInfo)
      o.md.update(a.getBytes())
    }
    var l = nt.md.sha1.create()
    return (
      (o.subject.getField = function (c) {
        return Mh(o.subject, c)
      }),
      (o.subject.addField = function (c) {
        Fl([c]), o.subject.attributes.push(c)
      }),
      (o.subject.attributes = we.RDNAttributesAsArray(
        r.certificationRequestInfoSubject,
        l,
      )),
      (o.subject.hash = l.digest().toHex()),
      (o.publicKey = we.publicKeyFromAsn1(r.subjectPublicKeyInfo)),
      (o.getAttribute = function (c) {
        return Mh(o, c)
      }),
      (o.addAttribute = function (c) {
        Fl([c]), o.attributes.push(c)
      }),
      (o.attributes = we.CRIAttributesAsArray(
        r.certificationRequestInfoAttributes || [],
      )),
      o
    )
  }
  we.createCertificationRequest = function () {
    var e = {}
    return (
      (e.version = 0),
      (e.signatureOid = null),
      (e.signature = null),
      (e.siginfo = {}),
      (e.siginfo.algorithmOid = null),
      (e.subject = {}),
      (e.subject.getField = function (t) {
        return Mh(e.subject, t)
      }),
      (e.subject.addField = function (t) {
        Fl([t]), e.subject.attributes.push(t)
      }),
      (e.subject.attributes = []),
      (e.subject.hash = null),
      (e.publicKey = null),
      (e.attributes = []),
      (e.getAttribute = function (t) {
        return Mh(e, t)
      }),
      (e.addAttribute = function (t) {
        Fl([t]), e.attributes.push(t)
      }),
      (e.md = null),
      (e.setSubject = function (t) {
        Fl(t), (e.subject.attributes = t), (e.subject.hash = null)
      }),
      (e.setAttributes = function (t) {
        Fl(t), (e.attributes = t)
      }),
      (e.sign = function (t, r) {
        e.md = r || nt.md.sha1.create()
        var n = Dr[e.md.algorithm + "WithRSAEncryption"]
        if (!n) {
          var i = new Error(
            "Could not compute certification request digest. Unknown message digest algorithm OID.",
          )
          throw ((i.algorithm = e.md.algorithm), i)
        }
        ;(e.signatureOid = e.siginfo.algorithmOid = n),
          (e.certificationRequestInfo = we.getCertificationRequestInfo(e))
        var s = R.toDer(e.certificationRequestInfo)
        e.md.update(s.getBytes()), (e.signature = t.sign(e.md))
      }),
      (e.verify = function () {
        var t = false,
          r = e.md
        if (r === null) {
          r = bT({
            signatureOid: e.signatureOid,
            type: "certification request",
          })
          var n =
              e.certificationRequestInfo || we.getCertificationRequestInfo(e),
            i = R.toDer(n)
          r.update(i.getBytes())
        }
        return (
          r !== null &&
            (t = ide({ certificate: e, md: r, signature: e.signature })),
          t
        )
      }),
      e
    )
  }
  function xy(e) {
    for (
      var t = R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, []),
        r,
        n,
        i = e.attributes,
        s = 0;
      s < i.length;
      ++s
    ) {
      r = i[s]
      var o = r.value,
        a = R.Type.PRINTABLESTRING
      "valueTagClass" in r &&
        ((a = r.valueTagClass),
        a === R.Type.UTF8 && (o = nt.util.encodeUtf8(o))),
        (n = R.create(R.Class.UNIVERSAL, R.Type.SET, true, [
          R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [
            R.create(
              R.Class.UNIVERSAL,
              R.Type.OID,
              false,
              R.oidToDer(r.type).getBytes(),
            ),
            R.create(R.Class.UNIVERSAL, a, false, o),
          ]),
        ])),
        t.value.push(n)
    }
    return t
  }
  function Fl(e) {
    for (var t, r = 0; r < e.length; ++r) {
      if (
        ((t = e[r]),
        typeof t.name > "u" &&
          (t.type && t.type in we.oids
            ? (t.name = we.oids[t.type])
            : t.shortName &&
              t.shortName in ui &&
              (t.name = we.oids[ui[t.shortName]])),
        typeof t.type > "u")
      )
        if (t.name && t.name in we.oids) t.type = we.oids[t.name]
        else {
          var n = new Error("Attribute type not specified.")
          throw ((n.attribute = t), n)
        }
      if (
        (typeof t.shortName > "u" &&
          t.name &&
          t.name in ui &&
          (t.shortName = ui[t.name]),
        t.type === Dr.extensionRequest &&
          ((t.valueConstructed = true),
          (t.valueTagClass = R.Type.SEQUENCE),
          !t.value && t.extensions))
      ) {
        t.value = []
        for (var i = 0; i < t.extensions.length; ++i)
          t.value.push(we.certificateExtensionToAsn1(sde(t.extensions[i])))
      }
      if (typeof t.value > "u") {
        var n = new Error("Attribute value not specified.")
        throw ((n.attribute = t), n)
      }
    }
  }
  function sde(e, t) {
    if (
      ((t = t || {}),
      typeof e.name > "u" &&
        e.id &&
        e.id in we.oids &&
        (e.name = we.oids[e.id]),
      typeof e.id > "u")
    )
      if (e.name && e.name in we.oids) e.id = we.oids[e.name]
      else {
        var r = new Error("Extension ID not specified.")
        throw ((r.extension = e), r)
      }
    if (typeof e.value < "u") return e
    if (e.name === "keyUsage") {
      var n = 0,
        i = 0,
        s = 0
      e.digitalSignature && ((i |= 128), (n = 7)),
        e.nonRepudiation && ((i |= 64), (n = 6)),
        e.keyEncipherment && ((i |= 32), (n = 5)),
        e.dataEncipherment && ((i |= 16), (n = 4)),
        e.keyAgreement && ((i |= 8), (n = 3)),
        e.keyCertSign && ((i |= 4), (n = 2)),
        e.cRLSign && ((i |= 2), (n = 1)),
        e.encipherOnly && ((i |= 1), (n = 0)),
        e.decipherOnly && ((s |= 128), (n = 7))
      var o = String.fromCharCode(n)
      s !== 0
        ? (o += String.fromCharCode(i) + String.fromCharCode(s))
        : i !== 0 && (o += String.fromCharCode(i)),
        (e.value = R.create(R.Class.UNIVERSAL, R.Type.BITSTRING, false, o))
    } else if (e.name === "basicConstraints")
      (e.value = R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [])),
        e.cA &&
          e.value.value.push(
            R.create(R.Class.UNIVERSAL, R.Type.BOOLEAN, false, "\xFF"),
          ),
        "pathLenConstraint" in e &&
          e.value.value.push(
            R.create(
              R.Class.UNIVERSAL,
              R.Type.INTEGER,
              false,
              R.integerToDer(e.pathLenConstraint).getBytes(),
            ),
          )
    else if (e.name === "extKeyUsage") {
      e.value = R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [])
      var a = e.value.value
      for (var l in e)
        e[l] === true &&
          (l in Dr
            ? a.push(
                R.create(
                  R.Class.UNIVERSAL,
                  R.Type.OID,
                  false,
                  R.oidToDer(Dr[l]).getBytes(),
                ),
              )
            : l.indexOf(".") !== -1 &&
              a.push(
                R.create(
                  R.Class.UNIVERSAL,
                  R.Type.OID,
                  false,
                  R.oidToDer(l).getBytes(),
                ),
              ))
    } else if (e.name === "nsCertType") {
      var n = 0,
        i = 0
      e.client && ((i |= 128), (n = 7)),
        e.server && ((i |= 64), (n = 6)),
        e.email && ((i |= 32), (n = 5)),
        e.objsign && ((i |= 16), (n = 4)),
        e.reserved && ((i |= 8), (n = 3)),
        e.sslCA && ((i |= 4), (n = 2)),
        e.emailCA && ((i |= 2), (n = 1)),
        e.objCA && ((i |= 1), (n = 0))
      var o = String.fromCharCode(n)
      i !== 0 && (o += String.fromCharCode(i)),
        (e.value = R.create(R.Class.UNIVERSAL, R.Type.BITSTRING, false, o))
    } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
      e.value = R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [])
      for (var c, u = 0; u < e.altNames.length; ++u) {
        c = e.altNames[u]
        var o = c.value
        if (c.type === 7 && c.ip) {
          if (((o = nt.util.bytesFromIP(c.ip)), o === null)) {
            var r = new Error(
              'Extension "ip" value is not a valid IPv4 or IPv6 address.',
            )
            throw ((r.extension = e), r)
          }
        } else
          c.type === 8 &&
            (c.oid ? (o = R.oidToDer(R.oidToDer(c.oid))) : (o = R.oidToDer(o)))
        e.value.value.push(R.create(R.Class.CONTEXT_SPECIFIC, c.type, false, o))
      }
    } else if (e.name === "nsComment" && t.cert) {
      if (
        !/^[\x00-\x7F]*$/.test(e.comment) ||
        e.comment.length < 1 ||
        e.comment.length > 128
      )
        throw new Error('Invalid "nsComment" content.')
      e.value = R.create(R.Class.UNIVERSAL, R.Type.IA5STRING, false, e.comment)
    } else if (e.name === "subjectKeyIdentifier" && t.cert) {
      var f = t.cert.generateSubjectKeyIdentifier()
      ;(e.subjectKeyIdentifier = f.toHex()),
        (e.value = R.create(
          R.Class.UNIVERSAL,
          R.Type.OCTETSTRING,
          false,
          f.getBytes(),
        ))
    } else if (e.name === "authorityKeyIdentifier" && t.cert) {
      e.value = R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [])
      var a = e.value.value
      if (e.keyIdentifier) {
        var p =
          e.keyIdentifier === true
            ? t.cert.generateSubjectKeyIdentifier().getBytes()
            : e.keyIdentifier
        a.push(R.create(R.Class.CONTEXT_SPECIFIC, 0, false, p))
      }
      if (e.authorityCertIssuer) {
        var g = [
          R.create(R.Class.CONTEXT_SPECIFIC, 4, true, [
            xy(
              e.authorityCertIssuer === true
                ? t.cert.issuer
                : e.authorityCertIssuer,
            ),
          ]),
        ]
        a.push(R.create(R.Class.CONTEXT_SPECIFIC, 1, true, g))
      }
      if (e.serialNumber) {
        var m = nt.util.hexToBytes(
          e.serialNumber === true ? t.cert.serialNumber : e.serialNumber,
        )
        a.push(R.create(R.Class.CONTEXT_SPECIFIC, 2, false, m))
      }
    } else if (e.name === "cRLDistributionPoints") {
      e.value = R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [])
      for (
        var a = e.value.value,
          y = R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, []),
          v = R.create(R.Class.CONTEXT_SPECIFIC, 0, true, []),
          c,
          u = 0;
        u < e.altNames.length;
        ++u
      ) {
        c = e.altNames[u]
        var o = c.value
        if (c.type === 7 && c.ip) {
          if (((o = nt.util.bytesFromIP(c.ip)), o === null)) {
            var r = new Error(
              'Extension "ip" value is not a valid IPv4 or IPv6 address.',
            )
            throw ((r.extension = e), r)
          }
        } else
          c.type === 8 &&
            (c.oid ? (o = R.oidToDer(R.oidToDer(c.oid))) : (o = R.oidToDer(o)))
        v.value.push(R.create(R.Class.CONTEXT_SPECIFIC, c.type, false, o))
      }
      y.value.push(R.create(R.Class.CONTEXT_SPECIFIC, 0, true, [v])), a.push(y)
    }
    if (typeof e.value > "u") {
      var r = new Error("Extension value not specified.")
      throw ((r.extension = e), r)
    }
    return e
  }
  function jW(e, t) {
    switch (e) {
      case Dr["RSASSA-PSS"]:
        var r = []
        return (
          t.hash.algorithmOid !== undefined &&
            r.push(
              R.create(R.Class.CONTEXT_SPECIFIC, 0, true, [
                R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [
                  R.create(
                    R.Class.UNIVERSAL,
                    R.Type.OID,
                    false,
                    R.oidToDer(t.hash.algorithmOid).getBytes(),
                  ),
                  R.create(R.Class.UNIVERSAL, R.Type.NULL, false, ""),
                ]),
              ]),
            ),
          t.mgf.algorithmOid !== undefined &&
            r.push(
              R.create(R.Class.CONTEXT_SPECIFIC, 1, true, [
                R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [
                  R.create(
                    R.Class.UNIVERSAL,
                    R.Type.OID,
                    false,
                    R.oidToDer(t.mgf.algorithmOid).getBytes(),
                  ),
                  R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [
                    R.create(
                      R.Class.UNIVERSAL,
                      R.Type.OID,
                      false,
                      R.oidToDer(t.mgf.hash.algorithmOid).getBytes(),
                    ),
                    R.create(R.Class.UNIVERSAL, R.Type.NULL, false, ""),
                  ]),
                ]),
              ]),
            ),
          t.saltLength !== undefined &&
            r.push(
              R.create(R.Class.CONTEXT_SPECIFIC, 2, true, [
                R.create(
                  R.Class.UNIVERSAL,
                  R.Type.INTEGER,
                  false,
                  R.integerToDer(t.saltLength).getBytes(),
                ),
              ]),
            ),
          R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, r)
        )
      default:
        return R.create(R.Class.UNIVERSAL, R.Type.NULL, false, "")
    }
  }
  function Utt(e) {
    var t = R.create(R.Class.CONTEXT_SPECIFIC, 0, true, [])
    if (e.attributes.length === 0) return t
    for (var r = e.attributes, n = 0; n < r.length; ++n) {
      var i = r[n],
        s = i.value,
        o = R.Type.UTF8
      "valueTagClass" in i && (o = i.valueTagClass),
        o === R.Type.UTF8 && (s = nt.util.encodeUtf8(s))
      var a = false
      "valueConstructed" in i && (a = i.valueConstructed)
      var l = R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [
        R.create(
          R.Class.UNIVERSAL,
          R.Type.OID,
          false,
          R.oidToDer(i.type).getBytes(),
        ),
        R.create(R.Class.UNIVERSAL, R.Type.SET, true, [
          R.create(R.Class.UNIVERSAL, o, a, s),
        ]),
      ])
      t.value.push(l)
    }
    return t
  }
  var Ott = new Date("1950-01-01T00:00:00Z"),
    qtt = new Date("2050-01-01T00:00:00Z")
  function rde(e) {
    return e >= Ott && e < qtt
      ? R.create(R.Class.UNIVERSAL, R.Type.UTCTIME, false, R.dateToUtcTime(e))
      : R.create(
          R.Class.UNIVERSAL,
          R.Type.GENERALIZEDTIME,
          false,
          R.dateToGeneralizedTime(e),
        )
  }
  we.getTBSCertificate = function (e) {
    var t = rde(e.validity.notBefore),
      r = rde(e.validity.notAfter),
      n = R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [
        R.create(R.Class.CONTEXT_SPECIFIC, 0, true, [
          R.create(
            R.Class.UNIVERSAL,
            R.Type.INTEGER,
            false,
            R.integerToDer(e.version).getBytes(),
          ),
        ]),
        R.create(
          R.Class.UNIVERSAL,
          R.Type.INTEGER,
          false,
          nt.util.hexToBytes(e.serialNumber),
        ),
        R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [
          R.create(
            R.Class.UNIVERSAL,
            R.Type.OID,
            false,
            R.oidToDer(e.siginfo.algorithmOid).getBytes(),
          ),
          jW(e.siginfo.algorithmOid, e.siginfo.parameters),
        ]),
        xy(e.issuer),
        R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [t, r]),
        xy(e.subject),
        we.publicKeyToAsn1(e.publicKey),
      ])
    return (
      e.issuer.uniqueId &&
        n.value.push(
          R.create(R.Class.CONTEXT_SPECIFIC, 1, true, [
            R.create(
              R.Class.UNIVERSAL,
              R.Type.BITSTRING,
              false,
              "\0" + e.issuer.uniqueId,
            ),
          ]),
        ),
      e.subject.uniqueId &&
        n.value.push(
          R.create(R.Class.CONTEXT_SPECIFIC, 2, true, [
            R.create(
              R.Class.UNIVERSAL,
              R.Type.BITSTRING,
              false,
              "\0" + e.subject.uniqueId,
            ),
          ]),
        ),
      e.extensions.length > 0 &&
        n.value.push(we.certificateExtensionsToAsn1(e.extensions)),
      n
    )
  }
  we.getCertificationRequestInfo = function (e) {
    var t = R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [
      R.create(
        R.Class.UNIVERSAL,
        R.Type.INTEGER,
        false,
        R.integerToDer(e.version).getBytes(),
      ),
      xy(e.subject),
      we.publicKeyToAsn1(e.publicKey),
      Utt(e),
    ])
    return t
  }
  we.distinguishedNameToAsn1 = function (e) {
    return xy(e)
  }
  we.certificateToAsn1 = function (e) {
    var t = e.tbsCertificate || we.getTBSCertificate(e)
    return R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [
      t,
      R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [
        R.create(
          R.Class.UNIVERSAL,
          R.Type.OID,
          false,
          R.oidToDer(e.signatureOid).getBytes(),
        ),
        jW(e.signatureOid, e.signatureParameters),
      ]),
      R.create(R.Class.UNIVERSAL, R.Type.BITSTRING, false, "\0" + e.signature),
    ])
  }
  we.certificateExtensionsToAsn1 = function (e) {
    var t = R.create(R.Class.CONTEXT_SPECIFIC, 3, true, []),
      r = R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [])
    t.value.push(r)
    for (var n = 0; n < e.length; ++n)
      r.value.push(we.certificateExtensionToAsn1(e[n]))
    return t
  }
  we.certificateExtensionToAsn1 = function (e) {
    var t = R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [])
    t.value.push(
      R.create(R.Class.UNIVERSAL, R.Type.OID, false, R.oidToDer(e.id).getBytes()),
    ),
      e.critical &&
        t.value.push(R.create(R.Class.UNIVERSAL, R.Type.BOOLEAN, false, "\xFF"))
    var r = e.value
    return (
      typeof e.value != "string" && (r = R.toDer(r).getBytes()),
      t.value.push(R.create(R.Class.UNIVERSAL, R.Type.OCTETSTRING, false, r)),
      t
    )
  }
  we.certificationRequestToAsn1 = function (e) {
    var t = e.certificationRequestInfo || we.getCertificationRequestInfo(e)
    return R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [
      t,
      R.create(R.Class.UNIVERSAL, R.Type.SEQUENCE, true, [
        R.create(
          R.Class.UNIVERSAL,
          R.Type.OID,
          false,
          R.oidToDer(e.signatureOid).getBytes(),
        ),
        jW(e.signatureOid, e.signatureParameters),
      ]),
      R.create(R.Class.UNIVERSAL, R.Type.BITSTRING, false, "\0" + e.signature),
    ])
  }
  we.createCaStore = function (e) {
    var t = { certs: {} }
    ;(t.getIssuer = function (o) {
      var a = r(o.issuer)
      return a
    }),
      (t.addCertificate = function (o) {
        if (
          (typeof o == "string" && (o = nt.pki.certificateFromPem(o)),
          n(o.subject),
          !t.hasCertificate(o))
        )
          if (o.subject.hash in t.certs) {
            var a = t.certs[o.subject.hash]
            nt.util.isArray(a) || (a = [a]),
              a.push(o),
              (t.certs[o.subject.hash] = a)
          } else t.certs[o.subject.hash] = o
      }),
      (t.hasCertificate = function (o) {
        typeof o == "string" && (o = nt.pki.certificateFromPem(o))
        var a = r(o.subject)
        if (!a) return false
        nt.util.isArray(a) || (a = [a])
        for (
          var l = R.toDer(we.certificateToAsn1(o)).getBytes(), c = 0;
          c < a.length;
          ++c
        ) {
          var u = R.toDer(we.certificateToAsn1(a[c])).getBytes()
          if (l === u) return true
        }
        return false
      }),
      (t.listAllCertificates = function () {
        var o = []
        for (var a in t.certs)
          if (t.certs.hasOwnProperty(a)) {
            var l = t.certs[a]
            if (!nt.util.isArray(l)) o.push(l)
            else for (var c = 0; c < l.length; ++c) o.push(l[c])
          }
        return o
      }),
      (t.removeCertificate = function (o) {
        var a
        if (
          (typeof o == "string" && (o = nt.pki.certificateFromPem(o)),
          n(o.subject),
          !t.hasCertificate(o))
        )
          return null
        var l = r(o.subject)
        if (!nt.util.isArray(l))
          return (
            (a = t.certs[o.subject.hash]), delete t.certs[o.subject.hash], a
          )
        for (
          var c = R.toDer(we.certificateToAsn1(o)).getBytes(), u = 0;
          u < l.length;
          ++u
        ) {
          var f = R.toDer(we.certificateToAsn1(l[u])).getBytes()
          c === f && ((a = l[u]), l.splice(u, 1))
        }
        return l.length === 0 && delete t.certs[o.subject.hash], a
      })
    function r(o) {
      return n(o), t.certs[o.hash] || null
    }
    function n(o) {
      if (!o.hash) {
        var a = nt.md.sha1.create()
        ;(o.attributes = we.RDNAttributesAsArray(xy(o), a)),
          (o.hash = a.digest().toHex())
      }
    }
    if (e)
      for (var i = 0; i < e.length; ++i) {
        var s = e[i]
        t.addCertificate(s)
      }
    return t
  }
  we.certificateError = {
    bad_certificate: "forge.pki.BadCertificate",
    unsupported_certificate: "forge.pki.UnsupportedCertificate",
    certificate_revoked: "forge.pki.CertificateRevoked",
    certificate_expired: "forge.pki.CertificateExpired",
    certificate_unknown: "forge.pki.CertificateUnknown",
    unknown_ca: "forge.pki.UnknownCertificateAuthority",
  }
  we.verifyCertificateChain = function (e, t, r) {
    typeof r == "function" && (r = { verify: r }),
      (r = r || {}),
      (t = t.slice(0))
    var n = t.slice(0),
      i = r.validityCheckDate
    typeof i > "u" && (i = new Date())
    var s = true,
      o = null,
      a = 0
    do {
      var l = t.shift(),
        c = null,
        u = false
      if (
        (i &&
          (i < l.validity.notBefore || i > l.validity.notAfter) &&
          (o = {
            message: "Certificate is not valid yet or has expired.",
            error: we.certificateError.certificate_expired,
            notBefore: l.validity.notBefore,
            notAfter: l.validity.notAfter,
            now: i,
          }),
        o === null)
      ) {
        if (
          ((c = t[0] || e.getIssuer(l)),
          c === null && l.isIssuer(l) && ((u = true), (c = l)),
          c)
        ) {
          var f = c
          nt.util.isArray(f) || (f = [f])
          for (var p = false; !p && f.length > 0; ) {
            c = f.shift()
            try {
              p = c.verify(l)
            } catch {}
          }
          p ||
            (o = {
              message: "Certificate signature is invalid.",
              error: we.certificateError.bad_certificate,
            })
        }
        o === null &&
          (!c || u) &&
          !e.hasCertificate(l) &&
          (o = {
            message: "Certificate is not trusted.",
            error: we.certificateError.unknown_ca,
          })
      }
      if (
        (o === null &&
          c &&
          !l.isIssuer(c) &&
          (o = {
            message: "Certificate issuer is invalid.",
            error: we.certificateError.bad_certificate,
          }),
        o === null)
      )
        for (
          var g = { keyUsage: true, basicConstraints: true }, m = 0;
          o === null && m < l.extensions.length;
          ++m
        ) {
          var y = l.extensions[m]
          y.critical &&
            !(y.name in g) &&
            (o = {
              message: "Certificate has an unsupported critical extension.",
              error: we.certificateError.unsupported_certificate,
            })
        }
      if (o === null && (!s || (t.length === 0 && (!c || u)))) {
        var v = l.getExtension("basicConstraints"),
          C = l.getExtension("keyUsage")
        if (
          (C !== null &&
            (!C.keyCertSign || v === null) &&
            (o = {
              message:
                "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
              error: we.certificateError.bad_certificate,
            }),
          o === null &&
            v !== null &&
            !v.cA &&
            (o = {
              message:
                "Certificate basicConstraints indicates the certificate is not a CA.",
              error: we.certificateError.bad_certificate,
            }),
          o === null && C !== null && "pathLenConstraint" in v)
        ) {
          var E = a - 1
          E > v.pathLenConstraint &&
            (o = {
              message:
                "Certificate basicConstraints pathLenConstraint violated.",
              error: we.certificateError.bad_certificate,
            })
        }
      }
      var w = o === null ? true : o.error,
        B = r.verify ? r.verify(w, a, n) : w
      if (B === true) o = null
      else
        throw (
          (w === true &&
            (o = {
              message: "The application rejected the certificate.",
              error: we.certificateError.bad_certificate,
            }),
          (B || B === 0) &&
            (typeof B == "object" && !nt.util.isArray(B)
              ? (B.message && (o.message = B.message),
                B.error && (o.error = B.error))
              : typeof B == "string" && (o.error = B)),
          o)
        )
      ;(s = false), ++a
    } while (t.length > 0)
    return true
  }
})
var XW = _((_kt, lde) => {
  "use strict"
  var wn = jt()
  Mc()
  Ay()
  Dh()
  zW()
  KW()
  Tl()
  A_()
  by()
  Pr()
  ET()
  var V = wn.asn1,
    fr = wn.pki,
    v_ = (lde.exports = wn.pkcs12 = wn.pkcs12 || {}),
    ade = {
      name: "ContentInfo",
      tagClass: V.Class.UNIVERSAL,
      type: V.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "ContentInfo.contentType",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.OID,
          constructed: false,
          capture: "contentType",
        },
        {
          name: "ContentInfo.content",
          tagClass: V.Class.CONTEXT_SPECIFIC,
          constructed: true,
          captureAsn1: "content",
        },
      ],
    },
    Vtt = {
      name: "PFX",
      tagClass: V.Class.UNIVERSAL,
      type: V.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "PFX.version",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.INTEGER,
          constructed: false,
          capture: "version",
        },
        ade,
        {
          name: "PFX.macData",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "mac",
          value: [
            {
              name: "PFX.macData.mac",
              tagClass: V.Class.UNIVERSAL,
              type: V.Type.SEQUENCE,
              constructed: true,
              value: [
                {
                  name: "PFX.macData.mac.digestAlgorithm",
                  tagClass: V.Class.UNIVERSAL,
                  type: V.Type.SEQUENCE,
                  constructed: true,
                  value: [
                    {
                      name: "PFX.macData.mac.digestAlgorithm.algorithm",
                      tagClass: V.Class.UNIVERSAL,
                      type: V.Type.OID,
                      constructed: false,
                      capture: "macAlgorithm",
                    },
                    {
                      name: "PFX.macData.mac.digestAlgorithm.parameters",
                      tagClass: V.Class.UNIVERSAL,
                      captureAsn1: "macAlgorithmParameters",
                    },
                  ],
                },
                {
                  name: "PFX.macData.mac.digest",
                  tagClass: V.Class.UNIVERSAL,
                  type: V.Type.OCTETSTRING,
                  constructed: false,
                  capture: "macDigest",
                },
              ],
            },
            {
              name: "PFX.macData.macSalt",
              tagClass: V.Class.UNIVERSAL,
              type: V.Type.OCTETSTRING,
              constructed: false,
              capture: "macSalt",
            },
            {
              name: "PFX.macData.iterations",
              tagClass: V.Class.UNIVERSAL,
              type: V.Type.INTEGER,
              constructed: false,
              optional: true,
              capture: "macIterations",
            },
          ],
        },
      ],
    },
    Htt = {
      name: "SafeBag",
      tagClass: V.Class.UNIVERSAL,
      type: V.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "SafeBag.bagId",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.OID,
          constructed: false,
          capture: "bagId",
        },
        {
          name: "SafeBag.bagValue",
          tagClass: V.Class.CONTEXT_SPECIFIC,
          constructed: true,
          captureAsn1: "bagValue",
        },
        {
          name: "SafeBag.bagAttributes",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.SET,
          constructed: true,
          optional: true,
          capture: "bagAttributes",
        },
      ],
    },
    Wtt = {
      name: "Attribute",
      tagClass: V.Class.UNIVERSAL,
      type: V.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "Attribute.attrId",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.OID,
          constructed: false,
          capture: "oid",
        },
        {
          name: "Attribute.attrValues",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.SET,
          constructed: true,
          capture: "values",
        },
      ],
    },
    Gtt = {
      name: "CertBag",
      tagClass: V.Class.UNIVERSAL,
      type: V.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "CertBag.certId",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.OID,
          constructed: false,
          capture: "certId",
        },
        {
          name: "CertBag.certValue",
          tagClass: V.Class.CONTEXT_SPECIFIC,
          constructed: true,
          value: [
            {
              name: "CertBag.certValue[0]",
              tagClass: V.Class.UNIVERSAL,
              type: V.Class.OCTETSTRING,
              constructed: false,
              capture: "cert",
            },
          ],
        },
      ],
    }
  function y_(e, t, r, n) {
    for (var i = [], s = 0; s < e.length; s++)
      for (var o = 0; o < e[s].safeBags.length; o++) {
        var a = e[s].safeBags[o]
        if (!(n !== undefined && a.type !== n)) {
          if (t === null) {
            i.push(a)
            continue
          }
          a.attributes[t] !== undefined &&
            a.attributes[t].indexOf(r) >= 0 &&
            i.push(a)
        }
      }
    return i
  }
  v_.pkcs12FromAsn1 = function (e, t, r) {
    typeof t == "string" ? ((r = t), (t = true)) : t === undefined && (t = true)
    var n = {},
      i = []
    if (!V.validate(e, Vtt, n, i)) {
      var s = new Error(
        "Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.",
      )
      throw ((s.errors = s), s)
    }
    var o = {
      version: n.version.charCodeAt(0),
      safeContents: [],
      getBags: function (v) {
        var C = {},
          E
        return (
          "localKeyId" in v
            ? (E = v.localKeyId)
            : "localKeyIdHex" in v && (E = wn.util.hexToBytes(v.localKeyIdHex)),
          E === undefined &&
            !("friendlyName" in v) &&
            "bagType" in v &&
            (C[v.bagType] = y_(o.safeContents, null, null, v.bagType)),
          E !== undefined &&
            (C.localKeyId = y_(o.safeContents, "localKeyId", E, v.bagType)),
          "friendlyName" in v &&
            (C.friendlyName = y_(
              o.safeContents,
              "friendlyName",
              v.friendlyName,
              v.bagType,
            )),
          C
        )
      },
      getBagsByFriendlyName: function (v, C) {
        return y_(o.safeContents, "friendlyName", v, C)
      },
      getBagsByLocalKeyId: function (v, C) {
        return y_(o.safeContents, "localKeyId", v, C)
      },
    }
    if (n.version.charCodeAt(0) !== 3) {
      var s = new Error("PKCS#12 PFX of version other than 3 not supported.")
      throw ((s.version = n.version.charCodeAt(0)), s)
    }
    if (V.derToOid(n.contentType) !== fr.oids.data) {
      var s = new Error(
        "Only PKCS#12 PFX in password integrity mode supported.",
      )
      throw ((s.oid = V.derToOid(n.contentType)), s)
    }
    var a = n.content.value[0]
    if (a.tagClass !== V.Class.UNIVERSAL || a.type !== V.Type.OCTETSTRING)
      throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.")
    if (((a = ZW(a)), n.mac)) {
      var l = null,
        c = 0,
        u = V.derToOid(n.macAlgorithm)
      switch (u) {
        case fr.oids.sha1:
          ;(l = wn.md.sha1.create()), (c = 20)
          break
        case fr.oids.sha256:
          ;(l = wn.md.sha256.create()), (c = 32)
          break
        case fr.oids.sha384:
          ;(l = wn.md.sha384.create()), (c = 48)
          break
        case fr.oids.sha512:
          ;(l = wn.md.sha512.create()), (c = 64)
          break
        case fr.oids.md5:
          ;(l = wn.md.md5.create()), (c = 16)
          break
      }
      if (l === null)
        throw new Error("PKCS#12 uses unsupported MAC algorithm: " + u)
      var f = new wn.util.ByteBuffer(n.macSalt),
        p =
          "macIterations" in n
            ? parseInt(wn.util.bytesToHex(n.macIterations), 16)
            : 1,
        g = v_.generateKey(r, f, 3, p, c, l),
        m = wn.hmac.create()
      m.start(l, g), m.update(a.value)
      var y = m.getMac()
      if (y.getBytes() !== n.macDigest)
        throw new Error("PKCS#12 MAC could not be verified. Invalid password?")
    }
    return $tt(o, a.value, t, r), o
  }
  function ZW(e) {
    if (e.composed || e.constructed) {
      for (var t = wn.util.createBuffer(), r = 0; r < e.value.length; ++r)
        t.putBytes(e.value[r].value)
      ;(e.composed = e.constructed = false), (e.value = t.getBytes())
    }
    return e
  }
  function $tt(e, t, r, n) {
    if (
      ((t = V.fromDer(t, r)),
      t.tagClass !== V.Class.UNIVERSAL ||
        t.type !== V.Type.SEQUENCE ||
        t.constructed !== true)
    )
      throw new Error(
        "PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo",
      )
    for (var i = 0; i < t.value.length; i++) {
      var s = t.value[i],
        o = {},
        a = []
      if (!V.validate(s, ade, o, a)) {
        var l = new Error("Cannot read ContentInfo.")
        throw ((l.errors = a), l)
      }
      var c = { encrypted: false },
        u = null,
        f = o.content.value[0]
      switch (V.derToOid(o.contentType)) {
        case fr.oids.data:
          if (f.tagClass !== V.Class.UNIVERSAL || f.type !== V.Type.OCTETSTRING)
            throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.")
          u = ZW(f).value
          break
        case fr.oids.encryptedData:
          ;(u = Ytt(f, n)), (c.encrypted = true)
          break
        default:
          var l = new Error("Unsupported PKCS#12 contentType.")
          throw ((l.contentType = V.derToOid(o.contentType)), l)
      }
      ;(c.safeBags = Ktt(u, r, n)), e.safeContents.push(c)
    }
  }
  function Ytt(e, t) {
    var r = {},
      n = []
    if (!V.validate(e, wn.pkcs7.asn1.encryptedDataValidator, r, n)) {
      var i = new Error("Cannot read EncryptedContentInfo.")
      throw ((i.errors = n), i)
    }
    var s = V.derToOid(r.contentType)
    if (s !== fr.oids.data) {
      var i = new Error("PKCS#12 EncryptedContentInfo ContentType is not Data.")
      throw ((i.oid = s), i)
    }
    s = V.derToOid(r.encAlgorithm)
    var o = fr.pbe.getCipher(s, r.encParameter, t),
      a = ZW(r.encryptedContentAsn1),
      l = wn.util.createBuffer(a.value)
    if ((o.update(l), !o.finish()))
      throw new Error("Failed to decrypt PKCS#12 SafeContents.")
    return o.output.getBytes()
  }
  function Ktt(e, t, r) {
    if (!t && e.length === 0) return []
    if (
      ((e = V.fromDer(e, t)),
      e.tagClass !== V.Class.UNIVERSAL ||
        e.type !== V.Type.SEQUENCE ||
        e.constructed !== true)
    )
      throw new Error(
        "PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.",
      )
    for (var n = [], i = 0; i < e.value.length; i++) {
      var s = e.value[i],
        o = {},
        a = []
      if (!V.validate(s, Htt, o, a)) {
        var l = new Error("Cannot read SafeBag.")
        throw ((l.errors = a), l)
      }
      var c = { type: V.derToOid(o.bagId), attributes: ztt(o.bagAttributes) }
      n.push(c)
      var u,
        f,
        p = o.bagValue.value[0]
      switch (c.type) {
        case fr.oids.pkcs8ShroudedKeyBag:
          if (((p = fr.decryptPrivateKeyInfo(p, r)), p === null))
            throw new Error(
              "Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?",
            )
        case fr.oids.keyBag:
          try {
            c.key = fr.privateKeyFromAsn1(p)
          } catch {
            ;(c.key = null), (c.asn1 = p)
          }
          continue
        case fr.oids.certBag:
          ;(u = Gtt),
            (f = function () {
              if (V.derToOid(o.certId) !== fr.oids.x509Certificate) {
                var m = new Error(
                  "Unsupported certificate type, only X.509 supported.",
                )
                throw ((m.oid = V.derToOid(o.certId)), m)
              }
              var y = V.fromDer(o.cert, t)
              try {
                c.cert = fr.certificateFromAsn1(y, true)
              } catch {
                ;(c.cert = null), (c.asn1 = y)
              }
            })
          break
        default:
          var l = new Error("Unsupported PKCS#12 SafeBag type.")
          throw ((l.oid = c.type), l)
      }
      if (u !== undefined && !V.validate(p, u, o, a)) {
        var l = new Error("Cannot read PKCS#12 " + u.name)
        throw ((l.errors = a), l)
      }
      f()
    }
    return n
  }
  function ztt(e) {
    var t = {}
    if (e !== undefined)
      for (var r = 0; r < e.length; ++r) {
        var n = {},
          i = []
        if (!V.validate(e[r], Wtt, n, i)) {
          var s = new Error("Cannot read PKCS#12 BagAttribute.")
          throw ((s.errors = i), s)
        }
        var o = V.derToOid(n.oid)
        if (fr.oids[o] !== undefined) {
          t[fr.oids[o]] = []
          for (var a = 0; a < n.values.length; ++a)
            t[fr.oids[o]].push(n.values[a].value)
        }
      }
    return t
  }
  v_.toPkcs12Asn1 = function (e, t, r, n) {
    ;(n = n || {}),
      (n.saltSize = n.saltSize || 8),
      (n.count = n.count || 2048),
      (n.algorithm = n.algorithm || n.encAlgorithm || "aes128"),
      "useMac" in n || (n.useMac = true),
      "localKeyId" in n || (n.localKeyId = null),
      "generateLocalKeyId" in n || (n.generateLocalKeyId = true)
    var i = n.localKeyId,
      s
    if (i !== null) i = wn.util.hexToBytes(i)
    else if (n.generateLocalKeyId)
      if (t) {
        var o = wn.util.isArray(t) ? t[0] : t
        typeof o == "string" && (o = fr.certificateFromPem(o))
        var a = wn.md.sha1.create()
        a.update(V.toDer(fr.certificateToAsn1(o)).getBytes()),
          (i = a.digest().getBytes())
      } else i = wn.random.getBytes(20)
    var l = []
    i !== null &&
      l.push(
        V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, true, [
          V.create(
            V.Class.UNIVERSAL,
            V.Type.OID,
            false,
            V.oidToDer(fr.oids.localKeyId).getBytes(),
          ),
          V.create(V.Class.UNIVERSAL, V.Type.SET, true, [
            V.create(V.Class.UNIVERSAL, V.Type.OCTETSTRING, false, i),
          ]),
        ]),
      ),
      "friendlyName" in n &&
        l.push(
          V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, true, [
            V.create(
              V.Class.UNIVERSAL,
              V.Type.OID,
              false,
              V.oidToDer(fr.oids.friendlyName).getBytes(),
            ),
            V.create(V.Class.UNIVERSAL, V.Type.SET, true, [
              V.create(V.Class.UNIVERSAL, V.Type.BMPSTRING, false, n.friendlyName),
            ]),
          ]),
        ),
      l.length > 0 && (s = V.create(V.Class.UNIVERSAL, V.Type.SET, true, l))
    var c = [],
      u = []
    t !== null && (wn.util.isArray(t) ? (u = t) : (u = [t]))
    for (var f = [], p = 0; p < u.length; ++p) {
      ;(t = u[p]), typeof t == "string" && (t = fr.certificateFromPem(t))
      var g = p === 0 ? s : undefined,
        m = fr.certificateToAsn1(t),
        y = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, true, [
          V.create(
            V.Class.UNIVERSAL,
            V.Type.OID,
            false,
            V.oidToDer(fr.oids.certBag).getBytes(),
          ),
          V.create(V.Class.CONTEXT_SPECIFIC, 0, true, [
            V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, true, [
              V.create(
                V.Class.UNIVERSAL,
                V.Type.OID,
                false,
                V.oidToDer(fr.oids.x509Certificate).getBytes(),
              ),
              V.create(V.Class.CONTEXT_SPECIFIC, 0, true, [
                V.create(
                  V.Class.UNIVERSAL,
                  V.Type.OCTETSTRING,
                  false,
                  V.toDer(m).getBytes(),
                ),
              ]),
            ]),
          ]),
          g,
        ])
      f.push(y)
    }
    if (f.length > 0) {
      var v = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, true, f),
        C = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, true, [
          V.create(
            V.Class.UNIVERSAL,
            V.Type.OID,
            false,
            V.oidToDer(fr.oids.data).getBytes(),
          ),
          V.create(V.Class.CONTEXT_SPECIFIC, 0, true, [
            V.create(
              V.Class.UNIVERSAL,
              V.Type.OCTETSTRING,
              false,
              V.toDer(v).getBytes(),
            ),
          ]),
        ])
      c.push(C)
    }
    var E = null
    if (e !== null) {
      var w = fr.wrapRsaPrivateKey(fr.privateKeyToAsn1(e))
      r === null
        ? (E = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, true, [
            V.create(
              V.Class.UNIVERSAL,
              V.Type.OID,
              false,
              V.oidToDer(fr.oids.keyBag).getBytes(),
            ),
            V.create(V.Class.CONTEXT_SPECIFIC, 0, true, [w]),
            s,
          ]))
        : (E = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, true, [
            V.create(
              V.Class.UNIVERSAL,
              V.Type.OID,
              false,
              V.oidToDer(fr.oids.pkcs8ShroudedKeyBag).getBytes(),
            ),
            V.create(V.Class.CONTEXT_SPECIFIC, 0, true, [
              fr.encryptPrivateKeyInfo(w, r, n),
            ]),
            s,
          ]))
      var B = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, true, [E]),
        T = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, true, [
          V.create(
            V.Class.UNIVERSAL,
            V.Type.OID,
            false,
            V.oidToDer(fr.oids.data).getBytes(),
          ),
          V.create(V.Class.CONTEXT_SPECIFIC, 0, true, [
            V.create(
              V.Class.UNIVERSAL,
              V.Type.OCTETSTRING,
              false,
              V.toDer(B).getBytes(),
            ),
          ]),
        ])
      c.push(T)
    }
    var N = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, true, c),
      W
    if (n.useMac) {
      var a = wn.md.sha1.create(),
        Z = new wn.util.ByteBuffer(wn.random.getBytes(n.saltSize)),
        te = n.count,
        e = v_.generateKey(r, Z, 3, te, 20),
        Y = wn.hmac.create()
      Y.start(a, e), Y.update(V.toDer(N).getBytes())
      var U = Y.getMac()
      W = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, true, [
        V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, true, [
          V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, true, [
            V.create(
              V.Class.UNIVERSAL,
              V.Type.OID,
              false,
              V.oidToDer(fr.oids.sha1).getBytes(),
            ),
            V.create(V.Class.UNIVERSAL, V.Type.NULL, false, ""),
          ]),
          V.create(V.Class.UNIVERSAL, V.Type.OCTETSTRING, false, U.getBytes()),
        ]),
        V.create(V.Class.UNIVERSAL, V.Type.OCTETSTRING, false, Z.getBytes()),
        V.create(
          V.Class.UNIVERSAL,
          V.Type.INTEGER,
          false,
          V.integerToDer(te).getBytes(),
        ),
      ])
    }
    return V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, true, [
      V.create(
        V.Class.UNIVERSAL,
        V.Type.INTEGER,
        false,
        V.integerToDer(3).getBytes(),
      ),
      V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, true, [
        V.create(
          V.Class.UNIVERSAL,
          V.Type.OID,
          false,
          V.oidToDer(fr.oids.data).getBytes(),
        ),
        V.create(V.Class.CONTEXT_SPECIFIC, 0, true, [
          V.create(
            V.Class.UNIVERSAL,
            V.Type.OCTETSTRING,
            false,
            V.toDer(N).getBytes(),
          ),
        ]),
      ]),
      W,
    ])
  }
  v_.generateKey = wn.pbe.generatePkcs12Key
})
var t5 = _((xkt, cde) => {
  "use strict"
  var Fh = jt()
  Mc()
  Dh()
  KW()
  Hp()
  fT()
  XW()
  vT()
  A_()
  Pr()
  ET()
  var e5 = Fh.asn1,
    wy = (cde.exports = Fh.pki = Fh.pki || {})
  wy.pemToDer = function (e) {
    var t = Fh.pem.decode(e)[0]
    if (t.procType && t.procType.type === "ENCRYPTED")
      throw new Error("Could not convert PEM to DER; PEM is encrypted.")
    return Fh.util.createBuffer(t.body)
  }
  wy.privateKeyFromPem = function (e) {
    var t = Fh.pem.decode(e)[0]
    if (t.type !== "PRIVATE KEY" && t.type !== "RSA PRIVATE KEY") {
      var r = new Error(
        'Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".',
      )
      throw ((r.headerType = t.type), r)
    }
    if (t.procType && t.procType.type === "ENCRYPTED")
      throw new Error(
        "Could not convert private key from PEM; PEM is encrypted.",
      )
    var n = e5.fromDer(t.body)
    return wy.privateKeyFromAsn1(n)
  }
  wy.privateKeyToPem = function (e, t) {
    var r = {
      type: "RSA PRIVATE KEY",
      body: e5.toDer(wy.privateKeyToAsn1(e)).getBytes(),
    }
    return Fh.pem.encode(r, { maxline: t })
  }
  wy.privateKeyInfoToPem = function (e, t) {
    var r = { type: "PRIVATE KEY", body: e5.toDer(e).getBytes() }
    return Fh.pem.encode(r, { maxline: t })
  }
})
var a5 = _((wkt, Ade) => {
  "use strict"
  var me = jt()
  Mc()
  Ay()
  lT()
  Hp()
  t5()
  Tl()
  by()
  Pr()
  var ST = function (e, t, r, n) {
      var i = me.util.createBuffer(),
        s = e.length >> 1,
        o = s + (e.length & 1),
        a = e.substr(0, o),
        l = e.substr(s, o),
        c = me.util.createBuffer(),
        u = me.hmac.create()
      r = t + r
      var f = Math.ceil(n / 16),
        p = Math.ceil(n / 20)
      u.start("MD5", a)
      var g = me.util.createBuffer()
      c.putBytes(r)
      for (var m = 0; m < f; ++m)
        u.start(null, null),
          u.update(c.getBytes()),
          c.putBuffer(u.digest()),
          u.start(null, null),
          u.update(c.bytes() + r),
          g.putBuffer(u.digest())
      u.start("SHA1", l)
      var y = me.util.createBuffer()
      c.clear(), c.putBytes(r)
      for (var m = 0; m < p; ++m)
        u.start(null, null),
          u.update(c.getBytes()),
          c.putBuffer(u.digest()),
          u.start(null, null),
          u.update(c.bytes() + r),
          y.putBuffer(u.digest())
      return i.putBytes(me.util.xorBytes(g.getBytes(), y.getBytes(), n)), i
    },
    Jtt = function (e, t, r) {
      var n = me.hmac.create()
      n.start("SHA1", e)
      var i = me.util.createBuffer()
      return (
        i.putInt32(t[0]),
        i.putInt32(t[1]),
        i.putByte(r.type),
        i.putByte(r.version.major),
        i.putByte(r.version.minor),
        i.putInt16(r.length),
        i.putBytes(r.fragment.bytes()),
        n.update(i.getBytes()),
        n.digest().getBytes()
      )
    },
    jtt = function (e, t, r) {
      var n = false
      try {
        var i = e.deflate(t.fragment.getBytes())
        ;(t.fragment = me.util.createBuffer(i)), (t.length = i.length), (n = true)
      } catch {}
      return n
    },
    Ztt = function (e, t, r) {
      var n = false
      try {
        var i = e.inflate(t.fragment.getBytes())
        ;(t.fragment = me.util.createBuffer(i)), (t.length = i.length), (n = true)
      } catch {}
      return n
    },
    Na = function (e, t) {
      var r = 0
      switch (t) {
        case 1:
          r = e.getByte()
          break
        case 2:
          r = e.getInt16()
          break
        case 3:
          r = e.getInt24()
          break
        case 4:
          r = e.getInt32()
          break
      }
      return me.util.createBuffer(e.getBytes(r))
    },
    Ql = function (e, t, r) {
      e.putInt(r.length(), t << 3), e.putBuffer(r)
    },
    M = {}
  M.Versions = {
    TLS_1_0: { major: 3, minor: 1 },
    TLS_1_1: { major: 3, minor: 2 },
    TLS_1_2: { major: 3, minor: 3 },
  }
  M.SupportedVersions = [M.Versions.TLS_1_1, M.Versions.TLS_1_0]
  M.Version = M.SupportedVersions[0]
  M.MaxFragment = 15360
  M.ConnectionEnd = { server: 0, client: 1 }
  M.PRFAlgorithm = { tls_prf_sha256: 0 }
  M.BulkCipherAlgorithm = { none: null, rc4: 0, des3: 1, aes: 2 }
  M.CipherType = { stream: 0, block: 1, aead: 2 }
  M.MACAlgorithm = {
    none: null,
    hmac_md5: 0,
    hmac_sha1: 1,
    hmac_sha256: 2,
    hmac_sha384: 3,
    hmac_sha512: 4,
  }
  M.CompressionMethod = { none: 0, deflate: 1 }
  M.ContentType = {
    change_cipher_spec: 20,
    alert: 21,
    handshake: 22,
    application_data: 23,
    heartbeat: 24,
  }
  M.HandshakeType = {
    hello_request: 0,
    client_hello: 1,
    server_hello: 2,
    certificate: 11,
    server_key_exchange: 12,
    certificate_request: 13,
    server_hello_done: 14,
    certificate_verify: 15,
    client_key_exchange: 16,
    finished: 20,
  }
  M.Alert = {}
  M.Alert.Level = { warning: 1, fatal: 2 }
  M.Alert.Description = {
    close_notify: 0,
    unexpected_message: 10,
    bad_record_mac: 20,
    decryption_failed: 21,
    record_overflow: 22,
    decompression_failure: 30,
    handshake_failure: 40,
    bad_certificate: 42,
    unsupported_certificate: 43,
    certificate_revoked: 44,
    certificate_expired: 45,
    certificate_unknown: 46,
    illegal_parameter: 47,
    unknown_ca: 48,
    access_denied: 49,
    decode_error: 50,
    decrypt_error: 51,
    export_restriction: 60,
    protocol_version: 70,
    insufficient_security: 71,
    internal_error: 80,
    user_canceled: 90,
    no_renegotiation: 100,
  }
  M.HeartbeatMessageType = { heartbeat_request: 1, heartbeat_response: 2 }
  M.CipherSuites = {}
  M.getCipherSuite = function (e) {
    var t = null
    for (var r in M.CipherSuites) {
      var n = M.CipherSuites[r]
      if (n.id[0] === e.charCodeAt(0) && n.id[1] === e.charCodeAt(1)) {
        t = n
        break
      }
    }
    return t
  }
  M.handleUnexpected = function (e, t) {
    var r = !e.open && e.entity === M.ConnectionEnd.client
    r ||
      e.error(e, {
        message: "Unexpected message. Received TLS record out of order.",
        send: true,
        alert: {
          level: M.Alert.Level.fatal,
          description: M.Alert.Description.unexpected_message,
        },
      })
  }
  M.handleHelloRequest = function (e, t, r) {
    !e.handshaking &&
      e.handshakes > 0 &&
      (M.queue(
        e,
        M.createAlert(e, {
          level: M.Alert.Level.warning,
          description: M.Alert.Description.no_renegotiation,
        }),
      ),
      M.flush(e)),
      e.process()
  }
  M.parseHelloMessage = function (e, t, r) {
    var n = null,
      i = e.entity === M.ConnectionEnd.client
    if (r < 38)
      e.error(e, {
        message: i
          ? "Invalid ServerHello message. Message too short."
          : "Invalid ClientHello message. Message too short.",
        send: true,
        alert: {
          level: M.Alert.Level.fatal,
          description: M.Alert.Description.illegal_parameter,
        },
      })
    else {
      var s = t.fragment,
        o = s.length()
      if (
        ((n = {
          version: { major: s.getByte(), minor: s.getByte() },
          random: me.util.createBuffer(s.getBytes(32)),
          session_id: Na(s, 1),
          extensions: [],
        }),
        i
          ? ((n.cipher_suite = s.getBytes(2)),
            (n.compression_method = s.getByte()))
          : ((n.cipher_suites = Na(s, 2)), (n.compression_methods = Na(s, 1))),
        (o = r - (o - s.length())),
        o > 0)
      ) {
        for (var a = Na(s, 2); a.length() > 0; )
          n.extensions.push({
            type: [a.getByte(), a.getByte()],
            data: Na(a, 2),
          })
        if (!i)
          for (var l = 0; l < n.extensions.length; ++l) {
            var c = n.extensions[l]
            if (c.type[0] === 0 && c.type[1] === 0)
              for (var u = Na(c.data, 2); u.length() > 0; ) {
                var f = u.getByte()
                if (f !== 0) break
                e.session.extensions.server_name.serverNameList.push(
                  Na(u, 2).getBytes(),
                )
              }
          }
      }
      if (
        e.session.version &&
        (n.version.major !== e.session.version.major ||
          n.version.minor !== e.session.version.minor)
      )
        return e.error(e, {
          message: "TLS version change is disallowed during renegotiation.",
          send: true,
          alert: {
            level: M.Alert.Level.fatal,
            description: M.Alert.Description.protocol_version,
          },
        })
      if (i) e.session.cipherSuite = M.getCipherSuite(n.cipher_suite)
      else
        for (
          var p = me.util.createBuffer(n.cipher_suites.bytes());
          p.length() > 0 &&
          ((e.session.cipherSuite = M.getCipherSuite(p.getBytes(2))),
          e.session.cipherSuite === null);

        );
      if (e.session.cipherSuite === null)
        return e.error(e, {
          message: "No cipher suites in common.",
          send: true,
          alert: {
            level: M.Alert.Level.fatal,
            description: M.Alert.Description.handshake_failure,
          },
          cipherSuite: me.util.bytesToHex(n.cipher_suite),
        })
      i
        ? (e.session.compressionMethod = n.compression_method)
        : (e.session.compressionMethod = M.CompressionMethod.none)
    }
    return n
  }
  M.createSecurityParameters = function (e, t) {
    var r = e.entity === M.ConnectionEnd.client,
      n = t.random.bytes(),
      i = r ? e.session.sp.client_random : n,
      s = r ? n : M.createRandom().getBytes()
    e.session.sp = {
      entity: e.entity,
      prf_algorithm: M.PRFAlgorithm.tls_prf_sha256,
      bulk_cipher_algorithm: null,
      cipher_type: null,
      enc_key_length: null,
      block_length: null,
      fixed_iv_length: null,
      record_iv_length: null,
      mac_algorithm: null,
      mac_length: null,
      mac_key_length: null,
      compression_algorithm: e.session.compressionMethod,
      pre_master_secret: null,
      master_secret: null,
      client_random: i,
      server_random: s,
    }
  }
  M.handleServerHello = function (e, t, r) {
    var n = M.parseHelloMessage(e, t, r)
    if (!e.fail) {
      if (n.version.minor <= e.version.minor) e.version.minor = n.version.minor
      else
        return e.error(e, {
          message: "Incompatible TLS version.",
          send: true,
          alert: {
            level: M.Alert.Level.fatal,
            description: M.Alert.Description.protocol_version,
          },
        })
      e.session.version = e.version
      var i = n.session_id.bytes()
      i.length > 0 && i === e.session.id
        ? ((e.expect = fde),
          (e.session.resuming = true),
          (e.session.sp.server_random = n.random.bytes()))
        : ((e.expect = ert),
          (e.session.resuming = false),
          M.createSecurityParameters(e, n)),
        (e.session.id = i),
        e.process()
    }
  }
  M.handleClientHello = function (e, t, r) {
    var n = M.parseHelloMessage(e, t, r)
    if (!e.fail) {
      var i = n.session_id.bytes(),
        s = null
      if (
        (e.sessionCache &&
          ((s = e.sessionCache.getSession(i)),
          s === null
            ? (i = "")
            : (s.version.major !== n.version.major ||
                s.version.minor > n.version.minor) &&
              ((s = null), (i = ""))),
        i.length === 0 && (i = me.random.getBytes(32)),
        (e.session.id = i),
        (e.session.clientHelloVersion = n.version),
        (e.session.sp = {}),
        s)
      )
        (e.version = e.session.version = s.version), (e.session.sp = s.sp)
      else {
        for (
          var o, a = 1;
          a < M.SupportedVersions.length &&
          ((o = M.SupportedVersions[a]), !(o.minor <= n.version.minor));
          ++a
        );
        ;(e.version = { major: o.major, minor: o.minor }),
          (e.session.version = e.version)
      }
      s !== null
        ? ((e.expect = s5),
          (e.session.resuming = true),
          (e.session.sp.client_random = n.random.bytes()))
        : ((e.expect = e.verifyClient !== false ? art : i5),
          (e.session.resuming = false),
          M.createSecurityParameters(e, n)),
        (e.open = true),
        M.queue(
          e,
          M.createRecord(e, {
            type: M.ContentType.handshake,
            data: M.createServerHello(e),
          }),
        ),
        e.session.resuming
          ? (M.queue(
              e,
              M.createRecord(e, {
                type: M.ContentType.change_cipher_spec,
                data: M.createChangeCipherSpec(),
              }),
            ),
            (e.state.pending = M.createConnectionState(e)),
            (e.state.current.write = e.state.pending.write),
            M.queue(
              e,
              M.createRecord(e, {
                type: M.ContentType.handshake,
                data: M.createFinished(e),
              }),
            ))
          : (M.queue(
              e,
              M.createRecord(e, {
                type: M.ContentType.handshake,
                data: M.createCertificate(e),
              }),
            ),
            e.fail ||
              (M.queue(
                e,
                M.createRecord(e, {
                  type: M.ContentType.handshake,
                  data: M.createServerKeyExchange(e),
                }),
              ),
              e.verifyClient !== false &&
                M.queue(
                  e,
                  M.createRecord(e, {
                    type: M.ContentType.handshake,
                    data: M.createCertificateRequest(e),
                  }),
                ),
              M.queue(
                e,
                M.createRecord(e, {
                  type: M.ContentType.handshake,
                  data: M.createServerHelloDone(e),
                }),
              ))),
        M.flush(e),
        e.process()
    }
  }
  M.handleCertificate = function (e, t, r) {
    if (r < 3)
      return e.error(e, {
        message: "Invalid Certificate message. Message too short.",
        send: true,
        alert: {
          level: M.Alert.Level.fatal,
          description: M.Alert.Description.illegal_parameter,
        },
      })
    var n = t.fragment,
      i = { certificate_list: Na(n, 3) },
      s,
      o,
      a = []
    try {
      for (; i.certificate_list.length() > 0; )
        (s = Na(i.certificate_list, 3)),
          (o = me.asn1.fromDer(s)),
          (s = me.pki.certificateFromAsn1(o, true)),
          a.push(s)
    } catch (c) {
      return e.error(e, {
        message: "Could not parse certificate list.",
        cause: c,
        send: true,
        alert: {
          level: M.Alert.Level.fatal,
          description: M.Alert.Description.bad_certificate,
        },
      })
    }
    var l = e.entity === M.ConnectionEnd.client
    ;(l || e.verifyClient === true) && a.length === 0
      ? e.error(e, {
          message: l
            ? "No server certificate provided."
            : "No client certificate provided.",
          send: true,
          alert: {
            level: M.Alert.Level.fatal,
            description: M.Alert.Description.illegal_parameter,
          },
        })
      : a.length === 0
        ? (e.expect = l ? ude : i5)
        : (l
            ? (e.session.serverCertificate = a[0])
            : (e.session.clientCertificate = a[0]),
          M.verifyCertificateChain(e, a) && (e.expect = l ? ude : i5)),
      e.process()
  }
  M.handleServerKeyExchange = function (e, t, r) {
    if (r > 0)
      return e.error(e, {
        message: "Invalid key parameters. Only RSA is supported.",
        send: true,
        alert: {
          level: M.Alert.Level.fatal,
          description: M.Alert.Description.unsupported_certificate,
        },
      })
    ;(e.expect = trt), e.process()
  }
  M.handleClientKeyExchange = function (e, t, r) {
    if (r < 48)
      return e.error(e, {
        message: "Invalid key parameters. Only RSA is supported.",
        send: true,
        alert: {
          level: M.Alert.Level.fatal,
          description: M.Alert.Description.unsupported_certificate,
        },
      })
    var n = t.fragment,
      i = { enc_pre_master_secret: Na(n, 2).getBytes() },
      s = null
    if (e.getPrivateKey)
      try {
        ;(s = e.getPrivateKey(e, e.session.serverCertificate)),
          (s = me.pki.privateKeyFromPem(s))
      } catch (l) {
        e.error(e, {
          message: "Could not get private key.",
          cause: l,
          send: true,
          alert: {
            level: M.Alert.Level.fatal,
            description: M.Alert.Description.internal_error,
          },
        })
      }
    if (s === null)
      return e.error(e, {
        message: "No private key set.",
        send: true,
        alert: {
          level: M.Alert.Level.fatal,
          description: M.Alert.Description.internal_error,
        },
      })
    try {
      var o = e.session.sp
      o.pre_master_secret = s.decrypt(i.enc_pre_master_secret)
      var a = e.session.clientHelloVersion
      if (
        a.major !== o.pre_master_secret.charCodeAt(0) ||
        a.minor !== o.pre_master_secret.charCodeAt(1)
      )
        throw new Error("TLS version rollback attack detected.")
    } catch {
      o.pre_master_secret = me.random.getBytes(48)
    }
    ;(e.expect = s5),
      e.session.clientCertificate !== null && (e.expect = lrt),
      e.process()
  }
  M.handleCertificateRequest = function (e, t, r) {
    if (r < 3)
      return e.error(e, {
        message: "Invalid CertificateRequest. Message too short.",
        send: true,
        alert: {
          level: M.Alert.Level.fatal,
          description: M.Alert.Description.illegal_parameter,
        },
      })
    var n = t.fragment,
      i = { certificate_types: Na(n, 1), certificate_authorities: Na(n, 2) }
    ;(e.session.certificateRequest = i), (e.expect = rrt), e.process()
  }
  M.handleCertificateVerify = function (e, t, r) {
    if (r < 2)
      return e.error(e, {
        message: "Invalid CertificateVerify. Message too short.",
        send: true,
        alert: {
          level: M.Alert.Level.fatal,
          description: M.Alert.Description.illegal_parameter,
        },
      })
    var n = t.fragment
    n.read -= 4
    var i = n.bytes()
    n.read += 4
    var s = { signature: Na(n, 2).getBytes() },
      o = me.util.createBuffer()
    o.putBuffer(e.session.md5.digest()),
      o.putBuffer(e.session.sha1.digest()),
      (o = o.getBytes())
    try {
      var a = e.session.clientCertificate
      if (!a.publicKey.verify(o, s.signature, "NONE"))
        throw new Error("CertificateVerify signature does not match.")
      e.session.md5.update(i), e.session.sha1.update(i)
    } catch {
      return e.error(e, {
        message: "Bad signature in CertificateVerify.",
        send: true,
        alert: {
          level: M.Alert.Level.fatal,
          description: M.Alert.Description.handshake_failure,
        },
      })
    }
    ;(e.expect = s5), e.process()
  }
  M.handleServerHelloDone = function (e, t, r) {
    if (r > 0)
      return e.error(e, {
        message: "Invalid ServerHelloDone message. Invalid length.",
        send: true,
        alert: {
          level: M.Alert.Level.fatal,
          description: M.Alert.Description.record_overflow,
        },
      })
    if (e.serverCertificate === null) {
      var n = {
          message: "No server certificate provided. Not enough security.",
          send: true,
          alert: {
            level: M.Alert.Level.fatal,
            description: M.Alert.Description.insufficient_security,
          },
        },
        i = 0,
        s = e.verify(e, n.alert.description, i, [])
      if (s !== true)
        return (
          (s || s === 0) &&
            (typeof s == "object" && !me.util.isArray(s)
              ? (s.message && (n.message = s.message),
                s.alert && (n.alert.description = s.alert))
              : typeof s == "number" && (n.alert.description = s)),
          e.error(e, n)
        )
    }
    e.session.certificateRequest !== null &&
      ((t = M.createRecord(e, {
        type: M.ContentType.handshake,
        data: M.createCertificate(e),
      })),
      M.queue(e, t)),
      (t = M.createRecord(e, {
        type: M.ContentType.handshake,
        data: M.createClientKeyExchange(e),
      })),
      M.queue(e, t),
      (e.expect = srt)
    var o = function (a, l) {
      a.session.certificateRequest !== null &&
        a.session.clientCertificate !== null &&
        M.queue(
          a,
          M.createRecord(a, {
            type: M.ContentType.handshake,
            data: M.createCertificateVerify(a, l),
          }),
        ),
        M.queue(
          a,
          M.createRecord(a, {
            type: M.ContentType.change_cipher_spec,
            data: M.createChangeCipherSpec(),
          }),
        ),
        (a.state.pending = M.createConnectionState(a)),
        (a.state.current.write = a.state.pending.write),
        M.queue(
          a,
          M.createRecord(a, {
            type: M.ContentType.handshake,
            data: M.createFinished(a),
          }),
        ),
        (a.expect = fde),
        M.flush(a),
        a.process()
    }
    if (
      e.session.certificateRequest === null ||
      e.session.clientCertificate === null
    )
      return o(e, null)
    M.getClientSignature(e, o)
  }
  M.handleChangeCipherSpec = function (e, t) {
    if (t.fragment.getByte() !== 1)
      return e.error(e, {
        message: "Invalid ChangeCipherSpec message received.",
        send: true,
        alert: {
          level: M.Alert.Level.fatal,
          description: M.Alert.Description.illegal_parameter,
        },
      })
    var r = e.entity === M.ConnectionEnd.client
    ;((e.session.resuming && r) || (!e.session.resuming && !r)) &&
      (e.state.pending = M.createConnectionState(e)),
      (e.state.current.read = e.state.pending.read),
      ((!e.session.resuming && r) || (e.session.resuming && !r)) &&
        (e.state.pending = null),
      (e.expect = r ? nrt : crt),
      e.process()
  }
  M.handleFinished = function (e, t, r) {
    var n = t.fragment
    n.read -= 4
    var i = n.bytes()
    n.read += 4
    var s = t.fragment.getBytes()
    ;(n = me.util.createBuffer()),
      n.putBuffer(e.session.md5.digest()),
      n.putBuffer(e.session.sha1.digest())
    var o = e.entity === M.ConnectionEnd.client,
      a = o ? "server finished" : "client finished",
      l = e.session.sp,
      c = 12,
      u = ST
    if (((n = u(l.master_secret, a, n.getBytes(), c)), n.getBytes() !== s))
      return e.error(e, {
        message: "Invalid verify_data in Finished message.",
        send: true,
        alert: {
          level: M.Alert.Level.fatal,
          description: M.Alert.Description.decrypt_error,
        },
      })
    e.session.md5.update(i),
      e.session.sha1.update(i),
      ((e.session.resuming && o) || (!e.session.resuming && !o)) &&
        (M.queue(
          e,
          M.createRecord(e, {
            type: M.ContentType.change_cipher_spec,
            data: M.createChangeCipherSpec(),
          }),
        ),
        (e.state.current.write = e.state.pending.write),
        (e.state.pending = null),
        M.queue(
          e,
          M.createRecord(e, {
            type: M.ContentType.handshake,
            data: M.createFinished(e),
          }),
        )),
      (e.expect = o ? irt : urt),
      (e.handshaking = false),
      ++e.handshakes,
      (e.peerCertificate = o
        ? e.session.serverCertificate
        : e.session.clientCertificate),
      M.flush(e),
      (e.isConnected = true),
      e.connected(e),
      e.process()
  }
  M.handleAlert = function (e, t) {
    var r = t.fragment,
      n = { level: r.getByte(), description: r.getByte() },
      i
    switch (n.description) {
      case M.Alert.Description.close_notify:
        i = "Connection closed."
        break
      case M.Alert.Description.unexpected_message:
        i = "Unexpected message."
        break
      case M.Alert.Description.bad_record_mac:
        i = "Bad record MAC."
        break
      case M.Alert.Description.decryption_failed:
        i = "Decryption failed."
        break
      case M.Alert.Description.record_overflow:
        i = "Record overflow."
        break
      case M.Alert.Description.decompression_failure:
        i = "Decompression failed."
        break
      case M.Alert.Description.handshake_failure:
        i = "Handshake failure."
        break
      case M.Alert.Description.bad_certificate:
        i = "Bad certificate."
        break
      case M.Alert.Description.unsupported_certificate:
        i = "Unsupported certificate."
        break
      case M.Alert.Description.certificate_revoked:
        i = "Certificate revoked."
        break
      case M.Alert.Description.certificate_expired:
        i = "Certificate expired."
        break
      case M.Alert.Description.certificate_unknown:
        i = "Certificate unknown."
        break
      case M.Alert.Description.illegal_parameter:
        i = "Illegal parameter."
        break
      case M.Alert.Description.unknown_ca:
        i = "Unknown certificate authority."
        break
      case M.Alert.Description.access_denied:
        i = "Access denied."
        break
      case M.Alert.Description.decode_error:
        i = "Decode error."
        break
      case M.Alert.Description.decrypt_error:
        i = "Decrypt error."
        break
      case M.Alert.Description.export_restriction:
        i = "Export restriction."
        break
      case M.Alert.Description.protocol_version:
        i = "Unsupported protocol version."
        break
      case M.Alert.Description.insufficient_security:
        i = "Insufficient security."
        break
      case M.Alert.Description.internal_error:
        i = "Internal error."
        break
      case M.Alert.Description.user_canceled:
        i = "User canceled."
        break
      case M.Alert.Description.no_renegotiation:
        i = "Renegotiation not supported."
        break
      default:
        i = "Unknown error."
        break
    }
    if (n.description === M.Alert.Description.close_notify) return e.close()
    e.error(e, {
      message: i,
      send: false,
      origin: e.entity === M.ConnectionEnd.client ? "server" : "client",
      alert: n,
    }),
      e.process()
  }
  M.handleHandshake = function (e, t) {
    var r = t.fragment,
      n = r.getByte(),
      i = r.getInt24()
    if (i > r.length())
      return (
        (e.fragmented = t),
        (t.fragment = me.util.createBuffer()),
        (r.read -= 4),
        e.process()
      )
    ;(e.fragmented = null), (r.read -= 4)
    var s = r.bytes(i + 4)
    ;(r.read += 4),
      n in wT[e.entity][e.expect]
        ? (e.entity === M.ConnectionEnd.server &&
            !e.open &&
            !e.fail &&
            ((e.handshaking = true),
            (e.session = {
              version: null,
              extensions: { server_name: { serverNameList: [] } },
              cipherSuite: null,
              compressionMethod: null,
              serverCertificate: null,
              clientCertificate: null,
              md5: me.md.md5.create(),
              sha1: me.md.sha1.create(),
            })),
          n !== M.HandshakeType.hello_request &&
            n !== M.HandshakeType.certificate_verify &&
            n !== M.HandshakeType.finished &&
            (e.session.md5.update(s), e.session.sha1.update(s)),
          wT[e.entity][e.expect][n](e, t, i))
        : M.handleUnexpected(e, t)
  }
  M.handleApplicationData = function (e, t) {
    e.data.putBuffer(t.fragment), e.dataReady(e), e.process()
  }
  M.handleHeartbeat = function (e, t) {
    var r = t.fragment,
      n = r.getByte(),
      i = r.getInt16(),
      s = r.getBytes(i)
    if (n === M.HeartbeatMessageType.heartbeat_request) {
      if (e.handshaking || i > s.length) return e.process()
      M.queue(
        e,
        M.createRecord(e, {
          type: M.ContentType.heartbeat,
          data: M.createHeartbeat(M.HeartbeatMessageType.heartbeat_response, s),
        }),
      ),
        M.flush(e)
    } else if (n === M.HeartbeatMessageType.heartbeat_response) {
      if (s !== e.expectedHeartbeatPayload) return e.process()
      e.heartbeatReceived && e.heartbeatReceived(e, me.util.createBuffer(s))
    }
    e.process()
  }
  var Xtt = 0,
    ert = 1,
    ude = 2,
    trt = 3,
    rrt = 4,
    fde = 5,
    nrt = 6,
    irt = 7,
    srt = 8,
    ort = 0,
    art = 1,
    i5 = 2,
    lrt = 3,
    s5 = 4,
    crt = 5,
    urt = 6,
    D = M.handleUnexpected,
    hde = M.handleChangeCipherSpec,
    Bs = M.handleAlert,
    bo = M.handleHandshake,
    gde = M.handleApplicationData,
    Rs = M.handleHeartbeat,
    o5 = []
  o5[M.ConnectionEnd.client] = [
    [D, Bs, bo, D, Rs],
    [D, Bs, bo, D, Rs],
    [D, Bs, bo, D, Rs],
    [D, Bs, bo, D, Rs],
    [D, Bs, bo, D, Rs],
    [hde, Bs, D, D, Rs],
    [D, Bs, bo, D, Rs],
    [D, Bs, bo, gde, Rs],
    [D, Bs, bo, D, Rs],
  ]
  o5[M.ConnectionEnd.server] = [
    [D, Bs, bo, D, Rs],
    [D, Bs, bo, D, Rs],
    [D, Bs, bo, D, Rs],
    [D, Bs, bo, D, Rs],
    [hde, Bs, D, D, Rs],
    [D, Bs, bo, D, Rs],
    [D, Bs, bo, gde, Rs],
    [D, Bs, bo, D, Rs],
  ]
  var Qh = M.handleHelloRequest,
    drt = M.handleServerHello,
    pde = M.handleCertificate,
    dde = M.handleServerKeyExchange,
    r5 = M.handleCertificateRequest,
    _T = M.handleServerHelloDone,
    mde = M.handleFinished,
    wT = []
  wT[M.ConnectionEnd.client] = [
    [D, D, drt, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D],
    [Qh, D, D, D, D, D, D, D, D, D, D, pde, dde, r5, _T, D, D, D, D, D, D],
    [Qh, D, D, D, D, D, D, D, D, D, D, D, dde, r5, _T, D, D, D, D, D, D],
    [Qh, D, D, D, D, D, D, D, D, D, D, D, D, r5, _T, D, D, D, D, D, D],
    [Qh, D, D, D, D, D, D, D, D, D, D, D, D, D, _T, D, D, D, D, D, D],
    [Qh, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D],
    [Qh, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, mde],
    [Qh, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D],
    [Qh, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D],
  ]
  var frt = M.handleClientHello,
    hrt = M.handleClientKeyExchange,
    grt = M.handleCertificateVerify
  wT[M.ConnectionEnd.server] = [
    [D, frt, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D],
    [D, D, D, D, D, D, D, D, D, D, D, pde, D, D, D, D, D, D, D, D, D],
    [D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, hrt, D, D, D, D],
    [D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, grt, D, D, D, D, D],
    [D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D],
    [D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, mde],
    [D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D],
    [D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D],
  ]
  M.generateKeys = function (e, t) {
    var r = ST,
      n = t.client_random + t.server_random
    e.session.resuming ||
      ((t.master_secret = r(
        t.pre_master_secret,
        "master secret",
        n,
        48,
      ).bytes()),
      (t.pre_master_secret = null)),
      (n = t.server_random + t.client_random)
    var i = 2 * t.mac_key_length + 2 * t.enc_key_length,
      s =
        e.version.major === M.Versions.TLS_1_0.major &&
        e.version.minor === M.Versions.TLS_1_0.minor
    s && (i += 2 * t.fixed_iv_length)
    var o = r(t.master_secret, "key expansion", n, i),
      a = {
        client_write_MAC_key: o.getBytes(t.mac_key_length),
        server_write_MAC_key: o.getBytes(t.mac_key_length),
        client_write_key: o.getBytes(t.enc_key_length),
        server_write_key: o.getBytes(t.enc_key_length),
      }
    return (
      s &&
        ((a.client_write_IV = o.getBytes(t.fixed_iv_length)),
        (a.server_write_IV = o.getBytes(t.fixed_iv_length))),
      a
    )
  }
  M.createConnectionState = function (e) {
    var t = e.entity === M.ConnectionEnd.client,
      r = function () {
        var s = {
          sequenceNumber: [0, 0],
          macKey: null,
          macLength: 0,
          macFunction: null,
          cipherState: null,
          cipherFunction: function (o) {
            return true
          },
          compressionState: null,
          compressFunction: function (o) {
            return true
          },
          updateSequenceNumber: function () {
            s.sequenceNumber[1] === 4294967295
              ? ((s.sequenceNumber[1] = 0), ++s.sequenceNumber[0])
              : ++s.sequenceNumber[1]
          },
        }
        return s
      },
      n = { read: r(), write: r() }
    if (
      ((n.read.update = function (s, o) {
        return (
          n.read.cipherFunction(o, n.read)
            ? n.read.compressFunction(s, o, n.read) ||
              s.error(s, {
                message: "Could not decompress record.",
                send: true,
                alert: {
                  level: M.Alert.Level.fatal,
                  description: M.Alert.Description.decompression_failure,
                },
              })
            : s.error(s, {
                message: "Could not decrypt record or bad MAC.",
                send: true,
                alert: {
                  level: M.Alert.Level.fatal,
                  description: M.Alert.Description.bad_record_mac,
                },
              }),
          !s.fail
        )
      }),
      (n.write.update = function (s, o) {
        return (
          n.write.compressFunction(s, o, n.write)
            ? n.write.cipherFunction(o, n.write) ||
              s.error(s, {
                message: "Could not encrypt record.",
                send: false,
                alert: {
                  level: M.Alert.Level.fatal,
                  description: M.Alert.Description.internal_error,
                },
              })
            : s.error(s, {
                message: "Could not compress record.",
                send: false,
                alert: {
                  level: M.Alert.Level.fatal,
                  description: M.Alert.Description.internal_error,
                },
              }),
          !s.fail
        )
      }),
      e.session)
    ) {
      var i = e.session.sp
      switch (
        (e.session.cipherSuite.initSecurityParameters(i),
        (i.keys = M.generateKeys(e, i)),
        (n.read.macKey = t
          ? i.keys.server_write_MAC_key
          : i.keys.client_write_MAC_key),
        (n.write.macKey = t
          ? i.keys.client_write_MAC_key
          : i.keys.server_write_MAC_key),
        e.session.cipherSuite.initConnectionState(n, e, i),
        i.compression_algorithm)
      ) {
        case M.CompressionMethod.none:
          break
        case M.CompressionMethod.deflate:
          ;(n.read.compressFunction = Ztt), (n.write.compressFunction = jtt)
          break
        default:
          throw new Error("Unsupported compression algorithm.")
      }
    }
    return n
  }
  M.createRandom = function () {
    var e = new Date(),
      t = +e + e.getTimezoneOffset() * 6e4,
      r = me.util.createBuffer()
    return r.putInt32(t), r.putBytes(me.random.getBytes(28)), r
  }
  M.createRecord = function (e, t) {
    if (!t.data) return null
    var r = {
      type: t.type,
      version: { major: e.version.major, minor: e.version.minor },
      length: t.data.length(),
      fragment: t.data,
    }
    return r
  }
  M.createAlert = function (e, t) {
    var r = me.util.createBuffer()
    return (
      r.putByte(t.level),
      r.putByte(t.description),
      M.createRecord(e, { type: M.ContentType.alert, data: r })
    )
  }
  M.createClientHello = function (e) {
    e.session.clientHelloVersion = {
      major: e.version.major,
      minor: e.version.minor,
    }
    for (
      var t = me.util.createBuffer(), r = 0;
      r < e.cipherSuites.length;
      ++r
    ) {
      var n = e.cipherSuites[r]
      t.putByte(n.id[0]), t.putByte(n.id[1])
    }
    var i = t.length(),
      s = me.util.createBuffer()
    s.putByte(M.CompressionMethod.none)
    var o = s.length(),
      a = me.util.createBuffer()
    if (e.virtualHost) {
      var l = me.util.createBuffer()
      l.putByte(0), l.putByte(0)
      var c = me.util.createBuffer()
      c.putByte(0), Ql(c, 2, me.util.createBuffer(e.virtualHost))
      var u = me.util.createBuffer()
      Ql(u, 2, c), Ql(l, 2, u), a.putBuffer(l)
    }
    var f = a.length()
    f > 0 && (f += 2)
    var p = e.session.id,
      g = p.length + 1 + 2 + 4 + 28 + 2 + i + 1 + o + f,
      m = me.util.createBuffer()
    return (
      m.putByte(M.HandshakeType.client_hello),
      m.putInt24(g),
      m.putByte(e.version.major),
      m.putByte(e.version.minor),
      m.putBytes(e.session.sp.client_random),
      Ql(m, 1, me.util.createBuffer(p)),
      Ql(m, 2, t),
      Ql(m, 1, s),
      f > 0 && Ql(m, 2, a),
      m
    )
  }
  M.createServerHello = function (e) {
    var t = e.session.id,
      r = t.length + 1 + 2 + 4 + 28 + 2 + 1,
      n = me.util.createBuffer()
    return (
      n.putByte(M.HandshakeType.server_hello),
      n.putInt24(r),
      n.putByte(e.version.major),
      n.putByte(e.version.minor),
      n.putBytes(e.session.sp.server_random),
      Ql(n, 1, me.util.createBuffer(t)),
      n.putByte(e.session.cipherSuite.id[0]),
      n.putByte(e.session.cipherSuite.id[1]),
      n.putByte(e.session.compressionMethod),
      n
    )
  }
  M.createCertificate = function (e) {
    var t = e.entity === M.ConnectionEnd.client,
      r = null
    if (e.getCertificate) {
      var n
      t
        ? (n = e.session.certificateRequest)
        : (n = e.session.extensions.server_name.serverNameList),
        (r = e.getCertificate(e, n))
    }
    var i = me.util.createBuffer()
    if (r !== null)
      try {
        me.util.isArray(r) || (r = [r])
        for (var s = null, o = 0; o < r.length; ++o) {
          var a = me.pem.decode(r[o])[0]
          if (
            a.type !== "CERTIFICATE" &&
            a.type !== "X509 CERTIFICATE" &&
            a.type !== "TRUSTED CERTIFICATE"
          ) {
            var l = new Error(
              'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".',
            )
            throw ((l.headerType = a.type), l)
          }
          if (a.procType && a.procType.type === "ENCRYPTED")
            throw new Error(
              "Could not convert certificate from PEM; PEM is encrypted.",
            )
          var c = me.util.createBuffer(a.body)
          s === null && (s = me.asn1.fromDer(c.bytes(), false))
          var u = me.util.createBuffer()
          Ql(u, 3, c), i.putBuffer(u)
        }
        ;(r = me.pki.certificateFromAsn1(s)),
          t
            ? (e.session.clientCertificate = r)
            : (e.session.serverCertificate = r)
      } catch (g) {
        return e.error(e, {
          message: "Could not send certificate list.",
          cause: g,
          send: true,
          alert: {
            level: M.Alert.Level.fatal,
            description: M.Alert.Description.bad_certificate,
          },
        })
      }
    var f = 3 + i.length(),
      p = me.util.createBuffer()
    return p.putByte(M.HandshakeType.certificate), p.putInt24(f), Ql(p, 3, i), p
  }
  M.createClientKeyExchange = function (e) {
    var t = me.util.createBuffer()
    t.putByte(e.session.clientHelloVersion.major),
      t.putByte(e.session.clientHelloVersion.minor),
      t.putBytes(me.random.getBytes(46))
    var r = e.session.sp
    r.pre_master_secret = t.getBytes()
    var n = e.session.serverCertificate.publicKey
    t = n.encrypt(r.pre_master_secret)
    var i = t.length + 2,
      s = me.util.createBuffer()
    return (
      s.putByte(M.HandshakeType.client_key_exchange),
      s.putInt24(i),
      s.putInt16(t.length),
      s.putBytes(t),
      s
    )
  }
  M.createServerKeyExchange = function (e) {
    var t = 0,
      r = me.util.createBuffer()
    return (
      t > 0 && (r.putByte(M.HandshakeType.server_key_exchange), r.putInt24(t)),
      r
    )
  }
  M.getClientSignature = function (e, t) {
    var r = me.util.createBuffer()
    r.putBuffer(e.session.md5.digest()),
      r.putBuffer(e.session.sha1.digest()),
      (r = r.getBytes()),
      (e.getSignature =
        e.getSignature ||
        function (n, i, s) {
          var o = null
          if (n.getPrivateKey)
            try {
              ;(o = n.getPrivateKey(n, n.session.clientCertificate)),
                (o = me.pki.privateKeyFromPem(o))
            } catch (a) {
              n.error(n, {
                message: "Could not get private key.",
                cause: a,
                send: true,
                alert: {
                  level: M.Alert.Level.fatal,
                  description: M.Alert.Description.internal_error,
                },
              })
            }
          o === null
            ? n.error(n, {
                message: "No private key set.",
                send: true,
                alert: {
                  level: M.Alert.Level.fatal,
                  description: M.Alert.Description.internal_error,
                },
              })
            : (i = o.sign(i, null)),
            s(n, i)
        }),
      e.getSignature(e, r, t)
  }
  M.createCertificateVerify = function (e, t) {
    var r = t.length + 2,
      n = me.util.createBuffer()
    return (
      n.putByte(M.HandshakeType.certificate_verify),
      n.putInt24(r),
      n.putInt16(t.length),
      n.putBytes(t),
      n
    )
  }
  M.createCertificateRequest = function (e) {
    var t = me.util.createBuffer()
    t.putByte(1)
    var r = me.util.createBuffer()
    for (var n in e.caStore.certs) {
      var i = e.caStore.certs[n],
        s = me.pki.distinguishedNameToAsn1(i.subject),
        o = me.asn1.toDer(s)
      r.putInt16(o.length()), r.putBuffer(o)
    }
    var a = 1 + t.length() + 2 + r.length(),
      l = me.util.createBuffer()
    return (
      l.putByte(M.HandshakeType.certificate_request),
      l.putInt24(a),
      Ql(l, 1, t),
      Ql(l, 2, r),
      l
    )
  }
  M.createServerHelloDone = function (e) {
    var t = me.util.createBuffer()
    return t.putByte(M.HandshakeType.server_hello_done), t.putInt24(0), t
  }
  M.createChangeCipherSpec = function () {
    var e = me.util.createBuffer()
    return e.putByte(1), e
  }
  M.createFinished = function (e) {
    var t = me.util.createBuffer()
    t.putBuffer(e.session.md5.digest()), t.putBuffer(e.session.sha1.digest())
    var r = e.entity === M.ConnectionEnd.client,
      n = e.session.sp,
      i = 12,
      s = ST,
      o = r ? "client finished" : "server finished"
    t = s(n.master_secret, o, t.getBytes(), i)
    var a = me.util.createBuffer()
    return (
      a.putByte(M.HandshakeType.finished),
      a.putInt24(t.length()),
      a.putBuffer(t),
      a
    )
  }
  M.createHeartbeat = function (e, t, r) {
    typeof r > "u" && (r = t.length)
    var n = me.util.createBuffer()
    n.putByte(e), n.putInt16(r), n.putBytes(t)
    var i = n.length(),
      s = Math.max(16, i - r - 3)
    return n.putBytes(me.random.getBytes(s)), n
  }
  M.queue = function (e, t) {
    if (
      t &&
      !(
        t.fragment.length() === 0 &&
        (t.type === M.ContentType.handshake ||
          t.type === M.ContentType.alert ||
          t.type === M.ContentType.change_cipher_spec)
      )
    ) {
      if (t.type === M.ContentType.handshake) {
        var r = t.fragment.bytes()
        e.session.md5.update(r), e.session.sha1.update(r), (r = null)
      }
      var n
      if (t.fragment.length() <= M.MaxFragment) n = [t]
      else {
        n = []
        for (var i = t.fragment.bytes(); i.length > M.MaxFragment; )
          n.push(
            M.createRecord(e, {
              type: t.type,
              data: me.util.createBuffer(i.slice(0, M.MaxFragment)),
            }),
          ),
            (i = i.slice(M.MaxFragment))
        i.length > 0 &&
          n.push(
            M.createRecord(e, { type: t.type, data: me.util.createBuffer(i) }),
          )
      }
      for (var s = 0; s < n.length && !e.fail; ++s) {
        var o = n[s],
          a = e.state.current.write
        a.update(e, o) && e.records.push(o)
      }
    }
  }
  M.flush = function (e) {
    for (var t = 0; t < e.records.length; ++t) {
      var r = e.records[t]
      e.tlsData.putByte(r.type),
        e.tlsData.putByte(r.version.major),
        e.tlsData.putByte(r.version.minor),
        e.tlsData.putInt16(r.fragment.length()),
        e.tlsData.putBuffer(e.records[t].fragment)
    }
    return (e.records = []), e.tlsDataReady(e)
  }
  var n5 = function (e) {
      switch (e) {
        case true:
          return true
        case me.pki.certificateError.bad_certificate:
          return M.Alert.Description.bad_certificate
        case me.pki.certificateError.unsupported_certificate:
          return M.Alert.Description.unsupported_certificate
        case me.pki.certificateError.certificate_revoked:
          return M.Alert.Description.certificate_revoked
        case me.pki.certificateError.certificate_expired:
          return M.Alert.Description.certificate_expired
        case me.pki.certificateError.certificate_unknown:
          return M.Alert.Description.certificate_unknown
        case me.pki.certificateError.unknown_ca:
          return M.Alert.Description.unknown_ca
        default:
          return M.Alert.Description.bad_certificate
      }
    },
    prt = function (e) {
      switch (e) {
        case true:
          return true
        case M.Alert.Description.bad_certificate:
          return me.pki.certificateError.bad_certificate
        case M.Alert.Description.unsupported_certificate:
          return me.pki.certificateError.unsupported_certificate
        case M.Alert.Description.certificate_revoked:
          return me.pki.certificateError.certificate_revoked
        case M.Alert.Description.certificate_expired:
          return me.pki.certificateError.certificate_expired
        case M.Alert.Description.certificate_unknown:
          return me.pki.certificateError.certificate_unknown
        case M.Alert.Description.unknown_ca:
          return me.pki.certificateError.unknown_ca
        default:
          return me.pki.certificateError.bad_certificate
      }
    }
  M.verifyCertificateChain = function (e, t) {
    try {
      var r = {}
      for (var n in e.verifyOptions) r[n] = e.verifyOptions[n]
      ;(r.verify = function (s, o, a) {
        var l = n5(s),
          c = e.verify(e, s, o, a)
        if (c !== true) {
          if (typeof c == "object" && !me.util.isArray(c)) {
            var u = new Error("The application rejected the certificate.")
            throw (
              ((u.send = true),
              (u.alert = {
                level: M.Alert.Level.fatal,
                description: M.Alert.Description.bad_certificate,
              }),
              c.message && (u.message = c.message),
              c.alert && (u.alert.description = c.alert),
              u)
            )
          }
          c !== s && (c = prt(c))
        }
        return c
      }),
        me.pki.verifyCertificateChain(e.caStore, t, r)
    } catch (s) {
      var i = s
      ;(typeof i != "object" || me.util.isArray(i)) &&
        (i = {
          send: true,
          alert: { level: M.Alert.Level.fatal, description: n5(s) },
        }),
        "send" in i || (i.send = true),
        "alert" in i ||
          (i.alert = { level: M.Alert.Level.fatal, description: n5(i.error) }),
        e.error(e, i)
    }
    return !e.fail
  }
  M.createSessionCache = function (e, t) {
    var r = null
    if (e && e.getSession && e.setSession && e.order) r = e
    else {
      ;(r = {}),
        (r.cache = e || {}),
        (r.capacity = Math.max(t || 100, 1)),
        (r.order = [])
      for (var n in e) r.order.length <= t ? r.order.push(n) : delete e[n]
      ;(r.getSession = function (i) {
        var s = null,
          o = null
        if (
          (i
            ? (o = me.util.bytesToHex(i))
            : r.order.length > 0 && (o = r.order[0]),
          o !== null && o in r.cache)
        ) {
          ;(s = r.cache[o]), delete r.cache[o]
          for (var a in r.order)
            if (r.order[a] === o) {
              r.order.splice(a, 1)
              break
            }
        }
        return s
      }),
        (r.setSession = function (i, s) {
          if (r.order.length === r.capacity) {
            var o = r.order.shift()
            delete r.cache[o]
          }
          var o = me.util.bytesToHex(i)
          r.order.push(o), (r.cache[o] = s)
        })
    }
    return r
  }
  M.createConnection = function (e) {
    var t = null
    e.caStore
      ? me.util.isArray(e.caStore)
        ? (t = me.pki.createCaStore(e.caStore))
        : (t = e.caStore)
      : (t = me.pki.createCaStore())
    var r = e.cipherSuites || null
    if (r === null) {
      r = []
      for (var n in M.CipherSuites) r.push(M.CipherSuites[n])
    }
    var i = e.server ? M.ConnectionEnd.server : M.ConnectionEnd.client,
      s = e.sessionCache ? M.createSessionCache(e.sessionCache) : null,
      o = {
        version: { major: M.Version.major, minor: M.Version.minor },
        entity: i,
        sessionId: e.sessionId,
        caStore: t,
        sessionCache: s,
        cipherSuites: r,
        connected: e.connected,
        virtualHost: e.virtualHost || null,
        verifyClient: e.verifyClient || false,
        verify:
          e.verify ||
          function (u, f, p, g) {
            return f
          },
        verifyOptions: e.verifyOptions || {},
        getCertificate: e.getCertificate || null,
        getPrivateKey: e.getPrivateKey || null,
        getSignature: e.getSignature || null,
        input: me.util.createBuffer(),
        tlsData: me.util.createBuffer(),
        data: me.util.createBuffer(),
        tlsDataReady: e.tlsDataReady,
        dataReady: e.dataReady,
        heartbeatReceived: e.heartbeatReceived,
        closed: e.closed,
        error: function (u, f) {
          ;(f.origin =
            f.origin ||
            (u.entity === M.ConnectionEnd.client ? "client" : "server")),
            f.send && (M.queue(u, M.createAlert(u, f.alert)), M.flush(u))
          var p = f.fatal !== false
          p && (u.fail = true), e.error(u, f), p && u.close(false)
        },
        deflate: e.deflate || null,
        inflate: e.inflate || null,
      }
    ;(o.reset = function (u) {
      ;(o.version = { major: M.Version.major, minor: M.Version.minor }),
        (o.record = null),
        (o.session = null),
        (o.peerCertificate = null),
        (o.state = { pending: null, current: null }),
        (o.expect = o.entity === M.ConnectionEnd.client ? Xtt : ort),
        (o.fragmented = null),
        (o.records = []),
        (o.open = false),
        (o.handshakes = 0),
        (o.handshaking = false),
        (o.isConnected = false),
        (o.fail = !(u || typeof u > "u")),
        o.input.clear(),
        o.tlsData.clear(),
        o.data.clear(),
        (o.state.current = M.createConnectionState(o))
    }),
      o.reset()
    var a = function (u, f) {
        var p = f.type - M.ContentType.change_cipher_spec,
          g = o5[u.entity][u.expect]
        p in g ? g[p](u, f) : M.handleUnexpected(u, f)
      },
      l = function (u) {
        var f = 0,
          p = u.input,
          g = p.length()
        if (g < 5) f = 5 - g
        else {
          u.record = {
            type: p.getByte(),
            version: { major: p.getByte(), minor: p.getByte() },
            length: p.getInt16(),
            fragment: me.util.createBuffer(),
            ready: false,
          }
          var m = u.record.version.major === u.version.major
          m &&
            u.session &&
            u.session.version &&
            (m = u.record.version.minor === u.version.minor),
            m ||
              u.error(u, {
                message: "Incompatible TLS version.",
                send: true,
                alert: {
                  level: M.Alert.Level.fatal,
                  description: M.Alert.Description.protocol_version,
                },
              })
        }
        return f
      },
      c = function (u) {
        var f = 0,
          p = u.input,
          g = p.length()
        if (g < u.record.length) f = u.record.length - g
        else {
          u.record.fragment.putBytes(p.getBytes(u.record.length)), p.compact()
          var m = u.state.current.read
          m.update(u, u.record) &&
            (u.fragmented !== null &&
              (u.fragmented.type === u.record.type
                ? (u.fragmented.fragment.putBuffer(u.record.fragment),
                  (u.record = u.fragmented))
                : u.error(u, {
                    message: "Invalid fragmented record.",
                    send: true,
                    alert: {
                      level: M.Alert.Level.fatal,
                      description: M.Alert.Description.unexpected_message,
                    },
                  })),
            (u.record.ready = true))
        }
        return f
      }
    return (
      (o.handshake = function (u) {
        if (o.entity !== M.ConnectionEnd.client)
          o.error(o, {
            message: "Cannot initiate handshake as a server.",
            fatal: false,
          })
        else if (o.handshaking)
          o.error(o, { message: "Handshake already in progress.", fatal: false })
        else {
          o.fail && !o.open && o.handshakes === 0 && (o.fail = false),
            (o.handshaking = true),
            (u = u || "")
          var f = null
          u.length > 0 &&
            (o.sessionCache && (f = o.sessionCache.getSession(u)),
            f === null && (u = "")),
            u.length === 0 &&
              o.sessionCache &&
              ((f = o.sessionCache.getSession()), f !== null && (u = f.id)),
            (o.session = {
              id: u,
              version: null,
              cipherSuite: null,
              compressionMethod: null,
              serverCertificate: null,
              certificateRequest: null,
              clientCertificate: null,
              sp: {},
              md5: me.md.md5.create(),
              sha1: me.md.sha1.create(),
            }),
            f && ((o.version = f.version), (o.session.sp = f.sp)),
            (o.session.sp.client_random = M.createRandom().getBytes()),
            (o.open = true),
            M.queue(
              o,
              M.createRecord(o, {
                type: M.ContentType.handshake,
                data: M.createClientHello(o),
              }),
            ),
            M.flush(o)
        }
      }),
      (o.process = function (u) {
        var f = 0
        return (
          u && o.input.putBytes(u),
          o.fail ||
            (o.record !== null &&
              o.record.ready &&
              o.record.fragment.isEmpty() &&
              (o.record = null),
            o.record === null && (f = l(o)),
            !o.fail && o.record !== null && !o.record.ready && (f = c(o)),
            !o.fail && o.record !== null && o.record.ready && a(o, o.record)),
          f
        )
      }),
      (o.prepare = function (u) {
        return (
          M.queue(
            o,
            M.createRecord(o, {
              type: M.ContentType.application_data,
              data: me.util.createBuffer(u),
            }),
          ),
          M.flush(o)
        )
      }),
      (o.prepareHeartbeatRequest = function (u, f) {
        return (
          u instanceof me.util.ByteBuffer && (u = u.bytes()),
          typeof f > "u" && (f = u.length),
          (o.expectedHeartbeatPayload = u),
          M.queue(
            o,
            M.createRecord(o, {
              type: M.ContentType.heartbeat,
              data: M.createHeartbeat(
                M.HeartbeatMessageType.heartbeat_request,
                u,
                f,
              ),
            }),
          ),
          M.flush(o)
        )
      }),
      (o.close = function (u) {
        if (!o.fail && o.sessionCache && o.session) {
          var f = {
            id: o.session.id,
            version: o.session.version,
            sp: o.session.sp,
          }
          ;(f.sp.keys = null), o.sessionCache.setSession(f.id, f)
        }
        o.open &&
          ((o.open = false),
          o.input.clear(),
          (o.isConnected || o.handshaking) &&
            ((o.isConnected = o.handshaking = false),
            M.queue(
              o,
              M.createAlert(o, {
                level: M.Alert.Level.warning,
                description: M.Alert.Description.close_notify,
              }),
            ),
            M.flush(o)),
          o.closed(o)),
          o.reset(u)
      }),
      o
    )
  }
  Ade.exports = me.tls = me.tls || {}
  for (xT in M) typeof M[xT] != "function" && (me.tls[xT] = M[xT])
  var xT
  me.tls.prf_tls1 = ST
  me.tls.hmac_sha1 = Jtt
  me.tls.createSessionCache = M.createSessionCache
  me.tls.createConnection = M.createConnection
})
var Cde = _((Skt, vde) => {
  "use strict"
  var Nh = jt()
  Rh()
  a5()
  var Nl = (vde.exports = Nh.tls)
  Nl.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA = {
    id: [0, 47],
    name: "TLS_RSA_WITH_AES_128_CBC_SHA",
    initSecurityParameters: function (e) {
      ;(e.bulk_cipher_algorithm = Nl.BulkCipherAlgorithm.aes),
        (e.cipher_type = Nl.CipherType.block),
        (e.enc_key_length = 16),
        (e.block_length = 16),
        (e.fixed_iv_length = 16),
        (e.record_iv_length = 16),
        (e.mac_algorithm = Nl.MACAlgorithm.hmac_sha1),
        (e.mac_length = 20),
        (e.mac_key_length = 20)
    },
    initConnectionState: yde,
  }
  Nl.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA = {
    id: [0, 53],
    name: "TLS_RSA_WITH_AES_256_CBC_SHA",
    initSecurityParameters: function (e) {
      ;(e.bulk_cipher_algorithm = Nl.BulkCipherAlgorithm.aes),
        (e.cipher_type = Nl.CipherType.block),
        (e.enc_key_length = 32),
        (e.block_length = 16),
        (e.fixed_iv_length = 16),
        (e.record_iv_length = 16),
        (e.mac_algorithm = Nl.MACAlgorithm.hmac_sha1),
        (e.mac_length = 20),
        (e.mac_key_length = 20)
    },
    initConnectionState: yde,
  }
  function yde(e, t, r) {
    var n = t.entity === Nh.tls.ConnectionEnd.client
    ;(e.read.cipherState = {
      init: false,
      cipher: Nh.cipher.createDecipher(
        "AES-CBC",
        n ? r.keys.server_write_key : r.keys.client_write_key,
      ),
      iv: n ? r.keys.server_write_IV : r.keys.client_write_IV,
    }),
      (e.write.cipherState = {
        init: false,
        cipher: Nh.cipher.createCipher(
          "AES-CBC",
          n ? r.keys.client_write_key : r.keys.server_write_key,
        ),
        iv: n ? r.keys.client_write_IV : r.keys.server_write_IV,
      }),
      (e.read.cipherFunction = vrt),
      (e.write.cipherFunction = mrt),
      (e.read.macLength = e.write.macLength = r.mac_length),
      (e.read.macFunction = e.write.macFunction = Nl.hmac_sha1)
  }
  function mrt(e, t) {
    var r = false,
      n = t.macFunction(t.macKey, t.sequenceNumber, e)
    e.fragment.putBytes(n), t.updateSequenceNumber()
    var i
    e.version.minor === Nl.Versions.TLS_1_0.minor
      ? (i = t.cipherState.init ? null : t.cipherState.iv)
      : (i = Nh.random.getBytesSync(16)),
      (t.cipherState.init = true)
    var s = t.cipherState.cipher
    return (
      s.start({ iv: i }),
      e.version.minor >= Nl.Versions.TLS_1_1.minor && s.output.putBytes(i),
      s.update(e.fragment),
      s.finish(Art) &&
        ((e.fragment = s.output), (e.length = e.fragment.length()), (r = true)),
      r
    )
  }
  function Art(e, t, r) {
    if (!r) {
      var n = e - (t.length() % e)
      t.fillWithByte(n - 1, n)
    }
    return true
  }
  function yrt(e, t, r) {
    var n = true
    if (r) {
      for (var i = t.length(), s = t.last(), o = i - 1 - s; o < i - 1; ++o)
        n = n && t.at(o) == s
      n && t.truncate(s + 1)
    }
    return n
  }
  function vrt(e, t) {
    var r = false,
      n
    e.version.minor === Nl.Versions.TLS_1_0.minor
      ? (n = t.cipherState.init ? null : t.cipherState.iv)
      : (n = e.fragment.getBytes(16)),
      (t.cipherState.init = true)
    var i = t.cipherState.cipher
    i.start({ iv: n }), i.update(e.fragment), (r = i.finish(yrt))
    var s = t.macLength,
      o = Nh.random.getBytesSync(s),
      a = i.output.length()
    a >= s
      ? ((e.fragment = i.output.getBytes(a - s)), (o = i.output.getBytes(s)))
      : (e.fragment = i.output.getBytes()),
      (e.fragment = Nh.util.createBuffer(e.fragment)),
      (e.length = e.fragment.length())
    var l = t.macFunction(t.macKey, t.sequenceNumber, e)
    return t.updateSequenceNumber(), (r = Crt(t.macKey, o, l) && r), r
  }
  function Crt(e, t, r) {
    var n = Nh.hmac.create()
    return (
      n.start("SHA1", e),
      n.update(t),
      (t = n.digest().getBytes()),
      n.start(null, null),
      n.update(r),
      (r = n.digest().getBytes()),
      t === r
    )
  }
})
var u5 = _((Ikt, xde) => {
  "use strict"
  var Nn = jt()
  Tu()
  Pr()
  var C_ = (xde.exports = Nn.sha512 = Nn.sha512 || {})
  Nn.md.sha512 = Nn.md.algorithms.sha512 = C_
  var Ede = (Nn.sha384 = Nn.sha512.sha384 = Nn.sha512.sha384 || {})
  Ede.create = function () {
    return C_.create("SHA-384")
  }
  Nn.md.sha384 = Nn.md.algorithms.sha384 = Ede
  Nn.sha512.sha256 = Nn.sha512.sha256 || {
    create: function () {
      return C_.create("SHA-512/256")
    },
  }
  Nn.md["sha512/256"] = Nn.md.algorithms["sha512/256"] = Nn.sha512.sha256
  Nn.sha512.sha224 = Nn.sha512.sha224 || {
    create: function () {
      return C_.create("SHA-512/224")
    },
  }
  Nn.md["sha512/224"] = Nn.md.algorithms["sha512/224"] = Nn.sha512.sha224
  C_.create = function (e) {
    if ((_de || brt(), typeof e > "u" && (e = "SHA-512"), !(e in zp)))
      throw new Error("Invalid SHA-512 algorithm: " + e)
    for (
      var t = zp[e],
        r = null,
        n = Nn.util.createBuffer(),
        i = new Array(80),
        s = 0;
      s < 80;
      ++s
    )
      i[s] = new Array(2)
    var o = 64
    switch (e) {
      case "SHA-384":
        o = 48
        break
      case "SHA-512/256":
        o = 32
        break
      case "SHA-512/224":
        o = 28
        break
    }
    var a = {
      algorithm: e.replace("-", "").toLowerCase(),
      blockLength: 128,
      digestLength: o,
      messageLength: 0,
      fullMessageLength: null,
      messageLengthSize: 16,
    }
    return (
      (a.start = function () {
        ;(a.messageLength = 0), (a.fullMessageLength = a.messageLength128 = [])
        for (var l = a.messageLengthSize / 4, c = 0; c < l; ++c)
          a.fullMessageLength.push(0)
        ;(n = Nn.util.createBuffer()), (r = new Array(t.length))
        for (var c = 0; c < t.length; ++c) r[c] = t[c].slice(0)
        return a
      }),
      a.start(),
      (a.update = function (l, c) {
        c === "utf8" && (l = Nn.util.encodeUtf8(l))
        var u = l.length
        ;(a.messageLength += u), (u = [(u / 4294967296) >>> 0, u >>> 0])
        for (var f = a.fullMessageLength.length - 1; f >= 0; --f)
          (a.fullMessageLength[f] += u[1]),
            (u[1] = u[0] + ((a.fullMessageLength[f] / 4294967296) >>> 0)),
            (a.fullMessageLength[f] = a.fullMessageLength[f] >>> 0),
            (u[0] = (u[1] / 4294967296) >>> 0)
        return (
          n.putBytes(l),
          bde(r, i, n),
          (n.read > 2048 || n.length() === 0) && n.compact(),
          a
        )
      }),
      (a.digest = function () {
        var l = Nn.util.createBuffer()
        l.putBytes(n.bytes())
        var c =
            a.fullMessageLength[a.fullMessageLength.length - 1] +
            a.messageLengthSize,
          u = c & (a.blockLength - 1)
        l.putBytes(l5.substr(0, a.blockLength - u))
        for (
          var f, p, g = a.fullMessageLength[0] * 8, m = 0;
          m < a.fullMessageLength.length - 1;
          ++m
        )
          (f = a.fullMessageLength[m + 1] * 8),
            (p = (f / 4294967296) >>> 0),
            (g += p),
            l.putInt32(g >>> 0),
            (g = f >>> 0)
        l.putInt32(g)
        for (var y = new Array(r.length), m = 0; m < r.length; ++m)
          y[m] = r[m].slice(0)
        bde(y, i, l)
        var v = Nn.util.createBuffer(),
          C
        e === "SHA-512"
          ? (C = y.length)
          : e === "SHA-384"
            ? (C = y.length - 2)
            : (C = y.length - 4)
        for (var m = 0; m < C; ++m)
          v.putInt32(y[m][0]),
            (m !== C - 1 || e !== "SHA-512/224") && v.putInt32(y[m][1])
        return v
      }),
      a
    )
  }
  var l5 = null,
    _de = false,
    c5 = null,
    zp = null
  function brt() {
    ;(l5 = "\x80"),
      (l5 += Nn.util.fillString("\0", 128)),
      (c5 = [
        [1116352408, 3609767458],
        [1899447441, 602891725],
        [3049323471, 3964484399],
        [3921009573, 2173295548],
        [961987163, 4081628472],
        [1508970993, 3053834265],
        [2453635748, 2937671579],
        [2870763221, 3664609560],
        [3624381080, 2734883394],
        [310598401, 1164996542],
        [607225278, 1323610764],
        [1426881987, 3590304994],
        [1925078388, 4068182383],
        [2162078206, 991336113],
        [2614888103, 633803317],
        [3248222580, 3479774868],
        [3835390401, 2666613458],
        [4022224774, 944711139],
        [264347078, 2341262773],
        [604807628, 2007800933],
        [770255983, 1495990901],
        [1249150122, 1856431235],
        [1555081692, 3175218132],
        [1996064986, 2198950837],
        [2554220882, 3999719339],
        [2821834349, 766784016],
        [2952996808, 2566594879],
        [3210313671, 3203337956],
        [3336571891, 1034457026],
        [3584528711, 2466948901],
        [113926993, 3758326383],
        [338241895, 168717936],
        [666307205, 1188179964],
        [773529912, 1546045734],
        [1294757372, 1522805485],
        [1396182291, 2643833823],
        [1695183700, 2343527390],
        [1986661051, 1014477480],
        [2177026350, 1206759142],
        [2456956037, 344077627],
        [2730485921, 1290863460],
        [2820302411, 3158454273],
        [3259730800, 3505952657],
        [3345764771, 106217008],
        [3516065817, 3606008344],
        [3600352804, 1432725776],
        [4094571909, 1467031594],
        [275423344, 851169720],
        [430227734, 3100823752],
        [506948616, 1363258195],
        [659060556, 3750685593],
        [883997877, 3785050280],
        [958139571, 3318307427],
        [1322822218, 3812723403],
        [1537002063, 2003034995],
        [1747873779, 3602036899],
        [1955562222, 1575990012],
        [2024104815, 1125592928],
        [2227730452, 2716904306],
        [2361852424, 442776044],
        [2428436474, 593698344],
        [2756734187, 3733110249],
        [3204031479, 2999351573],
        [3329325298, 3815920427],
        [3391569614, 3928383900],
        [3515267271, 566280711],
        [3940187606, 3454069534],
        [4118630271, 4000239992],
        [116418474, 1914138554],
        [174292421, 2731055270],
        [289380356, 3203993006],
        [460393269, 320620315],
        [685471733, 587496836],
        [852142971, 1086792851],
        [1017036298, 365543100],
        [1126000580, 2618297676],
        [1288033470, 3409855158],
        [1501505948, 4234509866],
        [1607167915, 987167468],
        [1816402316, 1246189591],
      ]),
      (zp = {}),
      (zp["SHA-512"] = [
        [1779033703, 4089235720],
        [3144134277, 2227873595],
        [1013904242, 4271175723],
        [2773480762, 1595750129],
        [1359893119, 2917565137],
        [2600822924, 725511199],
        [528734635, 4215389547],
        [1541459225, 327033209],
      ]),
      (zp["SHA-384"] = [
        [3418070365, 3238371032],
        [1654270250, 914150663],
        [2438529370, 812702999],
        [355462360, 4144912697],
        [1731405415, 4290775857],
        [2394180231, 1750603025],
        [3675008525, 1694076839],
        [1203062813, 3204075428],
      ]),
      (zp["SHA-512/256"] = [
        [573645204, 4230739756],
        [2673172387, 3360449730],
        [596883563, 1867755857],
        [2520282905, 1497426621],
        [2519219938, 2827943907],
        [3193839141, 1401305490],
        [721525244, 746961066],
        [246885852, 2177182882],
      ]),
      (zp["SHA-512/224"] = [
        [2352822216, 424955298],
        [1944164710, 2312950998],
        [502970286, 855612546],
        [1738396948, 1479516111],
        [258812777, 2077511080],
        [2011393907, 79989058],
        [1067287976, 1780299464],
        [286451373, 2446758561],
      ]),
      (_de = true)
  }
  function bde(e, t, r) {
    for (
      var n,
        i,
        s,
        o,
        a,
        l,
        c,
        u,
        f,
        p,
        g,
        m,
        y,
        v,
        C,
        E,
        w,
        B,
        T,
        N,
        W,
        Z,
        te,
        Y,
        U,
        ce,
        Ie,
        Q,
        se,
        J,
        ie,
        Ue,
        At,
        ve,
        Mt,
        Xt = r.length();
      Xt >= 128;

    ) {
      for (se = 0; se < 16; ++se)
        (t[se][0] = r.getInt32() >>> 0), (t[se][1] = r.getInt32() >>> 0)
      for (; se < 80; ++se)
        (Ue = t[se - 2]),
          (J = Ue[0]),
          (ie = Ue[1]),
          (n =
            (((J >>> 19) | (ie << 13)) ^
              ((ie >>> 29) | (J << 3)) ^
              (J >>> 6)) >>>
            0),
          (i =
            (((J << 13) | (ie >>> 19)) ^
              ((ie << 3) | (J >>> 29)) ^
              ((J << 26) | (ie >>> 6))) >>>
            0),
          (ve = t[se - 15]),
          (J = ve[0]),
          (ie = ve[1]),
          (s =
            (((J >>> 1) | (ie << 31)) ^
              ((J >>> 8) | (ie << 24)) ^
              (J >>> 7)) >>>
            0),
          (o =
            (((J << 31) | (ie >>> 1)) ^
              ((J << 24) | (ie >>> 8)) ^
              ((J << 25) | (ie >>> 7))) >>>
            0),
          (At = t[se - 7]),
          (Mt = t[se - 16]),
          (ie = i + At[1] + o + Mt[1]),
          (t[se][0] =
            (n + At[0] + s + Mt[0] + ((ie / 4294967296) >>> 0)) >>> 0),
          (t[se][1] = ie >>> 0)
      for (
        y = e[0][0],
          v = e[0][1],
          C = e[1][0],
          E = e[1][1],
          w = e[2][0],
          B = e[2][1],
          T = e[3][0],
          N = e[3][1],
          W = e[4][0],
          Z = e[4][1],
          te = e[5][0],
          Y = e[5][1],
          U = e[6][0],
          ce = e[6][1],
          Ie = e[7][0],
          Q = e[7][1],
          se = 0;
        se < 80;
        ++se
      )
        (c =
          (((W >>> 14) | (Z << 18)) ^
            ((W >>> 18) | (Z << 14)) ^
            ((Z >>> 9) | (W << 23))) >>>
          0),
          (u =
            (((W << 18) | (Z >>> 14)) ^
              ((W << 14) | (Z >>> 18)) ^
              ((Z << 23) | (W >>> 9))) >>>
            0),
          (f = (U ^ (W & (te ^ U))) >>> 0),
          (p = (ce ^ (Z & (Y ^ ce))) >>> 0),
          (a =
            (((y >>> 28) | (v << 4)) ^
              ((v >>> 2) | (y << 30)) ^
              ((v >>> 7) | (y << 25))) >>>
            0),
          (l =
            (((y << 4) | (v >>> 28)) ^
              ((v << 30) | (y >>> 2)) ^
              ((v << 25) | (y >>> 7))) >>>
            0),
          (g = ((y & C) | (w & (y ^ C))) >>> 0),
          (m = ((v & E) | (B & (v ^ E))) >>> 0),
          (ie = Q + u + p + c5[se][1] + t[se][1]),
          (n =
            (Ie + c + f + c5[se][0] + t[se][0] + ((ie / 4294967296) >>> 0)) >>>
            0),
          (i = ie >>> 0),
          (ie = l + m),
          (s = (a + g + ((ie / 4294967296) >>> 0)) >>> 0),
          (o = ie >>> 0),
          (Ie = U),
          (Q = ce),
          (U = te),
          (ce = Y),
          (te = W),
          (Y = Z),
          (ie = N + i),
          (W = (T + n + ((ie / 4294967296) >>> 0)) >>> 0),
          (Z = ie >>> 0),
          (T = w),
          (N = B),
          (w = C),
          (B = E),
          (C = y),
          (E = v),
          (ie = i + o),
          (y = (n + s + ((ie / 4294967296) >>> 0)) >>> 0),
          (v = ie >>> 0)
      ;(ie = e[0][1] + v),
        (e[0][0] = (e[0][0] + y + ((ie / 4294967296) >>> 0)) >>> 0),
        (e[0][1] = ie >>> 0),
        (ie = e[1][1] + E),
        (e[1][0] = (e[1][0] + C + ((ie / 4294967296) >>> 0)) >>> 0),
        (e[1][1] = ie >>> 0),
        (ie = e[2][1] + B),
        (e[2][0] = (e[2][0] + w + ((ie / 4294967296) >>> 0)) >>> 0),
        (e[2][1] = ie >>> 0),
        (ie = e[3][1] + N),
        (e[3][0] = (e[3][0] + T + ((ie / 4294967296) >>> 0)) >>> 0),
        (e[3][1] = ie >>> 0),
        (ie = e[4][1] + Z),
        (e[4][0] = (e[4][0] + W + ((ie / 4294967296) >>> 0)) >>> 0),
        (e[4][1] = ie >>> 0),
        (ie = e[5][1] + Y),
        (e[5][0] = (e[5][0] + te + ((ie / 4294967296) >>> 0)) >>> 0),
        (e[5][1] = ie >>> 0),
        (ie = e[6][1] + ce),
        (e[6][0] = (e[6][0] + U + ((ie / 4294967296) >>> 0)) >>> 0),
        (e[6][1] = ie >>> 0),
        (ie = e[7][1] + Q),
        (e[7][0] = (e[7][0] + Ie + ((ie / 4294967296) >>> 0)) >>> 0),
        (e[7][1] = ie >>> 0),
        (Xt -= 128)
    }
  }
})
var wde = _((d5) => {
  "use strict"
  var Ert = jt()
  Mc()
  var os = Ert.asn1
  d5.privateKeyValidator = {
    name: "PrivateKeyInfo",
    tagClass: os.Class.UNIVERSAL,
    type: os.Type.SEQUENCE,
    constructed: true,
    value: [
      {
        name: "PrivateKeyInfo.version",
        tagClass: os.Class.UNIVERSAL,
        type: os.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion",
      },
      {
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: os.Class.UNIVERSAL,
        type: os.Type.SEQUENCE,
        constructed: true,
        value: [
          {
            name: "AlgorithmIdentifier.algorithm",
            tagClass: os.Class.UNIVERSAL,
            type: os.Type.OID,
            constructed: false,
            capture: "privateKeyOid",
          },
        ],
      },
      {
        name: "PrivateKeyInfo",
        tagClass: os.Class.UNIVERSAL,
        type: os.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey",
      },
    ],
  }
  d5.publicKeyValidator = {
    name: "SubjectPublicKeyInfo",
    tagClass: os.Class.UNIVERSAL,
    type: os.Type.SEQUENCE,
    constructed: true,
    captureAsn1: "subjectPublicKeyInfo",
    value: [
      {
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: os.Class.UNIVERSAL,
        type: os.Type.SEQUENCE,
        constructed: true,
        value: [
          {
            name: "AlgorithmIdentifier.algorithm",
            tagClass: os.Class.UNIVERSAL,
            type: os.Type.OID,
            constructed: false,
            capture: "publicKeyOid",
          },
        ],
      },
      {
        tagClass: os.Class.UNIVERSAL,
        type: os.Type.BITSTRING,
        constructed: false,
        composed: true,
        captureBitStringValue: "ed25519PublicKey",
      },
    ],
  }
})
var Lde = _((Rkt, Pde) => {
  "use strict"
  var Ds = jt()
  m_()
  Tl()
  u5()
  Pr()
  var Tde = wde(),
    _rt = Tde.publicKeyValidator,
    xrt = Tde.privateKeyValidator
  typeof Sde > "u" && (Sde = Ds.jsbn.BigInteger)
  var Sde,
    g5 = Ds.util.ByteBuffer,
    ra = typeof Buffer > "u" ? Uint8Array : Buffer
  Ds.pki = Ds.pki || {}
  Pde.exports = Ds.pki.ed25519 = Ds.ed25519 = Ds.ed25519 || {}
  var hr = Ds.ed25519
  hr.constants = {}
  hr.constants.PUBLIC_KEY_BYTE_LENGTH = 32
  hr.constants.PRIVATE_KEY_BYTE_LENGTH = 64
  hr.constants.SEED_BYTE_LENGTH = 32
  hr.constants.SIGN_BYTE_LENGTH = 64
  hr.constants.HASH_BYTE_LENGTH = 64
  hr.generateKeyPair = function (e) {
    e = e || {}
    var t = e.seed
    if (t === undefined) t = Ds.random.getBytesSync(hr.constants.SEED_BYTE_LENGTH)
    else if (typeof t == "string") {
      if (t.length !== hr.constants.SEED_BYTE_LENGTH)
        throw new TypeError(
          '"seed" must be ' +
            hr.constants.SEED_BYTE_LENGTH +
            " bytes in length.",
        )
    } else if (!(t instanceof Uint8Array))
      throw new TypeError(
        '"seed" must be a node.js Buffer, Uint8Array, or a binary string.',
      )
    t = ef({ message: t, encoding: "binary" })
    for (
      var r = new ra(hr.constants.PUBLIC_KEY_BYTE_LENGTH),
        n = new ra(hr.constants.PRIVATE_KEY_BYTE_LENGTH),
        i = 0;
      i < 32;
      ++i
    )
      n[i] = t[i]
    return Brt(r, n), { publicKey: r, privateKey: n }
  }
  hr.privateKeyFromAsn1 = function (e) {
    var t = {},
      r = [],
      n = Ds.asn1.validate(e, xrt, t, r)
    if (!n) {
      var i = new Error("Invalid Key.")
      throw ((i.errors = r), i)
    }
    var s = Ds.asn1.derToOid(t.privateKeyOid),
      o = Ds.oids.EdDSA25519
    if (s !== o)
      throw new Error('Invalid OID "' + s + '"; OID must be "' + o + '".')
    var a = t.privateKey,
      l = ef({ message: Ds.asn1.fromDer(a).value, encoding: "binary" })
    return { privateKeyBytes: l }
  }
  hr.publicKeyFromAsn1 = function (e) {
    var t = {},
      r = [],
      n = Ds.asn1.validate(e, _rt, t, r)
    if (!n) {
      var i = new Error("Invalid Key.")
      throw ((i.errors = r), i)
    }
    var s = Ds.asn1.derToOid(t.publicKeyOid),
      o = Ds.oids.EdDSA25519
    if (s !== o)
      throw new Error('Invalid OID "' + s + '"; OID must be "' + o + '".')
    var a = t.ed25519PublicKey
    if (a.length !== hr.constants.PUBLIC_KEY_BYTE_LENGTH)
      throw new Error("Key length is invalid.")
    return ef({ message: a, encoding: "binary" })
  }
  hr.publicKeyFromPrivateKey = function (e) {
    e = e || {}
    var t = ef({ message: e.privateKey, encoding: "binary" })
    if (t.length !== hr.constants.PRIVATE_KEY_BYTE_LENGTH)
      throw new TypeError(
        '"options.privateKey" must have a byte length of ' +
          hr.constants.PRIVATE_KEY_BYTE_LENGTH,
      )
    for (
      var r = new ra(hr.constants.PUBLIC_KEY_BYTE_LENGTH), n = 0;
      n < r.length;
      ++n
    )
      r[n] = t[32 + n]
    return r
  }
  hr.sign = function (e) {
    e = e || {}
    var t = ef(e),
      r = ef({ message: e.privateKey, encoding: "binary" })
    if (r.length === hr.constants.SEED_BYTE_LENGTH) {
      var n = hr.generateKeyPair({ seed: r })
      r = n.privateKey
    } else if (r.length !== hr.constants.PRIVATE_KEY_BYTE_LENGTH)
      throw new TypeError(
        '"options.privateKey" must have a byte length of ' +
          hr.constants.SEED_BYTE_LENGTH +
          " or " +
          hr.constants.PRIVATE_KEY_BYTE_LENGTH,
      )
    var i = new ra(hr.constants.SIGN_BYTE_LENGTH + t.length)
    Rrt(i, t, t.length, r)
    for (
      var s = new ra(hr.constants.SIGN_BYTE_LENGTH), o = 0;
      o < s.length;
      ++o
    )
      s[o] = i[o]
    return s
  }
  hr.verify = function (e) {
    e = e || {}
    var t = ef(e)
    if (e.signature === undefined)
      throw new TypeError(
        '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.',
      )
    var r = ef({ message: e.signature, encoding: "binary" })
    if (r.length !== hr.constants.SIGN_BYTE_LENGTH)
      throw new TypeError(
        '"options.signature" must have a byte length of ' +
          hr.constants.SIGN_BYTE_LENGTH,
      )
    var n = ef({ message: e.publicKey, encoding: "binary" })
    if (n.length !== hr.constants.PUBLIC_KEY_BYTE_LENGTH)
      throw new TypeError(
        '"options.publicKey" must have a byte length of ' +
          hr.constants.PUBLIC_KEY_BYTE_LENGTH,
      )
    var i = new ra(hr.constants.SIGN_BYTE_LENGTH + t.length),
      s = new ra(hr.constants.SIGN_BYTE_LENGTH + t.length),
      o
    for (o = 0; o < hr.constants.SIGN_BYTE_LENGTH; ++o) i[o] = r[o]
    for (o = 0; o < t.length; ++o) i[o + hr.constants.SIGN_BYTE_LENGTH] = t[o]
    return Drt(s, i, i.length, n) >= 0
  }
  function ef(e) {
    var t = e.message
    if (t instanceof Uint8Array || t instanceof ra) return t
    var r = e.encoding
    if (t === undefined)
      if (e.md) (t = e.md.digest().getBytes()), (r = "binary")
      else
        throw new TypeError('"options.message" or "options.md" not specified.')
    if (typeof t == "string" && !r)
      throw new TypeError('"options.encoding" must be "binary" or "utf8".')
    if (typeof t == "string") {
      if (typeof Buffer < "u") return Buffer.from(t, r)
      t = new g5(t, r)
    } else if (!(t instanceof g5))
      throw new TypeError(
        '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.',
      )
    for (var n = new ra(t.length()), i = 0; i < n.length; ++i) n[i] = t.at(i)
    return n
  }
  var p5 = pt(),
    IT = pt([1]),
    wrt = pt([
      30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505,
      36039, 65139, 11119, 27886, 20995,
    ]),
    Srt = pt([
      61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010,
      6542, 64743, 22239, 55772, 9222,
    ]),
    Ide = pt([
      54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982,
      57905, 49316, 21502, 52590, 14035, 8553,
    ]),
    Bde = pt([
      26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214,
      26214, 26214, 26214, 26214, 26214, 26214,
    ]),
    f5 = new Float64Array([
      237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16,
    ]),
    Irt = pt([
      41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153,
      11085, 57099, 20417, 9344, 11139,
    ])
  function b_(e, t) {
    var r = Ds.md.sha512.create(),
      n = new g5(e)
    r.update(n.getBytes(t), "binary")
    var i = r.digest().getBytes()
    if (typeof Buffer < "u") return Buffer.from(i, "binary")
    for (var s = new ra(hr.constants.HASH_BYTE_LENGTH), o = 0; o < 64; ++o)
      s[o] = i.charCodeAt(o)
    return s
  }
  function Brt(e, t) {
    var r = [pt(), pt(), pt(), pt()],
      n,
      i = b_(t, 32)
    for (
      i[0] &= 248, i[31] &= 127, i[31] |= 64, v5(r, i), y5(e, r), n = 0;
      n < 32;
      ++n
    )
      t[n + 32] = e[n]
    return 0
  }
  function Rrt(e, t, r, n) {
    var i,
      s,
      o = new Float64Array(64),
      a = [pt(), pt(), pt(), pt()],
      l = b_(n, 32)
    ;(l[0] &= 248), (l[31] &= 127), (l[31] |= 64)
    var c = r + 64
    for (i = 0; i < r; ++i) e[64 + i] = t[i]
    for (i = 0; i < 32; ++i) e[32 + i] = l[32 + i]
    var u = b_(e.subarray(32), r + 32)
    for (m5(u), v5(a, u), y5(e, a), i = 32; i < 64; ++i) e[i] = n[i]
    var f = b_(e, r + 64)
    for (m5(f), i = 32; i < 64; ++i) o[i] = 0
    for (i = 0; i < 32; ++i) o[i] = u[i]
    for (i = 0; i < 32; ++i) for (s = 0; s < 32; s++) o[i + s] += f[i] * l[s]
    return kde(e.subarray(32), o), c
  }
  function Drt(e, t, r, n) {
    var i,
      s,
      o = new ra(32),
      a = [pt(), pt(), pt(), pt()],
      l = [pt(), pt(), pt(), pt()]
    if (((s = -1), r < 64 || Trt(l, n))) return -1
    for (i = 0; i < r; ++i) e[i] = t[i]
    for (i = 0; i < 32; ++i) e[i + 32] = n[i]
    var c = b_(e, r)
    if (
      (m5(c),
      Qde(a, l, c),
      v5(l, t.subarray(32)),
      A5(a, l),
      y5(o, a),
      (r -= 64),
      Mde(t, 0, o, 0))
    ) {
      for (i = 0; i < r; ++i) e[i] = 0
      return -1
    }
    for (i = 0; i < r; ++i) e[i] = t[i + 64]
    return (s = r), s
  }
  function kde(e, t) {
    var r, n, i, s
    for (n = 63; n >= 32; --n) {
      for (r = 0, i = n - 32, s = n - 12; i < s; ++i)
        (t[i] += r - 16 * t[n] * f5[i - (n - 32)]),
          (r = (t[i] + 128) >> 8),
          (t[i] -= r * 256)
      ;(t[i] += r), (t[n] = 0)
    }
    for (r = 0, i = 0; i < 32; ++i)
      (t[i] += r - (t[31] >> 4) * f5[i]), (r = t[i] >> 8), (t[i] &= 255)
    for (i = 0; i < 32; ++i) t[i] -= r * f5[i]
    for (n = 0; n < 32; ++n) (t[n + 1] += t[n] >> 8), (e[n] = t[n] & 255)
  }
  function m5(e) {
    for (var t = new Float64Array(64), r = 0; r < 64; ++r)
      (t[r] = e[r]), (e[r] = 0)
    kde(e, t)
  }
  function A5(e, t) {
    var r = pt(),
      n = pt(),
      i = pt(),
      s = pt(),
      o = pt(),
      a = pt(),
      l = pt(),
      c = pt(),
      u = pt()
    Iy(r, e[1], e[0]),
      Iy(u, t[1], t[0]),
      Cn(r, r, u),
      Sy(n, e[0], e[1]),
      Sy(u, t[0], t[1]),
      Cn(n, n, u),
      Cn(i, e[3], t[3]),
      Cn(i, i, Srt),
      Cn(s, e[2], t[2]),
      Sy(s, s, s),
      Iy(o, n, r),
      Iy(a, s, i),
      Sy(l, s, i),
      Sy(c, n, r),
      Cn(e[0], o, a),
      Cn(e[1], c, l),
      Cn(e[2], l, a),
      Cn(e[3], o, c)
  }
  function Rde(e, t, r) {
    for (var n = 0; n < 4; ++n) Nde(e[n], t[n], r)
  }
  function y5(e, t) {
    var r = pt(),
      n = pt(),
      i = pt()
    Qrt(i, t[2]),
      Cn(r, t[0], i),
      Cn(n, t[1], i),
      BT(e, n),
      (e[31] ^= Fde(r) << 7)
  }
  function BT(e, t) {
    var r,
      n,
      i,
      s = pt(),
      o = pt()
    for (r = 0; r < 16; ++r) o[r] = t[r]
    for (h5(o), h5(o), h5(o), n = 0; n < 2; ++n) {
      for (s[0] = o[0] - 65517, r = 1; r < 15; ++r)
        (s[r] = o[r] - 65535 - ((s[r - 1] >> 16) & 1)), (s[r - 1] &= 65535)
      ;(s[15] = o[15] - 32767 - ((s[14] >> 16) & 1)),
        (i = (s[15] >> 16) & 1),
        (s[14] &= 65535),
        Nde(o, s, 1 - i)
    }
    for (r = 0; r < 16; r++) (e[2 * r] = o[r] & 255), (e[2 * r + 1] = o[r] >> 8)
  }
  function Trt(e, t) {
    var r = pt(),
      n = pt(),
      i = pt(),
      s = pt(),
      o = pt(),
      a = pt(),
      l = pt()
    return (
      Ph(e[2], IT),
      krt(e[1], t),
      Jp(i, e[1]),
      Cn(s, i, wrt),
      Iy(i, i, e[2]),
      Sy(s, e[2], s),
      Jp(o, s),
      Jp(a, o),
      Cn(l, a, o),
      Cn(r, l, i),
      Cn(r, r, s),
      Mrt(r, r),
      Cn(r, r, i),
      Cn(r, r, s),
      Cn(r, r, s),
      Cn(e[0], r, s),
      Jp(n, e[0]),
      Cn(n, n, s),
      Dde(n, i) && Cn(e[0], e[0], Irt),
      Jp(n, e[0]),
      Cn(n, n, s),
      Dde(n, i)
        ? -1
        : (Fde(e[0]) === t[31] >> 7 && Iy(e[0], p5, e[0]),
          Cn(e[3], e[0], e[1]),
          0)
    )
  }
  function krt(e, t) {
    var r
    for (r = 0; r < 16; ++r) e[r] = t[2 * r] + (t[2 * r + 1] << 8)
    e[15] &= 32767
  }
  function Mrt(e, t) {
    var r = pt(),
      n
    for (n = 0; n < 16; ++n) r[n] = t[n]
    for (n = 250; n >= 0; --n) Jp(r, r), n !== 1 && Cn(r, r, t)
    for (n = 0; n < 16; ++n) e[n] = r[n]
  }
  function Dde(e, t) {
    var r = new ra(32),
      n = new ra(32)
    return BT(r, e), BT(n, t), Mde(r, 0, n, 0)
  }
  function Mde(e, t, r, n) {
    return Frt(e, t, r, n, 32)
  }
  function Frt(e, t, r, n, i) {
    var s,
      o = 0
    for (s = 0; s < i; ++s) o |= e[t + s] ^ r[n + s]
    return (1 & ((o - 1) >>> 8)) - 1
  }
  function Fde(e) {
    var t = new ra(32)
    return BT(t, e), t[0] & 1
  }
  function Qde(e, t, r) {
    var n, i
    for (
      Ph(e[0], p5), Ph(e[1], IT), Ph(e[2], IT), Ph(e[3], p5), i = 255;
      i >= 0;
      --i
    )
      (n = (r[(i / 8) | 0] >> (i & 7)) & 1),
        Rde(e, t, n),
        A5(t, e),
        A5(e, e),
        Rde(e, t, n)
  }
  function v5(e, t) {
    var r = [pt(), pt(), pt(), pt()]
    Ph(r[0], Ide), Ph(r[1], Bde), Ph(r[2], IT), Cn(r[3], Ide, Bde), Qde(e, r, t)
  }
  function Ph(e, t) {
    var r
    for (r = 0; r < 16; r++) e[r] = t[r] | 0
  }
  function Qrt(e, t) {
    var r = pt(),
      n
    for (n = 0; n < 16; ++n) r[n] = t[n]
    for (n = 253; n >= 0; --n) Jp(r, r), n !== 2 && n !== 4 && Cn(r, r, t)
    for (n = 0; n < 16; ++n) e[n] = r[n]
  }
  function h5(e) {
    var t,
      r,
      n = 1
    for (t = 0; t < 16; ++t)
      (r = e[t] + n + 65535),
        (n = Math.floor(r / 65536)),
        (e[t] = r - n * 65536)
    e[0] += n - 1 + 37 * (n - 1)
  }
  function Nde(e, t, r) {
    for (var n, i = ~(r - 1), s = 0; s < 16; ++s)
      (n = i & (e[s] ^ t[s])), (e[s] ^= n), (t[s] ^= n)
  }
  function pt(e) {
    var t,
      r = new Float64Array(16)
    if (e) for (t = 0; t < e.length; ++t) r[t] = e[t]
    return r
  }
  function Sy(e, t, r) {
    for (var n = 0; n < 16; ++n) e[n] = t[n] + r[n]
  }
  function Iy(e, t, r) {
    for (var n = 0; n < 16; ++n) e[n] = t[n] - r[n]
  }
  function Jp(e, t) {
    Cn(e, t, t)
  }
  function Cn(e, t, r) {
    var n,
      i,
      s = 0,
      o = 0,
      a = 0,
      l = 0,
      c = 0,
      u = 0,
      f = 0,
      p = 0,
      g = 0,
      m = 0,
      y = 0,
      v = 0,
      C = 0,
      E = 0,
      w = 0,
      B = 0,
      T = 0,
      N = 0,
      W = 0,
      Z = 0,
      te = 0,
      Y = 0,
      U = 0,
      ce = 0,
      Ie = 0,
      Q = 0,
      se = 0,
      J = 0,
      ie = 0,
      Ue = 0,
      At = 0,
      ve = r[0],
      Mt = r[1],
      Xt = r[2],
      rr = r[3],
      ue = r[4],
      wr = r[5],
      or = r[6],
      Wr = r[7],
      Ge = r[8],
      ln = r[9],
      Gr = r[10],
      pr = r[11],
      Ee = r[12],
      Or = r[13],
      he = r[14],
      be = r[15]
    ;(n = t[0]),
      (s += n * ve),
      (o += n * Mt),
      (a += n * Xt),
      (l += n * rr),
      (c += n * ue),
      (u += n * wr),
      (f += n * or),
      (p += n * Wr),
      (g += n * Ge),
      (m += n * ln),
      (y += n * Gr),
      (v += n * pr),
      (C += n * Ee),
      (E += n * Or),
      (w += n * he),
      (B += n * be),
      (n = t[1]),
      (o += n * ve),
      (a += n * Mt),
      (l += n * Xt),
      (c += n * rr),
      (u += n * ue),
      (f += n * wr),
      (p += n * or),
      (g += n * Wr),
      (m += n * Ge),
      (y += n * ln),
      (v += n * Gr),
      (C += n * pr),
      (E += n * Ee),
      (w += n * Or),
      (B += n * he),
      (T += n * be),
      (n = t[2]),
      (a += n * ve),
      (l += n * Mt),
      (c += n * Xt),
      (u += n * rr),
      (f += n * ue),
      (p += n * wr),
      (g += n * or),
      (m += n * Wr),
      (y += n * Ge),
      (v += n * ln),
      (C += n * Gr),
      (E += n * pr),
      (w += n * Ee),
      (B += n * Or),
      (T += n * he),
      (N += n * be),
      (n = t[3]),
      (l += n * ve),
      (c += n * Mt),
      (u += n * Xt),
      (f += n * rr),
      (p += n * ue),
      (g += n * wr),
      (m += n * or),
      (y += n * Wr),
      (v += n * Ge),
      (C += n * ln),
      (E += n * Gr),
      (w += n * pr),
      (B += n * Ee),
      (T += n * Or),
      (N += n * he),
      (W += n * be),
      (n = t[4]),
      (c += n * ve),
      (u += n * Mt),
      (f += n * Xt),
      (p += n * rr),
      (g += n * ue),
      (m += n * wr),
      (y += n * or),
      (v += n * Wr),
      (C += n * Ge),
      (E += n * ln),
      (w += n * Gr),
      (B += n * pr),
      (T += n * Ee),
      (N += n * Or),
      (W += n * he),
      (Z += n * be),
      (n = t[5]),
      (u += n * ve),
      (f += n * Mt),
      (p += n * Xt),
      (g += n * rr),
      (m += n * ue),
      (y += n * wr),
      (v += n * or),
      (C += n * Wr),
      (E += n * Ge),
      (w += n * ln),
      (B += n * Gr),
      (T += n * pr),
      (N += n * Ee),
      (W += n * Or),
      (Z += n * he),
      (te += n * be),
      (n = t[6]),
      (f += n * ve),
      (p += n * Mt),
      (g += n * Xt),
      (m += n * rr),
      (y += n * ue),
      (v += n * wr),
      (C += n * or),
      (E += n * Wr),
      (w += n * Ge),
      (B += n * ln),
      (T += n * Gr),
      (N += n * pr),
      (W += n * Ee),
      (Z += n * Or),
      (te += n * he),
      (Y += n * be),
      (n = t[7]),
      (p += n * ve),
      (g += n * Mt),
      (m += n * Xt),
      (y += n * rr),
      (v += n * ue),
      (C += n * wr),
      (E += n * or),
      (w += n * Wr),
      (B += n * Ge),
      (T += n * ln),
      (N += n * Gr),
      (W += n * pr),
      (Z += n * Ee),
      (te += n * Or),
      (Y += n * he),
      (U += n * be),
      (n = t[8]),
      (g += n * ve),
      (m += n * Mt),
      (y += n * Xt),
      (v += n * rr),
      (C += n * ue),
      (E += n * wr),
      (w += n * or),
      (B += n * Wr),
      (T += n * Ge),
      (N += n * ln),
      (W += n * Gr),
      (Z += n * pr),
      (te += n * Ee),
      (Y += n * Or),
      (U += n * he),
      (ce += n * be),
      (n = t[9]),
      (m += n * ve),
      (y += n * Mt),
      (v += n * Xt),
      (C += n * rr),
      (E += n * ue),
      (w += n * wr),
      (B += n * or),
      (T += n * Wr),
      (N += n * Ge),
      (W += n * ln),
      (Z += n * Gr),
      (te += n * pr),
      (Y += n * Ee),
      (U += n * Or),
      (ce += n * he),
      (Ie += n * be),
      (n = t[10]),
      (y += n * ve),
      (v += n * Mt),
      (C += n * Xt),
      (E += n * rr),
      (w += n * ue),
      (B += n * wr),
      (T += n * or),
      (N += n * Wr),
      (W += n * Ge),
      (Z += n * ln),
      (te += n * Gr),
      (Y += n * pr),
      (U += n * Ee),
      (ce += n * Or),
      (Ie += n * he),
      (Q += n * be),
      (n = t[11]),
      (v += n * ve),
      (C += n * Mt),
      (E += n * Xt),
      (w += n * rr),
      (B += n * ue),
      (T += n * wr),
      (N += n * or),
      (W += n * Wr),
      (Z += n * Ge),
      (te += n * ln),
      (Y += n * Gr),
      (U += n * pr),
      (ce += n * Ee),
      (Ie += n * Or),
      (Q += n * he),
      (se += n * be),
      (n = t[12]),
      (C += n * ve),
      (E += n * Mt),
      (w += n * Xt),
      (B += n * rr),
      (T += n * ue),
      (N += n * wr),
      (W += n * or),
      (Z += n * Wr),
      (te += n * Ge),
      (Y += n * ln),
      (U += n * Gr),
      (ce += n * pr),
      (Ie += n * Ee),
      (Q += n * Or),
      (se += n * he),
      (J += n * be),
      (n = t[13]),
      (E += n * ve),
      (w += n * Mt),
      (B += n * Xt),
      (T += n * rr),
      (N += n * ue),
      (W += n * wr),
      (Z += n * or),
      (te += n * Wr),
      (Y += n * Ge),
      (U += n * ln),
      (ce += n * Gr),
      (Ie += n * pr),
      (Q += n * Ee),
      (se += n * Or),
      (J += n * he),
      (ie += n * be),
      (n = t[14]),
      (w += n * ve),
      (B += n * Mt),
      (T += n * Xt),
      (N += n * rr),
      (W += n * ue),
      (Z += n * wr),
      (te += n * or),
      (Y += n * Wr),
      (U += n * Ge),
      (ce += n * ln),
      (Ie += n * Gr),
      (Q += n * pr),
      (se += n * Ee),
      (J += n * Or),
      (ie += n * he),
      (Ue += n * be),
      (n = t[15]),
      (B += n * ve),
      (T += n * Mt),
      (N += n * Xt),
      (W += n * rr),
      (Z += n * ue),
      (te += n * wr),
      (Y += n * or),
      (U += n * Wr),
      (ce += n * Ge),
      (Ie += n * ln),
      (Q += n * Gr),
      (se += n * pr),
      (J += n * Ee),
      (ie += n * Or),
      (Ue += n * he),
      (At += n * be),
      (s += 38 * T),
      (o += 38 * N),
      (a += 38 * W),
      (l += 38 * Z),
      (c += 38 * te),
      (u += 38 * Y),
      (f += 38 * U),
      (p += 38 * ce),
      (g += 38 * Ie),
      (m += 38 * Q),
      (y += 38 * se),
      (v += 38 * J),
      (C += 38 * ie),
      (E += 38 * Ue),
      (w += 38 * At),
      (i = 1),
      (n = s + i + 65535),
      (i = Math.floor(n / 65536)),
      (s = n - i * 65536),
      (n = o + i + 65535),
      (i = Math.floor(n / 65536)),
      (o = n - i * 65536),
      (n = a + i + 65535),
      (i = Math.floor(n / 65536)),
      (a = n - i * 65536),
      (n = l + i + 65535),
      (i = Math.floor(n / 65536)),
      (l = n - i * 65536),
      (n = c + i + 65535),
      (i = Math.floor(n / 65536)),
      (c = n - i * 65536),
      (n = u + i + 65535),
      (i = Math.floor(n / 65536)),
      (u = n - i * 65536),
      (n = f + i + 65535),
      (i = Math.floor(n / 65536)),
      (f = n - i * 65536),
      (n = p + i + 65535),
      (i = Math.floor(n / 65536)),
      (p = n - i * 65536),
      (n = g + i + 65535),
      (i = Math.floor(n / 65536)),
      (g = n - i * 65536),
      (n = m + i + 65535),
      (i = Math.floor(n / 65536)),
      (m = n - i * 65536),
      (n = y + i + 65535),
      (i = Math.floor(n / 65536)),
      (y = n - i * 65536),
      (n = v + i + 65535),
      (i = Math.floor(n / 65536)),
      (v = n - i * 65536),
      (n = C + i + 65535),
      (i = Math.floor(n / 65536)),
      (C = n - i * 65536),
      (n = E + i + 65535),
      (i = Math.floor(n / 65536)),
      (E = n - i * 65536),
      (n = w + i + 65535),
      (i = Math.floor(n / 65536)),
      (w = n - i * 65536),
      (n = B + i + 65535),
      (i = Math.floor(n / 65536)),
      (B = n - i * 65536),
      (s += i - 1 + 37 * (i - 1)),
      (i = 1),
      (n = s + i + 65535),
      (i = Math.floor(n / 65536)),
      (s = n - i * 65536),
      (n = o + i + 65535),
      (i = Math.floor(n / 65536)),
      (o = n - i * 65536),
      (n = a + i + 65535),
      (i = Math.floor(n / 65536)),
      (a = n - i * 65536),
      (n = l + i + 65535),
      (i = Math.floor(n / 65536)),
      (l = n - i * 65536),
      (n = c + i + 65535),
      (i = Math.floor(n / 65536)),
      (c = n - i * 65536),
      (n = u + i + 65535),
      (i = Math.floor(n / 65536)),
      (u = n - i * 65536),
      (n = f + i + 65535),
      (i = Math.floor(n / 65536)),
      (f = n - i * 65536),
      (n = p + i + 65535),
      (i = Math.floor(n / 65536)),
      (p = n - i * 65536),
      (n = g + i + 65535),
      (i = Math.floor(n / 65536)),
      (g = n - i * 65536),
      (n = m + i + 65535),
      (i = Math.floor(n / 65536)),
      (m = n - i * 65536),
      (n = y + i + 65535),
      (i = Math.floor(n / 65536)),
      (y = n - i * 65536),
      (n = v + i + 65535),
      (i = Math.floor(n / 65536)),
      (v = n - i * 65536),
      (n = C + i + 65535),
      (i = Math.floor(n / 65536)),
      (C = n - i * 65536),
      (n = E + i + 65535),
      (i = Math.floor(n / 65536)),
      (E = n - i * 65536),
      (n = w + i + 65535),
      (i = Math.floor(n / 65536)),
      (w = n - i * 65536),
      (n = B + i + 65535),
      (i = Math.floor(n / 65536)),
      (B = n - i * 65536),
      (s += i - 1 + 37 * (i - 1)),
      (e[0] = s),
      (e[1] = o),
      (e[2] = a),
      (e[3] = l),
      (e[4] = c),
      (e[5] = u),
      (e[6] = f),
      (e[7] = p),
      (e[8] = g),
      (e[9] = m),
      (e[10] = y),
      (e[11] = v),
      (e[12] = C),
      (e[13] = E),
      (e[14] = w),
      (e[15] = B)
  }
})
var Vde = _((Dkt, qde) => {
  "use strict"
  var Pa = jt()
  Pr()
  Tl()
  m_()
  qde.exports = Pa.kem = Pa.kem || {}
  var Ude = Pa.jsbn.BigInteger
  Pa.kem.rsa = {}
  Pa.kem.rsa.create = function (e, t) {
    t = t || {}
    var r = t.prng || Pa.random,
      n = {}
    return (
      (n.encrypt = function (i, s) {
        var o = Math.ceil(i.n.bitLength() / 8),
          a
        do a = new Ude(Pa.util.bytesToHex(r.getBytesSync(o)), 16).mod(i.n)
        while (a.compareTo(Ude.ONE) <= 0)
        a = Pa.util.hexToBytes(a.toString(16))
        var l = o - a.length
        l > 0 && (a = Pa.util.fillString("\0", l) + a)
        var c = i.encrypt(a, "NONE"),
          u = e.generate(a, s)
        return { encapsulation: c, key: u }
      }),
      (n.decrypt = function (i, s, o) {
        var a = i.decrypt(s, "NONE")
        return e.generate(a, o)
      }),
      n
    )
  }
  Pa.kem.kdf1 = function (e, t) {
    Ode(this, e, 0, t || e.digestLength)
  }
  Pa.kem.kdf2 = function (e, t) {
    Ode(this, e, 1, t || e.digestLength)
  }
  function Ode(e, t, r, n) {
    e.generate = function (i, s) {
      for (
        var o = new Pa.util.ByteBuffer(),
          a = Math.ceil(s / n) + r,
          l = new Pa.util.ByteBuffer(),
          c = r;
        c < a;
        ++c
      ) {
        l.putInt32(c), t.start(), t.update(i + l.getBytes())
        var u = t.digest()
        o.putBytes(u.getBytes(n))
      }
      return o.truncate(o.length() - s), o.getBytes()
    }
  }
})
var $de = _((Tkt, Gde) => {
  "use strict"
  var vr = jt()
  Pr()
  Gde.exports = vr.log = vr.log || {}
  vr.log.levels = [
    "none",
    "error",
    "warning",
    "info",
    "debug",
    "verbose",
    "max",
  ]
  var RT = {},
    E5 = [],
    __ = null
  vr.log.LEVEL_LOCKED = 2
  vr.log.NO_LEVEL_CHECK = 4
  vr.log.INTERPOLATE = 8
  for (Uu = 0; Uu < vr.log.levels.length; ++Uu)
    (C5 = vr.log.levels[Uu]), (RT[C5] = { index: Uu, name: C5.toUpperCase() })
  var C5, Uu
  vr.log.logMessage = function (e) {
    for (var t = RT[e.level].index, r = 0; r < E5.length; ++r) {
      var n = E5[r]
      if (n.flags & vr.log.NO_LEVEL_CHECK) n.f(e)
      else {
        var i = RT[n.level].index
        t <= i && n.f(n, e)
      }
    }
  }
  vr.log.prepareStandard = function (e) {
    "standard" in e ||
      (e.standard = RT[e.level].name + " [" + e.category + "] " + e.message)
  }
  vr.log.prepareFull = function (e) {
    if (!("full" in e)) {
      var t = [e.message]
      ;(t = t.concat([])), (e.full = vr.util.format.apply(this, t))
    }
  }
  vr.log.prepareStandardFull = function (e) {
    "standardFull" in e ||
      (vr.log.prepareStandard(e), (e.standardFull = e.standard))
  }
  for (
    b5 = ["error", "warning", "info", "debug", "verbose"], Uu = 0;
    Uu < b5.length;
    ++Uu
  )
    (function (t) {
      vr.log[t] = function (r, n) {
        var i = Array.prototype.slice.call(arguments).slice(2),
          s = {
            timestamp: new Date(),
            level: t,
            category: r,
            message: n,
            arguments: i,
          }
        vr.log.logMessage(s)
      }
    })(b5[Uu])
  var b5, Uu
  vr.log.makeLogger = function (e) {
    var t = { flags: 0, f: e }
    return vr.log.setLevel(t, "none"), t
  }
  vr.log.setLevel = function (e, t) {
    var r = false
    if (e && !(e.flags & vr.log.LEVEL_LOCKED))
      for (var n = 0; n < vr.log.levels.length; ++n) {
        var i = vr.log.levels[n]
        if (t == i) {
          ;(e.level = t), (r = true)
          break
        }
      }
    return r
  }
  vr.log.lock = function (e, t) {
    typeof t > "u" || t
      ? (e.flags |= vr.log.LEVEL_LOCKED)
      : (e.flags &= ~vr.log.LEVEL_LOCKED)
  }
  vr.log.addLogger = function (e) {
    E5.push(e)
  }
  typeof console < "u" && "log" in console
    ? (console.error && console.warn && console.info && console.debug
        ? ((Hde = {
            error: console.error,
            warning: console.warn,
            info: console.info,
            debug: console.debug,
            verbose: console.debug,
          }),
          (x_ = function (e, t) {
            vr.log.prepareStandard(t)
            var r = Hde[t.level],
              n = [t.standard]
            ;(n = n.concat(t.arguments.slice())), r.apply(console, n)
          }),
          (By = vr.log.makeLogger(x_)))
        : ((x_ = function (t, r) {
            vr.log.prepareStandardFull(r), console.log(r.standardFull)
          }),
          (By = vr.log.makeLogger(x_))),
      vr.log.setLevel(By, "debug"),
      vr.log.addLogger(By),
      (__ = By))
    : (console = { log: function () {} })
  var By, Hde, x_
  __ !== null &&
    typeof window < "u" &&
    window.location &&
    ((E_ = new URL(window.location.href).searchParams),
    E_.has("console.level") &&
      vr.log.setLevel(__, E_.get("console.level").slice(-1)[0]),
    E_.has("console.lock") &&
      ((Wde = E_.get("console.lock").slice(-1)[0]),
      Wde == "true" && vr.log.lock(__)))
  var E_, Wde
  vr.log.consoleLogger = __
})
var Kde = _((kkt, Yde) => {
  "use strict"
  Yde.exports = Tu()
  lT()
  by()
  QW()
  u5()
})
var jde = _((Mkt, Jde) => {
  "use strict"
  var De = jt()
  Rh()
  Mc()
  g_()
  Dh()
  Hp()
  zW()
  Tl()
  Pr()
  ET()
  var G = De.asn1,
    Eo = (Jde.exports = De.pkcs7 = De.pkcs7 || {})
  Eo.messageFromPem = function (e) {
    var t = De.pem.decode(e)[0]
    if (t.type !== "PKCS7") {
      var r = new Error(
        'Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".',
      )
      throw ((r.headerType = t.type), r)
    }
    if (t.procType && t.procType.type === "ENCRYPTED")
      throw new Error(
        "Could not convert PKCS#7 message from PEM; PEM is encrypted.",
      )
    var n = G.fromDer(t.body)
    return Eo.messageFromAsn1(n)
  }
  Eo.messageToPem = function (e, t) {
    var r = { type: "PKCS7", body: G.toDer(e.toAsn1()).getBytes() }
    return De.pem.encode(r, { maxline: t })
  }
  Eo.messageFromAsn1 = function (e) {
    var t = {},
      r = []
    if (!G.validate(e, Eo.asn1.contentInfoValidator, t, r)) {
      var n = new Error(
        "Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.",
      )
      throw ((n.errors = r), n)
    }
    var i = G.derToOid(t.contentType),
      s
    switch (i) {
      case De.pki.oids.envelopedData:
        s = Eo.createEnvelopedData()
        break
      case De.pki.oids.encryptedData:
        s = Eo.createEncryptedData()
        break
      case De.pki.oids.signedData:
        s = Eo.createSignedData()
        break
      default:
        throw new Error(
          "Cannot read PKCS#7 message. ContentType with OID " +
            i +
            " is not (yet) supported.",
        )
    }
    return s.fromAsn1(t.content.value[0]), s
  }
  Eo.createSignedData = function () {
    var e = null
    return (
      (e = {
        type: De.pki.oids.signedData,
        version: 1,
        certificates: [],
        crls: [],
        signers: [],
        digestAlgorithmIdentifiers: [],
        contentInfo: null,
        signerInfos: [],
        fromAsn1: function (n) {
          if (
            (x5(e, n, Eo.asn1.signedDataValidator),
            (e.certificates = []),
            (e.crls = []),
            (e.digestAlgorithmIdentifiers = []),
            (e.contentInfo = null),
            (e.signerInfos = []),
            e.rawCapture.certificates)
          )
            for (
              var i = e.rawCapture.certificates.value, s = 0;
              s < i.length;
              ++s
            )
              e.certificates.push(De.pki.certificateFromAsn1(i[s]))
        },
        toAsn1: function () {
          e.contentInfo || e.sign()
          for (var n = [], i = 0; i < e.certificates.length; ++i)
            n.push(De.pki.certificateToAsn1(e.certificates[i]))
          var s = [],
            o = G.create(G.Class.CONTEXT_SPECIFIC, 0, true, [
              G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [
                G.create(
                  G.Class.UNIVERSAL,
                  G.Type.INTEGER,
                  false,
                  G.integerToDer(e.version).getBytes(),
                ),
                G.create(
                  G.Class.UNIVERSAL,
                  G.Type.SET,
                  true,
                  e.digestAlgorithmIdentifiers,
                ),
                e.contentInfo,
              ]),
            ])
          return (
            n.length > 0 &&
              o.value[0].value.push(
                G.create(G.Class.CONTEXT_SPECIFIC, 0, true, n),
              ),
            s.length > 0 &&
              o.value[0].value.push(
                G.create(G.Class.CONTEXT_SPECIFIC, 1, true, s),
              ),
            o.value[0].value.push(
              G.create(G.Class.UNIVERSAL, G.Type.SET, true, e.signerInfos),
            ),
            G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [
              G.create(
                G.Class.UNIVERSAL,
                G.Type.OID,
                false,
                G.oidToDer(e.type).getBytes(),
              ),
              o,
            ])
          )
        },
        addSigner: function (n) {
          var i = n.issuer,
            s = n.serialNumber
          if (n.certificate) {
            var o = n.certificate
            typeof o == "string" && (o = De.pki.certificateFromPem(o)),
              (i = o.issuer.attributes),
              (s = o.serialNumber)
          }
          var a = n.key
          if (!a)
            throw new Error(
              "Could not add PKCS#7 signer; no private key specified.",
            )
          typeof a == "string" && (a = De.pki.privateKeyFromPem(a))
          var l = n.digestAlgorithm || De.pki.oids.sha1
          switch (l) {
            case De.pki.oids.sha1:
            case De.pki.oids.sha256:
            case De.pki.oids.sha384:
            case De.pki.oids.sha512:
            case De.pki.oids.md5:
              break
            default:
              throw new Error(
                "Could not add PKCS#7 signer; unknown message digest algorithm: " +
                  l,
              )
          }
          var c = n.authenticatedAttributes || []
          if (c.length > 0) {
            for (var u = false, f = false, p = 0; p < c.length; ++p) {
              var g = c[p]
              if (!u && g.type === De.pki.oids.contentType) {
                if (((u = true), f)) break
                continue
              }
              if (!f && g.type === De.pki.oids.messageDigest) {
                if (((f = true), u)) break
                continue
              }
            }
            if (!u || !f)
              throw new Error(
                "Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.",
              )
          }
          e.signers.push({
            key: a,
            version: 1,
            issuer: i,
            serialNumber: s,
            digestAlgorithm: l,
            signatureAlgorithm: De.pki.oids.rsaEncryption,
            signature: null,
            authenticatedAttributes: c,
            unauthenticatedAttributes: [],
          })
        },
        sign: function (n) {
          if (
            ((n = n || {}),
            (typeof e.content != "object" || e.contentInfo === null) &&
              ((e.contentInfo = G.create(
                G.Class.UNIVERSAL,
                G.Type.SEQUENCE,
                true,
                [
                  G.create(
                    G.Class.UNIVERSAL,
                    G.Type.OID,
                    false,
                    G.oidToDer(De.pki.oids.data).getBytes(),
                  ),
                ],
              )),
              "content" in e))
          ) {
            var i
            e.content instanceof De.util.ByteBuffer
              ? (i = e.content.bytes())
              : typeof e.content == "string" &&
                (i = De.util.encodeUtf8(e.content)),
              n.detached
                ? (e.detachedContent = G.create(
                    G.Class.UNIVERSAL,
                    G.Type.OCTETSTRING,
                    false,
                    i,
                  ))
                : e.contentInfo.value.push(
                    G.create(G.Class.CONTEXT_SPECIFIC, 0, true, [
                      G.create(G.Class.UNIVERSAL, G.Type.OCTETSTRING, false, i),
                    ]),
                  )
          }
          if (e.signers.length !== 0) {
            var s = t()
            r(s)
          }
        },
        verify: function () {
          throw new Error("PKCS#7 signature verification not yet implemented.")
        },
        addCertificate: function (n) {
          typeof n == "string" && (n = De.pki.certificateFromPem(n)),
            e.certificates.push(n)
        },
        addCertificateRevokationList: function (n) {
          throw new Error("PKCS#7 CRL support not yet implemented.")
        },
      }),
      e
    )
    function t() {
      for (var n = {}, i = 0; i < e.signers.length; ++i) {
        var s = e.signers[i],
          o = s.digestAlgorithm
        o in n || (n[o] = De.md[De.pki.oids[o]].create()),
          s.authenticatedAttributes.length === 0
            ? (s.md = n[o])
            : (s.md = De.md[De.pki.oids[o]].create())
      }
      e.digestAlgorithmIdentifiers = []
      for (var o in n)
        e.digestAlgorithmIdentifiers.push(
          G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [
            G.create(
              G.Class.UNIVERSAL,
              G.Type.OID,
              false,
              G.oidToDer(o).getBytes(),
            ),
            G.create(G.Class.UNIVERSAL, G.Type.NULL, false, ""),
          ]),
        )
      return n
    }
    function r(n) {
      var i
      if (
        (e.detachedContent
          ? (i = e.detachedContent)
          : ((i = e.contentInfo.value[1]), (i = i.value[0])),
        !i)
      )
        throw new Error(
          "Could not sign PKCS#7 message; there is no content to sign.",
        )
      var s = G.derToOid(e.contentInfo.value[0].value),
        o = G.toDer(i)
      o.getByte(), G.getBerValueLength(o), (o = o.getBytes())
      for (var a in n) n[a].start().update(o)
      for (var l = new Date(), c = 0; c < e.signers.length; ++c) {
        var u = e.signers[c]
        if (u.authenticatedAttributes.length === 0) {
          if (s !== De.pki.oids.data)
            throw new Error(
              "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.",
            )
        } else {
          u.authenticatedAttributesAsn1 = G.create(
            G.Class.CONTEXT_SPECIFIC,
            0,
            true,
            [],
          )
          for (
            var f = G.create(G.Class.UNIVERSAL, G.Type.SET, true, []), p = 0;
            p < u.authenticatedAttributes.length;
            ++p
          ) {
            var g = u.authenticatedAttributes[p]
            g.type === De.pki.oids.messageDigest
              ? (g.value = n[u.digestAlgorithm].digest())
              : g.type === De.pki.oids.signingTime &&
                (g.value || (g.value = l)),
              f.value.push(_5(g)),
              u.authenticatedAttributesAsn1.value.push(_5(g))
          }
          ;(o = G.toDer(f).getBytes()), u.md.start().update(o)
        }
        u.signature = u.key.sign(u.md, "RSASSA-PKCS1-V1_5")
      }
      e.signerInfos = qrt(e.signers)
    }
  }
  Eo.createEncryptedData = function () {
    var e = null
    return (
      (e = {
        type: De.pki.oids.encryptedData,
        version: 0,
        encryptedContent: { algorithm: De.pki.oids["aes256-CBC"] },
        fromAsn1: function (t) {
          x5(e, t, Eo.asn1.encryptedDataValidator)
        },
        decrypt: function (t) {
          t !== undefined && (e.encryptedContent.key = t), zde(e)
        },
      }),
      e
    )
  }
  Eo.createEnvelopedData = function () {
    var e = null
    return (
      (e = {
        type: De.pki.oids.envelopedData,
        version: 0,
        recipients: [],
        encryptedContent: { algorithm: De.pki.oids["aes256-CBC"] },
        fromAsn1: function (t) {
          var r = x5(e, t, Eo.asn1.envelopedDataValidator)
          e.recipients = Lrt(r.recipientInfos.value)
        },
        toAsn1: function () {
          return G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [
            G.create(
              G.Class.UNIVERSAL,
              G.Type.OID,
              false,
              G.oidToDer(e.type).getBytes(),
            ),
            G.create(G.Class.CONTEXT_SPECIFIC, 0, true, [
              G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [
                G.create(
                  G.Class.UNIVERSAL,
                  G.Type.INTEGER,
                  false,
                  G.integerToDer(e.version).getBytes(),
                ),
                G.create(G.Class.UNIVERSAL, G.Type.SET, true, Urt(e.recipients)),
                G.create(
                  G.Class.UNIVERSAL,
                  G.Type.SEQUENCE,
                  true,
                  Vrt(e.encryptedContent),
                ),
              ]),
            ]),
          ])
        },
        findRecipient: function (t) {
          for (
            var r = t.issuer.attributes, n = 0;
            n < e.recipients.length;
            ++n
          ) {
            var i = e.recipients[n],
              s = i.issuer
            if (i.serialNumber === t.serialNumber && s.length === r.length) {
              for (var o = true, a = 0; a < r.length; ++a)
                if (s[a].type !== r[a].type || s[a].value !== r[a].value) {
                  o = false
                  break
                }
              if (o) return i
            }
          }
          return null
        },
        decrypt: function (t, r) {
          if (e.encryptedContent.key === undefined && t !== undefined && r !== undefined)
            switch (t.encryptedContent.algorithm) {
              case De.pki.oids.rsaEncryption:
              case De.pki.oids.desCBC:
                var n = r.decrypt(t.encryptedContent.content)
                e.encryptedContent.key = De.util.createBuffer(n)
                break
              default:
                throw new Error(
                  "Unsupported asymmetric cipher, OID " +
                    t.encryptedContent.algorithm,
                )
            }
          zde(e)
        },
        addRecipient: function (t) {
          e.recipients.push({
            version: 0,
            issuer: t.issuer.attributes,
            serialNumber: t.serialNumber,
            encryptedContent: {
              algorithm: De.pki.oids.rsaEncryption,
              key: t.publicKey,
            },
          })
        },
        encrypt: function (t, r) {
          if (e.encryptedContent.content === undefined) {
            ;(r = r || e.encryptedContent.algorithm),
              (t = t || e.encryptedContent.key)
            var n, i, s
            switch (r) {
              case De.pki.oids["aes128-CBC"]:
                ;(n = 16), (i = 16), (s = De.aes.createEncryptionCipher)
                break
              case De.pki.oids["aes192-CBC"]:
                ;(n = 24), (i = 16), (s = De.aes.createEncryptionCipher)
                break
              case De.pki.oids["aes256-CBC"]:
                ;(n = 32), (i = 16), (s = De.aes.createEncryptionCipher)
                break
              case De.pki.oids["des-EDE3-CBC"]:
                ;(n = 24), (i = 8), (s = De.des.createEncryptionCipher)
                break
              default:
                throw new Error("Unsupported symmetric cipher, OID " + r)
            }
            if (t === undefined) t = De.util.createBuffer(De.random.getBytes(n))
            else if (t.length() != n)
              throw new Error(
                "Symmetric key has wrong length; got " +
                  t.length() +
                  " bytes, expected " +
                  n +
                  ".",
              )
            ;(e.encryptedContent.algorithm = r),
              (e.encryptedContent.key = t),
              (e.encryptedContent.parameter = De.util.createBuffer(
                De.random.getBytes(i),
              ))
            var o = s(t)
            if (
              (o.start(e.encryptedContent.parameter.copy()),
              o.update(e.content),
              !o.finish())
            )
              throw new Error("Symmetric encryption failed.")
            e.encryptedContent.content = o.output
          }
          for (var a = 0; a < e.recipients.length; ++a) {
            var l = e.recipients[a]
            if (l.encryptedContent.content === undefined)
              switch (l.encryptedContent.algorithm) {
                case De.pki.oids.rsaEncryption:
                  l.encryptedContent.content = l.encryptedContent.key.encrypt(
                    e.encryptedContent.key.data,
                  )
                  break
                default:
                  throw new Error(
                    "Unsupported asymmetric cipher, OID " +
                      l.encryptedContent.algorithm,
                  )
              }
          }
        },
      }),
      e
    )
  }
  function Nrt(e) {
    var t = {},
      r = []
    if (!G.validate(e, Eo.asn1.recipientInfoValidator, t, r)) {
      var n = new Error(
        "Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.",
      )
      throw ((n.errors = r), n)
    }
    return {
      version: t.version.charCodeAt(0),
      issuer: De.pki.RDNAttributesAsArray(t.issuer),
      serialNumber: De.util.createBuffer(t.serial).toHex(),
      encryptedContent: {
        algorithm: G.derToOid(t.encAlgorithm),
        parameter: t.encParameter ? t.encParameter.value : undefined,
        content: t.encKey,
      },
    }
  }
  function Prt(e) {
    return G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [
      G.create(
        G.Class.UNIVERSAL,
        G.Type.INTEGER,
        false,
        G.integerToDer(e.version).getBytes(),
      ),
      G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [
        De.pki.distinguishedNameToAsn1({ attributes: e.issuer }),
        G.create(
          G.Class.UNIVERSAL,
          G.Type.INTEGER,
          false,
          De.util.hexToBytes(e.serialNumber),
        ),
      ]),
      G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [
        G.create(
          G.Class.UNIVERSAL,
          G.Type.OID,
          false,
          G.oidToDer(e.encryptedContent.algorithm).getBytes(),
        ),
        G.create(G.Class.UNIVERSAL, G.Type.NULL, false, ""),
      ]),
      G.create(
        G.Class.UNIVERSAL,
        G.Type.OCTETSTRING,
        false,
        e.encryptedContent.content,
      ),
    ])
  }
  function Lrt(e) {
    for (var t = [], r = 0; r < e.length; ++r) t.push(Nrt(e[r]))
    return t
  }
  function Urt(e) {
    for (var t = [], r = 0; r < e.length; ++r) t.push(Prt(e[r]))
    return t
  }
  function Ort(e) {
    var t = G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [
      G.create(
        G.Class.UNIVERSAL,
        G.Type.INTEGER,
        false,
        G.integerToDer(e.version).getBytes(),
      ),
      G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [
        De.pki.distinguishedNameToAsn1({ attributes: e.issuer }),
        G.create(
          G.Class.UNIVERSAL,
          G.Type.INTEGER,
          false,
          De.util.hexToBytes(e.serialNumber),
        ),
      ]),
      G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [
        G.create(
          G.Class.UNIVERSAL,
          G.Type.OID,
          false,
          G.oidToDer(e.digestAlgorithm).getBytes(),
        ),
        G.create(G.Class.UNIVERSAL, G.Type.NULL, false, ""),
      ]),
    ])
    if (
      (e.authenticatedAttributesAsn1 &&
        t.value.push(e.authenticatedAttributesAsn1),
      t.value.push(
        G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [
          G.create(
            G.Class.UNIVERSAL,
            G.Type.OID,
            false,
            G.oidToDer(e.signatureAlgorithm).getBytes(),
          ),
          G.create(G.Class.UNIVERSAL, G.Type.NULL, false, ""),
        ]),
      ),
      t.value.push(
        G.create(G.Class.UNIVERSAL, G.Type.OCTETSTRING, false, e.signature),
      ),
      e.unauthenticatedAttributes.length > 0)
    ) {
      for (
        var r = G.create(G.Class.CONTEXT_SPECIFIC, 1, true, []), n = 0;
        n < e.unauthenticatedAttributes.length;
        ++n
      ) {
        var i = e.unauthenticatedAttributes[n]
        r.values.push(_5(i))
      }
      t.value.push(r)
    }
    return t
  }
  function qrt(e) {
    for (var t = [], r = 0; r < e.length; ++r) t.push(Ort(e[r]))
    return t
  }
  function _5(e) {
    var t
    if (e.type === De.pki.oids.contentType)
      t = G.create(
        G.Class.UNIVERSAL,
        G.Type.OID,
        false,
        G.oidToDer(e.value).getBytes(),
      )
    else if (e.type === De.pki.oids.messageDigest)
      t = G.create(G.Class.UNIVERSAL, G.Type.OCTETSTRING, false, e.value.bytes())
    else if (e.type === De.pki.oids.signingTime) {
      var r = new Date("1950-01-01T00:00:00Z"),
        n = new Date("2050-01-01T00:00:00Z"),
        i = e.value
      if (typeof i == "string") {
        var s = Date.parse(i)
        isNaN(s)
          ? i.length === 13
            ? (i = G.utcTimeToDate(i))
            : (i = G.generalizedTimeToDate(i))
          : (i = new Date(s))
      }
      i >= r && i < n
        ? (t = G.create(
            G.Class.UNIVERSAL,
            G.Type.UTCTIME,
            false,
            G.dateToUtcTime(i),
          ))
        : (t = G.create(
            G.Class.UNIVERSAL,
            G.Type.GENERALIZEDTIME,
            false,
            G.dateToGeneralizedTime(i),
          ))
    }
    return G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [
      G.create(
        G.Class.UNIVERSAL,
        G.Type.OID,
        false,
        G.oidToDer(e.type).getBytes(),
      ),
      G.create(G.Class.UNIVERSAL, G.Type.SET, true, [t]),
    ])
  }
  function Vrt(e) {
    return [
      G.create(
        G.Class.UNIVERSAL,
        G.Type.OID,
        false,
        G.oidToDer(De.pki.oids.data).getBytes(),
      ),
      G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [
        G.create(
          G.Class.UNIVERSAL,
          G.Type.OID,
          false,
          G.oidToDer(e.algorithm).getBytes(),
        ),
        e.parameter
          ? G.create(
              G.Class.UNIVERSAL,
              G.Type.OCTETSTRING,
              false,
              e.parameter.getBytes(),
            )
          : undefined,
      ]),
      G.create(G.Class.CONTEXT_SPECIFIC, 0, true, [
        G.create(
          G.Class.UNIVERSAL,
          G.Type.OCTETSTRING,
          false,
          e.content.getBytes(),
        ),
      ]),
    ]
  }
  function x5(e, t, r) {
    var n = {},
      i = []
    if (!G.validate(t, r, n, i)) {
      var s = new Error(
        "Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.",
      )
      throw ((s.errors = s), s)
    }
    var o = G.derToOid(n.contentType)
    if (o !== De.pki.oids.data)
      throw new Error(
        "Unsupported PKCS#7 message. Only wrapped ContentType Data supported.",
      )
    if (n.encryptedContent) {
      var a = ""
      if (De.util.isArray(n.encryptedContent))
        for (var l = 0; l < n.encryptedContent.length; ++l) {
          if (n.encryptedContent[l].type !== G.Type.OCTETSTRING)
            throw new Error(
              "Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.",
            )
          a += n.encryptedContent[l].value
        }
      else a = n.encryptedContent
      e.encryptedContent = {
        algorithm: G.derToOid(n.encAlgorithm),
        parameter: De.util.createBuffer(n.encParameter.value),
        content: De.util.createBuffer(a),
      }
    }
    if (n.content) {
      var a = ""
      if (De.util.isArray(n.content))
        for (var l = 0; l < n.content.length; ++l) {
          if (n.content[l].type !== G.Type.OCTETSTRING)
            throw new Error(
              "Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.",
            )
          a += n.content[l].value
        }
      else a = n.content
      e.content = De.util.createBuffer(a)
    }
    return (e.version = n.version.charCodeAt(0)), (e.rawCapture = n), n
  }
  function zde(e) {
    if (e.encryptedContent.key === undefined)
      throw new Error("Symmetric key not available.")
    if (e.content === undefined) {
      var t
      switch (e.encryptedContent.algorithm) {
        case De.pki.oids["aes128-CBC"]:
        case De.pki.oids["aes192-CBC"]:
        case De.pki.oids["aes256-CBC"]:
          t = De.aes.createDecryptionCipher(e.encryptedContent.key)
          break
        case De.pki.oids.desCBC:
        case De.pki.oids["des-EDE3-CBC"]:
          t = De.des.createDecryptionCipher(e.encryptedContent.key)
          break
        default:
          throw new Error(
            "Unsupported symmetric cipher, OID " + e.encryptedContent.algorithm,
          )
      }
      if (
        (t.start(e.encryptedContent.parameter),
        t.update(e.encryptedContent.content),
        !t.finish())
      )
        throw new Error("Symmetric decryption failed.")
      e.content = t.output
    }
  }
})
var Xde = _((Fkt, Zde) => {
  "use strict"
  var Mi = jt()
  Rh()
  Ay()
  lT()
  by()
  Pr()
  var TT = (Zde.exports = Mi.ssh = Mi.ssh || {})
  TT.privateKeyToPutty = function (e, t, r) {
    ;(r = r || ""), (t = t || "")
    var n = "ssh-rsa",
      i = t === "" ? "none" : "aes256-cbc",
      s =
        "PuTTY-User-Key-File-2: " +
        n +
        `\r
`
    ;(s +=
      "Encryption: " +
      i +
      `\r
`),
      (s +=
        "Comment: " +
        r +
        `\r
`)
    var o = Mi.util.createBuffer()
    Ry(o, n), Ou(o, e.e), Ou(o, e.n)
    var a = Mi.util.encode64(o.bytes(), 64),
      l = Math.floor(a.length / 66) + 1
    ;(s +=
      "Public-Lines: " +
      l +
      `\r
`),
      (s += a)
    var c = Mi.util.createBuffer()
    Ou(c, e.d), Ou(c, e.p), Ou(c, e.q), Ou(c, e.qInv)
    var u
    if (!t) u = Mi.util.encode64(c.bytes(), 64)
    else {
      var f = c.length() + 16 - 1
      f -= f % 16
      var p = DT(c.bytes())
      p.truncate(p.length() - f + c.length()), c.putBuffer(p)
      var g = Mi.util.createBuffer()
      g.putBuffer(DT("\0\0\0\0", t)), g.putBuffer(DT("\0\0\0", t))
      var m = Mi.aes.createEncryptionCipher(g.truncate(8), "CBC")
      m.start(Mi.util.createBuffer().fillWithByte(0, 16)),
        m.update(c.copy()),
        m.finish()
      var y = m.output
      y.truncate(16), (u = Mi.util.encode64(y.bytes(), 64))
    }
    ;(l = Math.floor(u.length / 66) + 1),
      (s +=
        `\r
Private-Lines: ` +
        l +
        `\r
`),
      (s += u)
    var v = DT("putty-private-key-file-mac-key", t),
      C = Mi.util.createBuffer()
    Ry(C, n),
      Ry(C, i),
      Ry(C, r),
      C.putInt32(o.length()),
      C.putBuffer(o),
      C.putInt32(c.length()),
      C.putBuffer(c)
    var E = Mi.hmac.create()
    return (
      E.start("sha1", v),
      E.update(C.bytes()),
      (s +=
        `\r
Private-MAC: ` +
        E.digest().toHex() +
        `\r
`),
      s
    )
  }
  TT.publicKeyToOpenSSH = function (e, t) {
    var r = "ssh-rsa"
    t = t || ""
    var n = Mi.util.createBuffer()
    return (
      Ry(n, r),
      Ou(n, e.e),
      Ou(n, e.n),
      r + " " + Mi.util.encode64(n.bytes()) + " " + t
    )
  }
  TT.privateKeyToOpenSSH = function (e, t) {
    return t
      ? Mi.pki.encryptRsaPrivateKey(e, t, { legacy: true, algorithm: "aes128" })
      : Mi.pki.privateKeyToPem(e)
  }
  TT.getPublicKeyFingerprint = function (e, t) {
    t = t || {}
    var r = t.md || Mi.md.md5.create(),
      n = "ssh-rsa",
      i = Mi.util.createBuffer()
    Ry(i, n), Ou(i, e.e), Ou(i, e.n), r.start(), r.update(i.getBytes())
    var s = r.digest()
    if (t.encoding === "hex") {
      var o = s.toHex()
      return t.delimiter ? o.match(/.{2}/g).join(t.delimiter) : o
    } else {
      if (t.encoding === "binary") return s.getBytes()
      if (t.encoding) throw new Error('Unknown encoding "' + t.encoding + '".')
    }
    return s
  }
  function Ou(e, t) {
    var r = t.toString(16)
    r[0] >= "8" && (r = "00" + r)
    var n = Mi.util.hexToBytes(r)
    e.putInt32(n.length), e.putBytes(n)
  }
  function Ry(e, t) {
    e.putInt32(t.length), e.putString(t)
  }
  function DT() {
    for (var e = Mi.md.sha1.create(), t = arguments.length, r = 0; r < t; ++r)
      e.update(arguments[r])
    return e.digest()
  }
})
var tfe = _((Qkt, efe) => {
  "use strict"
  efe.exports = jt()
  Rh()
  Cde()
  Mc()
  tT()
  g_()
  Lde()
  Ay()
  Vde()
  $de()
  Kde()
  JW()
  fT()
  Hp()
  WW()
  XW()
  jde()
  t5()
  $W()
  NW()
  vT()
  Tl()
  UW()
  Xde()
  a5()
  Pr()
})
var ife = _((jp) => {
  "use strict"
  Object.defineProperty(jp, "__esModule", { value: true })
  jp.convert = jp.Format = undefined
  var w_ = tfe(),
    Lh
  ;(function (e) {
    ;(e.der = "der"),
      (e.pem = "pem"),
      (e.txt = "txt"),
      (e.asn1 = "asn1"),
      (e.x509 = "x509"),
      (e.fingerprint = "fingerprint")
  })((Lh = jp.Format || (jp.Format = {})))
  function rfe(e) {
    var t = w_.pki.pemToDer(e),
      r = w_.asn1,
      n = r.fromDer(t.data.toString("binary")).value[0].value,
      i = n[0],
      s =
        i.tagClass === r.Class.CONTEXT_SPECIFIC &&
        i.type === 0 &&
        i.constructed,
      o = n.slice(s)
    return { serial: o[0], issuer: o[2], valid: o[3], subject: o[4] }
  }
  function Hrt(e) {
    var t = rfe(e),
      r = t.subject.value
        .map(function (i) {
          return i.value[0].value[1].value
        })
        .join("/"),
      n = t.valid.value
        .map(function (i) {
          return i.value
        })
        .join(" - ")
    return ["Subject	".concat(r), "Valid	".concat(n), String(e)].join(`
`)
  }
  function nfe(e, t) {
    switch (t) {
      case Lh.der:
        return w_.pki.pemToDer(e)
      case Lh.pem:
        return e
      case Lh.txt:
        return Hrt(e)
      case Lh.asn1:
        return rfe(e)
      case Lh.fingerprint:
        var r = w_.md.sha1.create(),
          n = nfe(e, Lh.der)
        return r.update(n.getBytes()), r.digest().toHex()
      case Lh.x509:
        return w_.pki.certificateFromPem(e)
      default:
        throw new Error("unknown format ".concat(t))
    }
  }
  jp.convert = nfe
})
var ufe = _((na) => {
  "use strict"
  var Uh =
      (na && na.__assign) ||
      function () {
        return (
          (Uh =
            Object.assign ||
            function (e) {
              for (var t, r = 1, n = arguments.length; r < n; r++) {
                t = arguments[r]
                for (var i in t)
                  Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i])
              }
              return e
            }),
          Uh.apply(this, arguments)
        )
      },
    kT =
      (na && na.__spreadArray) ||
      function (e, t, r) {
        if (r || arguments.length === 2)
          for (var n = 0, i = t.length, s; n < i; n++)
            (s || !(n in t)) &&
              (s || (s = Array.prototype.slice.call(t, 0, n)), (s[n] = t[n]))
        return e.concat(s || Array.prototype.slice.call(t))
      }
  Object.defineProperty(na, "__esModule", { value: true })
  na.convert = na.Format = na.addToGlobalAgent = na.get = undefined
  var w5 = require("https"),
    Wrt = require("tls"),
    sfe = require("child_process"),
    ofe = Uce(),
    tf = ife()
  Object.defineProperty(na, "Format", {
    enumerable: true,
    get: function () {
      return tf.Format
    },
  })
  Object.defineProperty(na, "convert", {
    enumerable: true,
    get: function () {
      return tf.convert
    },
  })
  var afe = process.platform === "darwin",
    lfe = w5.globalAgent,
    FT = {
      keychain: "all",
      unique: true,
      excludeBundled: true,
      format: tf.Format.pem,
    }
  function cfe(e) {
    if ((e === undefined && (e = FT), !afe)) return []
    e = Uh(Uh({}, FT), e)
    var t = /(?=-----BEGIN\sCERTIFICATE-----)/g,
      r = ["find-certificate", "-a", "-p"],
      n = []
    if (e.keychain === "all" || e.keychain === "SystemRootCertificates") {
      var i = "/System/Library/Keychains/SystemRootCertificates.keychain",
        s = (0, sfe.spawnSync)("/usr/bin/security", r.concat(i))
          .stdout.toString()
          .split(t)
          .map(function (c) {
            return c.trim()
          })
      n = kT(kT([], n, true), s, true)
    }
    if (e.keychain === "all" || e.keychain === "current") {
      var o = (0, sfe.spawnSync)("/usr/bin/security", r)
        .stdout.toString()
        .split(t)
        .map(function (c) {
          return c.trim()
        })
      n = kT(kT([], n, true), o, true)
    }
    if (e.unique || e.excludeBundled) {
      var a = n.map(function (c) {
          return (0, tf.convert)(c, tf.Format.fingerprint)
        }),
        l = e.excludeBundled
          ? Wrt.rootCertificates.map(function (c) {
              return (0, tf.convert)(c, tf.Format.fingerprint)
            })
          : []
      n = n.filter(function (c, u) {
        var f = a[u]
        return !(
          (e.unique && u !== a.indexOf(f)) ||
          (e.excludeBundled && l.includes(f))
        )
      })
    }
    return n.map(function (c) {
      return (0, tf.convert)(c, e.format)
    })
  }
  na.get = cfe
  var MT = lfe.options.ca,
    Grt = function (e) {
      if ((e === undefined && (e = FT), !!afe)) {
        var t
        Array.isArray(MT)
          ? (t = Array.from(MT))
          : (t = typeof MT < "u" ? [MT] : []),
          cfe(
            Uh(Uh(Uh({}, FT), e), {
              format: tf.Format.pem,
              excludeBundled: false,
            }),
          ).forEach(function (r) {
            return t.push(r)
          }),
          (lfe.options.ca = t),
          (w5.Agent = (function (r) {
            return function (n) {
              var i = typeof n < "u" ? Uh({}, n) : {}
              return typeof i.ca > "u" && (i.ca = t), r.call(this, i)
            }
          })(w5.Agent)),
          (0, ofe.setGlobalDispatcher)(new ofe.Agent({ connect: { ca: t } }))
      }
    }
  na.addToGlobalAgent = Grt
})
var Afe = _((fMt, mfe) => {
  "use strict"
  function Krt(e, t) {
    for (
      var r = -1, n = e == null ? 0 : e.length;
      ++r < n && t(e[r], r, e) !== false;

    );
    return e
  }
  mfe.exports = Krt
})
var vfe = _((hMt, yfe) => {
  "use strict"
  var zrt = ch(),
    Jrt = (function () {
      try {
        var e = zrt(Object, "defineProperty")
        return e({}, "", {}), e
      } catch {}
    })()
  yfe.exports = Jrt
})
var R5 = _((gMt, bfe) => {
  "use strict"
  var Cfe = vfe()
  function jrt(e, t, r) {
    t == "__proto__" && Cfe
      ? Cfe(e, t, { configurable: true, enumerable: true, value: r, writable: true })
      : (e[t] = r)
  }
  bfe.exports = jrt
})
var D5 = _((pMt, Efe) => {
  "use strict"
  var Zrt = R5(),
    Xrt = zB(),
    ent = Object.prototype,
    tnt = ent.hasOwnProperty
  function rnt(e, t, r) {
    var n = e[t]
    ;(!(tnt.call(e, t) && Xrt(n, r)) || (r === undefined && !(t in e))) &&
      Zrt(e, t, r)
  }
  Efe.exports = rnt
})
var S_ = _((mMt, _fe) => {
  "use strict"
  var nnt = D5(),
    int = R5()
  function snt(e, t, r, n) {
    var i = !r
    r || (r = {})
    for (var s = -1, o = t.length; ++s < o; ) {
      var a = t[s],
        l = n ? n(r[a], e[a], a, r, e) : undefined
      l === undefined && (l = e[a]), i ? int(r, a, l) : nnt(r, a, l)
    }
    return r
  }
  _fe.exports = snt
})
var wfe = _((AMt, xfe) => {
  "use strict"
  var ont = S_(),
    ant = nR()
  function lnt(e, t) {
    return e && ont(t, ant(t), e)
  }
  xfe.exports = lnt
})
var Ife = _((yMt, Sfe) => {
  "use strict"
  function cnt(e) {
    var t = []
    if (e != null) for (var r in Object(e)) t.push(r)
    return t
  }
  Sfe.exports = cnt
})
var Rfe = _((vMt, Bfe) => {
  "use strict"
  var unt = Bd(),
    dnt = rR(),
    fnt = Ife(),
    hnt = Object.prototype,
    gnt = hnt.hasOwnProperty
  function pnt(e) {
    if (!unt(e)) return fnt(e)
    var t = dnt(e),
      r = []
    for (var n in e) (n == "constructor" && (t || !gnt.call(e, n))) || r.push(n)
    return r
  }
  Bfe.exports = pnt
})
var UT = _((CMt, Dfe) => {
  "use strict"
  var mnt = KO(),
    Ant = Rfe(),
    ynt = JO()
  function vnt(e) {
    return ynt(e) ? mnt(e, true) : Ant(e)
  }
  Dfe.exports = vnt
})
var kfe = _((bMt, Tfe) => {
  "use strict"
  var Cnt = S_(),
    bnt = UT()
  function Ent(e, t) {
    return e && Cnt(t, bnt(t), e)
  }
  Tfe.exports = Ent
})
var Pfe = _((I_, Ty) => {
  "use strict"
  var _nt = Al(),
    Nfe = typeof I_ == "object" && I_ && !I_.nodeType && I_,
    Mfe = Nfe && typeof Ty == "object" && Ty && !Ty.nodeType && Ty,
    xnt = Mfe && Mfe.exports === Nfe,
    Ffe = xnt ? _nt.Buffer : undefined,
    Qfe = Ffe ? Ffe.allocUnsafe : undefined
  function wnt(e, t) {
    if (t) return e.slice()
    var r = e.length,
      n = Qfe ? Qfe(r) : new e.constructor(r)
    return e.copy(n), n
  }
  Ty.exports = wnt
})
var Ufe = _((EMt, Lfe) => {
  "use strict"
  function Snt(e, t) {
    var r = -1,
      n = e.length
    for (t || (t = Array(n)); ++r < n; ) t[r] = e[r]
    return t
  }
  Lfe.exports = Snt
})
var qfe = _((_Mt, Ofe) => {
  "use strict"
  var Int = S_(),
    Bnt = ZB()
  function Rnt(e, t) {
    return Int(e, Bnt(e), t)
  }
  Ofe.exports = Rnt
})
var T5 = _((xMt, Vfe) => {
  "use strict"
  var Dnt = zO(),
    Tnt = Dnt(Object.getPrototypeOf, Object)
  Vfe.exports = Tnt
})
var k5 = _((wMt, Hfe) => {
  "use strict"
  var knt = VO(),
    Mnt = T5(),
    Fnt = ZB(),
    Qnt = WO(),
    Nnt = Object.getOwnPropertySymbols,
    Pnt = Nnt
      ? function (e) {
          for (var t = []; e; ) knt(t, Fnt(e)), (e = Mnt(e))
          return t
        }
      : Qnt
  Hfe.exports = Pnt
})
var Gfe = _((SMt, Wfe) => {
  "use strict"
  var Lnt = S_(),
    Unt = k5()
  function Ont(e, t) {
    return Lnt(e, Unt(e), t)
  }
  Wfe.exports = Ont
})
var Yfe = _((IMt, $fe) => {
  "use strict"
  var qnt = HO(),
    Vnt = k5(),
    Hnt = UT()
  function Wnt(e) {
    return qnt(e, Hnt, Vnt)
  }
  $fe.exports = Wnt
})
var zfe = _((BMt, Kfe) => {
  "use strict"
  var Gnt = Object.prototype,
    $nt = Gnt.hasOwnProperty
  function Ynt(e) {
    var t = e.length,
      r = new e.constructor(t)
    return (
      t &&
        typeof e[0] == "string" &&
        $nt.call(e, "index") &&
        ((r.index = e.index), (r.input = e.input)),
      r
    )
  }
  Kfe.exports = Ynt
})
var OT = _((RMt, jfe) => {
  "use strict"
  var Jfe = OO()
  function Knt(e) {
    var t = new e.constructor(e.byteLength)
    return new Jfe(t).set(new Jfe(e)), t
  }
  jfe.exports = Knt
})
var Xfe = _((DMt, Zfe) => {
  "use strict"
  var znt = OT()
  function Jnt(e, t) {
    var r = t ? znt(e.buffer) : e.buffer
    return new e.constructor(r, e.byteOffset, e.byteLength)
  }
  Zfe.exports = Jnt
})
var the = _((TMt, ehe) => {
  "use strict"
  var jnt = /\w*$/
  function Znt(e) {
    var t = new e.constructor(e.source, jnt.exec(e))
    return (t.lastIndex = e.lastIndex), t
  }
  ehe.exports = Znt
})
var ohe = _((kMt, she) => {
  "use strict"
  var rhe = sb(),
    nhe = rhe ? rhe.prototype : undefined,
    ihe = nhe ? nhe.valueOf : undefined
  function Xnt(e) {
    return ihe ? Object(ihe.call(e)) : {}
  }
  she.exports = Xnt
})
var lhe = _((MMt, ahe) => {
  "use strict"
  var eit = OT()
  function tit(e, t) {
    var r = t ? eit(e.buffer) : e.buffer
    return new e.constructor(r, e.byteOffset, e.length)
  }
  ahe.exports = tit
})
var uhe = _((FMt, che) => {
  "use strict"
  var rit = OT(),
    nit = Xfe(),
    iit = the(),
    sit = ohe(),
    oit = lhe(),
    ait = "[object Boolean]",
    lit = "[object Date]",
    cit = "[object Map]",
    uit = "[object Number]",
    dit = "[object RegExp]",
    fit = "[object Set]",
    hit = "[object String]",
    git = "[object Symbol]",
    pit = "[object ArrayBuffer]",
    mit = "[object DataView]",
    Ait = "[object Float32Array]",
    yit = "[object Float64Array]",
    vit = "[object Int8Array]",
    Cit = "[object Int16Array]",
    bit = "[object Int32Array]",
    Eit = "[object Uint8Array]",
    _it = "[object Uint8ClampedArray]",
    xit = "[object Uint16Array]",
    wit = "[object Uint32Array]"
  function Sit(e, t, r) {
    var n = e.constructor
    switch (t) {
      case pit:
        return rit(e)
      case ait:
      case lit:
        return new n(+e)
      case mit:
        return nit(e, r)
      case Ait:
      case yit:
      case vit:
      case Cit:
      case bit:
      case Eit:
      case _it:
      case xit:
      case wit:
        return oit(e, r)
      case cit:
        return new n()
      case uit:
      case hit:
        return new n(e)
      case dit:
        return iit(e)
      case fit:
        return new n()
      case git:
        return sit(e)
    }
  }
  che.exports = Sit
})
var hhe = _((QMt, fhe) => {
  "use strict"
  var Iit = Bd(),
    dhe = Object.create,
    Bit = (function () {
      function e() {}
      return function (t) {
        if (!Iit(t)) return {}
        if (dhe) return dhe(t)
        e.prototype = t
        var r = new e()
        return (e.prototype = undefined), r
      }
    })()
  fhe.exports = Bit
})
var phe = _((NMt, ghe) => {
  "use strict"
  var Rit = hhe(),
    Dit = T5(),
    Tit = rR()
  function kit(e) {
    return typeof e.constructor == "function" && !Tit(e) ? Rit(Dit(e)) : {}
  }
  ghe.exports = kit
})
var Ahe = _((PMt, mhe) => {
  "use strict"
  var Mit = lE(),
    Fit = $f(),
    Qit = "[object Map]"
  function Nit(e) {
    return Fit(e) && Mit(e) == Qit
  }
  mhe.exports = Nit
})
var bhe = _((LMt, Che) => {
  "use strict"
  var Pit = Ahe(),
    Lit = eR(),
    yhe = tR(),
    vhe = yhe && yhe.isMap,
    Uit = vhe ? Lit(vhe) : Pit
  Che.exports = Uit
})
var _he = _((UMt, Ehe) => {
  "use strict"
  var Oit = lE(),
    qit = $f(),
    Vit = "[object Set]"
  function Hit(e) {
    return qit(e) && Oit(e) == Vit
  }
  Ehe.exports = Hit
})
var Ihe = _((OMt, She) => {
  "use strict"
  var Wit = _he(),
    Git = eR(),
    xhe = tR(),
    whe = xhe && xhe.isSet,
    $it = whe ? Git(whe) : Wit
  She.exports = $it
})
var khe = _((qMt, The) => {
  "use strict"
  var Yit = LO(),
    Kit = Afe(),
    zit = D5(),
    Jit = wfe(),
    jit = kfe(),
    Zit = Pfe(),
    Xit = Ufe(),
    est = qfe(),
    tst = Gfe(),
    rst = jO(),
    nst = Yfe(),
    ist = lE(),
    sst = zfe(),
    ost = uhe(),
    ast = phe(),
    lst = iE(),
    cst = XB(),
    ust = bhe(),
    dst = Bd(),
    fst = Ihe(),
    hst = nR(),
    gst = UT(),
    pst = 1,
    mst = 2,
    Ast = 4,
    Bhe = "[object Arguments]",
    yst = "[object Array]",
    vst = "[object Boolean]",
    Cst = "[object Date]",
    bst = "[object Error]",
    Rhe = "[object Function]",
    Est = "[object GeneratorFunction]",
    _st = "[object Map]",
    xst = "[object Number]",
    Dhe = "[object Object]",
    wst = "[object RegExp]",
    Sst = "[object Set]",
    Ist = "[object String]",
    Bst = "[object Symbol]",
    Rst = "[object WeakMap]",
    Dst = "[object ArrayBuffer]",
    Tst = "[object DataView]",
    kst = "[object Float32Array]",
    Mst = "[object Float64Array]",
    Fst = "[object Int8Array]",
    Qst = "[object Int16Array]",
    Nst = "[object Int32Array]",
    Pst = "[object Uint8Array]",
    Lst = "[object Uint8ClampedArray]",
    Ust = "[object Uint16Array]",
    Ost = "[object Uint32Array]",
    Sn = {}
  Sn[Bhe] =
    Sn[yst] =
    Sn[Dst] =
    Sn[Tst] =
    Sn[vst] =
    Sn[Cst] =
    Sn[kst] =
    Sn[Mst] =
    Sn[Fst] =
    Sn[Qst] =
    Sn[Nst] =
    Sn[_st] =
    Sn[xst] =
    Sn[Dhe] =
    Sn[wst] =
    Sn[Sst] =
    Sn[Ist] =
    Sn[Bst] =
    Sn[Pst] =
    Sn[Lst] =
    Sn[Ust] =
    Sn[Ost] =
      true
  Sn[bst] = Sn[Rhe] = Sn[Rst] = false
  function qT(e, t, r, n, i, s) {
    var o,
      a = t & pst,
      l = t & mst,
      c = t & Ast
    if ((r && (o = i ? r(e, n, i, s) : r(e)), o !== undefined)) return o
    if (!dst(e)) return e
    var u = lst(e)
    if (u) {
      if (((o = sst(e)), !a)) return Xit(e, o)
    } else {
      var f = ist(e),
        p = f == Rhe || f == Est
      if (cst(e)) return Zit(e, a)
      if (f == Dhe || f == Bhe || (p && !i)) {
        if (((o = l || p ? {} : ast(e)), !a))
          return l ? tst(e, jit(o, e)) : est(e, Jit(o, e))
      } else {
        if (!Sn[f]) return i ? e : {}
        o = ost(e, f, a)
      }
    }
    s || (s = new Yit())
    var g = s.get(e)
    if (g) return g
    s.set(e, o),
      fst(e)
        ? e.forEach(function (v) {
            o.add(qT(v, t, r, v, e, s))
          })
        : ust(e) &&
          e.forEach(function (v, C) {
            o.set(C, qT(v, t, r, C, e, s))
          })
    var m = c ? (l ? nst : rst) : l ? gst : hst,
      y = u ? undefined : m(e)
    return (
      Kit(y || e, function (v, C) {
        y && ((C = v), (v = e[C])), zit(o, C, qT(v, t, r, C, e, s))
      }),
      o
    )
  }
  The.exports = qT
})
var Fhe = _((VMt, Mhe) => {
  "use strict"
  var qst = khe(),
    Vst = 1,
    Hst = 4
  function Wst(e) {
    return qst(e, Vst | Hst)
  }
  Mhe.exports = Wst
})
var ia = _((HMt, Qhe) => {
  "use strict"
  var M5 = class e extends Error {
    constructor(t) {
      super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${
        t.toString().split(`
`)[0]
      }
`),
        Error.captureStackTrace(this, e)
    }
  }
  Qhe.exports = (e) => {
    if (e.length > 2) throw new M5(e)
    function t(n = {}) {
      this.options = n
    }
    t.prototype.transform = e
    function r(n) {
      return new t(n)
    }
    return (r.Format = t), r
  }
})
var Uhe = _((WMt, Lhe) => {
  "use strict"
  var Phe = {}
  Lhe.exports = Phe
  var Nhe = {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39],
    grey: [90, 39],
    brightRed: [91, 39],
    brightGreen: [92, 39],
    brightYellow: [93, 39],
    brightBlue: [94, 39],
    brightMagenta: [95, 39],
    brightCyan: [96, 39],
    brightWhite: [97, 39],
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgBrightRed: [101, 49],
    bgBrightGreen: [102, 49],
    bgBrightYellow: [103, 49],
    bgBrightBlue: [104, 49],
    bgBrightMagenta: [105, 49],
    bgBrightCyan: [106, 49],
    bgBrightWhite: [107, 49],
    blackBG: [40, 49],
    redBG: [41, 49],
    greenBG: [42, 49],
    yellowBG: [43, 49],
    blueBG: [44, 49],
    magentaBG: [45, 49],
    cyanBG: [46, 49],
    whiteBG: [47, 49],
  }
  Object.keys(Nhe).forEach(function (e) {
    var t = Nhe[e],
      r = (Phe[e] = [])
    ;(r.open = "\x1B[" + t[0] + "m"), (r.close = "\x1B[" + t[1] + "m")
  })
})
var qhe = _((GMt, Ohe) => {
  "use strict"
  Ohe.exports = function (e, t) {
    t = t || process.argv || []
    var r = t.indexOf("--"),
      n = /^-{1,2}/.test(e) ? "" : "--",
      i = t.indexOf(n + e)
    return i !== -1 && (r === -1 ? true : i < r)
  }
})
var Hhe = _(($Mt, Vhe) => {
  "use strict"
  var Gst = require("os"),
    Nc = qhe(),
    _o = process.env,
    ky = undefined
  Nc("no-color") || Nc("no-colors") || Nc("color=false")
    ? (ky = false)
    : (Nc("color") || Nc("colors") || Nc("color=true") || Nc("color=always")) &&
      (ky = true)
  "FORCE_COLOR" in _o &&
    (ky = _o.FORCE_COLOR.length === 0 || parseInt(_o.FORCE_COLOR, 10) !== 0)
  function $st(e) {
    return e === 0
      ? false
      : { level: e, hasBasic: true, has256: e >= 2, has16m: e >= 3 }
  }
  function Yst(e) {
    if (ky === false) return 0
    if (Nc("color=16m") || Nc("color=full") || Nc("color=truecolor")) return 3
    if (Nc("color=256")) return 2
    if (e && !e.isTTY && ky !== true) return 0
    var t = ky ? 1 : 0
    if (process.platform === "win32") {
      var r = Gst.release().split(".")
      return Number(process.versions.node.split(".")[0]) >= 8 &&
        Number(r[0]) >= 10 &&
        Number(r[2]) >= 10586
        ? Number(r[2]) >= 14931
          ? 3
          : 2
        : 1
    }
    if ("CI" in _o)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function (i) {
        return i in _o
      }) || _o.CI_NAME === "codeship"
        ? 1
        : t
    if ("TEAMCITY_VERSION" in _o)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(_o.TEAMCITY_VERSION) ? 1 : 0
    if ("TERM_PROGRAM" in _o) {
      var n = parseInt((_o.TERM_PROGRAM_VERSION || "").split(".")[0], 10)
      switch (_o.TERM_PROGRAM) {
        case "iTerm.app":
          return n >= 3 ? 3 : 2
        case "Hyper":
          return 3
        case "Apple_Terminal":
          return 2
      }
    }
    return /-256(color)?$/i.test(_o.TERM)
      ? 2
      : /^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(_o.TERM) ||
          "COLORTERM" in _o
        ? 1
        : (_o.TERM === "dumb", t)
  }
  function F5(e) {
    var t = Yst(e)
    return $st(t)
  }
  Vhe.exports = {
    supportsColor: F5,
    stdout: F5(process.stdout),
    stderr: F5(process.stderr),
  }
})
var Ghe = _((YMt, Whe) => {
  "use strict"
  Whe.exports = function (t, r) {
    var n = ""
    ;(t = t || "Run the trap, drop the bass"), (t = t.split(""))
    var i = {
      a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
      b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
      c: ["\xA9", "\u023B", "\u03FE"],
      d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
      e: [
        "\xCB",
        "\u0115",
        "\u018E",
        "\u0258",
        "\u03A3",
        "\u03BE",
        "\u04BC",
        "\u0A6C",
      ],
      f: ["\u04FA"],
      g: ["\u0262"],
      h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
      i: ["\u0F0F"],
      j: ["\u0134"],
      k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
      l: ["\u0139"],
      m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
      n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
      o: [
        "\xD8",
        "\xF5",
        "\xF8",
        "\u01FE",
        "\u0298",
        "\u047A",
        "\u05DD",
        "\u06DD",
        "\u0E4F",
      ],
      p: ["\u01F7", "\u048E"],
      q: ["\u09CD"],
      r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
      s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
      t: ["\u0141", "\u0166", "\u0373"],
      u: ["\u01B1", "\u054D"],
      v: ["\u05D8"],
      w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
      x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
      y: ["\xA5", "\u04B0", "\u04CB"],
      z: ["\u01B5", "\u0240"],
    }
    return (
      t.forEach(function (s) {
        s = s.toLowerCase()
        var o = i[s] || [" "],
          a = Math.floor(Math.random() * o.length)
        typeof i[s] < "u" ? (n += i[s][a]) : (n += s)
      }),
      n
    )
  }
})
var Yhe = _((KMt, $he) => {
  "use strict"
  $he.exports = function (t, r) {
    t = t || "   he is here   "
    var n = {
        up: [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A",
        ],
        down: [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323",
        ],
        mid: [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489",
        ],
      },
      i = [].concat(n.up, n.down, n.mid)
    function s(l) {
      var c = Math.floor(Math.random() * l)
      return c
    }
    function o(l) {
      var c = false
      return (
        i.filter(function (u) {
          c = u === l
        }),
        c
      )
    }
    function a(l, c) {
      var u = "",
        f,
        p
      ;(c = c || {}),
        (c.up = typeof c.up < "u" ? c.up : true),
        (c.mid = typeof c.mid < "u" ? c.mid : true),
        (c.down = typeof c.down < "u" ? c.down : true),
        (c.size = typeof c.size < "u" ? c.size : "maxi"),
        (l = l.split(""))
      for (p in l)
        if (!o(p)) {
          switch (((u = u + l[p]), (f = { up: 0, down: 0, mid: 0 }), c.size)) {
            case "mini":
              ;(f.up = s(8)), (f.mid = s(2)), (f.down = s(8))
              break
            case "maxi":
              ;(f.up = s(16) + 3), (f.mid = s(4) + 1), (f.down = s(64) + 3)
              break
            default:
              ;(f.up = s(8) + 1), (f.mid = s(6) / 2), (f.down = s(8) + 1)
              break
          }
          var g = ["up", "mid", "down"]
          for (var m in g)
            for (var y = g[m], v = 0; v <= f[y]; v++)
              c[y] && (u = u + n[y][s(n[y].length)])
        }
      return u
    }
    return a(t, r)
  }
})
var zhe = _((zMt, Khe) => {
  "use strict"
  Khe.exports = function (e) {
    return function (t, r, n) {
      if (t === " ") return t
      switch (r % 3) {
        case 0:
          return e.red(t)
        case 1:
          return e.white(t)
        case 2:
          return e.blue(t)
      }
    }
  }
})
var jhe = _((JMt, Jhe) => {
  "use strict"
  Jhe.exports = function (e) {
    return function (t, r, n) {
      return r % 2 === 0 ? t : e.inverse(t)
    }
  }
})
var Xhe = _((jMt, Zhe) => {
  "use strict"
  Zhe.exports = function (e) {
    var t = ["red", "yellow", "green", "blue", "magenta"]
    return function (r, n, i) {
      return r === " " ? r : e[t[n++ % t.length]](r)
    }
  }
})
var tge = _((ZMt, ege) => {
  "use strict"
  ege.exports = function (e) {
    var t = [
      "underline",
      "inverse",
      "grey",
      "yellow",
      "red",
      "green",
      "blue",
      "white",
      "cyan",
      "magenta",
      "brightYellow",
      "brightRed",
      "brightGreen",
      "brightBlue",
      "brightWhite",
      "brightCyan",
      "brightMagenta",
    ]
    return function (r, n, i) {
      return r === " " ? r : e[t[Math.round(Math.random() * (t.length - 2))]](r)
    }
  }
})
var age = _((eFt, oge) => {
  "use strict"
  var gr = {}
  oge.exports = gr
  gr.themes = {}
  var Kst = require("util"),
    em = (gr.styles = Uhe()),
    nge = Object.defineProperties,
    zst = new RegExp(/[\r\n]+/g)
  gr.supportsColor = Hhe().supportsColor
  typeof gr.enabled > "u" && (gr.enabled = gr.supportsColor() !== false)
  gr.enable = function () {
    gr.enabled = true
  }
  gr.disable = function () {
    gr.enabled = false
  }
  gr.stripColors = gr.strip = function (e) {
    return ("" + e).replace(/\x1B\[\d+m/g, "")
  }
  var XMt = (gr.stylize = function (t, r) {
      if (!gr.enabled) return t + ""
      var n = em[r]
      return !n && r in gr ? gr[r](t) : n.open + t + n.close
    }),
    Jst = /[|\\{}()[\]^$+*?.]/g,
    jst = function (e) {
      if (typeof e != "string") throw new TypeError("Expected a string")
      return e.replace(Jst, "\\$&")
    }
  function ige(e) {
    var t = function r() {
      return Xst.apply(r, arguments)
    }
    return (t._styles = e), (t.__proto__ = Zst), t
  }
  var sge = (function () {
      var e = {}
      return (
        (em.grey = em.gray),
        Object.keys(em).forEach(function (t) {
          ;(em[t].closeRe = new RegExp(jst(em[t].close), "g")),
            (e[t] = {
              get: function () {
                return ige(this._styles.concat(t))
              },
            })
        }),
        e
      )
    })(),
    Zst = nge(function () {}, sge)
  function Xst() {
    var e = Array.prototype.slice.call(arguments),
      t = e
        .map(function (o) {
          return o != null && o.constructor === String ? o : Kst.inspect(o)
        })
        .join(" ")
    if (!gr.enabled || !t) return t
    for (
      var r =
          t.indexOf(`
`) != -1,
        n = this._styles,
        i = n.length;
      i--;

    ) {
      var s = em[n[i]]
      ;(t = s.open + t.replace(s.closeRe, s.open) + s.close),
        r &&
          (t = t.replace(zst, function (o) {
            return s.close + o + s.open
          }))
    }
    return t
  }
  gr.setTheme = function (e) {
    if (typeof e == "string") {
      console.log(
        "colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));",
      )
      return
    }
    for (var t in e)
      (function (r) {
        gr[r] = function (n) {
          if (typeof e[r] == "object") {
            var i = n
            for (var s in e[r]) i = gr[e[r][s]](i)
            return i
          }
          return gr[e[r]](n)
        }
      })(t)
  }
  function eot() {
    var e = {}
    return (
      Object.keys(sge).forEach(function (t) {
        e[t] = {
          get: function () {
            return ige([t])
          },
        }
      }),
      e
    )
  }
  var tot = function (t, r) {
    var n = r.split("")
    return (n = n.map(t)), n.join("")
  }
  gr.trap = Ghe()
  gr.zalgo = Yhe()
  gr.maps = {}
  gr.maps.america = zhe()(gr)
  gr.maps.zebra = jhe()(gr)
  gr.maps.rainbow = Xhe()(gr)
  gr.maps.random = tge()(gr)
  for (rge in gr.maps)
    (function (e) {
      gr[e] = function (t) {
        return tot(gr.maps[e], t)
      }
    })(rge)
  var rge
  nge(gr, eot())
})
var Q5 = _((tFt, lge) => {
  "use strict"
  var rot = age()
  lge.exports = rot
})
var cge = _((N5) => {
  "use strict"
  N5.levels = {
    error: 0,
    warn: 1,
    help: 2,
    data: 3,
    info: 4,
    debug: 5,
    prompt: 6,
    verbose: 7,
    input: 8,
    silly: 9,
  }
  N5.colors = {
    error: "red",
    warn: "yellow",
    help: "cyan",
    data: "grey",
    info: "green",
    debug: "blue",
    prompt: "grey",
    verbose: "cyan",
    input: "grey",
    silly: "magenta",
  }
})
var uge = _((P5) => {
  "use strict"
  P5.levels = {
    error: 0,
    warn: 1,
    info: 2,
    http: 3,
    verbose: 4,
    debug: 5,
    silly: 6,
  }
  P5.colors = {
    error: "red",
    warn: "yellow",
    info: "green",
    http: "green",
    verbose: "cyan",
    debug: "blue",
    silly: "magenta",
  }
})
var dge = _((L5) => {
  "use strict"
  L5.levels = {
    emerg: 0,
    alert: 1,
    crit: 2,
    error: 3,
    warning: 4,
    notice: 5,
    info: 6,
    debug: 7,
  }
  L5.colors = {
    emerg: "red",
    alert: "yellow",
    crit: "red",
    error: "red",
    warning: "red",
    notice: "yellow",
    info: "green",
    debug: "blue",
  }
})
var fge = _((VT) => {
  "use strict"
  Object.defineProperty(VT, "cli", { value: cge() })
  Object.defineProperty(VT, "npm", { value: uge() })
  Object.defineProperty(VT, "syslog", { value: dge() })
})
var Qi = _((B_) => {
  "use strict"
  Object.defineProperty(B_, "LEVEL", { value: Symbol.for("level") })
  Object.defineProperty(B_, "MESSAGE", { value: Symbol.for("message") })
  Object.defineProperty(B_, "SPLAT", { value: Symbol.for("splat") })
  Object.defineProperty(B_, "configs", { value: fge() })
})
var GT = _((aFt, WT) => {
  "use strict"
  var q5 = Q5(),
    { LEVEL: U5, MESSAGE: O5 } = Qi()
  q5.enabled = true
  var hge = /\s+/,
    HT = class e {
      constructor(t = {}) {
        t.colors && this.addColors(t.colors), (this.options = t)
      }
      static addColors(t) {
        let r = Object.keys(t).reduce(
          (n, i) => ((n[i] = hge.test(t[i]) ? t[i].split(hge) : t[i]), n),
          {},
        )
        return (
          (e.allColors = Object.assign({}, e.allColors || {}, r)), e.allColors
        )
      }
      addColors(t) {
        return e.addColors(t)
      }
      colorize(t, r, n) {
        if ((typeof n > "u" && (n = r), !Array.isArray(e.allColors[t])))
          return q5[e.allColors[t]](n)
        for (let i = 0, s = e.allColors[t].length; i < s; i++)
          n = q5[e.allColors[t][i]](n)
        return n
      }
      transform(t, r) {
        return (
          r.all &&
            typeof t[O5] == "string" &&
            (t[O5] = this.colorize(t[U5], t.level, t[O5])),
          (r.level || r.all || !r.message) &&
            (t.level = this.colorize(t[U5], t.level)),
          (r.all || r.message) &&
            (t.message = this.colorize(t[U5], t.level, t.message)),
          t
        )
      }
    }
  WT.exports = (e) => new HT(e)
  WT.exports.Colorizer = WT.exports.Format = HT
})
var pge = _((lFt, gge) => {
  "use strict"
  var { Colorizer: not } = GT()
  gge.exports = (e) => (not.addColors(e.colors || e), e)
})
var Age = _((cFt, mge) => {
  "use strict"
  var iot = ia()
  mge.exports = iot((e) => ((e.message = `	${e.message}`), e))
})
var Cge = _((uFt, vge) => {
  "use strict"
  var sot = ia(),
    { LEVEL: yge, MESSAGE: V5 } = Qi()
  vge.exports = sot((e, { stack: t, cause: r }) => {
    if (e instanceof Error) {
      let i = Object.assign({}, e, {
        level: e.level,
        [yge]: e[yge] || e.level,
        message: e.message,
        [V5]: e[V5] || e.message,
      })
      return t && (i.stack = e.stack), r && (i.cause = e.cause), i
    }
    if (!(e.message instanceof Error)) return e
    let n = e.message
    return (
      Object.assign(e, n),
      (e.message = n.message),
      (e[V5] = n.message),
      t && (e.stack = n.stack),
      r && (e.cause = n.cause),
      e
    )
  })
})
var W5 = _((dFt, YT) => {
  "use strict"
  var { configs: oot, LEVEL: bge, MESSAGE: H5 } = Qi(),
    $T = class e {
      constructor(t = { levels: oot.npm.levels }) {
        ;(this.paddings = e.paddingForLevels(t.levels, t.filler)),
          (this.options = t)
      }
      static getLongestLevel(t) {
        let r = Object.keys(t).map((n) => n.length)
        return Math.max(...r)
      }
      static paddingForLevel(t, r, n) {
        let i = n + 1 - t.length,
          s = Math.floor(i / r.length)
        return `${r}${r.repeat(s)}`.slice(0, i)
      }
      static paddingForLevels(t, r = " ") {
        let n = e.getLongestLevel(t)
        return Object.keys(t).reduce(
          (i, s) => ((i[s] = e.paddingForLevel(s, r, n)), i),
          {},
        )
      }
      transform(t, r) {
        return (
          (t.message = `${this.paddings[t[bge]]}${t.message}`),
          t[H5] && (t[H5] = `${this.paddings[t[bge]]}${t[H5]}`),
          t
        )
      }
    }
  YT.exports = (e) => new $T(e)
  YT.exports.Padder = YT.exports.Format = $T
})
var Ege = _((fFt, G5) => {
  "use strict"
  var { Colorizer: aot } = GT(),
    { Padder: lot } = W5(),
    { configs: cot, MESSAGE: uot } = Qi(),
    KT = class {
      constructor(t = {}) {
        t.levels || (t.levels = cot.cli.levels),
          (this.colorizer = new aot(t)),
          (this.padder = new lot(t)),
          (this.options = t)
      }
      transform(t, r) {
        return (
          this.colorizer.transform(this.padder.transform(t, r), r),
          (t[uot] = `${t.level}:${t.message}`),
          t
        )
      }
    }
  G5.exports = (e) => new KT(e)
  G5.exports.Format = KT
})
var xge = _((hFt, $5) => {
  "use strict"
  var dot = ia()
  function _ge(e) {
    if (e.every(fot))
      return (t) => {
        let r = t
        for (let n = 0; n < e.length; n++)
          if (((r = e[n].transform(r, e[n].options)), !r)) return false
        return r
      }
  }
  function fot(e) {
    if (typeof e.transform != "function")
      throw new Error(
        [
          "No transform function found on format. Did you create a format instance?",
          "const myFormat = format(formatFn);",
          "const instance = myFormat();",
        ].join(`
`),
      )
    return true
  }
  $5.exports = (...e) => {
    let t = dot(_ge(e)),
      r = t()
    return (r.Format = t.Format), r
  }
  $5.exports.cascade = _ge
})
var R_ = _((J5, Bge) => {
  "use strict"
  var { hasOwnProperty: zT } = Object.prototype,
    rm = z5()
  rm.configure = z5
  rm.stringify = rm
  rm.default = rm
  J5.stringify = rm
  J5.configure = z5
  Bge.exports = rm
  var hot =
    /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/
  function qh(e) {
    return e.length < 5e3 && !hot.test(e) ? `"${e}"` : JSON.stringify(e)
  }
  function Y5(e) {
    if (e.length > 200) return e.sort()
    for (let t = 1; t < e.length; t++) {
      let r = e[t],
        n = t
      for (; n !== 0 && e[n - 1] > r; ) (e[n] = e[n - 1]), n--
      e[n] = r
    }
    return e
  }
  var got = Object.getOwnPropertyDescriptor(
    Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array())),
    Symbol.toStringTag,
  ).get
  function K5(e) {
    return got.call(e) !== undefined && e.length !== 0
  }
  function wge(e, t, r) {
    e.length < r && (r = e.length)
    let n = t === "," ? "" : " ",
      i = `"0":${n}${e[0]}`
    for (let s = 1; s < r; s++) i += `${t}"${s}":${n}${e[s]}`
    return i
  }
  function pot(e) {
    if (zT.call(e, "circularValue")) {
      let t = e.circularValue
      if (typeof t == "string") return `"${t}"`
      if (t == null) return t
      if (t === Error || t === TypeError)
        return {
          toString() {
            throw new TypeError("Converting circular structure to JSON")
          },
        }
      throw new TypeError(
        'The "circularValue" argument must be of type string or the value null or undefined',
      )
    }
    return '"[Circular]"'
  }
  function Sge(e, t) {
    let r
    if (zT.call(e, t) && ((r = e[t]), typeof r != "boolean"))
      throw new TypeError(`The "${t}" argument must be of type boolean`)
    return r === undefined ? true : r
  }
  function Ige(e, t) {
    let r
    if (zT.call(e, t)) {
      if (((r = e[t]), typeof r != "number"))
        throw new TypeError(`The "${t}" argument must be of type number`)
      if (!Number.isInteger(r))
        throw new TypeError(`The "${t}" argument must be an integer`)
      if (r < 1) throw new RangeError(`The "${t}" argument must be >= 1`)
    }
    return r === undefined ? 1 / 0 : r
  }
  function tm(e) {
    return e === 1 ? "1 item" : `${e} items`
  }
  function mot(e) {
    let t = new Set()
    for (let r of e)
      (typeof r == "string" || typeof r == "number") && t.add(String(r))
    return t
  }
  function Aot(e) {
    if (zT.call(e, "strict")) {
      let t = e.strict
      if (typeof t != "boolean")
        throw new TypeError('The "strict" argument must be of type boolean')
      if (t)
        return (r) => {
          let n = `Object can not safely be stringified. Received type ${typeof r}`
          throw (
            (typeof r != "function" && (n += ` (${r.toString()})`),
            new Error(n))
          )
        }
    }
  }
  function z5(e) {
    e = { ...e }
    let t = Aot(e)
    t &&
      (e.bigint === undefined && (e.bigint = false),
      "circularValue" in e || (e.circularValue = Error))
    let r = pot(e),
      n = Sge(e, "bigint"),
      i = Sge(e, "deterministic"),
      s = Ige(e, "maximumDepth"),
      o = Ige(e, "maximumBreadth")
    function a(p, g, m, y, v, C) {
      let E = g[p]
      switch (
        (typeof E == "object" &&
          E !== null &&
          typeof E.toJSON == "function" &&
          (E = E.toJSON(p)),
        (E = y.call(g, p, E)),
        typeof E)
      ) {
        case "string":
          return qh(E)
        case "object": {
          if (E === null) return "null"
          if (m.indexOf(E) !== -1) return r
          let w = "",
            B = ",",
            T = C
          if (Array.isArray(E)) {
            if (E.length === 0) return "[]"
            if (s < m.length + 1) return '"[Array]"'
            m.push(E),
              v !== "" &&
                ((C += v),
                (w += `
${C}`),
                (B = `,
${C}`))
            let U = Math.min(E.length, o),
              ce = 0
            for (; ce < U - 1; ce++) {
              let Q = a(String(ce), E, m, y, v, C)
              ;(w += Q !== undefined ? Q : "null"), (w += B)
            }
            let Ie = a(String(ce), E, m, y, v, C)
            if (((w += Ie !== undefined ? Ie : "null"), E.length - 1 > o)) {
              let Q = E.length - o - 1
              w += `${B}"... ${tm(Q)} not stringified"`
            }
            return (
              v !== "" &&
                (w += `
${T}`),
              m.pop(),
              `[${w}]`
            )
          }
          let N = Object.keys(E),
            W = N.length
          if (W === 0) return "{}"
          if (s < m.length + 1) return '"[Object]"'
          let Z = "",
            te = ""
          v !== "" &&
            ((C += v),
            (B = `,
${C}`),
            (Z = " "))
          let Y = Math.min(W, o)
          i && !K5(E) && (N = Y5(N)), m.push(E)
          for (let U = 0; U < Y; U++) {
            let ce = N[U],
              Ie = a(ce, E, m, y, v, C)
            Ie !== undefined && ((w += `${te}${qh(ce)}:${Z}${Ie}`), (te = B))
          }
          if (W > o) {
            let U = W - o
            ;(w += `${te}"...":${Z}"${tm(U)} not stringified"`), (te = B)
          }
          return (
            v !== "" &&
              te.length > 1 &&
              (w = `
${C}${w}
${T}`),
            m.pop(),
            `{${w}}`
          )
        }
        case "number":
          return isFinite(E) ? String(E) : t ? t(E) : "null"
        case "boolean":
          return E === true ? "true" : "false"
        case "undefined":
          return
        case "bigint":
          if (n) return String(E)
        default:
          return t ? t(E) : undefined
      }
    }
    function l(p, g, m, y, v, C) {
      switch (
        (typeof g == "object" &&
          g !== null &&
          typeof g.toJSON == "function" &&
          (g = g.toJSON(p)),
        typeof g)
      ) {
        case "string":
          return qh(g)
        case "object": {
          if (g === null) return "null"
          if (m.indexOf(g) !== -1) return r
          let E = C,
            w = "",
            B = ","
          if (Array.isArray(g)) {
            if (g.length === 0) return "[]"
            if (s < m.length + 1) return '"[Array]"'
            m.push(g),
              v !== "" &&
                ((C += v),
                (w += `
${C}`),
                (B = `,
${C}`))
            let W = Math.min(g.length, o),
              Z = 0
            for (; Z < W - 1; Z++) {
              let Y = l(String(Z), g[Z], m, y, v, C)
              ;(w += Y !== undefined ? Y : "null"), (w += B)
            }
            let te = l(String(Z), g[Z], m, y, v, C)
            if (((w += te !== undefined ? te : "null"), g.length - 1 > o)) {
              let Y = g.length - o - 1
              w += `${B}"... ${tm(Y)} not stringified"`
            }
            return (
              v !== "" &&
                (w += `
${E}`),
              m.pop(),
              `[${w}]`
            )
          }
          m.push(g)
          let T = ""
          v !== "" &&
            ((C += v),
            (B = `,
${C}`),
            (T = " "))
          let N = ""
          for (let W of y) {
            let Z = l(W, g[W], m, y, v, C)
            Z !== undefined && ((w += `${N}${qh(W)}:${T}${Z}`), (N = B))
          }
          return (
            v !== "" &&
              N.length > 1 &&
              (w = `
${C}${w}
${E}`),
            m.pop(),
            `{${w}}`
          )
        }
        case "number":
          return isFinite(g) ? String(g) : t ? t(g) : "null"
        case "boolean":
          return g === true ? "true" : "false"
        case "undefined":
          return
        case "bigint":
          if (n) return String(g)
        default:
          return t ? t(g) : undefined
      }
    }
    function c(p, g, m, y, v) {
      switch (typeof g) {
        case "string":
          return qh(g)
        case "object": {
          if (g === null) return "null"
          if (typeof g.toJSON == "function") {
            if (((g = g.toJSON(p)), typeof g != "object"))
              return c(p, g, m, y, v)
            if (g === null) return "null"
          }
          if (m.indexOf(g) !== -1) return r
          let C = v
          if (Array.isArray(g)) {
            if (g.length === 0) return "[]"
            if (s < m.length + 1) return '"[Array]"'
            m.push(g), (v += y)
            let Z = `
${v}`,
              te = `,
${v}`,
              Y = Math.min(g.length, o),
              U = 0
            for (; U < Y - 1; U++) {
              let Ie = c(String(U), g[U], m, y, v)
              ;(Z += Ie !== undefined ? Ie : "null"), (Z += te)
            }
            let ce = c(String(U), g[U], m, y, v)
            if (((Z += ce !== undefined ? ce : "null"), g.length - 1 > o)) {
              let Ie = g.length - o - 1
              Z += `${te}"... ${tm(Ie)} not stringified"`
            }
            return (
              (Z += `
${C}`),
              m.pop(),
              `[${Z}]`
            )
          }
          let E = Object.keys(g),
            w = E.length
          if (w === 0) return "{}"
          if (s < m.length + 1) return '"[Object]"'
          v += y
          let B = `,
${v}`,
            T = "",
            N = "",
            W = Math.min(w, o)
          K5(g) &&
            ((T += wge(g, B, o)),
            (E = E.slice(g.length)),
            (W -= g.length),
            (N = B)),
            i && (E = Y5(E)),
            m.push(g)
          for (let Z = 0; Z < W; Z++) {
            let te = E[Z],
              Y = c(te, g[te], m, y, v)
            Y !== undefined && ((T += `${N}${qh(te)}: ${Y}`), (N = B))
          }
          if (w > o) {
            let Z = w - o
            ;(T += `${N}"...": "${tm(Z)} not stringified"`), (N = B)
          }
          return (
            N !== "" &&
              (T = `
${v}${T}
${C}`),
            m.pop(),
            `{${T}}`
          )
        }
        case "number":
          return isFinite(g) ? String(g) : t ? t(g) : "null"
        case "boolean":
          return g === true ? "true" : "false"
        case "undefined":
          return
        case "bigint":
          if (n) return String(g)
        default:
          return t ? t(g) : undefined
      }
    }
    function u(p, g, m) {
      switch (typeof g) {
        case "string":
          return qh(g)
        case "object": {
          if (g === null) return "null"
          if (typeof g.toJSON == "function") {
            if (((g = g.toJSON(p)), typeof g != "object")) return u(p, g, m)
            if (g === null) return "null"
          }
          if (m.indexOf(g) !== -1) return r
          let y = ""
          if (Array.isArray(g)) {
            if (g.length === 0) return "[]"
            if (s < m.length + 1) return '"[Array]"'
            m.push(g)
            let B = Math.min(g.length, o),
              T = 0
            for (; T < B - 1; T++) {
              let W = u(String(T), g[T], m)
              ;(y += W !== undefined ? W : "null"), (y += ",")
            }
            let N = u(String(T), g[T], m)
            if (((y += N !== undefined ? N : "null"), g.length - 1 > o)) {
              let W = g.length - o - 1
              y += `,"... ${tm(W)} not stringified"`
            }
            return m.pop(), `[${y}]`
          }
          let v = Object.keys(g),
            C = v.length
          if (C === 0) return "{}"
          if (s < m.length + 1) return '"[Object]"'
          let E = "",
            w = Math.min(C, o)
          K5(g) &&
            ((y += wge(g, ",", o)),
            (v = v.slice(g.length)),
            (w -= g.length),
            (E = ",")),
            i && (v = Y5(v)),
            m.push(g)
          for (let B = 0; B < w; B++) {
            let T = v[B],
              N = u(T, g[T], m)
            N !== undefined && ((y += `${E}${qh(T)}:${N}`), (E = ","))
          }
          if (C > o) {
            let B = C - o
            y += `${E}"...":"${tm(B)} not stringified"`
          }
          return m.pop(), `{${y}}`
        }
        case "number":
          return isFinite(g) ? String(g) : t ? t(g) : "null"
        case "boolean":
          return g === true ? "true" : "false"
        case "undefined":
          return
        case "bigint":
          if (n) return String(g)
        default:
          return t ? t(g) : undefined
      }
    }
    function f(p, g, m) {
      if (arguments.length > 1) {
        let y = ""
        if (
          (typeof m == "number"
            ? (y = " ".repeat(Math.min(m, 10)))
            : typeof m == "string" && (y = m.slice(0, 10)),
          g != null)
        ) {
          if (typeof g == "function") return a("", { "": p }, [], g, y, "")
          if (Array.isArray(g)) return l("", p, [], mot(g), y, "")
        }
        if (y.length !== 0) return c("", p, [], y, "")
      }
      return u("", p, [])
    }
    return f
  }
})
var j5 = _((gFt, Rge) => {
  "use strict"
  var yot = ia(),
    { MESSAGE: vot } = Qi(),
    Cot = R_()
  function bot(e, t) {
    return typeof t == "bigint" ? t.toString() : t
  }
  Rge.exports = yot((e, t) => {
    let r = Cot.configure(t)
    return (e[vot] = r(e, t.replacer || bot, t.space)), e
  })
})
var Tge = _((pFt, Dge) => {
  "use strict"
  var Eot = ia()
  Dge.exports = Eot((e, t) =>
    t.message
      ? ((e.message = `[${t.label}] ${e.message}`), e)
      : ((e.label = t.label), e),
  )
})
var Mge = _((mFt, kge) => {
  "use strict"
  var _ot = ia(),
    { MESSAGE: xot } = Qi(),
    wot = R_()
  kge.exports = _ot((e) => {
    let t = {}
    return (
      e.message && ((t["@message"] = e.message), delete e.message),
      e.timestamp && ((t["@timestamp"] = e.timestamp), delete e.timestamp),
      (t["@fields"] = e),
      (e[xot] = wot(t)),
      e
    )
  })
})
var Qge = _((AFt, Fge) => {
  "use strict"
  var Sot = ia()
  function Iot(e, t, r) {
    let n = t.reduce((s, o) => ((s[o] = e[o]), delete e[o], s), {}),
      i = Object.keys(e).reduce((s, o) => ((s[o] = e[o]), delete e[o], s), {})
    return Object.assign(e, n, { [r]: i }), e
  }
  function Bot(e, t, r) {
    return (e[r] = t.reduce((n, i) => ((n[i] = e[i]), delete e[i], n), {})), e
  }
  Fge.exports = Sot((e, t = {}) => {
    let r = "metadata"
    t.key && (r = t.key)
    let n = []
    return (
      !t.fillExcept && !t.fillWith && (n.push("level"), n.push("message")),
      t.fillExcept && (n = t.fillExcept),
      n.length > 0 ? Iot(e, n, r) : t.fillWith ? Bot(e, t.fillWith, r) : e
    )
  })
})
var jT = _((yFt, Nge) => {
  "use strict"
  var My = 1e3,
    Fy = My * 60,
    Qy = Fy * 60,
    nm = Qy * 24,
    Rot = nm * 7,
    Dot = nm * 365.25
  Nge.exports = function (e, t) {
    t = t || {}
    var r = typeof e
    if (r === "string" && e.length > 0) return Tot(e)
    if (r === "number" && isFinite(e)) return t.long ? Mot(e) : kot(e)
    throw new Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(e),
    )
  }
  function Tot(e) {
    if (((e = String(e)), !(e.length > 100))) {
      var t =
        /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          e,
        )
      if (t) {
        var r = parseFloat(t[1]),
          n = (t[2] || "ms").toLowerCase()
        switch (n) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return r * Dot
          case "weeks":
          case "week":
          case "w":
            return r * Rot
          case "days":
          case "day":
          case "d":
            return r * nm
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return r * Qy
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return r * Fy
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return r * My
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return r
          default:
            return
        }
      }
    }
  }
  function kot(e) {
    var t = Math.abs(e)
    return t >= nm
      ? Math.round(e / nm) + "d"
      : t >= Qy
        ? Math.round(e / Qy) + "h"
        : t >= Fy
          ? Math.round(e / Fy) + "m"
          : t >= My
            ? Math.round(e / My) + "s"
            : e + "ms"
  }
  function Mot(e) {
    var t = Math.abs(e)
    return t >= nm
      ? JT(e, t, nm, "day")
      : t >= Qy
        ? JT(e, t, Qy, "hour")
        : t >= Fy
          ? JT(e, t, Fy, "minute")
          : t >= My
            ? JT(e, t, My, "second")
            : e + " ms"
  }
  function JT(e, t, r, n) {
    var i = t >= r * 1.5
    return Math.round(e / r) + " " + n + (i ? "s" : "")
  }
})
var Lge = _((D_, Pge) => {
  "use strict"
  var Fot = ia(),
    Qot = jT()
  Pge.exports = Fot((e) => {
    let t = +new Date()
    return (
      (D_.diff = t - (D_.prevTime || t)),
      (D_.prevTime = t),
      (e.ms = `+${Qot(D_.diff)}`),
      e
    )
  })
})
var qge = _((vFt, Oge) => {
  "use strict"
  var Not = require("util").inspect,
    Pot = ia(),
    { LEVEL: Lot, MESSAGE: Uge, SPLAT: Uot } = Qi()
  Oge.exports = Pot((e, t = {}) => {
    let r = Object.assign({}, e)
    return (
      delete r[Lot],
      delete r[Uge],
      delete r[Uot],
      (e[Uge] = Not(r, false, t.depth || null, t.colorize)),
      e
    )
  })
})
var Vge = _((CFt, XT) => {
  "use strict"
  var { MESSAGE: Oot } = Qi(),
    ZT = class {
      constructor(t) {
        this.template = t
      }
      transform(t) {
        return (t[Oot] = this.template(t)), t
      }
    }
  XT.exports = (e) => new ZT(e)
  XT.exports.Printf = XT.exports.Format = ZT
})
var Gge = _((bFt, Wge) => {
  "use strict"
  var qot = ia(),
    { MESSAGE: Hge } = Qi(),
    Vot = R_()
  Wge.exports = qot((e) => {
    let t = Vot(
        Object.assign({}, e, { level: undefined, message: undefined, splat: undefined }),
      ),
      r = (e.padding && e.padding[e.level]) || ""
    return (
      t !== "{}"
        ? (e[Hge] = `${e.level}:${r} ${e.message} ${t}`)
        : (e[Hge] = `${e.level}:${r} ${e.message}`),
      e
    )
  })
})
var Kge = _((EFt, Yge) => {
  "use strict"
  var Hot = require("util"),
    { SPLAT: $ge } = Qi(),
    Wot = /%[scdjifoO%]/g,
    Got = /%%/g,
    Z5 = class {
      constructor(t) {
        this.options = t
      }
      _splat(t, r) {
        let n = t.message,
          i = t[$ge] || t.splat || [],
          s = n.match(Got),
          o = (s && s.length) || 0,
          l = r.length - o - i.length,
          c = l < 0 ? i.splice(l, -1 * l) : [],
          u = c.length
        if (u) for (let f = 0; f < u; f++) Object.assign(t, c[f])
        return (t.message = Hot.format(n, ...i)), t
      }
      transform(t) {
        let r = t.message,
          n = t[$ge] || t.splat
        if (!n || !n.length) return t
        let i = r && r.match && r.match(Wot)
        if (!i && (n || n.length)) {
          let s = n.length > 1 ? n.splice(0) : n,
            o = s.length
          if (o) for (let a = 0; a < o; a++) Object.assign(t, s[a])
          return t
        }
        return i ? this._splat(t, i) : t
      }
    }
  Yge.exports = (e) => new Z5(e)
})
var Jge = _((ek, zge) => {
  "use strict"
  ;(function (e, t) {
    typeof ek == "object" && typeof zge < "u"
      ? t(ek)
      : typeof define == "function" && define.amd
        ? define(["exports"], t)
        : t((e.fecha = {}))
  })(ek, function (e) {
    "use strict"
    var t =
        /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g,
      r = "\\d\\d?",
      n = "\\d\\d",
      i = "\\d{3}",
      s = "\\d{4}",
      o = "[^\\s]+",
      a = /\[([^]*?)\]/gm
    function l(J, ie) {
      for (var Ue = [], At = 0, ve = J.length; At < ve; At++)
        Ue.push(J[At].substr(0, ie))
      return Ue
    }
    var c = function (J) {
      return function (ie, Ue) {
        var At = Ue[J].map(function (Mt) {
            return Mt.toLowerCase()
          }),
          ve = At.indexOf(ie.toLowerCase())
        return ve > -1 ? ve : null
      }
    }
    function u(J) {
      for (var ie = [], Ue = 1; Ue < arguments.length; Ue++)
        ie[Ue - 1] = arguments[Ue]
      for (var At = 0, ve = ie; At < ve.length; At++) {
        var Mt = ve[At]
        for (var Xt in Mt) J[Xt] = Mt[Xt]
      }
      return J
    }
    var f = [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
      ],
      p = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
      ],
      g = l(p, 3),
      m = l(f, 3),
      y = {
        dayNamesShort: m,
        dayNames: f,
        monthNamesShort: g,
        monthNames: p,
        amPm: ["am", "pm"],
        DoFn: function (J) {
          return (
            J +
            ["th", "st", "nd", "rd"][
              J % 10 > 3 ? 0 : ((J - (J % 10) !== 10 ? 1 : 0) * J) % 10
            ]
          )
        },
      },
      v = u({}, y),
      C = function (J) {
        return (v = u(v, J))
      },
      E = function (J) {
        return J.replace(/[|\\{()[^$+*?.-]/g, "\\$&")
      },
      w = function (J, ie) {
        for (ie === undefined && (ie = 2), J = String(J); J.length < ie; )
          J = "0" + J
        return J
      },
      B = {
        D: function (J) {
          return String(J.getDate())
        },
        DD: function (J) {
          return w(J.getDate())
        },
        Do: function (J, ie) {
          return ie.DoFn(J.getDate())
        },
        d: function (J) {
          return String(J.getDay())
        },
        dd: function (J) {
          return w(J.getDay())
        },
        ddd: function (J, ie) {
          return ie.dayNamesShort[J.getDay()]
        },
        dddd: function (J, ie) {
          return ie.dayNames[J.getDay()]
        },
        M: function (J) {
          return String(J.getMonth() + 1)
        },
        MM: function (J) {
          return w(J.getMonth() + 1)
        },
        MMM: function (J, ie) {
          return ie.monthNamesShort[J.getMonth()]
        },
        MMMM: function (J, ie) {
          return ie.monthNames[J.getMonth()]
        },
        YY: function (J) {
          return w(String(J.getFullYear()), 4).substr(2)
        },
        YYYY: function (J) {
          return w(J.getFullYear(), 4)
        },
        h: function (J) {
          return String(J.getHours() % 12 || 12)
        },
        hh: function (J) {
          return w(J.getHours() % 12 || 12)
        },
        H: function (J) {
          return String(J.getHours())
        },
        HH: function (J) {
          return w(J.getHours())
        },
        m: function (J) {
          return String(J.getMinutes())
        },
        mm: function (J) {
          return w(J.getMinutes())
        },
        s: function (J) {
          return String(J.getSeconds())
        },
        ss: function (J) {
          return w(J.getSeconds())
        },
        S: function (J) {
          return String(Math.round(J.getMilliseconds() / 100))
        },
        SS: function (J) {
          return w(Math.round(J.getMilliseconds() / 10), 2)
        },
        SSS: function (J) {
          return w(J.getMilliseconds(), 3)
        },
        a: function (J, ie) {
          return J.getHours() < 12 ? ie.amPm[0] : ie.amPm[1]
        },
        A: function (J, ie) {
          return J.getHours() < 12
            ? ie.amPm[0].toUpperCase()
            : ie.amPm[1].toUpperCase()
        },
        ZZ: function (J) {
          var ie = J.getTimezoneOffset()
          return (
            (ie > 0 ? "-" : "+") +
            w(Math.floor(Math.abs(ie) / 60) * 100 + (Math.abs(ie) % 60), 4)
          )
        },
        Z: function (J) {
          var ie = J.getTimezoneOffset()
          return (
            (ie > 0 ? "-" : "+") +
            w(Math.floor(Math.abs(ie) / 60), 2) +
            ":" +
            w(Math.abs(ie) % 60, 2)
          )
        },
      },
      T = function (J) {
        return +J - 1
      },
      N = [null, r],
      W = [null, o],
      Z = [
        "isPm",
        o,
        function (J, ie) {
          var Ue = J.toLowerCase()
          return Ue === ie.amPm[0] ? 0 : Ue === ie.amPm[1] ? 1 : null
        },
      ],
      te = [
        "timezoneOffset",
        "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
        function (J) {
          var ie = (J + "").match(/([+-]|\d\d)/gi)
          if (ie) {
            var Ue = +ie[1] * 60 + parseInt(ie[2], 10)
            return ie[0] === "+" ? Ue : -Ue
          }
          return 0
        },
      ],
      Y = {
        D: ["day", r],
        DD: ["day", n],
        Do: [
          "day",
          r + o,
          function (J) {
            return parseInt(J, 10)
          },
        ],
        M: ["month", r, T],
        MM: ["month", n, T],
        YY: [
          "year",
          n,
          function (J) {
            var ie = new Date(),
              Ue = +("" + ie.getFullYear()).substr(0, 2)
            return +("" + (+J > 68 ? Ue - 1 : Ue) + J)
          },
        ],
        h: ["hour", r, undefined, "isPm"],
        hh: ["hour", n, undefined, "isPm"],
        H: ["hour", r],
        HH: ["hour", n],
        m: ["minute", r],
        mm: ["minute", n],
        s: ["second", r],
        ss: ["second", n],
        YYYY: ["year", s],
        S: [
          "millisecond",
          "\\d",
          function (J) {
            return +J * 100
          },
        ],
        SS: [
          "millisecond",
          n,
          function (J) {
            return +J * 10
          },
        ],
        SSS: ["millisecond", i],
        d: N,
        dd: N,
        ddd: W,
        dddd: W,
        MMM: ["month", o, c("monthNamesShort")],
        MMMM: ["month", o, c("monthNames")],
        a: Z,
        A: Z,
        ZZ: te,
        Z: te,
      },
      U = {
        default: "ddd MMM DD YYYY HH:mm:ss",
        shortDate: "M/D/YY",
        mediumDate: "MMM D, YYYY",
        longDate: "MMMM D, YYYY",
        fullDate: "dddd, MMMM D, YYYY",
        isoDate: "YYYY-MM-DD",
        isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
        shortTime: "HH:mm",
        mediumTime: "HH:mm:ss",
        longTime: "HH:mm:ss.SSS",
      },
      ce = function (J) {
        return u(U, J)
      },
      Ie = function (J, ie, Ue) {
        if (
          (ie === undefined && (ie = U.default),
          Ue === undefined && (Ue = {}),
          typeof J == "number" && (J = new Date(J)),
          Object.prototype.toString.call(J) !== "[object Date]" ||
            isNaN(J.getTime()))
        )
          throw new Error("Invalid Date pass to format")
        ie = U[ie] || ie
        var At = []
        ie = ie.replace(a, function (Mt, Xt) {
          return At.push(Xt), "@@@"
        })
        var ve = u(u({}, v), Ue)
        return (
          (ie = ie.replace(t, function (Mt) {
            return B[Mt](J, ve)
          })),
          ie.replace(/@@@/g, function () {
            return At.shift()
          })
        )
      }
    function Q(J, ie, Ue) {
      if ((Ue === undefined && (Ue = {}), typeof ie != "string"))
        throw new Error("Invalid format in fecha parse")
      if (((ie = U[ie] || ie), J.length > 1e3)) return null
      var At = new Date(),
        ve = {
          year: At.getFullYear(),
          month: 0,
          day: 1,
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0,
          isPm: null,
          timezoneOffset: null,
        },
        Mt = [],
        Xt = [],
        rr = ie.replace(a, function (_t, hn) {
          return Xt.push(E(hn)), "@@@"
        }),
        ue = {},
        wr = {}
      ;(rr = E(rr).replace(t, function (_t) {
        var hn = Y[_t],
          Rn = hn[0],
          Ii = hn[1],
          so = hn[3]
        if (ue[Rn])
          throw new Error(
            "Invalid format. " + Rn + " specified twice in format",
          )
        return (ue[Rn] = true), so && (wr[so] = true), Mt.push(hn), "(" + Ii + ")"
      })),
        Object.keys(wr).forEach(function (_t) {
          if (!ue[_t])
            throw new Error(
              "Invalid format. " + _t + " is required in specified format",
            )
        }),
        (rr = rr.replace(/@@@/g, function () {
          return Xt.shift()
        }))
      var or = J.match(new RegExp(rr, "i"))
      if (!or) return null
      for (var Wr = u(u({}, v), Ue), Ge = 1; Ge < or.length; Ge++) {
        var ln = Mt[Ge - 1],
          Gr = ln[0],
          pr = ln[2],
          Ee = pr ? pr(or[Ge], Wr) : +or[Ge]
        if (Ee == null) return null
        ve[Gr] = Ee
      }
      ve.isPm === 1 && ve.hour != null && +ve.hour != 12
        ? (ve.hour = +ve.hour + 12)
        : ve.isPm === 0 && +ve.hour == 12 && (ve.hour = 0)
      var Or
      if (ve.timezoneOffset == null) {
        Or = new Date(
          ve.year,
          ve.month,
          ve.day,
          ve.hour,
          ve.minute,
          ve.second,
          ve.millisecond,
        )
        for (
          var he = [
              ["month", "getMonth"],
              ["day", "getDate"],
              ["hour", "getHours"],
              ["minute", "getMinutes"],
              ["second", "getSeconds"],
            ],
            Ge = 0,
            be = he.length;
          Ge < be;
          Ge++
        )
          if (ue[he[Ge][0]] && ve[he[Ge][0]] !== Or[he[Ge][1]]()) return null
      } else if (
        ((Or = new Date(
          Date.UTC(
            ve.year,
            ve.month,
            ve.day,
            ve.hour,
            ve.minute - ve.timezoneOffset,
            ve.second,
            ve.millisecond,
          ),
        )),
        ve.month > 11 ||
          ve.month < 0 ||
          ve.day > 31 ||
          ve.day < 1 ||
          ve.hour > 23 ||
          ve.hour < 0 ||
          ve.minute > 59 ||
          ve.minute < 0 ||
          ve.second > 59 ||
          ve.second < 0)
      )
        return null
      return Or
    }
    var se = {
      format: Ie,
      parse: Q,
      defaultI18n: y,
      setGlobalDateI18n: C,
      setGlobalDateMasks: ce,
    }
    ;(e.assign = u),
      (e.default = se),
      (e.format = Ie),
      (e.parse = Q),
      (e.defaultI18n = y),
      (e.setGlobalDateI18n = C),
      (e.setGlobalDateMasks = ce),
      Object.defineProperty(e, "__esModule", { value: true })
  })
})
var Zge = _((_Ft, jge) => {
  "use strict"
  var $ot = Jge(),
    Yot = ia()
  jge.exports = Yot(
    (e, t = {}) => (
      t.format &&
        (e.timestamp =
          typeof t.format == "function"
            ? t.format()
            : $ot.format(new Date(), t.format)),
      e.timestamp || (e.timestamp = new Date().toISOString()),
      t.alias && (e[t.alias] = e.timestamp),
      e
    ),
  )
})
var epe = _((xFt, Xge) => {
  "use strict"
  var X5 = Q5(),
    Kot = ia(),
    { MESSAGE: e3 } = Qi()
  Xge.exports = Kot(
    (e, t) => (
      t.level !== false && (e.level = X5.strip(e.level)),
      t.message !== false && (e.message = X5.strip(String(e.message))),
      t.raw !== false && e[e3] && (e[e3] = X5.strip(String(e[e3]))),
      e
    ),
  )
})
var r3 = _((t3) => {
  "use strict"
  var zot = (t3.format = ia())
  t3.levels = pge()
  function ks(e, t) {
    Object.defineProperty(zot, e, {
      get() {
        return t()
      },
      configurable: true,
    })
  }
  ks("align", function () {
    return Age()
  })
  ks("errors", function () {
    return Cge()
  })
  ks("cli", function () {
    return Ege()
  })
  ks("combine", function () {
    return xge()
  })
  ks("colorize", function () {
    return GT()
  })
  ks("json", function () {
    return j5()
  })
  ks("label", function () {
    return Tge()
  })
  ks("logstash", function () {
    return Mge()
  })
  ks("metadata", function () {
    return Qge()
  })
  ks("ms", function () {
    return Lge()
  })
  ks("padLevels", function () {
    return W5()
  })
  ks("prettyPrint", function () {
    return qge()
  })
  ks("printf", function () {
    return Vge()
  })
  ks("simple", function () {
    return Gge()
  })
  ks("splat", function () {
    return Kge()
  })
  ks("timestamp", function () {
    return Zge()
  })
  ks("uncolorize", function () {
    return epe()
  })
})
var n3 = _((tk) => {
  "use strict"
  var { format: tpe } = require("util")
  tk.warn = {
    deprecated(e) {
      return () => {
        throw new Error(tpe("{ %s } was removed in winston@3.0.0.", e))
      }
    },
    useFormat(e) {
      return () => {
        throw new Error(
          [
            tpe("{ %s } was removed in winston@3.0.0.", e),
            "Use a custom winston.format = winston.format(function) instead.",
          ].join(`
`),
        )
      }
    },
    forFunctions(e, t, r) {
      r.forEach((n) => {
        e[n] = tk.warn[t](n)
      })
    },
    forProperties(e, t, r) {
      r.forEach((n) => {
        let i = tk.warn[t](n)
        Object.defineProperty(e, n, { get: i, set: i })
      })
    },
  }
})
var rpe = _((IFt, Jot) => {
  Jot.exports = {
    name: "winston",
    description: "A logger for just about everything.",
    version: "3.11.0",
    author: "Charlie Robbins <charlie.robbins@gmail.com>",
    maintainers: ["David Hyde <dabh@alumni.stanford.edu>"],
    repository: {
      type: "git",
      url: "https://github.com/winstonjs/winston.git",
    },
    keywords: [
      "winston",
      "logger",
      "logging",
      "logs",
      "sysadmin",
      "bunyan",
      "pino",
      "loglevel",
      "tools",
      "json",
      "stream",
    ],
    dependencies: {
      "@dabh/diagnostics": "^2.0.2",
      "@colors/colors": "^1.6.0",
      async: "^3.2.3",
      "is-stream": "^2.0.0",
      logform: "^2.4.0",
      "one-time": "^1.0.0",
      "readable-stream": "^3.4.0",
      "safe-stable-stringify": "^2.3.1",
      "stack-trace": "0.0.x",
      "triple-beam": "^1.3.0",
      "winston-transport": "^4.5.0",
    },
    devDependencies: {
      "@babel/cli": "^7.17.0",
      "@babel/core": "^7.17.2",
      "@babel/preset-env": "^7.16.7",
      "@dabh/eslint-config-populist": "^5.0.0",
      "@types/node": "^20.3.1",
      "abstract-winston-transport": "^0.5.1",
      assume: "^2.2.0",
      "cross-spawn-async": "^2.2.5",
      eslint: "^8.9.0",
      hock: "^1.4.1",
      mocha: "8.1.3",
      nyc: "^15.1.0",
      rimraf: "^5.0.5",
      split2: "^4.1.0",
      "std-mocks": "^1.0.1",
      through2: "^4.0.2",
      "winston-compat": "^0.1.5",
    },
    main: "./lib/winston.js",
    browser: "./dist/winston",
    types: "./index.d.ts",
    scripts: {
      lint: "eslint lib/*.js lib/winston/*.js lib/winston/**/*.js --resolve-plugins-relative-to ./node_modules/@dabh/eslint-config-populist",
      test: "mocha",
      "test:coverage": "nyc npm run test:unit",
      "test:unit": "mocha test/unit",
      "test:integration": "mocha test/integration",
      build: "rimraf dist && babel lib -d dist",
      prepublishOnly: "npm run build",
    },
    engines: { node: ">= 12.0.0" },
    license: "MIT",
  }
})
var ipe = _((BFt, npe) => {
  "use strict"
  npe.exports = require("util").deprecate
})
var i3 = _((RFt, spe) => {
  "use strict"
  spe.exports = require("stream")
})
var o3 = _((DFt, ape) => {
  "use strict"
  function jot(e, t) {
    var r = this,
      n = this._readableState && this._readableState.destroyed,
      i = this._writableState && this._writableState.destroyed
    return n || i
      ? (t
          ? t(e)
          : e &&
            (this._writableState
              ? this._writableState.errorEmitted ||
                ((this._writableState.errorEmitted = true),
                process.nextTick(s3, this, e))
              : process.nextTick(s3, this, e)),
        this)
      : (this._readableState && (this._readableState.destroyed = true),
        this._writableState && (this._writableState.destroyed = true),
        this._destroy(e || null, function (s) {
          !t && s
            ? r._writableState
              ? r._writableState.errorEmitted
                ? process.nextTick(rk, r)
                : ((r._writableState.errorEmitted = true),
                  process.nextTick(ope, r, s))
              : process.nextTick(ope, r, s)
            : t
              ? (process.nextTick(rk, r), t(s))
              : process.nextTick(rk, r)
        }),
        this)
  }
  function ope(e, t) {
    s3(e, t), rk(e)
  }
  function rk(e) {
    ;(e._writableState && !e._writableState.emitClose) ||
      (e._readableState && !e._readableState.emitClose) ||
      e.emit("close")
  }
  function Zot() {
    this._readableState &&
      ((this._readableState.destroyed = false),
      (this._readableState.reading = false),
      (this._readableState.ended = false),
      (this._readableState.endEmitted = false)),
      this._writableState &&
        ((this._writableState.destroyed = false),
        (this._writableState.ended = false),
        (this._writableState.ending = false),
        (this._writableState.finalCalled = false),
        (this._writableState.prefinished = false),
        (this._writableState.finished = false),
        (this._writableState.errorEmitted = false))
  }
  function s3(e, t) {
    e.emit("error", t)
  }
  function Xot(e, t) {
    var r = e._readableState,
      n = e._writableState
    ;(r && r.autoDestroy) || (n && n.autoDestroy)
      ? e.destroy(t)
      : e.emit("error", t)
  }
  ape.exports = { destroy: jot, undestroy: Zot, errorOrDestroy: Xot }
})
var Vh = _((TFt, upe) => {
  "use strict"
  var cpe = {}
  function Pl(e, t, r) {
    r || (r = Error)
    function n(s, o, a) {
      return typeof t == "string" ? t : t(s, o, a)
    }
    class i extends r {
      constructor(o, a, l) {
        super(n(o, a, l))
      }
    }
    ;(i.prototype.name = r.name), (i.prototype.code = e), (cpe[e] = i)
  }
  function lpe(e, t) {
    if (Array.isArray(e)) {
      let r = e.length
      return (
        (e = e.map((n) => String(n))),
        r > 2
          ? `one of ${t} ${e.slice(0, r - 1).join(", ")}, or ` + e[r - 1]
          : r === 2
            ? `one of ${t} ${e[0]} or ${e[1]}`
            : `of ${t} ${e[0]}`
      )
    } else return `of ${t} ${String(e)}`
  }
  function eat(e, t, r) {
    return e.substr(!r || r < 0 ? 0 : +r, t.length) === t
  }
  function tat(e, t, r) {
    return (
      (r === undefined || r > e.length) && (r = e.length),
      e.substring(r - t.length, r) === t
    )
  }
  function rat(e, t, r) {
    return (
      typeof r != "number" && (r = 0),
      r + t.length > e.length ? false : e.indexOf(t, r) !== -1
    )
  }
  Pl(
    "ERR_INVALID_OPT_VALUE",
    function (e, t) {
      return 'The value "' + t + '" is invalid for option "' + e + '"'
    },
    TypeError,
  )
  Pl(
    "ERR_INVALID_ARG_TYPE",
    function (e, t, r) {
      let n
      typeof t == "string" && eat(t, "not ")
        ? ((n = "must not be"), (t = t.replace(/^not /, "")))
        : (n = "must be")
      let i
      if (tat(e, " argument")) i = `The ${e} ${n} ${lpe(t, "type")}`
      else {
        let s = rat(e, ".") ? "property" : "argument"
        i = `The "${e}" ${s} ${n} ${lpe(t, "type")}`
      }
      return (i += `. Received type ${typeof r}`), i
    },
    TypeError,
  )
  Pl("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF")
  Pl("ERR_METHOD_NOT_IMPLEMENTED", function (e) {
    return "The " + e + " method is not implemented"
  })
  Pl("ERR_STREAM_PREMATURE_CLOSE", "Premature close")
  Pl("ERR_STREAM_DESTROYED", function (e) {
    return "Cannot call " + e + " after a stream was destroyed"
  })
  Pl("ERR_MULTIPLE_CALLBACK", "Callback called multiple times")
  Pl("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable")
  Pl("ERR_STREAM_WRITE_AFTER_END", "write after end")
  Pl("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError)
  Pl(
    "ERR_UNKNOWN_ENCODING",
    function (e) {
      return "Unknown encoding: " + e
    },
    TypeError,
  )
  Pl("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event")
  upe.exports.codes = cpe
})
var a3 = _((kFt, dpe) => {
  "use strict"
  var nat = Vh().codes.ERR_INVALID_OPT_VALUE
  function iat(e, t, r) {
    return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null
  }
  function sat(e, t, r, n) {
    var i = iat(t, n, r)
    if (i != null) {
      if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
        var s = n ? r : "highWaterMark"
        throw new nat(s, i)
      }
      return Math.floor(i)
    }
    return e.objectMode ? 16 : 16 * 1024
  }
  dpe.exports = { getHighWaterMark: sat }
})
var fpe = _((MFt, l3) => {
  "use strict"
  typeof Object.create == "function"
    ? (l3.exports = function (t, r) {
        r &&
          ((t.super_ = r),
          (t.prototype = Object.create(r.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true,
            },
          })))
      })
    : (l3.exports = function (t, r) {
        if (r) {
          t.super_ = r
          var n = function () {}
          ;(n.prototype = r.prototype),
            (t.prototype = new n()),
            (t.prototype.constructor = t)
        }
      })
})
var Ny = _((FFt, u3) => {
  "use strict"
  try {
    if (((c3 = require("util")), typeof c3.inherits != "function")) throw ""
    u3.exports = c3.inherits
  } catch {
    u3.exports = fpe()
  }
  var c3
})
var ype = _((QFt, Ape) => {
  "use strict"
  function hpe(e, t) {
    var r = Object.keys(e)
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e)
      t &&
        (n = n.filter(function (i) {
          return Object.getOwnPropertyDescriptor(e, i).enumerable
        })),
        r.push.apply(r, n)
    }
    return r
  }
  function gpe(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {}
      t % 2
        ? hpe(Object(r), true).forEach(function (n) {
            oat(e, n, r[n])
          })
        : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
          : hpe(Object(r)).forEach(function (n) {
              Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n))
            })
    }
    return e
  }
  function oat(e, t, r) {
    return (
      (t = mpe(t)),
      t in e
        ? Object.defineProperty(e, t, {
            value: r,
            enumerable: true,
            configurable: true,
            writable: true,
          })
        : (e[t] = r),
      e
    )
  }
  function aat(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function")
  }
  function ppe(e, t) {
    for (var r = 0; r < t.length; r++) {
      var n = t[r]
      ;(n.enumerable = n.enumerable || false),
        (n.configurable = true),
        "value" in n && (n.writable = true),
        Object.defineProperty(e, mpe(n.key), n)
    }
  }
  function lat(e, t, r) {
    return (
      t && ppe(e.prototype, t),
      r && ppe(e, r),
      Object.defineProperty(e, "prototype", { writable: false }),
      e
    )
  }
  function mpe(e) {
    var t = cat(e, "string")
    return typeof t == "symbol" ? t : String(t)
  }
  function cat(e, t) {
    if (typeof e != "object" || e === null) return e
    var r = e[Symbol.toPrimitive]
    if (r !== undefined) {
      var n = r.call(e, t || "default")
      if (typeof n != "object") return n
      throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
  }
  var uat = require("buffer"),
    nk = uat.Buffer,
    dat = require("util"),
    d3 = dat.inspect,
    fat = (d3 && d3.custom) || "inspect"
  function hat(e, t, r) {
    nk.prototype.copy.call(e, t, r)
  }
  Ape.exports = (function () {
    function e() {
      aat(this, e), (this.head = null), (this.tail = null), (this.length = 0)
    }
    return (
      lat(e, [
        {
          key: "push",
          value: function (r) {
            var n = { data: r, next: null }
            this.length > 0 ? (this.tail.next = n) : (this.head = n),
              (this.tail = n),
              ++this.length
          },
        },
        {
          key: "unshift",
          value: function (r) {
            var n = { data: r, next: this.head }
            this.length === 0 && (this.tail = n), (this.head = n), ++this.length
          },
        },
        {
          key: "shift",
          value: function () {
            if (this.length !== 0) {
              var r = this.head.data
              return (
                this.length === 1
                  ? (this.head = this.tail = null)
                  : (this.head = this.head.next),
                --this.length,
                r
              )
            }
          },
        },
        {
          key: "clear",
          value: function () {
            ;(this.head = this.tail = null), (this.length = 0)
          },
        },
        {
          key: "join",
          value: function (r) {
            if (this.length === 0) return ""
            for (var n = this.head, i = "" + n.data; (n = n.next); )
              i += r + n.data
            return i
          },
        },
        {
          key: "concat",
          value: function (r) {
            if (this.length === 0) return nk.alloc(0)
            for (var n = nk.allocUnsafe(r >>> 0), i = this.head, s = 0; i; )
              hat(i.data, n, s), (s += i.data.length), (i = i.next)
            return n
          },
        },
        {
          key: "consume",
          value: function (r, n) {
            var i
            return (
              r < this.head.data.length
                ? ((i = this.head.data.slice(0, r)),
                  (this.head.data = this.head.data.slice(r)))
                : r === this.head.data.length
                  ? (i = this.shift())
                  : (i = n ? this._getString(r) : this._getBuffer(r)),
              i
            )
          },
        },
        {
          key: "first",
          value: function () {
            return this.head.data
          },
        },
        {
          key: "_getString",
          value: function (r) {
            var n = this.head,
              i = 1,
              s = n.data
            for (r -= s.length; (n = n.next); ) {
              var o = n.data,
                a = r > o.length ? o.length : r
              if (
                (a === o.length ? (s += o) : (s += o.slice(0, r)),
                (r -= a),
                r === 0)
              ) {
                a === o.length
                  ? (++i,
                    n.next
                      ? (this.head = n.next)
                      : (this.head = this.tail = null))
                  : ((this.head = n), (n.data = o.slice(a)))
                break
              }
              ++i
            }
            return (this.length -= i), s
          },
        },
        {
          key: "_getBuffer",
          value: function (r) {
            var n = nk.allocUnsafe(r),
              i = this.head,
              s = 1
            for (i.data.copy(n), r -= i.data.length; (i = i.next); ) {
              var o = i.data,
                a = r > o.length ? o.length : r
              if ((o.copy(n, n.length - r, 0, a), (r -= a), r === 0)) {
                a === o.length
                  ? (++s,
                    i.next
                      ? (this.head = i.next)
                      : (this.head = this.tail = null))
                  : ((this.head = i), (i.data = o.slice(a)))
                break
              }
              ++s
            }
            return (this.length -= s), n
          },
        },
        {
          key: fat,
          value: function (r, n) {
            return d3(
              this,
              gpe(gpe({}, n), {}, { depth: 0, customInspect: false }),
            )
          },
        },
      ]),
      e
    )
  })()
})
var bpe = _((f3, Cpe) => {
  "use strict"
  var ik = require("buffer"),
    qu = ik.Buffer
  function vpe(e, t) {
    for (var r in e) t[r] = e[r]
  }
  qu.from && qu.alloc && qu.allocUnsafe && qu.allocUnsafeSlow
    ? (Cpe.exports = ik)
    : (vpe(ik, f3), (f3.Buffer = im))
  function im(e, t, r) {
    return qu(e, t, r)
  }
  im.prototype = Object.create(qu.prototype)
  vpe(qu, im)
  im.from = function (e, t, r) {
    if (typeof e == "number")
      throw new TypeError("Argument must not be a number")
    return qu(e, t, r)
  }
  im.alloc = function (e, t, r) {
    if (typeof e != "number") throw new TypeError("Argument must be a number")
    var n = qu(e)
    return (
      t !== undefined
        ? typeof r == "string"
          ? n.fill(t, r)
          : n.fill(t)
        : n.fill(0),
      n
    )
  }
  im.allocUnsafe = function (e) {
    if (typeof e != "number") throw new TypeError("Argument must be a number")
    return qu(e)
  }
  im.allocUnsafeSlow = function (e) {
    if (typeof e != "number") throw new TypeError("Argument must be a number")
    return ik.SlowBuffer(e)
  }
})
var p3 = _((_pe) => {
  "use strict"
  var g3 = bpe().Buffer,
    Epe =
      g3.isEncoding ||
      function (e) {
        switch (((e = "" + e), e && e.toLowerCase())) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true
          default:
            return false
        }
      }
  function gat(e) {
    if (!e) return "utf8"
    for (var t; ; )
      switch (e) {
        case "utf8":
        case "utf-8":
          return "utf8"
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le"
        case "latin1":
        case "binary":
          return "latin1"
        case "base64":
        case "ascii":
        case "hex":
          return e
        default:
          if (t) return
          ;(e = ("" + e).toLowerCase()), (t = true)
      }
  }
  function pat(e) {
    var t = gat(e)
    if (typeof t != "string" && (g3.isEncoding === Epe || !Epe(e)))
      throw new Error("Unknown encoding: " + e)
    return t || e
  }
  _pe.StringDecoder = T_
  function T_(e) {
    this.encoding = pat(e)
    var t
    switch (this.encoding) {
      case "utf16le":
        ;(this.text = bat), (this.end = Eat), (t = 4)
        break
      case "utf8":
        ;(this.fillLast = yat), (t = 4)
        break
      case "base64":
        ;(this.text = _at), (this.end = xat), (t = 3)
        break
      default:
        ;(this.write = wat), (this.end = Sat)
        return
    }
    ;(this.lastNeed = 0),
      (this.lastTotal = 0),
      (this.lastChar = g3.allocUnsafe(t))
  }
  T_.prototype.write = function (e) {
    if (e.length === 0) return ""
    var t, r
    if (this.lastNeed) {
      if (((t = this.fillLast(e)), t === undefined)) return ""
      ;(r = this.lastNeed), (this.lastNeed = 0)
    } else r = 0
    return r < e.length ? (t ? t + this.text(e, r) : this.text(e, r)) : t || ""
  }
  T_.prototype.end = Cat
  T_.prototype.text = vat
  T_.prototype.fillLast = function (e) {
    if (this.lastNeed <= e.length)
      return (
        e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed),
        this.lastChar.toString(this.encoding, 0, this.lastTotal)
      )
    e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length),
      (this.lastNeed -= e.length)
  }
  function h3(e) {
    return e <= 127
      ? 0
      : e >> 5 === 6
        ? 2
        : e >> 4 === 14
          ? 3
          : e >> 3 === 30
            ? 4
            : e >> 6 === 2
              ? -1
              : -2
  }
  function mat(e, t, r) {
    var n = t.length - 1
    if (n < r) return 0
    var i = h3(t[n])
    return i >= 0
      ? (i > 0 && (e.lastNeed = i - 1), i)
      : --n < r || i === -2
        ? 0
        : ((i = h3(t[n])),
          i >= 0
            ? (i > 0 && (e.lastNeed = i - 2), i)
            : --n < r || i === -2
              ? 0
              : ((i = h3(t[n])),
                i >= 0
                  ? (i > 0 && (i === 2 ? (i = 0) : (e.lastNeed = i - 3)), i)
                  : 0))
  }
  function Aat(e, t, r) {
    if ((t[0] & 192) !== 128) return (e.lastNeed = 0), "\uFFFD"
    if (e.lastNeed > 1 && t.length > 1) {
      if ((t[1] & 192) !== 128) return (e.lastNeed = 1), "\uFFFD"
      if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
        return (e.lastNeed = 2), "\uFFFD"
    }
  }
  function yat(e) {
    var t = this.lastTotal - this.lastNeed,
      r = Aat(this, e, t)
    if (r !== undefined) return r
    if (this.lastNeed <= e.length)
      return (
        e.copy(this.lastChar, t, 0, this.lastNeed),
        this.lastChar.toString(this.encoding, 0, this.lastTotal)
      )
    e.copy(this.lastChar, t, 0, e.length), (this.lastNeed -= e.length)
  }
  function vat(e, t) {
    var r = mat(this, e, t)
    if (!this.lastNeed) return e.toString("utf8", t)
    this.lastTotal = r
    var n = e.length - (r - this.lastNeed)
    return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n)
  }
  function Cat(e) {
    var t = e && e.length ? this.write(e) : ""
    return this.lastNeed ? t + "\uFFFD" : t
  }
  function bat(e, t) {
    if ((e.length - t) % 2 === 0) {
      var r = e.toString("utf16le", t)
      if (r) {
        var n = r.charCodeAt(r.length - 1)
        if (n >= 55296 && n <= 56319)
          return (
            (this.lastNeed = 2),
            (this.lastTotal = 4),
            (this.lastChar[0] = e[e.length - 2]),
            (this.lastChar[1] = e[e.length - 1]),
            r.slice(0, -1)
          )
      }
      return r
    }
    return (
      (this.lastNeed = 1),
      (this.lastTotal = 2),
      (this.lastChar[0] = e[e.length - 1]),
      e.toString("utf16le", t, e.length - 1)
    )
  }
  function Eat(e) {
    var t = e && e.length ? this.write(e) : ""
    if (this.lastNeed) {
      var r = this.lastTotal - this.lastNeed
      return t + this.lastChar.toString("utf16le", 0, r)
    }
    return t
  }
  function _at(e, t) {
    var r = (e.length - t) % 3
    return r === 0
      ? e.toString("base64", t)
      : ((this.lastNeed = 3 - r),
        (this.lastTotal = 3),
        r === 1
          ? (this.lastChar[0] = e[e.length - 1])
          : ((this.lastChar[0] = e[e.length - 2]),
            (this.lastChar[1] = e[e.length - 1])),
        e.toString("base64", t, e.length - r))
  }
  function xat(e) {
    var t = e && e.length ? this.write(e) : ""
    return this.lastNeed
      ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed)
      : t
  }
  function wat(e) {
    return e.toString(this.encoding)
  }
  function Sat(e) {
    return e && e.length ? this.write(e) : ""
  }
})
var sk = _((PFt, Spe) => {
  "use strict"
  var xpe = Vh().codes.ERR_STREAM_PREMATURE_CLOSE
  function Iat(e) {
    var t = false
    return function () {
      if (!t) {
        t = true
        for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++)
          n[i] = arguments[i]
        e.apply(this, n)
      }
    }
  }
  function Bat() {}
  function Rat(e) {
    return e.setHeader && typeof e.abort == "function"
  }
  function wpe(e, t, r) {
    if (typeof t == "function") return wpe(e, null, t)
    t || (t = {}), (r = Iat(r || Bat))
    var n = t.readable || (t.readable !== false && e.readable),
      i = t.writable || (t.writable !== false && e.writable),
      s = function () {
        e.writable || a()
      },
      o = e._writableState && e._writableState.finished,
      a = function () {
        ;(i = false), (o = true), n || r.call(e)
      },
      l = e._readableState && e._readableState.endEmitted,
      c = function () {
        ;(n = false), (l = true), i || r.call(e)
      },
      u = function (m) {
        r.call(e, m)
      },
      f = function () {
        var m
        if (n && !l)
          return (
            (!e._readableState || !e._readableState.ended) && (m = new xpe()),
            r.call(e, m)
          )
        if (i && !o)
          return (
            (!e._writableState || !e._writableState.ended) && (m = new xpe()),
            r.call(e, m)
          )
      },
      p = function () {
        e.req.on("finish", a)
      }
    return (
      Rat(e)
        ? (e.on("complete", a),
          e.on("abort", f),
          e.req ? p() : e.on("request", p))
        : i && !e._writableState && (e.on("end", s), e.on("close", s)),
      e.on("end", c),
      e.on("finish", a),
      t.error !== false && e.on("error", u),
      e.on("close", f),
      function () {
        e.removeListener("complete", a),
          e.removeListener("abort", f),
          e.removeListener("request", p),
          e.req && e.req.removeListener("finish", a),
          e.removeListener("end", s),
          e.removeListener("close", s),
          e.removeListener("finish", a),
          e.removeListener("end", c),
          e.removeListener("error", u),
          e.removeListener("close", f)
      }
    )
  }
  Spe.exports = wpe
})
var Bpe = _((LFt, Ipe) => {
  "use strict"
  var ok
  function Hh(e, t, r) {
    return (
      (t = Dat(t)),
      t in e
        ? Object.defineProperty(e, t, {
            value: r,
            enumerable: true,
            configurable: true,
            writable: true,
          })
        : (e[t] = r),
      e
    )
  }
  function Dat(e) {
    var t = Tat(e, "string")
    return typeof t == "symbol" ? t : String(t)
  }
  function Tat(e, t) {
    if (typeof e != "object" || e === null) return e
    var r = e[Symbol.toPrimitive]
    if (r !== undefined) {
      var n = r.call(e, t || "default")
      if (typeof n != "object") return n
      throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
  }
  var kat = sk(),
    Wh = Symbol("lastResolve"),
    sm = Symbol("lastReject"),
    k_ = Symbol("error"),
    ak = Symbol("ended"),
    om = Symbol("lastPromise"),
    m3 = Symbol("handlePromise"),
    am = Symbol("stream")
  function Gh(e, t) {
    return { value: e, done: t }
  }
  function Mat(e) {
    var t = e[Wh]
    if (t !== null) {
      var r = e[am].read()
      r !== null &&
        ((e[om] = null), (e[Wh] = null), (e[sm] = null), t(Gh(r, false)))
    }
  }
  function Fat(e) {
    process.nextTick(Mat, e)
  }
  function Qat(e, t) {
    return function (r, n) {
      e.then(function () {
        if (t[ak]) {
          r(Gh(undefined, true))
          return
        }
        t[m3](r, n)
      }, n)
    }
  }
  var Nat = Object.getPrototypeOf(function () {}),
    Pat = Object.setPrototypeOf(
      ((ok = {
        get stream() {
          return this[am]
        },
        next: function () {
          var t = this,
            r = this[k_]
          if (r !== null) return Promise.reject(r)
          if (this[ak]) return Promise.resolve(Gh(undefined, true))
          if (this[am].destroyed)
            return new Promise(function (o, a) {
              process.nextTick(function () {
                t[k_] ? a(t[k_]) : o(Gh(undefined, true))
              })
            })
          var n = this[om],
            i
          if (n) i = new Promise(Qat(n, this))
          else {
            var s = this[am].read()
            if (s !== null) return Promise.resolve(Gh(s, false))
            i = new Promise(this[m3])
          }
          return (this[om] = i), i
        },
      }),
      Hh(ok, Symbol.asyncIterator, function () {
        return this
      }),
      Hh(ok, "return", function () {
        var t = this
        return new Promise(function (r, n) {
          t[am].destroy(null, function (i) {
            if (i) {
              n(i)
              return
            }
            r(Gh(undefined, true))
          })
        })
      }),
      ok),
      Nat,
    ),
    Lat = function (t) {
      var r,
        n = Object.create(
          Pat,
          ((r = {}),
          Hh(r, am, { value: t, writable: true }),
          Hh(r, Wh, { value: null, writable: true }),
          Hh(r, sm, { value: null, writable: true }),
          Hh(r, k_, { value: null, writable: true }),
          Hh(r, ak, { value: t._readableState.endEmitted, writable: true }),
          Hh(r, m3, {
            value: function (s, o) {
              var a = n[am].read()
              a
                ? ((n[om] = null), (n[Wh] = null), (n[sm] = null), s(Gh(a, false)))
                : ((n[Wh] = s), (n[sm] = o))
            },
            writable: true,
          }),
          r),
        )
      return (
        (n[om] = null),
        kat(t, function (i) {
          if (i && i.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var s = n[sm]
            s !== null &&
              ((n[om] = null), (n[Wh] = null), (n[sm] = null), s(i)),
              (n[k_] = i)
            return
          }
          var o = n[Wh]
          o !== null &&
            ((n[om] = null), (n[Wh] = null), (n[sm] = null), o(Gh(undefined, true))),
            (n[ak] = true)
        }),
        t.on("readable", Fat.bind(null, n)),
        n
      )
    }
  Ipe.exports = Lat
})
var kpe = _((UFt, Tpe) => {
  "use strict"
  function Rpe(e, t, r, n, i, s, o) {
    try {
      var a = e[s](o),
        l = a.value
    } catch (c) {
      r(c)
      return
    }
    a.done ? t(l) : Promise.resolve(l).then(n, i)
  }
  function Uat(e) {
    return function () {
      var t = this,
        r = arguments
      return new Promise(function (n, i) {
        var s = e.apply(t, r)
        function o(l) {
          Rpe(s, n, i, o, a, "next", l)
        }
        function a(l) {
          Rpe(s, n, i, o, a, "throw", l)
        }
        o(undefined)
      })
    }
  }
  function Dpe(e, t) {
    var r = Object.keys(e)
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e)
      t &&
        (n = n.filter(function (i) {
          return Object.getOwnPropertyDescriptor(e, i).enumerable
        })),
        r.push.apply(r, n)
    }
    return r
  }
  function Oat(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {}
      t % 2
        ? Dpe(Object(r), true).forEach(function (n) {
            qat(e, n, r[n])
          })
        : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
          : Dpe(Object(r)).forEach(function (n) {
              Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n))
            })
    }
    return e
  }
  function qat(e, t, r) {
    return (
      (t = Vat(t)),
      t in e
        ? Object.defineProperty(e, t, {
            value: r,
            enumerable: true,
            configurable: true,
            writable: true,
          })
        : (e[t] = r),
      e
    )
  }
  function Vat(e) {
    var t = Hat(e, "string")
    return typeof t == "symbol" ? t : String(t)
  }
  function Hat(e, t) {
    if (typeof e != "object" || e === null) return e
    var r = e[Symbol.toPrimitive]
    if (r !== undefined) {
      var n = r.call(e, t || "default")
      if (typeof n != "object") return n
      throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
  }
  var Wat = Vh().codes.ERR_INVALID_ARG_TYPE
  function Gat(e, t, r) {
    var n
    if (t && typeof t.next == "function") n = t
    else if (t && t[Symbol.asyncIterator]) n = t[Symbol.asyncIterator]()
    else if (t && t[Symbol.iterator]) n = t[Symbol.iterator]()
    else throw new Wat("iterable", ["Iterable"], t)
    var i = new e(Oat({ objectMode: true }, r)),
      s = false
    i._read = function () {
      s || ((s = true), o())
    }
    function o() {
      return a.apply(this, arguments)
    }
    function a() {
      return (
        (a = Uat(function* () {
          try {
            var l = yield n.next(),
              c = l.value,
              u = l.done
            u ? i.push(null) : i.push(yield c) ? o() : (s = false)
          } catch (f) {
            i.destroy(f)
          }
        })),
        a.apply(this, arguments)
      )
    }
    return i
  }
  Tpe.exports = Gat
})
var S3 = _((qFt, Vpe) => {
  "use strict"
  Vpe.exports = Ur
  var Py
  Ur.ReadableState = Npe
  var OFt = require("events").EventEmitter,
    Qpe = function (t, r) {
      return t.listeners(r).length
    },
    F_ = i3(),
    lk = require("buffer").Buffer,
    $at =
      (typeof global < "u"
        ? global
        : typeof window < "u"
          ? window
          : typeof self < "u"
            ? self
            : {}
      ).Uint8Array || function () {}
  function Yat(e) {
    return lk.from(e)
  }
  function Kat(e) {
    return lk.isBuffer(e) || e instanceof $at
  }
  var A3 = require("util"),
    sr
  A3 && A3.debuglog ? (sr = A3.debuglog("stream")) : (sr = function () {})
  var zat = ype(),
    x3 = o3(),
    Jat = a3(),
    jat = Jat.getHighWaterMark,
    ck = Vh().codes,
    Zat = ck.ERR_INVALID_ARG_TYPE,
    Xat = ck.ERR_STREAM_PUSH_AFTER_EOF,
    elt = ck.ERR_METHOD_NOT_IMPLEMENTED,
    tlt = ck.ERR_STREAM_UNSHIFT_AFTER_END_EVENT,
    Ly,
    y3,
    v3
  Ny()(Ur, F_)
  var M_ = x3.errorOrDestroy,
    C3 = ["error", "close", "destroy", "pause", "resume"]
  function rlt(e, t, r) {
    if (typeof e.prependListener == "function") return e.prependListener(t, r)
    !e._events || !e._events[t]
      ? e.on(t, r)
      : Array.isArray(e._events[t])
        ? e._events[t].unshift(r)
        : (e._events[t] = [r, e._events[t]])
  }
  function Npe(e, t, r) {
    ;(Py = Py || lm()),
      (e = e || {}),
      typeof r != "boolean" && (r = t instanceof Py),
      (this.objectMode = !!e.objectMode),
      r && (this.objectMode = this.objectMode || !!e.readableObjectMode),
      (this.highWaterMark = jat(this, e, "readableHighWaterMark", r)),
      (this.buffer = new zat()),
      (this.length = 0),
      (this.pipes = null),
      (this.pipesCount = 0),
      (this.flowing = null),
      (this.ended = false),
      (this.endEmitted = false),
      (this.reading = false),
      (this.sync = true),
      (this.needReadable = false),
      (this.emittedReadable = false),
      (this.readableListening = false),
      (this.resumeScheduled = false),
      (this.paused = true),
      (this.emitClose = e.emitClose !== false),
      (this.autoDestroy = !!e.autoDestroy),
      (this.destroyed = false),
      (this.defaultEncoding = e.defaultEncoding || "utf8"),
      (this.awaitDrain = 0),
      (this.readingMore = false),
      (this.decoder = null),
      (this.encoding = null),
      e.encoding &&
        (Ly || (Ly = p3().StringDecoder),
        (this.decoder = new Ly(e.encoding)),
        (this.encoding = e.encoding))
  }
  function Ur(e) {
    if (((Py = Py || lm()), !(this instanceof Ur))) return new Ur(e)
    var t = this instanceof Py
    ;(this._readableState = new Npe(e, this, t)),
      (this.readable = true),
      e &&
        (typeof e.read == "function" && (this._read = e.read),
        typeof e.destroy == "function" && (this._destroy = e.destroy)),
      F_.call(this)
  }
  Object.defineProperty(Ur.prototype, "destroyed", {
    enumerable: false,
    get: function () {
      return this._readableState === undefined ? false : this._readableState.destroyed
    },
    set: function (t) {
      this._readableState && (this._readableState.destroyed = t)
    },
  })
  Ur.prototype.destroy = x3.destroy
  Ur.prototype._undestroy = x3.undestroy
  Ur.prototype._destroy = function (e, t) {
    t(e)
  }
  Ur.prototype.push = function (e, t) {
    var r = this._readableState,
      n
    return (
      r.objectMode
        ? (n = true)
        : typeof e == "string" &&
          ((t = t || r.defaultEncoding),
          t !== r.encoding && ((e = lk.from(e, t)), (t = "")),
          (n = true)),
      Ppe(this, e, t, false, n)
    )
  }
  Ur.prototype.unshift = function (e) {
    return Ppe(this, e, null, true, false)
  }
  function Ppe(e, t, r, n, i) {
    sr("readableAddChunk", t)
    var s = e._readableState
    if (t === null) (s.reading = false), slt(e, s)
    else {
      var o
      if ((i || (o = nlt(s, t)), o)) M_(e, o)
      else if (s.objectMode || (t && t.length > 0))
        if (
          (typeof t != "string" &&
            !s.objectMode &&
            Object.getPrototypeOf(t) !== lk.prototype &&
            (t = Yat(t)),
          n)
        )
          s.endEmitted ? M_(e, new tlt()) : b3(e, s, t, true)
        else if (s.ended) M_(e, new Xat())
        else {
          if (s.destroyed) return false
          ;(s.reading = false),
            s.decoder && !r
              ? ((t = s.decoder.write(t)),
                s.objectMode || t.length !== 0 ? b3(e, s, t, false) : _3(e, s))
              : b3(e, s, t, false)
        }
      else n || ((s.reading = false), _3(e, s))
    }
    return !s.ended && (s.length < s.highWaterMark || s.length === 0)
  }
  function b3(e, t, r, n) {
    t.flowing && t.length === 0 && !t.sync
      ? ((t.awaitDrain = 0), e.emit("data", r))
      : ((t.length += t.objectMode ? 1 : r.length),
        n ? t.buffer.unshift(r) : t.buffer.push(r),
        t.needReadable && uk(e)),
      _3(e, t)
  }
  function nlt(e, t) {
    var r
    return (
      !Kat(t) &&
        typeof t != "string" &&
        t !== undefined &&
        !e.objectMode &&
        (r = new Zat("chunk", ["string", "Buffer", "Uint8Array"], t)),
      r
    )
  }
  Ur.prototype.isPaused = function () {
    return this._readableState.flowing === false
  }
  Ur.prototype.setEncoding = function (e) {
    Ly || (Ly = p3().StringDecoder)
    var t = new Ly(e)
    ;(this._readableState.decoder = t),
      (this._readableState.encoding = this._readableState.decoder.encoding)
    for (var r = this._readableState.buffer.head, n = ""; r !== null; )
      (n += t.write(r.data)), (r = r.next)
    return (
      this._readableState.buffer.clear(),
      n !== "" && this._readableState.buffer.push(n),
      (this._readableState.length = n.length),
      this
    )
  }
  var Mpe = 1073741824
  function ilt(e) {
    return (
      e >= Mpe
        ? (e = Mpe)
        : (e--,
          (e |= e >>> 1),
          (e |= e >>> 2),
          (e |= e >>> 4),
          (e |= e >>> 8),
          (e |= e >>> 16),
          e++),
      e
    )
  }
  function Fpe(e, t) {
    return e <= 0 || (t.length === 0 && t.ended)
      ? 0
      : t.objectMode
        ? 1
        : e !== e
          ? t.flowing && t.length
            ? t.buffer.head.data.length
            : t.length
          : (e > t.highWaterMark && (t.highWaterMark = ilt(e)),
            e <= t.length ? e : t.ended ? t.length : ((t.needReadable = true), 0))
  }
  Ur.prototype.read = function (e) {
    sr("read", e), (e = parseInt(e, 10))
    var t = this._readableState,
      r = e
    if (
      (e !== 0 && (t.emittedReadable = false),
      e === 0 &&
        t.needReadable &&
        ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) ||
          t.ended))
    )
      return (
        sr("read: emitReadable", t.length, t.ended),
        t.length === 0 && t.ended ? E3(this) : uk(this),
        null
      )
    if (((e = Fpe(e, t)), e === 0 && t.ended))
      return t.length === 0 && E3(this), null
    var n = t.needReadable
    sr("need readable", n),
      (t.length === 0 || t.length - e < t.highWaterMark) &&
        ((n = true), sr("length less than watermark", n)),
      t.ended || t.reading
        ? ((n = false), sr("reading or ended", n))
        : n &&
          (sr("do read"),
          (t.reading = true),
          (t.sync = true),
          t.length === 0 && (t.needReadable = true),
          this._read(t.highWaterMark),
          (t.sync = false),
          t.reading || (e = Fpe(r, t)))
    var i
    return (
      e > 0 ? (i = Ope(e, t)) : (i = null),
      i === null
        ? ((t.needReadable = t.length <= t.highWaterMark), (e = 0))
        : ((t.length -= e), (t.awaitDrain = 0)),
      t.length === 0 &&
        (t.ended || (t.needReadable = true), r !== e && t.ended && E3(this)),
      i !== null && this.emit("data", i),
      i
    )
  }
  function slt(e, t) {
    if ((sr("onEofChunk"), !t.ended)) {
      if (t.decoder) {
        var r = t.decoder.end()
        r &&
          r.length &&
          (t.buffer.push(r), (t.length += t.objectMode ? 1 : r.length))
      }
      ;(t.ended = true),
        t.sync
          ? uk(e)
          : ((t.needReadable = false),
            t.emittedReadable || ((t.emittedReadable = true), Lpe(e)))
    }
  }
  function uk(e) {
    var t = e._readableState
    sr("emitReadable", t.needReadable, t.emittedReadable),
      (t.needReadable = false),
      t.emittedReadable ||
        (sr("emitReadable", t.flowing),
        (t.emittedReadable = true),
        process.nextTick(Lpe, e))
  }
  function Lpe(e) {
    var t = e._readableState
    sr("emitReadable_", t.destroyed, t.length, t.ended),
      !t.destroyed &&
        (t.length || t.ended) &&
        (e.emit("readable"), (t.emittedReadable = false)),
      (t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark),
      w3(e)
  }
  function _3(e, t) {
    t.readingMore || ((t.readingMore = true), process.nextTick(olt, e, t))
  }
  function olt(e, t) {
    for (
      ;
      !t.reading &&
      !t.ended &&
      (t.length < t.highWaterMark || (t.flowing && t.length === 0));

    ) {
      var r = t.length
      if ((sr("maybeReadMore read 0"), e.read(0), r === t.length)) break
    }
    t.readingMore = false
  }
  Ur.prototype._read = function (e) {
    M_(this, new elt("_read()"))
  }
  Ur.prototype.pipe = function (e, t) {
    var r = this,
      n = this._readableState
    switch (n.pipesCount) {
      case 0:
        n.pipes = e
        break
      case 1:
        n.pipes = [n.pipes, e]
        break
      default:
        n.pipes.push(e)
        break
    }
    ;(n.pipesCount += 1), sr("pipe count=%d opts=%j", n.pipesCount, t)
    var i =
        (!t || t.end !== false) && e !== process.stdout && e !== process.stderr,
      s = i ? a : y
    n.endEmitted ? process.nextTick(s) : r.once("end", s), e.on("unpipe", o)
    function o(v, C) {
      sr("onunpipe"),
        v === r && C && C.hasUnpiped === false && ((C.hasUnpiped = true), u())
    }
    function a() {
      sr("onend"), e.end()
    }
    var l = alt(r)
    e.on("drain", l)
    var c = false
    function u() {
      sr("cleanup"),
        e.removeListener("close", g),
        e.removeListener("finish", m),
        e.removeListener("drain", l),
        e.removeListener("error", p),
        e.removeListener("unpipe", o),
        r.removeListener("end", a),
        r.removeListener("end", y),
        r.removeListener("data", f),
        (c = true),
        n.awaitDrain && (!e._writableState || e._writableState.needDrain) && l()
    }
    r.on("data", f)
    function f(v) {
      sr("ondata")
      var C = e.write(v)
      sr("dest.write", C),
        C === false &&
          (((n.pipesCount === 1 && n.pipes === e) ||
            (n.pipesCount > 1 && qpe(n.pipes, e) !== -1)) &&
            !c &&
            (sr("false write response, pause", n.awaitDrain), n.awaitDrain++),
          r.pause())
    }
    function p(v) {
      sr("onerror", v),
        y(),
        e.removeListener("error", p),
        Qpe(e, "error") === 0 && M_(e, v)
    }
    rlt(e, "error", p)
    function g() {
      e.removeListener("finish", m), y()
    }
    e.once("close", g)
    function m() {
      sr("onfinish"), e.removeListener("close", g), y()
    }
    e.once("finish", m)
    function y() {
      sr("unpipe"), r.unpipe(e)
    }
    return e.emit("pipe", r), n.flowing || (sr("pipe resume"), r.resume()), e
  }
  function alt(e) {
    return function () {
      var r = e._readableState
      sr("pipeOnDrain", r.awaitDrain),
        r.awaitDrain && r.awaitDrain--,
        r.awaitDrain === 0 && Qpe(e, "data") && ((r.flowing = true), w3(e))
    }
  }
  Ur.prototype.unpipe = function (e) {
    var t = this._readableState,
      r = { hasUnpiped: false }
    if (t.pipesCount === 0) return this
    if (t.pipesCount === 1)
      return e && e !== t.pipes
        ? this
        : (e || (e = t.pipes),
          (t.pipes = null),
          (t.pipesCount = 0),
          (t.flowing = false),
          e && e.emit("unpipe", this, r),
          this)
    if (!e) {
      var n = t.pipes,
        i = t.pipesCount
      ;(t.pipes = null), (t.pipesCount = 0), (t.flowing = false)
      for (var s = 0; s < i; s++) n[s].emit("unpipe", this, { hasUnpiped: false })
      return this
    }
    var o = qpe(t.pipes, e)
    return o === -1
      ? this
      : (t.pipes.splice(o, 1),
        (t.pipesCount -= 1),
        t.pipesCount === 1 && (t.pipes = t.pipes[0]),
        e.emit("unpipe", this, r),
        this)
  }
  Ur.prototype.on = function (e, t) {
    var r = F_.prototype.on.call(this, e, t),
      n = this._readableState
    return (
      e === "data"
        ? ((n.readableListening = this.listenerCount("readable") > 0),
          n.flowing !== false && this.resume())
        : e === "readable" &&
          !n.endEmitted &&
          !n.readableListening &&
          ((n.readableListening = n.needReadable = true),
          (n.flowing = false),
          (n.emittedReadable = false),
          sr("on readable", n.length, n.reading),
          n.length ? uk(this) : n.reading || process.nextTick(llt, this)),
      r
    )
  }
  Ur.prototype.addListener = Ur.prototype.on
  Ur.prototype.removeListener = function (e, t) {
    var r = F_.prototype.removeListener.call(this, e, t)
    return e === "readable" && process.nextTick(Upe, this), r
  }
  Ur.prototype.removeAllListeners = function (e) {
    var t = F_.prototype.removeAllListeners.apply(this, arguments)
    return (e === "readable" || e === undefined) && process.nextTick(Upe, this), t
  }
  function Upe(e) {
    var t = e._readableState
    ;(t.readableListening = e.listenerCount("readable") > 0),
      t.resumeScheduled && !t.paused
        ? (t.flowing = true)
        : e.listenerCount("data") > 0 && e.resume()
  }
  function llt(e) {
    sr("readable nexttick read 0"), e.read(0)
  }
  Ur.prototype.resume = function () {
    var e = this._readableState
    return (
      e.flowing ||
        (sr("resume"), (e.flowing = !e.readableListening), clt(this, e)),
      (e.paused = false),
      this
    )
  }
  function clt(e, t) {
    t.resumeScheduled || ((t.resumeScheduled = true), process.nextTick(ult, e, t))
  }
  function ult(e, t) {
    sr("resume", t.reading),
      t.reading || e.read(0),
      (t.resumeScheduled = false),
      e.emit("resume"),
      w3(e),
      t.flowing && !t.reading && e.read(0)
  }
  Ur.prototype.pause = function () {
    return (
      sr("call pause flowing=%j", this._readableState.flowing),
      this._readableState.flowing !== false &&
        (sr("pause"), (this._readableState.flowing = false), this.emit("pause")),
      (this._readableState.paused = true),
      this
    )
  }
  function w3(e) {
    var t = e._readableState
    for (sr("flow", t.flowing); t.flowing && e.read() !== null; );
  }
  Ur.prototype.wrap = function (e) {
    var t = this,
      r = this._readableState,
      n = false
    e.on("end", function () {
      if ((sr("wrapped end"), r.decoder && !r.ended)) {
        var o = r.decoder.end()
        o && o.length && t.push(o)
      }
      t.push(null)
    }),
      e.on("data", function (o) {
        if (
          (sr("wrapped data"),
          r.decoder && (o = r.decoder.write(o)),
          !(r.objectMode && o == null) && !(!r.objectMode && (!o || !o.length)))
        ) {
          var a = t.push(o)
          a || ((n = true), e.pause())
        }
      })
    for (var i in e)
      this[i] === undefined &&
        typeof e[i] == "function" &&
        (this[i] = (function (a) {
          return function () {
            return e[a].apply(e, arguments)
          }
        })(i))
    for (var s = 0; s < C3.length; s++) e.on(C3[s], this.emit.bind(this, C3[s]))
    return (
      (this._read = function (o) {
        sr("wrapped _read", o), n && ((n = false), e.resume())
      }),
      this
    )
  }
  typeof Symbol == "function" &&
    (Ur.prototype[Symbol.asyncIterator] = function () {
      return y3 === undefined && (y3 = Bpe()), y3(this)
    })
  Object.defineProperty(Ur.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function () {
      return this._readableState.highWaterMark
    },
  })
  Object.defineProperty(Ur.prototype, "readableBuffer", {
    enumerable: false,
    get: function () {
      return this._readableState && this._readableState.buffer
    },
  })
  Object.defineProperty(Ur.prototype, "readableFlowing", {
    enumerable: false,
    get: function () {
      return this._readableState.flowing
    },
    set: function (t) {
      this._readableState && (this._readableState.flowing = t)
    },
  })
  Ur._fromList = Ope
  Object.defineProperty(Ur.prototype, "readableLength", {
    enumerable: false,
    get: function () {
      return this._readableState.length
    },
  })
  function Ope(e, t) {
    if (t.length === 0) return null
    var r
    return (
      t.objectMode
        ? (r = t.buffer.shift())
        : !e || e >= t.length
          ? (t.decoder
              ? (r = t.buffer.join(""))
              : t.buffer.length === 1
                ? (r = t.buffer.first())
                : (r = t.buffer.concat(t.length)),
            t.buffer.clear())
          : (r = t.buffer.consume(e, t.decoder)),
      r
    )
  }
  function E3(e) {
    var t = e._readableState
    sr("endReadable", t.endEmitted),
      t.endEmitted || ((t.ended = true), process.nextTick(dlt, t, e))
  }
  function dlt(e, t) {
    if (
      (sr("endReadableNT", e.endEmitted, e.length),
      !e.endEmitted &&
        e.length === 0 &&
        ((e.endEmitted = true), (t.readable = false), t.emit("end"), e.autoDestroy))
    ) {
      var r = t._writableState
      ;(!r || (r.autoDestroy && r.finished)) && t.destroy()
    }
  }
  typeof Symbol == "function" &&
    (Ur.from = function (e, t) {
      return v3 === undefined && (v3 = kpe()), v3(Ur, e, t)
    })
  function qpe(e, t) {
    for (var r = 0, n = e.length; r < n; r++) if (e[r] === t) return r
    return -1
  }
})
var lm = _((VFt, Wpe) => {
  "use strict"
  var flt =
    Object.keys ||
    function (e) {
      var t = []
      for (var r in e) t.push(r)
      return t
    }
  Wpe.exports = Vu
  var Hpe = S3(),
    B3 = hk()
  Ny()(Vu, Hpe)
  for (I3 = flt(B3.prototype), dk = 0; dk < I3.length; dk++)
    (fk = I3[dk]), Vu.prototype[fk] || (Vu.prototype[fk] = B3.prototype[fk])
  var I3, fk, dk
  function Vu(e) {
    if (!(this instanceof Vu)) return new Vu(e)
    Hpe.call(this, e),
      B3.call(this, e),
      (this.allowHalfOpen = true),
      e &&
        (e.readable === false && (this.readable = false),
        e.writable === false && (this.writable = false),
        e.allowHalfOpen === false &&
          ((this.allowHalfOpen = false), this.once("end", hlt)))
  }
  Object.defineProperty(Vu.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function () {
      return this._writableState.highWaterMark
    },
  })
  Object.defineProperty(Vu.prototype, "writableBuffer", {
    enumerable: false,
    get: function () {
      return this._writableState && this._writableState.getBuffer()
    },
  })
  Object.defineProperty(Vu.prototype, "writableLength", {
    enumerable: false,
    get: function () {
      return this._writableState.length
    },
  })
  function hlt() {
    this._writableState.ended || process.nextTick(glt, this)
  }
  function glt(e) {
    e.end()
  }
  Object.defineProperty(Vu.prototype, "destroyed", {
    enumerable: false,
    get: function () {
      return this._readableState === undefined || this._writableState === undefined
        ? false
        : this._readableState.destroyed && this._writableState.destroyed
    },
    set: function (t) {
      this._readableState === undefined ||
        this._writableState === undefined ||
        ((this._readableState.destroyed = t),
        (this._writableState.destroyed = t))
    },
  })
})
var hk = _((HFt, Jpe) => {
  "use strict"
  Jpe.exports = fi
  function $pe(e) {
    var t = this
    ;(this.next = null),
      (this.entry = null),
      (this.finish = function () {
        qlt(t, e)
      })
  }
  var Uy
  fi.WritableState = N_
  var plt = { deprecate: ipe() },
    Ype = i3(),
    pk = require("buffer").Buffer,
    mlt =
      (typeof global < "u"
        ? global
        : typeof window < "u"
          ? window
          : typeof self < "u"
            ? self
            : {}
      ).Uint8Array || function () {}
  function Alt(e) {
    return pk.from(e)
  }
  function ylt(e) {
    return pk.isBuffer(e) || e instanceof mlt
  }
  var D3 = o3(),
    vlt = a3(),
    Clt = vlt.getHighWaterMark,
    $h = Vh().codes,
    blt = $h.ERR_INVALID_ARG_TYPE,
    Elt = $h.ERR_METHOD_NOT_IMPLEMENTED,
    _lt = $h.ERR_MULTIPLE_CALLBACK,
    xlt = $h.ERR_STREAM_CANNOT_PIPE,
    wlt = $h.ERR_STREAM_DESTROYED,
    Slt = $h.ERR_STREAM_NULL_VALUES,
    Ilt = $h.ERR_STREAM_WRITE_AFTER_END,
    Blt = $h.ERR_UNKNOWN_ENCODING,
    Oy = D3.errorOrDestroy
  Ny()(fi, Ype)
  function Rlt() {}
  function N_(e, t, r) {
    ;(Uy = Uy || lm()),
      (e = e || {}),
      typeof r != "boolean" && (r = t instanceof Uy),
      (this.objectMode = !!e.objectMode),
      r && (this.objectMode = this.objectMode || !!e.writableObjectMode),
      (this.highWaterMark = Clt(this, e, "writableHighWaterMark", r)),
      (this.finalCalled = false),
      (this.needDrain = false),
      (this.ending = false),
      (this.ended = false),
      (this.finished = false),
      (this.destroyed = false)
    var n = e.decodeStrings === false
    ;(this.decodeStrings = !n),
      (this.defaultEncoding = e.defaultEncoding || "utf8"),
      (this.length = 0),
      (this.writing = false),
      (this.corked = 0),
      (this.sync = true),
      (this.bufferProcessing = false),
      (this.onwrite = function (i) {
        Nlt(t, i)
      }),
      (this.writecb = null),
      (this.writelen = 0),
      (this.bufferedRequest = null),
      (this.lastBufferedRequest = null),
      (this.pendingcb = 0),
      (this.prefinished = false),
      (this.errorEmitted = false),
      (this.emitClose = e.emitClose !== false),
      (this.autoDestroy = !!e.autoDestroy),
      (this.bufferedRequestCount = 0),
      (this.corkedRequestsFree = new $pe(this))
  }
  N_.prototype.getBuffer = function () {
    for (var t = this.bufferedRequest, r = []; t; ) r.push(t), (t = t.next)
    return r
  }
  ;(function () {
    try {
      Object.defineProperty(N_.prototype, "buffer", {
        get: plt.deprecate(
          function () {
            return this.getBuffer()
          },
          "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.",
          "DEP0003",
        ),
      })
    } catch {}
  })()
  var gk
  typeof Symbol == "function" &&
  Symbol.hasInstance &&
  typeof Function.prototype[Symbol.hasInstance] == "function"
    ? ((gk = Function.prototype[Symbol.hasInstance]),
      Object.defineProperty(fi, Symbol.hasInstance, {
        value: function (t) {
          return gk.call(this, t)
            ? true
            : this !== fi
              ? false
              : t && t._writableState instanceof N_
        },
      }))
    : (gk = function (t) {
        return t instanceof this
      })
  function fi(e) {
    Uy = Uy || lm()
    var t = this instanceof Uy
    if (!t && !gk.call(fi, this)) return new fi(e)
    ;(this._writableState = new N_(e, this, t)),
      (this.writable = true),
      e &&
        (typeof e.write == "function" && (this._write = e.write),
        typeof e.writev == "function" && (this._writev = e.writev),
        typeof e.destroy == "function" && (this._destroy = e.destroy),
        typeof e.final == "function" && (this._final = e.final)),
      Ype.call(this)
  }
  fi.prototype.pipe = function () {
    Oy(this, new xlt())
  }
  function Dlt(e, t) {
    var r = new Ilt()
    Oy(e, r), process.nextTick(t, r)
  }
  function Tlt(e, t, r, n) {
    var i
    return (
      r === null
        ? (i = new Slt())
        : typeof r != "string" &&
          !t.objectMode &&
          (i = new blt("chunk", ["string", "Buffer"], r)),
      i ? (Oy(e, i), process.nextTick(n, i), false) : true
    )
  }
  fi.prototype.write = function (e, t, r) {
    var n = this._writableState,
      i = false,
      s = !n.objectMode && ylt(e)
    return (
      s && !pk.isBuffer(e) && (e = Alt(e)),
      typeof t == "function" && ((r = t), (t = null)),
      s ? (t = "buffer") : t || (t = n.defaultEncoding),
      typeof r != "function" && (r = Rlt),
      n.ending
        ? Dlt(this, r)
        : (s || Tlt(this, n, e, r)) &&
          (n.pendingcb++, (i = Mlt(this, n, s, e, t, r))),
      i
    )
  }
  fi.prototype.cork = function () {
    this._writableState.corked++
  }
  fi.prototype.uncork = function () {
    var e = this._writableState
    e.corked &&
      (e.corked--,
      !e.writing &&
        !e.corked &&
        !e.bufferProcessing &&
        e.bufferedRequest &&
        Kpe(this, e))
  }
  fi.prototype.setDefaultEncoding = function (t) {
    if (
      (typeof t == "string" && (t = t.toLowerCase()),
      !(
        [
          "hex",
          "utf8",
          "utf-8",
          "ascii",
          "binary",
          "base64",
          "ucs2",
          "ucs-2",
          "utf16le",
          "utf-16le",
          "raw",
        ].indexOf((t + "").toLowerCase()) > -1
      ))
    )
      throw new Blt(t)
    return (this._writableState.defaultEncoding = t), this
  }
  Object.defineProperty(fi.prototype, "writableBuffer", {
    enumerable: false,
    get: function () {
      return this._writableState && this._writableState.getBuffer()
    },
  })
  function klt(e, t, r) {
    return (
      !e.objectMode &&
        e.decodeStrings !== false &&
        typeof t == "string" &&
        (t = pk.from(t, r)),
      t
    )
  }
  Object.defineProperty(fi.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function () {
      return this._writableState.highWaterMark
    },
  })
  function Mlt(e, t, r, n, i, s) {
    if (!r) {
      var o = klt(t, n, i)
      n !== o && ((r = true), (i = "buffer"), (n = o))
    }
    var a = t.objectMode ? 1 : n.length
    t.length += a
    var l = t.length < t.highWaterMark
    if ((l || (t.needDrain = true), t.writing || t.corked)) {
      var c = t.lastBufferedRequest
      ;(t.lastBufferedRequest = {
        chunk: n,
        encoding: i,
        isBuf: r,
        callback: s,
        next: null,
      }),
        c
          ? (c.next = t.lastBufferedRequest)
          : (t.bufferedRequest = t.lastBufferedRequest),
        (t.bufferedRequestCount += 1)
    } else R3(e, t, false, a, n, i, s)
    return l
  }
  function R3(e, t, r, n, i, s, o) {
    ;(t.writelen = n),
      (t.writecb = o),
      (t.writing = true),
      (t.sync = true),
      t.destroyed
        ? t.onwrite(new wlt("write"))
        : r
          ? e._writev(i, t.onwrite)
          : e._write(i, s, t.onwrite),
      (t.sync = false)
  }
  function Flt(e, t, r, n, i) {
    --t.pendingcb,
      r
        ? (process.nextTick(i, n),
          process.nextTick(Q_, e, t),
          (e._writableState.errorEmitted = true),
          Oy(e, n))
        : (i(n), (e._writableState.errorEmitted = true), Oy(e, n), Q_(e, t))
  }
  function Qlt(e) {
    ;(e.writing = false),
      (e.writecb = null),
      (e.length -= e.writelen),
      (e.writelen = 0)
  }
  function Nlt(e, t) {
    var r = e._writableState,
      n = r.sync,
      i = r.writecb
    if (typeof i != "function") throw new _lt()
    if ((Qlt(r), t)) Flt(e, r, n, t, i)
    else {
      var s = zpe(r) || e.destroyed
      !s && !r.corked && !r.bufferProcessing && r.bufferedRequest && Kpe(e, r),
        n ? process.nextTick(Gpe, e, r, s, i) : Gpe(e, r, s, i)
    }
  }
  function Gpe(e, t, r, n) {
    r || Plt(e, t), t.pendingcb--, n(), Q_(e, t)
  }
  function Plt(e, t) {
    t.length === 0 && t.needDrain && ((t.needDrain = false), e.emit("drain"))
  }
  function Kpe(e, t) {
    t.bufferProcessing = true
    var r = t.bufferedRequest
    if (e._writev && r && r.next) {
      var n = t.bufferedRequestCount,
        i = new Array(n),
        s = t.corkedRequestsFree
      s.entry = r
      for (var o = 0, a = true; r; )
        (i[o] = r), r.isBuf || (a = false), (r = r.next), (o += 1)
      ;(i.allBuffers = a),
        R3(e, t, true, t.length, i, "", s.finish),
        t.pendingcb++,
        (t.lastBufferedRequest = null),
        s.next
          ? ((t.corkedRequestsFree = s.next), (s.next = null))
          : (t.corkedRequestsFree = new $pe(t)),
        (t.bufferedRequestCount = 0)
    } else {
      for (; r; ) {
        var l = r.chunk,
          c = r.encoding,
          u = r.callback,
          f = t.objectMode ? 1 : l.length
        if (
          (R3(e, t, false, f, l, c, u),
          (r = r.next),
          t.bufferedRequestCount--,
          t.writing)
        )
          break
      }
      r === null && (t.lastBufferedRequest = null)
    }
    ;(t.bufferedRequest = r), (t.bufferProcessing = false)
  }
  fi.prototype._write = function (e, t, r) {
    r(new Elt("_write()"))
  }
  fi.prototype._writev = null
  fi.prototype.end = function (e, t, r) {
    var n = this._writableState
    return (
      typeof e == "function"
        ? ((r = e), (e = null), (t = null))
        : typeof t == "function" && ((r = t), (t = null)),
      e != null && this.write(e, t),
      n.corked && ((n.corked = 1), this.uncork()),
      n.ending || Olt(this, n, r),
      this
    )
  }
  Object.defineProperty(fi.prototype, "writableLength", {
    enumerable: false,
    get: function () {
      return this._writableState.length
    },
  })
  function zpe(e) {
    return (
      e.ending &&
      e.length === 0 &&
      e.bufferedRequest === null &&
      !e.finished &&
      !e.writing
    )
  }
  function Llt(e, t) {
    e._final(function (r) {
      t.pendingcb--,
        r && Oy(e, r),
        (t.prefinished = true),
        e.emit("prefinish"),
        Q_(e, t)
    })
  }
  function Ult(e, t) {
    !t.prefinished &&
      !t.finalCalled &&
      (typeof e._final == "function" && !t.destroyed
        ? (t.pendingcb++, (t.finalCalled = true), process.nextTick(Llt, e, t))
        : ((t.prefinished = true), e.emit("prefinish")))
  }
  function Q_(e, t) {
    var r = zpe(t)
    if (
      r &&
      (Ult(e, t),
      t.pendingcb === 0 && ((t.finished = true), e.emit("finish"), t.autoDestroy))
    ) {
      var n = e._readableState
      ;(!n || (n.autoDestroy && n.endEmitted)) && e.destroy()
    }
    return r
  }
  function Olt(e, t, r) {
    ;(t.ending = true),
      Q_(e, t),
      r && (t.finished ? process.nextTick(r) : e.once("finish", r)),
      (t.ended = true),
      (e.writable = false)
  }
  function qlt(e, t, r) {
    var n = e.entry
    for (e.entry = null; n; ) {
      var i = n.callback
      t.pendingcb--, i(r), (n = n.next)
    }
    t.corkedRequestsFree.next = e
  }
  Object.defineProperty(fi.prototype, "destroyed", {
    enumerable: false,
    get: function () {
      return this._writableState === undefined ? false : this._writableState.destroyed
    },
    set: function (t) {
      this._writableState && (this._writableState.destroyed = t)
    },
  })
  fi.prototype.destroy = D3.destroy
  fi.prototype._undestroy = D3.undestroy
  fi.prototype._destroy = function (e, t) {
    t(e)
  }
})
var k3 = _((WFt, Zpe) => {
  "use strict"
  var Vlt = require("util"),
    { LEVEL: T3 } = Qi(),
    jpe = Yh(),
    P_ = (Zpe.exports = function (t = {}) {
      if (
        (jpe.call(this, t),
        !t.transport || typeof t.transport.log != "function")
      )
        throw new Error(
          "Invalid transport, must be an object with a log method.",
        )
      ;(this.transport = t.transport),
        (this.level = this.level || t.transport.level),
        (this.handleExceptions =
          this.handleExceptions || t.transport.handleExceptions),
        this._deprecated()
      function r(n) {
        this.emit("error", n, this.transport)
      }
      this.transport.__winstonError ||
        ((this.transport.__winstonError = r.bind(this)),
        this.transport.on("error", this.transport.__winstonError))
    })
  Vlt.inherits(P_, jpe)
  P_.prototype._write = function (t, r, n) {
    if (this.silent || (t.exception === true && !this.handleExceptions))
      return n(null)
    ;(!this.level || this.levels[this.level] >= this.levels[t[T3]]) &&
      this.transport.log(t[T3], t.message, t, this._nop),
      n(null)
  }
  P_.prototype._writev = function (t, r) {
    for (let n = 0; n < t.length; n++)
      this._accept(t[n]) &&
        (this.transport.log(
          t[n].chunk[T3],
          t[n].chunk.message,
          t[n].chunk,
          this._nop,
        ),
        t[n].callback())
    return r(null)
  }
  P_.prototype._deprecated = function () {
    console.error(
      [
        `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
        "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md",
      ].join(`
`),
    )
  }
  P_.prototype.close = function () {
    this.transport.close && this.transport.close(),
      this.transport.__winstonError &&
        (this.transport.removeListener("error", this.transport.__winstonError),
        (this.transport.__winstonError = null))
  }
})
var Yh = _((GFt, M3) => {
  "use strict"
  var Hlt = require("util"),
    Xpe = hk(),
    { LEVEL: eme } = Qi(),
    L_ = (M3.exports = function (t = {}) {
      Xpe.call(this, { objectMode: true, highWaterMark: t.highWaterMark }),
        (this.format = t.format),
        (this.level = t.level),
        (this.handleExceptions = t.handleExceptions),
        (this.handleRejections = t.handleRejections),
        (this.silent = t.silent),
        t.log && (this.log = t.log),
        t.logv && (this.logv = t.logv),
        t.close && (this.close = t.close),
        this.once("pipe", (r) => {
          ;(this.levels = r.levels), (this.parent = r)
        }),
        this.once("unpipe", (r) => {
          r === this.parent &&
            ((this.parent = null), this.close && this.close())
        })
    })
  Hlt.inherits(L_, Xpe)
  L_.prototype._write = function (t, r, n) {
    if (this.silent || (t.exception === true && !this.handleExceptions))
      return n(null)
    let i = this.level || (this.parent && this.parent.level)
    if (!i || this.levels[i] >= this.levels[t[eme]]) {
      if (t && !this.format) return this.log(t, n)
      let s, o
      try {
        o = this.format.transform(Object.assign({}, t), this.format.options)
      } catch (a) {
        s = a
      }
      if (s || !o) {
        if ((n(), s)) throw s
        return
      }
      return this.log(o, n)
    }
    return (this._writableState.sync = false), n(null)
  }
  L_.prototype._writev = function (t, r) {
    if (this.logv) {
      let n = t.filter(this._accept, this)
      return n.length ? this.logv(n, r) : r(null)
    }
    for (let n = 0; n < t.length; n++) {
      if (!this._accept(t[n])) continue
      if (t[n].chunk && !this.format) {
        this.log(t[n].chunk, t[n].callback)
        continue
      }
      let i, s
      try {
        s = this.format.transform(
          Object.assign({}, t[n].chunk),
          this.format.options,
        )
      } catch (o) {
        i = o
      }
      if (i || !s) {
        if ((t[n].callback(), i)) throw (r(null), i)
      } else this.log(s, t[n].callback)
    }
    return r(null)
  }
  L_.prototype._accept = function (t) {
    let r = t.chunk
    if (this.silent) return false
    let n = this.level || (this.parent && this.parent.level)
    return !!(
      (r.exception === true || !n || this.levels[n] >= this.levels[r[eme]]) &&
      (this.handleExceptions || r.exception !== true)
    )
  }
  L_.prototype._nop = function () {}
  M3.exports.LegacyTransportStream = k3()
})
var nme = _((YFt, rme) => {
  "use strict"
  var Wlt = require("os"),
    { LEVEL: tme, MESSAGE: qy } = Qi(),
    Glt = Yh()
  rme.exports = class extends Glt {
    constructor(t = {}) {
      super(t),
        (this.name = t.name || "console"),
        (this.stderrLevels = this._stringArrayToSet(t.stderrLevels)),
        (this.consoleWarnLevels = this._stringArrayToSet(t.consoleWarnLevels)),
        (this.eol = typeof t.eol == "string" ? t.eol : Wlt.EOL),
        this.setMaxListeners(30)
    }
    log(t, r) {
      if (
        (setImmediate(() => this.emit("logged", t)), this.stderrLevels[t[tme]])
      ) {
        console._stderr
          ? console._stderr.write(`${t[qy]}${this.eol}`)
          : console.error(t[qy]),
          r && r()
        return
      } else if (this.consoleWarnLevels[t[tme]]) {
        console._stderr
          ? console._stderr.write(`${t[qy]}${this.eol}`)
          : console.warn(t[qy]),
          r && r()
        return
      }
      console._stdout
        ? console._stdout.write(`${t[qy]}${this.eol}`)
        : console.log(t[qy]),
        r && r()
    }
    _stringArrayToSet(t, r) {
      if (!t) return {}
      if (
        ((r =
          r || "Cannot make set from type other than Array of string elements"),
        !Array.isArray(t))
      )
        throw new Error(r)
      return t.reduce((n, i) => {
        if (typeof i != "string") throw new Error(r)
        return (n[i] = true), n
      }, {})
    }
  }
})
var Ak = _((mk, ime) => {
  "use strict"
  Object.defineProperty(mk, "__esModule", { value: true })
  mk.default = $lt
  function $lt(e) {
    return (
      e && typeof e.length == "number" && e.length >= 0 && e.length % 1 === 0
    )
  }
  ime.exports = mk.default
})
var ome = _((yk, sme) => {
  "use strict"
  Object.defineProperty(yk, "__esModule", { value: true })
  yk.default = function (e) {
    return function (...t) {
      var r = t.pop()
      return e.call(this, t, r)
    }
  }
  sme.exports = yk.default
})
var cme = _((Kh) => {
  "use strict"
  Object.defineProperty(Kh, "__esModule", { value: true })
  Kh.fallback = ame
  Kh.wrap = lme
  var Ylt = (Kh.hasQueueMicrotask =
      typeof queueMicrotask == "function" && queueMicrotask),
    Klt = (Kh.hasSetImmediate =
      typeof setImmediate == "function" && setImmediate),
    zlt = (Kh.hasNextTick =
      typeof process == "object" && typeof process.nextTick == "function")
  function ame(e) {
    setTimeout(e, 0)
  }
  function lme(e) {
    return (t, ...r) => e(() => t(...r))
  }
  var U_
  Ylt
    ? (U_ = queueMicrotask)
    : Klt
      ? (U_ = setImmediate)
      : zlt
        ? (U_ = process.nextTick)
        : (U_ = ame)
  Kh.default = lme(U_)
})
var gme = _((vk, hme) => {
  "use strict"
  Object.defineProperty(vk, "__esModule", { value: true })
  vk.default = tct
  var Jlt = ome(),
    jlt = fme(Jlt),
    Zlt = cme(),
    Xlt = fme(Zlt),
    ect = cm()
  function fme(e) {
    return e && e.__esModule ? e : { default: e }
  }
  function tct(e) {
    return (0, ect.isAsync)(e)
      ? function (...t) {
          let r = t.pop(),
            n = e.apply(this, t)
          return ume(n, r)
        }
      : (0, jlt.default)(function (t, r) {
          var n
          try {
            n = e.apply(this, t)
          } catch (i) {
            return r(i)
          }
          if (n && typeof n.then == "function") return ume(n, r)
          r(null, n)
        })
  }
  function ume(e, t) {
    return e.then(
      (r) => {
        dme(t, null, r)
      },
      (r) => {
        dme(t, r && (r instanceof Error || r.message) ? r : new Error(r))
      },
    )
  }
  function dme(e, t, r) {
    try {
      e(t, r)
    } catch (n) {
      ;(0, Xlt.default)((i) => {
        throw i
      }, n)
    }
  }
  hme.exports = vk.default
})
var cm = _((rf) => {
  "use strict"
  Object.defineProperty(rf, "__esModule", { value: true })
  rf.isAsyncIterable = rf.isAsyncGenerator = rf.isAsync = undefined
  var rct = gme(),
    nct = ict(rct)
  function ict(e) {
    return e && e.__esModule ? e : { default: e }
  }
  function pme(e) {
    return e[Symbol.toStringTag] === "AsyncFunction"
  }
  function sct(e) {
    return e[Symbol.toStringTag] === "AsyncGenerator"
  }
  function oct(e) {
    return typeof e[Symbol.asyncIterator] == "function"
  }
  function act(e) {
    if (typeof e != "function") throw new Error("expected a function")
    return pme(e) ? (0, nct.default)(e) : e
  }
  rf.default = act
  rf.isAsync = pme
  rf.isAsyncGenerator = sct
  rf.isAsyncIterable = oct
})
var Vy = _((Ck, mme) => {
  "use strict"
  Object.defineProperty(Ck, "__esModule", { value: true })
  Ck.default = lct
  function lct(e, t) {
    if ((t || (t = e.length), !t)) throw new Error("arity is undefined")
    function r(...n) {
      return typeof n[t - 1] == "function"
        ? e.apply(this, n)
        : new Promise((i, s) => {
            ;(n[t - 1] = (o, ...a) => {
              if (o) return s(o)
              i(a.length > 1 ? a : a[0])
            }),
              e.apply(this, n)
          })
    }
    return r
  }
  mme.exports = Ck.default
})
var yme = _((bk, Ame) => {
  "use strict"
  Object.defineProperty(bk, "__esModule", { value: true })
  var cct = Ak(),
    uct = F3(cct),
    dct = cm(),
    fct = F3(dct),
    hct = Vy(),
    gct = F3(hct)
  function F3(e) {
    return e && e.__esModule ? e : { default: e }
  }
  bk.default = (0, gct.default)((e, t, r) => {
    var n = (0, uct.default)(t) ? [] : {}
    e(
      t,
      (i, s, o) => {
        ;(0, fct.default)(i)((a, ...l) => {
          l.length < 2 && ([l] = l), (n[s] = l), o(a)
        })
      },
      (i) => r(i, n),
    )
  }, 3)
  Ame.exports = bk.default
})
var Q3 = _((Ek, vme) => {
  "use strict"
  Object.defineProperty(Ek, "__esModule", { value: true })
  Ek.default = pct
  function pct(e) {
    function t(...r) {
      if (e !== null) {
        var n = e
        ;(e = null), n.apply(this, r)
      }
    }
    return Object.assign(t, e), t
  }
  vme.exports = Ek.default
})
var bme = _((_k, Cme) => {
  "use strict"
  Object.defineProperty(_k, "__esModule", { value: true })
  _k.default = function (e) {
    return e[Symbol.iterator] && e[Symbol.iterator]()
  }
  Cme.exports = _k.default
})
var xme = _((xk, _me) => {
  "use strict"
  Object.defineProperty(xk, "__esModule", { value: true })
  xk.default = _ct
  var mct = Ak(),
    Act = Eme(mct),
    yct = bme(),
    vct = Eme(yct)
  function Eme(e) {
    return e && e.__esModule ? e : { default: e }
  }
  function Cct(e) {
    var t = -1,
      r = e.length
    return function () {
      return ++t < r ? { value: e[t], key: t } : null
    }
  }
  function bct(e) {
    var t = -1
    return function () {
      var n = e.next()
      return n.done ? null : (t++, { value: n.value, key: t })
    }
  }
  function Ect(e) {
    var t = e ? Object.keys(e) : [],
      r = -1,
      n = t.length
    return function i() {
      var s = t[++r]
      return s === "__proto__" ? i() : r < n ? { value: e[s], key: s } : null
    }
  }
  function _ct(e) {
    if ((0, Act.default)(e)) return Cct(e)
    var t = (0, vct.default)(e)
    return t ? bct(t) : Ect(e)
  }
  _me.exports = xk.default
})
var N3 = _((wk, wme) => {
  "use strict"
  Object.defineProperty(wk, "__esModule", { value: true })
  wk.default = xct
  function xct(e) {
    return function (...t) {
      if (e === null) throw new Error("Callback was already called.")
      var r = e
      ;(e = null), r.apply(this, t)
    }
  }
  wme.exports = wk.default
})
var Ik = _((Sk, Sme) => {
  "use strict"
  Object.defineProperty(Sk, "__esModule", { value: true })
  var wct = {}
  Sk.default = wct
  Sme.exports = Sk.default
})
var Bme = _((Bk, Ime) => {
  "use strict"
  Object.defineProperty(Bk, "__esModule", { value: true })
  Bk.default = Rct
  var Sct = Ik(),
    Ict = Bct(Sct)
  function Bct(e) {
    return e && e.__esModule ? e : { default: e }
  }
  function Rct(e, t, r, n) {
    let i = false,
      s = false,
      o = false,
      a = 0,
      l = 0
    function c() {
      a >= t ||
        o ||
        i ||
        ((o = true),
        e
          .next()
          .then(({ value: p, done: g }) => {
            if (!(s || i)) {
              if (((o = false), g)) {
                ;(i = true), a <= 0 && n(null)
                return
              }
              a++, r(p, l, u), l++, c()
            }
          })
          .catch(f))
    }
    function u(p, g) {
      if (((a -= 1), !s)) {
        if (p) return f(p)
        if (p === false) {
          ;(i = true), (s = true)
          return
        }
        if (g === Ict.default || (i && a <= 0)) return (i = true), n(null)
        c()
      }
    }
    function f(p) {
      s || ((o = false), (i = true), n(p))
    }
    c()
  }
  Ime.exports = Bk.default
})
var kme = _((Rk, Tme) => {
  "use strict"
  Object.defineProperty(Rk, "__esModule", { value: true })
  var Dct = Q3(),
    Tct = O_(Dct),
    kct = xme(),
    Mct = O_(kct),
    Fct = N3(),
    Qct = O_(Fct),
    Rme = cm(),
    Nct = Bme(),
    Dme = O_(Nct),
    Pct = Ik(),
    Lct = O_(Pct)
  function O_(e) {
    return e && e.__esModule ? e : { default: e }
  }
  Rk.default = (e) => (t, r, n) => {
    if (((n = (0, Tct.default)(n)), e <= 0))
      throw new RangeError("concurrency limit cannot be less than 1")
    if (!t) return n(null)
    if ((0, Rme.isAsyncGenerator)(t)) return (0, Dme.default)(t, e, r, n)
    if ((0, Rme.isAsyncIterable)(t))
      return (0, Dme.default)(t[Symbol.asyncIterator](), e, r, n)
    var i = (0, Mct.default)(t),
      s = false,
      o = false,
      a = 0,
      l = false
    function c(f, p) {
      if (!o)
        if (((a -= 1), f)) (s = true), n(f)
        else if (f === false) (s = true), (o = true)
        else {
          if (p === Lct.default || (s && a <= 0)) return (s = true), n(null)
          l || u()
        }
    }
    function u() {
      for (l = true; a < e && !s; ) {
        var f = i()
        if (f === null) {
          ;(s = true), a <= 0 && n(null)
          return
        }
        ;(a += 1), r(f.value, f.key, (0, Qct.default)(c))
      }
      l = false
    }
    u()
  }
  Tme.exports = Rk.default
})
var L3 = _((Dk, Mme) => {
  "use strict"
  Object.defineProperty(Dk, "__esModule", { value: true })
  var Uct = kme(),
    Oct = P3(Uct),
    qct = cm(),
    Vct = P3(qct),
    Hct = Vy(),
    Wct = P3(Hct)
  function P3(e) {
    return e && e.__esModule ? e : { default: e }
  }
  function Gct(e, t, r, n) {
    return (0, Oct.default)(t)(e, (0, Vct.default)(r), n)
  }
  Dk.default = (0, Wct.default)(Gct, 4)
  Mme.exports = Dk.default
})
var Nme = _((Tk, Qme) => {
  "use strict"
  Object.defineProperty(Tk, "__esModule", { value: true })
  var $ct = L3(),
    Yct = Fme($ct),
    Kct = Vy(),
    zct = Fme(Kct)
  function Fme(e) {
    return e && e.__esModule ? e : { default: e }
  }
  function Jct(e, t, r) {
    return (0, Yct.default)(e, 1, t, r)
  }
  Tk.default = (0, zct.default)(Jct, 3)
  Qme.exports = Tk.default
})
var Ume = _((kk, Lme) => {
  "use strict"
  Object.defineProperty(kk, "__esModule", { value: true })
  kk.default = tut
  var jct = yme(),
    Zct = Pme(jct),
    Xct = Nme(),
    eut = Pme(Xct)
  function Pme(e) {
    return e && e.__esModule ? e : { default: e }
  }
  function tut(e, t) {
    return (0, Zct.default)(eut.default, e, t)
  }
  Lme.exports = kk.default
})
var U3 = _((JFt, qme) => {
  "use strict"
  qme.exports = nf
  var Mk = Vh().codes,
    rut = Mk.ERR_METHOD_NOT_IMPLEMENTED,
    nut = Mk.ERR_MULTIPLE_CALLBACK,
    iut = Mk.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    sut = Mk.ERR_TRANSFORM_WITH_LENGTH_0,
    Fk = lm()
  Ny()(nf, Fk)
  function out(e, t) {
    var r = this._transformState
    r.transforming = false
    var n = r.writecb
    if (n === null) return this.emit("error", new nut())
    ;(r.writechunk = null), (r.writecb = null), t != null && this.push(t), n(e)
    var i = this._readableState
    ;(i.reading = false),
      (i.needReadable || i.length < i.highWaterMark) &&
        this._read(i.highWaterMark)
  }
  function nf(e) {
    if (!(this instanceof nf)) return new nf(e)
    Fk.call(this, e),
      (this._transformState = {
        afterTransform: out.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null,
      }),
      (this._readableState.needReadable = true),
      (this._readableState.sync = false),
      e &&
        (typeof e.transform == "function" && (this._transform = e.transform),
        typeof e.flush == "function" && (this._flush = e.flush)),
      this.on("prefinish", aut)
  }
  function aut() {
    var e = this
    typeof this._flush == "function" && !this._readableState.destroyed
      ? this._flush(function (t, r) {
          Ome(e, t, r)
        })
      : Ome(this, null, null)
  }
  nf.prototype.push = function (e, t) {
    return (
      (this._transformState.needTransform = false),
      Fk.prototype.push.call(this, e, t)
    )
  }
  nf.prototype._transform = function (e, t, r) {
    r(new rut("_transform()"))
  }
  nf.prototype._write = function (e, t, r) {
    var n = this._transformState
    if (
      ((n.writecb = r),
      (n.writechunk = e),
      (n.writeencoding = t),
      !n.transforming)
    ) {
      var i = this._readableState
      ;(n.needTransform || i.needReadable || i.length < i.highWaterMark) &&
        this._read(i.highWaterMark)
    }
  }
  nf.prototype._read = function (e) {
    var t = this._transformState
    t.writechunk !== null && !t.transforming
      ? ((t.transforming = true),
        this._transform(t.writechunk, t.writeencoding, t.afterTransform))
      : (t.needTransform = true)
  }
  nf.prototype._destroy = function (e, t) {
    Fk.prototype._destroy.call(this, e, function (r) {
      t(r)
    })
  }
  function Ome(e, t, r) {
    if (t) return e.emit("error", t)
    if ((r != null && e.push(r), e._writableState.length)) throw new sut()
    if (e._transformState.transforming) throw new iut()
    return e.push(null)
  }
})
var Wme = _((jFt, Hme) => {
  "use strict"
  Hme.exports = q_
  var Vme = U3()
  Ny()(q_, Vme)
  function q_(e) {
    if (!(this instanceof q_)) return new q_(e)
    Vme.call(this, e)
  }
  q_.prototype._transform = function (e, t, r) {
    r(null, e)
  }
})
var zme = _((ZFt, Kme) => {
  "use strict"
  var O3
  function lut(e) {
    var t = false
    return function () {
      t || ((t = true), e.apply(undefined, arguments))
    }
  }
  var Yme = Vh().codes,
    cut = Yme.ERR_MISSING_ARGS,
    uut = Yme.ERR_STREAM_DESTROYED
  function Gme(e) {
    if (e) throw e
  }
  function dut(e) {
    return e.setHeader && typeof e.abort == "function"
  }
  function fut(e, t, r, n) {
    n = lut(n)
    var i = false
    e.on("close", function () {
      i = true
    }),
      O3 === undefined && (O3 = sk()),
      O3(e, { readable: t, writable: r }, function (o) {
        if (o) return n(o)
        ;(i = true), n()
      })
    var s = false
    return function (o) {
      if (!i && !s) {
        if (((s = true), dut(e))) return e.abort()
        if (typeof e.destroy == "function") return e.destroy()
        n(o || new uut("pipe"))
      }
    }
  }
  function $me(e) {
    e()
  }
  function hut(e, t) {
    return e.pipe(t)
  }
  function gut(e) {
    return !e.length || typeof e[e.length - 1] != "function" ? Gme : e.pop()
  }
  function put() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r]
    var n = gut(t)
    if ((Array.isArray(t[0]) && (t = t[0]), t.length < 2))
      throw new cut("streams")
    var i,
      s = t.map(function (o, a) {
        var l = a < t.length - 1,
          c = a > 0
        return fut(o, l, c, function (u) {
          i || (i = u), u && s.forEach($me), !l && (s.forEach($me), n(i))
        })
      })
    return t.reduce(hut)
  }
  Kme.exports = put
})
var Hy = _((Ll, H_) => {
  "use strict"
  var V_ = require("stream")
  process.env.READABLE_STREAM === "disable" && V_
    ? ((H_.exports = V_.Readable),
      Object.assign(H_.exports, V_),
      (H_.exports.Stream = V_))
    : ((Ll = H_.exports = S3()),
      (Ll.Stream = V_ || Ll),
      (Ll.Readable = Ll),
      (Ll.Writable = hk()),
      (Ll.Duplex = lm()),
      (Ll.Transform = U3()),
      (Ll.PassThrough = Wme()),
      (Ll.finished = sk()),
      (Ll.pipeline = zme()))
})
var Y3 = _((XFt, jme) => {
  "use strict"
  var Wy = [],
    W_ = [],
    q3 = function () {}
  function H3(e) {
    return ~Wy.indexOf(e) ? false : (Wy.push(e), true)
  }
  function W3(e) {
    q3 = e
  }
  function mut(e) {
    for (var t = [], r = 0; r < Wy.length; r++) {
      if (Wy[r].async) {
        t.push(Wy[r])
        continue
      }
      if (Wy[r](e)) return true
    }
    return t.length
      ? new Promise(function (i) {
          Promise.all(
            t.map(function (o) {
              return o(e)
            }),
          ).then(function (o) {
            i(o.some(Boolean))
          })
        })
      : false
  }
  function G3(e) {
    return ~W_.indexOf(e) ? false : (W_.push(e), true)
  }
  function V3() {
    q3.apply(q3, arguments)
  }
  function Jme(e) {
    for (var t = 0; t < W_.length; t++) e = W_[t].apply(W_[t], arguments)
    return e
  }
  function $3(e, t) {
    var r = Object.prototype.hasOwnProperty
    for (var n in t) r.call(t, n) && (e[n] = t[n])
    return e
  }
  function Aut(e) {
    return (
      (e.enabled = false),
      (e.modify = G3),
      (e.set = W3),
      (e.use = H3),
      $3(function () {
        return false
      }, e)
    )
  }
  function yut(e) {
    function t() {
      var r = Array.prototype.slice.call(arguments, 0)
      return V3.call(V3, e, Jme(r, e)), true
    }
    return (
      (e.enabled = true), (e.modify = G3), (e.set = W3), (e.use = H3), $3(t, e)
    )
  }
  jme.exports = function (t) {
    return (
      (t.introduce = $3),
      (t.enabled = mut),
      (t.process = Jme),
      (t.modify = G3),
      (t.write = V3),
      (t.nope = Aut),
      (t.yep = yut),
      (t.set = W3),
      (t.use = H3),
      t
    )
  }
})
var Xme = _((e1t, Zme) => {
  "use strict"
  var vut = Y3(),
    Cut = vut(function e(t, r) {
      return (
        (r = r || {}),
        (r.namespace = t),
        (r.prod = true),
        (r.dev = false),
        r.force || e.force ? e.yep(r) : e.nope(r)
      )
    })
  Zme.exports = Cut
})
var tAe = _((t1t, eAe) => {
  "use strict"
  eAe.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50],
  }
})
var nAe = _((r1t, rAe) => {
  "use strict"
  rAe.exports = function (t) {
    return !t || typeof t == "string"
      ? false
      : t instanceof Array ||
          Array.isArray(t) ||
          (t.length >= 0 &&
            (t.splice instanceof Function ||
              (Object.getOwnPropertyDescriptor(t, t.length - 1) &&
                t.constructor.name !== "String")))
  }
})
var oAe = _((n1t, sAe) => {
  "use strict"
  var but = nAe(),
    Eut = Array.prototype.concat,
    _ut = Array.prototype.slice,
    iAe = (sAe.exports = function (t) {
      for (var r = [], n = 0, i = t.length; n < i; n++) {
        var s = t[n]
        but(s) ? (r = Eut.call(r, _ut.call(s))) : r.push(s)
      }
      return r
    })
  iAe.wrap = function (e) {
    return function () {
      return e(iAe(arguments))
    }
  }
})
var uAe = _((i1t, cAe) => {
  "use strict"
  var G_ = tAe(),
    $_ = oAe(),
    aAe = Object.hasOwnProperty,
    lAe = Object.create(null)
  for (Qk in G_) aAe.call(G_, Qk) && (lAe[G_[Qk]] = Qk)
  var Qk,
    Oa = (cAe.exports = { to: {}, get: {} })
  Oa.get = function (e) {
    var t = e.substring(0, 3).toLowerCase(),
      r,
      n
    switch (t) {
      case "hsl":
        ;(r = Oa.get.hsl(e)), (n = "hsl")
        break
      case "hwb":
        ;(r = Oa.get.hwb(e)), (n = "hwb")
        break
      default:
        ;(r = Oa.get.rgb(e)), (n = "rgb")
        break
    }
    return r ? { model: n, value: r } : null
  }
  Oa.get.rgb = function (e) {
    if (!e) return null
    var t = /^#([a-f0-9]{3,4})$/i,
      r = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i,
      n =
        /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/,
      i =
        /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/,
      s = /^(\w+)$/,
      o = [0, 0, 0, 1],
      a,
      l,
      c
    if ((a = e.match(r))) {
      for (c = a[2], a = a[1], l = 0; l < 3; l++) {
        var u = l * 2
        o[l] = parseInt(a.slice(u, u + 2), 16)
      }
      c && (o[3] = parseInt(c, 16) / 255)
    } else if ((a = e.match(t))) {
      for (a = a[1], c = a[3], l = 0; l < 3; l++)
        o[l] = parseInt(a[l] + a[l], 16)
      c && (o[3] = parseInt(c + c, 16) / 255)
    } else if ((a = e.match(n))) {
      for (l = 0; l < 3; l++) o[l] = parseInt(a[l + 1], 0)
      a[4] &&
        (a[5] ? (o[3] = parseFloat(a[4]) * 0.01) : (o[3] = parseFloat(a[4])))
    } else if ((a = e.match(i))) {
      for (l = 0; l < 3; l++) o[l] = Math.round(parseFloat(a[l + 1]) * 2.55)
      a[4] &&
        (a[5] ? (o[3] = parseFloat(a[4]) * 0.01) : (o[3] = parseFloat(a[4])))
    } else
      return (a = e.match(s))
        ? a[1] === "transparent"
          ? [0, 0, 0, 0]
          : aAe.call(G_, a[1])
            ? ((o = G_[a[1]]), (o[3] = 1), o)
            : null
        : null
    for (l = 0; l < 3; l++) o[l] = zh(o[l], 0, 255)
    return (o[3] = zh(o[3], 0, 1)), o
  }
  Oa.get.hsl = function (e) {
    if (!e) return null
    var t =
        /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/,
      r = e.match(t)
    if (r) {
      var n = parseFloat(r[4]),
        i = ((parseFloat(r[1]) % 360) + 360) % 360,
        s = zh(parseFloat(r[2]), 0, 100),
        o = zh(parseFloat(r[3]), 0, 100),
        a = zh(isNaN(n) ? 1 : n, 0, 1)
      return [i, s, o, a]
    }
    return null
  }
  Oa.get.hwb = function (e) {
    if (!e) return null
    var t =
        /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/,
      r = e.match(t)
    if (r) {
      var n = parseFloat(r[4]),
        i = ((parseFloat(r[1]) % 360) + 360) % 360,
        s = zh(parseFloat(r[2]), 0, 100),
        o = zh(parseFloat(r[3]), 0, 100),
        a = zh(isNaN(n) ? 1 : n, 0, 1)
      return [i, s, o, a]
    }
    return null
  }
  Oa.to.hex = function () {
    var e = $_(arguments)
    return (
      "#" +
      Nk(e[0]) +
      Nk(e[1]) +
      Nk(e[2]) +
      (e[3] < 1 ? Nk(Math.round(e[3] * 255)) : "")
    )
  }
  Oa.to.rgb = function () {
    var e = $_(arguments)
    return e.length < 4 || e[3] === 1
      ? "rgb(" +
          Math.round(e[0]) +
          ", " +
          Math.round(e[1]) +
          ", " +
          Math.round(e[2]) +
          ")"
      : "rgba(" +
          Math.round(e[0]) +
          ", " +
          Math.round(e[1]) +
          ", " +
          Math.round(e[2]) +
          ", " +
          e[3] +
          ")"
  }
  Oa.to.rgb.percent = function () {
    var e = $_(arguments),
      t = Math.round((e[0] / 255) * 100),
      r = Math.round((e[1] / 255) * 100),
      n = Math.round((e[2] / 255) * 100)
    return e.length < 4 || e[3] === 1
      ? "rgb(" + t + "%, " + r + "%, " + n + "%)"
      : "rgba(" + t + "%, " + r + "%, " + n + "%, " + e[3] + ")"
  }
  Oa.to.hsl = function () {
    var e = $_(arguments)
    return e.length < 4 || e[3] === 1
      ? "hsl(" + e[0] + ", " + e[1] + "%, " + e[2] + "%)"
      : "hsla(" + e[0] + ", " + e[1] + "%, " + e[2] + "%, " + e[3] + ")"
  }
  Oa.to.hwb = function () {
    var e = $_(arguments),
      t = ""
    return (
      e.length >= 4 && e[3] !== 1 && (t = ", " + e[3]),
      "hwb(" + e[0] + ", " + e[1] + "%, " + e[2] + "%" + t + ")"
    )
  }
  Oa.to.keyword = function (e) {
    return lAe[e.slice(0, 3)]
  }
  function zh(e, t, r) {
    return Math.min(Math.max(t, e), r)
  }
  function Nk(e) {
    var t = Math.round(e).toString(16).toUpperCase()
    return t.length < 2 ? "0" + t : t
  }
})
var fAe = _((s1t, dAe) => {
  "use strict"
  dAe.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50],
  }
})
var K3 = _((o1t, mAe) => {
  "use strict"
  var um = fAe(),
    pAe = {}
  for (Pk in um) um.hasOwnProperty(Pk) && (pAe[um[Pk]] = Pk)
  var Pk,
    Ke = (mAe.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] },
    })
  for (xo in Ke)
    if (Ke.hasOwnProperty(xo)) {
      if (!("channels" in Ke[xo]))
        throw new Error("missing channels property: " + xo)
      if (!("labels" in Ke[xo]))
        throw new Error("missing channel labels property: " + xo)
      if (Ke[xo].labels.length !== Ke[xo].channels)
        throw new Error("channel and label counts mismatch: " + xo)
      ;(hAe = Ke[xo].channels),
        (gAe = Ke[xo].labels),
        delete Ke[xo].channels,
        delete Ke[xo].labels,
        Object.defineProperty(Ke[xo], "channels", { value: hAe }),
        Object.defineProperty(Ke[xo], "labels", { value: gAe })
    }
  var hAe, gAe, xo
  Ke.rgb.hsl = function (e) {
    var t = e[0] / 255,
      r = e[1] / 255,
      n = e[2] / 255,
      i = Math.min(t, r, n),
      s = Math.max(t, r, n),
      o = s - i,
      a,
      l,
      c
    return (
      s === i
        ? (a = 0)
        : t === s
          ? (a = (r - n) / o)
          : r === s
            ? (a = 2 + (n - t) / o)
            : n === s && (a = 4 + (t - r) / o),
      (a = Math.min(a * 60, 360)),
      a < 0 && (a += 360),
      (c = (i + s) / 2),
      s === i ? (l = 0) : c <= 0.5 ? (l = o / (s + i)) : (l = o / (2 - s - i)),
      [a, l * 100, c * 100]
    )
  }
  Ke.rgb.hsv = function (e) {
    var t,
      r,
      n,
      i,
      s,
      o = e[0] / 255,
      a = e[1] / 255,
      l = e[2] / 255,
      c = Math.max(o, a, l),
      u = c - Math.min(o, a, l),
      f = function (p) {
        return (c - p) / 6 / u + 1 / 2
      }
    return (
      u === 0
        ? (i = s = 0)
        : ((s = u / c),
          (t = f(o)),
          (r = f(a)),
          (n = f(l)),
          o === c
            ? (i = n - r)
            : a === c
              ? (i = 1 / 3 + t - n)
              : l === c && (i = 2 / 3 + r - t),
          i < 0 ? (i += 1) : i > 1 && (i -= 1)),
      [i * 360, s * 100, c * 100]
    )
  }
  Ke.rgb.hwb = function (e) {
    var t = e[0],
      r = e[1],
      n = e[2],
      i = Ke.rgb.hsl(e)[0],
      s = (1 / 255) * Math.min(t, Math.min(r, n))
    return (
      (n = 1 - (1 / 255) * Math.max(t, Math.max(r, n))), [i, s * 100, n * 100]
    )
  }
  Ke.rgb.cmyk = function (e) {
    var t = e[0] / 255,
      r = e[1] / 255,
      n = e[2] / 255,
      i,
      s,
      o,
      a
    return (
      (a = Math.min(1 - t, 1 - r, 1 - n)),
      (i = (1 - t - a) / (1 - a) || 0),
      (s = (1 - r - a) / (1 - a) || 0),
      (o = (1 - n - a) / (1 - a) || 0),
      [i * 100, s * 100, o * 100, a * 100]
    )
  }
  function xut(e, t) {
    return (
      Math.pow(e[0] - t[0], 2) +
      Math.pow(e[1] - t[1], 2) +
      Math.pow(e[2] - t[2], 2)
    )
  }
  Ke.rgb.keyword = function (e) {
    var t = pAe[e]
    if (t) return t
    var r = 1 / 0,
      n
    for (var i in um)
      if (um.hasOwnProperty(i)) {
        var s = um[i],
          o = xut(e, s)
        o < r && ((r = o), (n = i))
      }
    return n
  }
  Ke.keyword.rgb = function (e) {
    return um[e]
  }
  Ke.rgb.xyz = function (e) {
    var t = e[0] / 255,
      r = e[1] / 255,
      n = e[2] / 255
    ;(t = t > 0.04045 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92),
      (r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92),
      (n = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92)
    var i = t * 0.4124 + r * 0.3576 + n * 0.1805,
      s = t * 0.2126 + r * 0.7152 + n * 0.0722,
      o = t * 0.0193 + r * 0.1192 + n * 0.9505
    return [i * 100, s * 100, o * 100]
  }
  Ke.rgb.lab = function (e) {
    var t = Ke.rgb.xyz(e),
      r = t[0],
      n = t[1],
      i = t[2],
      s,
      o,
      a
    return (
      (r /= 95.047),
      (n /= 100),
      (i /= 108.883),
      (r = r > 0.008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116),
      (n = n > 0.008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116),
      (i = i > 0.008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116),
      (s = 116 * n - 16),
      (o = 500 * (r - n)),
      (a = 200 * (n - i)),
      [s, o, a]
    )
  }
  Ke.hsl.rgb = function (e) {
    var t = e[0] / 360,
      r = e[1] / 100,
      n = e[2] / 100,
      i,
      s,
      o,
      a,
      l
    if (r === 0) return (l = n * 255), [l, l, l]
    n < 0.5 ? (s = n * (1 + r)) : (s = n + r - n * r),
      (i = 2 * n - s),
      (a = [0, 0, 0])
    for (var c = 0; c < 3; c++)
      (o = t + (1 / 3) * -(c - 1)),
        o < 0 && o++,
        o > 1 && o--,
        6 * o < 1
          ? (l = i + (s - i) * 6 * o)
          : 2 * o < 1
            ? (l = s)
            : 3 * o < 2
              ? (l = i + (s - i) * (2 / 3 - o) * 6)
              : (l = i),
        (a[c] = l * 255)
    return a
  }
  Ke.hsl.hsv = function (e) {
    var t = e[0],
      r = e[1] / 100,
      n = e[2] / 100,
      i = r,
      s = Math.max(n, 0.01),
      o,
      a
    return (
      (n *= 2),
      (r *= n <= 1 ? n : 2 - n),
      (i *= s <= 1 ? s : 2 - s),
      (a = (n + r) / 2),
      (o = n === 0 ? (2 * i) / (s + i) : (2 * r) / (n + r)),
      [t, o * 100, a * 100]
    )
  }
  Ke.hsv.rgb = function (e) {
    var t = e[0] / 60,
      r = e[1] / 100,
      n = e[2] / 100,
      i = Math.floor(t) % 6,
      s = t - Math.floor(t),
      o = 255 * n * (1 - r),
      a = 255 * n * (1 - r * s),
      l = 255 * n * (1 - r * (1 - s))
    switch (((n *= 255), i)) {
      case 0:
        return [n, l, o]
      case 1:
        return [a, n, o]
      case 2:
        return [o, n, l]
      case 3:
        return [o, a, n]
      case 4:
        return [l, o, n]
      case 5:
        return [n, o, a]
    }
  }
  Ke.hsv.hsl = function (e) {
    var t = e[0],
      r = e[1] / 100,
      n = e[2] / 100,
      i = Math.max(n, 0.01),
      s,
      o,
      a
    return (
      (a = (2 - r) * n),
      (s = (2 - r) * i),
      (o = r * i),
      (o /= s <= 1 ? s : 2 - s),
      (o = o || 0),
      (a /= 2),
      [t, o * 100, a * 100]
    )
  }
  Ke.hwb.rgb = function (e) {
    var t = e[0] / 360,
      r = e[1] / 100,
      n = e[2] / 100,
      i = r + n,
      s,
      o,
      a,
      l
    i > 1 && ((r /= i), (n /= i)),
      (s = Math.floor(6 * t)),
      (o = 1 - n),
      (a = 6 * t - s),
      s & 1 && (a = 1 - a),
      (l = r + a * (o - r))
    var c, u, f
    switch (s) {
      default:
      case 6:
      case 0:
        ;(c = o), (u = l), (f = r)
        break
      case 1:
        ;(c = l), (u = o), (f = r)
        break
      case 2:
        ;(c = r), (u = o), (f = l)
        break
      case 3:
        ;(c = r), (u = l), (f = o)
        break
      case 4:
        ;(c = l), (u = r), (f = o)
        break
      case 5:
        ;(c = o), (u = r), (f = l)
        break
    }
    return [c * 255, u * 255, f * 255]
  }
  Ke.cmyk.rgb = function (e) {
    var t = e[0] / 100,
      r = e[1] / 100,
      n = e[2] / 100,
      i = e[3] / 100,
      s,
      o,
      a
    return (
      (s = 1 - Math.min(1, t * (1 - i) + i)),
      (o = 1 - Math.min(1, r * (1 - i) + i)),
      (a = 1 - Math.min(1, n * (1 - i) + i)),
      [s * 255, o * 255, a * 255]
    )
  }
  Ke.xyz.rgb = function (e) {
    var t = e[0] / 100,
      r = e[1] / 100,
      n = e[2] / 100,
      i,
      s,
      o
    return (
      (i = t * 3.2406 + r * -1.5372 + n * -0.4986),
      (s = t * -0.9689 + r * 1.8758 + n * 0.0415),
      (o = t * 0.0557 + r * -0.204 + n * 1.057),
      (i = i > 0.0031308 ? 1.055 * Math.pow(i, 1 / 2.4) - 0.055 : i * 12.92),
      (s = s > 0.0031308 ? 1.055 * Math.pow(s, 1 / 2.4) - 0.055 : s * 12.92),
      (o = o > 0.0031308 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o * 12.92),
      (i = Math.min(Math.max(0, i), 1)),
      (s = Math.min(Math.max(0, s), 1)),
      (o = Math.min(Math.max(0, o), 1)),
      [i * 255, s * 255, o * 255]
    )
  }
  Ke.xyz.lab = function (e) {
    var t = e[0],
      r = e[1],
      n = e[2],
      i,
      s,
      o
    return (
      (t /= 95.047),
      (r /= 100),
      (n /= 108.883),
      (t = t > 0.008856 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116),
      (r = r > 0.008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116),
      (n = n > 0.008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116),
      (i = 116 * r - 16),
      (s = 500 * (t - r)),
      (o = 200 * (r - n)),
      [i, s, o]
    )
  }
  Ke.lab.xyz = function (e) {
    var t = e[0],
      r = e[1],
      n = e[2],
      i,
      s,
      o
    ;(s = (t + 16) / 116), (i = r / 500 + s), (o = s - n / 200)
    var a = Math.pow(s, 3),
      l = Math.pow(i, 3),
      c = Math.pow(o, 3)
    return (
      (s = a > 0.008856 ? a : (s - 16 / 116) / 7.787),
      (i = l > 0.008856 ? l : (i - 16 / 116) / 7.787),
      (o = c > 0.008856 ? c : (o - 16 / 116) / 7.787),
      (i *= 95.047),
      (s *= 100),
      (o *= 108.883),
      [i, s, o]
    )
  }
  Ke.lab.lch = function (e) {
    var t = e[0],
      r = e[1],
      n = e[2],
      i,
      s,
      o
    return (
      (i = Math.atan2(n, r)),
      (s = (i * 360) / 2 / Math.PI),
      s < 0 && (s += 360),
      (o = Math.sqrt(r * r + n * n)),
      [t, o, s]
    )
  }
  Ke.lch.lab = function (e) {
    var t = e[0],
      r = e[1],
      n = e[2],
      i,
      s,
      o
    return (
      (o = (n / 360) * 2 * Math.PI),
      (i = r * Math.cos(o)),
      (s = r * Math.sin(o)),
      [t, i, s]
    )
  }
  Ke.rgb.ansi16 = function (e) {
    var t = e[0],
      r = e[1],
      n = e[2],
      i = 1 in arguments ? arguments[1] : Ke.rgb.hsv(e)[2]
    if (((i = Math.round(i / 50)), i === 0)) return 30
    var s =
      30 +
      ((Math.round(n / 255) << 2) |
        (Math.round(r / 255) << 1) |
        Math.round(t / 255))
    return i === 2 && (s += 60), s
  }
  Ke.hsv.ansi16 = function (e) {
    return Ke.rgb.ansi16(Ke.hsv.rgb(e), e[2])
  }
  Ke.rgb.ansi256 = function (e) {
    var t = e[0],
      r = e[1],
      n = e[2]
    if (t === r && r === n)
      return t < 8 ? 16 : t > 248 ? 231 : Math.round(((t - 8) / 247) * 24) + 232
    var i =
      16 +
      36 * Math.round((t / 255) * 5) +
      6 * Math.round((r / 255) * 5) +
      Math.round((n / 255) * 5)
    return i
  }
  Ke.ansi16.rgb = function (e) {
    var t = e % 10
    if (t === 0 || t === 7)
      return e > 50 && (t += 3.5), (t = (t / 10.5) * 255), [t, t, t]
    var r = (~~(e > 50) + 1) * 0.5,
      n = (t & 1) * r * 255,
      i = ((t >> 1) & 1) * r * 255,
      s = ((t >> 2) & 1) * r * 255
    return [n, i, s]
  }
  Ke.ansi256.rgb = function (e) {
    if (e >= 232) {
      var t = (e - 232) * 10 + 8
      return [t, t, t]
    }
    e -= 16
    var r,
      n = (Math.floor(e / 36) / 5) * 255,
      i = (Math.floor((r = e % 36) / 6) / 5) * 255,
      s = ((r % 6) / 5) * 255
    return [n, i, s]
  }
  Ke.rgb.hex = function (e) {
    var t =
        ((Math.round(e[0]) & 255) << 16) +
        ((Math.round(e[1]) & 255) << 8) +
        (Math.round(e[2]) & 255),
      r = t.toString(16).toUpperCase()
    return "000000".substring(r.length) + r
  }
  Ke.hex.rgb = function (e) {
    var t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i)
    if (!t) return [0, 0, 0]
    var r = t[0]
    t[0].length === 3 &&
      (r = r
        .split("")
        .map(function (a) {
          return a + a
        })
        .join(""))
    var n = parseInt(r, 16),
      i = (n >> 16) & 255,
      s = (n >> 8) & 255,
      o = n & 255
    return [i, s, o]
  }
  Ke.rgb.hcg = function (e) {
    var t = e[0] / 255,
      r = e[1] / 255,
      n = e[2] / 255,
      i = Math.max(Math.max(t, r), n),
      s = Math.min(Math.min(t, r), n),
      o = i - s,
      a,
      l
    return (
      o < 1 ? (a = s / (1 - o)) : (a = 0),
      o <= 0
        ? (l = 0)
        : i === t
          ? (l = ((r - n) / o) % 6)
          : i === r
            ? (l = 2 + (n - t) / o)
            : (l = 4 + (t - r) / o + 4),
      (l /= 6),
      (l %= 1),
      [l * 360, o * 100, a * 100]
    )
  }
  Ke.hsl.hcg = function (e) {
    var t = e[1] / 100,
      r = e[2] / 100,
      n = 1,
      i = 0
    return (
      r < 0.5 ? (n = 2 * t * r) : (n = 2 * t * (1 - r)),
      n < 1 && (i = (r - 0.5 * n) / (1 - n)),
      [e[0], n * 100, i * 100]
    )
  }
  Ke.hsv.hcg = function (e) {
    var t = e[1] / 100,
      r = e[2] / 100,
      n = t * r,
      i = 0
    return n < 1 && (i = (r - n) / (1 - n)), [e[0], n * 100, i * 100]
  }
  Ke.hcg.rgb = function (e) {
    var t = e[0] / 360,
      r = e[1] / 100,
      n = e[2] / 100
    if (r === 0) return [n * 255, n * 255, n * 255]
    var i = [0, 0, 0],
      s = (t % 1) * 6,
      o = s % 1,
      a = 1 - o,
      l = 0
    switch (Math.floor(s)) {
      case 0:
        ;(i[0] = 1), (i[1] = o), (i[2] = 0)
        break
      case 1:
        ;(i[0] = a), (i[1] = 1), (i[2] = 0)
        break
      case 2:
        ;(i[0] = 0), (i[1] = 1), (i[2] = o)
        break
      case 3:
        ;(i[0] = 0), (i[1] = a), (i[2] = 1)
        break
      case 4:
        ;(i[0] = o), (i[1] = 0), (i[2] = 1)
        break
      default:
        ;(i[0] = 1), (i[1] = 0), (i[2] = a)
    }
    return (
      (l = (1 - r) * n),
      [(r * i[0] + l) * 255, (r * i[1] + l) * 255, (r * i[2] + l) * 255]
    )
  }
  Ke.hcg.hsv = function (e) {
    var t = e[1] / 100,
      r = e[2] / 100,
      n = t + r * (1 - t),
      i = 0
    return n > 0 && (i = t / n), [e[0], i * 100, n * 100]
  }
  Ke.hcg.hsl = function (e) {
    var t = e[1] / 100,
      r = e[2] / 100,
      n = r * (1 - t) + 0.5 * t,
      i = 0
    return (
      n > 0 && n < 0.5
        ? (i = t / (2 * n))
        : n >= 0.5 && n < 1 && (i = t / (2 * (1 - n))),
      [e[0], i * 100, n * 100]
    )
  }
  Ke.hcg.hwb = function (e) {
    var t = e[1] / 100,
      r = e[2] / 100,
      n = t + r * (1 - t)
    return [e[0], (n - t) * 100, (1 - n) * 100]
  }
  Ke.hwb.hcg = function (e) {
    var t = e[1] / 100,
      r = e[2] / 100,
      n = 1 - r,
      i = n - t,
      s = 0
    return i < 1 && (s = (n - i) / (1 - i)), [e[0], i * 100, s * 100]
  }
  Ke.apple.rgb = function (e) {
    return [(e[0] / 65535) * 255, (e[1] / 65535) * 255, (e[2] / 65535) * 255]
  }
  Ke.rgb.apple = function (e) {
    return [(e[0] / 255) * 65535, (e[1] / 255) * 65535, (e[2] / 255) * 65535]
  }
  Ke.gray.rgb = function (e) {
    return [(e[0] / 100) * 255, (e[0] / 100) * 255, (e[0] / 100) * 255]
  }
  Ke.gray.hsl = Ke.gray.hsv = function (e) {
    return [0, 0, e[0]]
  }
  Ke.gray.hwb = function (e) {
    return [0, 100, e[0]]
  }
  Ke.gray.cmyk = function (e) {
    return [0, 0, 0, e[0]]
  }
  Ke.gray.lab = function (e) {
    return [e[0], 0, 0]
  }
  Ke.gray.hex = function (e) {
    var t = Math.round((e[0] / 100) * 255) & 255,
      r = (t << 16) + (t << 8) + t,
      n = r.toString(16).toUpperCase()
    return "000000".substring(n.length) + n
  }
  Ke.rgb.gray = function (e) {
    var t = (e[0] + e[1] + e[2]) / 3
    return [(t / 255) * 100]
  }
})
var yAe = _((a1t, AAe) => {
  "use strict"
  var Lk = K3()
  function wut() {
    for (var e = {}, t = Object.keys(Lk), r = t.length, n = 0; n < r; n++)
      e[t[n]] = { distance: -1, parent: null }
    return e
  }
  function Sut(e) {
    var t = wut(),
      r = [e]
    for (t[e].distance = 0; r.length; )
      for (
        var n = r.pop(), i = Object.keys(Lk[n]), s = i.length, o = 0;
        o < s;
        o++
      ) {
        var a = i[o],
          l = t[a]
        l.distance === -1 &&
          ((l.distance = t[n].distance + 1), (l.parent = n), r.unshift(a))
      }
    return t
  }
  function Iut(e, t) {
    return function (r) {
      return t(e(r))
    }
  }
  function But(e, t) {
    for (
      var r = [t[e].parent, e], n = Lk[t[e].parent][e], i = t[e].parent;
      t[i].parent;

    )
      r.unshift(t[i].parent),
        (n = Iut(Lk[t[i].parent][i], n)),
        (i = t[i].parent)
    return (n.conversion = r), n
  }
  AAe.exports = function (e) {
    for (
      var t = Sut(e), r = {}, n = Object.keys(t), i = n.length, s = 0;
      s < i;
      s++
    ) {
      var o = n[s],
        a = t[o]
      a.parent !== null && (r[o] = But(o, t))
    }
    return r
  }
})
var CAe = _((l1t, vAe) => {
  "use strict"
  var z3 = K3(),
    Rut = yAe(),
    Gy = {},
    Dut = Object.keys(z3)
  function Tut(e) {
    var t = function (r) {
      return r == null
        ? r
        : (arguments.length > 1 && (r = Array.prototype.slice.call(arguments)),
          e(r))
    }
    return "conversion" in e && (t.conversion = e.conversion), t
  }
  function kut(e) {
    var t = function (r) {
      if (r == null) return r
      arguments.length > 1 && (r = Array.prototype.slice.call(arguments))
      var n = e(r)
      if (typeof n == "object")
        for (var i = n.length, s = 0; s < i; s++) n[s] = Math.round(n[s])
      return n
    }
    return "conversion" in e && (t.conversion = e.conversion), t
  }
  Dut.forEach(function (e) {
    ;(Gy[e] = {}),
      Object.defineProperty(Gy[e], "channels", { value: z3[e].channels }),
      Object.defineProperty(Gy[e], "labels", { value: z3[e].labels })
    var t = Rut(e),
      r = Object.keys(t)
    r.forEach(function (n) {
      var i = t[n]
      ;(Gy[e][n] = kut(i)), (Gy[e][n].raw = Tut(i))
    })
  })
  vAe.exports = Gy
})
var _Ae = _((c1t, EAe) => {
  "use strict"
  var Y_ = uAe(),
    qa = CAe(),
    Z3 = [].slice,
    bAe = ["keyword", "gray", "hex"],
    J3 = {}
  Object.keys(qa).forEach(function (e) {
    J3[Z3.call(qa[e].labels).sort().join("")] = e
  })
  var Uk = {}
  function Ms(e, t) {
    if (!(this instanceof Ms)) return new Ms(e, t)
    if ((t && t in bAe && (t = null), t && !(t in qa)))
      throw new Error("Unknown model: " + t)
    var r, n
    if (e == null)
      (this.model = "rgb"), (this.color = [0, 0, 0]), (this.valpha = 1)
    else if (e instanceof Ms)
      (this.model = e.model),
        (this.color = e.color.slice()),
        (this.valpha = e.valpha)
    else if (typeof e == "string") {
      var i = Y_.get(e)
      if (i === null) throw new Error("Unable to parse color from string: " + e)
      ;(this.model = i.model),
        (n = qa[this.model].channels),
        (this.color = i.value.slice(0, n)),
        (this.valpha = typeof i.value[n] == "number" ? i.value[n] : 1)
    } else if (e.length) {
      ;(this.model = t || "rgb"), (n = qa[this.model].channels)
      var s = Z3.call(e, 0, n)
      ;(this.color = j3(s, n)),
        (this.valpha = typeof e[n] == "number" ? e[n] : 1)
    } else if (typeof e == "number")
      (e &= 16777215),
        (this.model = "rgb"),
        (this.color = [(e >> 16) & 255, (e >> 8) & 255, e & 255]),
        (this.valpha = 1)
    else {
      this.valpha = 1
      var o = Object.keys(e)
      "alpha" in e &&
        (o.splice(o.indexOf("alpha"), 1),
        (this.valpha = typeof e.alpha == "number" ? e.alpha : 0))
      var a = o.sort().join("")
      if (!(a in J3))
        throw new Error(
          "Unable to parse color from object: " + JSON.stringify(e),
        )
      this.model = J3[a]
      var l = qa[this.model].labels,
        c = []
      for (r = 0; r < l.length; r++) c.push(e[l[r]])
      this.color = j3(c)
    }
    if (Uk[this.model])
      for (n = qa[this.model].channels, r = 0; r < n; r++) {
        var u = Uk[this.model][r]
        u && (this.color[r] = u(this.color[r]))
      }
    ;(this.valpha = Math.max(0, Math.min(1, this.valpha))),
      Object.freeze && Object.freeze(this)
  }
  Ms.prototype = {
    toString: function () {
      return this.string()
    },
    toJSON: function () {
      return this[this.model]()
    },
    string: function (e) {
      var t = this.model in Y_.to ? this : this.rgb()
      t = t.round(typeof e == "number" ? e : 1)
      var r = t.valpha === 1 ? t.color : t.color.concat(this.valpha)
      return Y_.to[t.model](r)
    },
    percentString: function (e) {
      var t = this.rgb().round(typeof e == "number" ? e : 1),
        r = t.valpha === 1 ? t.color : t.color.concat(this.valpha)
      return Y_.to.rgb.percent(r)
    },
    array: function () {
      return this.valpha === 1
        ? this.color.slice()
        : this.color.concat(this.valpha)
    },
    object: function () {
      for (
        var e = {},
          t = qa[this.model].channels,
          r = qa[this.model].labels,
          n = 0;
        n < t;
        n++
      )
        e[r[n]] = this.color[n]
      return this.valpha !== 1 && (e.alpha = this.valpha), e
    },
    unitArray: function () {
      var e = this.rgb().color
      return (
        (e[0] /= 255),
        (e[1] /= 255),
        (e[2] /= 255),
        this.valpha !== 1 && e.push(this.valpha),
        e
      )
    },
    unitObject: function () {
      var e = this.rgb().object()
      return (
        (e.r /= 255),
        (e.g /= 255),
        (e.b /= 255),
        this.valpha !== 1 && (e.alpha = this.valpha),
        e
      )
    },
    round: function (e) {
      return (
        (e = Math.max(e || 0, 0)),
        new Ms(this.color.map(Fut(e)).concat(this.valpha), this.model)
      )
    },
    alpha: function (e) {
      return arguments.length
        ? new Ms(this.color.concat(Math.max(0, Math.min(1, e))), this.model)
        : this.valpha
    },
    red: hi("rgb", 0, Ki(255)),
    green: hi("rgb", 1, Ki(255)),
    blue: hi("rgb", 2, Ki(255)),
    hue: hi(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function (e) {
      return ((e % 360) + 360) % 360
    }),
    saturationl: hi("hsl", 1, Ki(100)),
    lightness: hi("hsl", 2, Ki(100)),
    saturationv: hi("hsv", 1, Ki(100)),
    value: hi("hsv", 2, Ki(100)),
    chroma: hi("hcg", 1, Ki(100)),
    gray: hi("hcg", 2, Ki(100)),
    white: hi("hwb", 1, Ki(100)),
    wblack: hi("hwb", 2, Ki(100)),
    cyan: hi("cmyk", 0, Ki(100)),
    magenta: hi("cmyk", 1, Ki(100)),
    yellow: hi("cmyk", 2, Ki(100)),
    black: hi("cmyk", 3, Ki(100)),
    x: hi("xyz", 0, Ki(100)),
    y: hi("xyz", 1, Ki(100)),
    z: hi("xyz", 2, Ki(100)),
    l: hi("lab", 0, Ki(100)),
    a: hi("lab", 1),
    b: hi("lab", 2),
    keyword: function (e) {
      return arguments.length ? new Ms(e) : qa[this.model].keyword(this.color)
    },
    hex: function (e) {
      return arguments.length ? new Ms(e) : Y_.to.hex(this.rgb().round().color)
    },
    rgbNumber: function () {
      var e = this.rgb().color
      return ((e[0] & 255) << 16) | ((e[1] & 255) << 8) | (e[2] & 255)
    },
    luminosity: function () {
      for (var e = this.rgb().color, t = [], r = 0; r < e.length; r++) {
        var n = e[r] / 255
        t[r] = n <= 0.03928 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4)
      }
      return 0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]
    },
    contrast: function (e) {
      var t = this.luminosity(),
        r = e.luminosity()
      return t > r ? (t + 0.05) / (r + 0.05) : (r + 0.05) / (t + 0.05)
    },
    level: function (e) {
      var t = this.contrast(e)
      return t >= 7.1 ? "AAA" : t >= 4.5 ? "AA" : ""
    },
    isDark: function () {
      var e = this.rgb().color,
        t = (e[0] * 299 + e[1] * 587 + e[2] * 114) / 1e3
      return t < 128
    },
    isLight: function () {
      return !this.isDark()
    },
    negate: function () {
      for (var e = this.rgb(), t = 0; t < 3; t++) e.color[t] = 255 - e.color[t]
      return e
    },
    lighten: function (e) {
      var t = this.hsl()
      return (t.color[2] += t.color[2] * e), t
    },
    darken: function (e) {
      var t = this.hsl()
      return (t.color[2] -= t.color[2] * e), t
    },
    saturate: function (e) {
      var t = this.hsl()
      return (t.color[1] += t.color[1] * e), t
    },
    desaturate: function (e) {
      var t = this.hsl()
      return (t.color[1] -= t.color[1] * e), t
    },
    whiten: function (e) {
      var t = this.hwb()
      return (t.color[1] += t.color[1] * e), t
    },
    blacken: function (e) {
      var t = this.hwb()
      return (t.color[2] += t.color[2] * e), t
    },
    grayscale: function () {
      var e = this.rgb().color,
        t = e[0] * 0.3 + e[1] * 0.59 + e[2] * 0.11
      return Ms.rgb(t, t, t)
    },
    fade: function (e) {
      return this.alpha(this.valpha - this.valpha * e)
    },
    opaquer: function (e) {
      return this.alpha(this.valpha + this.valpha * e)
    },
    rotate: function (e) {
      var t = this.hsl(),
        r = t.color[0]
      return (r = (r + e) % 360), (r = r < 0 ? 360 + r : r), (t.color[0] = r), t
    },
    mix: function (e, t) {
      if (!e || !e.rgb)
        throw new Error(
          'Argument to "mix" was not a Color instance, but rather an instance of ' +
            typeof e,
        )
      var r = e.rgb(),
        n = this.rgb(),
        i = t === undefined ? 0.5 : t,
        s = 2 * i - 1,
        o = r.alpha() - n.alpha(),
        a = ((s * o === -1 ? s : (s + o) / (1 + s * o)) + 1) / 2,
        l = 1 - a
      return Ms.rgb(
        a * r.red() + l * n.red(),
        a * r.green() + l * n.green(),
        a * r.blue() + l * n.blue(),
        r.alpha() * i + n.alpha() * (1 - i),
      )
    },
  }
  Object.keys(qa).forEach(function (e) {
    if (bAe.indexOf(e) === -1) {
      var t = qa[e].channels
      ;(Ms.prototype[e] = function () {
        if (this.model === e) return new Ms(this)
        if (arguments.length) return new Ms(arguments, e)
        var r = typeof arguments[t] == "number" ? t : this.valpha
        return new Ms(Qut(qa[this.model][e].raw(this.color)).concat(r), e)
      }),
        (Ms[e] = function (r) {
          return (
            typeof r == "number" && (r = j3(Z3.call(arguments), t)),
            new Ms(r, e)
          )
        })
    }
  })
  function Mut(e, t) {
    return Number(e.toFixed(t))
  }
  function Fut(e) {
    return function (t) {
      return Mut(t, e)
    }
  }
  function hi(e, t, r) {
    return (
      (e = Array.isArray(e) ? e : [e]),
      e.forEach(function (n) {
        ;(Uk[n] || (Uk[n] = []))[t] = r
      }),
      (e = e[0]),
      function (n) {
        var i
        return arguments.length
          ? (r && (n = r(n)), (i = this[e]()), (i.color[t] = n), i)
          : ((i = this[e]().color[t]), r && (i = r(i)), i)
      }
    )
  }
  function Ki(e) {
    return function (t) {
      return Math.max(0, Math.min(e, t))
    }
  }
  function Qut(e) {
    return Array.isArray(e) ? e : [e]
  }
  function j3(e, t) {
    for (var r = 0; r < t; r++) typeof e[r] != "number" && (e[r] = 0)
    return e
  }
  EAe.exports = Ms
})
var wAe = _((u1t, xAe) => {
  "use strict"
  xAe.exports = function (t) {
    for (
      var r = 0, n = 0;
      r < t.length;
      n = t.charCodeAt(r++) + ((n << 5) - n)
    );
    var i = Math.floor(Math.abs(((Math.sin(n) * 1e4) % 1) * 16777216)).toString(
      16,
    )
    return "#" + Array(6 - i.length + 1).join("0") + i
  }
})
var RAe = _((d1t, BAe) => {
  "use strict"
  var SAe = _Ae(),
    IAe = wAe()
  BAe.exports = function (t, r) {
    var n = t.split(r || ":"),
      i = IAe(n[0])
    if (!n.length) return i
    for (var s = 0, o = n.length - 1; s < o; s++)
      i = SAe(i)
        .mix(SAe(IAe(n[s + 1])))
        .saturate(1)
        .hex()
    return i
  }
})
var TAe = _((f1t, DAe) => {
  "use strict"
  function Pc(e, t) {
    if (t) return new Pc(e).style(t)
    if (!(this instanceof Pc)) return new Pc(e)
    this.text = e
  }
  Pc.prototype.prefix = "\x1B["
  Pc.prototype.suffix = "m"
  Pc.prototype.hex = function (t) {
    ;(t = t[0] === "#" ? t.substring(1) : t),
      t.length === 3 &&
        ((t = t.split("")),
        (t[5] = t[2]),
        (t[4] = t[2]),
        (t[3] = t[1]),
        (t[2] = t[1]),
        (t[1] = t[0]),
        (t = t.join("")))
    var r = t.substring(0, 2),
      n = t.substring(2, 4),
      i = t.substring(4, 6)
    return [parseInt(r, 16), parseInt(n, 16), parseInt(i, 16)]
  }
  Pc.prototype.rgb = function (t, r, n) {
    var i = (t / 255) * 5,
      s = (r / 255) * 5,
      o = (n / 255) * 5
    return this.ansi(i, s, o)
  }
  Pc.prototype.ansi = function (t, r, n) {
    var i = Math.round(t),
      s = Math.round(r),
      o = Math.round(n)
    return 16 + i * 36 + s * 6 + o
  }
  Pc.prototype.reset = function () {
    return this.prefix + "39;49" + this.suffix
  }
  Pc.prototype.style = function (t) {
    return (
      this.prefix +
      "38;5;" +
      this.rgb.apply(this, this.hex(t)) +
      this.suffix +
      this.text +
      this.reset()
    )
  }
  DAe.exports = Pc
})
var MAe = _((h1t, kAe) => {
  "use strict"
  var Nut = RAe(),
    Put = TAe()
  kAe.exports = function (t, r) {
    var n = r.namespace,
      i = r.colors !== false ? Put(n + ":", Nut(n)) : n + ":"
    return (t[0] = i + " " + t[0]), t
  }
})
var QAe = _((g1t, FAe) => {
  "use strict"
  FAe.exports = function (t, r) {
    if (!r) return false
    for (var n = r.split(/[\s,]+/), i = 0; i < n.length; i++) {
      if (((r = n[i].replace("*", ".*?")), r.charAt(0) === "-")) {
        if (new RegExp("^" + r.substr(1) + "$").test(t)) return false
        continue
      }
      if (new RegExp("^" + r + "$").test(t)) return true
    }
    return false
  }
})
var PAe = _((p1t, NAe) => {
  "use strict"
  var Lut = QAe()
  NAe.exports = function (t) {
    return function (n) {
      try {
        return Lut(n, t())
      } catch {}
      return false
    }
  }
})
var UAe = _((m1t, LAe) => {
  "use strict"
  var Uut = PAe()
  LAe.exports = Uut(function () {
    return process.env.DEBUG || process.env.DIAGNOSTICS
  })
})
var qAe = _((A1t, OAe) => {
  "use strict"
  OAe.exports = function (e, t) {
    try {
      Function.prototype.apply.call(console.log, console, t)
    } catch {}
  }
})
var HAe = _((y1t, VAe) => {
  "use strict"
  var Out = Y3(),
    qut = require("tty").isatty(1),
    Ok = Out(function e(t, r) {
      return (
        (r = r || {}),
        (r.colors = "colors" in r ? r.colors : qut),
        (r.namespace = t),
        (r.prod = false),
        (r.dev = true),
        !e.enabled(t) && !(r.force || e.force) ? e.nope(r) : e.yep(r)
      )
    })
  Ok.modify(MAe())
  Ok.use(UAe())
  Ok.set(qAe())
  VAe.exports = Ok
})
var K_ = _((v1t, X3) => {
  "use strict"
  process.env.NODE_ENV === "production"
    ? (X3.exports = Xme())
    : (X3.exports = HAe())
})
var GAe = _((C1t, WAe) => {
  "use strict"
  var eG = require("fs"),
    { StringDecoder: Vut } = require("string_decoder"),
    { Stream: Hut } = Hy()
  function Wut() {}
  WAe.exports = (e, t) => {
    let r = Buffer.alloc(65536),
      n = new Vut("utf8"),
      i = new Hut(),
      s = "",
      o = 0,
      a = 0
    return (
      e.start === -1 && delete e.start,
      (i.readable = true),
      (i.destroy = () => {
        ;(i.destroyed = true), i.emit("end"), i.emit("close")
      }),
      eG.open(e.file, "a+", "0644", (l, c) => {
        if (l) {
          t ? t(l) : i.emit("error", l), i.destroy()
          return
        }
        ;(function u() {
          if (i.destroyed) {
            eG.close(c, Wut)
            return
          }
          return eG.read(c, r, 0, r.length, o, (f, p) => {
            if (f) {
              t ? t(f) : i.emit("error", f), i.destroy()
              return
            }
            if (!p)
              return (
                s &&
                  ((e.start == null || a > e.start) &&
                    (t ? t(null, s) : i.emit("line", s)),
                  a++,
                  (s = "")),
                setTimeout(u, 1e3)
              )
            let g = n.write(r.slice(0, p))
            t || i.emit("data", g), (g = (s + g).split(/\n+/))
            let m = g.length - 1,
              y = 0
            for (; y < m; y++)
              (e.start == null || a > e.start) &&
                (t ? t(null, g[y]) : i.emit("line", g[y])),
                a++
            return (s = g[m]), (o += p), u()
          })
        })()
      }),
      t ? i.destroy : i
    )
  }
})
var KAe = _((E1t, YAe) => {
  "use strict"
  var sf = require("fs"),
    Zs = require("path"),
    Gut = Ume(),
    $ut = require("zlib"),
    { MESSAGE: Yut } = Qi(),
    { Stream: Kut, PassThrough: $Ae } = Hy(),
    zut = Yh(),
    Lc = K_()("winston:file"),
    Jut = require("os"),
    jut = GAe()
  YAe.exports = class extends zut {
    constructor(t = {}) {
      super(t), (this.name = t.name || "file")
      function r(n, ...i) {
        i.slice(1).forEach((s) => {
          if (t[s]) throw new Error(`Cannot set ${s} and ${n} together`)
        })
      }
      if (
        ((this._stream = new $Ae()),
        this._stream.setMaxListeners(30),
        (this._onError = this._onError.bind(this)),
        t.filename || t.dirname)
      )
        r("filename or dirname", "stream"),
          (this._basename = this.filename =
            t.filename ? Zs.basename(t.filename) : "winston.log"),
          (this.dirname = t.dirname || Zs.dirname(t.filename)),
          (this.options = t.options || { flags: "a" })
      else if (t.stream)
        console.warn(
          "options.stream will be removed in winston@4. Use winston.transports.Stream",
        ),
          r("stream", "filename", "maxsize"),
          (this._dest = this._stream.pipe(this._setupStream(t.stream))),
          (this.dirname = Zs.dirname(this._dest.path))
      else throw new Error("Cannot log to file without filename or stream.")
      ;(this.maxsize = t.maxsize || null),
        (this.rotationFormat = t.rotationFormat || false),
        (this.zippedArchive = t.zippedArchive || false),
        (this.maxFiles = t.maxFiles || null),
        (this.eol = typeof t.eol == "string" ? t.eol : Jut.EOL),
        (this.tailable = t.tailable || false),
        (this.lazy = t.lazy || false),
        (this._size = 0),
        (this._pendingSize = 0),
        (this._created = 0),
        (this._drain = false),
        (this._opening = false),
        (this._ending = false),
        (this._fileExist = false),
        this.dirname && this._createLogDirIfNotExist(this.dirname),
        this.lazy || this.open()
    }
    finishIfEnding() {
      this._ending &&
        (this._opening
          ? this.once("open", () => {
              this._stream.once("finish", () => this.emit("finish")),
                setImmediate(() => this._stream.end())
            })
          : (this._stream.once("finish", () => this.emit("finish")),
            setImmediate(() => this._stream.end())))
    }
    log(t, r = () => {}) {
      if (this.silent) return r(), true
      if (this._drain) {
        this._stream.once("drain", () => {
          ;(this._drain = false), this.log(t, r)
        })
        return
      }
      if (this._rotate) {
        this._stream.once("rotate", () => {
          ;(this._rotate = false), this.log(t, r)
        })
        return
      }
      if (this.lazy) {
        if (!this._fileExist) {
          this._opening || this.open(),
            this.once("open", () => {
              ;(this._fileExist = true), this.log(t, r)
            })
          return
        }
        if (this._needsNewFile(this._pendingSize)) {
          this._dest.once("close", () => {
            this._opening || this.open(),
              this.once("open", () => {
                this.log(t, r)
              })
          })
          return
        }
      }
      let n = `${t[Yut]}${this.eol}`,
        i = Buffer.byteLength(n)
      function s() {
        if (
          ((this._size += i),
          (this._pendingSize -= i),
          Lc("logged %s %s", this._size, n),
          this.emit("logged", t),
          !this._rotate && !this._opening && this._needsNewFile())
        ) {
          if (this.lazy) {
            this._endStream(() => {
              this.emit("fileclosed")
            })
            return
          }
          ;(this._rotate = true), this._endStream(() => this._rotateFile())
        }
      }
      ;(this._pendingSize += i),
        this._opening &&
          !this.rotatedWhileOpening &&
          this._needsNewFile(this._size + this._pendingSize) &&
          (this.rotatedWhileOpening = true)
      let o = this._stream.write(n, s.bind(this))
      return (
        o
          ? r()
          : ((this._drain = true),
            this._stream.once("drain", () => {
              ;(this._drain = false), r()
            })),
        Lc("written", o, this._drain),
        this.finishIfEnding(),
        o
      )
    }
    query(t, r) {
      typeof t == "function" && ((r = t), (t = {})), (t = f(t))
      let n = Zs.join(this.dirname, this.filename),
        i = "",
        s = [],
        o = 0,
        a = sf.createReadStream(n, { encoding: "utf8" })
      a.on("error", (p) => {
        if ((a.readable && a.destroy(), !!r))
          return p.code !== "ENOENT" ? r(p) : r(null, s)
      }),
        a.on("data", (p) => {
          p = (i + p).split(/\n+/)
          let g = p.length - 1,
            m = 0
          for (; m < g; m++) (!t.start || o >= t.start) && l(p[m]), o++
          i = p[g]
        }),
        a.on("close", () => {
          i && l(i, true),
            t.order === "desc" && (s = s.reverse()),
            r && r(null, s)
        })
      function l(p, g) {
        try {
          let m = JSON.parse(p)
          u(m) && c(m)
        } catch (m) {
          g || a.emit("error", m)
        }
      }
      function c(p) {
        if (t.rows && s.length >= t.rows && t.order !== "desc") {
          a.readable && a.destroy()
          return
        }
        t.fields && (p = t.fields.reduce((g, m) => ((g[m] = p[m]), g), {})),
          t.order === "desc" && s.length >= t.rows && s.shift(),
          s.push(p)
      }
      function u(p) {
        if (!p || typeof p != "object") return
        let g = new Date(p.timestamp)
        if (
          !(
            (t.from && g < t.from) ||
            (t.until && g > t.until) ||
            (t.level && t.level !== p.level)
          )
        )
          return true
      }
      function f(p) {
        return (
          (p = p || {}),
          (p.rows = p.rows || p.limit || 10),
          (p.start = p.start || 0),
          (p.until = p.until || new Date()),
          typeof p.until != "object" && (p.until = new Date(p.until)),
          (p.from = p.from || p.until - 24 * 60 * 60 * 1e3),
          typeof p.from != "object" && (p.from = new Date(p.from)),
          (p.order = p.order || "desc"),
          p
        )
      }
    }
    stream(t = {}) {
      let r = Zs.join(this.dirname, this.filename),
        n = new Kut(),
        i = { file: r, start: t.start }
      return (
        (n.destroy = jut(i, (s, o) => {
          if (s) return n.emit("error", s)
          try {
            n.emit("data", o), (o = JSON.parse(o)), n.emit("log", o)
          } catch (a) {
            n.emit("error", a)
          }
        })),
        n
      )
    }
    open() {
      this.filename &&
        (this._opening ||
          ((this._opening = true),
          this.stat((t, r) => {
            if (t) return this.emit("error", t)
            Lc("stat done: %s { size: %s }", this.filename, r),
              (this._size = r),
              (this._dest = this._createStream(this._stream)),
              (this._opening = false),
              this.once("open", () => {
                this._stream.eventNames().includes("rotate")
                  ? this._stream.emit("rotate")
                  : (this._rotate = false)
              })
          })))
    }
    stat(t) {
      let r = this._getFile(),
        n = Zs.join(this.dirname, r)
      sf.stat(n, (i, s) => {
        if (i && i.code === "ENOENT")
          return Lc("ENOENT\xA0ok", n), (this.filename = r), t(null, 0)
        if (i) return Lc(`err ${i.code} ${n}`), t(i)
        if (!s || this._needsNewFile(s.size))
          return this._incFile(() => this.stat(t))
        ;(this.filename = r), t(null, s.size)
      })
    }
    close(t) {
      this._stream &&
        this._stream.end(() => {
          t && t(), this.emit("flush"), this.emit("closed")
        })
    }
    _needsNewFile(t) {
      return (t = t || this._size), this.maxsize && t >= this.maxsize
    }
    _onError(t) {
      this.emit("error", t)
    }
    _setupStream(t) {
      return t.on("error", this._onError), t
    }
    _cleanupStream(t) {
      return t.removeListener("error", this._onError), t.destroy(), t
    }
    _rotateFile() {
      this._incFile(() => this.open())
    }
    _endStream(t = () => {}) {
      this._dest
        ? (this._stream.unpipe(this._dest),
          this._dest.end(() => {
            this._cleanupStream(this._dest), t()
          }))
        : t()
    }
    _createStream(t) {
      let r = Zs.join(this.dirname, this.filename)
      Lc("create stream start", r, this.options)
      let n = sf
        .createWriteStream(r, this.options)
        .on("error", (i) => Lc(i))
        .on("close", () => Lc("close", n.path, n.bytesWritten))
        .on("open", () => {
          Lc("file open ok", r),
            this.emit("open", r),
            t.pipe(n),
            this.rotatedWhileOpening &&
              ((this._stream = new $Ae()),
              this._stream.setMaxListeners(30),
              this._rotateFile(),
              (this.rotatedWhileOpening = false),
              this._cleanupStream(n),
              t.end())
        })
      if ((Lc("create stream ok", r), this.zippedArchive)) {
        let i = $ut.createGzip()
        return i.pipe(n), i
      }
      return n
    }
    _incFile(t) {
      Lc("_incFile", this.filename)
      let r = Zs.extname(this._basename),
        n = Zs.basename(this._basename, r)
      this.tailable
        ? this._checkMaxFilesTailable(r, n, t)
        : ((this._created += 1), this._checkMaxFilesIncrementing(r, n, t))
    }
    _getFile() {
      let t = Zs.extname(this._basename),
        r = Zs.basename(this._basename, t),
        n = this.rotationFormat ? this.rotationFormat() : this._created,
        i = !this.tailable && this._created ? `${r}${n}${t}` : `${r}${t}`
      return this.zippedArchive && !this.tailable ? `${i}.gz` : i
    }
    _checkMaxFilesIncrementing(t, r, n) {
      if (!this.maxFiles || this._created < this.maxFiles)
        return setImmediate(n)
      let i = this._created - this.maxFiles,
        s = i !== 0 ? i : "",
        o = this.zippedArchive ? ".gz" : "",
        a = `${r}${s}${t}${o}`,
        l = Zs.join(this.dirname, a)
      sf.unlink(l, n)
    }
    _checkMaxFilesTailable(t, r, n) {
      let i = []
      if (!this.maxFiles) return
      let s = this.zippedArchive ? ".gz" : ""
      for (let o = this.maxFiles - 1; o > 1; o--)
        i.push(
          function (a, l) {
            let c = `${r}${a - 1}${t}${s}`,
              u = Zs.join(this.dirname, c)
            sf.exists(u, (f) => {
              if (!f) return l(null)
              ;(c = `${r}${a}${t}${s}`),
                sf.rename(u, Zs.join(this.dirname, c), l)
            })
          }.bind(this, o),
        )
      Gut(i, () => {
        sf.rename(
          Zs.join(this.dirname, `${r}${t}`),
          Zs.join(this.dirname, `${r}1${t}${s}`),
          n,
        )
      })
    }
    _createLogDirIfNotExist(t) {
      sf.existsSync(t) || sf.mkdirSync(t, { recursive: true })
    }
  }
})
var JAe = _((x1t, zAe) => {
  "use strict"
  var Zut = require("http"),
    Xut = require("https"),
    { Stream: edt } = Hy(),
    tdt = Yh(),
    rdt = R_()
  zAe.exports = class extends tdt {
    constructor(t = {}) {
      super(t),
        (this.options = t),
        (this.name = t.name || "http"),
        (this.ssl = !!t.ssl),
        (this.host = t.host || "localhost"),
        (this.port = t.port),
        (this.auth = t.auth),
        (this.path = t.path || ""),
        (this.agent = t.agent),
        (this.headers = t.headers || {}),
        (this.headers["content-type"] = "application/json"),
        (this.batch = t.batch || false),
        (this.batchInterval = t.batchInterval || 5e3),
        (this.batchCount = t.batchCount || 10),
        (this.batchOptions = []),
        (this.batchTimeoutID = -1),
        (this.batchCallback = {}),
        this.port || (this.port = this.ssl ? 443 : 80)
    }
    log(t, r) {
      this._request(t, null, null, (n, i) => {
        i &&
          i.statusCode !== 200 &&
          (n = new Error(`Invalid HTTP Status Code: ${i.statusCode}`)),
          n ? this.emit("warn", n) : this.emit("logged", t)
      }),
        r && setImmediate(r)
    }
    query(t, r) {
      typeof t == "function" && ((r = t), (t = {})),
        (t = { method: "query", params: this.normalizeQuery(t) })
      let n = t.params.auth || null
      delete t.params.auth
      let i = t.params.path || null
      delete t.params.path,
        this._request(t, n, i, (s, o, a) => {
          if (
            (o &&
              o.statusCode !== 200 &&
              (s = new Error(`Invalid HTTP Status Code: ${o.statusCode}`)),
            s)
          )
            return r(s)
          if (typeof a == "string")
            try {
              a = JSON.parse(a)
            } catch (l) {
              return r(l)
            }
          r(null, a)
        })
    }
    stream(t = {}) {
      let r = new edt()
      t = { method: "stream", params: t }
      let n = t.params.path || null
      delete t.params.path
      let i = t.params.auth || null
      delete t.params.auth
      let s = "",
        o = this._request(t, i, n)
      return (
        (r.destroy = () => o.destroy()),
        o.on("data", (a) => {
          a = (s + a).split(/\n+/)
          let l = a.length - 1,
            c = 0
          for (; c < l; c++)
            try {
              r.emit("log", JSON.parse(a[c]))
            } catch (u) {
              r.emit("error", u)
            }
          s = a[l]
        }),
        o.on("error", (a) => r.emit("error", a)),
        r
      )
    }
    _request(t, r, n, i) {
      ;(t = t || {}),
        (r = r || this.auth),
        (n = n || this.path || ""),
        this.batch ? this._doBatch(t, i, r, n) : this._doRequest(t, i, r, n)
    }
    _doBatch(t, r, n, i) {
      if ((this.batchOptions.push(t), this.batchOptions.length === 1)) {
        let s = this
        ;(this.batchCallback = r),
          (this.batchTimeoutID = setTimeout(function () {
            ;(s.batchTimeoutID = -1), s._doBatchRequest(s.batchCallback, n, i)
          }, this.batchInterval))
      }
      this.batchOptions.length === this.batchCount &&
        this._doBatchRequest(this.batchCallback, n, i)
    }
    _doBatchRequest(t, r, n) {
      this.batchTimeoutID > 0 &&
        (clearTimeout(this.batchTimeoutID), (this.batchTimeoutID = -1))
      let i = this.batchOptions.slice()
      ;(this.batchOptions = []), this._doRequest(i, t, r, n)
    }
    _doRequest(t, r, n, i) {
      let s = Object.assign({}, this.headers)
      n && n.bearer && (s.Authorization = `Bearer ${n.bearer}`)
      let o = (this.ssl ? Xut : Zut).request({
        ...this.options,
        method: "POST",
        host: this.host,
        port: this.port,
        path: `/${i.replace(/^\//, "")}`,
        headers: s,
        auth:
          n && n.username && n.password ? `${n.username}:${n.password}` : "",
        agent: this.agent,
      })
      o.on("error", r),
        o.on("response", (a) => a.on("end", () => r(null, a)).resume()),
        o.end(Buffer.from(rdt(t, this.options.replacer), "utf8"))
    }
  }
})
var tG = _((w1t, jAe) => {
  "use strict"
  var Hu = (e) =>
    e !== null && typeof e == "object" && typeof e.pipe == "function"
  Hu.writable = (e) =>
    Hu(e) &&
    e.writable !== false &&
    typeof e._write == "function" &&
    typeof e._writableState == "object"
  Hu.readable = (e) =>
    Hu(e) &&
    e.readable !== false &&
    typeof e._read == "function" &&
    typeof e._readableState == "object"
  Hu.duplex = (e) => Hu.writable(e) && Hu.readable(e)
  Hu.transform = (e) => Hu.duplex(e) && typeof e._transform == "function"
  jAe.exports = Hu
})
var XAe = _((I1t, ZAe) => {
  "use strict"
  var ndt = tG(),
    { MESSAGE: idt } = Qi(),
    sdt = require("os"),
    odt = Yh()
  ZAe.exports = class extends odt {
    constructor(t = {}) {
      if ((super(t), !t.stream || !ndt(t.stream)))
        throw new Error("options.stream is required.")
      ;(this._stream = t.stream),
        this._stream.setMaxListeners(1 / 0),
        (this.isObjectMode = t.stream._writableState.objectMode),
        (this.eol = typeof t.eol == "string" ? t.eol : sdt.EOL)
    }
    log(t, r) {
      if ((setImmediate(() => this.emit("logged", t)), this.isObjectMode)) {
        this._stream.write(t), r && r()
        return
      }
      this._stream.write(`${t[idt]}${this.eol}`), r && r()
    }
  }
})
var e0e = _((z_) => {
  "use strict"
  Object.defineProperty(z_, "Console", {
    configurable: true,
    enumerable: true,
    get() {
      return nme()
    },
  })
  Object.defineProperty(z_, "File", {
    configurable: true,
    enumerable: true,
    get() {
      return KAe()
    },
  })
  Object.defineProperty(z_, "Http", {
    configurable: true,
    enumerable: true,
    get() {
      return JAe()
    },
  })
  Object.defineProperty(z_, "Stream", {
    configurable: true,
    enumerable: true,
    get() {
      return XAe()
    },
  })
})
var Vk = _((J_) => {
  "use strict"
  var qk = r3(),
    { configs: rG } = Qi()
  J_.cli = qk.levels(rG.cli)
  J_.npm = qk.levels(rG.npm)
  J_.syslog = qk.levels(rG.syslog)
  J_.addColors = qk.levels
})
var r0e = _((Hk, t0e) => {
  "use strict"
  Object.defineProperty(Hk, "__esModule", { value: true })
  var adt = Ak(),
    ldt = dm(adt),
    cdt = Ik(),
    udt = dm(cdt),
    ddt = L3(),
    fdt = dm(ddt),
    hdt = Q3(),
    gdt = dm(hdt),
    pdt = N3(),
    mdt = dm(pdt),
    Adt = cm(),
    ydt = dm(Adt),
    vdt = Vy(),
    Cdt = dm(vdt)
  function dm(e) {
    return e && e.__esModule ? e : { default: e }
  }
  function bdt(e, t, r) {
    r = (0, gdt.default)(r)
    var n = 0,
      i = 0,
      { length: s } = e,
      o = false
    s === 0 && r(null)
    function a(l, c) {
      l === false && (o = true),
        o !== true && (l ? r(l) : (++i === s || c === udt.default) && r(null))
    }
    for (; n < s; n++) t(e[n], n, (0, mdt.default)(a))
  }
  function Edt(e, t, r) {
    return (0, fdt.default)(e, 1 / 0, t, r)
  }
  function _dt(e, t, r) {
    var n = (0, ldt.default)(e) ? bdt : Edt
    return n(e, (0, ydt.default)(t), r)
  }
  Hk.default = (0, Cdt.default)(_dt, 3)
  t0e.exports = Hk.default
})
var i0e = _((Wk, n0e) => {
  "use strict"
  Object.defineProperty(Wk, "__esModule", { value: true })
  Wk.default = xdt
  function xdt(e) {
    return (t, r, n) => e(t, n)
  }
  n0e.exports = Wk.default
})
var Yk = _(($k, s0e) => {
  "use strict"
  Object.defineProperty($k, "__esModule", { value: true })
  var wdt = r0e(),
    Sdt = Gk(wdt),
    Idt = i0e(),
    Bdt = Gk(Idt),
    Rdt = cm(),
    Ddt = Gk(Rdt),
    Tdt = Vy(),
    kdt = Gk(Tdt)
  function Gk(e) {
    return e && e.__esModule ? e : { default: e }
  }
  function Mdt(e, t, r) {
    return (0, Sdt.default)(e, (0, Bdt.default)((0, Ddt.default)(t)), r)
  }
  $k.default = (0, kdt.default)(Mdt, 3)
  s0e.exports = $k.default
})
var a0e = _((D1t, o0e) => {
  "use strict"
  var Fdt = Object.prototype.toString
  o0e.exports = function (t) {
    if (typeof t.displayName == "string" && t.constructor.name)
      return t.displayName
    if (typeof t.name == "string" && t.name) return t.name
    if (
      typeof t == "object" &&
      t.constructor &&
      typeof t.constructor.name == "string"
    )
      return t.constructor.name
    var r = t.toString(),
      n = Fdt.call(t).slice(8, -1)
    return (
      n === "Function"
        ? (r = r.substring(r.indexOf("(") + 1, r.indexOf(")")))
        : (r = n),
      r || "anonymous"
    )
  }
})
var nG = _((T1t, l0e) => {
  "use strict"
  var Qdt = a0e()
  l0e.exports = function (t) {
    var r = 0,
      n
    function i() {
      return r || ((r = 1), (n = t.apply(this, arguments)), (t = null)), n
    }
    return (i.displayName = Qdt(t)), i
  }
})
var iG = _((Z_) => {
  "use strict"
  Z_.get = function (e) {
    var t = Error.stackTraceLimit
    Error.stackTraceLimit = 1 / 0
    var r = {},
      n = Error.prepareStackTrace
    ;(Error.prepareStackTrace = function (s, o) {
      return o
    }),
      Error.captureStackTrace(r, e || Z_.get)
    var i = r.stack
    return (Error.prepareStackTrace = n), (Error.stackTraceLimit = t), i
  }
  Z_.parse = function (e) {
    if (!e.stack) return []
    var t = this,
      r = e.stack
        .split(
          `
`,
        )
        .slice(1)
    return r
      .map(function (n) {
        if (n.match(/^\s*[-]{4,}$/))
          return t._createParsedCallSite({
            fileName: n,
            lineNumber: null,
            functionName: null,
            typeName: null,
            methodName: null,
            columnNumber: null,
            native: null,
          })
        var i = n.match(
          /at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/,
        )
        if (i) {
          var s = null,
            o = null,
            a = null,
            l = null,
            c = null,
            u = i[5] === "native"
          if (i[1]) {
            a = i[1]
            var f = a.lastIndexOf(".")
            if ((a[f - 1] == "." && f--, f > 0)) {
              ;(s = a.substr(0, f)), (o = a.substr(f + 1))
              var p = s.indexOf(".Module")
              p > 0 && ((a = a.substr(p + 1)), (s = s.substr(0, p)))
            }
            l = null
          }
          o && ((l = s), (c = o)),
            o === "<anonymous>" && ((c = null), (a = null))
          var g = {
            fileName: i[2] || null,
            lineNumber: parseInt(i[3], 10) || null,
            functionName: a,
            typeName: l,
            methodName: c,
            columnNumber: parseInt(i[4], 10) || null,
            native: u,
          }
          return t._createParsedCallSite(g)
        }
      })
      .filter(function (n) {
        return !!n
      })
  }
  function j_(e) {
    for (var t in e) this[t] = e[t]
  }
  var Ndt = [
      "this",
      "typeName",
      "functionName",
      "methodName",
      "fileName",
      "lineNumber",
      "columnNumber",
      "function",
      "evalOrigin",
    ],
    Pdt = ["topLevel", "eval", "native", "constructor"]
  Ndt.forEach(function (e) {
    ;(j_.prototype[e] = null),
      (j_.prototype["get" + e[0].toUpperCase() + e.substr(1)] = function () {
        return this[e]
      })
  })
  Pdt.forEach(function (e) {
    ;(j_.prototype[e] = false),
      (j_.prototype["is" + e[0].toUpperCase() + e.substr(1)] = function () {
        return this[e]
      })
  })
  Z_._createParsedCallSite = function (e) {
    return new j_(e)
  }
})
var sG = _((F1t, c0e) => {
  "use strict"
  var { Writable: Ldt } = Hy()
  c0e.exports = class extends Ldt {
    constructor(t) {
      if ((super({ objectMode: true }), !t))
        throw new Error("ExceptionStream requires a TransportStream instance.")
      ;(this.handleExceptions = true), (this.transport = t)
    }
    _write(t, r, n) {
      return t.exception ? this.transport.log(t, n) : (n(), true)
    }
  }
})
var aG = _((N1t, f0e) => {
  "use strict"
  var u0e = require("os"),
    Udt = Yk(),
    oG = K_()("winston:exception"),
    Odt = nG(),
    d0e = iG(),
    qdt = sG()
  f0e.exports = class {
    constructor(t) {
      if (!t) throw new Error("Logger is required to handle exceptions")
      ;(this.logger = t), (this.handlers = new Map())
    }
    handle(...t) {
      t.forEach((r) => {
        if (Array.isArray(r)) return r.forEach((n) => this._addHandler(n))
        this._addHandler(r)
      }),
        this.catcher ||
          ((this.catcher = this._uncaughtException.bind(this)),
          process.on("uncaughtException", this.catcher))
    }
    unhandle() {
      this.catcher &&
        (process.removeListener("uncaughtException", this.catcher),
        (this.catcher = false),
        Array.from(this.handlers.values()).forEach((t) =>
          this.logger.unpipe(t),
        ))
    }
    getAllInfo(t) {
      let r = null
      return (
        t && (r = typeof t == "string" ? t : t.message),
        {
          error: t,
          level: "error",
          message: [
            `uncaughtException: ${r || "(no error message)"}`,
            (t && t.stack) || "  No stack trace",
          ].join(`
`),
          stack: t && t.stack,
          exception: true,
          date: new Date().toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(t),
        }
      )
    }
    getProcessInfo() {
      return {
        pid: process.pid,
        uid: process.getuid ? process.getuid() : null,
        gid: process.getgid ? process.getgid() : null,
        cwd: process.cwd(),
        execPath: process.execPath,
        version: process.version,
        argv: process.argv,
        memoryUsage: process.memoryUsage(),
      }
    }
    getOsInfo() {
      return { loadavg: u0e.loadavg(), uptime: u0e.uptime() }
    }
    getTrace(t) {
      return (t ? d0e.parse(t) : d0e.get()).map((n) => ({
        column: n.getColumnNumber(),
        file: n.getFileName(),
        function: n.getFunctionName(),
        line: n.getLineNumber(),
        method: n.getMethodName(),
        native: n.isNative(),
      }))
    }
    _addHandler(t) {
      if (!this.handlers.has(t)) {
        t.handleExceptions = true
        let r = new qdt(t)
        this.handlers.set(t, r), this.logger.pipe(r)
      }
    }
    _uncaughtException(t) {
      let r = this.getAllInfo(t),
        n = this._getExceptionHandlers(),
        i =
          typeof this.logger.exitOnError == "function"
            ? this.logger.exitOnError(t)
            : this.logger.exitOnError,
        s
      !n.length &&
        i &&
        (console.warn(
          "winston: exitOnError cannot be true with no exception handlers.",
        ),
        console.warn("winston: not exiting process."),
        (i = false))
      function o() {
        oG("doExit", i),
          oG("process._exiting", process._exiting),
          i && !process._exiting && (s && clearTimeout(s), process.exit(1))
      }
      if (!n || n.length === 0) return process.nextTick(o)
      Udt(
        n,
        (a, l) => {
          let c = Odt(l),
            u = a.transport || a
          function f(p) {
            return () => {
              oG(p), c()
            }
          }
          ;(u._ending = true),
            u.once("finish", f("finished")),
            u.once("error", f("error"))
        },
        () => i && o(),
      ),
        this.logger.log(r),
        i && (s = setTimeout(o, 3e3))
    }
    _getExceptionHandlers() {
      return this.logger.transports.filter(
        (t) => (t.transport || t).handleExceptions,
      )
    }
  }
})
var cG = _((L1t, p0e) => {
  "use strict"
  var h0e = require("os"),
    Vdt = Yk(),
    lG = K_()("winston:rejection"),
    Hdt = nG(),
    g0e = iG(),
    Wdt = sG()
  p0e.exports = class {
    constructor(t) {
      if (!t) throw new Error("Logger is required to handle rejections")
      ;(this.logger = t), (this.handlers = new Map())
    }
    handle(...t) {
      t.forEach((r) => {
        if (Array.isArray(r)) return r.forEach((n) => this._addHandler(n))
        this._addHandler(r)
      }),
        this.catcher ||
          ((this.catcher = this._unhandledRejection.bind(this)),
          process.on("unhandledRejection", this.catcher))
    }
    unhandle() {
      this.catcher &&
        (process.removeListener("unhandledRejection", this.catcher),
        (this.catcher = false),
        Array.from(this.handlers.values()).forEach((t) =>
          this.logger.unpipe(t),
        ))
    }
    getAllInfo(t) {
      let r = null
      return (
        t && (r = typeof t == "string" ? t : t.message),
        {
          error: t,
          level: "error",
          message: [
            `unhandledRejection: ${r || "(no error message)"}`,
            (t && t.stack) || "  No stack trace",
          ].join(`
`),
          stack: t && t.stack,
          exception: true,
          date: new Date().toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(t),
        }
      )
    }
    getProcessInfo() {
      return {
        pid: process.pid,
        uid: process.getuid ? process.getuid() : null,
        gid: process.getgid ? process.getgid() : null,
        cwd: process.cwd(),
        execPath: process.execPath,
        version: process.version,
        argv: process.argv,
        memoryUsage: process.memoryUsage(),
      }
    }
    getOsInfo() {
      return { loadavg: h0e.loadavg(), uptime: h0e.uptime() }
    }
    getTrace(t) {
      return (t ? g0e.parse(t) : g0e.get()).map((n) => ({
        column: n.getColumnNumber(),
        file: n.getFileName(),
        function: n.getFunctionName(),
        line: n.getLineNumber(),
        method: n.getMethodName(),
        native: n.isNative(),
      }))
    }
    _addHandler(t) {
      if (!this.handlers.has(t)) {
        t.handleRejections = true
        let r = new Wdt(t)
        this.handlers.set(t, r), this.logger.pipe(r)
      }
    }
    _unhandledRejection(t) {
      let r = this.getAllInfo(t),
        n = this._getRejectionHandlers(),
        i =
          typeof this.logger.exitOnError == "function"
            ? this.logger.exitOnError(t)
            : this.logger.exitOnError,
        s
      !n.length &&
        i &&
        (console.warn(
          "winston: exitOnError cannot be true with no rejection handlers.",
        ),
        console.warn("winston: not exiting process."),
        (i = false))
      function o() {
        lG("doExit", i),
          lG("process._exiting", process._exiting),
          i && !process._exiting && (s && clearTimeout(s), process.exit(1))
      }
      if (!n || n.length === 0) return process.nextTick(o)
      Vdt(
        n,
        (a, l) => {
          let c = Hdt(l),
            u = a.transport || a
          function f(p) {
            return () => {
              lG(p), c()
            }
          }
          ;(u._ending = true),
            u.once("finish", f("finished")),
            u.once("error", f("error"))
        },
        () => i && o(),
      ),
        this.logger.log(r),
        i && (s = setTimeout(o, 3e3))
    }
    _getRejectionHandlers() {
      return this.logger.transports.filter(
        (t) => (t.transport || t).handleRejections,
      )
    }
  }
})
var A0e = _((U1t, m0e) => {
  "use strict"
  var uG = class {
    constructor(t) {
      let r = Kk()
      if (typeof t != "object" || Array.isArray(t) || !(t instanceof r))
        throw new Error("Logger is required for profiling")
      ;(this.logger = t), (this.start = Date.now())
    }
    done(...t) {
      typeof t[t.length - 1] == "function" &&
        (console.warn(
          "Callback function no longer supported as of winston@3.0.0",
        ),
        t.pop())
      let r = typeof t[t.length - 1] == "object" ? t.pop() : {}
      return (
        (r.level = r.level || "info"),
        (r.durationMs = Date.now() - this.start),
        this.logger.write(r)
      )
    }
  }
  m0e.exports = uG
})
var Kk = _((O1t, b0e) => {
  "use strict"
  var { Stream: Gdt, Transform: $dt } = Hy(),
    y0e = Yk(),
    { LEVEL: Wu, SPLAT: v0e } = Qi(),
    C0e = tG(),
    Ydt = aG(),
    Kdt = cG(),
    zdt = k3(),
    Jdt = A0e(),
    { warn: jdt } = n3(),
    Zdt = Vk(),
    Xdt = /%[scdjifoO%]/g,
    zk = class extends $dt {
      constructor(t) {
        super({ objectMode: true }), this.configure(t)
      }
      child(t) {
        let r = this
        return Object.create(r, {
          write: {
            value: function (n) {
              let i = Object.assign({}, t, n)
              n instanceof Error &&
                ((i.stack = n.stack), (i.message = n.message)),
                r.write(i)
            },
          },
        })
      }
      configure({
        silent: t,
        format: r,
        defaultMeta: n,
        levels: i,
        level: s = "info",
        exitOnError: o = true,
        transports: a,
        colors: l,
        emitErrs: c,
        formatters: u,
        padLevels: f,
        rewriters: p,
        stripColors: g,
        exceptionHandlers: m,
        rejectionHandlers: y,
      } = {}) {
        if (
          (this.transports.length && this.clear(),
          (this.silent = t),
          (this.format = r || this.format || j5()()),
          (this.defaultMeta = n || null),
          (this.levels = i || this.levels || Zdt.npm.levels),
          (this.level = s),
          this.exceptions && this.exceptions.unhandle(),
          this.rejections && this.rejections.unhandle(),
          (this.exceptions = new Ydt(this)),
          (this.rejections = new Kdt(this)),
          (this.profilers = {}),
          (this.exitOnError = o),
          a &&
            ((a = Array.isArray(a) ? a : [a]), a.forEach((v) => this.add(v))),
          l || c || u || f || p || g)
        )
          throw new Error(
            [
              "{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.",
              "Use a custom winston.format(function) instead.",
              "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md",
            ].join(`
`),
          )
        m && this.exceptions.handle(m), y && this.rejections.handle(y)
      }
      isLevelEnabled(t) {
        let r = dG(this.levels, t)
        if (r === null) return false
        let n = dG(this.levels, this.level)
        return n === null
          ? false
          : !this.transports || this.transports.length === 0
            ? n >= r
            : this.transports.findIndex((s) => {
                let o = dG(this.levels, s.level)
                return o === null && (o = n), o >= r
              }) !== -1
      }
      log(t, r, ...n) {
        if (arguments.length === 1)
          return (t[Wu] = t.level), this._addDefaultMeta(t), this.write(t), this
        if (arguments.length === 2)
          return r && typeof r == "object"
            ? ((r[Wu] = r.level = t),
              this._addDefaultMeta(r),
              this.write(r),
              this)
            : ((r = { [Wu]: t, level: t, message: r }),
              this._addDefaultMeta(r),
              this.write(r),
              this)
        let [i] = n
        if (
          typeof i == "object" &&
          i !== null &&
          !(r && r.match && r.match(Xdt))
        ) {
          let o = Object.assign({}, this.defaultMeta, i, {
            [Wu]: t,
            [v0e]: n,
            level: t,
            message: r,
          })
          return (
            i.message && (o.message = `${o.message} ${i.message}`),
            i.stack && (o.stack = i.stack),
            this.write(o),
            this
          )
        }
        return (
          this.write(
            Object.assign({}, this.defaultMeta, {
              [Wu]: t,
              [v0e]: n,
              level: t,
              message: r,
            }),
          ),
          this
        )
      }
      _transform(t, r, n) {
        if (this.silent) return n()
        t[Wu] || (t[Wu] = t.level),
          !this.levels[t[Wu]] &&
            this.levels[t[Wu]] !== 0 &&
            console.error("[winston] Unknown logger level: %s", t[Wu]),
          this._readableState.pipes ||
            console.error(
              "[winston] Attempt to write logs with no transports, which can increase memory usage: %j",
              t,
            )
        try {
          this.push(this.format.transform(t, this.format.options))
        } finally {
          ;(this._writableState.sync = false), n()
        }
      }
      _final(t) {
        let r = this.transports.slice()
        y0e(
          r,
          (n, i) => {
            if (!n || n.finished) return setImmediate(i)
            n.once("finish", i), n.end()
          },
          t,
        )
      }
      add(t) {
        let r = !C0e(t) || t.log.length > 2 ? new zdt({ transport: t }) : t
        if (!r._writableState || !r._writableState.objectMode)
          throw new Error(
            "Transports must WritableStreams in objectMode. Set { objectMode: true }.",
          )
        return (
          this._onEvent("error", r),
          this._onEvent("warn", r),
          this.pipe(r),
          t.handleExceptions && this.exceptions.handle(),
          t.handleRejections && this.rejections.handle(),
          this
        )
      }
      remove(t) {
        if (!t) return this
        let r = t
        return (
          (!C0e(t) || t.log.length > 2) &&
            (r = this.transports.filter((n) => n.transport === t)[0]),
          r && this.unpipe(r),
          this
        )
      }
      clear() {
        return this.unpipe(), this
      }
      close() {
        return (
          this.exceptions.unhandle(),
          this.rejections.unhandle(),
          this.clear(),
          this.emit("close"),
          this
        )
      }
      setLevels() {
        jdt.deprecated("setLevels")
      }
      query(t, r) {
        typeof t == "function" && ((r = t), (t = {})), (t = t || {})
        let n = {},
          i = Object.assign({}, t.query || {})
        function s(a, l) {
          t.query &&
            typeof a.formatQuery == "function" &&
            (t.query = a.formatQuery(i)),
            a.query(t, (c, u) => {
              if (c) return l(c)
              typeof a.formatResults == "function" &&
                (u = a.formatResults(u, t.format)),
                l(null, u)
            })
        }
        function o(a, l) {
          s(a, (c, u) => {
            l && ((u = c || u), u && (n[a.name] = u), l()), (l = null)
          })
        }
        y0e(
          this.transports.filter((a) => !!a.query),
          o,
          () => r(null, n),
        )
      }
      stream(t = {}) {
        let r = new Gdt(),
          n = []
        return (
          (r._streams = n),
          (r.destroy = () => {
            let i = n.length
            for (; i--; ) n[i].destroy()
          }),
          this.transports
            .filter((i) => !!i.stream)
            .forEach((i) => {
              let s = i.stream(t)
              s &&
                (n.push(s),
                s.on("log", (o) => {
                  ;(o.transport = o.transport || []),
                    o.transport.push(i.name),
                    r.emit("log", o)
                }),
                s.on("error", (o) => {
                  ;(o.transport = o.transport || []),
                    o.transport.push(i.name),
                    r.emit("error", o)
                }))
            }),
          r
        )
      }
      startTimer() {
        return new Jdt(this)
      }
      profile(t, ...r) {
        let n = Date.now()
        if (this.profilers[t]) {
          let i = this.profilers[t]
          delete this.profilers[t],
            typeof r[r.length - 2] == "function" &&
              (console.warn(
                "Callback function no longer supported as of winston@3.0.0",
              ),
              r.pop())
          let s = typeof r[r.length - 1] == "object" ? r.pop() : {}
          return (
            (s.level = s.level || "info"),
            (s.durationMs = n - i),
            (s.message = s.message || t),
            this.write(s)
          )
        }
        return (this.profilers[t] = n), this
      }
      handleExceptions(...t) {
        console.warn(
          "Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()",
        ),
          this.exceptions.handle(...t)
      }
      unhandleExceptions(...t) {
        console.warn(
          "Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()",
        ),
          this.exceptions.unhandle(...t)
      }
      cli() {
        throw new Error(
          [
            "Logger.cli() was removed in winston@3.0.0",
            "Use a custom winston.formats.cli() instead.",
            "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md",
          ].join(`
`),
        )
      }
      _onEvent(t, r) {
        function n(i) {
          t === "error" && !this.transports.includes(r) && this.add(r),
            this.emit(t, i, r)
        }
        r["__winston" + t] ||
          ((r["__winston" + t] = n.bind(this)), r.on(t, r["__winston" + t]))
      }
      _addDefaultMeta(t) {
        this.defaultMeta && Object.assign(t, this.defaultMeta)
      }
    }
  function dG(e, t) {
    let r = e[t]
    return !r && r !== 0 ? null : r
  }
  Object.defineProperty(zk.prototype, "transports", {
    configurable: false,
    enumerable: true,
    get() {
      let { pipes: e } = this._readableState
      return Array.isArray(e) ? e : [e].filter(Boolean)
    },
  })
  b0e.exports = zk
})
var fG = _((q1t, E0e) => {
  "use strict"
  var { LEVEL: eft } = Qi(),
    tft = Vk(),
    rft = Kk(),
    nft = K_()("winston:create-logger")
  function ift(e) {
    return "is" + e.charAt(0).toUpperCase() + e.slice(1) + "Enabled"
  }
  E0e.exports = function (e = {}) {
    e.levels = e.levels || tft.npm.levels
    class t extends rft {
      constructor(i) {
        super(i)
      }
    }
    let r = new t(e)
    return (
      Object.keys(e.levels).forEach(function (n) {
        if ((nft('Define prototype method for "%s"', n), n === "log")) {
          console.warn(
            'Level "log" not defined: conflicts with the method "log". Use a different level name.',
          )
          return
        }
        ;(t.prototype[n] = function (...i) {
          let s = this || r
          if (i.length === 1) {
            let [o] = i,
              a = (o && o.message && o) || { message: o }
            return (
              (a.level = a[eft] = n),
              s._addDefaultMeta(a),
              s.write(a),
              this || r
            )
          }
          return i.length === 0 ? (s.log(n, ""), s) : s.log(n, ...i)
        }),
          (t.prototype[ift(n)] = function () {
            return (this || r).isLevelEnabled(n)
          })
      }),
      r
    )
  }
})
var x0e = _((H1t, _0e) => {
  "use strict"
  var sft = fG()
  _0e.exports = class {
    constructor(t = {}) {
      ;(this.loggers = new Map()), (this.options = t)
    }
    add(t, r) {
      if (!this.loggers.has(t)) {
        r = Object.assign({}, r || this.options)
        let n = r.transports || this.options.transports
        n
          ? (r.transports = Array.isArray(n) ? n.slice() : [n])
          : (r.transports = [])
        let i = sft(r)
        i.on("close", () => this._delete(t)), this.loggers.set(t, i)
      }
      return this.loggers.get(t)
    }
    get(t, r) {
      return this.add(t, r)
    }
    has(t) {
      return !!this.loggers.has(t)
    }
    close(t) {
      if (t) return this._removeLogger(t)
      this.loggers.forEach((r, n) => this._removeLogger(n))
    }
    _removeLogger(t) {
      if (!this.loggers.has(t)) return
      this.loggers.get(t).close(), this._delete(t)
    }
    _delete(t) {
      this.loggers.delete(t)
    }
  }
})
var S0e = _((In) => {
  "use strict"
  var w0e = r3(),
    { warn: X_ } = n3()
  In.version = rpe().version
  In.transports = e0e()
  In.config = Vk()
  In.addColors = w0e.levels
  In.format = w0e.format
  In.createLogger = fG()
  In.Logger = Kk()
  In.ExceptionHandler = aG()
  In.RejectionHandler = cG()
  In.Container = x0e()
  In.Transport = Yh()
  In.loggers = new In.Container()
  var of = In.createLogger()
  Object.keys(In.config.npm.levels)
    .concat([
      "log",
      "query",
      "stream",
      "add",
      "remove",
      "clear",
      "profile",
      "startTimer",
      "handleExceptions",
      "unhandleExceptions",
      "handleRejections",
      "unhandleRejections",
      "configure",
      "child",
    ])
    .forEach((e) => (In[e] = (...t) => of[e](...t)))
  Object.defineProperty(In, "level", {
    get() {
      return of.level
    },
    set(e) {
      of.level = e
    },
  })
  Object.defineProperty(In, "exceptions", {
    get() {
      return of.exceptions
    },
  })
  ;["exitOnError"].forEach((e) => {
    Object.defineProperty(In, e, {
      get() {
        return of[e]
      },
      set(t) {
        of[e] = t
      },
    })
  })
  Object.defineProperty(In, "default", {
    get() {
      return {
        exceptionHandlers: of.exceptionHandlers,
        rejectionHandlers: of.rejectionHandlers,
        transports: of.transports,
      }
    },
  })
  X_.deprecated(In, "setLevels")
  X_.forFunctions(In, "useFormat", ["cli"])
  X_.forProperties(In, "useFormat", ["padLevels", "stripColors"])
  X_.forFunctions(In, "deprecated", [
    "addRewriter",
    "addFilter",
    "clone",
    "extend",
  ])
  X_.forProperties(In, "deprecated", ["emitErrs", "levelLength"])
})
var getLanguageDefinitions = _((sQt, lft) => {
  lft.exports = [
    {
      name: "C",
      vscode_name: "c",
      type: "programming",
      extensions: [".c", ".cats", ".h", ".idc", ".w"],
    },
    {
      name: "C++",
      vscode_name: "cpp",
      type: "programming",
      extensions: [
        ".cpp",
        ".c++",
        ".cc",
        ".cp",
        ".cxx",
        ".h",
        ".h++",
        ".hh",
        ".hpp",
        ".hxx",
        ".inc",
        ".inl",
        ".ipp",
        ".tcc",
        ".tpp",
      ],
    },
    { name: "Go", vscode_name: "go", type: "programming", extensions: [".go"] },
    {
      name: "Java",
      vscode_name: "java",
      type: "programming",
      extensions: [".java"],
    },
    {
      name: "JavaScript",
      vscode_name: "javascript",
      type: "programming",
      extensions: [
        ".js",
        "._js",
        ".bones",
        ".es",
        ".es6",
        ".frag",
        ".gs",
        ".jake",
        ".jsb",
        ".jscad",
        ".jsfl",
        ".jsm",
        ".jss",
        ".njs",
        ".pac",
        ".sjs",
        ".ssjs",
        ".sublime-build",
        ".sublime-commands",
        ".sublime-completions",
        ".sublime-keymap",
        ".sublime-macro",
        ".sublime-menu",
        ".sublime-mousemap",
        ".sublime-project",
        ".sublime-settings",
        ".sublime-theme",
        ".sublime-workspace",
        ".sublime_metrics",
        ".sublime_session",
        ".xsjs",
        ".xsjslib",
      ],
    },
    {
      name: "Python",
      vscode_name: "python",
      type: "programming",
      extensions: [
        ".py",
        ".bzl",
        ".cgi",
        ".fcgi",
        ".gyp",
        ".lmi",
        ".pyde",
        ".pyp",
        ".pyt",
        ".pyw",
        ".rpy",
        ".tac",
        ".wsgi",
        ".xpy",
      ],
    },
  ]
})
var V0e = _((SNt, q0e) => {
  "use strict"
  var O0e = "Expected a function",
    L0e = NaN,
    pft = "[object Symbol]",
    mft = /^\s+|\s+$/g,
    Aft = /^[-+]0x[0-9a-f]+$/i,
    yft = /^0b[01]+$/i,
    vft = /^0o[0-7]+$/i,
    Cft = parseInt,
    bft =
      typeof global == "object" && global && global.Object === Object && global,
    Eft = typeof self == "object" && self && self.Object === Object && self,
    _ft = bft || Eft || Function("return this")(),
    xft = Object.prototype,
    wft = xft.toString,
    Sft = Math.max,
    Ift = Math.min,
    bG = function () {
      return _ft.Date.now()
    }
  function Bft(e, t, r) {
    var n,
      i,
      s,
      o,
      a,
      l,
      c = 0,
      u = false,
      f = false,
      p = true
    if (typeof e != "function") throw new TypeError(O0e)
    ;(t = U0e(t) || 0),
      fM(r) &&
        ((u = !!r.leading),
        (f = "maxWait" in r),
        (s = f ? Sft(U0e(r.maxWait) || 0, t) : s),
        (p = "trailing" in r ? !!r.trailing : p))
    function g(N) {
      var W = n,
        Z = i
      return (n = i = undefined), (c = N), (o = e.apply(Z, W)), o
    }
    function m(N) {
      return (c = N), (a = setTimeout(C, t)), u ? g(N) : o
    }
    function y(N) {
      var W = N - l,
        Z = N - c,
        te = t - W
      return f ? Ift(te, s - Z) : te
    }
    function v(N) {
      var W = N - l,
        Z = N - c
      return l === undefined || W >= t || W < 0 || (f && Z >= s)
    }
    function C() {
      var N = bG()
      if (v(N)) return E(N)
      a = setTimeout(C, y(N))
    }
    function E(N) {
      return (a = undefined), p && n ? g(N) : ((n = i = undefined), o)
    }
    function w() {
      a !== undefined && clearTimeout(a), (c = 0), (n = l = i = a = undefined)
    }
    function B() {
      return a === undefined ? o : E(bG())
    }
    function T() {
      var N = bG(),
        W = v(N)
      if (((n = arguments), (i = this), (l = N), W)) {
        if (a === undefined) return m(l)
        if (f) return (a = setTimeout(C, t)), g(l)
      }
      return a === undefined && (a = setTimeout(C, t)), o
    }
    return (T.cancel = w), (T.flush = B), T
  }
  function Rft(e, t, r) {
    var n = true,
      i = true
    if (typeof e != "function") throw new TypeError(O0e)
    return (
      fM(r) &&
        ((n = "leading" in r ? !!r.leading : n),
        (i = "trailing" in r ? !!r.trailing : i)),
      Bft(e, t, { leading: n, maxWait: t, trailing: i })
    )
  }
  function fM(e) {
    var t = typeof e
    return !!e && (t == "object" || t == "function")
  }
  function Dft(e) {
    return !!e && typeof e == "object"
  }
  function Tft(e) {
    return typeof e == "symbol" || (Dft(e) && wft.call(e) == pft)
  }
  function U0e(e) {
    if (typeof e == "number") return e
    if (Tft(e)) return L0e
    if (fM(e)) {
      var t = typeof e.valueOf == "function" ? e.valueOf() : e
      e = fM(t) ? t + "" : t
    }
    if (typeof e != "string") return e === 0 ? e : +e
    e = e.replace(mft, "")
    var r = yft.test(e)
    return r || vft.test(e)
      ? Cft(e.slice(2), r ? 2 : 8)
      : Aft.test(e)
        ? L0e
        : +e
  }
  q0e.exports = Rft
})
var W0e = _((INt, H0e) => {
  "use strict"
  var EG = class {
      constructor(t) {
        ;(this.value = t), (this.next = undefined)
      }
    },
    _G = class {
      constructor() {
        this.clear()
      }
      enqueue(t) {
        let r = new EG(t)
        this._head
          ? ((this._tail.next = r), (this._tail = r))
          : ((this._head = r), (this._tail = r)),
          this._size++
      }
      dequeue() {
        let t = this._head
        if (t) return (this._head = this._head.next), this._size--, t.value
      }
      clear() {
        ;(this._head = undefined), (this._tail = undefined), (this._size = 0)
      }
      get size() {
        return this._size
      }
      *[Symbol.iterator]() {
        let t = this._head
        for (; t; ) yield t.value, (t = t.next)
      }
    }
  H0e.exports = _G
})
var $0e = _((BNt, G0e) => {
  "use strict"
  var kft = W0e(),
    Mft = (e) => {
      if (!((Number.isInteger(e) || e === 1 / 0) && e > 0))
        throw new TypeError(
          "Expected `concurrency` to be a number from 1 and up",
        )
      let t = new kft(),
        r = 0,
        n = () => {
          r--, t.size > 0 && t.dequeue()()
        },
        i = async (a, l, ...c) => {
          r++
          let u = (async () => a(...c))()
          l(u)
          try {
            await u
          } catch {}
          n()
        },
        s = (a, l, ...c) => {
          t.enqueue(i.bind(null, a, l, ...c)),
            (async () => (
              await Promise.resolve(), r < e && t.size > 0 && t.dequeue()()
            ))()
        },
        o = (a, ...l) =>
          new Promise((c) => {
            s(a, c, ...l)
          })
      return (
        Object.defineProperties(o, {
          activeCount: { get: () => r },
          pendingCount: { get: () => t.size },
          clearQueue: {
            value: () => {
              t.clear()
            },
          },
        }),
        o
      )
    }
  G0e.exports = Mft
})
var hx = _((L2t, Dye) => {
  "use strict"
  var Zft = "2.0.0",
    Xft = Number.MAX_SAFE_INTEGER || 9007199254740991,
    eht = 16,
    tht = 250,
    rht = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease",
    ]
  Dye.exports = {
    MAX_LENGTH: 256,
    MAX_SAFE_COMPONENT_LENGTH: eht,
    MAX_SAFE_BUILD_LENGTH: tht,
    MAX_SAFE_INTEGER: Xft,
    RELEASE_TYPES: rht,
    SEMVER_SPEC_VERSION: Zft,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2,
  }
})
var gx = _((U2t, Tye) => {
  "use strict"
  var nht =
    typeof process == "object" &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)
      ? (...e) => console.error("SEMVER", ...e)
      : () => {}
  Tye.exports = nht
})
var nv = _((df, kye) => {
  "use strict"
  var {
      MAX_SAFE_COMPONENT_LENGTH: LG,
      MAX_SAFE_BUILD_LENGTH: iht,
      MAX_LENGTH: sht,
    } = hx(),
    oht = gx()
  df = kye.exports = {}
  var aht = (df.re = []),
    lht = (df.safeRe = []),
    Oe = (df.src = []),
    qe = (df.t = {}),
    cht = 0,
    UG = "[a-zA-Z0-9-]",
    uht = [
      ["\\s", 1],
      ["\\d", sht],
      [UG, iht],
    ],
    dht = (e) => {
      for (let [t, r] of uht)
        e = e
          .split(`${t}*`)
          .join(`${t}{0,${r}}`)
          .split(`${t}+`)
          .join(`${t}{1,${r}}`)
      return e
    },
    Lt = (e, t, r) => {
      let n = dht(t),
        i = cht++
      oht(e, i, t),
        (qe[e] = i),
        (Oe[i] = t),
        (aht[i] = new RegExp(t, r ? "g" : undefined)),
        (lht[i] = new RegExp(n, r ? "g" : undefined))
    }
  Lt("NUMERICIDENTIFIER", "0|[1-9]\\d*")
  Lt("NUMERICIDENTIFIERLOOSE", "\\d+")
  Lt("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${UG}*`)
  Lt(
    "MAINVERSION",
    `(${Oe[qe.NUMERICIDENTIFIER]})\\.(${Oe[qe.NUMERICIDENTIFIER]})\\.(${Oe[qe.NUMERICIDENTIFIER]})`,
  )
  Lt(
    "MAINVERSIONLOOSE",
    `(${Oe[qe.NUMERICIDENTIFIERLOOSE]})\\.(${Oe[qe.NUMERICIDENTIFIERLOOSE]})\\.(${Oe[qe.NUMERICIDENTIFIERLOOSE]})`,
  )
  Lt(
    "PRERELEASEIDENTIFIER",
    `(?:${Oe[qe.NUMERICIDENTIFIER]}|${Oe[qe.NONNUMERICIDENTIFIER]})`,
  )
  Lt(
    "PRERELEASEIDENTIFIERLOOSE",
    `(?:${Oe[qe.NUMERICIDENTIFIERLOOSE]}|${Oe[qe.NONNUMERICIDENTIFIER]})`,
  )
  Lt(
    "PRERELEASE",
    `(?:-(${Oe[qe.PRERELEASEIDENTIFIER]}(?:\\.${Oe[qe.PRERELEASEIDENTIFIER]})*))`,
  )
  Lt(
    "PRERELEASELOOSE",
    `(?:-?(${Oe[qe.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${Oe[qe.PRERELEASEIDENTIFIERLOOSE]})*))`,
  )
  Lt("BUILDIDENTIFIER", `${UG}+`)
  Lt(
    "BUILD",
    `(?:\\+(${Oe[qe.BUILDIDENTIFIER]}(?:\\.${Oe[qe.BUILDIDENTIFIER]})*))`,
  )
  Lt(
    "FULLPLAIN",
    `v?${Oe[qe.MAINVERSION]}${Oe[qe.PRERELEASE]}?${Oe[qe.BUILD]}?`,
  )
  Lt("FULL", `^${Oe[qe.FULLPLAIN]}$`)
  Lt(
    "LOOSEPLAIN",
    `[v=\\s]*${Oe[qe.MAINVERSIONLOOSE]}${Oe[qe.PRERELEASELOOSE]}?${Oe[qe.BUILD]}?`,
  )
  Lt("LOOSE", `^${Oe[qe.LOOSEPLAIN]}$`)
  Lt("GTLT", "((?:<|>)?=?)")
  Lt("XRANGEIDENTIFIERLOOSE", `${Oe[qe.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
  Lt("XRANGEIDENTIFIER", `${Oe[qe.NUMERICIDENTIFIER]}|x|X|\\*`)
  Lt(
    "XRANGEPLAIN",
    `[v=\\s]*(${Oe[qe.XRANGEIDENTIFIER]})(?:\\.(${Oe[qe.XRANGEIDENTIFIER]})(?:\\.(${Oe[qe.XRANGEIDENTIFIER]})(?:${Oe[qe.PRERELEASE]})?${Oe[qe.BUILD]}?)?)?`,
  )
  Lt(
    "XRANGEPLAINLOOSE",
    `[v=\\s]*(${Oe[qe.XRANGEIDENTIFIERLOOSE]})(?:\\.(${Oe[qe.XRANGEIDENTIFIERLOOSE]})(?:\\.(${Oe[qe.XRANGEIDENTIFIERLOOSE]})(?:${Oe[qe.PRERELEASELOOSE]})?${Oe[qe.BUILD]}?)?)?`,
  )
  Lt("XRANGE", `^${Oe[qe.GTLT]}\\s*${Oe[qe.XRANGEPLAIN]}$`)
  Lt("XRANGELOOSE", `^${Oe[qe.GTLT]}\\s*${Oe[qe.XRANGEPLAINLOOSE]}$`)
  Lt(
    "COERCEPLAIN",
    `(^|[^\\d])(\\d{1,${LG}})(?:\\.(\\d{1,${LG}}))?(?:\\.(\\d{1,${LG}}))?`,
  )
  Lt("COERCE", `${Oe[qe.COERCEPLAIN]}(?:$|[^\\d])`)
  Lt(
    "COERCEFULL",
    Oe[qe.COERCEPLAIN] +
      `(?:${Oe[qe.PRERELEASE]})?(?:${Oe[qe.BUILD]})?(?:$|[^\\d])`,
  )
  Lt("COERCERTL", Oe[qe.COERCE], true)
  Lt("COERCERTLFULL", Oe[qe.COERCEFULL], true)
  Lt("LONETILDE", "(?:~>?)")
  Lt("TILDETRIM", `(\\s*)${Oe[qe.LONETILDE]}\\s+`, true)
  df.tildeTrimReplace = "$1~"
  Lt("TILDE", `^${Oe[qe.LONETILDE]}${Oe[qe.XRANGEPLAIN]}$`)
  Lt("TILDELOOSE", `^${Oe[qe.LONETILDE]}${Oe[qe.XRANGEPLAINLOOSE]}$`)
  Lt("LONECARET", "(?:\\^)")
  Lt("CARETTRIM", `(\\s*)${Oe[qe.LONECARET]}\\s+`, true)
  df.caretTrimReplace = "$1^"
  Lt("CARET", `^${Oe[qe.LONECARET]}${Oe[qe.XRANGEPLAIN]}$`)
  Lt("CARETLOOSE", `^${Oe[qe.LONECARET]}${Oe[qe.XRANGEPLAINLOOSE]}$`)
  Lt("COMPARATORLOOSE", `^${Oe[qe.GTLT]}\\s*(${Oe[qe.LOOSEPLAIN]})$|^$`)
  Lt("COMPARATOR", `^${Oe[qe.GTLT]}\\s*(${Oe[qe.FULLPLAIN]})$|^$`)
  Lt(
    "COMPARATORTRIM",
    `(\\s*)${Oe[qe.GTLT]}\\s*(${Oe[qe.LOOSEPLAIN]}|${Oe[qe.XRANGEPLAIN]})`,
    true,
  )
  df.comparatorTrimReplace = "$1$2$3"
  Lt(
    "HYPHENRANGE",
    `^\\s*(${Oe[qe.XRANGEPLAIN]})\\s+-\\s+(${Oe[qe.XRANGEPLAIN]})\\s*$`,
  )
  Lt(
    "HYPHENRANGELOOSE",
    `^\\s*(${Oe[qe.XRANGEPLAINLOOSE]})\\s+-\\s+(${Oe[qe.XRANGEPLAINLOOSE]})\\s*$`,
  )
  Lt("STAR", "(<|>)?=?\\s*\\*")
  Lt("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$")
  Lt("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$")
})
var BM = _((O2t, Mye) => {
  "use strict"
  var fht = Object.freeze({ loose: true }),
    hht = Object.freeze({}),
    ght = (e) => (e ? (typeof e != "object" ? fht : e) : hht)
  Mye.exports = ght
})
var OG = _((q2t, Nye) => {
  "use strict"
  var Fye = /^[0-9]+$/,
    Qye = (e, t) => {
      let r = Fye.test(e),
        n = Fye.test(t)
      return (
        r && n && ((e = +e), (t = +t)),
        e === t ? 0 : r && !n ? -1 : n && !r ? 1 : e < t ? -1 : 1
      )
    },
    pht = (e, t) => Qye(t, e)
  Nye.exports = { compareIdentifiers: Qye, rcompareIdentifiers: pht }
})
var Xs = _((V2t, Oye) => {
  "use strict"
  var RM = gx(),
    { MAX_LENGTH: Pye, MAX_SAFE_INTEGER: DM } = hx(),
    { safeRe: Lye, t: Uye } = nv(),
    mht = BM(),
    { compareIdentifiers: iv } = OG(),
    qG = class e {
      constructor(t, r) {
        if (((r = mht(r)), t instanceof e)) {
          if (
            t.loose === !!r.loose &&
            t.includePrerelease === !!r.includePrerelease
          )
            return t
          t = t.version
        } else if (typeof t != "string")
          throw new TypeError(
            `Invalid version. Must be a string. Got type "${typeof t}".`,
          )
        if (t.length > Pye)
          throw new TypeError(`version is longer than ${Pye} characters`)
        RM("SemVer", t, r),
          (this.options = r),
          (this.loose = !!r.loose),
          (this.includePrerelease = !!r.includePrerelease)
        let n = t.trim().match(r.loose ? Lye[Uye.LOOSE] : Lye[Uye.FULL])
        if (!n) throw new TypeError(`Invalid Version: ${t}`)
        if (
          ((this.raw = t),
          (this.major = +n[1]),
          (this.minor = +n[2]),
          (this.patch = +n[3]),
          this.major > DM || this.major < 0)
        )
          throw new TypeError("Invalid major version")
        if (this.minor > DM || this.minor < 0)
          throw new TypeError("Invalid minor version")
        if (this.patch > DM || this.patch < 0)
          throw new TypeError("Invalid patch version")
        n[4]
          ? (this.prerelease = n[4].split(".").map((i) => {
              if (/^[0-9]+$/.test(i)) {
                let s = +i
                if (s >= 0 && s < DM) return s
              }
              return i
            }))
          : (this.prerelease = []),
          (this.build = n[5] ? n[5].split(".") : []),
          this.format()
      }
      format() {
        return (
          (this.version = `${this.major}.${this.minor}.${this.patch}`),
          this.prerelease.length &&
            (this.version += `-${this.prerelease.join(".")}`),
          this.version
        )
      }
      toString() {
        return this.version
      }
      compare(t) {
        if (
          (RM("SemVer.compare", this.version, this.options, t),
          !(t instanceof e))
        ) {
          if (typeof t == "string" && t === this.version) return 0
          t = new e(t, this.options)
        }
        return t.version === this.version
          ? 0
          : this.compareMain(t) || this.comparePre(t)
      }
      compareMain(t) {
        return (
          t instanceof e || (t = new e(t, this.options)),
          iv(this.major, t.major) ||
            iv(this.minor, t.minor) ||
            iv(this.patch, t.patch)
        )
      }
      comparePre(t) {
        if (
          (t instanceof e || (t = new e(t, this.options)),
          this.prerelease.length && !t.prerelease.length)
        )
          return -1
        if (!this.prerelease.length && t.prerelease.length) return 1
        if (!this.prerelease.length && !t.prerelease.length) return 0
        let r = 0
        do {
          let n = this.prerelease[r],
            i = t.prerelease[r]
          if ((RM("prerelease compare", r, n, i), n === undefined && i === undefined))
            return 0
          if (i === undefined) return 1
          if (n === undefined) return -1
          if (n === i) continue
          return iv(n, i)
        } while (++r)
      }
      compareBuild(t) {
        t instanceof e || (t = new e(t, this.options))
        let r = 0
        do {
          let n = this.build[r],
            i = t.build[r]
          if ((RM("build compare", r, n, i), n === undefined && i === undefined))
            return 0
          if (i === undefined) return 1
          if (n === undefined) return -1
          if (n === i) continue
          return iv(n, i)
        } while (++r)
      }
      inc(t, r, n) {
        switch (t) {
          case "premajor":
            ;(this.prerelease.length = 0),
              (this.patch = 0),
              (this.minor = 0),
              this.major++,
              this.inc("pre", r, n)
            break
          case "preminor":
            ;(this.prerelease.length = 0),
              (this.patch = 0),
              this.minor++,
              this.inc("pre", r, n)
            break
          case "prepatch":
            ;(this.prerelease.length = 0),
              this.inc("patch", r, n),
              this.inc("pre", r, n)
            break
          case "prerelease":
            this.prerelease.length === 0 && this.inc("patch", r, n),
              this.inc("pre", r, n)
            break
          case "major":
            ;(this.minor !== 0 ||
              this.patch !== 0 ||
              this.prerelease.length === 0) &&
              this.major++,
              (this.minor = 0),
              (this.patch = 0),
              (this.prerelease = [])
            break
          case "minor":
            ;(this.patch !== 0 || this.prerelease.length === 0) && this.minor++,
              (this.patch = 0),
              (this.prerelease = [])
            break
          case "patch":
            this.prerelease.length === 0 && this.patch++, (this.prerelease = [])
            break
          case "pre": {
            let i = Number(n) ? 1 : 0
            if (!r && n === false)
              throw new Error("invalid increment argument: identifier is empty")
            if (this.prerelease.length === 0) this.prerelease = [i]
            else {
              let s = this.prerelease.length
              for (; --s >= 0; )
                typeof this.prerelease[s] == "number" &&
                  (this.prerelease[s]++, (s = -2))
              if (s === -1) {
                if (r === this.prerelease.join(".") && n === false)
                  throw new Error(
                    "invalid increment argument: identifier already exists",
                  )
                this.prerelease.push(i)
              }
            }
            if (r) {
              let s = [r, i]
              n === false && (s = [r]),
                iv(this.prerelease[0], r) === 0
                  ? isNaN(this.prerelease[1]) && (this.prerelease = s)
                  : (this.prerelease = s)
            }
            break
          }
          default:
            throw new Error(`invalid increment argument: ${t}`)
        }
        return (
          (this.raw = this.format()),
          this.build.length && (this.raw += `+${this.build.join(".")}`),
          this
        )
      }
    }
  Oye.exports = qG
})
var Am = _((H2t, Vye) => {
  "use strict"
  var qye = Xs(),
    Aht = (e, t, r = false) => {
      if (e instanceof qye) return e
      try {
        return new qye(e, t)
      } catch (n) {
        if (!r) return null
        throw n
      }
    }
  Vye.exports = Aht
})
var Wye = _((W2t, Hye) => {
  "use strict"
  var yht = Am(),
    vht = (e, t) => {
      let r = yht(e, t)
      return r ? r.version : null
    }
  Hye.exports = vht
})
var $ye = _((G2t, Gye) => {
  "use strict"
  var Cht = Am(),
    bht = (e, t) => {
      let r = Cht(e.trim().replace(/^[=v]+/, ""), t)
      return r ? r.version : null
    }
  Gye.exports = bht
})
var zye = _(($2t, Kye) => {
  "use strict"
  var Yye = Xs(),
    Eht = (e, t, r, n, i) => {
      typeof r == "string" && ((i = n), (n = r), (r = undefined))
      try {
        return new Yye(e instanceof Yye ? e.version : e, r).inc(t, n, i).version
      } catch {
        return null
      }
    }
  Kye.exports = Eht
})
var Zye = _((Y2t, jye) => {
  "use strict"
  var Jye = Am(),
    _ht = (e, t) => {
      let r = Jye(e, null, true),
        n = Jye(t, null, true),
        i = r.compare(n)
      if (i === 0) return null
      let s = i > 0,
        o = s ? r : n,
        a = s ? n : r,
        l = !!o.prerelease.length
      if (!!a.prerelease.length && !l)
        return !a.patch && !a.minor
          ? "major"
          : o.patch
            ? "patch"
            : o.minor
              ? "minor"
              : "major"
      let u = l ? "pre" : ""
      return r.major !== n.major
        ? u + "major"
        : r.minor !== n.minor
          ? u + "minor"
          : r.patch !== n.patch
            ? u + "patch"
            : "prerelease"
    }
  jye.exports = _ht
})
var eve = _((K2t, Xye) => {
  "use strict"
  var xht = Xs(),
    wht = (e, t) => new xht(e, t).major
  Xye.exports = wht
})
var rve = _((z2t, tve) => {
  "use strict"
  var Sht = Xs(),
    Iht = (e, t) => new Sht(e, t).minor
  tve.exports = Iht
})
var ive = _((J2t, nve) => {
  "use strict"
  var Bht = Xs(),
    Rht = (e, t) => new Bht(e, t).patch
  nve.exports = Rht
})
var ove = _((j2t, sve) => {
  "use strict"
  var Dht = Am(),
    Tht = (e, t) => {
      let r = Dht(e, t)
      return r && r.prerelease.length ? r.prerelease : null
    }
  sve.exports = Tht
})
var Gl = _((Z2t, lve) => {
  "use strict"
  var ave = Xs(),
    kht = (e, t, r) => new ave(e, r).compare(new ave(t, r))
  lve.exports = kht
})
var uve = _((X2t, cve) => {
  "use strict"
  var Mht = Gl(),
    Fht = (e, t, r) => Mht(t, e, r)
  cve.exports = Fht
})
var fve = _((ePt, dve) => {
  "use strict"
  var Qht = Gl(),
    Nht = (e, t) => Qht(e, t, true)
  dve.exports = Nht
})
var TM = _((tPt, gve) => {
  "use strict"
  var hve = Xs(),
    Pht = (e, t, r) => {
      let n = new hve(e, r),
        i = new hve(t, r)
      return n.compare(i) || n.compareBuild(i)
    }
  gve.exports = Pht
})
var mve = _((rPt, pve) => {
  "use strict"
  var Lht = TM(),
    Uht = (e, t) => e.sort((r, n) => Lht(r, n, t))
  pve.exports = Uht
})
var yve = _((nPt, Ave) => {
  "use strict"
  var Oht = TM(),
    qht = (e, t) => e.sort((r, n) => Oht(n, r, t))
  Ave.exports = qht
})
var px = _((iPt, vve) => {
  "use strict"
  var Vht = Gl(),
    Hht = (e, t, r) => Vht(e, t, r) > 0
  vve.exports = Hht
})
var kM = _((sPt, Cve) => {
  "use strict"
  var Wht = Gl(),
    Ght = (e, t, r) => Wht(e, t, r) < 0
  Cve.exports = Ght
})
var VG = _((oPt, bve) => {
  "use strict"
  var $ht = Gl(),
    Yht = (e, t, r) => $ht(e, t, r) === 0
  bve.exports = Yht
})
var HG = _((aPt, Eve) => {
  "use strict"
  var Kht = Gl(),
    zht = (e, t, r) => Kht(e, t, r) !== 0
  Eve.exports = zht
})
var MM = _((lPt, _ve) => {
  "use strict"
  var Jht = Gl(),
    jht = (e, t, r) => Jht(e, t, r) >= 0
  _ve.exports = jht
})
var FM = _((cPt, xve) => {
  "use strict"
  var Zht = Gl(),
    Xht = (e, t, r) => Zht(e, t, r) <= 0
  xve.exports = Xht
})
var WG = _((uPt, wve) => {
  "use strict"
  var egt = VG(),
    tgt = HG(),
    rgt = px(),
    ngt = MM(),
    igt = kM(),
    sgt = FM(),
    ogt = (e, t, r, n) => {
      switch (t) {
        case "===":
          return (
            typeof e == "object" && (e = e.version),
            typeof r == "object" && (r = r.version),
            e === r
          )
        case "!==":
          return (
            typeof e == "object" && (e = e.version),
            typeof r == "object" && (r = r.version),
            e !== r
          )
        case "":
        case "=":
        case "==":
          return egt(e, r, n)
        case "!=":
          return tgt(e, r, n)
        case ">":
          return rgt(e, r, n)
        case ">=":
          return ngt(e, r, n)
        case "<":
          return igt(e, r, n)
        case "<=":
          return sgt(e, r, n)
        default:
          throw new TypeError(`Invalid operator: ${t}`)
      }
    }
  wve.exports = ogt
})
var Ive = _((dPt, Sve) => {
  "use strict"
  var agt = Xs(),
    lgt = Am(),
    { safeRe: QM, t: NM } = nv(),
    cgt = (e, t) => {
      if (e instanceof agt) return e
      if ((typeof e == "number" && (e = String(e)), typeof e != "string"))
        return null
      t = t || {}
      let r = null
      if (!t.rtl)
        r = e.match(t.includePrerelease ? QM[NM.COERCEFULL] : QM[NM.COERCE])
      else {
        let l = t.includePrerelease ? QM[NM.COERCERTLFULL] : QM[NM.COERCERTL],
          c
        for (; (c = l.exec(e)) && (!r || r.index + r[0].length !== e.length); )
          (!r || c.index + c[0].length !== r.index + r[0].length) && (r = c),
            (l.lastIndex = c.index + c[1].length + c[2].length)
        l.lastIndex = -1
      }
      if (r === null) return null
      let n = r[2],
        i = r[3] || "0",
        s = r[4] || "0",
        o = t.includePrerelease && r[5] ? `-${r[5]}` : "",
        a = t.includePrerelease && r[6] ? `+${r[6]}` : ""
      return lgt(`${n}.${i}.${s}${o}${a}`, t)
    }
  Sve.exports = cgt
})
var Rve = _((fPt, Bve) => {
  "use strict"
  var GG = class {
    constructor() {
      ;(this.max = 1e3), (this.map = new Map())
    }
    get(t) {
      let r = this.map.get(t)
      if (r !== undefined) return this.map.delete(t), this.map.set(t, r), r
    }
    delete(t) {
      return this.map.delete(t)
    }
    set(t, r) {
      if (!this.delete(t) && r !== undefined) {
        if (this.map.size >= this.max) {
          let i = this.map.keys().next().value
          this.delete(i)
        }
        this.map.set(t, r)
      }
      return this
    }
  }
  Bve.exports = GG
})
var $l = _((hPt, Mve) => {
  "use strict"
  var ugt = /\s+/g,
    $G = class e {
      constructor(t, r) {
        if (((r = fgt(r)), t instanceof e))
          return t.loose === !!r.loose &&
            t.includePrerelease === !!r.includePrerelease
            ? t
            : new e(t.raw, r)
        if (t instanceof YG)
          return (
            (this.raw = t.value),
            (this.set = [[t]]),
            (this.formatted = undefined),
            this
          )
        if (
          ((this.options = r),
          (this.loose = !!r.loose),
          (this.includePrerelease = !!r.includePrerelease),
          (this.raw = t.trim().replace(ugt, " ")),
          (this.set = this.raw
            .split("||")
            .map((n) => this.parseRange(n.trim()))
            .filter((n) => n.length)),
          !this.set.length)
        )
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
        if (this.set.length > 1) {
          let n = this.set[0]
          if (
            ((this.set = this.set.filter((i) => !Tve(i[0]))),
            this.set.length === 0)
          )
            this.set = [n]
          else if (this.set.length > 1) {
            for (let i of this.set)
              if (i.length === 1 && vgt(i[0])) {
                this.set = [i]
                break
              }
          }
        }
        this.formatted = undefined
      }
      get range() {
        if (this.formatted === undefined) {
          this.formatted = ""
          for (let t = 0; t < this.set.length; t++) {
            t > 0 && (this.formatted += "||")
            let r = this.set[t]
            for (let n = 0; n < r.length; n++)
              n > 0 && (this.formatted += " "),
                (this.formatted += r[n].toString().trim())
          }
        }
        return this.formatted
      }
      format() {
        return this.range
      }
      toString() {
        return this.range
      }
      parseRange(t) {
        let n =
            ((this.options.includePrerelease && Agt) |
              (this.options.loose && ygt)) +
            ":" +
            t,
          i = Dve.get(n)
        if (i) return i
        let s = this.options.loose,
          o = s ? aa[Bo.HYPHENRANGELOOSE] : aa[Bo.HYPHENRANGE]
        ;(t = t.replace(o, Rgt(this.options.includePrerelease))),
          Ln("hyphen replace", t),
          (t = t.replace(aa[Bo.COMPARATORTRIM], ggt)),
          Ln("comparator trim", t),
          (t = t.replace(aa[Bo.TILDETRIM], pgt)),
          Ln("tilde trim", t),
          (t = t.replace(aa[Bo.CARETTRIM], mgt)),
          Ln("caret trim", t)
        let a = t
          .split(" ")
          .map((f) => Cgt(f, this.options))
          .join(" ")
          .split(/\s+/)
          .map((f) => Bgt(f, this.options))
        s &&
          (a = a.filter(
            (f) => (
              Ln("loose invalid filter", f, this.options),
              !!f.match(aa[Bo.COMPARATORLOOSE])
            ),
          )),
          Ln("range list", a)
        let l = new Map(),
          c = a.map((f) => new YG(f, this.options))
        for (let f of c) {
          if (Tve(f)) return [f]
          l.set(f.value, f)
        }
        l.size > 1 && l.has("") && l.delete("")
        let u = [...l.values()]
        return Dve.set(n, u), u
      }
      intersects(t, r) {
        if (!(t instanceof e)) throw new TypeError("a Range is required")
        return this.set.some(
          (n) =>
            kve(n, r) &&
            t.set.some(
              (i) =>
                kve(i, r) && n.every((s) => i.every((o) => s.intersects(o, r))),
            ),
        )
      }
      test(t) {
        if (!t) return false
        if (typeof t == "string")
          try {
            t = new hgt(t, this.options)
          } catch {
            return false
          }
        for (let r = 0; r < this.set.length; r++)
          if (Dgt(this.set[r], t, this.options)) return true
        return false
      }
    }
  Mve.exports = $G
  var dgt = Rve(),
    Dve = new dgt(),
    fgt = BM(),
    YG = mx(),
    Ln = gx(),
    hgt = Xs(),
    {
      safeRe: aa,
      t: Bo,
      comparatorTrimReplace: ggt,
      tildeTrimReplace: pgt,
      caretTrimReplace: mgt,
    } = nv(),
    { FLAG_INCLUDE_PRERELEASE: Agt, FLAG_LOOSE: ygt } = hx(),
    Tve = (e) => e.value === "<0.0.0-0",
    vgt = (e) => e.value === "",
    kve = (e, t) => {
      let r = true,
        n = e.slice(),
        i = n.pop()
      for (; r && n.length; )
        (r = n.every((s) => i.intersects(s, t))), (i = n.pop())
      return r
    },
    Cgt = (e, t) => (
      Ln("comp", e, t),
      (e = _gt(e, t)),
      Ln("caret", e),
      (e = bgt(e, t)),
      Ln("tildes", e),
      (e = wgt(e, t)),
      Ln("xrange", e),
      (e = Igt(e, t)),
      Ln("stars", e),
      e
    ),
    Ro = (e) => !e || e.toLowerCase() === "x" || e === "*",
    bgt = (e, t) =>
      e
        .trim()
        .split(/\s+/)
        .map((r) => Egt(r, t))
        .join(" "),
    Egt = (e, t) => {
      let r = t.loose ? aa[Bo.TILDELOOSE] : aa[Bo.TILDE]
      return e.replace(r, (n, i, s, o, a) => {
        Ln("tilde", e, n, i, s, o, a)
        let l
        return (
          Ro(i)
            ? (l = "")
            : Ro(s)
              ? (l = `>=${i}.0.0 <${+i + 1}.0.0-0`)
              : Ro(o)
                ? (l = `>=${i}.${s}.0 <${i}.${+s + 1}.0-0`)
                : a
                  ? (Ln("replaceTilde pr", a),
                    (l = `>=${i}.${s}.${o}-${a} <${i}.${+s + 1}.0-0`))
                  : (l = `>=${i}.${s}.${o} <${i}.${+s + 1}.0-0`),
          Ln("tilde return", l),
          l
        )
      })
    },
    _gt = (e, t) =>
      e
        .trim()
        .split(/\s+/)
        .map((r) => xgt(r, t))
        .join(" "),
    xgt = (e, t) => {
      Ln("caret", e, t)
      let r = t.loose ? aa[Bo.CARETLOOSE] : aa[Bo.CARET],
        n = t.includePrerelease ? "-0" : ""
      return e.replace(r, (i, s, o, a, l) => {
        Ln("caret", e, i, s, o, a, l)
        let c
        return (
          Ro(s)
            ? (c = "")
            : Ro(o)
              ? (c = `>=${s}.0.0${n} <${+s + 1}.0.0-0`)
              : Ro(a)
                ? s === "0"
                  ? (c = `>=${s}.${o}.0${n} <${s}.${+o + 1}.0-0`)
                  : (c = `>=${s}.${o}.0${n} <${+s + 1}.0.0-0`)
                : l
                  ? (Ln("replaceCaret pr", l),
                    s === "0"
                      ? o === "0"
                        ? (c = `>=${s}.${o}.${a}-${l} <${s}.${o}.${+a + 1}-0`)
                        : (c = `>=${s}.${o}.${a}-${l} <${s}.${+o + 1}.0-0`)
                      : (c = `>=${s}.${o}.${a}-${l} <${+s + 1}.0.0-0`))
                  : (Ln("no pr"),
                    s === "0"
                      ? o === "0"
                        ? (c = `>=${s}.${o}.${a}${n} <${s}.${o}.${+a + 1}-0`)
                        : (c = `>=${s}.${o}.${a}${n} <${s}.${+o + 1}.0-0`)
                      : (c = `>=${s}.${o}.${a} <${+s + 1}.0.0-0`)),
          Ln("caret return", c),
          c
        )
      })
    },
    wgt = (e, t) => (
      Ln("replaceXRanges", e, t),
      e
        .split(/\s+/)
        .map((r) => Sgt(r, t))
        .join(" ")
    ),
    Sgt = (e, t) => {
      e = e.trim()
      let r = t.loose ? aa[Bo.XRANGELOOSE] : aa[Bo.XRANGE]
      return e.replace(r, (n, i, s, o, a, l) => {
        Ln("xRange", e, n, i, s, o, a, l)
        let c = Ro(s),
          u = c || Ro(o),
          f = u || Ro(a),
          p = f
        return (
          i === "=" && p && (i = ""),
          (l = t.includePrerelease ? "-0" : ""),
          c
            ? i === ">" || i === "<"
              ? (n = "<0.0.0-0")
              : (n = "*")
            : i && p
              ? (u && (o = 0),
                (a = 0),
                i === ">"
                  ? ((i = ">="),
                    u
                      ? ((s = +s + 1), (o = 0), (a = 0))
                      : ((o = +o + 1), (a = 0)))
                  : i === "<=" && ((i = "<"), u ? (s = +s + 1) : (o = +o + 1)),
                i === "<" && (l = "-0"),
                (n = `${i + s}.${o}.${a}${l}`))
              : u
                ? (n = `>=${s}.0.0${l} <${+s + 1}.0.0-0`)
                : f && (n = `>=${s}.${o}.0${l} <${s}.${+o + 1}.0-0`),
          Ln("xRange return", n),
          n
        )
      })
    },
    Igt = (e, t) => (
      Ln("replaceStars", e, t), e.trim().replace(aa[Bo.STAR], "")
    ),
    Bgt = (e, t) => (
      Ln("replaceGTE0", e, t),
      e.trim().replace(aa[t.includePrerelease ? Bo.GTE0PRE : Bo.GTE0], "")
    ),
    Rgt = (e) => (t, r, n, i, s, o, a, l, c, u, f, p) => (
      Ro(n)
        ? (r = "")
        : Ro(i)
          ? (r = `>=${n}.0.0${e ? "-0" : ""}`)
          : Ro(s)
            ? (r = `>=${n}.${i}.0${e ? "-0" : ""}`)
            : o
              ? (r = `>=${r}`)
              : (r = `>=${r}${e ? "-0" : ""}`),
      Ro(c)
        ? (l = "")
        : Ro(u)
          ? (l = `<${+c + 1}.0.0-0`)
          : Ro(f)
            ? (l = `<${c}.${+u + 1}.0-0`)
            : p
              ? (l = `<=${c}.${u}.${f}-${p}`)
              : e
                ? (l = `<${c}.${u}.${+f + 1}-0`)
                : (l = `<=${l}`),
      `${r} ${l}`.trim()
    ),
    Dgt = (e, t, r) => {
      for (let n = 0; n < e.length; n++) if (!e[n].test(t)) return false
      if (t.prerelease.length && !r.includePrerelease) {
        for (let n = 0; n < e.length; n++)
          if (
            (Ln(e[n].semver),
            e[n].semver !== YG.ANY && e[n].semver.prerelease.length > 0)
          ) {
            let i = e[n].semver
            if (
              i.major === t.major &&
              i.minor === t.minor &&
              i.patch === t.patch
            )
              return true
          }
        return false
      }
      return true
    }
})
var mx = _((gPt, Uve) => {
  "use strict"
  var Ax = Symbol("SemVer ANY"),
    JG = class e {
      static get ANY() {
        return Ax
      }
      constructor(t, r) {
        if (((r = Fve(r)), t instanceof e)) {
          if (t.loose === !!r.loose) return t
          t = t.value
        }
        ;(t = t.trim().split(/\s+/).join(" ")),
          zG("comparator", t, r),
          (this.options = r),
          (this.loose = !!r.loose),
          this.parse(t),
          this.semver === Ax
            ? (this.value = "")
            : (this.value = this.operator + this.semver.version),
          zG("comp", this)
      }
      parse(t) {
        let r = this.options.loose
            ? Qve[Nve.COMPARATORLOOSE]
            : Qve[Nve.COMPARATOR],
          n = t.match(r)
        if (!n) throw new TypeError(`Invalid comparator: ${t}`)
        ;(this.operator = n[1] !== undefined ? n[1] : ""),
          this.operator === "=" && (this.operator = ""),
          n[2]
            ? (this.semver = new Pve(n[2], this.options.loose))
            : (this.semver = Ax)
      }
      toString() {
        return this.value
      }
      test(t) {
        if (
          (zG("Comparator.test", t, this.options.loose),
          this.semver === Ax || t === Ax)
        )
          return true
        if (typeof t == "string")
          try {
            t = new Pve(t, this.options)
          } catch {
            return false
          }
        return KG(t, this.operator, this.semver, this.options)
      }
      intersects(t, r) {
        if (!(t instanceof e)) throw new TypeError("a Comparator is required")
        return this.operator === ""
          ? this.value === ""
            ? true
            : new Lve(t.value, r).test(this.value)
          : t.operator === ""
            ? t.value === ""
              ? true
              : new Lve(this.value, r).test(t.semver)
            : ((r = Fve(r)),
              (r.includePrerelease &&
                (this.value === "<0.0.0-0" || t.value === "<0.0.0-0")) ||
              (!r.includePrerelease &&
                (this.value.startsWith("<0.0.0") ||
                  t.value.startsWith("<0.0.0")))
                ? false
                : !!(
                    (this.operator.startsWith(">") &&
                      t.operator.startsWith(">")) ||
                    (this.operator.startsWith("<") &&
                      t.operator.startsWith("<")) ||
                    (this.semver.version === t.semver.version &&
                      this.operator.includes("=") &&
                      t.operator.includes("=")) ||
                    (KG(this.semver, "<", t.semver, r) &&
                      this.operator.startsWith(">") &&
                      t.operator.startsWith("<")) ||
                    (KG(this.semver, ">", t.semver, r) &&
                      this.operator.startsWith("<") &&
                      t.operator.startsWith(">"))
                  ))
      }
    }
  Uve.exports = JG
  var Fve = BM(),
    { safeRe: Qve, t: Nve } = nv(),
    KG = WG(),
    zG = gx(),
    Pve = Xs(),
    Lve = $l()
})
var yx = _((pPt, Ove) => {
  "use strict"
  var Tgt = $l(),
    kgt = (e, t, r) => {
      try {
        t = new Tgt(t, r)
      } catch {
        return false
      }
      return t.test(e)
    }
  Ove.exports = kgt
})
var Vve = _((mPt, qve) => {
  "use strict"
  var Mgt = $l(),
    Fgt = (e, t) =>
      new Mgt(e, t).set.map((r) =>
        r
          .map((n) => n.value)
          .join(" ")
          .trim()
          .split(" "),
      )
  qve.exports = Fgt
})
var Wve = _((APt, Hve) => {
  "use strict"
  var Qgt = Xs(),
    Ngt = $l(),
    Pgt = (e, t, r) => {
      let n = null,
        i = null,
        s = null
      try {
        s = new Ngt(t, r)
      } catch {
        return null
      }
      return (
        e.forEach((o) => {
          s.test(o) &&
            (!n || i.compare(o) === -1) &&
            ((n = o), (i = new Qgt(n, r)))
        }),
        n
      )
    }
  Hve.exports = Pgt
})
var $ve = _((yPt, Gve) => {
  "use strict"
  var Lgt = Xs(),
    Ugt = $l(),
    Ogt = (e, t, r) => {
      let n = null,
        i = null,
        s = null
      try {
        s = new Ugt(t, r)
      } catch {
        return null
      }
      return (
        e.forEach((o) => {
          s.test(o) &&
            (!n || i.compare(o) === 1) &&
            ((n = o), (i = new Lgt(n, r)))
        }),
        n
      )
    }
  Gve.exports = Ogt
})
var zve = _((vPt, Kve) => {
  "use strict"
  var jG = Xs(),
    qgt = $l(),
    Yve = px(),
    Vgt = (e, t) => {
      e = new qgt(e, t)
      let r = new jG("0.0.0")
      if (e.test(r) || ((r = new jG("0.0.0-0")), e.test(r))) return r
      r = null
      for (let n = 0; n < e.set.length; ++n) {
        let i = e.set[n],
          s = null
        i.forEach((o) => {
          let a = new jG(o.semver.version)
          switch (o.operator) {
            case ">":
              a.prerelease.length === 0 ? a.patch++ : a.prerelease.push(0),
                (a.raw = a.format())
            case "":
            case ">=":
              ;(!s || Yve(a, s)) && (s = a)
              break
            case "<":
            case "<=":
              break
            default:
              throw new Error(`Unexpected operation: ${o.operator}`)
          }
        }),
          s && (!r || Yve(r, s)) && (r = s)
      }
      return r && e.test(r) ? r : null
    }
  Kve.exports = Vgt
})
var jve = _((CPt, Jve) => {
  "use strict"
  var Hgt = $l(),
    Wgt = (e, t) => {
      try {
        return new Hgt(e, t).range || "*"
      } catch {
        return null
      }
    }
  Jve.exports = Wgt
})
var PM = _((bPt, tCe) => {
  "use strict"
  var Ggt = Xs(),
    eCe = mx(),
    { ANY: $gt } = eCe,
    Ygt = $l(),
    Kgt = yx(),
    Zve = px(),
    Xve = kM(),
    zgt = FM(),
    Jgt = MM(),
    jgt = (e, t, r, n) => {
      ;(e = new Ggt(e, n)), (t = new Ygt(t, n))
      let i, s, o, a, l
      switch (r) {
        case ">":
          ;(i = Zve), (s = zgt), (o = Xve), (a = ">"), (l = ">=")
          break
        case "<":
          ;(i = Xve), (s = Jgt), (o = Zve), (a = "<"), (l = "<=")
          break
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"')
      }
      if (Kgt(e, t, n)) return false
      for (let c = 0; c < t.set.length; ++c) {
        let u = t.set[c],
          f = null,
          p = null
        if (
          (u.forEach((g) => {
            g.semver === $gt && (g = new eCe(">=0.0.0")),
              (f = f || g),
              (p = p || g),
              i(g.semver, f.semver, n)
                ? (f = g)
                : o(g.semver, p.semver, n) && (p = g)
          }),
          f.operator === a ||
            f.operator === l ||
            ((!p.operator || p.operator === a) && s(e, p.semver)))
        )
          return false
        if (p.operator === l && o(e, p.semver)) return false
      }
      return true
    }
  tCe.exports = jgt
})
var nCe = _((EPt, rCe) => {
  "use strict"
  var Zgt = PM(),
    Xgt = (e, t, r) => Zgt(e, t, ">", r)
  rCe.exports = Xgt
})
var sCe = _((_Pt, iCe) => {
  "use strict"
  var ept = PM(),
    tpt = (e, t, r) => ept(e, t, "<", r)
  iCe.exports = tpt
})
var lCe = _((xPt, aCe) => {
  "use strict"
  var oCe = $l(),
    rpt = (e, t, r) => (
      (e = new oCe(e, r)), (t = new oCe(t, r)), e.intersects(t, r)
    )
  aCe.exports = rpt
})
var uCe = _((wPt, cCe) => {
  "use strict"
  var npt = yx(),
    ipt = Gl()
  cCe.exports = (e, t, r) => {
    let n = [],
      i = null,
      s = null,
      o = e.sort((u, f) => ipt(u, f, r))
    for (let u of o)
      npt(u, t, r)
        ? ((s = u), i || (i = u))
        : (s && n.push([i, s]), (s = null), (i = null))
    i && n.push([i, null])
    let a = []
    for (let [u, f] of n)
      u === f
        ? a.push(u)
        : !f && u === o[0]
          ? a.push("*")
          : f
            ? u === o[0]
              ? a.push(`<=${f}`)
              : a.push(`${u} - ${f}`)
            : a.push(`>=${u}`)
    let l = a.join(" || "),
      c = typeof t.raw == "string" ? t.raw : String(t)
    return l.length < c.length ? l : t
  }
})
var mCe = _((SPt, pCe) => {
  "use strict"
  var dCe = $l(),
    XG = mx(),
    { ANY: ZG } = XG,
    vx = yx(),
    e4 = Gl(),
    spt = (e, t, r = {}) => {
      if (e === t) return true
      ;(e = new dCe(e, r)), (t = new dCe(t, r))
      let n = false
      e: for (let i of e.set) {
        for (let s of t.set) {
          let o = apt(i, s, r)
          if (((n = n || o !== null), o)) continue e
        }
        if (n) return false
      }
      return true
    },
    opt = [new XG(">=0.0.0-0")],
    fCe = [new XG(">=0.0.0")],
    apt = (e, t, r) => {
      if (e === t) return true
      if (e.length === 1 && e[0].semver === ZG) {
        if (t.length === 1 && t[0].semver === ZG) return true
        r.includePrerelease ? (e = opt) : (e = fCe)
      }
      if (t.length === 1 && t[0].semver === ZG) {
        if (r.includePrerelease) return true
        t = fCe
      }
      let n = new Set(),
        i,
        s
      for (let g of e)
        g.operator === ">" || g.operator === ">="
          ? (i = hCe(i, g, r))
          : g.operator === "<" || g.operator === "<="
            ? (s = gCe(s, g, r))
            : n.add(g.semver)
      if (n.size > 1) return null
      let o
      if (i && s) {
        if (((o = e4(i.semver, s.semver, r)), o > 0)) return null
        if (o === 0 && (i.operator !== ">=" || s.operator !== "<=")) return null
      }
      for (let g of n) {
        if ((i && !vx(g, String(i), r)) || (s && !vx(g, String(s), r)))
          return null
        for (let m of t) if (!vx(g, String(m), r)) return false
        return true
      }
      let a,
        l,
        c,
        u,
        f =
          s && !r.includePrerelease && s.semver.prerelease.length
            ? s.semver
            : false,
        p =
          i && !r.includePrerelease && i.semver.prerelease.length
            ? i.semver
            : false
      f &&
        f.prerelease.length === 1 &&
        s.operator === "<" &&
        f.prerelease[0] === 0 &&
        (f = false)
      for (let g of t) {
        if (
          ((u = u || g.operator === ">" || g.operator === ">="),
          (c = c || g.operator === "<" || g.operator === "<="),
          i)
        ) {
          if (
            (p &&
              g.semver.prerelease &&
              g.semver.prerelease.length &&
              g.semver.major === p.major &&
              g.semver.minor === p.minor &&
              g.semver.patch === p.patch &&
              (p = false),
            g.operator === ">" || g.operator === ">=")
          ) {
            if (((a = hCe(i, g, r)), a === g && a !== i)) return false
          } else if (i.operator === ">=" && !vx(i.semver, String(g), r))
            return false
        }
        if (s) {
          if (
            (f &&
              g.semver.prerelease &&
              g.semver.prerelease.length &&
              g.semver.major === f.major &&
              g.semver.minor === f.minor &&
              g.semver.patch === f.patch &&
              (f = false),
            g.operator === "<" || g.operator === "<=")
          ) {
            if (((l = gCe(s, g, r)), l === g && l !== s)) return false
          } else if (s.operator === "<=" && !vx(s.semver, String(g), r))
            return false
        }
        if (!g.operator && (s || i) && o !== 0) return false
      }
      return !((i && c && !s && o !== 0) || (s && u && !i && o !== 0) || p || f)
    },
    hCe = (e, t, r) => {
      if (!e) return t
      let n = e4(e.semver, t.semver, r)
      return n > 0
        ? e
        : n < 0 || (t.operator === ">" && e.operator === ">=")
          ? t
          : e
    },
    gCe = (e, t, r) => {
      if (!e) return t
      let n = e4(e.semver, t.semver, r)
      return n < 0
        ? e
        : n > 0 || (t.operator === "<" && e.operator === "<=")
          ? t
          : e
    }
  pCe.exports = spt
})
var CCe = _((IPt, vCe) => {
  "use strict"
  var t4 = nv(),
    ACe = hx(),
    lpt = Xs(),
    yCe = OG(),
    cpt = Am(),
    upt = Wye(),
    dpt = $ye(),
    fpt = zye(),
    hpt = Zye(),
    gpt = eve(),
    ppt = rve(),
    mpt = ive(),
    Apt = ove(),
    ypt = Gl(),
    vpt = uve(),
    Cpt = fve(),
    bpt = TM(),
    Ept = mve(),
    _pt = yve(),
    xpt = px(),
    wpt = kM(),
    Spt = VG(),
    Ipt = HG(),
    Bpt = MM(),
    Rpt = FM(),
    Dpt = WG(),
    Tpt = Ive(),
    kpt = mx(),
    Mpt = $l(),
    Fpt = yx(),
    Qpt = Vve(),
    Npt = Wve(),
    Ppt = $ve(),
    Lpt = zve(),
    Upt = jve(),
    Opt = PM(),
    qpt = nCe(),
    Vpt = sCe(),
    Hpt = lCe(),
    Wpt = uCe(),
    Gpt = mCe()
  vCe.exports = {
    parse: cpt,
    valid: upt,
    clean: dpt,
    inc: fpt,
    diff: hpt,
    major: gpt,
    minor: ppt,
    patch: mpt,
    prerelease: Apt,
    compare: ypt,
    rcompare: vpt,
    compareLoose: Cpt,
    compareBuild: bpt,
    sort: Ept,
    rsort: _pt,
    gt: xpt,
    lt: wpt,
    eq: Spt,
    neq: Ipt,
    gte: Bpt,
    lte: Rpt,
    cmp: Dpt,
    coerce: Tpt,
    Comparator: kpt,
    Range: Mpt,
    satisfies: Fpt,
    toComparators: Qpt,
    maxSatisfying: Npt,
    minSatisfying: Ppt,
    minVersion: Lpt,
    validRange: Upt,
    outside: Opt,
    gtr: qpt,
    ltr: Vpt,
    intersects: Hpt,
    simplifyRange: Wpt,
    subset: Gpt,
    SemVer: lpt,
    re: t4.re,
    src: t4.src,
    tokens: t4.t,
    SEMVER_SPEC_VERSION: ACe.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: ACe.RELEASE_TYPES,
    compareIdentifiers: yCe.compareIdentifiers,
    rcompareIdentifiers: yCe.rcompareIdentifiers,
  }
})
var H4 = _((l5t, uEe) => {
  "use strict"
  function fAt(e) {
    ;(r.debug = r),
      (r.default = r),
      (r.coerce = l),
      (r.disable = o),
      (r.enable = i),
      (r.enabled = a),
      (r.humanize = jT()),
      (r.destroy = c),
      Object.keys(e).forEach((u) => {
        r[u] = e[u]
      }),
      (r.names = []),
      (r.skips = []),
      (r.formatters = {})
    function t(u) {
      let f = 0
      for (let p = 0; p < u.length; p++)
        (f = (f << 5) - f + u.charCodeAt(p)), (f |= 0)
      return r.colors[Math.abs(f) % r.colors.length]
    }
    r.selectColor = t
    function r(u) {
      let f,
        p = null,
        g,
        m
      function y(...v) {
        if (!y.enabled) return
        let C = y,
          E = Number(new Date()),
          w = E - (f || E)
        ;(C.diff = w),
          (C.prev = f),
          (C.curr = E),
          (f = E),
          (v[0] = r.coerce(v[0])),
          typeof v[0] != "string" && v.unshift("%O")
        let B = 0
        ;(v[0] = v[0].replace(/%([a-zA-Z%])/g, (N, W) => {
          if (N === "%%") return "%"
          B++
          let Z = r.formatters[W]
          if (typeof Z == "function") {
            let te = v[B]
            ;(N = Z.call(C, te)), v.splice(B, 1), B--
          }
          return N
        })),
          r.formatArgs.call(C, v),
          (C.log || r.log).apply(C, v)
      }
      return (
        (y.namespace = u),
        (y.useColors = r.useColors()),
        (y.color = r.selectColor(u)),
        (y.extend = n),
        (y.destroy = r.destroy),
        Object.defineProperty(y, "enabled", {
          enumerable: true,
          configurable: false,
          get: () =>
            p !== null
              ? p
              : (g !== r.namespaces && ((g = r.namespaces), (m = r.enabled(u))),
                m),
          set: (v) => {
            p = v
          },
        }),
        typeof r.init == "function" && r.init(y),
        y
      )
    }
    function n(u, f) {
      let p = r(this.namespace + (typeof f > "u" ? ":" : f) + u)
      return (p.log = this.log), p
    }
    function i(u) {
      r.save(u), (r.namespaces = u), (r.names = []), (r.skips = [])
      let f = (typeof u == "string" ? u : "")
        .trim()
        .replace(" ", ",")
        .split(",")
        .filter(Boolean)
      for (let p of f) p[0] === "-" ? r.skips.push(p.slice(1)) : r.names.push(p)
    }
    function s(u, f) {
      let p = 0,
        g = 0,
        m = -1,
        y = 0
      for (; p < u.length; )
        if (g < f.length && (f[g] === u[p] || f[g] === "*"))
          f[g] === "*" ? ((m = g), (y = p), g++) : (p++, g++)
        else if (m !== -1) (g = m + 1), y++, (p = y)
        else return false
      for (; g < f.length && f[g] === "*"; ) g++
      return g === f.length
    }
    function o() {
      let u = [...r.names, ...r.skips.map((f) => "-" + f)].join(",")
      return r.enable(""), u
    }
    function a(u) {
      for (let f of r.skips) if (s(u, f)) return false
      for (let f of r.names) if (s(u, f)) return true
      return false
    }
    function l(u) {
      return u instanceof Error ? u.stack || u.message : u
    }
    function c() {
      console.warn(
        "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
      )
    }
    return r.enable(r.load()), r
  }
  uEe.exports = fAt
})
var dEe = _((Za, JF) => {
  "use strict"
  Za.formatArgs = gAt
  Za.save = pAt
  Za.load = mAt
  Za.useColors = hAt
  Za.storage = AAt()
  Za.destroy = (() => {
    let e = false
    return () => {
      e ||
        ((e = true),
        console.warn(
          "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
        ))
    }
  })()
  Za.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33",
  ]
  function hAt() {
    if (
      typeof window < "u" &&
      window.process &&
      (window.process.type === "renderer" || window.process.__nwjs)
    )
      return true
    if (
      typeof navigator < "u" &&
      navigator.userAgent &&
      navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
    )
      return false
    let e
    return (
      (typeof document < "u" &&
        document.documentElement &&
        document.documentElement.style &&
        document.documentElement.style.WebkitAppearance) ||
      (typeof window < "u" &&
        window.console &&
        (window.console.firebug ||
          (window.console.exception && window.console.table))) ||
      (typeof navigator < "u" &&
        navigator.userAgent &&
        (e = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) &&
        parseInt(e[1], 10) >= 31) ||
      (typeof navigator < "u" &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
    )
  }
  function gAt(e) {
    if (
      ((e[0] =
        (this.useColors ? "%c" : "") +
        this.namespace +
        (this.useColors ? " %c" : " ") +
        e[0] +
        (this.useColors ? "%c " : " ") +
        "+" +
        JF.exports.humanize(this.diff)),
      !this.useColors)
    )
      return
    let t = "color: " + this.color
    e.splice(1, 0, t, "color: inherit")
    let r = 0,
      n = 0
    e[0].replace(/%[a-zA-Z%]/g, (i) => {
      i !== "%%" && (r++, i === "%c" && (n = r))
    }),
      e.splice(n, 0, t)
  }
  Za.log = console.debug || console.log || (() => {})
  function pAt(e) {
    try {
      e ? Za.storage.setItem("debug", e) : Za.storage.removeItem("debug")
    } catch {}
  }
  function mAt() {
    let e
    try {
      e = Za.storage.getItem("debug")
    } catch {}
    return (
      !e && typeof process < "u" && "env" in process && (e = process.env.DEBUG),
      e
    )
  }
  function AAt() {
    try {
      return localStorage
    } catch {}
  }
  JF.exports = H4()(Za)
  var { formatters: yAt } = JF.exports
  yAt.j = function (e) {
    try {
      return JSON.stringify(e)
    } catch (t) {
      return "[UnexpectedJSONParseError]: " + t.message
    }
  }
})
var $4 = {}
lL($4, { createSupportsColor: () => G4, default: () => _At })
function zl(e, t = globalThis.Deno ? globalThis.Deno.args : ZF.default.argv) {
  let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--",
    n = t.indexOf(r + e),
    i = t.indexOf("--")
  return n !== -1 && (i === -1 || n < i)
}
function vAt() {
  if ("FORCE_COLOR" in Zn)
    return Zn.FORCE_COLOR === "true"
      ? 1
      : Zn.FORCE_COLOR === "false"
        ? 0
        : Zn.FORCE_COLOR.length === 0
          ? 1
          : Math.min(Number.parseInt(Zn.FORCE_COLOR, 10), 3)
}
function CAt(e) {
  return e === 0
    ? false
    : { level: e, hasBasic: true, has256: e >= 2, has16m: e >= 3 }
}
function bAt(e, { streamIsTTY: t, sniffFlags: r = true } = {}) {
  let n = vAt()
  n !== undefined && (jF = n)
  let i = r ? jF : n
  if (i === 0) return 0
  if (r) {
    if (zl("color=16m") || zl("color=full") || zl("color=truecolor")) return 3
    if (zl("color=256")) return 2
  }
  if ("TF_BUILD" in Zn && "AGENT_NAME" in Zn) return 1
  if (e && !t && i === undefined) return 0
  let s = i || 0
  if (Zn.TERM === "dumb") return s
  if (ZF.default.platform === "win32") {
    let o = fEe.default.release().split(".")
    return Number(o[0]) >= 10 && Number(o[2]) >= 10586
      ? Number(o[2]) >= 14931
        ? 3
        : 2
      : 1
  }
  if ("CI" in Zn)
    return "GITHUB_ACTIONS" in Zn || "GITEA_ACTIONS" in Zn
      ? 3
      : [
            "TRAVIS",
            "CIRCLECI",
            "APPVEYOR",
            "GITLAB_CI",
            "BUILDKITE",
            "DRONE",
          ].some((o) => o in Zn) || Zn.CI_NAME === "codeship"
        ? 1
        : s
  if ("TEAMCITY_VERSION" in Zn)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Zn.TEAMCITY_VERSION) ? 1 : 0
  if (Zn.COLORTERM === "truecolor" || Zn.TERM === "xterm-kitty") return 3
  if ("TERM_PROGRAM" in Zn) {
    let o = Number.parseInt((Zn.TERM_PROGRAM_VERSION || "").split(".")[0], 10)
    switch (Zn.TERM_PROGRAM) {
      case "iTerm.app":
        return o >= 3 ? 3 : 2
      case "Apple_Terminal":
        return 2
    }
  }
  return /-256(color)?$/i.test(Zn.TERM)
    ? 2
    : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
          Zn.TERM,
        ) || "COLORTERM" in Zn
      ? 1
      : s
}
function G4(e, t = {}) {
  let r = bAt(e, { streamIsTTY: e && e.isTTY, ...t })
  return CAt(r)
}
var ZF,
  fEe,
  W4,
  Zn,
  jF,
  EAt,
  _At,
  Y4 = RFe(() => {
    "use strict"
    ;(ZF = q(require("process"))),
      (fEe = q(require("os"))),
      (W4 = q(require("tty")))
    ;({ env: Zn } = ZF.default)
    zl("no-color") || zl("no-colors") || zl("color=false") || zl("color=never")
      ? (jF = 0)
      : (zl("color") ||
          zl("colors") ||
          zl("color=true") ||
          zl("color=always")) &&
        (jF = 1)
    ;(EAt = {
      stdout: G4({ isTTY: W4.default.isatty(1) }),
      stderr: G4({ isTTY: W4.default.isatty(2) }),
    }),
      (_At = EAt)
  })
var gEe = _((us, e1) => {
  "use strict"
  var xAt = require("tty"),
    XF = require("util")
  us.init = TAt
  us.log = BAt
  us.formatArgs = SAt
  us.save = RAt
  us.load = DAt
  us.useColors = wAt
  us.destroy = XF.deprecate(
    () => {},
    "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
  )
  us.colors = [6, 2, 3, 4, 5, 1]
  try {
    let e = (Y4(), cL($4))
    e &&
      (e.stderr || e).level >= 2 &&
      (us.colors = [
        20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63,
        68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128,
        129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168,
        169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200,
        201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221,
      ])
  } catch {}
  us.inspectOpts = Object.keys(process.env)
    .filter((e) => /^debug_/i.test(e))
    .reduce((e, t) => {
      let r = t
          .substring(6)
          .toLowerCase()
          .replace(/_([a-z])/g, (i, s) => s.toUpperCase()),
        n = process.env[t]
      return (
        /^(yes|on|true|enabled)$/i.test(n)
          ? (n = true)
          : /^(no|off|false|disabled)$/i.test(n)
            ? (n = false)
            : n === "null"
              ? (n = null)
              : (n = Number(n)),
        (e[r] = n),
        e
      )
    }, {})
  function wAt() {
    return "colors" in us.inspectOpts
      ? !!us.inspectOpts.colors
      : xAt.isatty(process.stderr.fd)
  }
  function SAt(e) {
    let { namespace: t, useColors: r } = this
    if (r) {
      let n = this.color,
        i = "\x1B[3" + (n < 8 ? n : "8;5;" + n),
        s = `  ${i};1m${t} \x1B[0m`
      ;(e[0] =
        s +
        e[0]
          .split(
            `
`,
          )
          .join(
            `
` + s,
          )),
        e.push(i + "m+" + e1.exports.humanize(this.diff) + "\x1B[0m")
    } else e[0] = IAt() + t + " " + e[0]
  }
  function IAt() {
    return us.inspectOpts.hideDate ? "" : new Date().toISOString() + " "
  }
  function BAt(...e) {
    return process.stderr.write(
      XF.formatWithOptions(us.inspectOpts, ...e) +
        `
`,
    )
  }
  function RAt(e) {
    e ? (process.env.DEBUG = e) : delete process.env.DEBUG
  }
  function DAt() {
    return process.env.DEBUG
  }
  function TAt(e) {
    e.inspectOpts = {}
    let t = Object.keys(us.inspectOpts)
    for (let r = 0; r < t.length; r++)
      e.inspectOpts[t[r]] = us.inspectOpts[t[r]]
  }
  e1.exports = H4()(us)
  var { formatters: hEe } = e1.exports
  hEe.o = function (e) {
    return (
      (this.inspectOpts.colors = this.useColors),
      XF.inspect(e, this.inspectOpts)
        .split(
          `
`,
        )
        .map((t) => t.trim())
        .join(" ")
    )
  }
  hEe.O = function (e) {
    return (
      (this.inspectOpts.colors = this.useColors),
      XF.inspect(e, this.inspectOpts)
    )
  }
})
var pEe = _((c5t, K4) => {
  "use strict"
  typeof process > "u" ||
  process.type === "renderer" ||
  process.browser === true ||
  process.__nwjs
    ? (K4.exports = dEe())
    : (K4.exports = gEe())
})
var mEe = _((Xa) => {
  "use strict"
  var kAt =
    (Xa && Xa.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e }
    }
  Object.defineProperty(Xa, "__esModule", { value: true })
  var MAt = require("fs"),
    FAt = kAt(pEe()),
    Sv = FAt.default("@kwsites/file-exists")
  function QAt(e, t, r) {
    Sv("checking %s", e)
    try {
      let n = MAt.statSync(e)
      return n.isFile() && t
        ? (Sv("[OK] path represents a file"), true)
        : n.isDirectory() && r
          ? (Sv("[OK] path represents a directory"), true)
          : (Sv(
              "[FAIL] path represents something other than a file or directory",
            ),
            false)
    } catch (n) {
      if (n.code === "ENOENT")
        return Sv("[FAIL] path is not accessible: %o", n), false
      throw (Sv("[FATAL] %o", n), n)
    }
  }
  function NAt(e, t = Xa.READABLE) {
    return QAt(e, (t & Xa.FILE) > 0, (t & Xa.FOLDER) > 0)
  }
  Xa.exists = NAt
  Xa.FILE = 1
  Xa.FOLDER = 2
  Xa.READABLE = Xa.FILE + Xa.FOLDER
})
var AEe = _((t1) => {
  "use strict"
  function PAt(e) {
    for (var t in e) t1.hasOwnProperty(t) || (t1[t] = e[t])
  }
  Object.defineProperty(t1, "__esModule", { value: true })
  PAt(mEe())
})
var z4 = _((f5t, yEe) => {
  "use strict"
  function LAt(e) {
    ;(r.debug = r),
      (r.default = r),
      (r.coerce = l),
      (r.disable = s),
      (r.enable = i),
      (r.enabled = o),
      (r.humanize = jT()),
      (r.destroy = c),
      Object.keys(e).forEach((u) => {
        r[u] = e[u]
      }),
      (r.names = []),
      (r.skips = []),
      (r.formatters = {})
    function t(u) {
      let f = 0
      for (let p = 0; p < u.length; p++)
        (f = (f << 5) - f + u.charCodeAt(p)), (f |= 0)
      return r.colors[Math.abs(f) % r.colors.length]
    }
    r.selectColor = t
    function r(u) {
      let f,
        p = null,
        g,
        m
      function y(...v) {
        if (!y.enabled) return
        let C = y,
          E = Number(new Date()),
          w = E - (f || E)
        ;(C.diff = w),
          (C.prev = f),
          (C.curr = E),
          (f = E),
          (v[0] = r.coerce(v[0])),
          typeof v[0] != "string" && v.unshift("%O")
        let B = 0
        ;(v[0] = v[0].replace(/%([a-zA-Z%])/g, (N, W) => {
          if (N === "%%") return "%"
          B++
          let Z = r.formatters[W]
          if (typeof Z == "function") {
            let te = v[B]
            ;(N = Z.call(C, te)), v.splice(B, 1), B--
          }
          return N
        })),
          r.formatArgs.call(C, v),
          (C.log || r.log).apply(C, v)
      }
      return (
        (y.namespace = u),
        (y.useColors = r.useColors()),
        (y.color = r.selectColor(u)),
        (y.extend = n),
        (y.destroy = r.destroy),
        Object.defineProperty(y, "enabled", {
          enumerable: true,
          configurable: false,
          get: () =>
            p !== null
              ? p
              : (g !== r.namespaces && ((g = r.namespaces), (m = r.enabled(u))),
                m),
          set: (v) => {
            p = v
          },
        }),
        typeof r.init == "function" && r.init(y),
        y
      )
    }
    function n(u, f) {
      let p = r(this.namespace + (typeof f > "u" ? ":" : f) + u)
      return (p.log = this.log), p
    }
    function i(u) {
      r.save(u), (r.namespaces = u), (r.names = []), (r.skips = [])
      let f,
        p = (typeof u == "string" ? u : "").split(/[\s,]+/),
        g = p.length
      for (f = 0; f < g; f++)
        p[f] &&
          ((u = p[f].replace(/\*/g, ".*?")),
          u[0] === "-"
            ? r.skips.push(new RegExp("^" + u.slice(1) + "$"))
            : r.names.push(new RegExp("^" + u + "$")))
    }
    function s() {
      let u = [...r.names.map(a), ...r.skips.map(a).map((f) => "-" + f)].join(
        ",",
      )
      return r.enable(""), u
    }
    function o(u) {
      if (u[u.length - 1] === "*") return true
      let f, p
      for (f = 0, p = r.skips.length; f < p; f++)
        if (r.skips[f].test(u)) return false
      for (f = 0, p = r.names.length; f < p; f++)
        if (r.names[f].test(u)) return true
      return false
    }
    function a(u) {
      return u
        .toString()
        .substring(2, u.toString().length - 2)
        .replace(/\.\*\?$/, "*")
    }
    function l(u) {
      return u instanceof Error ? u.stack || u.message : u
    }
    function c() {
      console.warn(
        "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
      )
    }
    return r.enable(r.load()), r
  }
  yEe.exports = LAt
})
var vEe = _((el, r1) => {
  "use strict"
  el.formatArgs = OAt
  el.save = qAt
  el.load = VAt
  el.useColors = UAt
  el.storage = HAt()
  el.destroy = (() => {
    let e = false
    return () => {
      e ||
        ((e = true),
        console.warn(
          "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
        ))
    }
  })()
  el.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33",
  ]
  function UAt() {
    if (
      typeof window < "u" &&
      window.process &&
      (window.process.type === "renderer" || window.process.__nwjs)
    )
      return true
    if (
      typeof navigator < "u" &&
      navigator.userAgent &&
      navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
    )
      return false
    let e
    return (
      (typeof document < "u" &&
        document.documentElement &&
        document.documentElement.style &&
        document.documentElement.style.WebkitAppearance) ||
      (typeof window < "u" &&
        window.console &&
        (window.console.firebug ||
          (window.console.exception && window.console.table))) ||
      (typeof navigator < "u" &&
        navigator.userAgent &&
        (e = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) &&
        parseInt(e[1], 10) >= 31) ||
      (typeof navigator < "u" &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
    )
  }
  function OAt(e) {
    if (
      ((e[0] =
        (this.useColors ? "%c" : "") +
        this.namespace +
        (this.useColors ? " %c" : " ") +
        e[0] +
        (this.useColors ? "%c " : " ") +
        "+" +
        r1.exports.humanize(this.diff)),
      !this.useColors)
    )
      return
    let t = "color: " + this.color
    e.splice(1, 0, t, "color: inherit")
    let r = 0,
      n = 0
    e[0].replace(/%[a-zA-Z%]/g, (i) => {
      i !== "%%" && (r++, i === "%c" && (n = r))
    }),
      e.splice(n, 0, t)
  }
  el.log = console.debug || console.log || (() => {})
  function qAt(e) {
    try {
      e ? el.storage.setItem("debug", e) : el.storage.removeItem("debug")
    } catch {}
  }
  function VAt() {
    let e
    try {
      e = el.storage.getItem("debug")
    } catch {}
    return (
      !e && typeof process < "u" && "env" in process && (e = process.env.DEBUG),
      e
    )
  }
  function HAt() {
    try {
      return localStorage
    } catch {}
  }
  r1.exports = z4()(el)
  var { formatters: WAt } = r1.exports
  WAt.j = function (e) {
    try {
      return JSON.stringify(e)
    } catch (t) {
      return "[UnexpectedJSONParseError]: " + t.message
    }
  }
})
var bEe = _((ds, i1) => {
  "use strict"
  var GAt = require("tty"),
    n1 = require("util")
  ds.init = ZAt
  ds.log = zAt
  ds.formatArgs = YAt
  ds.save = JAt
  ds.load = jAt
  ds.useColors = $At
  ds.destroy = n1.deprecate(
    () => {},
    "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
  )
  ds.colors = [6, 2, 3, 4, 5, 1]
  try {
    let e = (Y4(), cL($4))
    e &&
      (e.stderr || e).level >= 2 &&
      (ds.colors = [
        20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63,
        68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128,
        129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168,
        169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200,
        201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221,
      ])
  } catch {}
  ds.inspectOpts = Object.keys(process.env)
    .filter((e) => /^debug_/i.test(e))
    .reduce((e, t) => {
      let r = t
          .substring(6)
          .toLowerCase()
          .replace(/_([a-z])/g, (i, s) => s.toUpperCase()),
        n = process.env[t]
      return (
        /^(yes|on|true|enabled)$/i.test(n)
          ? (n = true)
          : /^(no|off|false|disabled)$/i.test(n)
            ? (n = false)
            : n === "null"
              ? (n = null)
              : (n = Number(n)),
        (e[r] = n),
        e
      )
    }, {})
  function $At() {
    return "colors" in ds.inspectOpts
      ? !!ds.inspectOpts.colors
      : GAt.isatty(process.stderr.fd)
  }
  function YAt(e) {
    let { namespace: t, useColors: r } = this
    if (r) {
      let n = this.color,
        i = "\x1B[3" + (n < 8 ? n : "8;5;" + n),
        s = `  ${i};1m${t} \x1B[0m`
      ;(e[0] =
        s +
        e[0]
          .split(
            `
`,
          )
          .join(
            `
` + s,
          )),
        e.push(i + "m+" + i1.exports.humanize(this.diff) + "\x1B[0m")
    } else e[0] = KAt() + t + " " + e[0]
  }
  function KAt() {
    return ds.inspectOpts.hideDate ? "" : new Date().toISOString() + " "
  }
  function zAt(...e) {
    return process.stderr.write(
      n1.formatWithOptions(ds.inspectOpts, ...e) +
        `
`,
    )
  }
  function JAt(e) {
    e ? (process.env.DEBUG = e) : delete process.env.DEBUG
  }
  function jAt() {
    return process.env.DEBUG
  }
  function ZAt(e) {
    e.inspectOpts = {}
    let t = Object.keys(ds.inspectOpts)
    for (let r = 0; r < t.length; r++)
      e.inspectOpts[t[r]] = ds.inspectOpts[t[r]]
  }
  i1.exports = z4()(ds)
  var { formatters: CEe } = i1.exports
  CEe.o = function (e) {
    return (
      (this.inspectOpts.colors = this.useColors),
      n1
        .inspect(e, this.inspectOpts)
        .split(
          `
`,
        )
        .map((t) => t.trim())
        .join(" ")
    )
  }
  CEe.O = function (e) {
    return (
      (this.inspectOpts.colors = this.useColors),
      n1.inspect(e, this.inspectOpts)
    )
  }
})
var EEe = _((h5t, J4) => {
  "use strict"
  typeof process > "u" ||
  process.type === "renderer" ||
  process.browser === true ||
  process.__nwjs
    ? (J4.exports = vEe())
    : (J4.exports = bEe())
})
var Z4 = _((Bm) => {
  "use strict"
  Object.defineProperty(Bm, "__esModule", { value: true })
  Bm.createDeferred = Bm.deferred = undefined
  function j4() {
    let e,
      t,
      r = "pending"
    return {
      promise: new Promise((i, s) => {
        ;(e = i), (t = s)
      }),
      done(i) {
        r === "pending" && ((r = "resolved"), e(i))
      },
      fail(i) {
        r === "pending" && ((r = "rejected"), t(i))
      },
      get fulfilled() {
        return r !== "pending"
      },
      get status() {
        return r
      },
    }
  }
  Bm.deferred = j4
  Bm.createDeferred = j4
  Bm.default = j4
})
var ywe = _((d8t, Y1) => {
  "use strict"
  Y1.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/
  Y1.exports.ID_Start =
    /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/
  Y1.exports.ID_Continue =
    /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
})
var Y8 = _((f8t, vwe) => {
  "use strict"
  var $8 = ywe()
  vwe.exports = {
    isSpaceSeparator(e) {
      return typeof e == "string" && $8.Space_Separator.test(e)
    },
    isIdStartChar(e) {
      return (
        typeof e == "string" &&
        ((e >= "a" && e <= "z") ||
          (e >= "A" && e <= "Z") ||
          e === "$" ||
          e === "_" ||
          $8.ID_Start.test(e))
      )
    },
    isIdContinueChar(e) {
      return (
        typeof e == "string" &&
        ((e >= "a" && e <= "z") ||
          (e >= "A" && e <= "Z") ||
          (e >= "0" && e <= "9") ||
          e === "$" ||
          e === "_" ||
          e === "\u200C" ||
          e === "\u200D" ||
          $8.ID_Continue.test(e))
      )
    },
    isDigit(e) {
      return typeof e == "string" && /[0-9]/.test(e)
    },
    isHexDigit(e) {
      return typeof e == "string" && /[0-9A-Fa-f]/.test(e)
    },
  }
})
var xwe = _((h8t, _we) => {
  "use strict"
  var fs = Y8(),
    z8,
    Fo,
    Ef,
    z1,
    hg,
    Jc,
    hs,
    Z8,
    tw
  _we.exports = function (t, r) {
    ;(z8 = String(t)),
      (Fo = "start"),
      (Ef = []),
      (z1 = 0),
      (hg = 1),
      (Jc = 0),
      (hs = undefined),
      (Z8 = undefined),
      (tw = undefined)
    do (hs = hCt()), mCt[Fo]()
    while (hs.type !== "eof")
    return typeof r == "function" ? J8({ "": tw }, "", r) : tw
  }
  function J8(e, t, r) {
    let n = e[t]
    if (n != null && typeof n == "object")
      if (Array.isArray(n))
        for (let i = 0; i < n.length; i++) {
          let s = String(i),
            o = J8(n, s, r)
          o === undefined
            ? delete n[s]
            : Object.defineProperty(n, s, {
                value: o,
                writable: true,
                enumerable: true,
                configurable: true,
              })
        }
      else
        for (let i in n) {
          let s = J8(n, i, r)
          s === undefined
            ? delete n[i]
            : Object.defineProperty(n, i, {
                value: s,
                writable: true,
                enumerable: true,
                configurable: true,
              })
        }
    return r.call(e, t, n)
  }
  var Zt, qt, ew, bf, Er
  function hCt() {
    for (Zt = "default", qt = "", ew = false, bf = 1; ; ) {
      Er = _f()
      let e = bwe[Zt]()
      if (e) return e
    }
  }
  function _f() {
    if (z8[z1]) return String.fromCodePoint(z8.codePointAt(z1))
  }
  function ge() {
    let e = _f()
    return (
      e ===
      `
`
        ? (hg++, (Jc = 0))
        : e
          ? (Jc += e.length)
          : Jc++,
      e && (z1 += e.length),
      e
    )
  }
  var bwe = {
    default() {
      switch (Er) {
        case "	":
        case "\v":
        case "\f":
        case " ":
        case "\xA0":
        case "\uFEFF":
        case `
`:
        case "\r":
        case "\u2028":
        case "\u2029":
          ge()
          return
        case "/":
          ge(), (Zt = "comment")
          return
        case undefined:
          return ge(), Un("eof")
      }
      if (fs.isSpaceSeparator(Er)) {
        ge()
        return
      }
      return bwe[Fo]()
    },
    comment() {
      switch (Er) {
        case "*":
          ge(), (Zt = "multiLineComment")
          return
        case "/":
          ge(), (Zt = "singleLineComment")
          return
      }
      throw On(ge())
    },
    multiLineComment() {
      switch (Er) {
        case "*":
          ge(), (Zt = "multiLineCommentAsterisk")
          return
        case undefined:
          throw On(ge())
      }
      ge()
    },
    multiLineCommentAsterisk() {
      switch (Er) {
        case "*":
          ge()
          return
        case "/":
          ge(), (Zt = "default")
          return
        case undefined:
          throw On(ge())
      }
      ge(), (Zt = "multiLineComment")
    },
    singleLineComment() {
      switch (Er) {
        case `
`:
        case "\r":
        case "\u2028":
        case "\u2029":
          ge(), (Zt = "default")
          return
        case undefined:
          return ge(), Un("eof")
      }
      ge()
    },
    value() {
      switch (Er) {
        case "{":
        case "[":
          return Un("punctuator", ge())
        case "n":
          return ge(), Om("ull"), Un("null", null)
        case "t":
          return ge(), Om("rue"), Un("boolean", true)
        case "f":
          return ge(), Om("alse"), Un("boolean", false)
        case "-":
        case "+":
          ge() === "-" && (bf = -1), (Zt = "sign")
          return
        case ".":
          ;(qt = ge()), (Zt = "decimalPointLeading")
          return
        case "0":
          ;(qt = ge()), (Zt = "zero")
          return
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          ;(qt = ge()), (Zt = "decimalInteger")
          return
        case "I":
          return ge(), Om("nfinity"), Un("numeric", 1 / 0)
        case "N":
          return ge(), Om("aN"), Un("numeric", NaN)
        case '"':
        case "'":
          ;(ew = ge() === '"'), (qt = ""), (Zt = "string")
          return
      }
      throw On(ge())
    },
    identifierNameStartEscape() {
      if (Er !== "u") throw On(ge())
      ge()
      let e = j8()
      switch (e) {
        case "$":
        case "_":
          break
        default:
          if (!fs.isIdStartChar(e)) throw Cwe()
          break
      }
      ;(qt += e), (Zt = "identifierName")
    },
    identifierName() {
      switch (Er) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          qt += ge()
          return
        case "\\":
          ge(), (Zt = "identifierNameEscape")
          return
      }
      if (fs.isIdContinueChar(Er)) {
        qt += ge()
        return
      }
      return Un("identifier", qt)
    },
    identifierNameEscape() {
      if (Er !== "u") throw On(ge())
      ge()
      let e = j8()
      switch (e) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          break
        default:
          if (!fs.isIdContinueChar(e)) throw Cwe()
          break
      }
      ;(qt += e), (Zt = "identifierName")
    },
    sign() {
      switch (Er) {
        case ".":
          ;(qt = ge()), (Zt = "decimalPointLeading")
          return
        case "0":
          ;(qt = ge()), (Zt = "zero")
          return
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          ;(qt = ge()), (Zt = "decimalInteger")
          return
        case "I":
          return ge(), Om("nfinity"), Un("numeric", bf * (1 / 0))
        case "N":
          return ge(), Om("aN"), Un("numeric", NaN)
      }
      throw On(ge())
    },
    zero() {
      switch (Er) {
        case ".":
          ;(qt += ge()), (Zt = "decimalPoint")
          return
        case "e":
        case "E":
          ;(qt += ge()), (Zt = "decimalExponent")
          return
        case "x":
        case "X":
          ;(qt += ge()), (Zt = "hexadecimal")
          return
      }
      return Un("numeric", bf * 0)
    },
    decimalInteger() {
      switch (Er) {
        case ".":
          ;(qt += ge()), (Zt = "decimalPoint")
          return
        case "e":
        case "E":
          ;(qt += ge()), (Zt = "decimalExponent")
          return
      }
      if (fs.isDigit(Er)) {
        qt += ge()
        return
      }
      return Un("numeric", bf * Number(qt))
    },
    decimalPointLeading() {
      if (fs.isDigit(Er)) {
        ;(qt += ge()), (Zt = "decimalFraction")
        return
      }
      throw On(ge())
    },
    decimalPoint() {
      switch (Er) {
        case "e":
        case "E":
          ;(qt += ge()), (Zt = "decimalExponent")
          return
      }
      if (fs.isDigit(Er)) {
        ;(qt += ge()), (Zt = "decimalFraction")
        return
      }
      return Un("numeric", bf * Number(qt))
    },
    decimalFraction() {
      switch (Er) {
        case "e":
        case "E":
          ;(qt += ge()), (Zt = "decimalExponent")
          return
      }
      if (fs.isDigit(Er)) {
        qt += ge()
        return
      }
      return Un("numeric", bf * Number(qt))
    },
    decimalExponent() {
      switch (Er) {
        case "+":
        case "-":
          ;(qt += ge()), (Zt = "decimalExponentSign")
          return
      }
      if (fs.isDigit(Er)) {
        ;(qt += ge()), (Zt = "decimalExponentInteger")
        return
      }
      throw On(ge())
    },
    decimalExponentSign() {
      if (fs.isDigit(Er)) {
        ;(qt += ge()), (Zt = "decimalExponentInteger")
        return
      }
      throw On(ge())
    },
    decimalExponentInteger() {
      if (fs.isDigit(Er)) {
        qt += ge()
        return
      }
      return Un("numeric", bf * Number(qt))
    },
    hexadecimal() {
      if (fs.isHexDigit(Er)) {
        ;(qt += ge()), (Zt = "hexadecimalInteger")
        return
      }
      throw On(ge())
    },
    hexadecimalInteger() {
      if (fs.isHexDigit(Er)) {
        qt += ge()
        return
      }
      return Un("numeric", bf * Number(qt))
    },
    string() {
      switch (Er) {
        case "\\":
          ge(), (qt += gCt())
          return
        case '"':
          if (ew) return ge(), Un("string", qt)
          qt += ge()
          return
        case "'":
          if (!ew) return ge(), Un("string", qt)
          qt += ge()
          return
        case `
`:
        case "\r":
          throw On(ge())
        case "\u2028":
        case "\u2029":
          ACt(Er)
          break
        case undefined:
          throw On(ge())
      }
      qt += ge()
    },
    start() {
      switch (Er) {
        case "{":
        case "[":
          return Un("punctuator", ge())
      }
      Zt = "value"
    },
    beforePropertyName() {
      switch (Er) {
        case "$":
        case "_":
          ;(qt = ge()), (Zt = "identifierName")
          return
        case "\\":
          ge(), (Zt = "identifierNameStartEscape")
          return
        case "}":
          return Un("punctuator", ge())
        case '"':
        case "'":
          ;(ew = ge() === '"'), (Zt = "string")
          return
      }
      if (fs.isIdStartChar(Er)) {
        ;(qt += ge()), (Zt = "identifierName")
        return
      }
      throw On(ge())
    },
    afterPropertyName() {
      if (Er === ":") return Un("punctuator", ge())
      throw On(ge())
    },
    beforePropertyValue() {
      Zt = "value"
    },
    afterPropertyValue() {
      switch (Er) {
        case ",":
        case "}":
          return Un("punctuator", ge())
      }
      throw On(ge())
    },
    beforeArrayValue() {
      if (Er === "]") return Un("punctuator", ge())
      Zt = "value"
    },
    afterArrayValue() {
      switch (Er) {
        case ",":
        case "]":
          return Un("punctuator", ge())
      }
      throw On(ge())
    },
    end() {
      throw On(ge())
    },
  }
  function Un(e, t) {
    return { type: e, value: t, line: hg, column: Jc }
  }
  function Om(e) {
    for (let t of e) {
      if (_f() !== t) throw On(ge())
      ge()
    }
  }
  function gCt() {
    switch (_f()) {
      case "b":
        return ge(), "\b"
      case "f":
        return ge(), "\f"
      case "n":
        return (
          ge(),
          `
`
        )
      case "r":
        return ge(), "\r"
      case "t":
        return ge(), "	"
      case "v":
        return ge(), "\v"
      case "0":
        if ((ge(), fs.isDigit(_f()))) throw On(ge())
        return "\0"
      case "x":
        return ge(), pCt()
      case "u":
        return ge(), j8()
      case `
`:
      case "\u2028":
      case "\u2029":
        return ge(), ""
      case "\r":
        return (
          ge(),
          _f() ===
            `
` && ge(),
          ""
        )
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        throw On(ge())
      case undefined:
        throw On(ge())
    }
    return ge()
  }
  function pCt() {
    let e = "",
      t = _f()
    if (!fs.isHexDigit(t) || ((e += ge()), (t = _f()), !fs.isHexDigit(t)))
      throw On(ge())
    return (e += ge()), String.fromCodePoint(parseInt(e, 16))
  }
  function j8() {
    let e = "",
      t = 4
    for (; t-- > 0; ) {
      let r = _f()
      if (!fs.isHexDigit(r)) throw On(ge())
      e += ge()
    }
    return String.fromCodePoint(parseInt(e, 16))
  }
  var mCt = {
    start() {
      if (hs.type === "eof") throw qm()
      K8()
    },
    beforePropertyName() {
      switch (hs.type) {
        case "identifier":
        case "string":
          ;(Z8 = hs.value), (Fo = "afterPropertyName")
          return
        case "punctuator":
          K1()
          return
        case "eof":
          throw qm()
      }
    },
    afterPropertyName() {
      if (hs.type === "eof") throw qm()
      Fo = "beforePropertyValue"
    },
    beforePropertyValue() {
      if (hs.type === "eof") throw qm()
      K8()
    },
    beforeArrayValue() {
      if (hs.type === "eof") throw qm()
      if (hs.type === "punctuator" && hs.value === "]") {
        K1()
        return
      }
      K8()
    },
    afterPropertyValue() {
      if (hs.type === "eof") throw qm()
      switch (hs.value) {
        case ",":
          Fo = "beforePropertyName"
          return
        case "}":
          K1()
      }
    },
    afterArrayValue() {
      if (hs.type === "eof") throw qm()
      switch (hs.value) {
        case ",":
          Fo = "beforeArrayValue"
          return
        case "]":
          K1()
      }
    },
    end() {},
  }
  function K8() {
    let e
    switch (hs.type) {
      case "punctuator":
        switch (hs.value) {
          case "{":
            e = {}
            break
          case "[":
            e = []
            break
        }
        break
      case "null":
      case "boolean":
      case "numeric":
      case "string":
        e = hs.value
        break
    }
    if (tw === undefined) tw = e
    else {
      let t = Ef[Ef.length - 1]
      Array.isArray(t)
        ? t.push(e)
        : Object.defineProperty(t, Z8, {
            value: e,
            writable: true,
            enumerable: true,
            configurable: true,
          })
    }
    if (e !== null && typeof e == "object")
      Ef.push(e),
        Array.isArray(e)
          ? (Fo = "beforeArrayValue")
          : (Fo = "beforePropertyName")
    else {
      let t = Ef[Ef.length - 1]
      t == null
        ? (Fo = "end")
        : Array.isArray(t)
          ? (Fo = "afterArrayValue")
          : (Fo = "afterPropertyValue")
    }
  }
  function K1() {
    Ef.pop()
    let e = Ef[Ef.length - 1]
    e == null
      ? (Fo = "end")
      : Array.isArray(e)
        ? (Fo = "afterArrayValue")
        : (Fo = "afterPropertyValue")
  }
  function On(e) {
    return J1(
      e === undefined
        ? `JSON5: invalid end of input at ${hg}:${Jc}`
        : `JSON5: invalid character '${Ewe(e)}' at ${hg}:${Jc}`,
    )
  }
  function qm() {
    return J1(`JSON5: invalid end of input at ${hg}:${Jc}`)
  }
  function Cwe() {
    return (Jc -= 5), J1(`JSON5: invalid identifier character at ${hg}:${Jc}`)
  }
  function ACt(e) {
    console.warn(
      `JSON5: '${Ewe(e)}' in strings is not valid ECMAScript; consider escaping`,
    )
  }
  function Ewe(e) {
    let t = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029",
    }
    if (t[e]) return t[e]
    if (e < " ") {
      let r = e.charCodeAt(0).toString(16)
      return "\\x" + ("00" + r).substring(r.length)
    }
    return e
  }
  function J1(e) {
    let t = new SyntaxError(e)
    return (t.lineNumber = hg), (t.columnNumber = Jc), t
  }
})
var Swe = _((g8t, wwe) => {
  "use strict"
  var X8 = Y8()
  wwe.exports = function (t, r, n) {
    let i = [],
      s = "",
      o,
      a,
      l = "",
      c
    if (
      (r != null &&
        typeof r == "object" &&
        !Array.isArray(r) &&
        ((n = r.space), (c = r.quote), (r = r.replacer)),
      typeof r == "function")
    )
      a = r
    else if (Array.isArray(r)) {
      o = []
      for (let y of r) {
        let v
        typeof y == "string"
          ? (v = y)
          : (typeof y == "number" ||
              y instanceof String ||
              y instanceof Number) &&
            (v = String(y)),
          v !== undefined && o.indexOf(v) < 0 && o.push(v)
      }
    }
    return (
      n instanceof Number
        ? (n = Number(n))
        : n instanceof String && (n = String(n)),
      typeof n == "number"
        ? n > 0 &&
          ((n = Math.min(10, Math.floor(n))), (l = "          ".substr(0, n)))
        : typeof n == "string" && (l = n.substr(0, 10)),
      u("", { "": t })
    )
    function u(y, v) {
      let C = v[y]
      switch (
        (C != null &&
          (typeof C.toJSON5 == "function"
            ? (C = C.toJSON5(y))
            : typeof C.toJSON == "function" && (C = C.toJSON(y))),
        a && (C = a.call(v, y, C)),
        C instanceof Number
          ? (C = Number(C))
          : C instanceof String
            ? (C = String(C))
            : C instanceof Boolean && (C = C.valueOf()),
        C)
      ) {
        case null:
          return "null"
        case true:
          return "true"
        case false:
          return "false"
      }
      if (typeof C == "string") return f(C, false)
      if (typeof C == "number") return String(C)
      if (typeof C == "object") return Array.isArray(C) ? m(C) : p(C)
    }
    function f(y) {
      let v = { "'": 0.1, '"': 0.2 },
        C = {
          "'": "\\'",
          '"': '\\"',
          "\\": "\\\\",
          "\b": "\\b",
          "\f": "\\f",
          "\n": "\\n",
          "\r": "\\r",
          "	": "\\t",
          "\v": "\\v",
          "\0": "\\0",
          "\u2028": "\\u2028",
          "\u2029": "\\u2029",
        },
        E = ""
      for (let B = 0; B < y.length; B++) {
        let T = y[B]
        switch (T) {
          case "'":
          case '"':
            v[T]++, (E += T)
            continue
          case "\0":
            if (X8.isDigit(y[B + 1])) {
              E += "\\x00"
              continue
            }
        }
        if (C[T]) {
          E += C[T]
          continue
        }
        if (T < " ") {
          let N = T.charCodeAt(0).toString(16)
          E += "\\x" + ("00" + N).substring(N.length)
          continue
        }
        E += T
      }
      let w = c || Object.keys(v).reduce((B, T) => (v[B] < v[T] ? B : T))
      return (E = E.replace(new RegExp(w, "g"), C[w])), w + E + w
    }
    function p(y) {
      if (i.indexOf(y) >= 0)
        throw TypeError("Converting circular structure to JSON5")
      i.push(y)
      let v = s
      s = s + l
      let C = o || Object.keys(y),
        E = []
      for (let B of C) {
        let T = u(B, y)
        if (T !== undefined) {
          let N = g(B) + ":"
          l !== "" && (N += " "), (N += T), E.push(N)
        }
      }
      let w
      if (E.length === 0) w = "{}"
      else {
        let B
        if (l === "") (B = E.join(",")), (w = "{" + B + "}")
        else {
          let T =
            `,
` + s
          ;(B = E.join(T)),
            (w =
              `{
` +
              s +
              B +
              `,
` +
              v +
              "}")
        }
      }
      return i.pop(), (s = v), w
    }
    function g(y) {
      if (y.length === 0) return f(y, true)
      let v = String.fromCodePoint(y.codePointAt(0))
      if (!X8.isIdStartChar(v)) return f(y, true)
      for (let C = v.length; C < y.length; C++)
        if (!X8.isIdContinueChar(String.fromCodePoint(y.codePointAt(C))))
          return f(y, true)
      return y
    }
    function m(y) {
      if (i.indexOf(y) >= 0)
        throw TypeError("Converting circular structure to JSON5")
      i.push(y)
      let v = s
      s = s + l
      let C = []
      for (let w = 0; w < y.length; w++) {
        let B = u(String(w), y)
        C.push(B !== undefined ? B : "null")
      }
      let E
      if (C.length === 0) E = "[]"
      else if (l === "") E = "[" + C.join(",") + "]"
      else {
        let w =
            `,
` + s,
          B = C.join(w)
        E =
          `[
` +
          s +
          B +
          `,
` +
          v +
          "]"
      }
      return i.pop(), (s = v), E
    }
  }
})
var e6 = _((p8t, Iwe) => {
  "use strict"
  var yCt = xwe(),
    vCt = Swe(),
    CCt = { parse: yCt, stringify: vCt }
  Iwe.exports = CCt
})
var F6 = _((VXt, pIe) => {
  "use strict"
  function ri(e, r) {
    var r = r || {}
    ;(this._capacity = r.capacity),
      (this._head = 0),
      (this._tail = 0),
      Array.isArray(e)
        ? this._fromArray(e)
        : ((this._capacityMask = 3), (this._list = new Array(4)))
  }
  ri.prototype.peekAt = function (t) {
    var r = t
    if (r === (r | 0)) {
      var n = this.size()
      if (!(r >= n || r < -n))
        return (
          r < 0 && (r += n),
          (r = (this._head + r) & this._capacityMask),
          this._list[r]
        )
    }
  }
  ri.prototype.get = function (t) {
    return this.peekAt(t)
  }
  ri.prototype.peek = function () {
    if (this._head !== this._tail) return this._list[this._head]
  }
  ri.prototype.peekFront = function () {
    return this.peek()
  }
  ri.prototype.peekBack = function () {
    return this.peekAt(-1)
  }
  Object.defineProperty(ri.prototype, "length", {
    get: function () {
      return this.size()
    },
  })
  ri.prototype.size = function () {
    return this._head === this._tail
      ? 0
      : this._head < this._tail
        ? this._tail - this._head
        : this._capacityMask + 1 - (this._head - this._tail)
  }
  ri.prototype.unshift = function (t) {
    if (arguments.length === 0) return this.size()
    var r = this._list.length
    return (
      (this._head = (this._head - 1 + r) & this._capacityMask),
      (this._list[this._head] = t),
      this._tail === this._head && this._growArray(),
      this._capacity && this.size() > this._capacity && this.pop(),
      this._head < this._tail
        ? this._tail - this._head
        : this._capacityMask + 1 - (this._head - this._tail)
    )
  }
  ri.prototype.shift = function () {
    var t = this._head
    if (t !== this._tail) {
      var r = this._list[t]
      return (
        (this._list[t] = undefined),
        (this._head = (t + 1) & this._capacityMask),
        t < 2 &&
          this._tail > 1e4 &&
          this._tail <= this._list.length >>> 2 &&
          this._shrinkArray(),
        r
      )
    }
  }
  ri.prototype.push = function (t) {
    if (arguments.length === 0) return this.size()
    var r = this._tail
    return (
      (this._list[r] = t),
      (this._tail = (r + 1) & this._capacityMask),
      this._tail === this._head && this._growArray(),
      this._capacity && this.size() > this._capacity && this.shift(),
      this._head < this._tail
        ? this._tail - this._head
        : this._capacityMask + 1 - (this._head - this._tail)
    )
  }
  ri.prototype.pop = function () {
    var t = this._tail
    if (t !== this._head) {
      var r = this._list.length
      this._tail = (t - 1 + r) & this._capacityMask
      var n = this._list[this._tail]
      return (
        (this._list[this._tail] = undefined),
        this._head < 2 && t > 1e4 && t <= r >>> 2 && this._shrinkArray(),
        n
      )
    }
  }
  ri.prototype.removeOne = function (t) {
    var r = t
    if (r === (r | 0) && this._head !== this._tail) {
      var n = this.size(),
        i = this._list.length
      if (!(r >= n || r < -n)) {
        r < 0 && (r += n), (r = (this._head + r) & this._capacityMask)
        var s = this._list[r],
          o
        if (t < n / 2) {
          for (o = t; o > 0; o--)
            this._list[r] = this._list[(r = (r - 1 + i) & this._capacityMask)]
          ;(this._list[r] = undefined),
            (this._head = (this._head + 1 + i) & this._capacityMask)
        } else {
          for (o = n - 1 - t; o > 0; o--)
            this._list[r] = this._list[(r = (r + 1 + i) & this._capacityMask)]
          ;(this._list[r] = undefined),
            (this._tail = (this._tail - 1 + i) & this._capacityMask)
        }
        return s
      }
    }
  }
  ri.prototype.remove = function (t, r) {
    var n = t,
      i,
      s = r
    if (n === (n | 0) && this._head !== this._tail) {
      var o = this.size(),
        a = this._list.length
      if (!(n >= o || n < -o || r < 1)) {
        if ((n < 0 && (n += o), r === 1 || !r))
          return (i = new Array(1)), (i[0] = this.removeOne(n)), i
        if (n === 0 && n + r >= o) return (i = this.toArray()), this.clear(), i
        n + r > o && (r = o - n)
        var l
        for (i = new Array(r), l = 0; l < r; l++)
          i[l] = this._list[(this._head + n + l) & this._capacityMask]
        if (((n = (this._head + n) & this._capacityMask), t + r === o)) {
          for (
            this._tail = (this._tail - r + a) & this._capacityMask, l = r;
            l > 0;
            l--
          )
            this._list[(n = (n + 1 + a) & this._capacityMask)] = undefined
          return i
        }
        if (t === 0) {
          for (
            this._head = (this._head + r + a) & this._capacityMask, l = r - 1;
            l > 0;
            l--
          )
            this._list[(n = (n + 1 + a) & this._capacityMask)] = undefined
          return i
        }
        if (n < o / 2) {
          for (
            this._head = (this._head + t + r + a) & this._capacityMask, l = t;
            l > 0;
            l--
          )
            this.unshift(this._list[(n = (n - 1 + a) & this._capacityMask)])
          for (n = (this._head - 1 + a) & this._capacityMask; s > 0; )
            (this._list[(n = (n - 1 + a) & this._capacityMask)] = undefined), s--
          t < 0 && (this._tail = n)
        } else {
          for (
            this._tail = n,
              n = (n + r + a) & this._capacityMask,
              l = o - (r + t);
            l > 0;
            l--
          )
            this.push(this._list[n++])
          for (n = this._tail; s > 0; )
            (this._list[(n = (n + 1 + a) & this._capacityMask)] = undefined), s--
        }
        return (
          this._head < 2 &&
            this._tail > 1e4 &&
            this._tail <= a >>> 2 &&
            this._shrinkArray(),
          i
        )
      }
    }
  }
  ri.prototype.splice = function (t, r) {
    var n = t
    if (n === (n | 0)) {
      var i = this.size()
      if ((n < 0 && (n += i), !(n > i)))
        if (arguments.length > 2) {
          var s,
            o,
            a,
            l = arguments.length,
            c = this._list.length,
            u = 2
          if (!i || n < i / 2) {
            for (o = new Array(n), s = 0; s < n; s++)
              o[s] = this._list[(this._head + s) & this._capacityMask]
            for (
              r === 0
                ? ((a = []),
                  n > 0 &&
                    (this._head = (this._head + n + c) & this._capacityMask))
                : ((a = this.remove(n, r)),
                  (this._head = (this._head + n + c) & this._capacityMask));
              l > u;

            )
              this.unshift(arguments[--l])
            for (s = n; s > 0; s--) this.unshift(o[s - 1])
          } else {
            o = new Array(i - (n + r))
            var f = o.length
            for (s = 0; s < f; s++)
              o[s] = this._list[(this._head + n + r + s) & this._capacityMask]
            for (
              r === 0
                ? ((a = []),
                  n != i &&
                    (this._tail = (this._head + n + c) & this._capacityMask))
                : ((a = this.remove(n, r)),
                  (this._tail = (this._tail - f + c) & this._capacityMask));
              u < l;

            )
              this.push(arguments[u++])
            for (s = 0; s < f; s++) this.push(o[s])
          }
          return a
        } else return this.remove(n, r)
    }
  }
  ri.prototype.clear = function () {
    ;(this._list = new Array(this._list.length)),
      (this._head = 0),
      (this._tail = 0)
  }
  ri.prototype.isEmpty = function () {
    return this._head === this._tail
  }
  ri.prototype.toArray = function () {
    return this._copyArray(false)
  }
  ri.prototype._fromArray = function (t) {
    var r = t.length,
      n = this._nextPowerOf2(r)
    ;(this._list = new Array(n)), (this._capacityMask = n - 1), (this._tail = r)
    for (var i = 0; i < r; i++) this._list[i] = t[i]
  }
  ri.prototype._copyArray = function (t, r) {
    var n = this._list,
      i = n.length,
      s = this.length
    if (((r = r | s), r == s && this._head < this._tail))
      return this._list.slice(this._head, this._tail)
    var o = new Array(r),
      a = 0,
      l
    if (t || this._head > this._tail) {
      for (l = this._head; l < i; l++) o[a++] = n[l]
      for (l = 0; l < this._tail; l++) o[a++] = n[l]
    } else for (l = this._head; l < this._tail; l++) o[a++] = n[l]
    return o
  }
  ri.prototype._growArray = function () {
    if (this._head != 0) {
      var t = this._copyArray(true, this._list.length << 1)
      ;(this._tail = this._list.length), (this._head = 0), (this._list = t)
    } else (this._tail = this._list.length), (this._list.length <<= 1)
    this._capacityMask = (this._capacityMask << 1) | 1
  }
  ri.prototype._shrinkArray = function () {
    ;(this._list.length >>>= 1), (this._capacityMask >>>= 1)
  }
  ri.prototype._nextPowerOf2 = function (t) {
    var r = Math.log(t) / Math.log(2),
      n = 1 << (r + 1)
    return Math.max(n, 4)
  }
  pIe.exports = ri
})
var SIe = _((ler, wIe) => {
  "use strict"
  function AIe(e) {
    return Array.isArray(e) ? e : [e]
  }
  var bIe = "",
    yIe = " ",
    N6 = "\\",
    cbt = /^\s+$/,
    ubt = /(?:[^\\]|^)\\$/,
    dbt = /^\\!/,
    fbt = /^\\#/,
    hbt = /\r?\n/g,
    gbt = /^\.*\/|^\.+$/,
    P6 = "/",
    EIe = "node-ignore"
  typeof Symbol < "u" && (EIe = Symbol.for("node-ignore"))
  var vIe = EIe,
    pbt = (e, t, r) => Object.defineProperty(e, t, { value: r }),
    mbt = /([0-z])-([0-z])/g,
    _Ie = () => false,
    Abt = (e) =>
      e.replace(mbt, (t, r, n) =>
        r.charCodeAt(0) <= n.charCodeAt(0) ? t : bIe,
      ),
    ybt = (e) => {
      let { length: t } = e
      return e.slice(0, t - (t % 2))
    },
    vbt = [
      [/\\?\s+$/, (e) => (e.indexOf("\\") === 0 ? yIe : bIe)],
      [/\\\s/g, () => yIe],
      [/[\\$.|*+(){^]/g, (e) => `\\${e}`],
      [/(?!\\)\?/g, () => "[^/]"],
      [/^\//, () => "^"],
      [/\//g, () => "\\/"],
      [/^\^*\\\*\\\*\\\//, () => "^(?:.*\\/)?"],
      [
        /^(?=[^^])/,
        function () {
          return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)"
        },
      ],
      [
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        (e, t, r) => (t + 6 < r.length ? "(?:\\/[^\\/]+)*" : "\\/.+"),
      ],
      [
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        (e, t, r) => {
          let n = r.replace(/\\\*/g, "[^\\/]*")
          return t + n
        },
      ],
      [/\\\\\\(?=[$.|*+(){^])/g, () => N6],
      [/\\\\/g, () => N6],
      [
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (e, t, r, n, i) =>
          t === N6
            ? `\\[${r}${ybt(n)}${i}`
            : i === "]" && n.length % 2 === 0
              ? `[${Abt(r)}${n}]`
              : "[]",
      ],
      [/(?:[^*])$/, (e) => (/\/$/.test(e) ? `${e}$` : `${e}(?=$|\\/$)`)],
      [/(\^|\\\/)?\\\*$/, (e, t) => `${t ? `${t}[^/]+` : "[^/]*"}(?=$|\\/$)`],
    ],
    CIe = Object.create(null),
    Cbt = (e, t) => {
      let r = CIe[e]
      return (
        r ||
          ((r = vbt.reduce((n, i) => n.replace(i[0], i[1].bind(e)), e)),
          (CIe[e] = r)),
        t ? new RegExp(r, "i") : new RegExp(r)
      )
    },
    O6 = (e) => typeof e == "string",
    bbt = (e) =>
      e && O6(e) && !cbt.test(e) && !ubt.test(e) && e.indexOf("#") !== 0,
    Ebt = (e) => e.split(hbt),
    L6 = class {
      constructor(t, r, n, i) {
        ;(this.origin = t),
          (this.pattern = r),
          (this.negative = n),
          (this.regex = i)
      }
    },
    _bt = (e, t) => {
      let r = e,
        n = false
      e.indexOf("!") === 0 && ((n = true), (e = e.substr(1))),
        (e = e.replace(dbt, "!").replace(fbt, "#"))
      let i = Cbt(e, t)
      return new L6(r, e, n, i)
    },
    xbt = (e, t) => {
      throw new t(e)
    },
    Rf = (e, t, r) =>
      O6(e)
        ? e
          ? Rf.isNotRelative(e)
            ? r(
                `path should be a \`path.relative()\`d string, but got "${t}"`,
                RangeError,
              )
            : true
          : r("path must not be empty", TypeError)
        : r(`path must be a string, but got \`${t}\``, TypeError),
    xIe = (e) => gbt.test(e)
  Rf.isNotRelative = xIe
  Rf.convert = (e) => e
  var U6 = class {
      constructor({
        ignorecase: t = true,
        ignoreCase: r = t,
        allowRelativePaths: n = false,
      } = {}) {
        pbt(this, vIe, true),
          (this._rules = []),
          (this._ignoreCase = r),
          (this._allowRelativePaths = n),
          this._initCache()
      }
      _initCache() {
        ;(this._ignoreCache = Object.create(null)),
          (this._testCache = Object.create(null))
      }
      _addPattern(t) {
        if (t && t[vIe]) {
          ;(this._rules = this._rules.concat(t._rules)), (this._added = true)
          return
        }
        if (bbt(t)) {
          let r = _bt(t, this._ignoreCase)
          ;(this._added = true), this._rules.push(r)
        }
      }
      add(t) {
        return (
          (this._added = false),
          AIe(O6(t) ? Ebt(t) : t).forEach(this._addPattern, this),
          this._added && this._initCache(),
          this
        )
      }
      addPattern(t) {
        return this.add(t)
      }
      _testOne(t, r) {
        let n = false,
          i = false
        return (
          this._rules.forEach((s) => {
            let { negative: o } = s
            if ((i === o && n !== i) || (o && !n && !i && !r)) return
            s.regex.test(t) && ((n = !o), (i = o))
          }),
          { ignored: n, unignored: i }
        )
      }
      _test(t, r, n, i) {
        let s = t && Rf.convert(t)
        return (
          Rf(s, t, this._allowRelativePaths ? _Ie : xbt), this._t(s, r, n, i)
        )
      }
      _t(t, r, n, i) {
        if (t in r) return r[t]
        if ((i || (i = t.split(P6)), i.pop(), !i.length))
          return (r[t] = this._testOne(t, n))
        let s = this._t(i.join(P6) + P6, r, n, i)
        if (s.ignored) return (r[t] = s)
        let o = this._testOne(t, n)
        return (r[t] = {
          ignored: o.ignored,
          unignored: s.unignored || o.unignored,
        })
      }
      ignores(t) {
        return this._test(t, this._ignoreCache, false).ignored
      }
      createFilter() {
        return (t) => !this.ignores(t)
      }
      filter(t) {
        return AIe(t).filter(this.createFilter())
      }
      test(t) {
        return this._test(t, this._testCache, true)
      }
    },
    s2 = (e) => new U6(e),
    wbt = (e) => Rf(e && Rf.convert(e), e, _Ie)
  s2.isPathValid = wbt
  s2.default = s2
  wIe.exports = s2
  if (
    typeof process < "u" &&
    ((process.env && process.env.IGNORE_TEST_WIN32) ||
      process.platform === "win32")
  ) {
    let e = (r) =>
      /^\\\\\?\\/.test(r) || /["<>|\u0000-\u001F]+/u.test(r)
        ? r
        : r.replace(/\\/g, "/")
    Rf.convert = e
    let t = /^[a-z]:\//i
    Rf.isNotRelative = (r) => t.test(r) || xIe(r)
  }
})
var sEt = {}
lL(sEt, {
  AugmentExtension: () => AugmentExtension,
  _exportedForTesting: () => iEt,
  activate: () => activate,
  getSessionId: () => eBe,
})
module.exports = cL(sEt)
var XC
function IY(e) {
  if (XC) {
    XC.warn(
      "Attempting to initialize logger when one is already configured. Keeping existing logger.",
    )
    return
  }
  XC = e
}
function getLogger(e) {
  if (!XC)
    throw new Error(
      "Logger not initialized. Call setLibraryLogger() before using getLogger().",
    )
  return XC.child({ prefix: e })
}
var eb = class {
    static _instance = undefined
    static setPluginFileStore(t) {
      if (this._instance !== undefined) {
        getLogger("PluginFileStore").warn(
          "Attempting to initialize client workspaces when one is already configured. Keeping existing client workspaces.",
        )
        return
      }
      this._instance = t
    }
    static getPluginFileStore() {
      if (this._instance === undefined) throw new Error("PluginFileStore not set")
      return this._instance
    }
    static reset() {
      this._instance = undefined
    }
  },
  BY = (e) => eb.setPluginFileStore(e),
  Og = () => eb.getPluginFileStore(),
  RY = () => eb.reset()
var zS = class e {
    _logger = getLogger("AgentShardStorage")
    static storagePathKeyPrefix = "agent-edit-shard-storage"
    static manifestKey = "manifest"
    static serializedStoreKey = "serialized-store"
    async save(t) {
      await this._saveJson(
        this._getStoragePath(Id.serializedStore, e.serializedStoreKey),
        t,
      )
    }
    async load() {
      return this._loadJson(
        this._getStoragePath(Id.serializedStore, e.serializedStoreKey),
      )
    }
    async _saveJson(t, r) {
      let n = Buffer.from(JSON.stringify(r), "utf8")
      await Og().saveAsset(t, new Uint8Array(n))
    }
    async _loadJson(t) {
      let r = await Og().loadAsset(t)
      if (!(!r || r.length === 0))
        return JSON.parse(Buffer.from(r).toString("utf8"))
    }
    _getStoragePath(t, r) {
      return `agent-edits/${t}/${e.storagePathKeyPrefix}-${r}.json`
    }
    async saveShard(t, r) {
      await this._saveJson(this._getStoragePath(Id.shards, t), r)
    }
    async loadShard(t) {
      return this._loadJson(this._getStoragePath(Id.shards, t))
    }
    async deleteShard(t) {
      await Og().deleteAsset(this._getStoragePath(Id.shards, t))
    }
    async saveManifest(t) {
      await this._saveJson(this._getStoragePath(Id.manifest, e.manifestKey), t)
    }
    async loadManifest() {
      return this._loadJson(this._getStoragePath(Id.manifest, e.manifestKey))
    }
  },
  Id
;(function (e) {
  ;(e.shards = "shards"),
    (e.manifest = "manifest"),
    (e.serializedStore = "serialized-store")
})(Id || (Id = {}))
var tb = require("path")
function joinPaths(basePath, relativePath, ensureTrailingSlash = false) {
  let fullPath = (0, tb.join)(basePath, relativePath)
  return ensureTrailingSlash && !fullPath.endsWith(tb.sep) && (fullPath += tb.sep), fullPath
}
var QualifiedPathName = class e {
  rootPath
  relPath
  constructor(t, r) {
    ;(this.rootPath = t), (this.relPath = r)
  }
  static from(t) {
    return new e(t.rootPath, t.relPath)
  }
  get absPath() {
    return joinPaths(this.rootPath, this.relPath)
  }
  equals(t) {
    return e.equals(this, t)
  }
  static equals(t, r) {
    if (t === r) return true
    if (t == null || r == null) return false
    let n = DY(t) ? joinPaths(t.rootPath, t.relPath) : t.fsPath,
      i = DY(r) ? joinPaths(r.rootPath, r.relPath) : r.fsPath
    return n === i
  }
}
function DY(e) {
  return (
    e != null && typeof e == "object" && ("rootPath" in e || "relPath" in e)
  )
}
function xA(e) {
  return (
    typeof e == "object" &&
    e !== null &&
    "document" in e &&
    typeof e.document == "object" &&
    e.document !== null &&
    "path" in e.document &&
    !("checkpointId" in e)
  )
}
function wA(e) {
  return (
    typeof e == "object" &&
    e !== null &&
    "documentMetadata" in e &&
    typeof e.documentMetadata == "object" &&
    e.documentMetadata !== null &&
    "path" in e.documentMetadata &&
    !("document" in e)
  )
}
function TY(e) {
  return typeof e != "string"
    ? { isValid: false, reason: "Shard ID must be a string" }
    : e.length === 0
      ? { isValid: false, reason: "Shard ID cannot be empty" }
      : { isValid: true }
}
function uL(e) {
  if (typeof e.version != "number" || typeof e.lastUpdated != "number")
    return {
      isValid: false,
      reason: "Invalid manifest version or lastUpdated timestamp",
    }
  if (!e.shards || typeof e.shards != "object")
    return { isValid: false, reason: "Missing or invalid shards object" }
  for (let [t, r] of Object.entries(e.shards)) {
    let n = TY(t)
    if (!n.isValid) return n
    if (!r || typeof r != "object")
      return { isValid: false, reason: `Invalid metadata object for shard ${t}` }
    if (typeof r.size != "number")
      return { isValid: false, reason: `Invalid size field for shard ${t}` }
    if (typeof r.checkpointCount != "number")
      return {
        isValid: false,
        reason: `Invalid checkpointCount field for shard ${t}`,
      }
    if (typeof r.lastModified != "number")
      return {
        isValid: false,
        reason: `Invalid lastModified field for shard ${t}`,
      }
    if (!Array.isArray(r.checkpointDocumentIds))
      return {
        isValid: false,
        reason: `Invalid checkpointDocumentIds array for shard ${t}`,
      }
    for (let i of r.checkpointDocumentIds)
      if (typeof i != "string" || i.length === 0)
        return {
          isValid: false,
          reason: `Invalid checkpoint document ID in shard ${t}: ${i}`,
        }
  }
  return { isValid: true }
}
function kY(e) {
  let t = {}
  for (let [n, i] of Object.entries(e.shards))
    DFe({ id: n, checkpoints: {}, metadata: i }).isValid && (t[n] = i)
  let r = 1
  return (
    typeof e.version == "number" && e.version >= 1
      ? (r = e.version + 1)
      : (r = 1),
    { ...e, version: r, lastUpdated: Date.now(), shards: t }
  )
}
function DFe(e) {
  let t = TY(e.id)
  if (!t.isValid) return t
  let r = uL({
    version: 1,
    lastUpdated: Date.now(),
    shards: { [e.id]: e.metadata },
  })
  if (!r.isValid) return r
  if (typeof e.checkpoints != "object" || !e.checkpoints)
    return { isValid: false, reason: "Missing or invalid checkpoints object" }
  for (let [s, o] of Object.entries(e.checkpoints)) {
    if (typeof s != "string" || s.length === 0)
      return { isValid: false, reason: `Invalid checkpoint ID: ${s}` }
    if (!Array.isArray(o))
      return { isValid: false, reason: `Checkpoints for ID ${s} must be an array` }
    for (let a of o) {
      if (
        typeof a != "object" ||
        !a ||
        typeof a.sourceToolCallRequestId != "string" ||
        typeof a.timestamp != "number" ||
        typeof a.conversationId != "string"
      )
        return {
          isValid: false,
          reason: `Invalid checkpoint common properties in ID ${s}`,
        }
      if (xA(a)) {
        let l = TFe(a.document, s)
        if (!l.isValid) return l
      } else if (wA(a)) {
        if (typeof a.documentMetadata != "object" || !a.documentMetadata)
          return {
            isValid: false,
            reason: `Invalid DehydratedCheckpoint structure in ID ${s}`,
          }
      } else
        return { isValid: false, reason: `Unknown checkpoint type in ID ${s}` }
    }
  }
  let n = new Set(Object.keys(e.checkpoints)),
    i = new Set(e.metadata.checkpointDocumentIds)
  if (n.size !== i.size)
    return {
      isValid: false,
      reason:
        "Mismatch between checkpoint IDs in metadata and actual checkpoints",
    }
  for (let s of n)
    if (!i.has(s))
      return {
        isValid: false,
        reason:
          "Mismatch between checkpoint IDs in metadata and actual checkpoints",
      }
  return { isValid: true }
}
function TFe(e, t) {
  if (typeof e != "object" || !e)
    return {
      isValid: false,
      reason: `Invalid SerializedCheckpoint structure in ID ${t}`,
    }
  let r = e
  if (
    (r.originalCode !== undefined && typeof r.originalCode != "string") ||
    (r.modifiedCode !== undefined && typeof r.modifiedCode != "string")
  )
    return {
      isValid: false,
      reason: `Invalid SerializedCheckpoint structure in ID ${t}`,
    }
  if (typeof r.path != "object" || !r.path)
    return {
      isValid: false,
      reason: `Invalid SerializedCheckpoint structure in ID ${t}`,
    }
  let n = r.path
  return typeof n.rootPath != "string" || typeof n.relPath != "string"
    ? {
        isValid: false,
        reason: `Invalid SerializedCheckpoint structure in ID ${t}`,
      }
    : { isValid: true }
}
function dL(e, t, r = true) {
  let { minTimestamp: n, maxTimestamp: i, minIdx: s, maxIdx: o } = t
  return e.filter((a, l) => {
    let c =
        (n === undefined || a.timestamp >= n) && (i === undefined || a.timestamp < i),
      u = (s === undefined || l >= s) && (o === undefined || l < o),
      f = n !== undefined || i !== undefined,
      p = s !== undefined || o !== undefined
    if (!(f || p)) return r
    let m = (!f || c) && (!p || u)
    return r ? m : !m
  })
}
var DisposableCollection_2 = class {
  _disposables = []
  add(disposable) {
    if (disposable === undefined)
      throw new Error(
        "Attempt to add undefined disposable to DisposableCollection",
      )
    return this._disposables.push(disposable), disposable
  }
  addAll(...disposables) {
    disposables.forEach((disposable) => this.add(disposable))
  }
  adopt(otherCollection) {
    this._disposables.push(...otherCollection._disposables), (otherCollection._disposables.length = 0)
  }
  dispose() {
    for (let disposable of this._disposables) disposable.dispose()
    this._disposables.length = 0
  }
}
var DisposableContainer_2 = class {
  _disposables = new DisposableCollection_2()
  _priorityDisposables = new DisposableCollection_2()
  constructor(t = new DisposableCollection_2(), r = new DisposableCollection_2()) {
    this._disposables.adopt(t), this._priorityDisposables.adopt(r)
  }
  addDisposable(t, r = false) {
    return r ? this._priorityDisposables.add(t) : this._disposables.add(t)
  }
  addDisposables(...t) {
    this._disposables.addAll(...t)
  }
  dispose() {
    this._priorityDisposables.dispose(), this._disposables.dispose()
  }
}
var DiffViewDocument = class e extends DisposableContainer_2 {
  filePath
  _originalCode
  _modifiedCode
  _opts
  static EMPTY_PATH_NAME = { rootPath: "", relPath: "" }
  _originalListeners
  _modifiedListeners
  _isUntitled
  constructor(t, r, n, i) {
    super(),
      (this.filePath = t),
      (this._originalCode = r),
      (this._modifiedCode = n),
      (this._opts = i),
      (this._isUntitled = this._opts.isUntitled ?? (() => false)),
      (this._originalListeners = new Set()),
      (this._modifiedListeners = new Set()),
      this.addDisposable({ dispose: () => this._originalListeners.clear() }),
      this.addDisposable({ dispose: () => this._modifiedListeners.clear() }),
      this._opts?.logger?.debug(this.toString("constructor", true))
  }
  toString(t, r = false) {
    let n = this.isUntitled ? " (untitled)" : "",
      i = this._originalCode !== this._modifiedCode,
      s = this._originalCode
        ? this._originalCode.split(`
`).length
        : 0,
      o = this._modifiedCode
        ? this._modifiedCode.split(`
`).length
        : 0,
      a = this._originalCode !== undefined,
      l = this._modifiedCode !== undefined
    return r
      ? [
          `[${t}] DiffViewDocument`,
          "----------------------------------------",
          `Path      : ${this.filePath.absPath}${n}`,
          `Original  : ${a ? `${s} lines` : "(file deleted)"}`,
          `Modified  : ${l ? `${o} lines` : "(file deleted)"}`,
          "----------------------------------------",
        ].join(`
`)
      : [
          `[${t}] DiffViewDocument`,
          "----------------------------------------",
          `Path      : ${this.filePath.absPath}${n}`,
          `Status    : ${i ? "Modified" : "Unchanged"}`,
          `Orig Size : ${a ? `${this._originalCode?.length} chars` : "(file deleted)"}`,
          `Mod Size  : ${l ? `${this._modifiedCode?.length} chars` : "(file deleted)"}`,
          "",
          "Original Code:",
          a ? this._originalCode || "(empty)" : "(file deleted)",
          "",
          "Modified Code:",
          l ? this._modifiedCode || "(empty)" : "(file deleted)",
          "----------------------------------------",
        ].join(`
`)
  }
  static empty() {
    return new e(QualifiedPathName.from(e.EMPTY_PATH_NAME), "", "", {})
  }
  static deleted(t) {
    return new e(t, undefined, undefined, {})
  }
  get isEmptyDocument() {
    return this.filePath.equals(e.EMPTY_PATH_NAME)
  }
  get absPath() {
    return this.filePath.absPath
  }
  get originalCode() {
    return this.isEmptyDocument ? "" : this._originalCode
  }
  get modifiedCode() {
    return this.isEmptyDocument ? "" : this._modifiedCode
  }
  get isUntitled() {
    return this._isUntitled(this.filePath)
  }
  onOriginalUpdated = (t) => (
    this._originalListeners.add(t),
    { dispose: () => this._originalListeners.delete(t) }
  )
  onModifiedUpdated = (t) => (
    this._modifiedListeners.add(t),
    { dispose: () => this._modifiedListeners.delete(t) }
  )
  updateOriginal = (t) =>
    this.originalCode === t
      ? false
      : ((this._originalCode = t),
        this._originalListeners.forEach((r) => r(this)),
        true)
  updateBuffer = (t) =>
    this.modifiedCode === t
      ? false
      : ((this._modifiedCode = t),
        this._modifiedListeners.forEach((r) => r(this)),
        true)
  updateCodeVersions = (t, r) => {
    let n = false
    return t === undefined && r === undefined
      ? ((n = this.updateOriginal(undefined) || n),
        (n = this.updateBuffer(undefined) || n),
        n)
      : (t !== undefined && (n = this.updateOriginal(t) || n),
        r !== undefined && (n = this.updateBuffer(r) || n),
        n)
  }
}
var SA =
    typeof performance == "object" &&
    performance &&
    typeof performance.now == "function"
      ? performance
      : Date,
  FY = new Set(),
  fL = typeof process == "object" && process ? process : {},
  QY = (e, t, r, n) => {
    typeof fL.emitWarning == "function"
      ? fL.emitWarning(e, t, r, n)
      : console.error(`[${r}] ${t}: ${e}`)
  },
  JS = globalThis.AbortController,
  MY = globalThis.AbortSignal
if (typeof JS > "u") {
  ;(MY = class {
    onabort
    _onabort = []
    reason
    aborted = false
    addEventListener(n, i) {
      this._onabort.push(i)
    }
  }),
    (JS = class {
      constructor() {
        t()
      }
      signal = new MY()
      abort(n) {
        if (!this.signal.aborted) {
          ;(this.signal.reason = n), (this.signal.aborted = true)
          for (let i of this.signal._onabort) i(n)
          this.signal.onabort?.(n)
        }
      }
    })
  let e = fL.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1",
    t = () => {
      e &&
        ((e = false),
        QY(
          "AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.",
          "NO_ABORT_CONTROLLER",
          "ENOTSUP",
          t,
        ))
    }
}
var kFe = (e) => !FY.has(e),
  IEt = Symbol("type"),
  Wf = (e) => e && e === Math.floor(e) && e > 0 && isFinite(e),
  NY = (e) =>
    Wf(e)
      ? e <= Math.pow(2, 8)
        ? Uint8Array
        : e <= Math.pow(2, 16)
          ? Uint16Array
          : e <= Math.pow(2, 32)
            ? Uint32Array
            : e <= Number.MAX_SAFE_INTEGER
              ? IA
              : null
      : null,
  IA = class extends Array {
    constructor(t) {
      super(t), this.fill(0)
    }
  },
  hL = class e {
    heap
    length
    static #e = false
    static create(t) {
      let r = NY(t)
      if (!r) return []
      e.#e = true
      let n = new e(t, r)
      return (e.#e = false), n
    }
    constructor(t, r) {
      if (!e.#e) throw new TypeError("instantiate Stack using Stack.create(n)")
      ;(this.heap = new r(t)), (this.length = 0)
    }
    push(t) {
      this.heap[this.length++] = t
    }
    pop() {
      return this.heap[--this.length]
    }
  },
  Gf = class e {
    #e
    #t
    #i
    #n
    #r
    #l
    ttl
    ttlResolution
    ttlAutopurge
    updateAgeOnGet
    updateAgeOnHas
    allowStale
    noDisposeOnSet
    noUpdateTTL
    maxEntrySize
    sizeCalculation
    noDeleteOnFetchRejection
    noDeleteOnStaleGet
    allowStaleOnFetchAbort
    allowStaleOnFetchRejection
    ignoreFetchAbort
    #o
    #u
    #d
    #a
    #s
    #p
    #A
    #g
    #f
    #C
    #h
    #b
    #E
    #y
    #_
    #B
    #m
    static unsafeExposeInternals(t) {
      return {
        starts: t.#E,
        ttls: t.#y,
        sizes: t.#b,
        keyMap: t.#d,
        keyList: t.#a,
        valList: t.#s,
        next: t.#p,
        prev: t.#A,
        get head() {
          return t.#g
        },
        get tail() {
          return t.#f
        },
        free: t.#C,
        isBackgroundFetch: (r) => t.#c(r),
        backgroundFetch: (r, n, i, s) => t.#F(r, n, i, s),
        moveToTail: (r) => t.#T(r),
        indexes: (r) => t.#x(r),
        rindexes: (r) => t.#w(r),
        isStale: (r) => t.#v(r),
      }
    }
    get max() {
      return this.#e
    }
    get maxSize() {
      return this.#t
    }
    get calculatedSize() {
      return this.#u
    }
    get size() {
      return this.#o
    }
    get fetchMethod() {
      return this.#r
    }
    get memoMethod() {
      return this.#l
    }
    get dispose() {
      return this.#i
    }
    get disposeAfter() {
      return this.#n
    }
    constructor(t) {
      let {
        max: r = 0,
        ttl: n,
        ttlResolution: i = 1,
        ttlAutopurge: s,
        updateAgeOnGet: o,
        updateAgeOnHas: a,
        allowStale: l,
        dispose: c,
        disposeAfter: u,
        noDisposeOnSet: f,
        noUpdateTTL: p,
        maxSize: g = 0,
        maxEntrySize: m = 0,
        sizeCalculation: y,
        fetchMethod: v,
        memoMethod: C,
        noDeleteOnFetchRejection: E,
        noDeleteOnStaleGet: w,
        allowStaleOnFetchRejection: B,
        allowStaleOnFetchAbort: T,
        ignoreFetchAbort: N,
      } = t
      if (r !== 0 && !Wf(r))
        throw new TypeError("max option must be a nonnegative integer")
      let W = r ? NY(r) : Array
      if (!W) throw new Error("invalid max value: " + r)
      if (
        ((this.#e = r),
        (this.#t = g),
        (this.maxEntrySize = m || this.#t),
        (this.sizeCalculation = y),
        this.sizeCalculation)
      ) {
        if (!this.#t && !this.maxEntrySize)
          throw new TypeError(
            "cannot set sizeCalculation without setting maxSize or maxEntrySize",
          )
        if (typeof this.sizeCalculation != "function")
          throw new TypeError("sizeCalculation set to non-function")
      }
      if (C !== undefined && typeof C != "function")
        throw new TypeError("memoMethod must be a function if defined")
      if (((this.#l = C), v !== undefined && typeof v != "function"))
        throw new TypeError("fetchMethod must be a function if specified")
      if (
        ((this.#r = v),
        (this.#B = !!v),
        (this.#d = new Map()),
        (this.#a = new Array(r).fill(undefined)),
        (this.#s = new Array(r).fill(undefined)),
        (this.#p = new W(r)),
        (this.#A = new W(r)),
        (this.#g = 0),
        (this.#f = 0),
        (this.#C = hL.create(r)),
        (this.#o = 0),
        (this.#u = 0),
        typeof c == "function" && (this.#i = c),
        typeof u == "function"
          ? ((this.#n = u), (this.#h = []))
          : ((this.#n = undefined), (this.#h = undefined)),
        (this.#_ = !!this.#i),
        (this.#m = !!this.#n),
        (this.noDisposeOnSet = !!f),
        (this.noUpdateTTL = !!p),
        (this.noDeleteOnFetchRejection = !!E),
        (this.allowStaleOnFetchRejection = !!B),
        (this.allowStaleOnFetchAbort = !!T),
        (this.ignoreFetchAbort = !!N),
        this.maxEntrySize !== 0)
      ) {
        if (this.#t !== 0 && !Wf(this.#t))
          throw new TypeError("maxSize must be a positive integer if specified")
        if (!Wf(this.maxEntrySize))
          throw new TypeError(
            "maxEntrySize must be a positive integer if specified",
          )
        this.#q()
      }
      if (
        ((this.allowStale = !!l),
        (this.noDeleteOnStaleGet = !!w),
        (this.updateAgeOnGet = !!o),
        (this.updateAgeOnHas = !!a),
        (this.ttlResolution = Wf(i) || i === 0 ? i : 1),
        (this.ttlAutopurge = !!s),
        (this.ttl = n || 0),
        this.ttl)
      ) {
        if (!Wf(this.ttl))
          throw new TypeError("ttl must be a positive integer if specified")
        this.#Q()
      }
      if (this.#e === 0 && this.ttl === 0 && this.#t === 0)
        throw new TypeError("At least one of max, maxSize, or ttl is required")
      if (!this.ttlAutopurge && !this.#e && !this.#t) {
        let Z = "LRU_CACHE_UNBOUNDED"
        kFe(Z) &&
          (FY.add(Z),
          QY(
            "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.",
            "UnboundedCacheWarning",
            Z,
            e,
          ))
      }
    }
    getRemainingTTL(t) {
      return this.#d.has(t) ? 1 / 0 : 0
    }
    #Q() {
      let t = new IA(this.#e),
        r = new IA(this.#e)
      ;(this.#y = t),
        (this.#E = r),
        (this.#N = (s, o, a = SA.now()) => {
          if (
            ((r[s] = o !== 0 ? a : 0), (t[s] = o), o !== 0 && this.ttlAutopurge)
          ) {
            let l = setTimeout(() => {
              this.#v(s) && this.#S(this.#a[s], "expire")
            }, o + 1)
            l.unref && l.unref()
          }
        }),
        (this.#R = (s) => {
          r[s] = t[s] !== 0 ? SA.now() : 0
        }),
        (this.#I = (s, o) => {
          if (t[o]) {
            let a = t[o],
              l = r[o]
            if (!a || !l) return
            ;(s.ttl = a), (s.start = l), (s.now = n || i())
            let c = s.now - l
            s.remainingTTL = a - c
          }
        })
      let n = 0,
        i = () => {
          let s = SA.now()
          if (this.ttlResolution > 0) {
            n = s
            let o = setTimeout(() => (n = 0), this.ttlResolution)
            o.unref && o.unref()
          }
          return s
        }
      ;(this.getRemainingTTL = (s) => {
        let o = this.#d.get(s)
        if (o === undefined) return 0
        let a = t[o],
          l = r[o]
        if (!a || !l) return 1 / 0
        let c = (n || i()) - l
        return a - c
      }),
        (this.#v = (s) => {
          let o = r[s],
            a = t[s]
          return !!a && !!o && (n || i()) - o > a
        })
    }
    #R = () => {}
    #I = () => {}
    #N = () => {}
    #v = () => false
    #q() {
      let t = new IA(this.#e)
      ;(this.#u = 0),
        (this.#b = t),
        (this.#D = (r) => {
          ;(this.#u -= t[r]), (t[r] = 0)
        }),
        (this.#P = (r, n, i, s) => {
          if (this.#c(n)) return 0
          if (!Wf(i))
            if (s) {
              if (typeof s != "function")
                throw new TypeError("sizeCalculation must be a function")
              if (((i = s(n, r)), !Wf(i)))
                throw new TypeError(
                  "sizeCalculation return invalid (expect positive integer)",
                )
            } else
              throw new TypeError(
                "invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.",
              )
          return i
        }),
        (this.#k = (r, n, i) => {
          if (((t[r] = n), this.#t)) {
            let s = this.#t - t[r]
            for (; this.#u > s; ) this.#M(true)
          }
          ;(this.#u += t[r]),
            i && ((i.entrySize = n), (i.totalCalculatedSize = this.#u))
        })
    }
    #D = (t) => {}
    #k = (t, r, n) => {}
    #P = (t, r, n, i) => {
      if (n || i)
        throw new TypeError(
          "cannot set size without setting maxSize or maxEntrySize on cache",
        )
      return 0
    };
    *#x({ allowStale: t = this.allowStale } = {}) {
      if (this.#o)
        for (
          let r = this.#f;
          !(!this.#L(r) || ((t || !this.#v(r)) && (yield r), r === this.#g));

        )
          r = this.#A[r]
    }
    *#w({ allowStale: t = this.allowStale } = {}) {
      if (this.#o)
        for (
          let r = this.#g;
          !(!this.#L(r) || ((t || !this.#v(r)) && (yield r), r === this.#f));

        )
          r = this.#p[r]
    }
    #L(t) {
      return t !== undefined && this.#d.get(this.#a[t]) === t
    }
    *entries() {
      for (let t of this.#x())
        this.#s[t] !== undefined &&
          this.#a[t] !== undefined &&
          !this.#c(this.#s[t]) &&
          (yield [this.#a[t], this.#s[t]])
    }
    *rentries() {
      for (let t of this.#w())
        this.#s[t] !== undefined &&
          this.#a[t] !== undefined &&
          !this.#c(this.#s[t]) &&
          (yield [this.#a[t], this.#s[t]])
    }
    *keys() {
      for (let t of this.#x()) {
        let r = this.#a[t]
        r !== undefined && !this.#c(this.#s[t]) && (yield r)
      }
    }
    *rkeys() {
      for (let t of this.#w()) {
        let r = this.#a[t]
        r !== undefined && !this.#c(this.#s[t]) && (yield r)
      }
    }
    *values() {
      for (let t of this.#x())
        this.#s[t] !== undefined && !this.#c(this.#s[t]) && (yield this.#s[t])
    }
    *rvalues() {
      for (let t of this.#w())
        this.#s[t] !== undefined && !this.#c(this.#s[t]) && (yield this.#s[t])
    }
    [Symbol.iterator]() {
      return this.entries()
    }
    [Symbol.toStringTag] = "LRUCache"
    find(t, r = {}) {
      for (let n of this.#x()) {
        let i = this.#s[n],
          s = this.#c(i) ? i.__staleWhileFetching : i
        if (s !== undefined && t(s, this.#a[n], this))
          return this.get(this.#a[n], r)
      }
    }
    forEach(t, r = this) {
      for (let n of this.#x()) {
        let i = this.#s[n],
          s = this.#c(i) ? i.__staleWhileFetching : i
        s !== undefined && t.call(r, s, this.#a[n], this)
      }
    }
    rforEach(t, r = this) {
      for (let n of this.#w()) {
        let i = this.#s[n],
          s = this.#c(i) ? i.__staleWhileFetching : i
        s !== undefined && t.call(r, s, this.#a[n], this)
      }
    }
    purgeStale() {
      let t = false
      for (let r of this.#w({ allowStale: true }))
        this.#v(r) && (this.#S(this.#a[r], "expire"), (t = true))
      return t
    }
    info(t) {
      let r = this.#d.get(t)
      if (r === undefined) return
      let n = this.#s[r],
        i = this.#c(n) ? n.__staleWhileFetching : n
      if (i === undefined) return
      let s = { value: i }
      if (this.#y && this.#E) {
        let o = this.#y[r],
          a = this.#E[r]
        if (o && a) {
          let l = o - (SA.now() - a)
          ;(s.ttl = l), (s.start = Date.now())
        }
      }
      return this.#b && (s.size = this.#b[r]), s
    }
    dump() {
      let t = []
      for (let r of this.#x({ allowStale: true })) {
        let n = this.#a[r],
          i = this.#s[r],
          s = this.#c(i) ? i.__staleWhileFetching : i
        if (s === undefined || n === undefined) continue
        let o = { value: s }
        if (this.#y && this.#E) {
          o.ttl = this.#y[r]
          let a = SA.now() - this.#E[r]
          o.start = Math.floor(Date.now() - a)
        }
        this.#b && (o.size = this.#b[r]), t.unshift([n, o])
      }
      return t
    }
    load(t) {
      this.clear()
      for (let [r, n] of t) {
        if (n.start) {
          let i = Date.now() - n.start
          n.start = SA.now() - i
        }
        this.set(r, n.value, n)
      }
    }
    set(t, r, n = {}) {
      if (r === undefined) return this.delete(t), this
      let {
          ttl: i = this.ttl,
          start: s,
          noDisposeOnSet: o = this.noDisposeOnSet,
          sizeCalculation: a = this.sizeCalculation,
          status: l,
        } = n,
        { noUpdateTTL: c = this.noUpdateTTL } = n,
        u = this.#P(t, r, n.size || 0, a)
      if (this.maxEntrySize && u > this.maxEntrySize)
        return (
          l && ((l.set = "miss"), (l.maxEntrySizeExceeded = true)),
          this.#S(t, "set"),
          this
        )
      let f = this.#o === 0 ? undefined : this.#d.get(t)
      if (f === undefined)
        (f =
          this.#o === 0
            ? this.#f
            : this.#C.length !== 0
              ? this.#C.pop()
              : this.#o === this.#e
                ? this.#M(false)
                : this.#o),
          (this.#a[f] = t),
          (this.#s[f] = r),
          this.#d.set(t, f),
          (this.#p[this.#f] = f),
          (this.#A[f] = this.#f),
          (this.#f = f),
          this.#o++,
          this.#k(f, u, l),
          l && (l.set = "add"),
          (c = false)
      else {
        this.#T(f)
        let p = this.#s[f]
        if (r !== p) {
          if (this.#B && this.#c(p)) {
            p.__abortController.abort(new Error("replaced"))
            let { __staleWhileFetching: g } = p
            g !== undefined &&
              !o &&
              (this.#_ && this.#i?.(g, t, "set"),
              this.#m && this.#h?.push([g, t, "set"]))
          } else
            o ||
              (this.#_ && this.#i?.(p, t, "set"),
              this.#m && this.#h?.push([p, t, "set"]))
          if ((this.#D(f), this.#k(f, u, l), (this.#s[f] = r), l)) {
            l.set = "replace"
            let g = p && this.#c(p) ? p.__staleWhileFetching : p
            g !== undefined && (l.oldValue = g)
          }
        } else l && (l.set = "update")
      }
      if (
        (i !== 0 && !this.#y && this.#Q(),
        this.#y && (c || this.#N(f, i, s), l && this.#I(l, f)),
        !o && this.#m && this.#h)
      ) {
        let p = this.#h,
          g
        for (; (g = p?.shift()); ) this.#n?.(...g)
      }
      return this
    }
    pop() {
      try {
        for (; this.#o; ) {
          let t = this.#s[this.#g]
          if ((this.#M(true), this.#c(t))) {
            if (t.__staleWhileFetching) return t.__staleWhileFetching
          } else if (t !== undefined) return t
        }
      } finally {
        if (this.#m && this.#h) {
          let t = this.#h,
            r
          for (; (r = t?.shift()); ) this.#n?.(...r)
        }
      }
    }
    #M(t) {
      let r = this.#g,
        n = this.#a[r],
        i = this.#s[r]
      return (
        this.#B && this.#c(i)
          ? i.__abortController.abort(new Error("evicted"))
          : (this.#_ || this.#m) &&
            (this.#_ && this.#i?.(i, n, "evict"),
            this.#m && this.#h?.push([i, n, "evict"])),
        this.#D(r),
        t && ((this.#a[r] = undefined), (this.#s[r] = undefined), this.#C.push(r)),
        this.#o === 1
          ? ((this.#g = this.#f = 0), (this.#C.length = 0))
          : (this.#g = this.#p[r]),
        this.#d.delete(n),
        this.#o--,
        r
      )
    }
    has(t, r = {}) {
      let { updateAgeOnHas: n = this.updateAgeOnHas, status: i } = r,
        s = this.#d.get(t)
      if (s !== undefined) {
        let o = this.#s[s]
        if (this.#c(o) && o.__staleWhileFetching === undefined) return false
        if (this.#v(s)) i && ((i.has = "stale"), this.#I(i, s))
        else return n && this.#R(s), i && ((i.has = "hit"), this.#I(i, s)), true
      } else i && (i.has = "miss")
      return false
    }
    peek(t, r = {}) {
      let { allowStale: n = this.allowStale } = r,
        i = this.#d.get(t)
      if (i === undefined || (!n && this.#v(i))) return
      let s = this.#s[i]
      return this.#c(s) ? s.__staleWhileFetching : s
    }
    #F(t, r, n, i) {
      let s = r === undefined ? undefined : this.#s[r]
      if (this.#c(s)) return s
      let o = new JS(),
        { signal: a } = n
      a?.addEventListener("abort", () => o.abort(a.reason), {
        signal: o.signal,
      })
      let l = { signal: o.signal, options: n, context: i },
        c = (y, v = false) => {
          let { aborted: C } = o.signal,
            E = n.ignoreFetchAbort && y !== undefined
          if (
            (n.status &&
              (C && !v
                ? ((n.status.fetchAborted = true),
                  (n.status.fetchError = o.signal.reason),
                  E && (n.status.fetchAbortIgnored = true))
                : (n.status.fetchResolved = true)),
            C && !E && !v)
          )
            return f(o.signal.reason)
          let w = g
          return (
            this.#s[r] === g &&
              (y === undefined
                ? w.__staleWhileFetching
                  ? (this.#s[r] = w.__staleWhileFetching)
                  : this.#S(t, "fetch")
                : (n.status && (n.status.fetchUpdated = true),
                  this.set(t, y, l.options))),
            y
          )
        },
        u = (y) => (
          n.status &&
            ((n.status.fetchRejected = true), (n.status.fetchError = y)),
          f(y)
        ),
        f = (y) => {
          let { aborted: v } = o.signal,
            C = v && n.allowStaleOnFetchAbort,
            E = C || n.allowStaleOnFetchRejection,
            w = E || n.noDeleteOnFetchRejection,
            B = g
          if (
            (this.#s[r] === g &&
              (!w || B.__staleWhileFetching === undefined
                ? this.#S(t, "fetch")
                : C || (this.#s[r] = B.__staleWhileFetching)),
            E)
          )
            return (
              n.status &&
                B.__staleWhileFetching !== undefined &&
                (n.status.returnedStale = true),
              B.__staleWhileFetching
            )
          if (B.__returned === B) throw y
        },
        p = (y, v) => {
          let C = this.#r?.(t, s, l)
          C &&
            C instanceof Promise &&
            C.then((E) => y(E === undefined ? undefined : E), v),
            o.signal.addEventListener("abort", () => {
              ;(!n.ignoreFetchAbort || n.allowStaleOnFetchAbort) &&
                (y(undefined), n.allowStaleOnFetchAbort && (y = (E) => c(E, true)))
            })
        }
      n.status && (n.status.fetchDispatched = true)
      let g = new Promise(p).then(c, u),
        m = Object.assign(g, {
          __abortController: o,
          __staleWhileFetching: s,
          __returned: undefined,
        })
      return (
        r === undefined
          ? (this.set(t, m, { ...l.options, status: undefined }),
            (r = this.#d.get(t)))
          : (this.#s[r] = m),
        m
      )
    }
    #c(t) {
      if (!this.#B) return false
      let r = t
      return (
        !!r &&
        r instanceof Promise &&
        r.hasOwnProperty("__staleWhileFetching") &&
        r.__abortController instanceof JS
      )
    }
    async fetch(t, r = {}) {
      let {
        allowStale: n = this.allowStale,
        updateAgeOnGet: i = this.updateAgeOnGet,
        noDeleteOnStaleGet: s = this.noDeleteOnStaleGet,
        ttl: o = this.ttl,
        noDisposeOnSet: a = this.noDisposeOnSet,
        size: l = 0,
        sizeCalculation: c = this.sizeCalculation,
        noUpdateTTL: u = this.noUpdateTTL,
        noDeleteOnFetchRejection: f = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection: p = this.allowStaleOnFetchRejection,
        ignoreFetchAbort: g = this.ignoreFetchAbort,
        allowStaleOnFetchAbort: m = this.allowStaleOnFetchAbort,
        context: y,
        forceRefresh: v = false,
        status: C,
        signal: E,
      } = r
      if (!this.#B)
        return (
          C && (C.fetch = "get"),
          this.get(t, {
            allowStale: n,
            updateAgeOnGet: i,
            noDeleteOnStaleGet: s,
            status: C,
          })
        )
      let w = {
          allowStale: n,
          updateAgeOnGet: i,
          noDeleteOnStaleGet: s,
          ttl: o,
          noDisposeOnSet: a,
          size: l,
          sizeCalculation: c,
          noUpdateTTL: u,
          noDeleteOnFetchRejection: f,
          allowStaleOnFetchRejection: p,
          allowStaleOnFetchAbort: m,
          ignoreFetchAbort: g,
          status: C,
          signal: E,
        },
        B = this.#d.get(t)
      if (B === undefined) {
        C && (C.fetch = "miss")
        let T = this.#F(t, B, w, y)
        return (T.__returned = T)
      } else {
        let T = this.#s[B]
        if (this.#c(T)) {
          let Y = n && T.__staleWhileFetching !== undefined
          return (
            C && ((C.fetch = "inflight"), Y && (C.returnedStale = true)),
            Y ? T.__staleWhileFetching : (T.__returned = T)
          )
        }
        let N = this.#v(B)
        if (!v && !N)
          return (
            C && (C.fetch = "hit"),
            this.#T(B),
            i && this.#R(B),
            C && this.#I(C, B),
            T
          )
        let W = this.#F(t, B, w, y),
          te = W.__staleWhileFetching !== undefined && n
        return (
          C &&
            ((C.fetch = N ? "stale" : "refresh"),
            te && N && (C.returnedStale = true)),
          te ? W.__staleWhileFetching : (W.__returned = W)
        )
      }
    }
    async forceFetch(t, r = {}) {
      let n = await this.fetch(t, r)
      if (n === undefined) throw new Error("fetch() returned undefined")
      return n
    }
    memo(t, r = {}) {
      let n = this.#l
      if (!n) throw new Error("no memoMethod provided to constructor")
      let { context: i, forceRefresh: s, ...o } = r,
        a = this.get(t, o)
      if (!s && a !== undefined) return a
      let l = n(t, a, { options: o, context: i })
      return this.set(t, l, o), l
    }
    get(t, r = {}) {
      let {
          allowStale: n = this.allowStale,
          updateAgeOnGet: i = this.updateAgeOnGet,
          noDeleteOnStaleGet: s = this.noDeleteOnStaleGet,
          status: o,
        } = r,
        a = this.#d.get(t)
      if (a !== undefined) {
        let l = this.#s[a],
          c = this.#c(l)
        return (
          o && this.#I(o, a),
          this.#v(a)
            ? (o && (o.get = "stale"),
              c
                ? (o &&
                    n &&
                    l.__staleWhileFetching !== undefined &&
                    (o.returnedStale = true),
                  n ? l.__staleWhileFetching : undefined)
                : (s || this.#S(t, "expire"),
                  o && n && (o.returnedStale = true),
                  n ? l : undefined))
            : (o && (o.get = "hit"),
              c ? l.__staleWhileFetching : (this.#T(a), i && this.#R(a), l))
        )
      } else o && (o.get = "miss")
    }
    #U(t, r) {
      ;(this.#A[r] = t), (this.#p[t] = r)
    }
    #T(t) {
      t !== this.#f &&
        (t === this.#g
          ? (this.#g = this.#p[t])
          : this.#U(this.#A[t], this.#p[t]),
        this.#U(this.#f, t),
        (this.#f = t))
    }
    delete(t) {
      return this.#S(t, "delete")
    }
    #S(t, r) {
      let n = false
      if (this.#o !== 0) {
        let i = this.#d.get(t)
        if (i !== undefined)
          if (((n = true), this.#o === 1)) this.#O(r)
          else {
            this.#D(i)
            let s = this.#s[i]
            if (
              (this.#c(s)
                ? s.__abortController.abort(new Error("deleted"))
                : (this.#_ || this.#m) &&
                  (this.#_ && this.#i?.(s, t, r),
                  this.#m && this.#h?.push([s, t, r])),
              this.#d.delete(t),
              (this.#a[i] = undefined),
              (this.#s[i] = undefined),
              i === this.#f)
            )
              this.#f = this.#A[i]
            else if (i === this.#g) this.#g = this.#p[i]
            else {
              let o = this.#A[i]
              this.#p[o] = this.#p[i]
              let a = this.#p[i]
              this.#A[a] = this.#A[i]
            }
            this.#o--, this.#C.push(i)
          }
      }
      if (this.#m && this.#h?.length) {
        let i = this.#h,
          s
        for (; (s = i?.shift()); ) this.#n?.(...s)
      }
      return n
    }
    clear() {
      return this.#O("delete")
    }
    #O(t) {
      for (let r of this.#w({ allowStale: true })) {
        let n = this.#s[r]
        if (this.#c(n)) n.__abortController.abort(new Error("deleted"))
        else {
          let i = this.#a[r]
          this.#_ && this.#i?.(n, i, t), this.#m && this.#h?.push([n, i, t])
        }
      }
      if (
        (this.#d.clear(),
        this.#s.fill(undefined),
        this.#a.fill(undefined),
        this.#y && this.#E && (this.#y.fill(0), this.#E.fill(0)),
        this.#b && this.#b.fill(0),
        (this.#g = 0),
        (this.#f = 0),
        (this.#C.length = 0),
        (this.#u = 0),
        (this.#o = 0),
        this.#m && this.#h)
      ) {
        let r = this.#h,
          n
        for (; (n = r?.shift()); ) this.#n?.(...n)
      }
    }
  }
var rb = new Gf({ ttl: 1e3 * 60 * 5, max: 1e3, updateAgeOnGet: true })
function PY(e) {
  let { conversationId: t, sourceToolCallRequestId: r, timestamp: n } = e,
    { path: i } = e.documentMetadata,
    o = (i.rootPath ? `${i.rootPath}/${i.relPath}` : i.relPath).replace(
      /[/\\:*?"<>|]/g,
      "_",
    )
  return `checkpoint-documents/${t}/document-${o}-${n}-${r}.json`
}
function MFe(e) {
  return { path: { rootPath: e.rootPath, relPath: e.relPath } }
}
async function LY(e, t) {
  let r = getLogger("CheckpointHydration")
  try {
    if (xA(e)) return FFe(e, t, r)
    if (wA(e)) return await QFe(e, r)
  } catch (n) {
    r.warn(`Failed to hydrate checkpoint: ${String(n)}`)
  }
  return PFe(e)
}
function FFe(e, t, r) {
  let n = e.document,
    i = QualifiedPathName.from(n.path),
    s = new DiffViewDocument(i, n.originalCode, n.modifiedCode, {})
  return (
    s.filePath.absPath !== i.absPath &&
      r.warn(
        `Document path mismatch: document has ${s.filePath.absPath}, but path parameter is ${i.absPath}`,
      ),
    {
      sourceToolCallRequestId: e.sourceToolCallRequestId,
      timestamp: e.timestamp,
      conversationId: e.conversationId,
      document: s,
    }
  )
}
async function QFe(e, t) {
  let r = `${e.conversationId}-${e.sourceToolCallRequestId}-${e.timestamp}`
  if (rb.has(r))
    return (
      t.debug(`Cache hit for checkpoint: ${r}`),
      {
        sourceToolCallRequestId: e.sourceToolCallRequestId,
        timestamp: e.timestamp,
        conversationId: e.conversationId,
        document: rb.get(r),
      }
    )
  t.debug(`Loading document for checkpoint: ${e.sourceToolCallRequestId}`)
  let n = PY(e),
    i = await Og().loadAsset(n)
  if (!i || i.length === 0)
    throw new Error(`Checkpoint document not found at: ${n}`)
  let s = NFe(i),
    o = (() => {
      let a = QualifiedPathName.from(s.path),
        l = new DiffViewDocument(a, s.originalCode, s.modifiedCode, {})
      return rb.set(r, l), l
    })()
  return (
    rb.set(r, o),
    {
      sourceToolCallRequestId: e.sourceToolCallRequestId,
      timestamp: e.timestamp,
      conversationId: e.conversationId,
      document: o,
    }
  )
}
function NFe(e) {
  try {
    let t = JSON.parse(Buffer.from(e).toString("utf8"))
    if (!t || typeof t != "object") throw new Error("Invalid document format")
    return t
  } catch (t) {
    throw new Error(
      `Failed to parse checkpoint document: ${t instanceof Error ? t.message : String(t)}`,
    )
  }
}
function PFe(e) {
  return {
    sourceToolCallRequestId: e.sourceToolCallRequestId,
    timestamp: e.timestamp,
    conversationId: e.conversationId,
    document: DiffViewDocument.empty(),
  }
}
async function UY(e, t = false) {
  let r = getLogger("CheckpointHydration"),
    n = MFe(e.document.filePath)
  return (
    t && (await LFe(e, n, r)),
    {
      sourceToolCallRequestId: e.sourceToolCallRequestId,
      timestamp: e.timestamp,
      conversationId: e.conversationId,
      documentMetadata: n,
    }
  )
}
async function LFe(e, t, r) {
  r.debug(`Storing document for checkpoint: ${e.sourceToolCallRequestId}`)
  try {
    let n = UFe(e.document),
      i = {
        sourceToolCallRequestId: e.sourceToolCallRequestId,
        timestamp: e.timestamp,
        conversationId: e.conversationId,
        documentMetadata: t,
      },
      s = PY(i)
    await Og().saveAsset(s, Buffer.from(JSON.stringify(n), "utf8"))
    let o = `${e.conversationId}-${e.sourceToolCallRequestId}-${e.timestamp}`
    rb.set(o, e.document)
  } catch (n) {
    r.error(`Failed to store checkpoint document: ${String(n)}`)
  }
}
function UFe(e) {
  return {
    path: { rootPath: e.filePath.rootPath, relPath: e.filePath.relPath },
    originalCode: e.originalCode,
    modifiedCode: e.modifiedCode,
  }
}
var nb = class e {
  _id
  _checkpointDocumentIdFn
  _checkpoints = new Map()
  _lastModified = Date.now()
  _isDirty = false
  _dirtyCheckpoints = new Set()
  constructor(t, r) {
    ;(this._id = t), (this._checkpointDocumentIdFn = r)
  }
  static async fromSerialized(t, r, n) {
    if (r.id !== t)
      throw new Error(`Shard ID mismatch: expected ${t}, got ${r.id}`)
    try {
      let i = new e(t, n)
      for (let s of Object.entries(r.checkpoints))
        for (let o of s[1]) {
          let a
          if (xA(o)) a = QualifiedPathName.from(o.document.path)
          else if (wA(o)) a = QualifiedPathName.from(o.documentMetadata.path)
          else {
            getLogger("ShardData").warn(
              `Unknown checkpoint format: ${JSON.stringify(o)}`,
            )
            continue
          }
          let l = { conversationId: o.conversationId, path: a },
            c = await LY(o, a)
          i.addCheckpoint(l, c)
        }
      return i
    } catch (i) {
      let s = `Failed to deserialize shard: ${i instanceof Error ? i.message : String(i)}`
      throw new Error(s)
    }
  }
  get id() {
    return this._id
  }
  get size() {
    return Array.from(this._checkpoints.values()).reduce(
      (t, r) =>
        t +
        r.reduce(
          (n, i) =>
            n +
            (i.document.originalCode ? i.document.originalCode.length : 0) +
            (i.document.modifiedCode ? i.document.modifiedCode.length : 0),
          0,
        ),
      0,
    )
  }
  get checkpointCount() {
    return Array.from(this._checkpoints.values()).reduce(
      (t, r) => t + r.length,
      0,
    )
  }
  get lastModified() {
    return this._lastModified
  }
  get checkpointDocumentIds() {
    return Array.from(this._checkpoints.keys())
  }
  getCheckpointsById(t) {
    return this._checkpoints.get(t)
  }
  async serialize() {
    try {
      let t = { id: this.id, checkpoints: {}, metadata: this.getMetadata() }
      for (let r of this.checkpointDocumentIds) {
        let n = this.getCheckpointsById(r)
        n &&
          (t.checkpoints[r] = await Promise.all(
            n.map(async (i) => {
              let s = this.isCheckpointDirty(i),
                o = await UY(i, s)
              return this.markCheckpointClean(i), o
            }),
          ))
      }
      return t
    } catch (t) {
      let r = `Failed to serialize shard: ${t instanceof Error ? t.message : String(t)}`
      throw new Error(r)
    }
  }
  getMetadata() {
    return {
      checkpointDocumentIds: this.checkpointDocumentIds,
      size: this.size,
      checkpointCount: this.checkpointCount,
      lastModified: this._lastModified,
    }
  }
  get isDirty() {
    return this._isDirty
  }
  clearDirty() {
    ;(this._isDirty = false), this._dirtyCheckpoints.clear()
  }
  isCheckpointDirty(t) {
    return this._dirtyCheckpoints.has(t.sourceToolCallRequestId)
  }
  markCheckpointDirty(t) {
    this._dirtyCheckpoints.add(t.sourceToolCallRequestId), (this._isDirty = true)
  }
  markCheckpointClean(t) {
    this._dirtyCheckpoints.delete(t.sourceToolCallRequestId)
  }
  hasKey(t) {
    return this._checkpoints.has(this._checkpointDocumentIdFn(t))
  }
  getAllCheckpoints() {
    return Array.from(this._checkpoints.values()).flat()
  }
  getAllCheckpointsSorted() {
    return this.getAllCheckpoints().sort((t, r) => t.timestamp - r.timestamp)
  }
  get orderedCheckpointsByTime() {
    return this.getAllCheckpointsSorted()
  }
  get totalCheckpointCount() {
    return this.checkpointCount
  }
  getCheckpointNumberForToolCall(t) {
    let r = this.orderedCheckpointsByTime.findIndex(
      (n) => n.sourceToolCallRequestId === t,
    )
    return r === -1 ? undefined : r
  }
  getCheckpointBySourceId(t) {
    return this.getAllCheckpoints().find((r) => r.sourceToolCallRequestId === t)
  }
  getCheckpoints(t, r) {
    let n = this._checkpoints.get(this._checkpointDocumentIdFn(t))
    if (!n?.length) return
    if (!r) return n
    let i = dL(n, r)
    return i.length > 0 ? i : []
  }
  getLatestCheckpoint(t) {
    let r = this._checkpoints.get(this._checkpointDocumentIdFn(t))
    return r?.[r.length - 1]
  }
  addCheckpoint(t, r) {
    let n = this._checkpointDocumentIdFn(t),
      s = [...(this._checkpoints.get(n) || []), r].sort(
        (o, a) => o.timestamp - a.timestamp,
      )
    this._checkpoints.set(n, s),
      this.markCheckpointDirty(r),
      (this._lastModified = Date.now())
  }
  updateCheckpoint(t, r) {
    let n = this._checkpointDocumentIdFn(t),
      i = this._checkpoints.get(n) || [],
      s = i.findIndex(
        (o) => o.sourceToolCallRequestId === r.sourceToolCallRequestId,
      )
    s !== -1 &&
      ((i[s] = r),
      this._checkpoints.set(n, i),
      this.markCheckpointDirty(r),
      (this._lastModified = Date.now()))
  }
  getAllTrackedConversationIds() {
    let t = new Set()
    for (let r of this.getAllCheckpoints()) t.add(r.conversationId)
    return Array.from(t)
  }
  getAllTrackedFilePaths(t) {
    let r = new Map()
    for (let n of this.getAllCheckpoints())
      n.conversationId === t &&
        r.set(n.document.filePath.absPath, n.document.filePath)
    return Array.from(r.values())
  }
  removeCheckpoint(t, r) {
    let n = this._checkpointDocumentIdFn(t),
      i = this._checkpoints.get(n)
    if (!i?.length) return false
    if (!r)
      return (
        this._checkpoints.delete(n),
        (this._lastModified = Date.now()),
        (this._isDirty = true),
        true
      )
    let s = dL(i, r, false)
    return s.length === i.length
      ? false
      : (s.length === 0
          ? this._checkpoints.delete(n)
          : this._checkpoints.set(n, s),
        (this._lastModified = Date.now()),
        (this._isDirty = true),
        true)
  }
  clear() {
    this._checkpoints.clear(),
      (this._lastModified = Date.now()),
      (this._isDirty = true)
  }
  markAllCheckpointsDirty() {
    for (let t of this._checkpoints.values())
      for (let r of t) this.markCheckpointDirty(r)
  }
}
var ib = class {
    static _instance = undefined
    static setClientWorkspaces(t) {
      if (this._instance !== undefined) {
        getLogger("ClientWorkspaces").warn(
          "Attempting to initialize client workspaces when one is already configured. Keeping existing client workspaces.",
        )
        return
      }
      this._instance = t
    }
    static getClientWorkspaces() {
      if (this._instance === undefined) throw new Error("ClientWorkspaces not set")
      return this._instance
    }
    static reset() {
      this._instance = undefined
    }
  },
  OY = (e) => ib.setClientWorkspaces(e),
  Vi = () => ib.getClientWorkspaces(),
  qY = () => ib.reset()
var AK = q(Yf())
var jS = class e extends DisposableContainer_2 {
  _storage
  _shardFunction
  _options
  static DEFAULT_FLUSH_INTERVAL_MS = 5e3
  _shardCache = new Map()
  _manifest = { version: 1, lastUpdated: Date.now(), shards: {} }
  _accessOrder = []
  _flushThrottled
  _isDisposing = false
  _initializePromise
  _logger
  _checkpointDocumentIdFn
  constructor(t, r, n = {}) {
    super(),
      (this._storage = t),
      (this._shardFunction = r),
      (this._options = n),
      (this._checkpointDocumentIdFn = (i) =>
        `${i.conversationId}:${i.path.absPath}`),
      (this._logger = this._options.logger ?? getLogger("ShardManager")),
      (this._flushThrottled = (0, AK.default)(
        () => this._flush(),
        this._options.flushIntervalMs ?? e.DEFAULT_FLUSH_INTERVAL_MS,
        { leading: false, trailing: true },
      ))
  }
  get manifest() {
    return this._manifest
  }
  initialize = async () =>
    this._initializePromise
      ? this._initializePromise
      : ((this._initializePromise = (async () => {
          try {
            let t = await this._storage.loadManifest()
            t
              ? uL(t).isValid
                ? (this._manifest = t)
                : ((this._manifest = kY(t)),
                  await this._storage.saveManifest(this._manifest))
              : ((this._manifest = {
                  version: 1,
                  lastUpdated: Date.now(),
                  shards: {},
                }),
                await this._storage.saveManifest(this._manifest))
          } catch (t) {
            throw ((this._initializePromise = undefined), t)
          }
        })()),
        this._initializePromise)
  _getShardId(t) {
    let r = this._checkpointDocumentIdFn(t)
    for (let [n, i] of Object.entries(this._manifest.shards))
      if (i.checkpointDocumentIds.includes(r)) return n
    return this._shardFunction(t, {
      manifestSnapshot: this._manifest,
      pathStats: { checkpointCount: 0, estimatedSize: 0 },
    })
  }
  _updateAccessTime(t) {
    let r = this._accessOrder.indexOf(t)
    r > -1 && this._accessOrder.splice(r, 1), this._accessOrder.push(t)
  }
  async _updateCheckpointsFromDisk(t) {
    let r = []
    for (let s of t.getAllTrackedConversationIds())
      for (let o of t.getAllTrackedFilePaths(s)) {
        let a = t.getLatestCheckpoint({ conversationId: s, path: o })
        a && r.push({ conversationId: s, path: o, latestCheckpoint: a })
      }
    if (r.length === 0) return t
    let n = await Promise.all(
        r.map(async (s) => {
          try {
            let o = (await Vi().readFile(s.path.absPath)).contents
            return { ...s, onDiskContents: o, error: null }
          } catch (o) {
            return (
              this._logger.error(`Failed to read file ${s.path.absPath}:`, o),
              { ...s, onDiskContents: null, error: o }
            )
          }
        }),
      ),
      i = []
    for (let s of n) {
      if (
        s.error ||
        !s.onDiskContents ||
        s.onDiskContents === s.latestCheckpoint.document.modifiedCode
      )
        continue
      let o = new DiffViewDocument(
        s.path,
        s.latestCheckpoint.document.modifiedCode,
        s.onDiskContents,
        {},
      )
      i.push({
        keyData: { conversationId: s.conversationId, path: s.path },
        checkpoint: {
          sourceToolCallRequestId: crypto.randomUUID(),
          timestamp: Date.now(),
          document: o,
          conversationId: s.conversationId,
        },
      })
    }
    for (let { keyData: s, checkpoint: o } of i) t.addCheckpoint(s, o)
    return t
  }
  async _loadShard(t) {
    let r = this._shardCache.get(t)
    if (r) return this._updateAccessTime(t), r
    let n = await this._storage.loadShard(t)
    return (
      this._logger.debug(`Loading shard ${t} from storage`),
      (r = n
        ? await nb.fromSerialized(t, n, this._checkpointDocumentIdFn)
        : new nb(t, this._checkpointDocumentIdFn)),
      (r = await this._updateCheckpointsFromDisk(r)),
      this._shardCache.set(t, r),
      this._updateAccessTime(t),
      r
    )
  }
  _updateManifest(t, r) {
    ;(this._manifest.shards[t] = r.getMetadata()),
      (this._manifest.lastUpdated = Date.now())
  }
  _triggerFlush() {
    if (this._isDisposing) return this._flush()
    this._flushThrottled()
  }
  async _flush() {
    let t = [],
      r = [],
      n = false
    for (let [i, s] of this._shardCache.entries())
      s.checkpointCount === 0
        ? (r.push(i), (n = true))
        : s.isDirty &&
          (t.push(i), (this._manifest.shards[i] = s.getMetadata()), (n = true))
    if (n) {
      this._manifest.lastUpdated = Date.now()
      try {
        let i = new Map()
        for (let l of t) {
          let c = this._shardCache.get(l)
          c && i.set(l, await c.serialize())
        }
        await Promise.all(
          Array.from(i.entries()).map(([l, c]) =>
            this._storage.saveShard(l, c),
          ),
        ),
          await Promise.all(r.map((l) => this._storage.deleteShard(l)))
        let s = this._options.maxCachedShards ?? 10,
          o = [],
          a = []
        for (; this._shardCache.size > s && this._accessOrder.length > 0; ) {
          let l = this._accessOrder.shift()
          if (l) {
            let c = this._shardCache.get(l)
            c &&
              c.isDirty &&
              a.push(this._storage.saveShard(l, await c.serialize())),
              o.push(l)
          }
        }
        await Promise.all(a), await this._storage.saveManifest(this._manifest)
        for (let l of t) {
          let c = this._shardCache.get(l)
          c && c.clearDirty()
        }
        for (let l of r)
          this._shardCache.delete(l), delete this._manifest.shards[l]
        for (let l of o) this._shardCache.delete(l)
      } catch (i) {
        this._logger.error("Failed to flush shards:", i)
      }
    }
  }
  async flush() {
    await this._flush()
  }
  getCacheSize() {
    return this._shardCache.size
  }
  getShard = async (t) => {
    let r = this._getShardId(t)
    return await this.getShardById(r)
  }
  getShardById = async (t) => await this._loadShard(t)
  hasKey = async (t) => {
    let r = this._getShardId(t)
    return (await this._loadShard(r)).hasKey(t)
  }
  getCheckpoints = async (t, r) => {
    let n = this._getShardId(t)
    return (await this._loadShard(n)).getCheckpoints(t, r) || []
  }
  getLatestCheckpoint = async (t) => {
    let r = this._getShardId(t)
    return (await this._loadShard(r)).getLatestCheckpoint(t)
  }
  addCheckpoint = async (t, r) => {
    await this._performShardOperation(t, (n) => {
      n.addCheckpoint(t, r)
    })
  }
  updateCheckpoint = async (t, r) => {
    await this._performShardOperation(t, (n) => {
      n.updateCheckpoint(t, r)
    })
  }
  removeCheckpoint = async (t, r) => {
    let n = false
    return (
      await this._performShardOperation(t, (i) => {
        n = i.removeCheckpoint(t, r)
      }),
      n
    )
  }
  async _performShardOperation(t, r) {
    let n = this._getShardId(t)
    await this._performShardOperationById(n, r)
  }
  async _performShardOperationById(t, r) {
    let n = await this._loadShard(t)
    r(n), this._updateManifest(t, n), await this._triggerFlush()
  }
  clearShard = async (t) => {
    await this._performShardOperationById(t, (r) => {
      r.clear()
    })
  }
  clear = async () => {
    for (let [, t] of this._shardCache) t.clear()
    ;(this._manifest = { version: 1, lastUpdated: Date.now(), shards: {} }),
      await this._flush(),
      this._shardCache.clear(),
      (this._accessOrder = [])
  }
  dispose = async () => {
    ;(this._isDisposing = true),
      this._flushThrottled.cancel && this._flushThrottled.cancel(),
      await this._flush(),
      super.dispose()
  }
}
var Es = []
for (let e = 0; e < 256; ++e) Es.push((e + 256).toString(16).slice(1))
function yK(e, t = 0) {
  return (
    Es[e[t + 0]] +
    Es[e[t + 1]] +
    Es[e[t + 2]] +
    Es[e[t + 3]] +
    "-" +
    Es[e[t + 4]] +
    Es[e[t + 5]] +
    "-" +
    Es[e[t + 6]] +
    Es[e[t + 7]] +
    "-" +
    Es[e[t + 8]] +
    Es[e[t + 9]] +
    "-" +
    Es[e[t + 10]] +
    Es[e[t + 11]] +
    Es[e[t + 12]] +
    Es[e[t + 13]] +
    Es[e[t + 14]] +
    Es[e[t + 15]]
  ).toLowerCase()
}
var vK = require("crypto"),
  XS = new Uint8Array(256),
  ZS = XS.length
function mL() {
  return (
    ZS > XS.length - 16 && ((0, vK.randomFillSync)(XS), (ZS = 0)),
    XS.slice(ZS, (ZS += 16))
  )
}
var CK = require("crypto"),
  AL = { randomUUID: CK.randomUUID }
function k1e(e, t, r) {
  if (AL.randomUUID && !t && !e) return AL.randomUUID()
  e = e || {}
  let n = e.random ?? e.rng?.() ?? mL()
  if (n.length < 16) throw new Error("Random bytes length must be >= 16")
  if (((n[6] = (n[6] & 15) | 64), (n[8] = (n[8] & 63) | 128), t)) {
    if (((r = r || 0), r < 0 || r + 16 > t.length))
      throw new RangeError(
        `UUID byte range ${r}:${r + 15} is out of buffer bounds`,
      )
    for (let i = 0; i < 16; ++i) t[r + i] = n[i]
    return t
  }
  return yK(n)
}
var yL = k1e
function ho() {
  return yL()
}
function fc() {}
fc.prototype = {
  diff: function (t, r) {
    var n,
      i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      s = i.callback
    typeof i == "function" && ((s = i), (i = {}))
    var o = this
    function a(B) {
      return (
        (B = o.postProcess(B, i)),
        s
          ? (setTimeout(function () {
              s(B)
            }, 0),
            true)
          : B
      )
    }
    ;(t = this.castInput(t, i)),
      (r = this.castInput(r, i)),
      (t = this.removeEmpty(this.tokenize(t, i))),
      (r = this.removeEmpty(this.tokenize(r, i)))
    var l = r.length,
      c = t.length,
      u = 1,
      f = l + c
    i.maxEditLength != null && (f = Math.min(f, i.maxEditLength))
    var p = (n = i.timeout) !== null && n !== undefined ? n : 1 / 0,
      g = Date.now() + p,
      m = [{ oldPos: -1, lastComponent: undefined }],
      y = this.extractCommon(m[0], r, t, 0, i)
    if (m[0].oldPos + 1 >= c && y + 1 >= l)
      return a(bK(o, m[0].lastComponent, r, t, o.useLongestToken))
    var v = -1 / 0,
      C = 1 / 0
    function E() {
      for (var B = Math.max(v, -u); B <= Math.min(C, u); B += 2) {
        var T = undefined,
          N = m[B - 1],
          W = m[B + 1]
        N && (m[B - 1] = undefined)
        var Z = false
        if (W) {
          var te = W.oldPos - B
          Z = W && 0 <= te && te < l
        }
        var Y = N && N.oldPos + 1 < c
        if (!Z && !Y) {
          m[B] = undefined
          continue
        }
        if (
          (!Y || (Z && N.oldPos < W.oldPos)
            ? (T = o.addToPath(W, true, false, 0, i))
            : (T = o.addToPath(N, false, true, 1, i)),
          (y = o.extractCommon(T, r, t, B, i)),
          T.oldPos + 1 >= c && y + 1 >= l)
        )
          return a(bK(o, T.lastComponent, r, t, o.useLongestToken))
        ;(m[B] = T),
          T.oldPos + 1 >= c && (C = Math.min(C, B - 1)),
          y + 1 >= l && (v = Math.max(v, B + 1))
      }
      u++
    }
    if (s)
      (function B() {
        setTimeout(function () {
          if (u > f || Date.now() > g) return s()
          E() || B()
        }, 0)
      })()
    else
      for (; u <= f && Date.now() <= g; ) {
        var w = E()
        if (w) return w
      }
  },
  addToPath: function (t, r, n, i, s) {
    var o = t.lastComponent
    return o && !s.oneChangePerToken && o.added === r && o.removed === n
      ? {
          oldPos: t.oldPos + i,
          lastComponent: {
            count: o.count + 1,
            added: r,
            removed: n,
            previousComponent: o.previousComponent,
          },
        }
      : {
          oldPos: t.oldPos + i,
          lastComponent: {
            count: 1,
            added: r,
            removed: n,
            previousComponent: o,
          },
        }
  },
  extractCommon: function (t, r, n, i, s) {
    for (
      var o = r.length, a = n.length, l = t.oldPos, c = l - i, u = 0;
      c + 1 < o && l + 1 < a && this.equals(n[l + 1], r[c + 1], s);

    )
      c++,
        l++,
        u++,
        s.oneChangePerToken &&
          (t.lastComponent = {
            count: 1,
            previousComponent: t.lastComponent,
            added: false,
            removed: false,
          })
    return (
      u &&
        !s.oneChangePerToken &&
        (t.lastComponent = {
          count: u,
          previousComponent: t.lastComponent,
          added: false,
          removed: false,
        }),
      (t.oldPos = l),
      c
    )
  },
  equals: function (t, r, n) {
    return n.comparator
      ? n.comparator(t, r)
      : t === r || (n.ignoreCase && t.toLowerCase() === r.toLowerCase())
  },
  removeEmpty: function (t) {
    for (var r = [], n = 0; n < t.length; n++) t[n] && r.push(t[n])
    return r
  },
  castInput: function (t) {
    return t
  },
  tokenize: function (t) {
    return Array.from(t)
  },
  join: function (t) {
    return t.join("")
  },
  postProcess: function (t) {
    return t
  },
}
function bK(e, t, r, n, i) {
  for (var s = [], o; t; )
    s.push(t), (o = t.previousComponent), delete t.previousComponent, (t = o)
  s.reverse()
  for (var a = 0, l = s.length, c = 0, u = 0; a < l; a++) {
    var f = s[a]
    if (f.removed) (f.value = e.join(n.slice(u, u + f.count))), (u += f.count)
    else {
      if (!f.added && i) {
        var p = r.slice(c, c + f.count)
        ;(p = p.map(function (g, m) {
          var y = n[u + m]
          return y.length > g.length ? y : g
        })),
          (f.value = e.join(p))
      } else f.value = e.join(r.slice(c, c + f.count))
      ;(c += f.count), f.added || (u += f.count)
    }
  }
  return s
}
var __t = new fc()
function EK(e, t) {
  var r
  for (r = 0; r < e.length && r < t.length; r++)
    if (e[r] != t[r]) return e.slice(0, r)
  return e.slice(0, r)
}
function _K(e, t) {
  var r
  if (!e || !t || e[e.length - 1] != t[t.length - 1]) return ""
  for (r = 0; r < e.length && r < t.length; r++)
    if (e[e.length - (r + 1)] != t[t.length - (r + 1)]) return e.slice(-r)
  return e.slice(-r)
}
function CL(e, t, r) {
  if (e.slice(0, t.length) != t)
    throw Error(
      "string "
        .concat(JSON.stringify(e), " doesn't start with prefix ")
        .concat(JSON.stringify(t), "; this is a bug"),
    )
  return r + e.slice(t.length)
}
function bL(e, t, r) {
  if (!t) return e + r
  if (e.slice(-t.length) != t)
    throw Error(
      "string "
        .concat(JSON.stringify(e), " doesn't end with suffix ")
        .concat(JSON.stringify(t), "; this is a bug"),
    )
  return e.slice(0, -t.length) + r
}
function ab(e, t) {
  return CL(e, t, "")
}
function eI(e, t) {
  return bL(e, t, "")
}
function xK(e, t) {
  return t.slice(0, M1e(e, t))
}
function M1e(e, t) {
  var r = 0
  e.length > t.length && (r = e.length - t.length)
  var n = t.length
  e.length < t.length && (n = e.length)
  var i = Array(n),
    s = 0
  i[0] = 0
  for (var o = 1; o < n; o++) {
    for (t[o] == t[s] ? (i[o] = i[s]) : (i[o] = s); s > 0 && t[o] != t[s]; )
      s = i[s]
    t[o] == t[s] && s++
  }
  s = 0
  for (var a = r; a < e.length; a++) {
    for (; s > 0 && e[a] != t[s]; ) s = i[s]
    e[a] == t[s] && s++
  }
  return s
}
var tI =
    "a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}",
  F1e = new RegExp("[".concat(tI, "]+|\\s+|[^").concat(tI, "]"), "ug"),
  iI = new fc()
iI.equals = function (e, t, r) {
  return (
    r.ignoreCase && ((e = e.toLowerCase()), (t = t.toLowerCase())),
    e.trim() === t.trim()
  )
}
iI.tokenize = function (e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    r
  if (t.intlSegmenter) {
    if (t.intlSegmenter.resolvedOptions().granularity != "word")
      throw new Error('The segmenter passed must have a granularity of "word"')
    r = Array.from(t.intlSegmenter.segment(e), function (s) {
      return s.segment
    })
  } else r = e.match(F1e) || []
  var n = [],
    i = null
  return (
    r.forEach(function (s) {
      ;/\s/.test(s)
        ? i == null
          ? n.push(s)
          : n.push(n.pop() + s)
        : /\s/.test(i)
          ? n[n.length - 1] == i
            ? n.push(n.pop() + s)
            : n.push(i + s)
          : n.push(s),
        (i = s)
    }),
    n
  )
}
iI.join = function (e) {
  return e
    .map(function (t, r) {
      return r == 0 ? t : t.replace(/^\s+/, "")
    })
    .join("")
}
iI.postProcess = function (e, t) {
  if (!e || t.oneChangePerToken) return e
  var r = null,
    n = null,
    i = null
  return (
    e.forEach(function (s) {
      s.added
        ? (n = s)
        : s.removed
          ? (i = s)
          : ((n || i) && wK(r, i, n, s), (r = s), (n = null), (i = null))
    }),
    (n || i) && wK(r, i, n, null),
    e
  )
}
function wK(e, t, r, n) {
  if (t && r) {
    var i = t.value.match(/^\s*/)[0],
      s = t.value.match(/\s*$/)[0],
      o = r.value.match(/^\s*/)[0],
      a = r.value.match(/\s*$/)[0]
    if (e) {
      var l = EK(i, o)
      ;(e.value = bL(e.value, o, l)),
        (t.value = ab(t.value, l)),
        (r.value = ab(r.value, l))
    }
    if (n) {
      var c = _K(s, a)
      ;(n.value = CL(n.value, a, c)),
        (t.value = eI(t.value, c)),
        (r.value = eI(r.value, c))
    }
  } else if (r)
    e && (r.value = r.value.replace(/^\s*/, "")),
      n && (n.value = n.value.replace(/^\s*/, ""))
  else if (e && n) {
    var u = n.value.match(/^\s*/)[0],
      f = t.value.match(/^\s*/)[0],
      p = t.value.match(/\s*$/)[0],
      g = EK(u, f)
    t.value = ab(t.value, g)
    var m = _K(ab(u, g), p)
    ;(t.value = eI(t.value, m)),
      (n.value = CL(n.value, u, m)),
      (e.value = bL(e.value, u, u.slice(0, u.length - m.length)))
  } else if (n) {
    var y = n.value.match(/^\s*/)[0],
      v = t.value.match(/\s*$/)[0],
      C = xK(v, y)
    t.value = eI(t.value, C)
  } else if (e) {
    var E = e.value.match(/\s*$/)[0],
      w = t.value.match(/^\s*/)[0],
      B = xK(E, w)
    t.value = ab(t.value, B)
  }
}
var Q1e = new fc()
Q1e.tokenize = function (e) {
  var t = new RegExp(
    "(\\r?\\n)|[".concat(tI, "]+|[^\\S\\n\\r]+|[^").concat(tI, "]"),
    "ug",
  )
  return e.match(t) || []
}
var sI = new fc()
sI.tokenize = function (e, t) {
  t.stripTrailingCr &&
    (e = e.replace(
      /\r\n/g,
      `
`,
    ))
  var r = [],
    n = e.split(/(\n|\r\n)/)
  n[n.length - 1] || n.pop()
  for (var i = 0; i < n.length; i++) {
    var s = n[i]
    i % 2 && !t.newlineIsToken ? (r[r.length - 1] += s) : r.push(s)
  }
  return r
}
sI.equals = function (e, t, r) {
  return (
    r.ignoreWhitespace
      ? ((!r.newlineIsToken ||
          !e.includes(`
`)) &&
          (e = e.trim()),
        (!r.newlineIsToken ||
          !t.includes(`
`)) &&
          (t = t.trim()))
      : r.ignoreNewlineAtEof &&
        !r.newlineIsToken &&
        (e.endsWith(`
`) && (e = e.slice(0, -1)),
        t.endsWith(`
`) && (t = t.slice(0, -1))),
    fc.prototype.equals.call(this, e, t, r)
  )
}
function Kf(e, t, r) {
  return sI.diff(e, t, r)
}
var N1e = new fc()
N1e.tokenize = function (e) {
  return e.split(/(\S.+?[.!?])(?=\s+|$)/)
}
var P1e = new fc()
P1e.tokenize = function (e) {
  return e.split(/([{}:;,]|\s+)/)
}
function SK(e, t) {
  var r = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e)
    t &&
      (n = n.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      r.push.apply(r, n)
  }
  return r
}
function rI(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? SK(Object(r), true).forEach(function (n) {
          O1e(e, n, r[n])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
        : SK(Object(r)).forEach(function (n) {
            Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n))
          })
  }
  return e
}
function L1e(e, t) {
  if (typeof e != "object" || !e) return e
  var r = e[Symbol.toPrimitive]
  if (r !== undefined) {
    var n = r.call(e, t || "default")
    if (typeof n != "object") return n
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
function U1e(e) {
  var t = L1e(e, "string")
  return typeof t == "symbol" ? t : t + ""
}
function EL(e) {
  "@babel/helpers - typeof"
  return (
    (EL =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    EL(e)
  )
}
function O1e(e, t, r) {
  return (
    (t = U1e(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: r,
          enumerable: true,
          configurable: true,
          writable: true,
        })
      : (e[t] = r),
    e
  )
}
function vL(e) {
  return q1e(e) || V1e(e) || H1e(e) || W1e()
}
function q1e(e) {
  if (Array.isArray(e)) return _L(e)
}
function V1e(e) {
  if (
    (typeof Symbol < "u" && e[Symbol.iterator] != null) ||
    e["@@iterator"] != null
  )
    return Array.from(e)
}
function H1e(e, t) {
  if (e) {
    if (typeof e == "string") return _L(e, t)
    var r = Object.prototype.toString.call(e).slice(8, -1)
    if (
      (r === "Object" && e.constructor && (r = e.constructor.name),
      r === "Map" || r === "Set")
    )
      return Array.from(e)
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
      return _L(e, t)
  }
}
function _L(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r]
  return n
}
function W1e() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
var lb = new fc()
lb.useLongestToken = true
lb.tokenize = sI.tokenize
lb.castInput = function (e, t) {
  var r = t.undefinedReplacement,
    n = t.stringifyReplacer,
    i =
      n === undefined
        ? function (s, o) {
            return typeof o > "u" ? r : o
          }
        : n
  return typeof e == "string"
    ? e
    : JSON.stringify(xL(e, null, null, i), i, "  ")
}
lb.equals = function (e, t, r) {
  return fc.prototype.equals.call(
    lb,
    e.replace(/,([\r\n])/g, "$1"),
    t.replace(/,([\r\n])/g, "$1"),
    r,
  )
}
function xL(e, t, r, n, i) {
  ;(t = t || []), (r = r || []), n && (e = n(i, e))
  var s
  for (s = 0; s < t.length; s += 1) if (t[s] === e) return r[s]
  var o
  if (Object.prototype.toString.call(e) === "[object Array]") {
    for (
      t.push(e), o = new Array(e.length), r.push(o), s = 0;
      s < e.length;
      s += 1
    )
      o[s] = xL(e[s], t, r, n, i)
    return t.pop(), r.pop(), o
  }
  if ((e && e.toJSON && (e = e.toJSON()), EL(e) === "object" && e !== null)) {
    t.push(e), (o = {}), r.push(o)
    var a = [],
      l
    for (l in e) Object.prototype.hasOwnProperty.call(e, l) && a.push(l)
    for (a.sort(), s = 0; s < a.length; s += 1)
      (l = a[s]), (o[l] = xL(e[l], t, r, n, l))
    t.pop(), r.pop()
  } else o = e
  return o
}
var wL = new fc()
wL.tokenize = function (e) {
  return e.slice()
}
wL.join = wL.removeEmpty = function (e) {
  return e
}
function nI(e, t, r, n, i, s, o) {
  if (
    (o || (o = {}),
    typeof o == "function" && (o = { callback: o }),
    typeof o.context > "u" && (o.context = 4),
    o.newlineIsToken)
  )
    throw new Error(
      "newlineIsToken may not be used with patch-generation functions, only with diffing functions",
    )
  if (o.callback) {
    var a = o,
      l = a.callback
    Kf(
      r,
      n,
      rI(
        rI({}, o),
        {},
        {
          callback: function (f) {
            var p = c(f)
            l(p)
          },
        },
      ),
    )
  } else return c(Kf(r, n, o))
  function c(u) {
    if (!u) return
    u.push({ value: "", lines: [] })
    function f(Z) {
      return Z.map(function (te) {
        return " " + te
      })
    }
    for (
      var p = [],
        g = 0,
        m = 0,
        y = [],
        v = 1,
        C = 1,
        E = function () {
          var te = u[w],
            Y = te.lines || G1e(te.value)
          if (((te.lines = Y), te.added || te.removed)) {
            var U
            if (!g) {
              var ce = u[w - 1]
              ;(g = v),
                (m = C),
                ce &&
                  ((y = o.context > 0 ? f(ce.lines.slice(-o.context)) : []),
                  (g -= y.length),
                  (m -= y.length))
            }
            ;(U = y).push.apply(
              U,
              vL(
                Y.map(function (ie) {
                  return (te.added ? "+" : "-") + ie
                }),
              ),
            ),
              te.added ? (C += Y.length) : (v += Y.length)
          } else {
            if (g)
              if (Y.length <= o.context * 2 && w < u.length - 2) {
                var Ie
                ;(Ie = y).push.apply(Ie, vL(f(Y)))
              } else {
                var Q,
                  se = Math.min(Y.length, o.context)
                ;(Q = y).push.apply(Q, vL(f(Y.slice(0, se))))
                var J = {
                  oldStart: g,
                  oldLines: v - g + se,
                  newStart: m,
                  newLines: C - m + se,
                  lines: y,
                }
                p.push(J), (g = 0), (m = 0), (y = [])
              }
            ;(v += Y.length), (C += Y.length)
          }
        },
        w = 0;
      w < u.length;
      w++
    )
      E()
    for (var B = 0, T = p; B < T.length; B++)
      for (var N = T[B], W = 0; W < N.lines.length; W++)
        N.lines[W].endsWith(`
`)
          ? (N.lines[W] = N.lines[W].slice(0, -1))
          : (N.lines.splice(W + 1, 0, "\\ No newline at end of file"), W++)
    return {
      oldFileName: e,
      newFileName: t,
      oldHeader: i,
      newHeader: s,
      hunks: p,
    }
  }
}
function SL(e) {
  if (Array.isArray(e))
    return e.map(SL).join(`
`)
  var t = []
  e.oldFileName == e.newFileName && t.push("Index: " + e.oldFileName),
    t.push(
      "===================================================================",
    ),
    t.push(
      "--- " +
        e.oldFileName +
        (typeof e.oldHeader > "u" ? "" : "	" + e.oldHeader),
    ),
    t.push(
      "+++ " +
        e.newFileName +
        (typeof e.newHeader > "u" ? "" : "	" + e.newHeader),
    )
  for (var r = 0; r < e.hunks.length; r++) {
    var n = e.hunks[r]
    n.oldLines === 0 && (n.oldStart -= 1),
      n.newLines === 0 && (n.newStart -= 1),
      t.push(
        "@@ -" +
          n.oldStart +
          "," +
          n.oldLines +
          " +" +
          n.newStart +
          "," +
          n.newLines +
          " @@",
      ),
      t.push.apply(t, n.lines)
  }
  return (
    t.join(`
`) +
    `
`
  )
}
function oI(e, t, r, n, i, s, o) {
  var a
  if (
    (typeof o == "function" && (o = { callback: o }),
    (a = o) !== null && a !== undefined && a.callback)
  ) {
    var c = o,
      u = c.callback
    nI(
      e,
      t,
      r,
      n,
      i,
      s,
      rI(
        rI({}, o),
        {},
        {
          callback: function (p) {
            p ? u(SL(p)) : u()
          },
        },
      ),
    )
  } else {
    var l = nI(e, t, r, n, i, s, o)
    return l ? SL(l) : undefined
  }
}
function G1e(e) {
  var t = e.endsWith(`
`),
    r = e
      .split(
        `
`,
      )
      .map(function (n) {
        return (
          n +
          `
`
        )
      })
  return t ? r.pop() : r.push(r.pop().slice(0, -1)), r
}
var aI = class extends DisposableContainer_2 {
  _storage
  _getMemoriesAbsPath
  _onDocumentChange
  _onFileDeleted
  _onFileDidMove
  shardManager
  _shardFunction = (t) => `shard-${t.conversationId}`
  _currentConversationId
  _logger = getLogger("AggregateCheckpointManager")
  _agentEditListHasUpdatesCallbacks = new Set()
  constructor(t, r, n, i, s) {
    super(),
      (this._storage = t),
      (this._getMemoriesAbsPath = r),
      (this._onDocumentChange = n),
      (this._onFileDeleted = i),
      (this._onFileDidMove = s),
      (this.shardManager = new jS(this._storage, this._shardFunction)),
      this.addDisposable(
        this._onDocumentChange((o) => {
          this._handleDocumentChange(o)
        }),
      ),
      this.addDisposable(
        this._onFileDeleted((o) => {
          this._handleFileDeleted(o)
        }),
      ),
      this.addDisposable(
        this._onFileDidMove((o) => {
          this._handleFileMoved(o)
        }),
      ),
      this.addDisposable({
        dispose: () => {
          this._agentEditListHasUpdatesCallbacks.clear()
        },
      })
  }
  get currentConversationId() {
    return this._currentConversationId
  }
  setCurrentConversation(t) {
    this._currentConversationId = t
  }
  getAgentMemoriesAbsPath = () => this._getMemoriesAbsPath()
  onAgentEditListHasUpdates = (t) => (
    this._agentEditListHasUpdatesCallbacks.add(t),
    {
      dispose: () => {
        this._agentEditListHasUpdatesCallbacks.delete(t)
      },
    }
  )
  _notifyAgentEditListHasUpdates = () => {
    this._agentEditListHasUpdatesCallbacks.forEach((t) => t())
  }
  _getAllTrackedFiles = async (t) => {
    await this.shardManager.initialize()
    let r = this._shardFunction({ conversationId: t })
    return (await this.shardManager.getShardById(r)).getAllTrackedFilePaths(t)
  }
  _checkpointFileState = async (t, r, n = {}) => {
    let i = (await Vi().readFile(r.absPath)).contents
    if (i === undefined) return
    let s = {
        sourceToolCallRequestId: ho(),
        timestamp: n.timestamp ?? Date.now(),
        document: new DiffViewDocument(r, i, i, { logger: this._logger }),
        conversationId: t,
      },
      o = { conversationId: t, path: r }
    return (
      await this.shardManager.addCheckpoint(o, s),
      this._notifyAgentEditListHasUpdates(),
      s.sourceToolCallRequestId
    )
  }
  _trackFile = async (t, r) => {
    await this.shardManager.initialize()
    let n = { conversationId: t, path: r }
    if ((await this.shardManager.getCheckpoints(n)).length > 0) {
      this._logger.debug(`File already tracked: ${r.absPath}`)
      return
    }
    this._logger.debug(`Tracking file: ${r.absPath}`),
      await this._checkpointFileState(t, r, { timestamp: 0 })
  }
  storeCurrentFileStateAsCheckpoint = async (t, r) => (
    await this.shardManager.initialize(), await this._checkpointFileState(t, r)
  )
  addCheckpoint = async (t, r) => {
    await this.shardManager.initialize(),
      await this._trackFile(t.conversationId, r.document.filePath),
      await this.shardManager.addCheckpoint(t, r),
      r.document.modifiedCode === undefined
        ? (this._logger.debug(`Deleting file: ${r.document.filePath.absPath}`),
          await Vi().deleteFile(r.document.filePath))
        : (this._logger.debug(`Writing file: ${r.document.filePath.absPath}`),
          await Vi().writeFile(r.document.filePath, r.document.modifiedCode)),
      this._notifyAgentEditListHasUpdates()
  }
  _getFileStateAtTimestamp = async (t, r, n) => {
    if (!(await this.shardManager.hasKey({ conversationId: t, path: r })))
      return null
    let s = { conversationId: t, path: r },
      a = (await this.shardManager.getCheckpoints(s, { maxTimestamp: n })).at(
        -1,
      )
    if (a) return a.document.modifiedCode
    let c = (await this.shardManager.getCheckpoints(s, { minTimestamp: n })).at(
      0,
    )
    return c ? c.document.originalCode : null
  }
  _handleDocumentChange = async (t) => {
    let r = QualifiedPathName.from(t.document.qualifiedPathName)
    if (r === undefined || this._currentConversationId === undefined) return
    let n = t.document.getText?.()
    await this.updateLatestCheckpoint(r, n)
  }
  _handleFileDeleted = async (t) => {
    let r = QualifiedPathName.from(t.qualifiedPathName)
    if (r === undefined || this._currentConversationId === undefined) return
    this._logger.debug(`Handling file deleted notification: ${r.absPath}`)
    let n = { conversationId: this._currentConversationId, path: r },
      i = await this._getFileStateAtTimestamp(
        this._currentConversationId,
        r,
        Number.MAX_SAFE_INTEGER,
      )
    i !== null &&
      (await this.addCheckpoint(n, {
        sourceToolCallRequestId: ho(),
        timestamp: Date.now(),
        document: new DiffViewDocument(r, i, undefined, {}),
        conversationId: this._currentConversationId,
      }),
      this._logger.debug(`Marked file deleted: ${r.absPath}`))
  }
  _handleFileMoved = async (t) => {
    let r = QualifiedPathName.from(t.oldQualifiedPathName),
      n = QualifiedPathName.from(t.newQualifiedPathName)
    if (r === undefined || n === undefined || this._currentConversationId === undefined)
      return
    this._logger.debug(`File moved: ${r.absPath} -> ${n.absPath}`)
    let i = { conversationId: this._currentConversationId, path: r },
      s = await this.shardManager.getCheckpoints(i)
    if (s.length === 0) return
    let o = { conversationId: this._currentConversationId, path: n }
    for (let a of s) {
      let l = {
        ...a,
        document: new DiffViewDocument(
          n,
          a.document.originalCode,
          a.document.modifiedCode,
          {},
        ),
      }
      await this.shardManager.addCheckpoint(o, l)
    }
    await this.shardManager.removeCheckpoint(i),
      this._notifyAgentEditListHasUpdates()
  }
  updateLatestCheckpoint = async (t, r, n) => {
    if (this._currentConversationId === undefined) {
      this._logger.warn(
        "Cannot update latest checkpoint. No current conversation ID.",
      )
      return
    }
    let i = { conversationId: this._currentConversationId, path: t },
      o = (await this.shardManager.getCheckpoints(i)).at(-1)
    if (o === undefined) return
    let a = { ...o, document: new DiffViewDocument(t, o.document.originalCode, r, {}) }
    await this.shardManager.updateCheckpoint(i, a),
      this._logger.debug(
        `Updated latest checkpoint for ${t.absPath} with ${r}`,
      ),
      this._notifyAgentEditListHasUpdates(),
      (n?.saveToWorkspace ?? false) &&
        (r === undefined
          ? (await Vi().deleteFile(t),
            this._logger.debug(`Deleted file: ${t.absPath}`))
          : (await Vi().writeFile(t, r),
            this._logger.debug(`Wrote file: ${t.absPath}`)))
  }
  getAggregateCheckpointForFile = async (t, r) => {
    await this.shardManager.initialize()
    let n = this._currentConversationId
    if (n === undefined)
      return {
        fromTimestamp: 0,
        toTimestamp: 1 / 0,
        conversationId: "",
        files: [],
      }
    let i = r.minTimestamp ?? 0,
      s = r.maxTimestamp ?? 1 / 0,
      o = await this._getFileStateAtTimestamp(n, t, i),
      a = await this._getFileStateAtTimestamp(n, t, s)
    if (o === null || a === null)
      return (
        this._logger.warn(
          `Cannot get aggregate checkpoint for ${t.absPath}. No checkpoints found.`,
        ),
        { fromTimestamp: i, toTimestamp: s, conversationId: n, files: [] }
      )
    let l = new DiffViewDocument(t, o, a, {})
    return {
      fromTimestamp: i,
      toTimestamp: s,
      conversationId: n,
      files: [{ changesSummary: IL(l), changeDocument: l }],
    }
  }
  getCheckpointByRequestId = async (t) => {
    await this.shardManager.initialize()
    let r = this._currentConversationId
    if (r === undefined) return
    let n = this._shardFunction({ conversationId: r }),
      s = (await this.shardManager.getShardById(n)).getCheckpointBySourceId(t)
    if (s !== undefined)
      return {
        fromTimestamp: s.timestamp,
        toTimestamp: s.timestamp,
        conversationId: r,
        files: [{ changesSummary: IL(s.document), changeDocument: s.document }],
      }
  }
  getAggregateCheckpoint = async (t) => {
    await this.shardManager.initialize()
    let r = t.minTimestamp ?? 0,
      n = t.maxTimestamp ?? 1 / 0,
      i = this._currentConversationId
    if (i === undefined)
      return {
        fromTimestamp: 0,
        toTimestamp: 1 / 0,
        conversationId: "",
        files: [],
      }
    let s = await this._getAllTrackedFiles(i),
      o = await Promise.all(
        s.map(async (a) => {
          let l = await this._getFileStateAtTimestamp(i, a, r),
            c = await this._getFileStateAtTimestamp(i, a, n)
          if (l === null || c === null) {
            this._logger.warn(
              `Cannot get aggregate checkpoint for ${a.absPath}. No checkpoints found.`,
            )
            return
          }
          return new DiffViewDocument(a, l, c, {})
        }),
      )
    return {
      fromTimestamp: r,
      toTimestamp: n,
      conversationId: i,
      files: o
        .filter((a) => a !== undefined)
        .map((a) => ({ changesSummary: IL(a), changeDocument: a })),
    }
  }
  clearConversationCheckpoints = async (t) => {
    await this.shardManager.initialize(),
      await this.shardManager.clearShard(
        this._shardFunction({ conversationId: t }),
      )
  }
  revertDocumentToTimestamp = async (t, r) => {
    await this.shardManager.initialize()
    let n = this._currentConversationId
    if (n === undefined) return
    let i = await this._getFileStateAtTimestamp(n, t, r),
      s = await this._getFileStateAtTimestamp(n, t, Number.MAX_SAFE_INTEGER)
    i === null ||
      s === null ||
      (await this.addCheckpoint(
        { conversationId: n, path: t },
        {
          sourceToolCallRequestId: ho(),
          timestamp: Date.now(),
          document: new DiffViewDocument(t, s ?? "", i, {}),
          conversationId: n,
        },
      ))
  }
  revertToTimestamp = async (t) => {
    if (
      (await this.shardManager.initialize(),
      this._currentConversationId === undefined)
    )
      return
    let n = await this.getAggregateCheckpoint({
      minTimestamp: t,
      maxTimestamp: undefined,
    })
    this._logger.debug(
      `Reverting to timestamp: ${t}. Includes files ${n.files.map((i) => i.changeDocument.filePath.absPath).join(", ")}`,
    ),
      await Promise.all(
        n.files.map(async (i) => {
          await this.revertDocumentToTimestamp(i.changeDocument.filePath, t)
        }),
      )
  }
}
function IL(e) {
  let t = Kf(e.originalCode ?? "", e.modifiedCode ?? ""),
    r = t.filter((i) => i.added).reduce((i, s) => i + (s.count ?? 0), 0),
    n = t.filter((i) => i.removed).reduce((i, s) => i + (s.count ?? 0), 0)
  return { totalAddedLines: r, totalRemovedLines: n, changes: t }
}
var InvalidCompletionUrlError = class extends Error {
  constructor() {
    super("The completion URL setting is invalid")
  }
}
var cb = class {
    static _instance = undefined
    static setAPIClient(t) {
      if (this._instance !== undefined) {
        getLogger("APICLient").warn(
          "Attempting to initialize API clientwhen one is already configured. Keeping existing client workspaces.",
        )
        return
      }
      this._instance = t
    }
    static getAPIClient() {
      if (this._instance === undefined) throw new Error("API Client not set")
      return this._instance
    }
    static reset() {
      this._instance = undefined
    }
  },
  IK = (e) => cb.setAPIClient(e),
  yl = () => cb.getAPIClient(),
  BK = () => cb.reset()
var ub = class {
    static _instance = undefined
    static setClientActions(t) {
      if (this._instance !== undefined) {
        getLogger("ClientActions").warn(
          "Attempting to initialize client actions when one is already configured. Keeping existing client actions.",
        )
        return
      }
      this._instance = t
    }
    static getClientActions() {
      if (this._instance === undefined) throw new Error("ClientActions not set")
      return this._instance
    }
    static reset() {
      this._instance = undefined
    }
  },
  RK = (e) => ub.setClientActions(e),
  DK = () => ub.getClientActions(),
  TK = () => ub.reset()
var ClientAuthSingleton = class {
    static _instance = undefined
    static setClientAuth(t) {
      if (this._instance !== undefined) {
        getLogger("ClientAuth").warn(
          "Attempting to initialize client auth when one is already configured. Keeping existing client auth.",
        )
        return
      }
      this._instance = t
    }
    static getClientAuth() {
      if (this._instance === undefined) throw new Error("ClientAuth not set")
      return this._instance
    }
    static reset() {
      this._instance = undefined
    }
  },
  setClientAuth = (e) => ClientAuthSingleton.setClientAuth(e),
  getClientAuth = () => ClientAuthSingleton.getClientAuth()
var ClientConfigSingleton = class {
    static _instance = undefined
    static setClientConfig(t) {
      if (this._instance !== undefined) {
        getLogger("ClientConfig").warn(
          "Attempting to initialize client config when one is already configured. Keeping existing client config.",
        )
        return
      }
      this._instance = t
    }
    static getClientConfig() {
      if (this._instance === undefined) throw new Error("ClientConfig not set")
      return this._instance
    }
    static reset() {
      this._instance = undefined
    }
  },
  setClientConfig = (e) => ClientConfigSingleton.setClientConfig(e),
  getClientConfig = () => ClientConfigSingleton.getClientConfig()
var db = class {
    static _instance = undefined
    static setClientFeatureFlags(t) {
      if (this._instance !== undefined) {
        getLogger("ClientFeatureFlags").warn(
          "Attempting to initialize client feature flags when one is already configured. Keeping existing client feature flags.",
        )
        return
      }
      this._instance = t
    }
    static getClientFeatureFlags() {
      if (this._instance === undefined)
        throw new Error("ClientFeatureFlags not set")
      return this._instance
    }
    static reset() {
      this._instance = undefined
    }
  },
  NK = (e) => db.setClientFeatureFlags(e),
  _a = () => db.getClientFeatureFlags(),
  PK = () => db.reset()
var du
;(function (e) {
  e.agent = "agent"
})(du || (du = {}))
var hc
;(function (e) {
  e.global = "global"
})(hc || (hc = {}))
var fb = class {
    static _instance = undefined
    static setStateForSidecar(t) {
      if (this._instance !== undefined) {
        getLogger("PluginStateForSidecarSingleton").warn(
          "Attempting to initialize plugin state when one is already configured. Keeping existing plugin state.",
        )
        return
      }
      this._instance = t
    }
    static getStateForSidecar() {
      if (this._instance === undefined)
        throw new Error("PluginStateForSidecar not set")
      return this._instance
    }
    static reset() {
      this._instance = undefined
    }
  },
  LK = (e) => fb.setStateForSidecar(e),
  DA = () => fb.getStateForSidecar(),
  UK = () => fb.reset()
var hb = class {
    static _instance = undefined
    static setWebviewMessagingClient(t) {
      if (this._instance !== undefined) {
        getLogger("WebviewMessages").warn(
          "Attempting to initialize webview messages when one is already configured. Keeping existing webview message client.",
        )
        return
      }
      this._instance = t
    }
    static getWebviewMessagingClient() {
      if (this._instance === undefined)
        throw new Error("Webview messaging client not set")
      return this._instance
    }
    static reset() {
      this._instance = undefined
    }
  },
  OK = (e) => hb.setWebviewMessagingClient(e),
  $1e = () => hb.getWebviewMessagingClient(),
  qK = () => hb.reset()
function VK(e, t) {
  $1e().onMessage(e, t)
}
var RequestStatus
;(function (e) {
  ;(e[(e.ok = 0)] = "ok"),
    (e[(e.cancelled = 1)] = "cancelled"),
    (e[(e.unknown = 2)] = "unknown"),
    (e[(e.unavailable = 3)] = "unavailable"),
    (e[(e.unimplemented = 4)] = "unimplemented"),
    (e[(e.invalidArgument = 5)] = "invalidArgument"),
    (e[(e.resourceExhausted = 6)] = "resourceExhausted"),
    (e[(e.unauthenticated = 7)] = "unauthenticated"),
    (e[(e.permissionDenied = 8)] = "permissionDenied"),
    (e[(e.deadlineExceeded = 9)] = "deadlineExceeded"),
    (e[(e.augmentTooLarge = 10)] = "augmentTooLarge")
})(RequestStatus || (RequestStatus = {}))
var ApiError = class ApiError extends Error {
  status
  constructor(statusCode, message) {
    super(message), (this.status = statusCode)
  }
  static transientIssue(message) {
    return new ApiError(RequestStatus.unavailable, message)
  }
  static fromResponse(response) {
    return new ApiError(mapHttpStatusToRequestStatus(response.status), `HTTP error: ${response.status} ${response.statusText}`)
  }
  static isAPIErrorWithStatus(error, statusCode) {
    return error instanceof ApiError ? error.status === statusCode : false
  }
  static isRetriableAPIError(error) {
    return error instanceof ApiError ? retriableStatusCodes.has(error.status) : false
  }
}
function mapHttpStatusToRequestStatus(httpStatusCode) {
  switch (httpStatusCode) {
    case 200:
      return RequestStatus.ok
    case 400:
      return RequestStatus.invalidArgument
    case 401:
      return RequestStatus.unauthenticated
    case 403:
      return RequestStatus.permissionDenied
    case 404:
      return RequestStatus.unimplemented
    case 413:
      return RequestStatus.augmentTooLarge
    case 429:
      return RequestStatus.resourceExhausted
    case 499:
      return RequestStatus.cancelled
    case 504:
      return RequestStatus.deadlineExceeded
  }
  return httpStatusCode >= 500 && httpStatusCode < 600 ? RequestStatus.unavailable : RequestStatus.unknown
}
var retriableStatusCodes = new Set([RequestStatus.unavailable, RequestStatus.cancelled])
function z1e(e) {
  return e.cause instanceof String
    ? String(e.cause)
    : e.cause instanceof Object
      ? JSON.stringify(e.cause)
      : ""
}
function getErrorMessage(error, includeCause = false) {
  if (error instanceof Error) {
    if (includeCause) {
      let causeString = z1e(error)
      if (causeString !== "") return `${error.message} (due to ${causeString})`
    }
    return error.message
  }
  return String(error)
}
var CircularBuffer = class {
  _maxItems
  _insertCount = 0
  _emptySlots
  _items
  constructor(capacity) {
    ;(this._maxItems = capacity), (this._items = new Array(capacity)), (this._emptySlots = capacity)
  }
  get empty() {
    return this.length === 0
  }
  get length() {
    return this._maxItems - this._emptySlots
  }
  addItem(item) {
    ;(this._items[this._insertCount % this._maxItems] = item),
      (this._emptySlots = Math.max(this._emptySlots - 1, 0)),
      this._insertCount++
  }
  shiftLeft(count) {
    this._emptySlots = Math.min(this._emptySlots + count, this._maxItems)
  }
  shiftRight(count) {
    ;(this._insertCount -= Math.min(count, this.length)),
      (this._emptySlots = Math.min(this._emptySlots + count, this._maxItems))
  }
  at(index) {
    if (index < 0)
      return index < -this.length
        ? undefined
        : this._items[(this._insertCount + index) % this._maxItems]
    if (!(index >= this.length))
      return this._items[
        (this._insertCount + this._emptySlots + index) % this._maxItems
      ]
  }
  _normalizeSliceIdx(index) {
    return index >= 0 ? Math.min(index, this.length) : Math.max(this.length + index, 0)
  }
  _translateIdx(index) {
    return (this._insertCount + this._emptySlots + index) % this._maxItems
  }
  slice(start, end) {
    let normalizedStart = this._normalizeSliceIdx(start ?? 0),
      normalizedEnd = this._normalizeSliceIdx(end ?? this.length)
    if (normalizedStart > normalizedEnd) return []
    let sliceLength = normalizedEnd - normalizedStart,
      startPosition = this._translateIdx(normalizedStart)
    return startPosition + sliceLength <= this._maxItems
      ? this._items.slice(startPosition, startPosition + sliceLength)
      : this._items
          .slice(startPosition)
          .concat(this._items.slice(0, (startPosition + sliceLength) % this._maxItems))
  }
  *[Symbol.iterator]() {
    for (let index = 0; index < this.length; index++) yield this.at(index)
  }
  clear() {
    this._emptySlots = this._maxItems
  }
}
var J1e = { initialMS: 100, mult: 2, maxMS: 3e4 }
function sleep(milliseconds) {
  return milliseconds === 0
    ? Promise.resolve()
    : new Promise((resolve) => {
        setTimeout(resolve, milliseconds)
      })
}
async function retryOperation(operation, logger, options = J1e) {
  let delayMs = 0,
    startTime = options.maxTotalMs !== undefined ? Date.now() : undefined,
    isRetriableError = options.canRetry ? options.canRetry : (error) => ApiError.isRetriableAPIError(error)
  for (let retryCount = 0; ; retryCount++)
    try {
      let result = await operation()
      return (
        retryCount > 0 && logger.info(`Operation succeeded after ${retryCount} transient failures`), result
      )
    } catch (error) {
      if (!isRetriableError(error)) throw error
      let attemptNumber = retryCount + 1
      if (
        (options.maxTries !== undefined && attemptNumber >= options.maxTries) ||
        (delayMs === 0 ? (delayMs = options.initialMS) : (delayMs = Math.min(delayMs * options.mult, options.maxMS)),
        logger.info(
          `Operation failed with error ${error}, retrying in ${delayMs} ms; retries = ${retryCount}`,
        ),
        options.maxTotalMs !== undefined &&
          startTime !== undefined &&
          Date.now() - startTime + delayMs > options.maxTotalMs)
      )
        throw error
      await sleep(delayMs)
    }
}
async function executeWithTimeout(operation, timeoutMs) {
  let timeoutPromise = new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(new Error("Execution aborted due to timeout."))
    }, timeoutMs)
  })
  return await Promise.race([operation, timeoutPromise])
}
var MetricsReporter = class {
  _uploadMsec
  _uploadBatchSize
  _logger
  _store
  _uploadIntervalId = undefined
  _currentUploadPromise
  constructor(loggerName, maxItems, uploadInterval, batchSize) {
    ;(this._uploadMsec = uploadInterval),
      (this._uploadBatchSize = batchSize),
      (this._store = new CircularBuffer(maxItems)),
      (this._logger = getLogger(loggerName))
  }
  report(metric) {
    this._store.addItem(metric)
  }
  get uploadEnabled() {
    return this._uploadIntervalId !== undefined
  }
  enableUpload() {
    this.uploadEnabled ||
      (this._uploadIntervalId = setInterval(() => {
        this._currentUploadPromise === undefined &&
          (async () => {
            try {
              ;(this._currentUploadPromise = this._doUpload()),
                await this._currentUploadPromise
            } finally {
              this._currentUploadPromise = undefined
            }
          })()
      }, this._uploadMsec))
  }
  async uploadNow() {
    return this._doUpload()
  }
  async _doUpload() {
    if (this._store.length === 0) return
    let metrics = this._store.slice()
    this._store.clear()
    for (let index = 0; index < metrics.length; index += this._uploadBatchSize) {
      let batch = metrics.slice(index, index + this._uploadBatchSize)
      await retryOperation(async () => {
        if (this.uploadEnabled)
          try {
            return (
              this._logger.debug(`Uploading ${batch.length} metric(s)`),
              await this.performUpload(batch)
            )
          } catch (error) {
            throw (
              (this._logger.error(
                `Error uploading metrics: ${error} ${error instanceof Error ? error.stack : ""}`,
              ),
              error)
            )
          }
      }, this._logger)
    }
  }
  disableUpload() {
    clearInterval(this._uploadIntervalId), (this._uploadIntervalId = undefined)
  }
  dispose() {
    this.disableUpload()
  }
}
function Vn(e) {
  let t = Math.floor(e / 1e3),
    r = (e % 1e3) * 1e6
  return [t, r]
}
var uI = class e extends MetricsReporter {
  static maxRecords = 1e4
  static batchSize = 1e3
  static uploadMsec = 1e4
  static instance = null
  static getInstance() {
    return (
      e.instance || ((e.instance = new e()), e.instance.enableUpload()),
      e.instance
    )
  }
  static reset() {
    e.instance && (e.instance.dispose(), (e.instance = null))
  }
  constructor() {
    super("AgentRequestEventReporter", e.maxRecords, e.uploadMsec, e.batchSize)
  }
  reportEvent(t) {
    let [r, n] = Vn(Date.now())
    this.report({
      event_time_sec: r,
      event_time_nsec: n,
      event_name: t.eventName,
      conversation_id: t.conversationId,
      request_id: t.requestId,
      chat_history_length: t.chatHistoryLength,
    })
  }
  performUpload(t) {
    return yl().logAgentRequestEvent(t)
  }
}
function HK() {
  return uI.getInstance()
}
function WK() {
  uI.reset()
}
var dI = class e extends MetricsReporter {
  static maxRecords = 1e4
  static batchSize = 1e3
  static uploadMsec = 1e4
  static instance = null
  static getInstance() {
    return (
      e.instance || ((e.instance = new e()), e.instance.enableUpload()),
      e.instance
    )
  }
  static reset() {
    e.instance && (e.instance.dispose(), (e.instance = null))
  }
  constructor() {
    super("AgentSessionEventReporter", e.maxRecords, e.uploadMsec, e.batchSize)
  }
  formatTracingData(t) {
    return {
      flags: t.flags,
      nums: t.nums,
      string_stats: t.string_stats,
      request_ids: t.request_ids,
    }
  }
  reportEvent(t) {
    let [r, n] = Vn(Date.now()),
      i,
      s = _a().flags.memoriesParams.enable_memories_tracing
    if (
      (t.eventData?.agentReversionData && (i = { agent_reversion_data: {} }),
      t.eventData?.agentInterruptionData &&
        (i = {
          agent_interruption_data: {
            request_id: t.eventData.agentInterruptionData.requestId,
            curr_conversation_length:
              t.eventData.agentInterruptionData.currConversationLength,
          },
        }),
      t.eventData?.rememberToolCallData)
    ) {
      if (!s) return
      i = {
        remember_tool_call_data: {
          caller: t.eventData.rememberToolCallData.caller,
          is_complex_new_memory:
            t.eventData.rememberToolCallData.is_complex_new_memory,
          tracing_data: this.formatTracingData(
            t.eventData.rememberToolCallData.tracingData,
          ),
        },
      }
    }
    if (t.eventData?.initialOrientationData) {
      if (!s) return
      i = {
        initial_orientation_data: {
          caller: t.eventData.initialOrientationData.caller,
          tracing_data: this.formatTracingData(
            t.eventData.initialOrientationData.tracingData,
          ),
        },
      }
    }
    if (t.eventData?.classifyAndDistillData) {
      if (!s) return
      i = {
        classify_and_distill_data: {
          tracing_data: this.formatTracingData(
            t.eventData.classifyAndDistillData.tracingData,
          ),
        },
      }
    }
    if (t.eventData?.flushMemoriesData) {
      if (!s) return
      i = {
        flush_memories_data: {
          tracing_data: this.formatTracingData(
            t.eventData.flushMemoriesData.tracingData,
          ),
        },
      }
    }
    t.eventData?.memoriesFileOpenData &&
      (i = {
        memories_file_open_data: {
          memories_path_undefined:
            t.eventData.memoriesFileOpenData.memoriesPathUndefined,
        },
      }),
      this.report({
        event_time_sec: r,
        event_time_nsec: n,
        event_name: t.eventName,
        conversation_id: t.conversationId,
        event_data: i,
      })
  }
  performUpload(t) {
    return yl().logAgentSessionEvent(t)
  }
}
function Mr() {
  return dI.getInstance()
}
function GK() {
  dI.reset()
}
var fI = class e extends MetricsReporter {
  static defaultMaxRecords = 1e4
  static defaultBatchSize = 1e3
  static defaultUploadMsec = 1e4
  constructor(t, r, n) {
    super(
      "ToolUseRequestEventReporter",
      t ?? e.defaultMaxRecords,
      r ?? e.defaultUploadMsec,
      n ?? e.defaultBatchSize,
    )
  }
  reportEvent(t, r, n, i, s, o, a, l, c, u) {
    let [f, p] = Vn(Date.now())
    this.report({
      requestId: t,
      toolName: r,
      toolUseId: n,
      toolInput: i,
      toolOutputIsError: s,
      toolRunDurationMs: o,
      isMcpTool: a,
      conversationId: l,
      chatHistoryLength: c,
      eventTimeSec: f,
      eventTimeNsec: p,
      toolRequestId: u,
    })
  }
  performUpload(t) {
    return yl().logToolUseRequestEvent(t)
  }
}
var Hi
;(function (e) {
  ;(e.shell = "shell"),
    (e.webFetch = "web-fetch"),
    (e.strReplaceEditor = "str-replace-editor"),
    (e.codebaseRetrieval = "codebase-retrieval"),
    (e.removeFiles = "remove-files"),
    (e.remember = "remember")
})(Hi || (Hi = {}))
var hI = {
  strReplaceEditor: "str_replace_editor_tool",
  backendEditTool: "backend_edit_tool",
}
var po
;(function (e) {
  ;(e[(e.TEXT = 0)] = "TEXT"),
    (e[(e.TOOL_RESULT = 1)] = "TOOL_RESULT"),
    (e[(e.IMAGE = 2)] = "IMAGE"),
    (e[(e.IMAGE_ID = 3)] = "IMAGE_ID"),
    (e[(e.IDE_STATE = 4)] = "IDE_STATE"),
    (e[(e.EDIT_EVENTS = 5)] = "EDIT_EVENTS"),
    (e[(e.CHECKPOINT_REF = 6)] = "CHECKPOINT_REF"),
    (e[(e.CHANGE_PERSONALITY = 7)] = "CHANGE_PERSONALITY")
})(po || (po = {}))
var gI
;(function (e) {
  ;(e[(e.IMAGE_FORMAT_UNSPECIFIED = 0)] = "IMAGE_FORMAT_UNSPECIFIED"),
    (e[(e.PNG = 1)] = "PNG"),
    (e[(e.JPEG = 2)] = "JPEG"),
    (e[(e.GIF = 3)] = "GIF"),
    (e[(e.WEBP = 4)] = "WEBP")
})(gI || (gI = {}))
var $K
;(function (e) {
  ;(e[(e.UNSPECIFIED = 0)] = "UNSPECIFIED"),
    (e[(e.USER_EDIT = 1)] = "USER_EDIT"),
    (e[(e.CHECKPOINT_REVERT = 2)] = "CHECKPOINT_REVERT")
})($K || ($K = {}))
var YK
;(function (e) {
  ;(e[(e.CONTENT_TYPE_UNSPECIFIED = 0)] = "CONTENT_TYPE_UNSPECIFIED"),
    (e[(e.CONTENT_TEXT = 1)] = "CONTENT_TEXT"),
    (e[(e.CONTENT_IMAGE = 2)] = "CONTENT_IMAGE")
})(YK || (YK = {}))
var gc
;(function (e) {
  ;(e[(e.RAW_RESPONSE = 0)] = "RAW_RESPONSE"),
    (e[(e.SUGGESTED_QUESTIONS = 1)] = "SUGGESTED_QUESTIONS"),
    (e[(e.MAIN_TEXT_FINISHED = 2)] = "MAIN_TEXT_FINISHED"),
    (e[(e.TOOL_USE = 5)] = "TOOL_USE"),
    (e[(e.AGENT_MEMORY = 6)] = "AGENT_MEMORY")
})(gc || (gc = {}))
var Fr
;(function (e) {
  ;(e.chat = "CHAT"),
    (e.agent = "AGENT"),
    (e.remoteAgent = "REMOTE_AGENT"),
    (e.memories = "MEMORIES"),
    (e.orientation = "ORIENTATION"),
    (e.memoriesCompression = "MEMORIES_COMPRESSION")
})(Fr || (Fr = {}))
var KK
;(function (e) {
  ;(e[(e.DEFAULT = 0)] = "DEFAULT"),
    (e[(e.PROTOTYPER = 1)] = "PROTOTYPER"),
    (e[(e.BRAINSTORM = 2)] = "BRAINSTORM"),
    (e[(e.REVIEWER = 3)] = "REVIEWER")
})(KK || (KK = {}))
var nr
;(function (e) {
  ;(e.modified = "MODIFIED"),
    (e.added = "ADDED"),
    (e.deleted = "DELETED"),
    (e.renamed = "RENAMED")
})(nr || (nr = {}))
var Ir
;(function (e) {
  e.assertEqual = (i) => i
  function t(i) {}
  e.assertIs = t
  function r(i) {
    throw new Error()
  }
  ;(e.assertNever = r),
    (e.arrayToEnum = (i) => {
      let s = {}
      for (let o of i) s[o] = o
      return s
    }),
    (e.getValidEnumValues = (i) => {
      let s = e.objectKeys(i).filter((a) => typeof i[i[a]] != "number"),
        o = {}
      for (let a of s) o[a] = i[a]
      return e.objectValues(o)
    }),
    (e.objectValues = (i) =>
      e.objectKeys(i).map(function (s) {
        return i[s]
      })),
    (e.objectKeys =
      typeof Object.keys == "function"
        ? (i) => Object.keys(i)
        : (i) => {
            let s = []
            for (let o in i)
              Object.prototype.hasOwnProperty.call(i, o) && s.push(o)
            return s
          }),
    (e.find = (i, s) => {
      for (let o of i) if (s(o)) return o
    }),
    (e.isInteger =
      typeof Number.isInteger == "function"
        ? (i) => Number.isInteger(i)
        : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i)
  function n(i, s = " | ") {
    return i.map((o) => (typeof o == "string" ? `'${o}'` : o)).join(s)
  }
  ;(e.joinValues = n),
    (e.jsonStringifyReplacer = (i, s) =>
      typeof s == "bigint" ? s.toString() : s)
})(Ir || (Ir = {}))
var RL
;(function (e) {
  e.mergeShapes = (t, r) => ({ ...t, ...r })
})(RL || (RL = {}))
var Le = Ir.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
  ]),
  Td = (e) => {
    switch (typeof e) {
      case "undefined":
        return Le.undefined
      case "string":
        return Le.string
      case "number":
        return isNaN(e) ? Le.nan : Le.number
      case "boolean":
        return Le.boolean
      case "function":
        return Le.function
      case "bigint":
        return Le.bigint
      case "symbol":
        return Le.symbol
      case "object":
        return Array.isArray(e)
          ? Le.array
          : e === null
            ? Le.null
            : e.then &&
                typeof e.then == "function" &&
                e.catch &&
                typeof e.catch == "function"
              ? Le.promise
              : typeof Map < "u" && e instanceof Map
                ? Le.map
                : typeof Set < "u" && e instanceof Set
                  ? Le.set
                  : typeof Date < "u" && e instanceof Date
                    ? Le.date
                    : Le.object
      default:
        return Le.unknown
    }
  },
  Ce = Ir.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
  ]),
  j1e = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:"),
  xa = class e extends Error {
    get errors() {
      return this.issues
    }
    constructor(t) {
      super(),
        (this.issues = []),
        (this.addIssue = (n) => {
          this.issues = [...this.issues, n]
        }),
        (this.addIssues = (n = []) => {
          this.issues = [...this.issues, ...n]
        })
      let r = new.target.prototype
      Object.setPrototypeOf
        ? Object.setPrototypeOf(this, r)
        : (this.__proto__ = r),
        (this.name = "ZodError"),
        (this.issues = t)
    }
    format(t) {
      let r =
          t ||
          function (s) {
            return s.message
          },
        n = { _errors: [] },
        i = (s) => {
          for (let o of s.issues)
            if (o.code === "invalid_union") o.unionErrors.map(i)
            else if (o.code === "invalid_return_type") i(o.returnTypeError)
            else if (o.code === "invalid_arguments") i(o.argumentsError)
            else if (o.path.length === 0) n._errors.push(r(o))
            else {
              let a = n,
                l = 0
              for (; l < o.path.length; ) {
                let c = o.path[l]
                l === o.path.length - 1
                  ? ((a[c] = a[c] || { _errors: [] }), a[c]._errors.push(r(o)))
                  : (a[c] = a[c] || { _errors: [] }),
                  (a = a[c]),
                  l++
              }
            }
        }
      return i(this), n
    }
    static assert(t) {
      if (!(t instanceof e)) throw new Error(`Not a ZodError: ${t}`)
    }
    toString() {
      return this.message
    }
    get message() {
      return JSON.stringify(this.issues, Ir.jsonStringifyReplacer, 2)
    }
    get isEmpty() {
      return this.issues.length === 0
    }
    flatten(t = (r) => r.message) {
      let r = {},
        n = []
      for (let i of this.issues)
        i.path.length > 0
          ? ((r[i.path[0]] = r[i.path[0]] || []), r[i.path[0]].push(t(i)))
          : n.push(t(i))
      return { formErrors: n, fieldErrors: r }
    }
    get formErrors() {
      return this.flatten()
    }
  }
xa.create = (e) => new xa(e)
var FA = (e, t) => {
    let r
    switch (e.code) {
      case Ce.invalid_type:
        e.received === Le.undefined
          ? (r = "Required")
          : (r = `Expected ${e.expected}, received ${e.received}`)
        break
      case Ce.invalid_literal:
        r = `Invalid literal value, expected ${JSON.stringify(e.expected, Ir.jsonStringifyReplacer)}`
        break
      case Ce.unrecognized_keys:
        r = `Unrecognized key(s) in object: ${Ir.joinValues(e.keys, ", ")}`
        break
      case Ce.invalid_union:
        r = "Invalid input"
        break
      case Ce.invalid_union_discriminator:
        r = `Invalid discriminator value. Expected ${Ir.joinValues(e.options)}`
        break
      case Ce.invalid_enum_value:
        r = `Invalid enum value. Expected ${Ir.joinValues(e.options)}, received '${e.received}'`
        break
      case Ce.invalid_arguments:
        r = "Invalid function arguments"
        break
      case Ce.invalid_return_type:
        r = "Invalid function return type"
        break
      case Ce.invalid_date:
        r = "Invalid date"
        break
      case Ce.invalid_string:
        typeof e.validation == "object"
          ? "includes" in e.validation
            ? ((r = `Invalid input: must include "${e.validation.includes}"`),
              typeof e.validation.position == "number" &&
                (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`))
            : "startsWith" in e.validation
              ? (r = `Invalid input: must start with "${e.validation.startsWith}"`)
              : "endsWith" in e.validation
                ? (r = `Invalid input: must end with "${e.validation.endsWith}"`)
                : Ir.assertNever(e.validation)
          : e.validation !== "regex"
            ? (r = `Invalid ${e.validation}`)
            : (r = "Invalid")
        break
      case Ce.too_small:
        e.type === "array"
          ? (r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)`)
          : e.type === "string"
            ? (r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)`)
            : e.type === "number"
              ? (r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}`)
              : e.type === "date"
                ? (r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}`)
                : (r = "Invalid input")
        break
      case Ce.too_big:
        e.type === "array"
          ? (r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)`)
          : e.type === "string"
            ? (r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)`)
            : e.type === "number"
              ? (r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}`)
              : e.type === "bigint"
                ? (r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}`)
                : e.type === "date"
                  ? (r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}`)
                  : (r = "Invalid input")
        break
      case Ce.custom:
        r = "Invalid input"
        break
      case Ce.invalid_intersection_types:
        r = "Intersection results could not be merged"
        break
      case Ce.not_multiple_of:
        r = `Number must be a multiple of ${e.multipleOf}`
        break
      case Ce.not_finite:
        r = "Number must be finite"
        break
      default:
        ;(r = t.defaultError), Ir.assertNever(e)
    }
    return { message: r }
  },
  jK = FA
function Z1e(e) {
  jK = e
}
function pI() {
  return jK
}
var mI = (e) => {
    let { data: t, path: r, errorMaps: n, issueData: i } = e,
      s = [...r, ...(i.path || [])],
      o = { ...i, path: s }
    if (i.message !== undefined) return { ...i, path: s, message: i.message }
    let a = "",
      l = n
        .filter((c) => !!c)
        .slice()
        .reverse()
    for (let c of l) a = c(o, { data: t, defaultError: a }).message
    return { ...i, path: s, message: a }
  },
  X1e = []
function ke(e, t) {
  let r = pI(),
    n = mI({
      issueData: t,
      data: e.data,
      path: e.path,
      errorMaps: [
        e.common.contextualErrorMap,
        e.schemaErrorMap,
        r,
        r === FA ? undefined : FA,
      ].filter((i) => !!i),
    })
  e.common.issues.push(n)
}
var Vs = class e {
    constructor() {
      this.value = "valid"
    }
    dirty() {
      this.value === "valid" && (this.value = "dirty")
    }
    abort() {
      this.value !== "aborted" && (this.value = "aborted")
    }
    static mergeArray(t, r) {
      let n = []
      for (let i of r) {
        if (i.status === "aborted") return Et
        i.status === "dirty" && t.dirty(), n.push(i.value)
      }
      return { status: t.value, value: n }
    }
    static async mergeObjectAsync(t, r) {
      let n = []
      for (let i of r) {
        let s = await i.key,
          o = await i.value
        n.push({ key: s, value: o })
      }
      return e.mergeObjectSync(t, n)
    }
    static mergeObjectSync(t, r) {
      let n = {}
      for (let i of r) {
        let { key: s, value: o } = i
        if (s.status === "aborted" || o.status === "aborted") return Et
        s.status === "dirty" && t.dirty(),
          o.status === "dirty" && t.dirty(),
          s.value !== "__proto__" &&
            (typeof o.value < "u" || i.alwaysSet) &&
            (n[s.value] = o.value)
      }
      return { status: t.value, value: n }
    }
  },
  Et = Object.freeze({ status: "aborted" }),
  MA = (e) => ({ status: "dirty", value: e }),
  mo = (e) => ({ status: "valid", value: e }),
  DL = (e) => e.status === "aborted",
  TL = (e) => e.status === "dirty",
  Vg = (e) => e.status === "valid",
  mb = (e) => typeof Promise < "u" && e instanceof Promise
function AI(e, t, r, n) {
  if (r === "a" && !n)
    throw new TypeError("Private accessor was defined without a getter")
  if (typeof t == "function" ? e !== t || !n : !t.has(e))
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it",
    )
  return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e)
}
function ZK(e, t, r, n, i) {
  if (n === "m") throw new TypeError("Private method is not writable")
  if (n === "a" && !i)
    throw new TypeError("Private accessor was defined without a setter")
  if (typeof t == "function" ? e !== t || !i : !t.has(e))
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it",
    )
  return n === "a" ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
}
var Je
;(function (e) {
  ;(e.errToObj = (t) => (typeof t == "string" ? { message: t } : t || {})),
    (e.toString = (t) => (typeof t == "string" ? t : t?.message))
})(Je || (Je = {}))
var gb,
  pb,
  Cl = class {
    constructor(t, r, n, i) {
      ;(this._cachedPath = []),
        (this.parent = t),
        (this.data = r),
        (this._path = n),
        (this._key = i)
    }
    get path() {
      return (
        this._cachedPath.length ||
          (this._key instanceof Array
            ? this._cachedPath.push(...this._path, ...this._key)
            : this._cachedPath.push(...this._path, this._key)),
        this._cachedPath
      )
    }
  },
  zK = (e, t) => {
    if (Vg(t)) return { success: true, data: t.value }
    if (!e.common.issues.length)
      throw new Error("Validation failed but no issues detected.")
    return {
      success: false,
      get error() {
        if (this._error) return this._error
        let r = new xa(e.common.issues)
        return (this._error = r), this._error
      },
    }
  }
function Vt(e) {
  if (!e) return {}
  let {
    errorMap: t,
    invalid_type_error: r,
    required_error: n,
    description: i,
  } = e
  if (t && (r || n))
    throw new Error(
      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`,
    )
  return t
    ? { errorMap: t, description: i }
    : {
        errorMap: (o, a) => {
          var l, c
          let { message: u } = e
          return o.code === "invalid_enum_value"
            ? { message: u ?? a.defaultError }
            : typeof a.data > "u"
              ? {
                  message:
                    (l = u ?? n) !== null && l !== undefined ? l : a.defaultError,
                }
              : o.code !== "invalid_type"
                ? { message: a.defaultError }
                : {
                    message:
                      (c = u ?? r) !== null && c !== undefined
                        ? c
                        : a.defaultError,
                  }
        },
        description: i,
      }
}
var Ht = class {
    get description() {
      return this._def.description
    }
    _getType(t) {
      return Td(t.data)
    }
    _getOrReturnCtx(t, r) {
      return (
        r || {
          common: t.parent.common,
          data: t.data,
          parsedType: Td(t.data),
          schemaErrorMap: this._def.errorMap,
          path: t.path,
          parent: t.parent,
        }
      )
    }
    _processInputParams(t) {
      return {
        status: new Vs(),
        ctx: {
          common: t.parent.common,
          data: t.data,
          parsedType: Td(t.data),
          schemaErrorMap: this._def.errorMap,
          path: t.path,
          parent: t.parent,
        },
      }
    }
    _parseSync(t) {
      let r = this._parse(t)
      if (mb(r)) throw new Error("Synchronous parse encountered promise.")
      return r
    }
    _parseAsync(t) {
      let r = this._parse(t)
      return Promise.resolve(r)
    }
    parse(t, r) {
      let n = this.safeParse(t, r)
      if (n.success) return n.data
      throw n.error
    }
    safeParse(t, r) {
      var n
      let i = {
          common: {
            issues: [],
            async: (n = r?.async) !== null && n !== undefined ? n : false,
            contextualErrorMap: r?.errorMap,
          },
          path: r?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data: t,
          parsedType: Td(t),
        },
        s = this._parseSync({ data: t, path: i.path, parent: i })
      return zK(i, s)
    }
    "~validate"(t) {
      var r, n
      let i = {
        common: { issues: [], async: !!this["~standard"].async },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: Td(t),
      }
      if (!this["~standard"].async)
        try {
          let s = this._parseSync({ data: t, path: [], parent: i })
          return Vg(s) ? { value: s.value } : { issues: i.common.issues }
        } catch (s) {
          !(
            (n =
              (r = s?.message) === null || r === undefined
                ? undefined
                : r.toLowerCase()) === null || n === undefined
          ) &&
            n.includes("encountered") &&
            (this["~standard"].async = true),
            (i.common = { issues: [], async: true })
        }
      return this._parseAsync({ data: t, path: [], parent: i }).then((s) =>
        Vg(s) ? { value: s.value } : { issues: i.common.issues },
      )
    }
    async parseAsync(t, r) {
      let n = await this.safeParseAsync(t, r)
      if (n.success) return n.data
      throw n.error
    }
    async safeParseAsync(t, r) {
      let n = {
          common: { issues: [], contextualErrorMap: r?.errorMap, async: true },
          path: r?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data: t,
          parsedType: Td(t),
        },
        i = this._parse({ data: t, path: n.path, parent: n }),
        s = await (mb(i) ? i : Promise.resolve(i))
      return zK(n, s)
    }
    refine(t, r) {
      let n = (i) =>
        typeof r == "string" || typeof r > "u"
          ? { message: r }
          : typeof r == "function"
            ? r(i)
            : r
      return this._refinement((i, s) => {
        let o = t(i),
          a = () => s.addIssue({ code: Ce.custom, ...n(i) })
        return typeof Promise < "u" && o instanceof Promise
          ? o.then((l) => (l ? true : (a(), false)))
          : o
            ? true
            : (a(), false)
      })
    }
    refinement(t, r) {
      return this._refinement((n, i) =>
        t(n) ? true : (i.addIssue(typeof r == "function" ? r(n, i) : r), false),
      )
    }
    _refinement(t) {
      return new wa({
        schema: this,
        typeName: yt.ZodEffects,
        effect: { type: "refinement", refinement: t },
      })
    }
    superRefine(t) {
      return this._refinement(t)
    }
    constructor(t) {
      ;(this.spa = this.safeParseAsync),
        (this._def = t),
        (this.parse = this.parse.bind(this)),
        (this.safeParse = this.safeParse.bind(this)),
        (this.parseAsync = this.parseAsync.bind(this)),
        (this.safeParseAsync = this.safeParseAsync.bind(this)),
        (this.spa = this.spa.bind(this)),
        (this.refine = this.refine.bind(this)),
        (this.refinement = this.refinement.bind(this)),
        (this.superRefine = this.superRefine.bind(this)),
        (this.optional = this.optional.bind(this)),
        (this.nullable = this.nullable.bind(this)),
        (this.nullish = this.nullish.bind(this)),
        (this.array = this.array.bind(this)),
        (this.promise = this.promise.bind(this)),
        (this.or = this.or.bind(this)),
        (this.and = this.and.bind(this)),
        (this.transform = this.transform.bind(this)),
        (this.brand = this.brand.bind(this)),
        (this.default = this.default.bind(this)),
        (this.catch = this.catch.bind(this)),
        (this.describe = this.describe.bind(this)),
        (this.pipe = this.pipe.bind(this)),
        (this.readonly = this.readonly.bind(this)),
        (this.isNullable = this.isNullable.bind(this)),
        (this.isOptional = this.isOptional.bind(this)),
        (this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: (r) => this["~validate"](r),
        })
    }
    optional() {
      return vl.create(this, this._def)
    }
    nullable() {
      return gu.create(this, this._def)
    }
    nullish() {
      return this.nullable().optional()
    }
    array() {
      return Md.create(this)
    }
    promise() {
      return jf.create(this, this._def)
    }
    or(t) {
      return zg.create([this, t], this._def)
    }
    and(t) {
      return Jg.create(this, t, this._def)
    }
    transform(t) {
      return new wa({
        ...Vt(this._def),
        schema: this,
        typeName: yt.ZodEffects,
        effect: { type: "transform", transform: t },
      })
    }
    default(t) {
      let r = typeof t == "function" ? t : () => t
      return new tp({
        ...Vt(this._def),
        innerType: this,
        defaultValue: r,
        typeName: yt.ZodDefault,
      })
    }
    brand() {
      return new Ab({ typeName: yt.ZodBranded, type: this, ...Vt(this._def) })
    }
    catch(t) {
      let r = typeof t == "function" ? t : () => t
      return new rp({
        ...Vt(this._def),
        innerType: this,
        catchValue: r,
        typeName: yt.ZodCatch,
      })
    }
    describe(t) {
      let r = this.constructor
      return new r({ ...this._def, description: t })
    }
    pipe(t) {
      return yb.create(this, t)
    }
    readonly() {
      return np.create(this)
    }
    isOptional() {
      return this.safeParse(undefined).success
    }
    isNullable() {
      return this.safeParse(null).success
    }
  },
  eQe = /^c[^\s-]{8,}$/i,
  tQe = /^[0-9a-z]+$/,
  rQe = /^[0-9A-HJKMNP-TV-Z]{26}$/i,
  nQe =
    /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  iQe = /^[a-z0-9_-]{21}$/i,
  sQe = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
  oQe =
    /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
  aQe =
    /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
  lQe = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
  BL,
  cQe =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  uQe =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  dQe =
    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
  fQe =
    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  hQe = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  gQe =
    /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  XK =
    "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
  pQe = new RegExp(`^${XK}$`)
function ez(e) {
  let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d"
  return (
    e.precision
      ? (t = `${t}\\.\\d{${e.precision}}`)
      : e.precision == null && (t = `${t}(\\.\\d+)?`),
    t
  )
}
function mQe(e) {
  return new RegExp(`^${ez(e)}$`)
}
function tz(e) {
  let t = `${XK}T${ez(e)}`,
    r = []
  return (
    r.push(e.local ? "Z?" : "Z"),
    e.offset && r.push("([+-]\\d{2}:?\\d{2})"),
    (t = `${t}(${r.join("|")})`),
    new RegExp(`^${t}$`)
  )
}
function AQe(e, t) {
  return !!(
    ((t === "v4" || !t) && cQe.test(e)) ||
    ((t === "v6" || !t) && dQe.test(e))
  )
}
function yQe(e, t) {
  if (!sQe.test(e)) return false
  try {
    let [r] = e.split("."),
      n = r
        .replace(/-/g, "+")
        .replace(/_/g, "/")
        .padEnd(r.length + ((4 - (r.length % 4)) % 4), "="),
      i = JSON.parse(atob(n))
    return !(
      typeof i != "object" ||
      i === null ||
      !i.typ ||
      !i.alg ||
      (t && i.alg !== t)
    )
  } catch {
    return false
  }
}
function vQe(e, t) {
  return !!(
    ((t === "v4" || !t) && uQe.test(e)) ||
    ((t === "v6" || !t) && fQe.test(e))
  )
}
var zf = class e extends Ht {
  _parse(t) {
    if (
      (this._def.coerce && (t.data = String(t.data)),
      this._getType(t) !== Le.string)
    ) {
      let s = this._getOrReturnCtx(t)
      return (
        ke(s, {
          code: Ce.invalid_type,
          expected: Le.string,
          received: s.parsedType,
        }),
        Et
      )
    }
    let n = new Vs(),
      i
    for (let s of this._def.checks)
      if (s.kind === "min")
        t.data.length < s.value &&
          ((i = this._getOrReturnCtx(t, i)),
          ke(i, {
            code: Ce.too_small,
            minimum: s.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: s.message,
          }),
          n.dirty())
      else if (s.kind === "max")
        t.data.length > s.value &&
          ((i = this._getOrReturnCtx(t, i)),
          ke(i, {
            code: Ce.too_big,
            maximum: s.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: s.message,
          }),
          n.dirty())
      else if (s.kind === "length") {
        let o = t.data.length > s.value,
          a = t.data.length < s.value
        ;(o || a) &&
          ((i = this._getOrReturnCtx(t, i)),
          o
            ? ke(i, {
                code: Ce.too_big,
                maximum: s.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: s.message,
              })
            : a &&
              ke(i, {
                code: Ce.too_small,
                minimum: s.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: s.message,
              }),
          n.dirty())
      } else if (s.kind === "email")
        aQe.test(t.data) ||
          ((i = this._getOrReturnCtx(t, i)),
          ke(i, {
            validation: "email",
            code: Ce.invalid_string,
            message: s.message,
          }),
          n.dirty())
      else if (s.kind === "emoji")
        BL || (BL = new RegExp(lQe, "u")),
          BL.test(t.data) ||
            ((i = this._getOrReturnCtx(t, i)),
            ke(i, {
              validation: "emoji",
              code: Ce.invalid_string,
              message: s.message,
            }),
            n.dirty())
      else if (s.kind === "uuid")
        nQe.test(t.data) ||
          ((i = this._getOrReturnCtx(t, i)),
          ke(i, {
            validation: "uuid",
            code: Ce.invalid_string,
            message: s.message,
          }),
          n.dirty())
      else if (s.kind === "nanoid")
        iQe.test(t.data) ||
          ((i = this._getOrReturnCtx(t, i)),
          ke(i, {
            validation: "nanoid",
            code: Ce.invalid_string,
            message: s.message,
          }),
          n.dirty())
      else if (s.kind === "cuid")
        eQe.test(t.data) ||
          ((i = this._getOrReturnCtx(t, i)),
          ke(i, {
            validation: "cuid",
            code: Ce.invalid_string,
            message: s.message,
          }),
          n.dirty())
      else if (s.kind === "cuid2")
        tQe.test(t.data) ||
          ((i = this._getOrReturnCtx(t, i)),
          ke(i, {
            validation: "cuid2",
            code: Ce.invalid_string,
            message: s.message,
          }),
          n.dirty())
      else if (s.kind === "ulid")
        rQe.test(t.data) ||
          ((i = this._getOrReturnCtx(t, i)),
          ke(i, {
            validation: "ulid",
            code: Ce.invalid_string,
            message: s.message,
          }),
          n.dirty())
      else if (s.kind === "url")
        try {
          new URL(t.data)
        } catch {
          ;(i = this._getOrReturnCtx(t, i)),
            ke(i, {
              validation: "url",
              code: Ce.invalid_string,
              message: s.message,
            }),
            n.dirty()
        }
      else
        s.kind === "regex"
          ? ((s.regex.lastIndex = 0),
            s.regex.test(t.data) ||
              ((i = this._getOrReturnCtx(t, i)),
              ke(i, {
                validation: "regex",
                code: Ce.invalid_string,
                message: s.message,
              }),
              n.dirty()))
          : s.kind === "trim"
            ? (t.data = t.data.trim())
            : s.kind === "includes"
              ? t.data.includes(s.value, s.position) ||
                ((i = this._getOrReturnCtx(t, i)),
                ke(i, {
                  code: Ce.invalid_string,
                  validation: { includes: s.value, position: s.position },
                  message: s.message,
                }),
                n.dirty())
              : s.kind === "toLowerCase"
                ? (t.data = t.data.toLowerCase())
                : s.kind === "toUpperCase"
                  ? (t.data = t.data.toUpperCase())
                  : s.kind === "startsWith"
                    ? t.data.startsWith(s.value) ||
                      ((i = this._getOrReturnCtx(t, i)),
                      ke(i, {
                        code: Ce.invalid_string,
                        validation: { startsWith: s.value },
                        message: s.message,
                      }),
                      n.dirty())
                    : s.kind === "endsWith"
                      ? t.data.endsWith(s.value) ||
                        ((i = this._getOrReturnCtx(t, i)),
                        ke(i, {
                          code: Ce.invalid_string,
                          validation: { endsWith: s.value },
                          message: s.message,
                        }),
                        n.dirty())
                      : s.kind === "datetime"
                        ? tz(s).test(t.data) ||
                          ((i = this._getOrReturnCtx(t, i)),
                          ke(i, {
                            code: Ce.invalid_string,
                            validation: "datetime",
                            message: s.message,
                          }),
                          n.dirty())
                        : s.kind === "date"
                          ? pQe.test(t.data) ||
                            ((i = this._getOrReturnCtx(t, i)),
                            ke(i, {
                              code: Ce.invalid_string,
                              validation: "date",
                              message: s.message,
                            }),
                            n.dirty())
                          : s.kind === "time"
                            ? mQe(s).test(t.data) ||
                              ((i = this._getOrReturnCtx(t, i)),
                              ke(i, {
                                code: Ce.invalid_string,
                                validation: "time",
                                message: s.message,
                              }),
                              n.dirty())
                            : s.kind === "duration"
                              ? oQe.test(t.data) ||
                                ((i = this._getOrReturnCtx(t, i)),
                                ke(i, {
                                  validation: "duration",
                                  code: Ce.invalid_string,
                                  message: s.message,
                                }),
                                n.dirty())
                              : s.kind === "ip"
                                ? AQe(t.data, s.version) ||
                                  ((i = this._getOrReturnCtx(t, i)),
                                  ke(i, {
                                    validation: "ip",
                                    code: Ce.invalid_string,
                                    message: s.message,
                                  }),
                                  n.dirty())
                                : s.kind === "jwt"
                                  ? yQe(t.data, s.alg) ||
                                    ((i = this._getOrReturnCtx(t, i)),
                                    ke(i, {
                                      validation: "jwt",
                                      code: Ce.invalid_string,
                                      message: s.message,
                                    }),
                                    n.dirty())
                                  : s.kind === "cidr"
                                    ? vQe(t.data, s.version) ||
                                      ((i = this._getOrReturnCtx(t, i)),
                                      ke(i, {
                                        validation: "cidr",
                                        code: Ce.invalid_string,
                                        message: s.message,
                                      }),
                                      n.dirty())
                                    : s.kind === "base64"
                                      ? hQe.test(t.data) ||
                                        ((i = this._getOrReturnCtx(t, i)),
                                        ke(i, {
                                          validation: "base64",
                                          code: Ce.invalid_string,
                                          message: s.message,
                                        }),
                                        n.dirty())
                                      : s.kind === "base64url"
                                        ? gQe.test(t.data) ||
                                          ((i = this._getOrReturnCtx(t, i)),
                                          ke(i, {
                                            validation: "base64url",
                                            code: Ce.invalid_string,
                                            message: s.message,
                                          }),
                                          n.dirty())
                                        : Ir.assertNever(s)
    return { status: n.value, value: t.data }
  }
  _regex(t, r, n) {
    return this.refinement((i) => t.test(i), {
      validation: r,
      code: Ce.invalid_string,
      ...Je.errToObj(n),
    })
  }
  _addCheck(t) {
    return new e({ ...this._def, checks: [...this._def.checks, t] })
  }
  email(t) {
    return this._addCheck({ kind: "email", ...Je.errToObj(t) })
  }
  url(t) {
    return this._addCheck({ kind: "url", ...Je.errToObj(t) })
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...Je.errToObj(t) })
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...Je.errToObj(t) })
  }
  nanoid(t) {
    return this._addCheck({ kind: "nanoid", ...Je.errToObj(t) })
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...Je.errToObj(t) })
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...Je.errToObj(t) })
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...Je.errToObj(t) })
  }
  base64(t) {
    return this._addCheck({ kind: "base64", ...Je.errToObj(t) })
  }
  base64url(t) {
    return this._addCheck({ kind: "base64url", ...Je.errToObj(t) })
  }
  jwt(t) {
    return this._addCheck({ kind: "jwt", ...Je.errToObj(t) })
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...Je.errToObj(t) })
  }
  cidr(t) {
    return this._addCheck({ kind: "cidr", ...Je.errToObj(t) })
  }
  datetime(t) {
    var r, n
    return typeof t == "string"
      ? this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: t,
        })
      : this._addCheck({
          kind: "datetime",
          precision: typeof t?.precision > "u" ? null : t?.precision,
          offset: (r = t?.offset) !== null && r !== undefined ? r : false,
          local: (n = t?.local) !== null && n !== undefined ? n : false,
          ...Je.errToObj(t?.message),
        })
  }
  date(t) {
    return this._addCheck({ kind: "date", message: t })
  }
  time(t) {
    return typeof t == "string"
      ? this._addCheck({ kind: "time", precision: null, message: t })
      : this._addCheck({
          kind: "time",
          precision: typeof t?.precision > "u" ? null : t?.precision,
          ...Je.errToObj(t?.message),
        })
  }
  duration(t) {
    return this._addCheck({ kind: "duration", ...Je.errToObj(t) })
  }
  regex(t, r) {
    return this._addCheck({ kind: "regex", regex: t, ...Je.errToObj(r) })
  }
  includes(t, r) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: r?.position,
      ...Je.errToObj(r?.message),
    })
  }
  startsWith(t, r) {
    return this._addCheck({ kind: "startsWith", value: t, ...Je.errToObj(r) })
  }
  endsWith(t, r) {
    return this._addCheck({ kind: "endsWith", value: t, ...Je.errToObj(r) })
  }
  min(t, r) {
    return this._addCheck({ kind: "min", value: t, ...Je.errToObj(r) })
  }
  max(t, r) {
    return this._addCheck({ kind: "max", value: t, ...Je.errToObj(r) })
  }
  length(t, r) {
    return this._addCheck({ kind: "length", value: t, ...Je.errToObj(r) })
  }
  nonempty(t) {
    return this.min(1, Je.errToObj(t))
  }
  trim() {
    return new e({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }],
    })
  }
  toLowerCase() {
    return new e({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }],
    })
  }
  toUpperCase() {
    return new e({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }],
    })
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime")
  }
  get isDate() {
    return !!this._def.checks.find((t) => t.kind === "date")
  }
  get isTime() {
    return !!this._def.checks.find((t) => t.kind === "time")
  }
  get isDuration() {
    return !!this._def.checks.find((t) => t.kind === "duration")
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email")
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url")
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji")
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid")
  }
  get isNANOID() {
    return !!this._def.checks.find((t) => t.kind === "nanoid")
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid")
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2")
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid")
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip")
  }
  get isCIDR() {
    return !!this._def.checks.find((t) => t.kind === "cidr")
  }
  get isBase64() {
    return !!this._def.checks.find((t) => t.kind === "base64")
  }
  get isBase64url() {
    return !!this._def.checks.find((t) => t.kind === "base64url")
  }
  get minLength() {
    let t = null
    for (let r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value)
    return t
  }
  get maxLength() {
    let t = null
    for (let r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value)
    return t
  }
}
zf.create = (e) => {
  var t
  return new zf({
    checks: [],
    typeName: yt.ZodString,
    coerce: (t = e?.coerce) !== null && t !== undefined ? t : false,
    ...Vt(e),
  })
}
function CQe(e, t) {
  let r = (e.toString().split(".")[1] || "").length,
    n = (t.toString().split(".")[1] || "").length,
    i = r > n ? r : n,
    s = parseInt(e.toFixed(i).replace(".", "")),
    o = parseInt(t.toFixed(i).replace(".", ""))
  return (s % o) / Math.pow(10, i)
}
var Hg = class e extends Ht {
  constructor() {
    super(...arguments),
      (this.min = this.gte),
      (this.max = this.lte),
      (this.step = this.multipleOf)
  }
  _parse(t) {
    if (
      (this._def.coerce && (t.data = Number(t.data)),
      this._getType(t) !== Le.number)
    ) {
      let s = this._getOrReturnCtx(t)
      return (
        ke(s, {
          code: Ce.invalid_type,
          expected: Le.number,
          received: s.parsedType,
        }),
        Et
      )
    }
    let n,
      i = new Vs()
    for (let s of this._def.checks)
      s.kind === "int"
        ? Ir.isInteger(t.data) ||
          ((n = this._getOrReturnCtx(t, n)),
          ke(n, {
            code: Ce.invalid_type,
            expected: "integer",
            received: "float",
            message: s.message,
          }),
          i.dirty())
        : s.kind === "min"
          ? (s.inclusive ? t.data < s.value : t.data <= s.value) &&
            ((n = this._getOrReturnCtx(t, n)),
            ke(n, {
              code: Ce.too_small,
              minimum: s.value,
              type: "number",
              inclusive: s.inclusive,
              exact: false,
              message: s.message,
            }),
            i.dirty())
          : s.kind === "max"
            ? (s.inclusive ? t.data > s.value : t.data >= s.value) &&
              ((n = this._getOrReturnCtx(t, n)),
              ke(n, {
                code: Ce.too_big,
                maximum: s.value,
                type: "number",
                inclusive: s.inclusive,
                exact: false,
                message: s.message,
              }),
              i.dirty())
            : s.kind === "multipleOf"
              ? CQe(t.data, s.value) !== 0 &&
                ((n = this._getOrReturnCtx(t, n)),
                ke(n, {
                  code: Ce.not_multiple_of,
                  multipleOf: s.value,
                  message: s.message,
                }),
                i.dirty())
              : s.kind === "finite"
                ? Number.isFinite(t.data) ||
                  ((n = this._getOrReturnCtx(t, n)),
                  ke(n, { code: Ce.not_finite, message: s.message }),
                  i.dirty())
                : Ir.assertNever(s)
    return { status: i.value, value: t.data }
  }
  gte(t, r) {
    return this.setLimit("min", t, true, Je.toString(r))
  }
  gt(t, r) {
    return this.setLimit("min", t, false, Je.toString(r))
  }
  lte(t, r) {
    return this.setLimit("max", t, true, Je.toString(r))
  }
  lt(t, r) {
    return this.setLimit("max", t, false, Je.toString(r))
  }
  setLimit(t, r, n, i) {
    return new e({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: t, value: r, inclusive: n, message: Je.toString(i) },
      ],
    })
  }
  _addCheck(t) {
    return new e({ ...this._def, checks: [...this._def.checks, t] })
  }
  int(t) {
    return this._addCheck({ kind: "int", message: Je.toString(t) })
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: Je.toString(t),
    })
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: Je.toString(t),
    })
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: Je.toString(t),
    })
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: Je.toString(t),
    })
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Je.toString(r),
    })
  }
  finite(t) {
    return this._addCheck({ kind: "finite", message: Je.toString(t) })
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: Je.toString(t),
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: Je.toString(t),
    })
  }
  get minValue() {
    let t = null
    for (let r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value)
    return t
  }
  get maxValue() {
    let t = null
    for (let r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value)
    return t
  }
  get isInt() {
    return !!this._def.checks.find(
      (t) =>
        t.kind === "int" || (t.kind === "multipleOf" && Ir.isInteger(t.value)),
    )
  }
  get isFinite() {
    let t = null,
      r = null
    for (let n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return true
      n.kind === "min"
        ? (r === null || n.value > r) && (r = n.value)
        : n.kind === "max" && (t === null || n.value < t) && (t = n.value)
    }
    return Number.isFinite(r) && Number.isFinite(t)
  }
}
Hg.create = (e) =>
  new Hg({
    checks: [],
    typeName: yt.ZodNumber,
    coerce: e?.coerce || false,
    ...Vt(e),
  })
var Wg = class e extends Ht {
  constructor() {
    super(...arguments), (this.min = this.gte), (this.max = this.lte)
  }
  _parse(t) {
    if (this._def.coerce)
      try {
        t.data = BigInt(t.data)
      } catch {
        return this._getInvalidInput(t)
      }
    if (this._getType(t) !== Le.bigint) return this._getInvalidInput(t)
    let n,
      i = new Vs()
    for (let s of this._def.checks)
      s.kind === "min"
        ? (s.inclusive ? t.data < s.value : t.data <= s.value) &&
          ((n = this._getOrReturnCtx(t, n)),
          ke(n, {
            code: Ce.too_small,
            type: "bigint",
            minimum: s.value,
            inclusive: s.inclusive,
            message: s.message,
          }),
          i.dirty())
        : s.kind === "max"
          ? (s.inclusive ? t.data > s.value : t.data >= s.value) &&
            ((n = this._getOrReturnCtx(t, n)),
            ke(n, {
              code: Ce.too_big,
              type: "bigint",
              maximum: s.value,
              inclusive: s.inclusive,
              message: s.message,
            }),
            i.dirty())
          : s.kind === "multipleOf"
            ? t.data % s.value !== BigInt(0) &&
              ((n = this._getOrReturnCtx(t, n)),
              ke(n, {
                code: Ce.not_multiple_of,
                multipleOf: s.value,
                message: s.message,
              }),
              i.dirty())
            : Ir.assertNever(s)
    return { status: i.value, value: t.data }
  }
  _getInvalidInput(t) {
    let r = this._getOrReturnCtx(t)
    return (
      ke(r, {
        code: Ce.invalid_type,
        expected: Le.bigint,
        received: r.parsedType,
      }),
      Et
    )
  }
  gte(t, r) {
    return this.setLimit("min", t, true, Je.toString(r))
  }
  gt(t, r) {
    return this.setLimit("min", t, false, Je.toString(r))
  }
  lte(t, r) {
    return this.setLimit("max", t, true, Je.toString(r))
  }
  lt(t, r) {
    return this.setLimit("max", t, false, Je.toString(r))
  }
  setLimit(t, r, n, i) {
    return new e({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: t, value: r, inclusive: n, message: Je.toString(i) },
      ],
    })
  }
  _addCheck(t) {
    return new e({ ...this._def, checks: [...this._def.checks, t] })
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: Je.toString(t),
    })
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: Je.toString(t),
    })
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: Je.toString(t),
    })
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: Je.toString(t),
    })
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Je.toString(r),
    })
  }
  get minValue() {
    let t = null
    for (let r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value)
    return t
  }
  get maxValue() {
    let t = null
    for (let r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value)
    return t
  }
}
Wg.create = (e) => {
  var t
  return new Wg({
    checks: [],
    typeName: yt.ZodBigInt,
    coerce: (t = e?.coerce) !== null && t !== undefined ? t : false,
    ...Vt(e),
  })
}
var Gg = class extends Ht {
  _parse(t) {
    if (
      (this._def.coerce && (t.data = !!t.data), this._getType(t) !== Le.boolean)
    ) {
      let n = this._getOrReturnCtx(t)
      return (
        ke(n, {
          code: Ce.invalid_type,
          expected: Le.boolean,
          received: n.parsedType,
        }),
        Et
      )
    }
    return mo(t.data)
  }
}
Gg.create = (e) =>
  new Gg({ typeName: yt.ZodBoolean, coerce: e?.coerce || false, ...Vt(e) })
var $g = class e extends Ht {
  _parse(t) {
    if (
      (this._def.coerce && (t.data = new Date(t.data)),
      this._getType(t) !== Le.date)
    ) {
      let s = this._getOrReturnCtx(t)
      return (
        ke(s, {
          code: Ce.invalid_type,
          expected: Le.date,
          received: s.parsedType,
        }),
        Et
      )
    }
    if (isNaN(t.data.getTime())) {
      let s = this._getOrReturnCtx(t)
      return ke(s, { code: Ce.invalid_date }), Et
    }
    let n = new Vs(),
      i
    for (let s of this._def.checks)
      s.kind === "min"
        ? t.data.getTime() < s.value &&
          ((i = this._getOrReturnCtx(t, i)),
          ke(i, {
            code: Ce.too_small,
            message: s.message,
            inclusive: true,
            exact: false,
            minimum: s.value,
            type: "date",
          }),
          n.dirty())
        : s.kind === "max"
          ? t.data.getTime() > s.value &&
            ((i = this._getOrReturnCtx(t, i)),
            ke(i, {
              code: Ce.too_big,
              message: s.message,
              inclusive: true,
              exact: false,
              maximum: s.value,
              type: "date",
            }),
            n.dirty())
          : Ir.assertNever(s)
    return { status: n.value, value: new Date(t.data.getTime()) }
  }
  _addCheck(t) {
    return new e({ ...this._def, checks: [...this._def.checks, t] })
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: Je.toString(r),
    })
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: Je.toString(r),
    })
  }
  get minDate() {
    let t = null
    for (let r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value)
    return t != null ? new Date(t) : null
  }
  get maxDate() {
    let t = null
    for (let r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value)
    return t != null ? new Date(t) : null
  }
}
$g.create = (e) =>
  new $g({
    checks: [],
    coerce: e?.coerce || false,
    typeName: yt.ZodDate,
    ...Vt(e),
  })
var QA = class extends Ht {
  _parse(t) {
    if (this._getType(t) !== Le.symbol) {
      let n = this._getOrReturnCtx(t)
      return (
        ke(n, {
          code: Ce.invalid_type,
          expected: Le.symbol,
          received: n.parsedType,
        }),
        Et
      )
    }
    return mo(t.data)
  }
}
QA.create = (e) => new QA({ typeName: yt.ZodSymbol, ...Vt(e) })
var Yg = class extends Ht {
  _parse(t) {
    if (this._getType(t) !== Le.undefined) {
      let n = this._getOrReturnCtx(t)
      return (
        ke(n, {
          code: Ce.invalid_type,
          expected: Le.undefined,
          received: n.parsedType,
        }),
        Et
      )
    }
    return mo(t.data)
  }
}
Yg.create = (e) => new Yg({ typeName: yt.ZodUndefined, ...Vt(e) })
var Kg = class extends Ht {
  _parse(t) {
    if (this._getType(t) !== Le.null) {
      let n = this._getOrReturnCtx(t)
      return (
        ke(n, {
          code: Ce.invalid_type,
          expected: Le.null,
          received: n.parsedType,
        }),
        Et
      )
    }
    return mo(t.data)
  }
}
Kg.create = (e) => new Kg({ typeName: yt.ZodNull, ...Vt(e) })
var Jf = class extends Ht {
  constructor() {
    super(...arguments), (this._any = true)
  }
  _parse(t) {
    return mo(t.data)
  }
}
Jf.create = (e) => new Jf({ typeName: yt.ZodAny, ...Vt(e) })
var kd = class extends Ht {
  constructor() {
    super(...arguments), (this._unknown = true)
  }
  _parse(t) {
    return mo(t.data)
  }
}
kd.create = (e) => new kd({ typeName: yt.ZodUnknown, ...Vt(e) })
var pc = class extends Ht {
  _parse(t) {
    let r = this._getOrReturnCtx(t)
    return (
      ke(r, {
        code: Ce.invalid_type,
        expected: Le.never,
        received: r.parsedType,
      }),
      Et
    )
  }
}
pc.create = (e) => new pc({ typeName: yt.ZodNever, ...Vt(e) })
var NA = class extends Ht {
  _parse(t) {
    if (this._getType(t) !== Le.undefined) {
      let n = this._getOrReturnCtx(t)
      return (
        ke(n, {
          code: Ce.invalid_type,
          expected: Le.void,
          received: n.parsedType,
        }),
        Et
      )
    }
    return mo(t.data)
  }
}
NA.create = (e) => new NA({ typeName: yt.ZodVoid, ...Vt(e) })
var Md = class e extends Ht {
  _parse(t) {
    let { ctx: r, status: n } = this._processInputParams(t),
      i = this._def
    if (r.parsedType !== Le.array)
      return (
        ke(r, {
          code: Ce.invalid_type,
          expected: Le.array,
          received: r.parsedType,
        }),
        Et
      )
    if (i.exactLength !== null) {
      let o = r.data.length > i.exactLength.value,
        a = r.data.length < i.exactLength.value
      ;(o || a) &&
        (ke(r, {
          code: o ? Ce.too_big : Ce.too_small,
          minimum: a ? i.exactLength.value : undefined,
          maximum: o ? i.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: i.exactLength.message,
        }),
        n.dirty())
    }
    if (
      (i.minLength !== null &&
        r.data.length < i.minLength.value &&
        (ke(r, {
          code: Ce.too_small,
          minimum: i.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: i.minLength.message,
        }),
        n.dirty()),
      i.maxLength !== null &&
        r.data.length > i.maxLength.value &&
        (ke(r, {
          code: Ce.too_big,
          maximum: i.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: i.maxLength.message,
        }),
        n.dirty()),
      r.common.async)
    )
      return Promise.all(
        [...r.data].map((o, a) => i.type._parseAsync(new Cl(r, o, r.path, a))),
      ).then((o) => Vs.mergeArray(n, o))
    let s = [...r.data].map((o, a) =>
      i.type._parseSync(new Cl(r, o, r.path, a)),
    )
    return Vs.mergeArray(n, s)
  }
  get element() {
    return this._def.type
  }
  min(t, r) {
    return new e({
      ...this._def,
      minLength: { value: t, message: Je.toString(r) },
    })
  }
  max(t, r) {
    return new e({
      ...this._def,
      maxLength: { value: t, message: Je.toString(r) },
    })
  }
  length(t, r) {
    return new e({
      ...this._def,
      exactLength: { value: t, message: Je.toString(r) },
    })
  }
  nonempty(t) {
    return this.min(1, t)
  }
}
Md.create = (e, t) =>
  new Md({
    type: e,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: yt.ZodArray,
    ...Vt(t),
  })
function kA(e) {
  if (e instanceof Ho) {
    let t = {}
    for (let r in e.shape) {
      let n = e.shape[r]
      t[r] = vl.create(kA(n))
    }
    return new Ho({ ...e._def, shape: () => t })
  } else
    return e instanceof Md
      ? new Md({ ...e._def, type: kA(e.element) })
      : e instanceof vl
        ? vl.create(kA(e.unwrap()))
        : e instanceof gu
          ? gu.create(kA(e.unwrap()))
          : e instanceof hu
            ? hu.create(e.items.map((t) => kA(t)))
            : e
}
var Ho = class e extends Ht {
  constructor() {
    super(...arguments),
      (this._cached = null),
      (this.nonstrict = this.passthrough),
      (this.augment = this.extend)
  }
  _getCached() {
    if (this._cached !== null) return this._cached
    let t = this._def.shape(),
      r = Ir.objectKeys(t)
    return (this._cached = { shape: t, keys: r })
  }
  _parse(t) {
    if (this._getType(t) !== Le.object) {
      let c = this._getOrReturnCtx(t)
      return (
        ke(c, {
          code: Ce.invalid_type,
          expected: Le.object,
          received: c.parsedType,
        }),
        Et
      )
    }
    let { status: n, ctx: i } = this._processInputParams(t),
      { shape: s, keys: o } = this._getCached(),
      a = []
    if (
      !(this._def.catchall instanceof pc && this._def.unknownKeys === "strip")
    )
      for (let c in i.data) o.includes(c) || a.push(c)
    let l = []
    for (let c of o) {
      let u = s[c],
        f = i.data[c]
      l.push({
        key: { status: "valid", value: c },
        value: u._parse(new Cl(i, f, i.path, c)),
        alwaysSet: c in i.data,
      })
    }
    if (this._def.catchall instanceof pc) {
      let c = this._def.unknownKeys
      if (c === "passthrough")
        for (let u of a)
          l.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: i.data[u] },
          })
      else if (c === "strict")
        a.length > 0 &&
          (ke(i, { code: Ce.unrecognized_keys, keys: a }), n.dirty())
      else if (c !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.")
    } else {
      let c = this._def.catchall
      for (let u of a) {
        let f = i.data[u]
        l.push({
          key: { status: "valid", value: u },
          value: c._parse(new Cl(i, f, i.path, u)),
          alwaysSet: u in i.data,
        })
      }
    }
    return i.common.async
      ? Promise.resolve()
          .then(async () => {
            let c = []
            for (let u of l) {
              let f = await u.key,
                p = await u.value
              c.push({ key: f, value: p, alwaysSet: u.alwaysSet })
            }
            return c
          })
          .then((c) => Vs.mergeObjectSync(n, c))
      : Vs.mergeObjectSync(n, l)
  }
  get shape() {
    return this._def.shape()
  }
  strict(t) {
    return (
      Je.errToObj,
      new e({
        ...this._def,
        unknownKeys: "strict",
        ...(t !== undefined
          ? {
              errorMap: (r, n) => {
                var i, s, o, a
                let l =
                  (o =
                    (s = (i = this._def).errorMap) === null || s === undefined
                      ? undefined
                      : s.call(i, r, n).message) !== null && o !== undefined
                    ? o
                    : n.defaultError
                return r.code === "unrecognized_keys"
                  ? {
                      message:
                        (a = Je.errToObj(t).message) !== null && a !== undefined
                          ? a
                          : l,
                    }
                  : { message: l }
              },
            }
          : {}),
      })
    )
  }
  strip() {
    return new e({ ...this._def, unknownKeys: "strip" })
  }
  passthrough() {
    return new e({ ...this._def, unknownKeys: "passthrough" })
  }
  extend(t) {
    return new e({
      ...this._def,
      shape: () => ({ ...this._def.shape(), ...t }),
    })
  }
  merge(t) {
    return new e({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({ ...this._def.shape(), ...t._def.shape() }),
      typeName: yt.ZodObject,
    })
  }
  setKey(t, r) {
    return this.augment({ [t]: r })
  }
  catchall(t) {
    return new e({ ...this._def, catchall: t })
  }
  pick(t) {
    let r = {}
    return (
      Ir.objectKeys(t).forEach((n) => {
        t[n] && this.shape[n] && (r[n] = this.shape[n])
      }),
      new e({ ...this._def, shape: () => r })
    )
  }
  omit(t) {
    let r = {}
    return (
      Ir.objectKeys(this.shape).forEach((n) => {
        t[n] || (r[n] = this.shape[n])
      }),
      new e({ ...this._def, shape: () => r })
    )
  }
  deepPartial() {
    return kA(this)
  }
  partial(t) {
    let r = {}
    return (
      Ir.objectKeys(this.shape).forEach((n) => {
        let i = this.shape[n]
        t && !t[n] ? (r[n] = i) : (r[n] = i.optional())
      }),
      new e({ ...this._def, shape: () => r })
    )
  }
  required(t) {
    let r = {}
    return (
      Ir.objectKeys(this.shape).forEach((n) => {
        if (t && !t[n]) r[n] = this.shape[n]
        else {
          let s = this.shape[n]
          for (; s instanceof vl; ) s = s._def.innerType
          r[n] = s
        }
      }),
      new e({ ...this._def, shape: () => r })
    )
  }
  keyof() {
    return rz(Ir.objectKeys(this.shape))
  }
}
Ho.create = (e, t) =>
  new Ho({
    shape: () => e,
    unknownKeys: "strip",
    catchall: pc.create(),
    typeName: yt.ZodObject,
    ...Vt(t),
  })
Ho.strictCreate = (e, t) =>
  new Ho({
    shape: () => e,
    unknownKeys: "strict",
    catchall: pc.create(),
    typeName: yt.ZodObject,
    ...Vt(t),
  })
Ho.lazycreate = (e, t) =>
  new Ho({
    shape: e,
    unknownKeys: "strip",
    catchall: pc.create(),
    typeName: yt.ZodObject,
    ...Vt(t),
  })
var zg = class extends Ht {
  _parse(t) {
    let { ctx: r } = this._processInputParams(t),
      n = this._def.options
    function i(s) {
      for (let a of s) if (a.result.status === "valid") return a.result
      for (let a of s)
        if (a.result.status === "dirty")
          return r.common.issues.push(...a.ctx.common.issues), a.result
      let o = s.map((a) => new xa(a.ctx.common.issues))
      return ke(r, { code: Ce.invalid_union, unionErrors: o }), Et
    }
    if (r.common.async)
      return Promise.all(
        n.map(async (s) => {
          let o = { ...r, common: { ...r.common, issues: [] }, parent: null }
          return {
            result: await s._parseAsync({
              data: r.data,
              path: r.path,
              parent: o,
            }),
            ctx: o,
          }
        }),
      ).then(i)
    {
      let s,
        o = []
      for (let l of n) {
        let c = { ...r, common: { ...r.common, issues: [] }, parent: null },
          u = l._parseSync({ data: r.data, path: r.path, parent: c })
        if (u.status === "valid") return u
        u.status === "dirty" && !s && (s = { result: u, ctx: c }),
          c.common.issues.length && o.push(c.common.issues)
      }
      if (s) return r.common.issues.push(...s.ctx.common.issues), s.result
      let a = o.map((l) => new xa(l))
      return ke(r, { code: Ce.invalid_union, unionErrors: a }), Et
    }
  }
  get options() {
    return this._def.options
  }
}
zg.create = (e, t) => new zg({ options: e, typeName: yt.ZodUnion, ...Vt(t) })
var Dd = (e) =>
    e instanceof jg
      ? Dd(e.schema)
      : e instanceof wa
        ? Dd(e.innerType())
        : e instanceof Zg
          ? [e.value]
          : e instanceof Xg
            ? e.options
            : e instanceof ep
              ? Ir.objectValues(e.enum)
              : e instanceof tp
                ? Dd(e._def.innerType)
                : e instanceof Yg
                  ? [undefined]
                  : e instanceof Kg
                    ? [null]
                    : e instanceof vl
                      ? [undefined, ...Dd(e.unwrap())]
                      : e instanceof gu
                        ? [null, ...Dd(e.unwrap())]
                        : e instanceof Ab || e instanceof np
                          ? Dd(e.unwrap())
                          : e instanceof rp
                            ? Dd(e._def.innerType)
                            : [],
  yI = class e extends Ht {
    _parse(t) {
      let { ctx: r } = this._processInputParams(t)
      if (r.parsedType !== Le.object)
        return (
          ke(r, {
            code: Ce.invalid_type,
            expected: Le.object,
            received: r.parsedType,
          }),
          Et
        )
      let n = this.discriminator,
        i = r.data[n],
        s = this.optionsMap.get(i)
      return s
        ? r.common.async
          ? s._parseAsync({ data: r.data, path: r.path, parent: r })
          : s._parseSync({ data: r.data, path: r.path, parent: r })
        : (ke(r, {
            code: Ce.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [n],
          }),
          Et)
    }
    get discriminator() {
      return this._def.discriminator
    }
    get options() {
      return this._def.options
    }
    get optionsMap() {
      return this._def.optionsMap
    }
    static create(t, r, n) {
      let i = new Map()
      for (let s of r) {
        let o = Dd(s.shape[t])
        if (!o.length)
          throw new Error(
            `A discriminator value for key \`${t}\` could not be extracted from all schema options`,
          )
        for (let a of o) {
          if (i.has(a))
            throw new Error(
              `Discriminator property ${String(t)} has duplicate value ${String(a)}`,
            )
          i.set(a, s)
        }
      }
      return new e({
        typeName: yt.ZodDiscriminatedUnion,
        discriminator: t,
        options: r,
        optionsMap: i,
        ...Vt(n),
      })
    }
  }
function kL(e, t) {
  let r = Td(e),
    n = Td(t)
  if (e === t) return { valid: true, data: e }
  if (r === Le.object && n === Le.object) {
    let i = Ir.objectKeys(t),
      s = Ir.objectKeys(e).filter((a) => i.indexOf(a) !== -1),
      o = { ...e, ...t }
    for (let a of s) {
      let l = kL(e[a], t[a])
      if (!l.valid) return { valid: false }
      o[a] = l.data
    }
    return { valid: true, data: o }
  } else if (r === Le.array && n === Le.array) {
    if (e.length !== t.length) return { valid: false }
    let i = []
    for (let s = 0; s < e.length; s++) {
      let o = e[s],
        a = t[s],
        l = kL(o, a)
      if (!l.valid) return { valid: false }
      i.push(l.data)
    }
    return { valid: true, data: i }
  } else
    return r === Le.date && n === Le.date && +e == +t
      ? { valid: true, data: e }
      : { valid: false }
}
var Jg = class extends Ht {
  _parse(t) {
    let { status: r, ctx: n } = this._processInputParams(t),
      i = (s, o) => {
        if (DL(s) || DL(o)) return Et
        let a = kL(s.value, o.value)
        return a.valid
          ? ((TL(s) || TL(o)) && r.dirty(), { status: r.value, value: a.data })
          : (ke(n, { code: Ce.invalid_intersection_types }), Et)
      }
    return n.common.async
      ? Promise.all([
          this._def.left._parseAsync({ data: n.data, path: n.path, parent: n }),
          this._def.right._parseAsync({
            data: n.data,
            path: n.path,
            parent: n,
          }),
        ]).then(([s, o]) => i(s, o))
      : i(
          this._def.left._parseSync({ data: n.data, path: n.path, parent: n }),
          this._def.right._parseSync({ data: n.data, path: n.path, parent: n }),
        )
  }
}
Jg.create = (e, t, r) =>
  new Jg({ left: e, right: t, typeName: yt.ZodIntersection, ...Vt(r) })
var hu = class e extends Ht {
  _parse(t) {
    let { status: r, ctx: n } = this._processInputParams(t)
    if (n.parsedType !== Le.array)
      return (
        ke(n, {
          code: Ce.invalid_type,
          expected: Le.array,
          received: n.parsedType,
        }),
        Et
      )
    if (n.data.length < this._def.items.length)
      return (
        ke(n, {
          code: Ce.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array",
        }),
        Et
      )
    !this._def.rest &&
      n.data.length > this._def.items.length &&
      (ke(n, {
        code: Ce.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array",
      }),
      r.dirty())
    let s = [...n.data]
      .map((o, a) => {
        let l = this._def.items[a] || this._def.rest
        return l ? l._parse(new Cl(n, o, n.path, a)) : null
      })
      .filter((o) => !!o)
    return n.common.async
      ? Promise.all(s).then((o) => Vs.mergeArray(r, o))
      : Vs.mergeArray(r, s)
  }
  get items() {
    return this._def.items
  }
  rest(t) {
    return new e({ ...this._def, rest: t })
  }
}
hu.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])")
  return new hu({ items: e, typeName: yt.ZodTuple, rest: null, ...Vt(t) })
}
var vI = class e extends Ht {
    get keySchema() {
      return this._def.keyType
    }
    get valueSchema() {
      return this._def.valueType
    }
    _parse(t) {
      let { status: r, ctx: n } = this._processInputParams(t)
      if (n.parsedType !== Le.object)
        return (
          ke(n, {
            code: Ce.invalid_type,
            expected: Le.object,
            received: n.parsedType,
          }),
          Et
        )
      let i = [],
        s = this._def.keyType,
        o = this._def.valueType
      for (let a in n.data)
        i.push({
          key: s._parse(new Cl(n, a, n.path, a)),
          value: o._parse(new Cl(n, n.data[a], n.path, a)),
          alwaysSet: a in n.data,
        })
      return n.common.async
        ? Vs.mergeObjectAsync(r, i)
        : Vs.mergeObjectSync(r, i)
    }
    get element() {
      return this._def.valueType
    }
    static create(t, r, n) {
      return r instanceof Ht
        ? new e({ keyType: t, valueType: r, typeName: yt.ZodRecord, ...Vt(n) })
        : new e({
            keyType: zf.create(),
            valueType: t,
            typeName: yt.ZodRecord,
            ...Vt(r),
          })
    }
  },
  PA = class extends Ht {
    get keySchema() {
      return this._def.keyType
    }
    get valueSchema() {
      return this._def.valueType
    }
    _parse(t) {
      let { status: r, ctx: n } = this._processInputParams(t)
      if (n.parsedType !== Le.map)
        return (
          ke(n, {
            code: Ce.invalid_type,
            expected: Le.map,
            received: n.parsedType,
          }),
          Et
        )
      let i = this._def.keyType,
        s = this._def.valueType,
        o = [...n.data.entries()].map(([a, l], c) => ({
          key: i._parse(new Cl(n, a, n.path, [c, "key"])),
          value: s._parse(new Cl(n, l, n.path, [c, "value"])),
        }))
      if (n.common.async) {
        let a = new Map()
        return Promise.resolve().then(async () => {
          for (let l of o) {
            let c = await l.key,
              u = await l.value
            if (c.status === "aborted" || u.status === "aborted") return Et
            ;(c.status === "dirty" || u.status === "dirty") && r.dirty(),
              a.set(c.value, u.value)
          }
          return { status: r.value, value: a }
        })
      } else {
        let a = new Map()
        for (let l of o) {
          let c = l.key,
            u = l.value
          if (c.status === "aborted" || u.status === "aborted") return Et
          ;(c.status === "dirty" || u.status === "dirty") && r.dirty(),
            a.set(c.value, u.value)
        }
        return { status: r.value, value: a }
      }
    }
  }
PA.create = (e, t, r) =>
  new PA({ valueType: t, keyType: e, typeName: yt.ZodMap, ...Vt(r) })
var LA = class e extends Ht {
  _parse(t) {
    let { status: r, ctx: n } = this._processInputParams(t)
    if (n.parsedType !== Le.set)
      return (
        ke(n, {
          code: Ce.invalid_type,
          expected: Le.set,
          received: n.parsedType,
        }),
        Et
      )
    let i = this._def
    i.minSize !== null &&
      n.data.size < i.minSize.value &&
      (ke(n, {
        code: Ce.too_small,
        minimum: i.minSize.value,
        type: "set",
        inclusive: true,
        exact: false,
        message: i.minSize.message,
      }),
      r.dirty()),
      i.maxSize !== null &&
        n.data.size > i.maxSize.value &&
        (ke(n, {
          code: Ce.too_big,
          maximum: i.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: i.maxSize.message,
        }),
        r.dirty())
    let s = this._def.valueType
    function o(l) {
      let c = new Set()
      for (let u of l) {
        if (u.status === "aborted") return Et
        u.status === "dirty" && r.dirty(), c.add(u.value)
      }
      return { status: r.value, value: c }
    }
    let a = [...n.data.values()].map((l, c) =>
      s._parse(new Cl(n, l, n.path, c)),
    )
    return n.common.async ? Promise.all(a).then((l) => o(l)) : o(a)
  }
  min(t, r) {
    return new e({
      ...this._def,
      minSize: { value: t, message: Je.toString(r) },
    })
  }
  max(t, r) {
    return new e({
      ...this._def,
      maxSize: { value: t, message: Je.toString(r) },
    })
  }
  size(t, r) {
    return this.min(t, r).max(t, r)
  }
  nonempty(t) {
    return this.min(1, t)
  }
}
LA.create = (e, t) =>
  new LA({
    valueType: e,
    minSize: null,
    maxSize: null,
    typeName: yt.ZodSet,
    ...Vt(t),
  })
var CI = class e extends Ht {
    constructor() {
      super(...arguments), (this.validate = this.implement)
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t)
      if (r.parsedType !== Le.function)
        return (
          ke(r, {
            code: Ce.invalid_type,
            expected: Le.function,
            received: r.parsedType,
          }),
          Et
        )
      function n(a, l) {
        return mI({
          data: a,
          path: r.path,
          errorMaps: [
            r.common.contextualErrorMap,
            r.schemaErrorMap,
            pI(),
            FA,
          ].filter((c) => !!c),
          issueData: { code: Ce.invalid_arguments, argumentsError: l },
        })
      }
      function i(a, l) {
        return mI({
          data: a,
          path: r.path,
          errorMaps: [
            r.common.contextualErrorMap,
            r.schemaErrorMap,
            pI(),
            FA,
          ].filter((c) => !!c),
          issueData: { code: Ce.invalid_return_type, returnTypeError: l },
        })
      }
      let s = { errorMap: r.common.contextualErrorMap },
        o = r.data
      if (this._def.returns instanceof jf) {
        let a = this
        return mo(async function (...l) {
          let c = new xa([]),
            u = await a._def.args.parseAsync(l, s).catch((g) => {
              throw (c.addIssue(n(l, g)), c)
            }),
            f = await Reflect.apply(o, this, u)
          return await a._def.returns._def.type.parseAsync(f, s).catch((g) => {
            throw (c.addIssue(i(f, g)), c)
          })
        })
      } else {
        let a = this
        return mo(function (...l) {
          let c = a._def.args.safeParse(l, s)
          if (!c.success) throw new xa([n(l, c.error)])
          let u = Reflect.apply(o, this, c.data),
            f = a._def.returns.safeParse(u, s)
          if (!f.success) throw new xa([i(u, f.error)])
          return f.data
        })
      }
    }
    parameters() {
      return this._def.args
    }
    returnType() {
      return this._def.returns
    }
    args(...t) {
      return new e({ ...this._def, args: hu.create(t).rest(kd.create()) })
    }
    returns(t) {
      return new e({ ...this._def, returns: t })
    }
    implement(t) {
      return this.parse(t)
    }
    strictImplement(t) {
      return this.parse(t)
    }
    static create(t, r, n) {
      return new e({
        args: t || hu.create([]).rest(kd.create()),
        returns: r || kd.create(),
        typeName: yt.ZodFunction,
        ...Vt(n),
      })
    }
  },
  jg = class extends Ht {
    get schema() {
      return this._def.getter()
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t)
      return this._def
        .getter()
        ._parse({ data: r.data, path: r.path, parent: r })
    }
  }
jg.create = (e, t) => new jg({ getter: e, typeName: yt.ZodLazy, ...Vt(t) })
var Zg = class extends Ht {
  _parse(t) {
    if (t.data !== this._def.value) {
      let r = this._getOrReturnCtx(t)
      return (
        ke(r, {
          received: r.data,
          code: Ce.invalid_literal,
          expected: this._def.value,
        }),
        Et
      )
    }
    return { status: "valid", value: t.data }
  }
  get value() {
    return this._def.value
  }
}
Zg.create = (e, t) => new Zg({ value: e, typeName: yt.ZodLiteral, ...Vt(t) })
function rz(e, t) {
  return new Xg({ values: e, typeName: yt.ZodEnum, ...Vt(t) })
}
var Xg = class e extends Ht {
  constructor() {
    super(...arguments), gb.set(this, undefined)
  }
  _parse(t) {
    if (typeof t.data != "string") {
      let r = this._getOrReturnCtx(t),
        n = this._def.values
      return (
        ke(r, {
          expected: Ir.joinValues(n),
          received: r.parsedType,
          code: Ce.invalid_type,
        }),
        Et
      )
    }
    if (
      (AI(this, gb, "f") || ZK(this, gb, new Set(this._def.values), "f"),
      !AI(this, gb, "f").has(t.data))
    ) {
      let r = this._getOrReturnCtx(t),
        n = this._def.values
      return (
        ke(r, { received: r.data, code: Ce.invalid_enum_value, options: n }), Et
      )
    }
    return mo(t.data)
  }
  get options() {
    return this._def.values
  }
  get enum() {
    let t = {}
    for (let r of this._def.values) t[r] = r
    return t
  }
  get Values() {
    let t = {}
    for (let r of this._def.values) t[r] = r
    return t
  }
  get Enum() {
    let t = {}
    for (let r of this._def.values) t[r] = r
    return t
  }
  extract(t, r = this._def) {
    return e.create(t, { ...this._def, ...r })
  }
  exclude(t, r = this._def) {
    return e.create(
      this.options.filter((n) => !t.includes(n)),
      { ...this._def, ...r },
    )
  }
}
gb = new WeakMap()
Xg.create = rz
var ep = class extends Ht {
  constructor() {
    super(...arguments), pb.set(this, undefined)
  }
  _parse(t) {
    let r = Ir.getValidEnumValues(this._def.values),
      n = this._getOrReturnCtx(t)
    if (n.parsedType !== Le.string && n.parsedType !== Le.number) {
      let i = Ir.objectValues(r)
      return (
        ke(n, {
          expected: Ir.joinValues(i),
          received: n.parsedType,
          code: Ce.invalid_type,
        }),
        Et
      )
    }
    if (
      (AI(this, pb, "f") ||
        ZK(this, pb, new Set(Ir.getValidEnumValues(this._def.values)), "f"),
      !AI(this, pb, "f").has(t.data))
    ) {
      let i = Ir.objectValues(r)
      return (
        ke(n, { received: n.data, code: Ce.invalid_enum_value, options: i }), Et
      )
    }
    return mo(t.data)
  }
  get enum() {
    return this._def.values
  }
}
pb = new WeakMap()
ep.create = (e, t) =>
  new ep({ values: e, typeName: yt.ZodNativeEnum, ...Vt(t) })
var jf = class extends Ht {
  unwrap() {
    return this._def.type
  }
  _parse(t) {
    let { ctx: r } = this._processInputParams(t)
    if (r.parsedType !== Le.promise && r.common.async === false)
      return (
        ke(r, {
          code: Ce.invalid_type,
          expected: Le.promise,
          received: r.parsedType,
        }),
        Et
      )
    let n = r.parsedType === Le.promise ? r.data : Promise.resolve(r.data)
    return mo(
      n.then((i) =>
        this._def.type.parseAsync(i, {
          path: r.path,
          errorMap: r.common.contextualErrorMap,
        }),
      ),
    )
  }
}
jf.create = (e, t) => new jf({ type: e, typeName: yt.ZodPromise, ...Vt(t) })
var wa = class extends Ht {
  innerType() {
    return this._def.schema
  }
  sourceType() {
    return this._def.schema._def.typeName === yt.ZodEffects
      ? this._def.schema.sourceType()
      : this._def.schema
  }
  _parse(t) {
    let { status: r, ctx: n } = this._processInputParams(t),
      i = this._def.effect || null,
      s = {
        addIssue: (o) => {
          ke(n, o), o.fatal ? r.abort() : r.dirty()
        },
        get path() {
          return n.path
        },
      }
    if (((s.addIssue = s.addIssue.bind(s)), i.type === "preprocess")) {
      let o = i.transform(n.data, s)
      if (n.common.async)
        return Promise.resolve(o).then(async (a) => {
          if (r.value === "aborted") return Et
          let l = await this._def.schema._parseAsync({
            data: a,
            path: n.path,
            parent: n,
          })
          return l.status === "aborted"
            ? Et
            : l.status === "dirty" || r.value === "dirty"
              ? MA(l.value)
              : l
        })
      {
        if (r.value === "aborted") return Et
        let a = this._def.schema._parseSync({
          data: o,
          path: n.path,
          parent: n,
        })
        return a.status === "aborted"
          ? Et
          : a.status === "dirty" || r.value === "dirty"
            ? MA(a.value)
            : a
      }
    }
    if (i.type === "refinement") {
      let o = (a) => {
        let l = i.refinement(a, s)
        if (n.common.async) return Promise.resolve(l)
        if (l instanceof Promise)
          throw new Error(
            "Async refinement encountered during synchronous parse operation. Use .parseAsync instead.",
          )
        return a
      }
      if (n.common.async === false) {
        let a = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n,
        })
        return a.status === "aborted"
          ? Et
          : (a.status === "dirty" && r.dirty(),
            o(a.value),
            { status: r.value, value: a.value })
      } else
        return this._def.schema
          ._parseAsync({ data: n.data, path: n.path, parent: n })
          .then((a) =>
            a.status === "aborted"
              ? Et
              : (a.status === "dirty" && r.dirty(),
                o(a.value).then(() => ({ status: r.value, value: a.value }))),
          )
    }
    if (i.type === "transform")
      if (n.common.async === false) {
        let o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n,
        })
        if (!Vg(o)) return o
        let a = i.transform(o.value, s)
        if (a instanceof Promise)
          throw new Error(
            "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.",
          )
        return { status: r.value, value: a }
      } else
        return this._def.schema
          ._parseAsync({ data: n.data, path: n.path, parent: n })
          .then((o) =>
            Vg(o)
              ? Promise.resolve(i.transform(o.value, s)).then((a) => ({
                  status: r.value,
                  value: a,
                }))
              : o,
          )
    Ir.assertNever(i)
  }
}
wa.create = (e, t, r) =>
  new wa({ schema: e, typeName: yt.ZodEffects, effect: t, ...Vt(r) })
wa.createWithPreprocess = (e, t, r) =>
  new wa({
    schema: t,
    effect: { type: "preprocess", transform: e },
    typeName: yt.ZodEffects,
    ...Vt(r),
  })
var vl = class extends Ht {
  _parse(t) {
    return this._getType(t) === Le.undefined
      ? mo(undefined)
      : this._def.innerType._parse(t)
  }
  unwrap() {
    return this._def.innerType
  }
}
vl.create = (e, t) =>
  new vl({ innerType: e, typeName: yt.ZodOptional, ...Vt(t) })
var gu = class extends Ht {
  _parse(t) {
    return this._getType(t) === Le.null
      ? mo(null)
      : this._def.innerType._parse(t)
  }
  unwrap() {
    return this._def.innerType
  }
}
gu.create = (e, t) =>
  new gu({ innerType: e, typeName: yt.ZodNullable, ...Vt(t) })
var tp = class extends Ht {
  _parse(t) {
    let { ctx: r } = this._processInputParams(t),
      n = r.data
    return (
      r.parsedType === Le.undefined && (n = this._def.defaultValue()),
      this._def.innerType._parse({ data: n, path: r.path, parent: r })
    )
  }
  removeDefault() {
    return this._def.innerType
  }
}
tp.create = (e, t) =>
  new tp({
    innerType: e,
    typeName: yt.ZodDefault,
    defaultValue: typeof t.default == "function" ? t.default : () => t.default,
    ...Vt(t),
  })
var rp = class extends Ht {
  _parse(t) {
    let { ctx: r } = this._processInputParams(t),
      n = { ...r, common: { ...r.common, issues: [] } },
      i = this._def.innerType._parse({
        data: n.data,
        path: n.path,
        parent: { ...n },
      })
    return mb(i)
      ? i.then((s) => ({
          status: "valid",
          value:
            s.status === "valid"
              ? s.value
              : this._def.catchValue({
                  get error() {
                    return new xa(n.common.issues)
                  },
                  input: n.data,
                }),
        }))
      : {
          status: "valid",
          value:
            i.status === "valid"
              ? i.value
              : this._def.catchValue({
                  get error() {
                    return new xa(n.common.issues)
                  },
                  input: n.data,
                }),
        }
  }
  removeCatch() {
    return this._def.innerType
  }
}
rp.create = (e, t) =>
  new rp({
    innerType: e,
    typeName: yt.ZodCatch,
    catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
    ...Vt(t),
  })
var UA = class extends Ht {
  _parse(t) {
    if (this._getType(t) !== Le.nan) {
      let n = this._getOrReturnCtx(t)
      return (
        ke(n, {
          code: Ce.invalid_type,
          expected: Le.nan,
          received: n.parsedType,
        }),
        Et
      )
    }
    return { status: "valid", value: t.data }
  }
}
UA.create = (e) => new UA({ typeName: yt.ZodNaN, ...Vt(e) })
var bQe = Symbol("zod_brand"),
  Ab = class extends Ht {
    _parse(t) {
      let { ctx: r } = this._processInputParams(t),
        n = r.data
      return this._def.type._parse({ data: n, path: r.path, parent: r })
    }
    unwrap() {
      return this._def.type
    }
  },
  yb = class e extends Ht {
    _parse(t) {
      let { status: r, ctx: n } = this._processInputParams(t)
      if (n.common.async)
        return (async () => {
          let s = await this._def.in._parseAsync({
            data: n.data,
            path: n.path,
            parent: n,
          })
          return s.status === "aborted"
            ? Et
            : s.status === "dirty"
              ? (r.dirty(), MA(s.value))
              : this._def.out._parseAsync({
                  data: s.value,
                  path: n.path,
                  parent: n,
                })
        })()
      {
        let i = this._def.in._parseSync({
          data: n.data,
          path: n.path,
          parent: n,
        })
        return i.status === "aborted"
          ? Et
          : i.status === "dirty"
            ? (r.dirty(), { status: "dirty", value: i.value })
            : this._def.out._parseSync({
                data: i.value,
                path: n.path,
                parent: n,
              })
      }
    }
    static create(t, r) {
      return new e({ in: t, out: r, typeName: yt.ZodPipeline })
    }
  },
  np = class extends Ht {
    _parse(t) {
      let r = this._def.innerType._parse(t),
        n = (i) => (Vg(i) && (i.value = Object.freeze(i.value)), i)
      return mb(r) ? r.then((i) => n(i)) : n(r)
    }
    unwrap() {
      return this._def.innerType
    }
  }
np.create = (e, t) =>
  new np({ innerType: e, typeName: yt.ZodReadonly, ...Vt(t) })
function nz(e, t = {}, r) {
  return e
    ? Jf.create().superRefine((n, i) => {
        var s, o
        if (!e(n)) {
          let a =
              typeof t == "function"
                ? t(n)
                : typeof t == "string"
                  ? { message: t }
                  : t,
            l =
              (o = (s = a.fatal) !== null && s !== undefined ? s : r) !== null &&
              o !== undefined
                ? o
                : true,
            c = typeof a == "string" ? { message: a } : a
          i.addIssue({ code: "custom", ...c, fatal: l })
        }
      })
    : Jf.create()
}
var EQe = { object: Ho.lazycreate },
  yt
;(function (e) {
  ;(e.ZodString = "ZodString"),
    (e.ZodNumber = "ZodNumber"),
    (e.ZodNaN = "ZodNaN"),
    (e.ZodBigInt = "ZodBigInt"),
    (e.ZodBoolean = "ZodBoolean"),
    (e.ZodDate = "ZodDate"),
    (e.ZodSymbol = "ZodSymbol"),
    (e.ZodUndefined = "ZodUndefined"),
    (e.ZodNull = "ZodNull"),
    (e.ZodAny = "ZodAny"),
    (e.ZodUnknown = "ZodUnknown"),
    (e.ZodNever = "ZodNever"),
    (e.ZodVoid = "ZodVoid"),
    (e.ZodArray = "ZodArray"),
    (e.ZodObject = "ZodObject"),
    (e.ZodUnion = "ZodUnion"),
    (e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
    (e.ZodIntersection = "ZodIntersection"),
    (e.ZodTuple = "ZodTuple"),
    (e.ZodRecord = "ZodRecord"),
    (e.ZodMap = "ZodMap"),
    (e.ZodSet = "ZodSet"),
    (e.ZodFunction = "ZodFunction"),
    (e.ZodLazy = "ZodLazy"),
    (e.ZodLiteral = "ZodLiteral"),
    (e.ZodEnum = "ZodEnum"),
    (e.ZodEffects = "ZodEffects"),
    (e.ZodNativeEnum = "ZodNativeEnum"),
    (e.ZodOptional = "ZodOptional"),
    (e.ZodNullable = "ZodNullable"),
    (e.ZodDefault = "ZodDefault"),
    (e.ZodCatch = "ZodCatch"),
    (e.ZodPromise = "ZodPromise"),
    (e.ZodBranded = "ZodBranded"),
    (e.ZodPipeline = "ZodPipeline"),
    (e.ZodReadonly = "ZodReadonly")
})(yt || (yt = {}))
var _Qe = (e, t = { message: `Input not instance of ${e.name}` }) =>
    nz((r) => r instanceof e, t),
  iz = zf.create,
  sz = Hg.create,
  xQe = UA.create,
  wQe = Wg.create,
  oz = Gg.create,
  SQe = $g.create,
  IQe = QA.create,
  BQe = Yg.create,
  RQe = Kg.create,
  DQe = Jf.create,
  TQe = kd.create,
  kQe = pc.create,
  MQe = NA.create,
  FQe = Md.create,
  QQe = Ho.create,
  NQe = Ho.strictCreate,
  PQe = zg.create,
  LQe = yI.create,
  UQe = Jg.create,
  OQe = hu.create,
  qQe = vI.create,
  VQe = PA.create,
  HQe = LA.create,
  WQe = CI.create,
  GQe = jg.create,
  $Qe = Zg.create,
  YQe = Xg.create,
  KQe = ep.create,
  zQe = jf.create,
  JK = wa.create,
  JQe = vl.create,
  jQe = gu.create,
  ZQe = wa.createWithPreprocess,
  XQe = yb.create,
  eNe = () => iz().optional(),
  tNe = () => sz().optional(),
  rNe = () => oz().optional(),
  nNe = {
    string: (e) => zf.create({ ...e, coerce: true }),
    number: (e) => Hg.create({ ...e, coerce: true }),
    boolean: (e) => Gg.create({ ...e, coerce: true }),
    bigint: (e) => Wg.create({ ...e, coerce: true }),
    date: (e) => $g.create({ ...e, coerce: true }),
  },
  iNe = Et,
  k = Object.freeze({
    __proto__: null,
    defaultErrorMap: FA,
    setErrorMap: Z1e,
    getErrorMap: pI,
    makeIssue: mI,
    EMPTY_PATH: X1e,
    addIssueToContext: ke,
    ParseStatus: Vs,
    INVALID: Et,
    DIRTY: MA,
    OK: mo,
    isAborted: DL,
    isDirty: TL,
    isValid: Vg,
    isAsync: mb,
    get util() {
      return Ir
    },
    get objectUtil() {
      return RL
    },
    ZodParsedType: Le,
    getParsedType: Td,
    ZodType: Ht,
    datetimeRegex: tz,
    ZodString: zf,
    ZodNumber: Hg,
    ZodBigInt: Wg,
    ZodBoolean: Gg,
    ZodDate: $g,
    ZodSymbol: QA,
    ZodUndefined: Yg,
    ZodNull: Kg,
    ZodAny: Jf,
    ZodUnknown: kd,
    ZodNever: pc,
    ZodVoid: NA,
    ZodArray: Md,
    ZodObject: Ho,
    ZodUnion: zg,
    ZodDiscriminatedUnion: yI,
    ZodIntersection: Jg,
    ZodTuple: hu,
    ZodRecord: vI,
    ZodMap: PA,
    ZodSet: LA,
    ZodFunction: CI,
    ZodLazy: jg,
    ZodLiteral: Zg,
    ZodEnum: Xg,
    ZodNativeEnum: ep,
    ZodPromise: jf,
    ZodEffects: wa,
    ZodTransformer: wa,
    ZodOptional: vl,
    ZodNullable: gu,
    ZodDefault: tp,
    ZodCatch: rp,
    ZodNaN: UA,
    BRAND: bQe,
    ZodBranded: Ab,
    ZodPipeline: yb,
    ZodReadonly: np,
    custom: nz,
    Schema: Ht,
    ZodSchema: Ht,
    late: EQe,
    get ZodFirstPartyTypeKind() {
      return yt
    },
    coerce: nNe,
    any: DQe,
    array: FQe,
    bigint: wQe,
    boolean: oz,
    date: SQe,
    discriminatedUnion: LQe,
    effect: JK,
    enum: YQe,
    function: WQe,
    instanceof: _Qe,
    intersection: UQe,
    lazy: GQe,
    literal: $Qe,
    map: VQe,
    nan: xQe,
    nativeEnum: KQe,
    never: kQe,
    null: RQe,
    nullable: jQe,
    number: sz,
    object: QQe,
    oboolean: rNe,
    onumber: tNe,
    optional: JQe,
    ostring: eNe,
    pipeline: XQe,
    preprocess: ZQe,
    promise: zQe,
    record: qQe,
    set: HQe,
    strictObject: NQe,
    string: iz,
    symbol: IQe,
    transformer: JK,
    tuple: OQe,
    undefined: BQe,
    union: PQe,
    unknown: TQe,
    void: MQe,
    NEVER: iNe,
    ZodIssueCode: Ce,
    quotelessJson: j1e,
    ZodError: xa,
  })
var ML = "2024-11-05",
  az = [ML, "2024-10-07"],
  bI = "2.0",
  lz = k.union([k.string(), k.number().int()]),
  cz = k.string(),
  mc = k
    .object({
      _meta: k.optional(
        k.object({ progressToken: k.optional(lz) }).passthrough(),
      ),
    })
    .passthrough(),
  Sa = k.object({ method: k.string(), params: k.optional(mc) }),
  vb = k
    .object({ _meta: k.optional(k.object({}).passthrough()) })
    .passthrough(),
  pu = k.object({ method: k.string(), params: k.optional(vb) }),
  Ac = k
    .object({ _meta: k.optional(k.object({}).passthrough()) })
    .passthrough(),
  EI = k.union([k.string(), k.number().int()]),
  sNe = k
    .object({ jsonrpc: k.literal(bI), id: EI })
    .merge(Sa)
    .strict(),
  oNe = k
    .object({ jsonrpc: k.literal(bI) })
    .merge(pu)
    .strict(),
  aNe = k.object({ jsonrpc: k.literal(bI), id: EI, result: Ac }).strict(),
  ip
;(function (e) {
  ;(e[(e.ConnectionClosed = -1)] = "ConnectionClosed"),
    (e[(e.RequestTimeout = -2)] = "RequestTimeout"),
    (e[(e.ParseError = -32700)] = "ParseError"),
    (e[(e.InvalidRequest = -32600)] = "InvalidRequest"),
    (e[(e.MethodNotFound = -32601)] = "MethodNotFound"),
    (e[(e.InvalidParams = -32602)] = "InvalidParams"),
    (e[(e.InternalError = -32603)] = "InternalError")
})(ip || (ip = {}))
var lNe = k
    .object({
      jsonrpc: k.literal(bI),
      id: EI,
      error: k.object({
        code: k.number().int(),
        message: k.string(),
        data: k.optional(k.unknown()),
      }),
    })
    .strict(),
  uz = k.union([sNe, oNe, aNe, lNe]),
  sp = Ac.strict(),
  _I = pu.extend({
    method: k.literal("notifications/cancelled"),
    params: vb.extend({ requestId: EI, reason: k.string().optional() }),
  }),
  dz = k.object({ name: k.string(), version: k.string() }).passthrough(),
  cNe = k
    .object({
      experimental: k.optional(k.object({}).passthrough()),
      sampling: k.optional(k.object({}).passthrough()),
      roots: k.optional(
        k.object({ listChanged: k.optional(k.boolean()) }).passthrough(),
      ),
    })
    .passthrough(),
  uNe = Sa.extend({
    method: k.literal("initialize"),
    params: mc.extend({
      protocolVersion: k.string(),
      capabilities: cNe,
      clientInfo: dz,
    }),
  }),
  dNe = k
    .object({
      experimental: k.optional(k.object({}).passthrough()),
      logging: k.optional(k.object({}).passthrough()),
      prompts: k.optional(
        k.object({ listChanged: k.optional(k.boolean()) }).passthrough(),
      ),
      resources: k.optional(
        k
          .object({
            subscribe: k.optional(k.boolean()),
            listChanged: k.optional(k.boolean()),
          })
          .passthrough(),
      ),
      tools: k.optional(
        k.object({ listChanged: k.optional(k.boolean()) }).passthrough(),
      ),
    })
    .passthrough(),
  FL = Ac.extend({
    protocolVersion: k.string(),
    capabilities: dNe,
    serverInfo: dz,
  }),
  fNe = pu.extend({ method: k.literal("notifications/initialized") }),
  xI = Sa.extend({ method: k.literal("ping") }),
  hNe = k
    .object({ progress: k.number(), total: k.optional(k.number()) })
    .passthrough(),
  wI = pu.extend({
    method: k.literal("notifications/progress"),
    params: vb.merge(hNe).extend({ progressToken: lz }),
  }),
  SI = Sa.extend({ params: mc.extend({ cursor: k.optional(cz) }).optional() }),
  II = Ac.extend({ nextCursor: k.optional(cz) }),
  fz = k
    .object({ uri: k.string(), mimeType: k.optional(k.string()) })
    .passthrough(),
  hz = fz.extend({ text: k.string() }),
  gz = fz.extend({ blob: k.string().base64() }),
  gNe = k
    .object({
      uri: k.string(),
      name: k.string(),
      description: k.optional(k.string()),
      mimeType: k.optional(k.string()),
    })
    .passthrough(),
  pNe = k
    .object({
      uriTemplate: k.string(),
      name: k.string(),
      description: k.optional(k.string()),
      mimeType: k.optional(k.string()),
    })
    .passthrough(),
  mNe = SI.extend({ method: k.literal("resources/list") }),
  QL = II.extend({ resources: k.array(gNe) }),
  ANe = SI.extend({ method: k.literal("resources/templates/list") }),
  NL = II.extend({ resourceTemplates: k.array(pNe) }),
  yNe = Sa.extend({
    method: k.literal("resources/read"),
    params: mc.extend({ uri: k.string() }),
  }),
  PL = Ac.extend({ contents: k.array(k.union([hz, gz])) }),
  vNe = pu.extend({
    method: k.literal("notifications/resources/list_changed"),
  }),
  CNe = Sa.extend({
    method: k.literal("resources/subscribe"),
    params: mc.extend({ uri: k.string() }),
  }),
  bNe = Sa.extend({
    method: k.literal("resources/unsubscribe"),
    params: mc.extend({ uri: k.string() }),
  }),
  ENe = pu.extend({
    method: k.literal("notifications/resources/updated"),
    params: vb.extend({ uri: k.string() }),
  }),
  _Ne = k
    .object({
      name: k.string(),
      description: k.optional(k.string()),
      required: k.optional(k.boolean()),
    })
    .passthrough(),
  xNe = k
    .object({
      name: k.string(),
      description: k.optional(k.string()),
      arguments: k.optional(k.array(_Ne)),
    })
    .passthrough(),
  wNe = SI.extend({ method: k.literal("prompts/list") }),
  LL = II.extend({ prompts: k.array(xNe) }),
  SNe = Sa.extend({
    method: k.literal("prompts/get"),
    params: mc.extend({
      name: k.string(),
      arguments: k.optional(k.record(k.string())),
    }),
  }),
  BI = k.object({ type: k.literal("text"), text: k.string() }).passthrough(),
  RI = k
    .object({
      type: k.literal("image"),
      data: k.string().base64(),
      mimeType: k.string(),
    })
    .passthrough(),
  pz = k
    .object({ type: k.literal("resource"), resource: k.union([hz, gz]) })
    .passthrough(),
  INe = k
    .object({
      role: k.enum(["user", "assistant"]),
      content: k.union([BI, RI, pz]),
    })
    .passthrough(),
  UL = Ac.extend({
    description: k.optional(k.string()),
    messages: k.array(INe),
  }),
  BNe = pu.extend({ method: k.literal("notifications/prompts/list_changed") }),
  RNe = k
    .object({
      name: k.string(),
      description: k.optional(k.string()),
      inputSchema: k
        .object({
          type: k.literal("object"),
          properties: k.optional(k.object({}).passthrough()),
        })
        .passthrough(),
    })
    .passthrough(),
  DNe = SI.extend({ method: k.literal("tools/list") }),
  OL = II.extend({ tools: k.array(RNe) }),
  qA = Ac.extend({
    content: k.array(k.union([BI, RI, pz])),
    isError: k.boolean().default(false).optional(),
  }),
  _xt = qA.or(Ac.extend({ toolResult: k.unknown() })),
  TNe = Sa.extend({
    method: k.literal("tools/call"),
    params: mc.extend({
      name: k.string(),
      arguments: k.optional(k.record(k.unknown())),
    }),
  }),
  kNe = pu.extend({ method: k.literal("notifications/tools/list_changed") }),
  mz = k.enum([
    "debug",
    "info",
    "notice",
    "warning",
    "error",
    "critical",
    "alert",
    "emergency",
  ]),
  MNe = Sa.extend({
    method: k.literal("logging/setLevel"),
    params: mc.extend({ level: mz }),
  }),
  FNe = pu.extend({
    method: k.literal("notifications/message"),
    params: vb.extend({
      level: mz,
      logger: k.optional(k.string()),
      data: k.unknown(),
    }),
  }),
  QNe = k.object({ name: k.string().optional() }).passthrough(),
  NNe = k
    .object({
      hints: k.optional(k.array(QNe)),
      costPriority: k.optional(k.number().min(0).max(1)),
      speedPriority: k.optional(k.number().min(0).max(1)),
      intelligencePriority: k.optional(k.number().min(0).max(1)),
    })
    .passthrough(),
  PNe = k
    .object({ role: k.enum(["user", "assistant"]), content: k.union([BI, RI]) })
    .passthrough(),
  LNe = Sa.extend({
    method: k.literal("sampling/createMessage"),
    params: mc.extend({
      messages: k.array(PNe),
      systemPrompt: k.optional(k.string()),
      includeContext: k.optional(k.enum(["none", "thisServer", "allServers"])),
      temperature: k.optional(k.number()),
      maxTokens: k.number().int(),
      stopSequences: k.optional(k.array(k.string())),
      metadata: k.optional(k.object({}).passthrough()),
      modelPreferences: k.optional(NNe),
    }),
  }),
  UNe = Ac.extend({
    model: k.string(),
    stopReason: k.optional(
      k.enum(["endTurn", "stopSequence", "maxTokens"]).or(k.string()),
    ),
    role: k.enum(["user", "assistant"]),
    content: k.discriminatedUnion("type", [BI, RI]),
  }),
  ONe = k
    .object({ type: k.literal("ref/resource"), uri: k.string() })
    .passthrough(),
  qNe = k
    .object({ type: k.literal("ref/prompt"), name: k.string() })
    .passthrough(),
  VNe = Sa.extend({
    method: k.literal("completion/complete"),
    params: mc.extend({
      ref: k.union([qNe, ONe]),
      argument: k.object({ name: k.string(), value: k.string() }).passthrough(),
    }),
  }),
  qL = Ac.extend({
    completion: k
      .object({
        values: k.array(k.string()).max(100),
        total: k.optional(k.number().int()),
        hasMore: k.optional(k.boolean()),
      })
      .passthrough(),
  }),
  HNe = k
    .object({
      uri: k.string().startsWith("file://"),
      name: k.optional(k.string()),
    })
    .passthrough(),
  WNe = Sa.extend({ method: k.literal("roots/list") }),
  GNe = Ac.extend({ roots: k.array(HNe) }),
  $Ne = pu.extend({ method: k.literal("notifications/roots/list_changed") }),
  xxt = k.union([
    xI,
    uNe,
    VNe,
    MNe,
    SNe,
    wNe,
    mNe,
    ANe,
    yNe,
    CNe,
    bNe,
    TNe,
    DNe,
  ]),
  wxt = k.union([_I, wI, fNe, $Ne]),
  Sxt = k.union([sp, UNe, GNe]),
  Ixt = k.union([xI, LNe, WNe]),
  Bxt = k.union([_I, wI, FNe, ENe, vNe, kNe, BNe]),
  Rxt = k.union([sp, FL, qL, UL, LL, QL, NL, PL, qA, OL]),
  OA = class extends Error {
    code
    data
    constructor(t, r, n) {
      super(`MCP error ${t}: ${r}`), (this.code = t), (this.data = n)
    }
  }
var YNe = 6e4,
  DI = class {
    _options
    _transport
    _requestMessageId = 0
    _requestHandlers = new Map()
    _requestHandlerAbortControllers = new Map()
    _notificationHandlers = new Map()
    _responseHandlers = new Map()
    _progressHandlers = new Map()
    onclose
    onerror
    fallbackRequestHandler
    fallbackNotificationHandler
    constructor(t) {
      ;(this._options = t),
        this.setNotificationHandler(_I, (r) => {
          this._requestHandlerAbortControllers
            .get(r.params.requestId)
            ?.abort(r.params.reason)
        }),
        this.setNotificationHandler(wI, (r) => {
          this._onprogress(r)
        }),
        this.setRequestHandler(xI, (r) => ({}))
    }
    async connect(t) {
      ;(this._transport = t),
        (this._transport.onclose = () => {
          this._onclose()
        }),
        (this._transport.onerror = (r) => {
          this._onerror(r)
        }),
        (this._transport.onmessage = (r) => {
          "method" in r
            ? "id" in r
              ? this._onrequest(r)
              : this._onnotification(r)
            : this._onresponse(r)
        }),
        await this._transport.start()
    }
    _onclose() {
      let t = this._responseHandlers
      ;(this._responseHandlers = new Map()),
        this._progressHandlers.clear(),
        (this._transport = undefined),
        this.onclose?.()
      let r = new OA(ip.ConnectionClosed, "Connection closed")
      for (let n of t.values()) n(r)
    }
    _onerror(t) {
      this.onerror?.(t)
    }
    _onnotification(t) {
      let r =
        this._notificationHandlers.get(t.method) ??
        this.fallbackNotificationHandler
      r !== undefined &&
        Promise.resolve()
          .then(() => r(t))
          .catch((n) =>
            this._onerror(
              new Error(`Uncaught error in notification handler: ${n}`),
            ),
          )
    }
    _onrequest(t) {
      let r = this._requestHandlers.get(t.method) ?? this.fallbackRequestHandler
      if (r === undefined) {
        this._transport
          ?.send({
            jsonrpc: "2.0",
            id: t.id,
            error: { code: ip.MethodNotFound, message: "Method not found" },
          })
          .catch((i) =>
            this._onerror(new Error(`Failed to send an error response: ${i}`)),
          )
        return
      }
      let n = new AbortController()
      this._requestHandlerAbortControllers.set(t.id, n),
        Promise.resolve()
          .then(() => r(t, { signal: n.signal }))
          .then(
            (i) => {
              if (!n.signal.aborted)
                return this._transport?.send({
                  result: i,
                  jsonrpc: "2.0",
                  id: t.id,
                })
            },
            (i) => {
              if (!n.signal.aborted)
                return this._transport?.send({
                  jsonrpc: "2.0",
                  id: t.id,
                  error: {
                    code: Number.isSafeInteger(i.code)
                      ? i.code
                      : ip.InternalError,
                    message: i.message ?? "Internal error",
                  },
                })
            },
          )
          .catch((i) =>
            this._onerror(new Error(`Failed to send response: ${i}`)),
          )
          .finally(() => {
            this._requestHandlerAbortControllers.delete(t.id)
          })
    }
    _onprogress(t) {
      let { progressToken: r, ...n } = t.params,
        i = this._progressHandlers.get(Number(r))
      if (i === undefined) {
        this._onerror(
          new Error(
            `Received a progress notification for an unknown token: ${JSON.stringify(t)}`,
          ),
        )
        return
      }
      i(n)
    }
    _onresponse(t) {
      let r = t.id,
        n = this._responseHandlers.get(Number(r))
      if (n === undefined) {
        this._onerror(
          new Error(
            `Received a response for an unknown message ID: ${JSON.stringify(t)}`,
          ),
        )
        return
      }
      if (
        (this._responseHandlers.delete(Number(r)),
        this._progressHandlers.delete(Number(r)),
        "result" in t)
      )
        n(t)
      else {
        let i = new OA(t.error.code, t.error.message, t.error.data)
        n(i)
      }
    }
    get transport() {
      return this._transport
    }
    async close() {
      await this._transport?.close()
    }
    request(t, r, n) {
      return new Promise((i, s) => {
        if (!this._transport) {
          s(new Error("Not connected"))
          return
        }
        this._options?.enforceStrictCapabilities === true &&
          this.assertCapabilityForMethod(t.method),
          n?.signal?.throwIfAborted()
        let o = this._requestMessageId++,
          a = { ...t, jsonrpc: "2.0", id: o }
        n?.onprogress &&
          (this._progressHandlers.set(o, n.onprogress),
          (a.params = { ...t.params, _meta: { progressToken: o } }))
        let l
        this._responseHandlers.set(o, (f) => {
          if ((l !== undefined && clearTimeout(l), !n?.signal?.aborted)) {
            if (f instanceof Error) return s(f)
            try {
              let p = r.parse(f.result)
              i(p)
            } catch (p) {
              s(p)
            }
          }
        })
        let c = (f) => {
          this._responseHandlers.delete(o),
            this._progressHandlers.delete(o),
            this._transport
              ?.send({
                jsonrpc: "2.0",
                method: "notifications/cancelled",
                params: { requestId: o, reason: String(f) },
              })
              .catch((p) =>
                this._onerror(new Error(`Failed to send cancellation: ${p}`)),
              ),
            s(f)
        }
        n?.signal?.addEventListener("abort", () => {
          l !== undefined && clearTimeout(l), c(n?.signal?.reason)
        })
        let u = n?.timeout ?? YNe
        ;(l = setTimeout(
          () =>
            c(new OA(ip.RequestTimeout, "Request timed out", { timeout: u })),
          u,
        )),
          this._transport.send(a).catch((f) => {
            l !== undefined && clearTimeout(l), s(f)
          })
      })
    }
    async notification(t) {
      if (!this._transport) throw new Error("Not connected")
      this.assertNotificationCapability(t.method)
      let r = { ...t, jsonrpc: "2.0" }
      await this._transport.send(r)
    }
    setRequestHandler(t, r) {
      let n = t.shape.method.value
      this.assertRequestHandlerCapability(n),
        this._requestHandlers.set(n, (i, s) =>
          Promise.resolve(r(t.parse(i), s)),
        )
    }
    removeRequestHandler(t) {
      this._requestHandlers.delete(t)
    }
    setNotificationHandler(t, r) {
      this._notificationHandlers.set(t.shape.method.value, (n) =>
        Promise.resolve(r(t.parse(n))),
      )
    }
    removeNotificationHandler(t) {
      this._notificationHandlers.delete(t)
    }
  }
var TI = class extends DI {
  _clientInfo
  _serverCapabilities
  _serverVersion
  _capabilities
  constructor(t, r) {
    super(r), (this._clientInfo = t), (this._capabilities = r.capabilities)
  }
  assertCapability(t, r) {
    if (!this._serverCapabilities?.[t])
      throw new Error(`Server does not support ${t} (required for ${r})`)
  }
  async connect(t) {
    await super.connect(t)
    try {
      let r = await this.request(
        {
          method: "initialize",
          params: {
            protocolVersion: ML,
            capabilities: this._capabilities,
            clientInfo: this._clientInfo,
          },
        },
        FL,
      )
      if (r === undefined)
        throw new Error(`Server sent invalid initialize result: ${r}`)
      if (!az.includes(r.protocolVersion))
        throw new Error(
          `Server's protocol version is not supported: ${r.protocolVersion}`,
        )
      ;(this._serverCapabilities = r.capabilities),
        (this._serverVersion = r.serverInfo),
        await this.notification({ method: "notifications/initialized" })
    } catch (r) {
      throw (this.close(), r)
    }
  }
  getServerCapabilities() {
    return this._serverCapabilities
  }
  getServerVersion() {
    return this._serverVersion
  }
  assertCapabilityForMethod(t) {
    switch (t) {
      case "logging/setLevel":
        if (!this._serverCapabilities?.logging)
          throw new Error(`Server does not support logging (required for ${t})`)
        break
      case "prompts/get":
      case "prompts/list":
        if (!this._serverCapabilities?.prompts)
          throw new Error(`Server does not support prompts (required for ${t})`)
        break
      case "resources/list":
      case "resources/templates/list":
      case "resources/read":
      case "resources/subscribe":
      case "resources/unsubscribe":
        if (!this._serverCapabilities?.resources)
          throw new Error(
            `Server does not support resources (required for ${t})`,
          )
        if (
          t === "resources/subscribe" &&
          !this._serverCapabilities.resources.subscribe
        )
          throw new Error(
            `Server does not support resource subscriptions (required for ${t})`,
          )
        break
      case "tools/call":
      case "tools/list":
        if (!this._serverCapabilities?.tools)
          throw new Error(`Server does not support tools (required for ${t})`)
        break
      case "completion/complete":
        if (!this._serverCapabilities?.prompts)
          throw new Error(`Server does not support prompts (required for ${t})`)
        break
      case "initialize":
        break
      case "ping":
        break
    }
  }
  assertNotificationCapability(t) {
    switch (t) {
      case "notifications/roots/list_changed":
        if (!this._capabilities.roots?.listChanged)
          throw new Error(
            `Client does not support roots list changed notifications (required for ${t})`,
          )
        break
      case "notifications/initialized":
        break
      case "notifications/cancelled":
        break
      case "notifications/progress":
        break
    }
  }
  assertRequestHandlerCapability(t) {
    switch (t) {
      case "sampling/createMessage":
        if (!this._capabilities.sampling)
          throw new Error(
            `Client does not support sampling capability (required for ${t})`,
          )
        break
      case "roots/list":
        if (!this._capabilities.roots)
          throw new Error(
            `Client does not support roots capability (required for ${t})`,
          )
        break
      case "ping":
        break
    }
  }
  async ping(t) {
    return this.request({ method: "ping" }, sp, t)
  }
  async complete(t, r) {
    return this.request({ method: "completion/complete", params: t }, qL, r)
  }
  async setLoggingLevel(t, r) {
    return this.request(
      { method: "logging/setLevel", params: { level: t } },
      sp,
      r,
    )
  }
  async getPrompt(t, r) {
    return this.request({ method: "prompts/get", params: t }, UL, r)
  }
  async listPrompts(t, r) {
    return this.request({ method: "prompts/list", params: t }, LL, r)
  }
  async listResources(t, r) {
    return this.request({ method: "resources/list", params: t }, QL, r)
  }
  async listResourceTemplates(t, r) {
    return this.request(
      { method: "resources/templates/list", params: t },
      NL,
      r,
    )
  }
  async readResource(t, r) {
    return this.request({ method: "resources/read", params: t }, PL, r)
  }
  async subscribeResource(t, r) {
    return this.request({ method: "resources/subscribe", params: t }, sp, r)
  }
  async unsubscribeResource(t, r) {
    return this.request({ method: "resources/unsubscribe", params: t }, sp, r)
  }
  async callTool(t, r = qA, n) {
    return this.request({ method: "tools/call", params: t }, r, n)
  }
  async listTools(t, r) {
    return this.request({ method: "tools/list", params: t }, OL, r)
  }
  async sendRootsListChanged() {
    return this.notification({ method: "notifications/roots/list_changed" })
  }
}
var yz = require("child_process"),
  Cb = q(require("process"))
var kI = class {
  _buffer
  append(t) {
    this._buffer = this._buffer ? Buffer.concat([this._buffer, t]) : t
  }
  readMessage() {
    if (!this._buffer) return null
    let t = this._buffer.indexOf(`
`)
    if (t === -1) return null
    let r = this._buffer.toString("utf8", 0, t)
    return (this._buffer = this._buffer.subarray(t + 1)), KNe(r)
  }
  clear() {
    this._buffer = undefined
  }
}
function KNe(e) {
  return uz.parse(JSON.parse(e))
}
function Az(e) {
  return (
    JSON.stringify(e) +
    `
`
  )
}
var zNe =
  Cb.default.platform === "win32"
    ? [
        "APPDATA",
        "HOMEDRIVE",
        "HOMEPATH",
        "LOCALAPPDATA",
        "PATH",
        "PROCESSOR_ARCHITECTURE",
        "SYSTEMDRIVE",
        "SYSTEMROOT",
        "TEMP",
        "USERNAME",
        "USERPROFILE",
      ]
    : ["HOME", "LOGNAME", "PATH", "SHELL", "TERM", "USER"]
function VL() {
  let e = {}
  for (let t of zNe) {
    let r = Cb.default.env[t]
    r !== undefined && (r.startsWith("()") || (e[t] = r))
  }
  return e
}
var MI = class {
  _process
  _abortController = new AbortController()
  _readBuffer = new kI()
  _serverParams
  onclose
  onerror
  onmessage
  constructor(t) {
    this._serverParams = t
  }
  async start() {
    if (this._process)
      throw new Error(
        "StdioClientTransport already started! If using Client class, note that connect() calls start() automatically.",
      )
    return new Promise((t, r) => {
      ;(this._process = (0, yz.spawn)(
        this._serverParams.command,
        this._serverParams.args ?? [],
        {
          env: this._serverParams.env ?? VL(),
          stdio: ["pipe", "pipe", this._serverParams.stderr ?? "inherit"],
          shell: false,
          signal: this._abortController.signal,
          windowsHide: Cb.default.platform === "win32" && JNe(),
        },
      )),
        this._process.on("error", (n) => {
          if (n.name === "AbortError") {
            this.onclose?.()
            return
          }
          r(n), this.onerror?.(n)
        }),
        this._process.on("spawn", () => {
          t()
        }),
        this._process.on("close", (n) => {
          ;(this._process = undefined), this.onclose?.()
        }),
        this._process.stdin?.on("error", (n) => {
          this.onerror?.(n)
        }),
        this._process.stdout?.on("data", (n) => {
          this._readBuffer.append(n), this.processReadBuffer()
        }),
        this._process.stdout?.on("error", (n) => {
          this.onerror?.(n)
        })
    })
  }
  get stderr() {
    return this._process?.stderr ?? null
  }
  processReadBuffer() {
    for (;;)
      try {
        let t = this._readBuffer.readMessage()
        if (t === null) break
        this.onmessage?.(t)
      } catch (t) {
        this.onerror?.(t)
      }
  }
  async close() {
    this._abortController.abort(),
      (this._process = undefined),
      this._readBuffer.clear()
  }
  send(t) {
    return new Promise((r) => {
      if (!this._process?.stdin) throw new Error("Not connected")
      let n = Az(t)
      this._process.stdin.write(n) ? r() : this._process.stdin.once("drain", r)
    })
  }
}
function JNe() {
  return "type" in Cb.default
}
var Cz = q(_s())
var ToolType
;(function (e) {
  ;(e.readFile = "read-file"),
    (e.saveFile = "save-file"),
    (e.editFile = "edit-file"),
    (e.clarify = "clarify"),
    (e.onboardingSubAgent = "onboarding-sub-agent"),
    (e.launchProcess = "launch-process"),
    (e.killProcess = "kill-process"),
    (e.readProcess = "read-process"),
    (e.writeProcess = "write-process"),
    (e.listProcesses = "list-processes"),
    (e.waitProcess = "wait-process"),
    (e.openBrowser = "open-browser"),
    (e.strReplaceEditor = "str-replace-editor"),
    (e.diagnostics = "diagnostics"),
    (e.setupScript = "setup-script")
})(ToolType || (ToolType = {}))
var ToolHostType
;(function (e) {
  ;(e.remoteToolHost = "remoteToolHost"),
    (e.localToolHost = "localToolHost"),
    (e.sidecarToolHost = "sidecarToolHost"),
    (e.mcpHost = "mcpHost")
})(ToolHostType || (ToolHostType = {}))
var ContentType
;(function (e) {
  ;(e[(e.ContentText = 0)] = "ContentText"),
    (e[(e.ContentImage = 1)] = "ContentImage")
})(ContentType || (ContentType = {}))
var ToolSafetyLevel
;(function (e) {
  ;(e[(e.Unsafe = 0)] = "Unsafe"),
    (e[(e.Safe = 1)] = "Safe"),
    (e[(e.Check = 2)] = "Check")
})(ToolSafetyLevel || (ToolSafetyLevel = {}))
var En = class {
    name
    toolSafety
    constructor(t, r) {
      ;(this.name = t), (this.toolSafety = r)
    }
    version = 1
  },
  IntegrationServiceType
;(function (e) {
  ;(e[(e.Unknown = 0)] = "Unknown"),
    (e[(e.WebSearch = 1)] = "WebSearch"),
    (e[(e.GitHubApi = 8)] = "GitHubApi"),
    (e[(e.Linear = 12)] = "Linear"),
    (e[(e.Jira = 13)] = "Jira"),
    (e[(e.Confluence = 14)] = "Confluence"),
    (e[(e.Notion = 15)] = "Notion"),
    (e[(e.Supabase = 16)] = "Supabase"),
    (e[(e.Glean = 17)] = "Glean")
})(IntegrationServiceType || (IntegrationServiceType = {}))
var IntegrationServiceStatus
;(function (e) {
  ;(e[(e.UnknownStatus = 0)] = "UnknownStatus"),
    (e[(e.Available = 1)] = "Available"),
    (e[(e.UserConfigRequired = 2)] = "UserConfigRequired")
})(IntegrationServiceStatus || (IntegrationServiceStatus = {}))
var bz = require("child_process")
function cr(e, t) {
  return { text: e, isError: false, requestId: t }
}
function at(e, t) {
  return { text: e, isError: true, requestId: t }
}
function vz(e, t = false, r) {
  if (e.length === 0) return t ? at("No content provided", r) : cr("", r)
  let n = ""
  for (let i of e)
    if (i.type === ContentType.ContentText && i.text_content) {
      n = i.text_content
      break
    }
  return { text: n, isError: t, requestId: r, contentNodes: e }
}
var Eb = class e {
  _config
  _onStartupError
  _client = undefined
  _initializingPromise
  _closingPromise = undefined
  _cancelledByUser = false
  _toolDefinitions = undefined
  _runningTool = undefined
  _serverName
  _stdErrGenerator = undefined
  static maxTimeoutMs = 2147483647
  static defaultTimeoutMs = 2e9
  _logger = getLogger("McpHost")
  constructor(t, r = undefined, n) {
    ;(this._config = t),
      (this._onStartupError = n),
      (this._client = new TI(
        { name: "augment-mcp-client", version: "1.0.0" },
        { capabilities: {} },
      )),
      this.validateConfig(t),
      (this._serverName =
        t.name && t.name.length > 0
          ? this.sanitizeServerName(t.name)
          : this.extractServerName(t.command)),
      (this._initializingPromise = (async () => {
        if ((await r, this._closingPromise !== undefined))
          throw new Error("Client is closing")
        if (this._client === undefined) throw new Error("Client is undefined")
        let i = this._config.command,
          s = this._config.args || []
        this._config.useShellInterpolation &&
          (process.platform === "win32"
            ? ((s = ["/c", i]), (i = "cmd.exe"))
            : ((s = ["-c", i]), (i = "/bin/sh")))
        let o = new HL({
          command: i,
          args: s,
          env: { ...VL(), ...this._config.env },
          stderr: "pipe",
        })
        ;(this._stdErrGenerator = o),
          this._logger.debug(`Connecting to MCP server: "${t.name}"`),
          await this._client.connect(o),
          this._logger.debug(`Connected to MCP server: "${t.name}"`)
        let a = await this._client.listTools()
        this._logger.debug(`${t.name} has ${a?.tools.length} tools}`),
          (this._toolDefinitions =
            a?.tools.map((l) => {
              let c = this.createNamespacedToolName(l.name)
              return {
                definition: {
                  name: c,
                  description: l.description ?? "",
                  input_schema_json: JSON.stringify(l.inputSchema),
                  tool_safety: ToolSafetyLevel.Unsafe,
                  mcp_server_name: this._serverName,
                  mcp_tool_name: l.name,
                },
                identifier: { hostName: ToolHostType.mcpHost, toolId: c },
                isConfigured: true,
                enabled: true,
                toolSafety: ToolSafetyLevel.Unsafe,
              }
            }) ?? [])
      })()
        .catch((i) => {
          let s
          this._client !== undefined &&
            this._stdErrGenerator !== undefined &&
            (s = this._stdErrGenerator.capturedStderr)
          let o = [
            `Failed to connect to MCP server "${this._config.name}"`,
            `  Comment: ${this._config.command}`,
            `  Args: ${(this._config.args || []).join(" ")}`,
            `  Error: ${i instanceof Error ? i.message : String(i)}`,
            `  Stderr: ${s}`,
          ]
          this._logger.error(
            o.join(`
`),
          ),
            this._onStartupError({
              command: this._config.command,
              args: this._config.args,
              error: i instanceof Error ? i.message : String(i),
              ...(s !== undefined && { stderr: s }),
            })
        })
        .finally(() => {
          this._stdErrGenerator?.stopCapturing()
        }))
  }
  isRequestActive(t, r) {
    return (
      this._runningTool?.requestId === t && this._runningTool?.toolUseId === r
    )
  }
  close(t = false) {
    return (
      this._closingPromise === undefined &&
        ((this._cancelledByUser = t),
        (this._closingPromise = (async () => {
          let r = this._stdErrGenerator?._process?.pid
          if (
            this._config.useShellInterpolation &&
            (process.platform === "linux" || process.platform === "darwin") &&
            r
          )
            try {
              ;(0, bz.execSync)(`pkill -P ${r}`)
            } catch {}
          await (await this.getClient()).close()
        })())),
      this._closingPromise
    )
  }
  closeAllToolProcesses() {
    return Promise.resolve()
  }
  async getToolDefinitions() {
    return (
      await this.getClient(),
      this._toolDefinitions === undefined ? [] : this._toolDefinitions
    )
  }
  getAllToolDefinitions(t = true) {
    return this.getToolDefinitions()
  }
  getTool(t) {}
  getName() {
    return ToolHostType.mcpHost
  }
  async callTool(t, r, n, i, s) {
    let o = await this.getClient()
    if (this._closingPromise !== undefined) return at("MCP client is closing")
    this._runningTool = { requestId: t, toolUseId: r }
    let a = this.extractOriginalToolName(n),
      l
    try {
      let f = { timeout: this._config.timeoutMs ?? e.defaultTimeoutMs }
      l = await o.callTool({ name: a, arguments: i }, qA, f)
    } catch (f) {
      if (this._cancelledByUser) return at("Cancelled by user.")
      throw f
    } finally {
      this._runningTool = undefined
    }
    let c = typeof l.isError == "boolean" ? l.isError : false
    if (!Array.isArray(l.content))
      throw new Error("Unexpected result format: content is not an array")
    let u = []
    for (let f of l.content)
      typeof f.type == "string" &&
        (f.type === "image" &&
        f.data &&
        typeof f.data == "string" &&
        typeof f.mimeType == "string"
          ? u.push({
              type: ContentType.ContentImage,
              image_content: {
                media_type: String(f.mimeType),
                image_data: String(f.data),
              },
            })
          : f.type === "text" &&
            typeof f.text == "string" &&
            u.push({ type: ContentType.ContentText, text_content: String(f.text) }))
    if (u.length === 0) {
      let f = c ? "No result" : ""
      return c ? at(f) : cr(f)
    }
    if (u.length === 1) {
      let f = u[0]
      if (f.type === ContentType.ContentText)
        return c ? at(f.text_content || "", t) : cr(f.text_content || "", t)
    }
    return vz(u, c, t)
  }
  async checkToolCallSafe(t, r) {
    return Promise.resolve(false)
  }
  async getClient() {
    if ((await this._initializingPromise, this._client === undefined))
      throw new Error("Client is undefined")
    return this._client
  }
  validateConfig(t) {
    if (t?.timeoutMs !== undefined && t?.timeoutMs > e.maxTimeoutMs)
      throw new Error(
        `Timeout is too large: ${t.timeoutMs}, max is ${e.maxTimeoutMs}.`,
      )
  }
  sanitizeServerName(t) {
    return t.replace(/[^a-zA-Z0-9_-]/g, "_")
  }
  extractServerName(t) {
    let n = t.split(/\s+/)[0].split(/[/\\]/).pop() || "mcp"
    return this.sanitizeServerName(n)
  }
  _toolNameMap = new Map()
  createNamespacedToolName(t) {
    let r = (0, Cz.truncate)(`${t}_${this._serverName}`, {
      length: 64,
      omission: "",
    })
    return this._toolNameMap.set(r, t), r
  }
  extractOriginalToolName(t) {
    let r = this._toolNameMap.get(t)
    if (r) return r
    let n = `_${this._serverName}`
    return t.endsWith(n) ? t.substring(0, t.length - n.length) : t
  }
  factory(t) {
    return new e(this._config, t, this._onStartupError)
  }
}
var HL = class extends MI {
  _capturedStdErr = []
  _capturing = true
  async start() {
    await super.start()
    let t = this.stderr
    t &&
      t.on("data", (r) => {
        this._capturing && this._capturedStdErr.push(r.toString())
      })
  }
  get capturedStderr() {
    return this._capturedStdErr.join("")
  }
  stopCapturing() {
    this._capturing = false
  }
}
function Ez(e) {
  return Object.keys(e)
    .map((t) => Number.parseInt(t, 10))
    .filter((t) => !Number.isNaN(t))
}
var _z = require("child_process"),
  xz = require("util")
async function WA(e, t) {
  let r = (0, xz.promisify)(_z.exec)
  try {
    let { stdout: n } = await r(e, t)
    return n.trim()
  } catch {
    return
  }
}
var FI = class {
  toolId = IntegrationServiceType.GitHubApi
  constructor() {}
  async transform(t) {
    let r = await this.getGitInfo()
    return r
      ? {
          ...t,
          description:
            t.description +
            `

` +
            r,
        }
      : t
  }
  async getGitInfo() {
    let t = await Vi().getCwd()
    if (!t) return
    let r = { timeout: 1e3, cwd: t }
    try {
      let n = await WA("git rev-parse --show-toplevel", r)
      if (!n) return
      let i = { timeout: 1e3, cwd: n },
        [s, o, a, l] = await Promise.all([
          WA("git config --get remote.origin.url", i),
          WA("git rev-parse --abbrev-ref HEAD", i),
          WA("git rev-parse --abbrev-ref origin/HEAD", i),
          WA("git config --get user.email", i),
        ]),
        c = a?.split("/").pop(),
        u = ["Local Git Repository Information:"]
      return (
        n && u.push(`- Repository Root: ${n}`),
        s && u.push(`- Remote URL: ${s}`),
        o && u.push(`- Current Branch: ${o}`),
        c && u.push(`- Default Branch: ${c}`),
        l && u.push(`- Git User Email: ${l}`),
        u.push("REPOSITORY SCOPE:"),
        u.push(
          "All queries MUST be limited to this repository only, unless explicitly requested otherwise. Always indicate in text outside of the tool use that you are limiting to this repo if you are doing so.",
        ),
        u.join(`
`) +
          `
`
      )
    } catch {
      return
    }
  }
}
var QI = class e {
    _remoteInfoSource
    _abortController = undefined
    _toolMap = new Map()
    _logger = getLogger("RemoteToolHost")
    _transformationMap
    _cachedToolDefinitions = null
    _lastCacheUpdateTime = 0
    _cacheExpirationMs = 60 * 60 * 1e3
    constructor(t) {
      this._remoteInfoSource = t
      let r = new FI()
      this._transformationMap = new Map([[r.toolId, r]])
    }
    async getToolDefinitions(t = true) {
      let r = (await this._getToolDefinitions(t)).filter((n) => n.isConfigured)
      return (
        this._toolMap.clear(),
        r.forEach((n) => {
          this._toolMap.set(n.identifier.toolId, n)
        }),
        r
      )
    }
    async getAllToolDefinitions(t = true) {
      return await this._getToolDefinitions(t)
    }
    getTool(t) {}
    getName() {
      return ToolHostType.remoteToolHost
    }
    async _getToolDefinitions(t = true) {
      if (
        t &&
        this._cachedToolDefinitions !== null &&
        Date.now() - this._lastCacheUpdateTime < this._cacheExpirationMs
      )
        return this._cachedToolDefinitions
      this._logger.debug("Fetching remote tool definitions from backend")
      try {
        let r = Ez(IntegrationServiceType),
          n = await this._remoteInfoSource.retrieveRemoteTools(r),
          i = n
            .filter((c) => c.availabilityStatus === IntegrationServiceStatus.UserConfigRequired)
            .map((c) => c.remoteToolId),
          s = await this._remoteInfoSource.filterToolsWithExtraInput(i),
          o = (c) =>
            c.availabilityStatus === IntegrationServiceStatus.Available
              ? true
              : c.availabilityStatus === IntegrationServiceStatus.UserConfigRequired
                ? s.has(c.remoteToolId)
                : false,
          l = (
            await Promise.all(
              n.map(async (c) => {
                let u = this._transformationMap.get(c.remoteToolId)
                if (u) {
                  this._logger.debug(
                    `Applying transformation for ${c.remoteToolId}`,
                  )
                  let f = await u.transform(c.toolDefinition)
                  return { ...c, toolDefinition: f }
                }
                return c
              }),
            )
          ).map((c) => ({
            definition: c.toolDefinition,
            identifier: { hostName: ToolHostType.remoteToolHost, toolId: c.remoteToolId },
            isConfigured: o(c),
            enabled: true,
            toolSafety: c.toolSafety,
            oauthUrl: c.oauthUrl,
          }))
        return (
          (this._cachedToolDefinitions = l),
          (this._lastCacheUpdateTime = Date.now()),
          l
        )
      } catch (r) {
        return (
          this._logger.error("Failed to list remote tools", r),
          this._cachedToolDefinitions !== null
            ? (this._logger.info(
                "Using expired cache due to error fetching remote tools",
              ),
              this._cachedToolDefinitions)
            : []
        )
      }
    }
    findToolIdByName(t) {
      for (let [r, n] of this._toolMap.entries())
        if (n.definition.name.toString() === t) return r
      return IntegrationServiceType.Unknown
    }
    async callTool(t, r, n, i, s) {
      try {
        let o = (this._abortController = new AbortController()),
          a = this.findToolIdByName(n)
        if (!this._toolMap.get(a))
          return (
            this._logger.error(`Tool not found: ${n}`),
            { text: `Tool ${n} not found.`, isError: true }
          )
        let c = ho(),
          u = await this._remoteInfoSource.runRemoteTool(
            c,
            n,
            JSON.stringify(i),
            a,
            o.signal,
          )
        return (
          u.status !== _b.ExecutionSuccess &&
            this._logger.error(
              `Failed to run remote tool ${n}: ${_b[u.status]}`,
            ),
          {
            text: u.toolOutput,
            isError: u.status !== _b.ExecutionSuccess,
            requestId: c,
          }
        )
      } catch (o) {
        return {
          text: `Failed to run remote tool ${n} - ${o instanceof Error ? o.message : o}`,
          isError: true,
        }
      } finally {
        this._abortController = undefined
      }
    }
    checkToolCallSafe(t, r) {
      let n = this.findToolIdByName(t),
        i = this._toolMap.get(n)
      return i?.toolSafety === ToolSafetyLevel.Check
        ? yl().checkToolSafety(n, JSON.stringify(r))
        : Promise.resolve(i?.toolSafety === ToolSafetyLevel.Safe)
    }
    isRequestActive(t, r) {
      return this._abortController !== undefined
    }
    close(t = false) {
      return this._abortController?.abort(), Promise.resolve()
    }
    closeAllToolProcesses() {
      return Promise.resolve()
    }
    factory(t) {
      return new e(this._remoteInfoSource)
    }
  },
  _b
;(function (e) {
  ;(e[(e.ExecutionUnknownStatus = 0)] = "ExecutionUnknownStatus"),
    (e[(e.ExecutionSuccess = 1)] = "ExecutionSuccess"),
    (e[(e.NotFound = 2)] = "NotFound"),
    (e[(e.InvalidInput = 3)] = "InvalidInput"),
    (e[(e.ExecutionError = 4)] = "ExecutionError"),
    (e[(e.NotAvailable = 5)] = "NotAvailable"),
    (e[(e.AuthenticationError = 6)] = "AuthenticationError")
})(_b || (_b = {}))
var GA = class {
  _tools
  hostName
  _unsupportedTools
  _runningTool = undefined
  _abortController = undefined
  constructor(t, r, n) {
    ;(this._tools = t), (this.hostName = r), (this._unsupportedTools = n)
  }
  getToolDefinitions() {
    return Promise.resolve(
      this._tools
        .filter((t) => !this._unsupportedTools?.has(t.name))
        .map((t) => ({
          definition: {
            name: t.name,
            description: t.description,
            input_schema_json: t.inputSchemaJson,
            tool_safety: t.toolSafety,
          },
          identifier: { hostName: this.hostName, toolId: t.name },
          isConfigured: true,
          enabled: true,
          toolSafety: t.toolSafety,
        })),
    )
  }
  getAllToolDefinitions(t = true) {
    return this.getToolDefinitions()
  }
  getTool(t) {
    return this._tools.find((r) => r.name === t)
  }
  getName() {
    return this.hostName
  }
  async callTool(t, r, n, i, s) {
    let o = this._tools.find((a) => a.name.toString() === n)
    if (o === undefined) return { isError: true, text: `Tool ${n} not found.` }
    this._runningTool = { requestId: t, toolUseId: r, tool: o }
    try {
      let a = (this._abortController = new AbortController())
      return await o.call(i, s, a.signal)
    } finally {
      ;(this._runningTool = undefined), (this._abortController = undefined)
    }
  }
  async checkToolCallSafe(t, r) {
    let n = this._tools.find((i) => i.name === t)
    return n === undefined ? Promise.resolve(false) : n.checkToolCallSafe(r)
  }
  isRequestActive(t, r) {
    return (
      this._runningTool?.requestId === t && this._runningTool?.toolUseId === r
    )
  }
  close(t = false) {
    return this._abortController?.abort(), Promise.resolve()
  }
  closeAllToolProcesses() {
    return Promise.resolve()
  }
}
function yc(e, t, r = false) {
  let n = [...e]
  return n.length <= t
    ? e
    : r
      ? t <= 3
        ? "..."
        : "..." + n.slice(3 - t).join("")
      : n.slice(0, Math.max(t - 3, 0)).join("") + "..."
}
function NI(e, t) {
  if (e.length <= t || e.length === 0) return e
  let r = e.split(`
`),
    i =
      "... additional lines truncated ..." + (r[0].endsWith("\r") ? "\r" : ""),
    s = ""
  if (r.length < 2 || r[0].length + r[r.length - 1].length + i.length > t) {
    let o = Math.floor(t / 2)
    s = [e.slice(0, o), "<...>", e.slice(-o)].join("")
  } else {
    let o = [],
      a = [],
      l = i.length + 1
    for (let c = 0; c < Math.floor(r.length / 2); c++) {
      let u = r[c],
        f = r[r.length - 1 - c],
        p = u.length + f.length + 2
      if (l + p > t) break
      ;(l += p), o.push(u), a.push(f)
    }
    o.push(i),
      o.push(...a.reverse()),
      (s = o.join(`
`))
  }
  return s
}
var xb = class extends En {
  _maxRetrievalSize = 2e4
  constructor() {
    super(Hi.codebaseRetrieval, ToolSafetyLevel.Safe)
  }
  description = `This tool is Augment's context engine, the world's best codebase context engine. It:
1. Takes in a natural language description of the code you are looking for;
2. Uses a proprietary retrieval/embedding model suite that produces the highest-quality recall of relevant code snippets from across the codebase;
3. Maintains a real-time index of the codebase, so the results are always up-to-date and reflects the current state of the codebase;
4. Can retrieve across different programming languages;
5. Only reflects the current state of the codebase on the disk, and has no information on version control or code history.`
  inputSchemaJson = JSON.stringify({
    type: "object",
    properties: {
      information_request: {
        type: "string",
        description: "A description of the information you need.",
      },
    },
    required: ["information_request"],
  })
  version = 2
  checkToolCallSafe(t) {
    return true
  }
  async call(t, r, n) {
    let i = ho()
    try {
      let s = t.information_request,
        o = await yl().agentCodebaseRetrieval(
          i,
          s,
          r,
          this._maxRetrievalSize,
          n,
        ),
        a = yc(o.formattedRetrieval, this._maxRetrievalSize)
      return cr(a, i)
    } catch (s) {
      return at(
        `Failed to retrieve codebase information: ${s instanceof Error ? s.message : String(s)}`,
        i,
      )
    }
  }
}
var wb = class extends En {
  _checkpointManager
  constructor(t) {
    super(Hi.removeFiles, ToolSafetyLevel.Safe), (this._checkpointManager = t)
  }
  description =
    "Remove files. ONLY use this tool to delete files in the user's workspace. This is the only safe tool to delete files in a way that the user can undo the change. Do NOT use the shell or launch-process tools to remove files."
  inputSchemaJson = JSON.stringify({
    type: "object",
    properties: {
      file_paths: {
        type: "array",
        description: "The paths of the files to remove.",
        items: { type: "string" },
      },
    },
    required: ["file_paths"],
  })
  checkToolCallSafe(t) {
    return true
  }
  async call(t, r, n) {
    let i = t.file_paths,
      s = 0,
      o
    try {
      for (let a of i) {
        let l = await Vi().readFile(a)
        if (l === undefined || l.contents === undefined || l.filepath === undefined) {
          o = `Cannot read file: ${a}`
          break
        }
        let c = l.filepath,
          u = l.contents,
          f = new DiffViewDocument(c, u, undefined, {}),
          p = r.at(-1)?.request_id ?? ho(),
          g = this._checkpointManager.currentConversationId ?? ""
        try {
          await this._checkpointManager.addCheckpoint(
            { conversationId: g, path: c },
            {
              sourceToolCallRequestId: p,
              timestamp: Date.now(),
              document: f,
              conversationId: g,
            },
          ),
            s++
        } catch (m) {
          o = `Failed to delete file ${a}: ${m instanceof Error ? m.message : String(m)}`
          break
        }
      }
    } catch (a) {
      o = `Failed to remove file(s): ${a instanceof Error ? a.message : String(a)}`
    }
    return s === i.length && o === undefined
      ? cr(`File(s) removed: ${i.slice(0, s).join(", ")}`)
      : at(
          `Removed file(s) ${i.slice(0, s).join(", ")} but failed to remove file(s): ${i.slice(s).join(", ")}: ${o ?? ""}`,
        )
  }
}
function wz(e) {
  let t = [],
    r = ""
  for (let n = 0; n < e.length; n++) {
    let i = e[n]
    ;/[a-zA-Z0-9_]/.test(i)
      ? (r += i)
      : /\s/.test(i)
        ? r && (t.push(r), (r = ""))
        : (r && (t.push(r), (r = "")), t.push(i))
  }
  return r && t.push(r), t
}
function jNe(e, t, r = 100) {
  let n = e.length,
    i = t.length,
    s = Array.from({ length: n }).fill(-1)
  if (n === 0 || i === 0) return s
  let o = Array.from({ length: n + 1 })
      .fill([])
      .map(() => Array.from({ length: 2 * r + 1 }).fill(0)),
    a = Array.from({ length: n + 1 })
      .fill([])
      .map(() => Array.from({ length: 2 * r + 1 }).fill([0, 0]))
  for (let m = 1; m <= n; m++) {
    let y = Math.max(1, m - r),
      v = Math.min(i, m + r)
    for (let C = y; C <= v; C++) {
      let E = C - (m - r)
      if (e[m - 1] === t[C - 1]) {
        let w = m - 1,
          B = C - 1
        if (B >= Math.max(1, w - r) && B <= Math.min(i, w + r)) {
          let T = B - (w - r)
          ;(o[m][E] = o[w][T] + 1), (a[m][E] = [-1, -1])
        } else (o[m][E] = 1), (a[m][E] = [-1, -1])
      } else {
        let w = 0,
          B = 0
        C - 1 >= y && (w = o[m][E - 1])
        let T = m - 1
        if (C >= Math.max(1, T - r) && C <= Math.min(i, T + r)) {
          let N = C - (T - r)
          B = o[T][N]
        }
        w >= B
          ? ((o[m][E] = w), (a[m][E] = [0, -1]))
          : ((o[m][E] = B), (a[m][E] = [-1, 0]))
      }
    }
  }
  let l = n,
    c = i,
    u = 0,
    f = i,
    p = Math.max(1, n - r),
    g = Math.min(i, n + r)
  for (let m = p; m <= g; m++) {
    let y = m - (n - r)
    o[n][y] > u && ((u = o[n][y]), (f = m))
  }
  for (l = n, c = f; l > 0 && c > 0; ) {
    let m = c - (l - r)
    if (m < 0 || m >= 2 * r + 1) break
    let [y, v] = a[l][m]
    if (
      (y === -1 && v === -1 && (s[l - 1] = c - 1),
      (l += y),
      (c += v),
      y === 0 && v === 0)
    )
      break
  }
  return s
}
function Sz(e, t) {
  let r = e.map((f) => wz(f)),
    n = t.map((f) => wz(f))
  function i(f) {
    let p = [],
      g = []
    for (let m = 0; m < f.length; m++)
      for (let y = 0; y < f[m].length; y++) p.push(f[m][y]), g.push(m)
    return [p, g]
  }
  let [s, o] = i(r),
    [a, l] = i(n),
    c = jNe(s, a),
    u = Array.from({ length: e.length })
      .fill([])
      .map(() => [])
  for (let f = 0; f < c.length; f++) {
    let p = c[f]
    if (p !== -1) {
      let g = o[f],
        m = l[p]
      u[g].includes(m) || u[g].push(m)
    }
  }
  return u
}
var ZNe = 5e4,
  XNe =
    "<response clipped><NOTE>To save on context only part of this file has been shown to you.</NOTE>"
function e2e(e) {
  let t = e.includes(`\r
`)
    ? `\r
`
    : `
`
  return e
    .split(t)
    .map((i) => i.replace(/\s+$/, ""))
    .join(t)
}
function Iz(e, t, r = 1, n) {
  ;(e = t2e(e)),
    (e = e
      .split(
        `
`,
      )
      .map((s, o) => `${String(o + r).padStart(6)}	${s}`).join(`
`))
  let i = `Here's the result of running \`cat -n\` on ${t}:
${e}
`
  return (
    n !== undefined &&
      (i += `Total lines in file: ${n}
`),
    i
  )
}
function t2e(e, t = ZNe) {
  return e.length <= t ? e : e.slice(0, t) + XNe
}
function WL(e) {
  return e.replaceAll(
    `\r
`,
    `
`,
  )
}
function r2e(e) {
  return e.includes(`\r
`)
    ? `\r
`
    : `
`
}
function $A(e) {
  let t = r2e(e)
  return { content: WL(e2e(e)), originalLineEnding: t }
}
function GL(e, t) {
  return t ===
    `
`
    ? e
    : e.replaceAll(
        `
`,
        t,
      )
}
function Bz(e, t, r) {
  let n = ""
  if (
    !Array.isArray(e) ||
    e.length !== 2 ||
    !e.every((o) => typeof o == "number")
  )
    return (
      (n = `Invalid view range provided. Showing entire file (lines 1-${t}).`),
      { initLine: 1, finalLine: t, message: n }
    )
  let i = e[0],
    s = e[1]
  if (
    (i < 1
      ? ((n += `Start line ${i} is less than 1. Adjusted to 1.
`),
        (i = 1))
      : i > t &&
        ((n += `Start line ${i} exceeds file length (${t}). Adjusted to 1.
`),
        (i = 1)),
    s === -1)
  )
    s = t
  else if (s > t)
    (n += `End line ${s} exceeds file length (${t}). Adjusted to ${t}. `),
      (s = t)
  else if (s < i)
    (n += `End line ${s} is less than start line ${i}. Adjusted to ${t}. `),
      (s = t)
  else if (s - i + 1 < r) {
    let o = Math.min(i + r - 1, t)
    ;(n += `View range expanded to meet minimum size of ${r} lines. `),
      o >= t
        ? (n += `End line adjusted to last line of file (${t}).`)
        : (n += `New range: [${i}, ${o}].`),
      (s = o)
  }
  return (n = n.trim()), { initLine: i, finalLine: s, message: n }
}
function n2e(e, t, r, n) {
  let i = Math.max(0, t - n),
    s = t + r - 1 + n
  return (
    (e = e.replaceAll(
      `\r
`,
      `
`,
    )),
    {
      snippet: e
        .split(
          `
`,
        )
        .slice(i, s + 1).join(`
`),
      startLine: i,
    }
  )
}
function PI(e, t, r, n) {
  let { snippet: i, startLine: s } = n2e(e, t, r, n)
  return i
    .split(
      `
`,
    )
    .map((a, l) => `${String(l + s + 1).padStart(6)}	${a}`).join(`
`)
}
function LI(e) {
  let t = e.split(`
`),
    r = 0,
    n = 0,
    i = 0
  for (let s of t) {
    if (s.trim() === "") continue
    let o = s.match(/^( +)/),
      a = s.match(/^(\t+)/)
    o ? (r++, i === 0 && (i = o[1].length)) : a && n++
  }
  return n > r ? { type: "tab", size: 1 } : { type: "space", size: i || 2 }
}
function $L(e, t) {
  let r = e.split(`
`),
    n = t.type === "tab" ? /^\t/ : new RegExp(`^ {1,${t.size}}`)
  return r.map((i) => i.replace(n, "")).join(`
`)
}
function YL(e, t) {
  return e
    .split(
      `
`,
    )
    .every((n) => {
      if (n.trim() === "") return true
      let i = t.type === "tab" ? /^\t/ : new RegExp(`^ {1,${t.size}}`)
      return n.match(i)
    })
}
function KL(e, t) {
  let r = e.split(`
`),
    n = t.split(`
`),
    i = []
  if (t.trim() === "" || n.length > r.length) return i
  if (n.length === 1)
    return (
      r.forEach((c, u) => {
        c.includes(t) && i.push({ startLine: u, endLine: u })
      }),
      i
    )
  let s = e,
    o = t,
    a = 0,
    l
  for (; (l = s.indexOf(o, a)) !== -1; ) {
    let c = s.substring(0, l),
      u = s.substring(0, l + o.length),
      f = (c.match(/\n/g) || []).length,
      p = (u.match(/\n/g) || []).length
    i.push({ startLine: f, endLine: p }), (a = l + 1)
  }
  return i
}
function Rz(e, t, r, n) {
  if (e.length === 0) return -1
  if (e.length === 1) return 0
  for (let u = 0; u < e.length; u++) {
    let f = e[u]
    if (f.startLine === t && f.endLine === r) return u
  }
  if (n === 0) return -1
  let i = -1,
    s = Number.MAX_SAFE_INTEGER
  for (let u = 0; u < e.length; u++) {
    let f = e[u],
      p = Math.abs(f.startLine - t)
    p < s && ((s = p), (i = u))
  }
  if (n === 1) return i
  if (i === -1) return -1
  let o = Number.MAX_SAFE_INTEGER,
    a = -1
  for (let u = 0; u < e.length; u++) {
    if (u === i) continue
    let f = e[u],
      p = Math.abs(f.startLine - t)
    p < o && ((o = p), (a = u))
  }
  let l = Math.abs(e[a].startLine - e[i].startLine),
    c = Math.floor((l / 2) * n)
  return s <= c ? i : -1
}
function UI(e) {
  if (e === undefined)
    throw new Error(
      "Missing required parameter `str_replace_entries` for `str_replace` command.",
    )
  if (!Array.isArray(e))
    throw new Error(
      "Invalid parameter `str_replace_entries` for `str_replace` command. It must be an array of objects.",
    )
  if (e.length === 0)
    throw new Error(
      "Empty required parameter `str_replace_entries` for `str_replace` command.",
    )
  let t = []
  for (let [r, n] of e.entries()) {
    if (typeof n != "object" || !n)
      throw new Error(
        "Invalid parameter `str_replace_entries` for `str_replace` command. It must be an array of objects.",
      )
    let i = n
    if (i.old_str === undefined)
      throw new Error(
        "Missing required parameter `old_str` for `str_replace` command.",
      )
    if (i.new_str === undefined)
      throw new Error(
        "Missing required parameter `new_str` for `str_replace` command.",
      )
    if (
      (i.old_str_start_line_number === 0 &&
        (i.old_str_start_line_number = undefined),
      i.old_str_end_line_number === 0 && (i.old_str_end_line_number = undefined),
      i.old_str_start_line_number !== undefined &&
        (!Number.isInteger(i.old_str_start_line_number) ||
          i.old_str_start_line_number < 1))
    )
      throw new Error(
        "Invalid parameter `old_str_start_line_number` for `str_replace` command. It must be a positive integer.",
      )
    if (
      i.old_str_end_line_number !== undefined &&
      (!Number.isInteger(i.old_str_end_line_number) ||
        i.old_str_end_line_number < 1)
    )
      throw new Error(
        "Invalid parameter `old_str_end_line_number` for `str_replace` command. It must be a positive integer.",
      )
    t.push({
      index: i.index ?? r,
      old_str: i.old_str,
      new_str: i.new_str,
      old_str_start_line_number: i.old_str_start_line_number,
      old_str_end_line_number: i.old_str_end_line_number,
    })
  }
  return t
}
function Dz(e) {
  return (
    (e = i2e(e)),
    e.sort((t, r) => {
      let n = t.old_str_start_line_number ?? -1
      return (r.old_str_start_line_number ?? -1) - n
    }),
    e
  )
}
function Tz(e, t) {
  let r = e.old_str_start_line_number,
    n = e.old_str_end_line_number
  if (!(r === undefined || n === undefined))
    for (let i of t) {
      if (
        e.index == i.index ||
        i.old_str_start_line_number === undefined ||
        i.old_str_end_line_number === undefined
      )
        continue
      let s = {
        startLine: i.old_str_start_line_number,
        endLine: i.old_str_end_line_number,
      }
      if (
        (r <= s.startLine && s.startLine <= n) ||
        (r <= s.endLine && s.endLine <= n) ||
        (s.startLine <= r && r <= s.endLine)
      )
        return i
    }
}
function kz(e, t) {
  let r = e.old_str_start_line_number + 1,
    n = e.old_str_end_line_number + 1,
    i = t.old_str_start_line_number + 1,
    s = t.old_str_end_line_number + 1
  return `old_str line numbers range overlaps with another entry.
This entry range: [${r}-${n}]
Overlapping entry index: ${t.index}
Overlapping entry range: [${i}-${s}]`
}
function OI(e) {
  if (e === undefined)
    throw new Error(
      "Missing required parameter `insert_line_entries` for `insert` command.",
    )
  if (!Array.isArray(e))
    throw new Error(
      "Invalid parameter `insert_line_entries` for `insert` command. It must be an array of objects.",
    )
  if (e.length === 0)
    throw new Error(
      "Empty required parameter `insert_line_entries` for `insert` command.",
    )
  let t = []
  for (let [r, n] of e.entries()) {
    if (typeof n != "object" || !n)
      throw new Error(
        "Invalid parameter `insert_line_entries` for `insert` command. It must be an array of objects.",
      )
    let i = n
    if (i.insert_line === undefined)
      throw new Error(
        "Missing required parameter `insert_line` for `insert` command.",
      )
    if (i.new_str === undefined)
      throw new Error(
        "Missing required parameter `new_str` for `insert` command.",
      )
    if (!Number.isInteger(i.insert_line) || i.insert_line < 0)
      throw new Error(
        "Invalid parameter `insert_line` for `insert` command. It must be a non-negative integer.",
      )
    t.push({
      index: i.index ?? r,
      insert_line: i.insert_line,
      new_str: i.new_str,
    })
  }
  return t
}
function i2e(e) {
  return e.map((t) => ({
    ...t,
    old_str_start_line_number:
      t.old_str_start_line_number !== undefined
        ? t.old_str_start_line_number - 1
        : undefined,
    old_str_end_line_number:
      t.old_str_end_line_number !== undefined
        ? t.old_str_end_line_number - 1
        : undefined,
  }))
}
function Mz(e, t) {
  t = t.replaceAll(
    `\r
`,
    `
`,
  )
  let r = e.newContent.split(`
`),
    n = t.split(`
`),
    i = Sz(r, n)
  ;(e.newStrStartLineNumber =
    i[e.newStrStartLineNumber][0] ?? e.newStrStartLineNumber),
    (e.newStrEndLineNumber =
      i[e.newStrEndLineNumber][i[e.newStrEndLineNumber].length - 1] ??
      e.newStrEndLineNumber)
}
function Fz(e) {
  let t = []
  if ("old_str" in e && "new_str" in e) {
    let n = { index: 0, old_str: e.old_str, new_str: e.new_str }
    "old_str_start_line_number" in e &&
      (n.old_str_start_line_number = e.old_str_start_line_number),
      "old_str_end_line_number" in e &&
        (n.old_str_end_line_number = e.old_str_end_line_number),
      t.push(n)
  }
  let r = Object.keys(e).filter(
    (n) => n.startsWith("old_str_") && /^old_str_\d+$/.test(n),
  )
  r.sort((n, i) => {
    let s = parseInt(n.replace("old_str_", "")),
      o = parseInt(i.replace("old_str_", ""))
    return s - o
  })
  for (let n of r) {
    let i = n.replace("old_str_", "")
    if (`new_str_${i}` in e) {
      let s = {
        index: parseInt(i),
        old_str: e[`old_str_${i}`],
        new_str: e[`new_str_${i}`],
      }
      ;`old_str_start_line_number_${i}` in e &&
        (s.old_str_start_line_number = e[`old_str_start_line_number_${i}`]),
        `old_str_end_line_number_${i}` in e &&
          (s.old_str_end_line_number = e[`old_str_end_line_number_${i}`]),
        t.push(s)
    }
  }
  return t
}
function Qz(e) {
  let t = []
  "insert_line" in e &&
    "new_str" in e &&
    t.push({ index: 0, insert_line: e.insert_line, new_str: e.new_str })
  let r = Object.keys(e).filter(
    (n) => n.startsWith("insert_line_") && /^insert_line_\d+$/.test(n),
  )
  r.sort((n, i) => {
    let s = parseInt(n.replace("insert_line_", "")),
      o = parseInt(i.replace("insert_line_", ""))
    return s - o
  })
  for (let n of r) {
    let i = n.replace("insert_line_", "")
    ;`new_str_${i}` in e &&
      t.push({
        index: parseInt(i),
        insert_line: e[`insert_line_${i}`],
        new_str: e[`new_str_${i}`],
      })
  }
  return t
}
var qI = class {
  _logger
  constructor() {
    this._logger = getLogger("StrReplaceEditorToolDefinitionFlat")
  }
  extractStrReplaceEntries(t) {
    let r = Fz(t)
    this._logger.debug(
      `Extracted ${r.length} str_replace entries from flat schema`,
    )
    let n = UI(r)
    return (
      this._logger.debug(
        `Validated ${n.length} str_replace entries from flat schema`,
      ),
      n
    )
  }
  extractInsertLineEntries(t) {
    let r = Qz(t)
    this._logger.debug(`Extracted ${r.length} insert entries from flat schema`)
    let n = OI(r)
    return (
      this._logger.debug(
        `Validated ${n.length} insert entries from flat schema`,
      ),
      n
    )
  }
  description =
    "Custom editing tool for viewing, creating and editing files\n* `path` is a file path relative to the workspace root\n* command `view` displays the result of applying `cat -n`.\n* If a `command` generates a long output, it will be truncated and marked with `<response clipped>`\n* `insert` and `str_replace` commands output a snippet of the edited section for each entry. This snippet reflects the final state of the file after all edits and IDE auto-formatting have been applied.\n\n\nNotes for using the `str_replace` command:\n* Specify `old_str_1`, `new_str_1`, `old_str_start_line_number_1` and `old_str_end_line_number_1` properties for the first replacement, `old_str_2`, `new_str_2`, `old_str_start_line_number_2` and `old_str_end_line_number_2` for the second replacement, and so on\n* The `old_str_start_line_number_1` and `old_str_end_line_number_1` parameters are 1-based line numbers\n* Both `old_str_start_line_number_1` and `old_str_end_line_number_1` are INCLUSIVE\n* The `old_str_1` parameter should match EXACTLY one or more consecutive lines from the original file. Be mindful of whitespace!\n* Empty `old_str_1` is allowed only when the file is empty or contains only whitespaces\n* It is important to specify `old_str_start_line_number_1` and `old_str_end_line_number_1` to disambiguate between multiple occurrences of `old_str_1` in the file\n* Make sure that `old_str_start_line_number_1` and `old_str_end_line_number_1` do not overlap with other `old_str_start_line_number_2` and `old_str_end_line_number_2` entries\n* The `new_str_1` parameter should contain the edited lines that should replace the `old_str_1`. Can be an empty string to delete content\n* To make multiple replacements in one tool call add multiple sets of replacement parameters. For example, `old_str_1`, `new_str_1`, `old_str_start_line_number_1` and `old_str_end_line_number_1` properties for the first replacement, `old_str_2`, `new_str_2`, `old_str_start_line_number_2`, `old_str_end_line_number_2` for the second replacement, etc.\n\nNotes for using the `insert` command:\n* Specify `insert_line_1` and `new_str_1` properties for the first insertion, `insert_line_2` and `new_str_2` for the second insertion, and so on\n* The `insert_line_1` parameter specifies the line number after which to insert the new string\n* The `insert_line_1` parameter is 1-based line number\n* To insert at the very beginning of the file, use `insert_line_1: 0`\n* To make multiple insertions in one tool call add multiple sets of insertion parameters. For example, `insert_line_1` and `new_str_1` properties for the first insertion, `insert_line_2` and `new_str_2` for the second insertion, etc.\n\nNotes for using the `view` command:\n* Strongly prefer to use larger ranges of at least 500 lines when scanning through files. One call with large range is much more efficient than many calls with small ranges\n\nIMPORTANT:\n* This is the only tool you should use for editing files.\n* If it fails try your best to fix inputs and retry.\n* DO NOT fall back to removing the whole file and recreating it from scratch.\n* DO NOT use sed or any other command line tools for editing files.\n* Try to fit as many edits in one tool call as possible\n* Use view command to read the file before editing it.\n"
  inputSchemaJson = JSON.stringify({
    type: "object",
    properties: {
      command: {
        type: "string",
        enum: ["view", "str_replace", "insert"],
        description:
          "The commands to run. Allowed options are: 'view', 'str_replace', 'insert'.",
      },
      path: {
        description:
          "Full path to file relative to the workspace root, e.g. 'services/api_proxy/file.py' or 'services/api_proxy'.",
        type: "string",
      },
      view_range: {
        description:
          "Optional parameter of `view` command when `path` points to a file. If none is given, the full file is shown. If provided, the file will be shown in the indicated line number range, e.g. [501, 1000] will show lines from 501 to 1000. Indices are 1-based and inclusive. Setting `[start_line, -1]` shows all lines from `start_line` to the end of the file.",
        type: "array",
        items: { type: "integer" },
      },
      insert_line_1: {
        description:
          "Required parameter of `insert` command. The line number after which to insert the new string. This line number is relative to the state of the file before any insertions in the current tool call have been applied.",
        type: "integer",
      },
      new_str_1: {
        description:
          "Required parameter of `str_replace` command containing the new string. Can be an empty string to delete content. Required parameter of `insert` command containing the string to insert.",
        type: "string",
      },
      old_str_1: {
        description:
          "Required parameter of `str_replace` command containing the string in `path` to replace.",
        type: "string",
      },
      old_str_start_line_number_1: {
        description:
          "The line number of the first line of `old_str_1` in the file. This is used to disambiguate between multiple occurrences of `old_str_1` in the file.",
        type: "integer",
      },
      old_str_end_line_number_1: {
        description:
          "The line number of the last line of `old_str_1` in the file. This is used to disambiguate between multiple occurrences of `old_str_1` in the file.",
        type: "integer",
      },
    },
    required: ["command", "path"],
  })
}
var VI = class {
  _logger
  constructor() {
    this._logger = getLogger("StrReplaceEditorToolDefinitionNested")
  }
  extractStrReplaceEntries(t) {
    let r = UI(t.str_replace_entries)
    return this._logger.debug(`Validated ${r.length} str_replace entries`), r
  }
  extractInsertLineEntries(t) {
    let r = OI(t.insert_line_entries)
    return this._logger.debug(`Validated ${r.length} insert entries`), r
  }
  description =
    "Custom editing tool for viewing, creating and editing files\n* `path` is a file path relative to the workspace root\n* command `view` displays the result of applying `cat -n`.\n* If a `command` generates a long output, it will be truncated and marked with `<response clipped>`\n* `insert` and `str_replace` commands output a snippet of the edited section for each entry. This snippet reflects the final state of the file after all edits and IDE auto-formatting have been applied.\n\n\nNotes for using the `str_replace` command:\n* Use the `str_replace_entries` parameter with an array of objects\n* Each object should have `old_str`, `new_str`, `old_str_start_line_number` and `old_str_end_line_number` properties\n* The `old_str_start_line_number` and `old_str_end_line_number` parameters are 1-based line numbers\n* Both `old_str_start_line_number` and `old_str_end_line_number` are INCLUSIVE\n* The `old_str` parameter should match EXACTLY one or more consecutive lines from the original file. Be mindful of whitespace!\n* Empty `old_str` is allowed only when the file is empty or contains only whitespaces\n* It is important to specify `old_str_start_line_number` and `old_str_end_line_number` to disambiguate between multiple occurrences of `old_str` in the file\n* Make sure that `old_str_start_line_number` and `old_str_end_line_number` do not overlap with other entries in `str_replace_entries`\n* The `new_str` parameter should contain the edited lines that should replace the `old_str`. Can be an empty string to delete content\n\nNotes for using the `insert` command:\n* Use the `insert_line_entries` parameter with an array of objects\n* Each object should have `insert_line` and `new_str` properties\n* The `insert_line` parameter specifies the line number after which to insert the new string\n* The `insert_line` parameter is 1-based line number\n* To insert at the very beginning of the file, use `insert_line: 0`\n\nNotes for using the `view` command:\n* Strongly prefer to use larger ranges of at least 500 lines when scanning through files. One call with large range is much more efficient than many calls with small ranges\n\nIMPORTANT:\n* This is the only tool you should use for editing files.\n* If it fails try your best to fix inputs and retry.\n* DO NOT fall back to removing the whole file and recreating it from scratch.\n* DO NOT use sed or any other command line tools for editing files.\n* Try to fit as many edits in one tool call as possible\n* Use view command to read the file before editing it.\n"
  inputSchemaJson = JSON.stringify({
    type: "object",
    properties: {
      command: {
        type: "string",
        enum: ["view", "str_replace", "insert"],
        description:
          "The commands to run. Allowed options are: 'view', 'str_replace', 'insert'.",
      },
      path: {
        description:
          "Full path to file relative to the workspace root, e.g. 'services/api_proxy/file.py' or 'services/api_proxy'.",
        type: "string",
      },
      view_range: {
        description:
          "Optional parameter of `view` command when `path` points to a file. If none is given, the full file is shown. If provided, the file will be shown in the indicated line number range, e.g. [501, 1000] will show lines from 501 to 1000. Indices are 1-based and inclusive. Setting `[start_line, -1]` shows all lines from `start_line` to the end of the file.",
        type: "array",
        items: { type: "integer" },
      },
      insert_line_entries: {
        description:
          "Required parameter of `insert` command. A list of entries to insert. Each entry is a dictionary with keys `insert_line` and `new_str`.",
        type: "array",
        items: {
          type: "object",
          properties: {
            insert_line: {
              description:
                "The line number after which to insert the new string. This line number is relative to the state of the file before any insertions in the current tool call have been applied.",
              type: "integer",
            },
            new_str: {
              description: "The string to insert. Can be an empty string.",
              type: "string",
            },
          },
          required: ["insert_line", "new_str"],
        },
      },
      str_replace_entries: {
        description:
          "Required parameter of `str_replace` command. A list of entries to replace. Each entry is a dictionary with keys `old_str`, `old_str_start_line_number`, `old_str_end_line_number` and `new_str`. `old_str` from different entries should not overlap.",
        type: "array",
        items: {
          type: "object",
          properties: {
            old_str: {
              description: "The string in `path` to replace.",
              type: "string",
            },
            old_str_start_line_number: {
              description:
                "The line number of the first line of `old_str` in the file. This is used to disambiguate between multiple occurrences of `old_str` in the file.",
              type: "integer",
            },
            old_str_end_line_number: {
              description:
                "The line number of the last line of `old_str` in the file. This is used to disambiguate between multiple occurrences of `old_str` in the file.",
              type: "integer",
            },
            new_str: {
              description:
                "The string to replace `old_str` with. Can be an empty string to delete content.",
              type: "string",
            },
          },
          required: [
            "old_str",
            "new_str",
            "old_str_start_line_number",
            "old_str_end_line_number",
          ],
        },
      },
    },
    required: ["command", "path"],
  })
}
var zL = 4,
  op = class extends En {
    _checkpointManager
    _lineNumberErrorTolerance
    _waitForAutoFormatMs
    _logger
    _toolDefinition
    constructor(t, r = 0.2, n = 1e3, i) {
      super(Hi.strReplaceEditor, ToolSafetyLevel.Safe),
        (this._checkpointManager = t),
        (this._lineNumberErrorTolerance = r),
        (this._waitForAutoFormatMs = n),
        i
          ? (this._toolDefinition = i)
          : _a().flags.agentEditToolSchemaType ===
              "StrReplaceEditorToolDefinitionFlat"
            ? (this._toolDefinition = new qI())
            : (this._toolDefinition = new VI()),
        (this.description = this._toolDefinition.description),
        (this.inputSchemaJson = this._toolDefinition.inputSchemaJson),
        (this._logger = getLogger("StrReplaceEditorTool")),
        this._logger.debug(
          `Initialized with params: lineNumberErrorTolerance=${r}, waitForAutoFormatSec=${n}`,
        )
    }
    description
    inputSchemaJson
    checkToolCallSafe(t) {
      return true
    }
    async readFile(t) {
      this._logger.debug(`Reading file: ${t}`)
      try {
        let r = await Vi().readFile(t)
        if (r === undefined || r.contents === undefined || r.filepath === undefined)
          throw (
            (this._logger.error(
              `Failed to read file: ${t} - file details undefined`,
            ),
            new Error(`Cannot read file: ${t}`))
          )
        return (
          this._logger.debug(
            `Successfully read file: ${t} (${r.contents.length} bytes)`,
          ),
          { contents: r.contents, filepath: r.filepath }
        )
      } catch (r) {
        throw (
          (this._logger.error(
            `Error reading file ${t}: ${r instanceof Error ? r.message : String(r)}`,
          ),
          new Error(
            `Ran into ${r instanceof Error ? r.message : String(r)} while trying to read ${t}`,
          ))
        )
      }
    }
    async createCheckpoint(t, r, n, i) {
      this._logger.debug(`Creating checkpoint for file: ${t.absPath}`)
      let s = new DiffViewDocument(t, r, n, {}),
        o = i.at(-1)?.request_id ?? ho(),
        a = this._checkpointManager.currentConversationId ?? ""
      this._logger.debug(
        `Adding checkpoint with conversationId: ${a}, requestId: ${o}`,
      ),
        await this._checkpointManager.addCheckpoint(
          { conversationId: a, path: t },
          {
            sourceToolCallRequestId: o,
            timestamp: Date.now(),
            document: s,
            conversationId: a,
          },
        )
    }
    async call(t, r, n) {
      try {
        this._logger.debug(
          `Tool called with command: ${String(t.command)}, path: ${String(t.path)}`,
        )
        let i = t.command
        if (t.path === undefined)
          return (
            this._logger.error("Missing required parameter 'path'"),
            at("Missing required parameter `path`")
          )
        if (typeof t.path != "string")
          return (
            this._logger.error(
              "Invalid parameter 'path'. It must be a string.",
            ),
            at("Invalid parameter `path`. It must be a string.")
          )
        if (t.path.trim() === "")
          return (
            this._logger.error(
              "Invalid parameter 'path'. It must not be empty.",
            ),
            at("Invalid parameter `path`. It must not be empty.")
          )
        let s = t.path,
          o = await this.readFile(s)
        switch (i) {
          case "view":
            return (
              this._logger.debug(
                `Handling 'view' command for ${s} with range: ${JSON.stringify(t.view_range)}`,
              ),
              this.handleView(s, o, t.view_range)
            )
          case "str_replace":
            return (
              this._logger.debug(
                `Handling 'str_replace' command for ${s} with ${Array.isArray(t.str_replace_entries) ? t.str_replace_entries.length : 0} entries`,
              ),
              await this.handleStrReplace(
                s,
                o,
                this._toolDefinition.extractStrReplaceEntries(t),
                r,
              )
            )
          case "insert":
            return (
              this._logger.debug(
                `Handling 'insert' command for ${s} with ${Array.isArray(t.insert_line_entries) ? t.insert_line_entries.length : 0} entries`,
              ),
              await this.handleInsert(
                s,
                o,
                this._toolDefinition.extractInsertLineEntries(t),
                r,
              )
            )
          default:
            return (
              this._logger.error(`Unknown command: ${String(i)}`),
              at(`Unknown command: ${String(i)}`)
            )
        }
      } catch (i) {
        return (
          this._logger.error(
            `Error in tool call: ${i instanceof Error ? i.message : String(i)}`,
          ),
          i instanceof Error ? at(i.message) : at(`Unknown error: ${String(i)}`)
        )
      }
    }
    async prepareToolResponse(t, r, n, i, s, o, a, l) {
      this._logger.debug(`Preparing tool response for ${a} command on ${t}`)
      let c = GL(n, i),
        u = GL(s, i)
      if (c !== u) {
        this._logger.debug(
          "Content changed, creating checkpoint and waiting for auto-formatting",
        ),
          await this.createCheckpoint(r.filepath, c, u, o),
          await sleep(this._waitForAutoFormatMs)
        let v = (await this.readFile(t)).contents,
          C = v !== u
        C && this._logger.debug("File was auto-formatted after edit"),
          l.sort(
            (w, B) =>
              (w.newStrStartLineNumber ?? -1) - (B.newStrStartLineNumber ?? -1),
          )
        let E = 0
        for (let w of l)
          w.newStrStartLineNumber !== undefined &&
            w.newStrEndLineNumber !== undefined &&
            (this._logger.debug(
              `Adjusting line numbers for result: start=${w.newStrStartLineNumber}, end=${w.newStrEndLineNumber}, shift=${E}`,
            ),
            (w.newStrStartLineNumber += E),
            (w.newStrEndLineNumber += E),
            (w.newContent = s),
            C &&
              (Mz(w, v),
              this._logger.debug(
                `Updated line numbers after reformatting: start=${w.newStrStartLineNumber}, end=${w.newStrEndLineNumber}`,
              )),
            (E += w.numLinesDiff)),
            (w.newContent = v)
      } else this._logger.debug("No content changes detected")
      let f = l.every((v) => v.isError),
        p = l.every((v) => !v.isError)
      this._logger.debug(
        `Results summary: all errors=${f}, all success=${p}, total results=${l.length}`,
      )
      let m = l.map((v) => {
          let C = v.genMessageFunc
            ? v.genMessageFunc(v)
            : "No message available"
          return `Result for ${a} for entry with index [${v.index}]:
${C}
`
        }).join(`
`),
        y
      return (
        f
          ? (y = `Failed to edit the file ${t}. See below for details.
${m}
Fix failed ${a} entries accordingly and try again.
`)
          : p
            ? (y = `Successfully edited the file ${t}.
${m}
Review the changes and make sure they are as expected (correct indentation, no duplicate lines, etc).
Edit the file again if necessary.
`)
            : (y = `Partially edited the file ${t}. See below for details.
${m}
Fix failed ${a} entries accordingly and try again.
`),
        f
          ? (this._logger.debug(`Returning error response for ${t}`), at(y))
          : (this._logger.debug(`Returning success response for ${t}`), cr(y))
      )
    }
    handleView(t, r, n) {
      this._logger.debug(
        `Handling view command for ${t} with range: ${JSON.stringify(n)}`,
      )
      let s = WL(r.contents).split(`
`),
        o = s.length
      this._logger.debug(`File ${t} has ${o} lines`)
      let a = 1,
        l = o,
        c = ""
      if (n)
        try {
          let p = _a().flags?.agentEditToolMinViewSize ?? 0,
            g = Bz(n, o, p)
          ;(a = g.initLine),
            (l = g.finalLine),
            g.message &&
              (c = `Note:
${g.message}

`)
        } catch (p) {
          throw p instanceof Error
            ? p
            : new Error(`Invalid view_range: ${String(p)}`)
        }
      let u =
          l === -1
            ? s.slice(a - 1).join(`
`)
            : s.slice(a - 1, l).join(`
`),
        f = Iz(u, t.toString(), a, o)
      return cr(c + f)
    }
    singleStrReplace(t, r, n, i, s, o, a) {
      ;(n = $A(n).content), (i = $A(i).content)
      let l = (v, C, E, w, B, T) => ({
          isError: false,
          index: s,
          oldStr: n,
          oldStrStartLineNumber: o,
          oldStrEndLineNumber: a,
          newContent: v,
          newStr: C,
          newStrStartLineNumber: E,
          newStrEndLineNumber: w,
          numLinesDiff: B,
          genMessageFunc: T,
        }),
        c = (v) => ({
          isError: true,
          index: s,
          oldStr: n,
          oldStrStartLineNumber: o,
          oldStrEndLineNumber: a,
          numLinesDiff: 0,
          genMessageFunc: v,
        }),
        u,
        f = 0,
        p = 0
      if (n.trim() === "")
        if (r.trim() === "")
          (u = i),
            (f = 0),
            (p =
              i.split(`
`).length - 1)
        else
          return c(
            () =>
              `No replacement was performed, old_str is empty which is only allowed when the file is empty or contains only whitespace. The file ${t} is not empty.`,
          )
      else {
        let v = KL(r, n)
        if (v.length === 0) {
          let C = LI(r),
            E = LI(n),
            w = LI(i)
          if (
            C.type === "tab" &&
            E.type === "tab" &&
            w.type === "tab" &&
            YL(n, C) &&
            YL(i, C)
          ) {
            let B = $L(n, C),
              T = $L(i, C)
            ;(v = KL(r, B)), v.length > 0 && ((n = B), (i = T))
          }
          if (v.length === 0)
            return c((T) => {
              let N = `No replacement was performed, oldStr did not appear verbatim in ${t}.`
              if (
                T.oldStrStartLineNumber !== undefined &&
                T.oldStrEndLineNumber !== undefined
              ) {
                let W = PI(
                    r,
                    T.oldStrStartLineNumber,
                    T.oldStrEndLineNumber - T.oldStrStartLineNumber + 1,
                    zL,
                  ),
                  Z = r
                    .split(
                      `
`,
                    )
                    .slice(T.oldStrStartLineNumber, T.oldStrEndLineNumber + 1)
                    .join(`
`),
                  te = oI(
                    "oldStr",
                    "regionContent",
                    T.oldStr +
                      `
`,
                    Z +
                      `
`,
                    undefined,
                    undefined,
                    { context: 3 },
                  )
                N += `
The content in the specified region is:
${W}

Diff between oldStr and the specified region is:
${te}`
              }
              return N
            })
        }
        if (v.length === 1) {
          let C = v[0]
          ;(u = r.replace(n, (E) => i)),
            (f = C.startLine),
            (p =
              C.startLine +
              i.split(`
`).length -
              1)
        } else {
          if (o === undefined || a === undefined)
            return c(
              () =>
                `Multiple occurrences of oldStr \`${n}\` found. Please provide line numbers to disambiguate.`,
            )
          let C = Rz(v, o, a, this._lineNumberErrorTolerance)
          if (C === -1) {
            let Y = o + 1,
              U = a + 1
            return c(
              () =>
                `No match found close to the provided line numbers (${Y}, ${U}).`,
            )
          }
          let E = v[C],
            w = r.split(`
`),
            B = w.slice(0, E.startLine).join(`
`),
            T = w.slice(E.endLine + 1).join(`
`),
            N = w.slice(E.startLine, E.endLine + 1).join(`
`),
            W = N.indexOf(n)
          if (W === -1)
            return c(
              () =>
                "Internal error: Could not find the exact position of the match.",
            )
          let Z = N.substring(0, W),
            te = N.substring(W + n.length)
          ;(u =
            B +
            (B
              ? `
`
              : "") +
            Z +
            i +
            te +
            (T
              ? `
`
              : "") +
            T),
            (f = E.startLine),
            (p =
              E.startLine +
              i.split(`
`).length -
              1)
        }
      }
      let g = n.split(`
`).length,
        y =
          i.split(`
`).length - g
      return l(
        u,
        i,
        f,
        p,
        y,
        (v) => `Replacement successful.
Edited section after IDE auto-formatting was applied:
${PI(v.newContent, v.newStrStartLineNumber, v.newStrEndLineNumber - v.newStrStartLineNumber + 1, zL)}`,
      )
    }
    async handleStrReplace(t, r, n, i) {
      this._logger.debug(`Handling str_replace command for ${t}`)
      let s = Dz(n),
        { content: o, originalLineEnding: a } = $A(r.contents),
        l = o,
        c = new Map()
      for (let u of s) {
        let f = Tz(u, s),
          p
        f !== undefined
          ? (p = {
              isError: true,
              index: u.index,
              oldStr: u.old_str,
              oldStrStartLineNumber: u.old_str_start_line_number,
              oldStrEndLineNumber: u.old_str_end_line_number,
              numLinesDiff: 0,
              genMessageFunc: () => kz(u, f),
            })
          : (p = this.singleStrReplace(
              t,
              l,
              u.old_str,
              u.new_str,
              u.index,
              u.old_str_start_line_number,
              u.old_str_end_line_number,
            )),
          c.set(u.index, p),
          !p.isError && p.newContent !== undefined && (l = p.newContent)
      }
      return this.prepareToolResponse(
        t,
        r,
        o,
        a,
        l,
        i,
        "str_replace",
        Array.from(c.values()),
      )
    }
    async handleInsert(t, r, n, i) {
      this._logger.debug(`Handling insert command for ${t}`)
      let { content: s, originalLineEnding: o } = $A(r.contents),
        a = s,
        l = a.split(`
`)
      n.sort((u, f) => f.insert_line - u.insert_line)
      let c = new Map()
      for (let u of n) {
        let f = u.insert_line,
          p = $A(u.new_str).content
        if (
          ((l = a.split(`
`)),
          f < 0 || f > l.length)
        ) {
          c.set(u.index, {
            isError: true,
            index: u.index,
            oldStr: "",
            oldStrStartLineNumber: f,
            oldStrEndLineNumber: f,
            numLinesDiff: 0,
            genMessageFunc: () =>
              `Invalid \`insert_line\` parameter: ${f}. It should be within the range of lines of the file: [0, ${l.length}]`,
          })
          continue
        }
        let g = p.split(`
`)
        ;(a = [...l.slice(0, f), ...g, ...l.slice(f)].join(`
`)),
          c.set(u.index, {
            isError: false,
            index: u.index,
            oldStr: "",
            oldStrStartLineNumber: f,
            oldStrEndLineNumber: f,
            newContent: a,
            newStr: p,
            newStrStartLineNumber: f,
            newStrEndLineNumber: f + g.length - 1,
            numLinesDiff: g.length,
            genMessageFunc: (y) => `Successfully inserted new_str.
Edited section after IDE auto-formatting was applied:
${PI(y.newContent, y.newStrStartLineNumber, y.newStrEndLineNumber - y.newStrStartLineNumber + 1, zL)}`,
          })
      }
      return this.prepareToolResponse(
        t,
        r,
        s,
        o,
        a,
        i,
        "insert",
        Array.from(c.values()),
      )
    }
  }
var X7 = q(Z7()),
  fUe = "Augment-WebFetch/1.0",
  Gb = class extends En {
    _turndownService
    _userAgent
    constructor(t) {
      super(Hi.webFetch, ToolSafetyLevel.Unsafe)
      let r = new X7.default()
      r.addRule("removeStyleAndScriptTags", {
        filter: ["style", "script"],
        replacement: function () {
          return ""
        },
      }),
        (this._turndownService = r),
        (this._userAgent = t || fUe)
    }
    description = `Fetches data from a webpage and converts it into Markdown.

1. The tool takes in a URL and returns the content of the page in Markdown format;
2. If the return is not valid Markdown, it means the tool cannot successfully parse this page.`
    inputSchemaJson = JSON.stringify({
      type: "object",
      properties: { url: { type: "string", description: "The URL to fetch." } },
      required: ["url"],
    })
    checkToolCallSafe(t) {
      return false
    }
    async call(t, r, n) {
      let i = t.url
      try {
        let o = await (
          await fetch(i, {
            signal: n,
            headers: { "User-Agent": this._userAgent },
          })
        ).text()
        return { text: this._turndownService.turndown(o), isError: false }
      } catch (s) {
        return {
          text: `Failed to fetch URL: ${i}: ${s instanceof Error ? s.message : String(s)}`,
          isError: true,
        }
      }
    }
  }
function hUe(e) {
  return e === undefined
    ? { num_lines: -1, num_chars: -1 }
    : {
        num_lines: e.split(`
`).length,
        num_chars: e.length,
      }
}
var IB = class {
    tracingData = { flags: {}, nums: {}, string_stats: {}, request_ids: {} }
    setFlag(t, r = true) {
      this.tracingData.flags[t] = {
        value: r,
        timestamp: new Date().toISOString(),
      }
    }
    getFlag(t) {
      return this.tracingData.flags[t]?.value
    }
    setNum(t, r) {
      this.tracingData.nums[t] = {
        value: r,
        timestamp: new Date().toISOString(),
      }
    }
    getNum(t) {
      return this.tracingData.nums[t]?.value
    }
    setStringStats(t, r) {
      this.tracingData.string_stats[t] = {
        value: hUe(r),
        timestamp: new Date().toISOString(),
      }
    }
    setRequestId(t, r) {
      this.tracingData.request_ids[t] = {
        value: r,
        timestamp: new Date().toISOString(),
      }
    }
  },
  BB
;(function (e) {
  ;(e[(e.unspecified = 0)] = "unspecified"),
    (e[(e.classify_and_distill = 1)] = "classify_and_distill"),
    (e[(e.orientation = 2)] = "orientation")
})(BB || (BB = {}))
var rn
;(function (e) {
  ;(e.memoriesRequestId = "memoriesRequestId"),
    (e.exceptionThrown = "exceptionThrown"),
    (e.toolOutputIsError = "toolOutputIsError"),
    (e.injectionNoCodeWrapper = "injectionNoCodeWrapper"),
    (e.rememberToolModelNameMissing = "rememberToolModelNameMissing"),
    (e.compressionStarted = "compressionStarted"),
    (e.compressionTargetMissing = "compressionTargetMissing"),
    (e.compressionPromptMissing = "compressionPromptMissing"),
    (e.compressionNumRecentMemoriesToKeepMissing =
      "compressionNumRecentMemoriesToKeepMissing"),
    (e.compressionRecentMemoriesSubpromptMissing =
      "compressionRecentMemoriesSubpromptMissing"),
    (e.compressionMemoriesQueueSize = "compressionMemoriesQueueSize"),
    (e.compressionPromptStats = "compressionPromptStats"),
    (e.compressionRequestId = "compressionRequestId"),
    (e.compressionMemoriesStats = "compressedMemoriesStats"),
    (e.compressionFailed = "compressionFailed"),
    (e.setMemoriesStart = "setMemoriesStart"),
    (e.setMemoriesUpperBoundSizeMissing = "setMemoriesUpperBoundSizeMissing"),
    (e.setMemoriesNonEmptyLines = "nonEmptyLines"),
    (e.setMemoriesNoMemoriesFile = "noMemoriesFile"),
    (e.setMemoriesUpdateBufferFailed = "updateBufferFailed"),
    (e.setMemoriesNoChangesMade = "noChangesMade"),
    (e.injectionStarted = "injectionStarted"),
    (e.injectionCurrentMemoriesStats = "injectionCurrentMemoriesStats"),
    (e.injectionPromptMissing = "injectionPromptMissing"),
    (e.injectionPromptStats = "injectionPromptStats"),
    (e.injectionRequestId = "injectionRequestId"),
    (e.injectionUpdatedMemoriesStats = "injectionUpdatedMemoriesStats"),
    (e.injectionFailed = "injectionFailed")
})(rn || (rn = {}))
var RB = class e extends IB {
    caller
    is_complex_new_memory
    constructor(t, r) {
      super(), (this.caller = t), (this.is_complex_new_memory = r)
    }
    static create(t, r) {
      return new e(t, r)
    }
  },
  eZ
;(function (e) {
  ;(e.start = "start"),
    (e.end = "end"),
    (e.memoriesRequestId = "memoriesRequestId"),
    (e.exceptionThrown = "exceptionThrown"),
    (e.lastUserExchangeRequestId = "lastUserExchangeRequestId"),
    (e.noMemoryData = "noMemoryData"),
    (e.agenticTurnHasRememberToolCall = "agenticTurnHasRememberToolCall"),
    (e.emptyMemory = "emptyMemory"),
    (e.removeUserExchangeMemoryFailed = "removeUserExchangeMemoryFailed")
})(eZ || (eZ = {}))
var MemoryEventType
;(function (e) {
  ;(e.openedAgentConversation = "opened-agent-conversation"),
    (e.revertCheckpoint = "revert-checkpoint"),
    (e.agentInterruption = "agent-interruption"),
    (e.sentUserMessage = "sent-user-message"),
    (e.rememberToolCall = "remember-tool-call"),
    (e.openedMemoriesFile = "opened-memories-file"),
    (e.initialOrientation = "initial-orientation"),
    (e.classifyAndDistill = "classify-and-distill"),
    (e.flushMemories = "flush-memories"),
    (e.vsCodeTerminalShellIntegrationNotAvailable =
      "vs-code-terminal-shell-integration-not-available"),
    (e.vsCodeTerminalReadingApproximateOutput =
      "vs-code-terminal-reading-approximate-output"),
    (e.vsCodeTerminalTimedOutWaitingForNoopCommand =
      "vs-code-terminal-timed-out-waiting-for-noop-command"),
    (e.vsCodeTerminalFailedToUseShellIntegration =
      "vs-code-terminal-failed-to-use-shell-integration"),
    (e.vsCodeTerminalLastCommandIsSameAsCurrent =
      "vs-code-terminal-last-command-is-same-as-current"),
    (e.vsCodeTerminalPollingDeterminedProcessIsDone =
      "vs-code-terminal-polling-determined-process-is-done"),
    (e.vsCodeTerminalFailedToReadOutput =
      "vs-code-terminal-failed-to-read-output"),
    (e.vsCodeTerminalBuggyOutput = "vs-code-terminal-buggy-output"),
    (e.vsCodeTerminalBuggyExecutionEvents =
      "vs-code-terminal-buggy-execution-events"),
    (e.vsCodeTerminalUnsupportedVSCodeShell =
      "vs-code-terminal-unsupported-vscode-shell"),
    (e.vsCodeTerminalFailedToFindGitBash =
      "vs-code-terminal-failed-to-find-git-bash"),
    (e.vsCodeTerminalFailedToFindPowerShell =
      "vs-code-terminal-failed-to-find-powershell"),
    (e.vsCodeTerminalNoSupportedShellsFound =
      "vs-code-terminal-no-supported-shells-found"),
    (e.vsCodeTerminalSettingsChanged = "vs-code-terminal-settings-changed"),
    (e.vsCodeTerminalWaitTimeout = "vs-code-terminal-wait-timeout"),
    (e.vsCodeTerminalErrorLoadingSettings =
      "vs-code-terminal-error-loading-settings"),
    (e.vsCodeTerminalErrorCheckingForShellUpdates =
      "vs-code-terminal-error-checking-for-shell-updates"),
    (e.vsCodeTerminalErrorCleaningUpTempDir =
      "vs-code-terminal-error-cleaning-up-temp-dir"),
    (e.vsCodeTerminalErrorInitializingShells =
      "vs-code-terminal-error-initializing-shells"),
    (e.vsCodeTerminalErrorCheckingShellCapability =
      "vs-code-terminal-error-checking-shell-capability"),
    (e.vsCodeTerminalErrorCreatingZshEnvironment =
      "vs-code-terminal-error-creating-zsh-environment"),
    (e.chatHistoryTruncated = "chat-history-truncated"),
    (e.enhancedPrompt = "enhanced-prompt")
})(MemoryEventType || (MemoryEventType = {}))
var tZ
;(function (e) {
  e.sentUserMessage = "sent-user-message"
})(tZ || (tZ = {}))
var nh
;(function (e) {
  ;(e[(e.unspecified = 0)] = "unspecified"),
    (e[(e.onboarding = 1)] = "onboarding"),
    (e[(e.command = 2)] = "command"),
    (e[(e.automaticAfterIndexing = 3)] = "automaticAfterIndexing")
})(nh || (nh = {}))
var TelemetryFlags
;(function (e) {
  ;(e.exceptionThrown = "exceptionThrown"),
    (e.start = "start"),
    (e.end = "end"),
    (e.concurrencyLevelMissing = "concurrencyLevelMissing"),
    (e.initialOrientationDisabled = "initialOrientationDisabled"),
    (e.noRootFolderFound = "noRootFolderFound"),
    (e.retryWithLowerConcurrencyLevel = "retryWithLowerConcurrencyLevel"),
    (e.localizationPromptMissing = "localizationPromptMissing"),
    (e.detectLanguagesPromptMissing = "detectLanguagesPromptMissing"),
    (e.orientationCompressionPromptMissing =
      "orientationCompressionPromptMissing"),
    (e.orientationMaxLanguagesMissing = "orientationMaxLanguagesMissing"),
    (e.orientationBuildTestQueryMissing = "orientationBuildTestQueryMissing"),
    (e.orientationModelNameMissing = "orientationModelNameMissing"),
    (e.topLanguagesNumFiles = "topLanguagesNumFiles"),
    (e.topLanguagesNumCodeFiles = "topLanguagesNumCodeFiles"),
    (e.topLanguagesRequestId = "topLanguagesRequestId"),
    (e.topLanguagesModelResponseStats = "topLanguagesModelResponseStats"),
    (e.topLanguagesNumDetectedLanguages = "topLanguagesNumDetectedLanguages"),
    (e.topLanguagesNumFinalLanguages = "topLanguagesNumFinalLanguages"),
    (e.localizationStarted = "localizationStarted"),
    (e.localizationEnded = "localizationEnded"),
    (e.localizationPromptStats_0 = "localizationPromptStats_0"),
    (e.localizationPromptStats_1 = "localizationPromptStats_1"),
    (e.localizationPromptStats_2 = "localizationPromptStats_2"),
    (e.localizationPromptStats_3 = "localizationPromptStats_3"),
    (e.localizationPromptStats_4 = "localizationPromptStats_4"),
    (e.localizationPromptStats_5 = "localizationPromptStats_5"),
    (e.localizationRequestId_0 = "localizationRequestId_0"),
    (e.localizationRequestId_1 = "localizationRequestId_1"),
    (e.localizationRequestId_2 = "localizationRequestId_2"),
    (e.localizationRequestId_3 = "localizationRequestId_3"),
    (e.localizationRequestId_4 = "localizationRequestId_4"),
    (e.localizationRequestId_5 = "localizationRequestId_5"),
    (e.localizationResponseStats_0 = "localizationResponseStats_0"),
    (e.localizationResponseStats_1 = "localizationResponseStats_1"),
    (e.localizationResponseStats_2 = "localizationResponseStats_2"),
    (e.localizationResponseStats_3 = "localizationResponseStats_3"),
    (e.localizationResponseStats_4 = "localizationResponseStats_4"),
    (e.localizationResponseStats_5 = "localizationResponseStats_5"),
    (e.localizationParsingFailed_0 = "localizationParsingFailed_0"),
    (e.localizationParsingFailed_1 = "localizationParsingFailed_1"),
    (e.localizationParsingFailed_2 = "localizationParsingFailed_2"),
    (e.localizationParsingFailed_3 = "localizationParsingFailed_3"),
    (e.localizationParsingFailed_4 = "localizationParsingFailed_4"),
    (e.localizationParsingFailed_5 = "localizationParsingFailed_5"),
    (e.localizationNumLocations_0 = "localizationNumLocations_0"),
    (e.localizationNumLocations_1 = "localizationNumLocations_1"),
    (e.localizationNumLocations_2 = "localizationNumLocations_2"),
    (e.localizationNumLocations_3 = "localizationNumLocations_3"),
    (e.localizationNumLocations_4 = "localizationNumLocations_4"),
    (e.localizationNumLocations_5 = "localizationNumLocations_5"),
    (e.failedToListRootFolder = "failedToListRootFolder"),
    (e.agenticStarted = "agenticStarted"),
    (e.agenticEnded = "agenticEnded"),
    (e.agenticNumTurns_0 = "agenticNumTurns_0"),
    (e.agenticNumTurns_1 = "agenticNumTurns_1"),
    (e.agenticNumTurns_2 = "agenticNumTurns_2"),
    (e.agenticNumTurns_3 = "agenticNumTurns_3"),
    (e.agenticNumTurns_4 = "agenticNumTurns_4"),
    (e.agenticNumTurns_5 = "agenticNumTurns_5"),
    (e.agenticModelResponseStats_0 = "agenticModelResponseStats_0"),
    (e.agenticModelResponseStats_1 = "agenticModelResponseStats_1"),
    (e.agenticModelResponseStats_2 = "agenticModelResponseStats_2"),
    (e.agenticModelResponseStats_3 = "agenticModelResponseStats_3"),
    (e.agenticModelResponseStats_4 = "agenticModelResponseStats_4"),
    (e.agenticModelResponseStats_5 = "agenticModelResponseStats_5"),
    (e.agenticFailedToComplete_0 = "agenticFailedToComplete_0"),
    (e.agenticFailedToComplete_1 = "agenticFailedToComplete_1"),
    (e.agenticFailedToComplete_2 = "agenticFailedToComplete_2"),
    (e.agenticFailedToComplete_3 = "agenticFailedToComplete_3"),
    (e.agenticFailedToComplete_4 = "agenticFailedToComplete_4"),
    (e.agenticFailedToComplete_5 = "agenticFailedToComplete_5"),
    (e.agenticModelResponseStats = "agenticModelResponseStats"),
    (e.compressionRequestId = "compressionRequestId"),
    (e.compressionModelResponseStats = "compressionModelResponseStats"),
    (e.compressionParsingFailed = "compressionParsingFailed"),
    (e.rememberStarted = "rememberStarted"),
    (e.rememberEnded = "rememberEnded"),
    (e.failedToReadGuidelines = "failedToReadGuidelines"),
    (e.failedToWriteGuidelines = "failedToWriteGuidelines")
})(TelemetryFlags || (TelemetryFlags = {}))
var DB = class e extends IB {
    caller
    constructor(t) {
      super(), (this.caller = t)
    }
    static create(t) {
      return new e(t)
    }
  },
  rZ
;(function (e) {
  ;(e.memoriesRequestId = "memoriesRequestId"),
    (e.exceptionThrown = "exceptionThrown"),
    (e.start = "start"),
    (e.end = "end"),
    (e.noPendingUserMessage = "noPendingUserMessage"),
    (e.startSendSilentExchange = "startSendSilentExchange"),
    (e.sendSilentExchangeRequestId = "sendSilentExchangeRequestId"),
    (e.sendSilentExchangeResponseStats = "sendSilentExchangeResponseStats"),
    (e.noRequestId = "noRequestId"),
    (e.conversationChanged = "conversationChanged"),
    (e.explanationStats = "explanationStats"),
    (e.contentStats = "contentStats"),
    (e.invalidResponse = "invalidResponse"),
    (e.worthRemembering = "worthRemembering"),
    (e.lastUserExchangeRequestId = "lastUserExchangeRequestId"),
    (e.noLastUserExchangeRequestId = "noLastUserExchangeRequestId")
})(rZ || (rZ = {}))
var nZ
;(function (e) {
  ;(e.remoteAgentSetup = "remote-agent-setup"),
    (e.setupScript = "setup-script"),
    (e.sshInteraction = "ssh-interaction"),
    (e.notificationBell = "notification-bell"),
    (e.diffPanel = "diff-panel")
})(nZ || (nZ = {}))
var iZ
;(function (e) {
  ;(e[(e.unknown = 0)] = "unknown"),
    (e[(e.completed = 1)] = "completed"),
    (e[(e.failed = 2)] = "failed")
})(iZ || (iZ = {}))
var sZ
;(function (e) {
  ;(e[(e.unknown = 0)] = "unknown"),
    (e[(e.clicked = 1)] = "clicked"),
    (e[(e.remoteSessionStarted = 2)] = "remoteSessionStarted")
})(sZ || (sZ = {}))
var oZ
;(function (e) {
  ;(e[(e.unknown = 0)] = "unknown"),
    (e[(e.activated = 1)] = "activated"),
    (e[(e.deactivated = 2)] = "deactivated"),
    (e[(e.notified = 4)] = "notified"),
    (e[(e.accepted = 3)] = "accepted")
})(oZ || (oZ = {}))
async function mp(e, t, r, n, i, s, o) {
  return await yl().chatStream(e, t, r, n, i, s, o)
}
var TB = class extends DiffViewDocument {
  constructor(t, r, n, i) {
    super(t, r, n, { ...i }),
      this.addDisposable(
        this.onModifiedUpdated(() => void this.writeDocumentToFile()),
      )
  }
  async writeDocumentToFile() {
    this.modifiedCode === undefined
      ? await Vi().deleteFile(this.filePath)
      : await Vi().writeFile(this.filePath, this.modifiedCode)
  }
}
var kB = class extends En {
  _getAgentMemories
  _getAgentMemoriesAbsPath
  _memoryUpdateManager
  memoryRingBuffer
  maxMemoryBufferSize = 1e3
  constructor(t, r, n) {
    super(Hi.remember, ToolSafetyLevel.Safe),
      (this._getAgentMemories = t),
      (this._getAgentMemoriesAbsPath = r),
      (this._memoryUpdateManager = n),
      (this.memoryRingBuffer = new CircularBuffer(this.maxMemoryBufferSize))
  }
  description = `Call this tool when user asks you:
- to remember something
- to create memory/memories

Use this tool only with information that can be useful in the long-term.
Do not use this tool for temporary information.
`
  inputSchemaJson = JSON.stringify({
    type: "object",
    properties: {
      memory: {
        type: "string",
        description: "The concise (1 sentence) memory to remember.",
      },
    },
    required: ["memory"],
  })
  checkToolCallSafe(t) {
    return true
  }
  async call(t, r, n) {
    let i = t.memory
    this.memoryRingBuffer.addItem(i)
    let s = t.isComplexNewMemory ?? false,
      o = t.caller ?? BB.unspecified,
      a = t.memoriesRequestId,
      l = RB.create(o, s)
    a && l.setRequestId(rn.memoriesRequestId, a)
    let c
    try {
      c = await this.injectMemories(i, s, l)
    } catch {
      l.setFlag(rn.exceptionThrown)
    } finally {
      c === undefined && (c = at("Failed to save memory.")),
        l.setFlag(rn.toolOutputIsError, c.isError),
        Mr().reportEvent({
          eventName: MemoryEventType.rememberToolCall,
          conversationId: "",
          eventData: { rememberToolCallData: l },
        })
    }
    return c
  }
  async injectMemories(t, r, n) {
    n.setFlag(rn.injectionStarted)
    let i = await this._getAgentMemories()
    if ((n.setStringStats(rn.injectionCurrentMemoriesStats, i), !i))
      return (
        t.trim().split(`
`).length === 1 && (t = `- ${t}`),
        this._setMemories(t, "", n)
      )
    let s
    if (
      (r
        ? (s = _a().flags.memoriesParams.complex_injection_prompt)
        : (s = _a().flags.memoriesParams.injection_prompt),
      !s)
    )
      return n.setFlag(rn.injectionPromptMissing), at("Failed to save memory.")
    ;(s = s.replace("{currentMemories}", i).replace("{newMemory}", t)),
      n.setStringStats(rn.injectionPromptStats, s)
    try {
      let o = ho()
      n.setRequestId(rn.injectionRequestId, o)
      let a = await this._callModel(s, o, n, Fr.memories)
      n.setStringStats(rn.injectionUpdatedMemoriesStats, a)
      let l = Math.abs(
          a.split(`
`).length -
            i.split(`
`).length,
        ),
        c = Math.abs(a.length - i.length)
      if (l > 10 || c > 1e3) throw new Error("Injection failed")
      return this._setMemories(a, i, n)
    } catch {
      return n.setFlag(rn.injectionFailed), at("Failed to save memory.")
    }
  }
  async _callModel(t, r, n, i) {
    let s = await mp(t, r, [], [], [], i)
    for await (let { nodes: o = [] } of s) {
      let a = o.find((l) => l.type === gc.RAW_RESPONSE)?.content
      if (a) {
        let l = a.indexOf("```"),
          c = a.lastIndexOf("```")
        return l !== -1 && c !== -1 && c > l + 3
          ? a.substring(l + 3, c).trim()
          : (n.setFlag(rn.injectionNoCodeWrapper),
            a
              .trim()
              .replace(/^`+|`+$/g, "")
              .trim())
      }
    }
    throw new Error("Model call failed")
  }
  async _setMemories(t, r, n) {
    n.setFlag(rn.setMemoriesStart)
    let i = _a().flags.memoriesParams.upper_bound_size
    if (!i)
      return (
        n.setFlag(rn.setMemoriesUpperBoundSizeMissing),
        Promise.resolve(at("Failed to save memories: upper bound size missing"))
      )
    let s = t
      .split(
        `
`,
      )
      .filter((c) => c.trim()).length
    n.setNum(rn.setMemoriesNonEmptyLines, s),
      s >= i && (t = await this._compressMemories(t, n))
    let o = this._getAgentMemoriesAbsPath()
    if (!o)
      return (
        n.setFlag(rn.setMemoriesNoMemoriesFile),
        Promise.resolve(
          at("Failed to save memories: no memories file available"),
        )
      )
    let a = new TB(new QualifiedPathName("", o), r, r, {}),
      l = a.updateBuffer(t)
    return (
      n.setFlag(rn.setMemoriesUpdateBufferFailed, !l),
      t === r
        ? (n.setFlag(rn.setMemoriesNoChangesMade),
          a.dispose(),
          Promise.resolve(cr("No changes made to memories")))
        : (a.dispose(),
          l &&
            this._memoryUpdateManager &&
            this._memoryUpdateManager.notifyMemoryHasUpdates(),
          Promise.resolve(
            l
              ? cr("Memories saved successfully.")
              : at("Failed to update buffer"),
          ))
    )
  }
  async _compressMemories(t, r) {
    r.setFlag(rn.compressionStarted)
    let n = _a().flags.memoriesParams.compression_target
    if (!n) return r.setFlag(rn.compressionTargetMissing), t
    let i = _a().flags.memoriesParams.compression_prompt
    if (!i) return r.setFlag(rn.compressionPromptMissing), t
    let s = _a().flags.memoriesParams.num_recent_memories_to_keep
    if (s === undefined)
      return r.setFlag(rn.compressionNumRecentMemoriesToKeepMissing), t
    if (
      (r.setNum(rn.compressionMemoriesQueueSize, this.memoryRingBuffer.length),
      s > 0 &&
        i.includes("{recentMemoriesSubprompt}") &&
        this.memoryRingBuffer.length > 0)
    ) {
      let o = _a().flags.memoriesParams.recent_memories_subprompt
      if (o === undefined)
        return r.setFlag(rn.compressionRecentMemoriesSubpromptMissing), t
      let a = this.memoryRingBuffer.slice(-s).map((l) => `- ${l}`).join(`
`)
      ;(o = o.replace("{recentMemories}", a)),
        (i = i.replace("{recentMemoriesSubprompt}", o))
    } else
      i.includes("{recentMemoriesSubprompt}") &&
        (i = i.replace("{recentMemoriesSubprompt}", ""))
    ;(i = i
      .replace("{memories}", t)
      .replace("{compressionTarget}", n.toString())),
      r.setStringStats(rn.compressionPromptStats, i)
    try {
      let o = ho()
      r.setRequestId(rn.compressionRequestId, o)
      let a = await this._callModel(i, o, r, Fr.memoriesCompression)
      return (
        r.setStringStats(rn.compressionMemoriesStats, a),
        a.split(`
`).length >=
        t.split(`
`).length
          ? t
          : a
      )
    } catch {
      return r.setFlag(rn.compressionFailed), t
    }
  }
}
var aZ = q(Yf()),
  MB = class e extends DisposableContainer_2 {
    static THROTTLE_DELAY_MS = 500
    _memoryHasUpdatesCallbacks = new Set()
    _throttledNotifyMemoryHasUpdates
    constructor() {
      super(),
        (this._throttledNotifyMemoryHasUpdates = (0, aZ.default)(
          this._notifyMemoryHasUpdatesImmediate,
          e.THROTTLE_DELAY_MS,
          { trailing: true },
        ))
    }
    onMemoryHasUpdates = (t) => (
      this._memoryHasUpdatesCallbacks.add(t),
      {
        dispose: () => {
          this._memoryHasUpdatesCallbacks.delete(t)
        },
      }
    )
    notifyMemoryHasUpdates = () => {
      this._throttledNotifyMemoryHasUpdates()
    }
    _notifyMemoryHasUpdatesImmediate = () => {
      this._memoryHasUpdatesCallbacks.forEach((t) => t())
    }
  }
var JZ = require("util"),
  jZ = require("child_process")
function _Z(e) {
  return typeof e > "u" || e === null
}
function gUe(e) {
  return typeof e == "object" && e !== null
}
function pUe(e) {
  return Array.isArray(e) ? e : _Z(e) ? [] : [e]
}
function mUe(e, t) {
  var r, n, i, s
  if (t)
    for (s = Object.keys(t), r = 0, n = s.length; r < n; r += 1)
      (i = s[r]), (e[i] = t[i])
  return e
}
function AUe(e, t) {
  var r = "",
    n
  for (n = 0; n < t; n += 1) r += e
  return r
}
function yUe(e) {
  return e === 0 && Number.NEGATIVE_INFINITY === 1 / e
}
var vUe = _Z,
  CUe = gUe,
  bUe = pUe,
  EUe = AUe,
  _Ue = yUe,
  xUe = mUe,
  $i = {
    isNothing: vUe,
    isObject: CUe,
    toArray: bUe,
    repeat: EUe,
    isNegativeZero: _Ue,
    extend: xUe,
  }
function xZ(e, t) {
  var r = "",
    n = e.reason || "(unknown reason)"
  return e.mark
    ? (e.mark.name && (r += 'in "' + e.mark.name + '" '),
      (r += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")"),
      !t &&
        e.mark.snippet &&
        (r +=
          `

` + e.mark.snippet),
      n + " " + r)
    : n
}
function Yb(e, t) {
  Error.call(this),
    (this.name = "YAMLException"),
    (this.reason = e),
    (this.mark = t),
    (this.message = xZ(this, false)),
    Error.captureStackTrace
      ? Error.captureStackTrace(this, this.constructor)
      : (this.stack = new Error().stack || "")
}
Yb.prototype = Object.create(Error.prototype)
Yb.prototype.constructor = Yb
Yb.prototype.toString = function (t) {
  return this.name + ": " + xZ(this, t)
}
var $o = Yb
function CO(e, t, r, n, i) {
  var s = "",
    o = "",
    a = Math.floor(i / 2) - 1
  return (
    n - t > a && ((s = " ... "), (t = n - a + s.length)),
    r - n > a && ((o = " ..."), (r = n + a - o.length)),
    {
      str: s + e.slice(t, r).replace(/\t/g, "\u2192") + o,
      pos: n - t + s.length,
    }
  )
}
function bO(e, t) {
  return $i.repeat(" ", t - e.length) + e
}
function wUe(e, t) {
  if (((t = Object.create(t || null)), !e.buffer)) return null
  t.maxLength || (t.maxLength = 79),
    typeof t.indent != "number" && (t.indent = 1),
    typeof t.linesBefore != "number" && (t.linesBefore = 3),
    typeof t.linesAfter != "number" && (t.linesAfter = 2)
  for (
    var r = /\r?\n|\r|\0/g, n = [0], i = [], s, o = -1;
    (s = r.exec(e.buffer));

  )
    i.push(s.index),
      n.push(s.index + s[0].length),
      e.position <= s.index && o < 0 && (o = n.length - 2)
  o < 0 && (o = n.length - 1)
  var a = "",
    l,
    c,
    u = Math.min(e.line + t.linesAfter, i.length).toString().length,
    f = t.maxLength - (t.indent + u + 3)
  for (l = 1; l <= t.linesBefore && !(o - l < 0); l++)
    (c = CO(e.buffer, n[o - l], i[o - l], e.position - (n[o] - n[o - l]), f)),
      (a =
        $i.repeat(" ", t.indent) +
        bO((e.line - l + 1).toString(), u) +
        " | " +
        c.str +
        `
` +
        a)
  for (
    c = CO(e.buffer, n[o], i[o], e.position, f),
      a +=
        $i.repeat(" ", t.indent) +
        bO((e.line + 1).toString(), u) +
        " | " +
        c.str +
        `
`,
      a +=
        $i.repeat("-", t.indent + u + 3 + c.pos) +
        `^
`,
      l = 1;
    l <= t.linesAfter && !(o + l >= i.length);
    l++
  )
    (c = CO(e.buffer, n[o + l], i[o + l], e.position - (n[o] - n[o + l]), f)),
      (a +=
        $i.repeat(" ", t.indent) +
        bO((e.line + l + 1).toString(), u) +
        " | " +
        c.str +
        `
`)
  return a.replace(/\n$/, "")
}
var SUe = wUe,
  IUe = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases",
  ],
  BUe = ["scalar", "sequence", "mapping"]
function RUe(e) {
  var t = {}
  return (
    e !== null &&
      Object.keys(e).forEach(function (r) {
        e[r].forEach(function (n) {
          t[String(n)] = r
        })
      }),
    t
  )
}
function DUe(e, t) {
  if (
    ((t = t || {}),
    Object.keys(t).forEach(function (r) {
      if (IUe.indexOf(r) === -1)
        throw new $o(
          'Unknown option "' +
            r +
            '" is met in definition of "' +
            e +
            '" YAML type.',
        )
    }),
    (this.options = t),
    (this.tag = e),
    (this.kind = t.kind || null),
    (this.resolve =
      t.resolve ||
      function () {
        return true
      }),
    (this.construct =
      t.construct ||
      function (r) {
        return r
      }),
    (this.instanceOf = t.instanceOf || null),
    (this.predicate = t.predicate || null),
    (this.represent = t.represent || null),
    (this.representName = t.representName || null),
    (this.defaultStyle = t.defaultStyle || null),
    (this.multi = t.multi || false),
    (this.styleAliases = RUe(t.styleAliases || null)),
    BUe.indexOf(this.kind) === -1)
  )
    throw new $o(
      'Unknown kind "' +
        this.kind +
        '" is specified for "' +
        e +
        '" YAML type.',
    )
}
var Ys = DUe
function lZ(e, t) {
  var r = []
  return (
    e[t].forEach(function (n) {
      var i = r.length
      r.forEach(function (s, o) {
        s.tag === n.tag && s.kind === n.kind && s.multi === n.multi && (i = o)
      }),
        (r[i] = n)
    }),
    r
  )
}
function TUe() {
  var e = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: { scalar: [], sequence: [], mapping: [], fallback: [] },
    },
    t,
    r
  function n(i) {
    i.multi
      ? (e.multi[i.kind].push(i), e.multi.fallback.push(i))
      : (e[i.kind][i.tag] = e.fallback[i.tag] = i)
  }
  for (t = 0, r = arguments.length; t < r; t += 1) arguments[t].forEach(n)
  return e
}
function _O(e) {
  return this.extend(e)
}
_O.prototype.extend = function (t) {
  var r = [],
    n = []
  if (t instanceof Ys) n.push(t)
  else if (Array.isArray(t)) n = n.concat(t)
  else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
    t.implicit && (r = r.concat(t.implicit)),
      t.explicit && (n = n.concat(t.explicit))
  else
    throw new $o(
      "Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })",
    )
  r.forEach(function (s) {
    if (!(s instanceof Ys))
      throw new $o(
        "Specified list of YAML types (or a single Type object) contains a non-Type object.",
      )
    if (s.loadKind && s.loadKind !== "scalar")
      throw new $o(
        "There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.",
      )
    if (s.multi)
      throw new $o(
        "There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.",
      )
  }),
    n.forEach(function (s) {
      if (!(s instanceof Ys))
        throw new $o(
          "Specified list of YAML types (or a single Type object) contains a non-Type object.",
        )
    })
  var i = Object.create(_O.prototype)
  return (
    (i.implicit = (this.implicit || []).concat(r)),
    (i.explicit = (this.explicit || []).concat(n)),
    (i.compiledImplicit = lZ(i, "implicit")),
    (i.compiledExplicit = lZ(i, "explicit")),
    (i.compiledTypeMap = TUe(i.compiledImplicit, i.compiledExplicit)),
    i
  )
}
var kUe = _O,
  MUe = new Ys("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function (e) {
      return e !== null ? e : ""
    },
  }),
  FUe = new Ys("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function (e) {
      return e !== null ? e : []
    },
  }),
  QUe = new Ys("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function (e) {
      return e !== null ? e : {}
    },
  }),
  NUe = new kUe({ explicit: [MUe, FUe, QUe] })
function PUe(e) {
  if (e === null) return true
  var t = e.length
  return (
    (t === 1 && e === "~") ||
    (t === 4 && (e === "null" || e === "Null" || e === "NULL"))
  )
}
function LUe() {
  return null
}
function UUe(e) {
  return e === null
}
var OUe = new Ys("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: PUe,
  construct: LUe,
  predicate: UUe,
  represent: {
    canonical: function () {
      return "~"
    },
    lowercase: function () {
      return "null"
    },
    uppercase: function () {
      return "NULL"
    },
    camelcase: function () {
      return "Null"
    },
    empty: function () {
      return ""
    },
  },
  defaultStyle: "lowercase",
})
function qUe(e) {
  if (e === null) return false
  var t = e.length
  return (
    (t === 4 && (e === "true" || e === "True" || e === "TRUE")) ||
    (t === 5 && (e === "false" || e === "False" || e === "FALSE"))
  )
}
function VUe(e) {
  return e === "true" || e === "True" || e === "TRUE"
}
function HUe(e) {
  return Object.prototype.toString.call(e) === "[object Boolean]"
}
var WUe = new Ys("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: qUe,
  construct: VUe,
  predicate: HUe,
  represent: {
    lowercase: function (e) {
      return e ? "true" : "false"
    },
    uppercase: function (e) {
      return e ? "TRUE" : "FALSE"
    },
    camelcase: function (e) {
      return e ? "True" : "False"
    },
  },
  defaultStyle: "lowercase",
})
function GUe(e) {
  return (48 <= e && e <= 57) || (65 <= e && e <= 70) || (97 <= e && e <= 102)
}
function $Ue(e) {
  return 48 <= e && e <= 55
}
function YUe(e) {
  return 48 <= e && e <= 57
}
function KUe(e) {
  if (e === null) return false
  var t = e.length,
    r = 0,
    n = false,
    i
  if (!t) return false
  if (((i = e[r]), (i === "-" || i === "+") && (i = e[++r]), i === "0")) {
    if (r + 1 === t) return true
    if (((i = e[++r]), i === "b")) {
      for (r++; r < t; r++)
        if (((i = e[r]), i !== "_")) {
          if (i !== "0" && i !== "1") return false
          n = true
        }
      return n && i !== "_"
    }
    if (i === "x") {
      for (r++; r < t; r++)
        if (((i = e[r]), i !== "_")) {
          if (!GUe(e.charCodeAt(r))) return false
          n = true
        }
      return n && i !== "_"
    }
    if (i === "o") {
      for (r++; r < t; r++)
        if (((i = e[r]), i !== "_")) {
          if (!$Ue(e.charCodeAt(r))) return false
          n = true
        }
      return n && i !== "_"
    }
  }
  if (i === "_") return false
  for (; r < t; r++)
    if (((i = e[r]), i !== "_")) {
      if (!YUe(e.charCodeAt(r))) return false
      n = true
    }
  return !(!n || i === "_")
}
function zUe(e) {
  var t = e,
    r = 1,
    n
  if (
    (t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")),
    (n = t[0]),
    (n === "-" || n === "+") &&
      (n === "-" && (r = -1), (t = t.slice(1)), (n = t[0])),
    t === "0")
  )
    return 0
  if (n === "0") {
    if (t[1] === "b") return r * parseInt(t.slice(2), 2)
    if (t[1] === "x") return r * parseInt(t.slice(2), 16)
    if (t[1] === "o") return r * parseInt(t.slice(2), 8)
  }
  return r * parseInt(t, 10)
}
function JUe(e) {
  return (
    Object.prototype.toString.call(e) === "[object Number]" &&
    e % 1 === 0 &&
    !$i.isNegativeZero(e)
  )
}
var jUe = new Ys("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: KUe,
    construct: zUe,
    predicate: JUe,
    represent: {
      binary: function (e) {
        return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1)
      },
      octal: function (e) {
        return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1)
      },
      decimal: function (e) {
        return e.toString(10)
      },
      hexadecimal: function (e) {
        return e >= 0
          ? "0x" + e.toString(16).toUpperCase()
          : "-0x" + e.toString(16).toUpperCase().slice(1)
      },
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"],
    },
  }),
  ZUe = new RegExp(
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$",
  )
function XUe(e) {
  return !(e === null || !ZUe.test(e) || e[e.length - 1] === "_")
}
function eOe(e) {
  var t, r
  return (
    (t = e.replace(/_/g, "").toLowerCase()),
    (r = t[0] === "-" ? -1 : 1),
    "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)),
    t === ".inf"
      ? r === 1
        ? Number.POSITIVE_INFINITY
        : Number.NEGATIVE_INFINITY
      : t === ".nan"
        ? NaN
        : r * parseFloat(t, 10)
  )
}
var tOe = /^[-+]?[0-9]+e/
function rOe(e, t) {
  var r
  if (isNaN(e))
    switch (t) {
      case "lowercase":
        return ".nan"
      case "uppercase":
        return ".NAN"
      case "camelcase":
        return ".NaN"
    }
  else if (Number.POSITIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return ".inf"
      case "uppercase":
        return ".INF"
      case "camelcase":
        return ".Inf"
    }
  else if (Number.NEGATIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return "-.inf"
      case "uppercase":
        return "-.INF"
      case "camelcase":
        return "-.Inf"
    }
  else if ($i.isNegativeZero(e)) return "-0.0"
  return (r = e.toString(10)), tOe.test(r) ? r.replace("e", ".e") : r
}
function nOe(e) {
  return (
    Object.prototype.toString.call(e) === "[object Number]" &&
    (e % 1 !== 0 || $i.isNegativeZero(e))
  )
}
var iOe = new Ys("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: XUe,
    construct: eOe,
    predicate: nOe,
    represent: rOe,
    defaultStyle: "lowercase",
  }),
  sOe = NUe.extend({ implicit: [OUe, WUe, jUe, iOe] }),
  oOe = sOe,
  wZ = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"),
  SZ = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$",
  )
function aOe(e) {
  return e === null ? false : wZ.exec(e) !== null || SZ.exec(e) !== null
}
function lOe(e) {
  var t,
    r,
    n,
    i,
    s,
    o,
    a,
    l = 0,
    c = null,
    u,
    f,
    p
  if (((t = wZ.exec(e)), t === null && (t = SZ.exec(e)), t === null))
    throw new Error("Date resolve error")
  if (((r = +t[1]), (n = +t[2] - 1), (i = +t[3]), !t[4]))
    return new Date(Date.UTC(r, n, i))
  if (((s = +t[4]), (o = +t[5]), (a = +t[6]), t[7])) {
    for (l = t[7].slice(0, 3); l.length < 3; ) l += "0"
    l = +l
  }
  return (
    t[9] &&
      ((u = +t[10]),
      (f = +(t[11] || 0)),
      (c = (u * 60 + f) * 6e4),
      t[9] === "-" && (c = -c)),
    (p = new Date(Date.UTC(r, n, i, s, o, a, l))),
    c && p.setTime(p.getTime() - c),
    p
  )
}
function cOe(e) {
  return e.toISOString()
}
var uOe = new Ys("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: aOe,
  construct: lOe,
  instanceOf: Date,
  represent: cOe,
})
function dOe(e) {
  return e === "<<" || e === null
}
var fOe = new Ys("tag:yaml.org,2002:merge", { kind: "scalar", resolve: dOe }),
  BO = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`
function hOe(e) {
  if (e === null) return false
  var t,
    r,
    n = 0,
    i = e.length,
    s = BO
  for (r = 0; r < i; r++)
    if (((t = s.indexOf(e.charAt(r))), !(t > 64))) {
      if (t < 0) return false
      n += 6
    }
  return n % 8 === 0
}
function gOe(e) {
  var t,
    r,
    n = e.replace(/[\r\n=]/g, ""),
    i = n.length,
    s = BO,
    o = 0,
    a = []
  for (t = 0; t < i; t++)
    t % 4 === 0 &&
      t &&
      (a.push((o >> 16) & 255), a.push((o >> 8) & 255), a.push(o & 255)),
      (o = (o << 6) | s.indexOf(n.charAt(t)))
  return (
    (r = (i % 4) * 6),
    r === 0
      ? (a.push((o >> 16) & 255), a.push((o >> 8) & 255), a.push(o & 255))
      : r === 18
        ? (a.push((o >> 10) & 255), a.push((o >> 2) & 255))
        : r === 12 && a.push((o >> 4) & 255),
    new Uint8Array(a)
  )
}
function pOe(e) {
  var t = "",
    r = 0,
    n,
    i,
    s = e.length,
    o = BO
  for (n = 0; n < s; n++)
    n % 3 === 0 &&
      n &&
      ((t += o[(r >> 18) & 63]),
      (t += o[(r >> 12) & 63]),
      (t += o[(r >> 6) & 63]),
      (t += o[r & 63])),
      (r = (r << 8) + e[n])
  return (
    (i = s % 3),
    i === 0
      ? ((t += o[(r >> 18) & 63]),
        (t += o[(r >> 12) & 63]),
        (t += o[(r >> 6) & 63]),
        (t += o[r & 63]))
      : i === 2
        ? ((t += o[(r >> 10) & 63]),
          (t += o[(r >> 4) & 63]),
          (t += o[(r << 2) & 63]),
          (t += o[64]))
        : i === 1 &&
          ((t += o[(r >> 2) & 63]),
          (t += o[(r << 4) & 63]),
          (t += o[64]),
          (t += o[64])),
    t
  )
}
function mOe(e) {
  return Object.prototype.toString.call(e) === "[object Uint8Array]"
}
var AOe = new Ys("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: hOe,
    construct: gOe,
    predicate: mOe,
    represent: pOe,
  }),
  yOe = Object.prototype.hasOwnProperty,
  vOe = Object.prototype.toString
function COe(e) {
  if (e === null) return true
  var t = [],
    r,
    n,
    i,
    s,
    o,
    a = e
  for (r = 0, n = a.length; r < n; r += 1) {
    if (((i = a[r]), (o = false), vOe.call(i) !== "[object Object]")) return false
    for (s in i)
      if (yOe.call(i, s))
        if (!o) o = true
        else return false
    if (!o) return false
    if (t.indexOf(s) === -1) t.push(s)
    else return false
  }
  return true
}
function bOe(e) {
  return e !== null ? e : []
}
var EOe = new Ys("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: COe,
    construct: bOe,
  }),
  _Oe = Object.prototype.toString
function xOe(e) {
  if (e === null) return true
  var t,
    r,
    n,
    i,
    s,
    o = e
  for (s = new Array(o.length), t = 0, r = o.length; t < r; t += 1) {
    if (
      ((n = o[t]),
      _Oe.call(n) !== "[object Object]" ||
        ((i = Object.keys(n)), i.length !== 1))
    )
      return false
    s[t] = [i[0], n[i[0]]]
  }
  return true
}
function wOe(e) {
  if (e === null) return []
  var t,
    r,
    n,
    i,
    s,
    o = e
  for (s = new Array(o.length), t = 0, r = o.length; t < r; t += 1)
    (n = o[t]), (i = Object.keys(n)), (s[t] = [i[0], n[i[0]]])
  return s
}
var SOe = new Ys("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: xOe,
    construct: wOe,
  }),
  IOe = Object.prototype.hasOwnProperty
function BOe(e) {
  if (e === null) return true
  var t,
    r = e
  for (t in r) if (IOe.call(r, t) && r[t] !== null) return false
  return true
}
function ROe(e) {
  return e !== null ? e : {}
}
var DOe = new Ys("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: BOe,
    construct: ROe,
  }),
  IZ = oOe.extend({ implicit: [uOe, fOe], explicit: [AOe, EOe, SOe, DOe] }),
  sh = Object.prototype.hasOwnProperty,
  FB = 1,
  BZ = 2,
  RZ = 3,
  QB = 4,
  EO = 1,
  TOe = 2,
  cZ = 3,
  kOe =
    /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,
  MOe = /[\x85\u2028\u2029]/,
  FOe = /[,\[\]\{\}]/,
  DZ = /^(?:!|!!|![a-z\-]+!)$/i,
  TZ =
    /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i
function uZ(e) {
  return Object.prototype.toString.call(e)
}
function vu(e) {
  return e === 10 || e === 13
}
function yp(e) {
  return e === 9 || e === 32
}
function Yo(e) {
  return e === 9 || e === 32 || e === 10 || e === 13
}
function u0(e) {
  return e === 44 || e === 91 || e === 93 || e === 123 || e === 125
}
function QOe(e) {
  var t
  return 48 <= e && e <= 57
    ? e - 48
    : ((t = e | 32), 97 <= t && t <= 102 ? t - 97 + 10 : -1)
}
function NOe(e) {
  return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0
}
function POe(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1
}
function dZ(e) {
  return e === 48
    ? "\0"
    : e === 97
      ? "\x07"
      : e === 98
        ? "\b"
        : e === 116 || e === 9
          ? "	"
          : e === 110
            ? `
`
            : e === 118
              ? "\v"
              : e === 102
                ? "\f"
                : e === 114
                  ? "\r"
                  : e === 101
                    ? "\x1B"
                    : e === 32
                      ? " "
                      : e === 34
                        ? '"'
                        : e === 47
                          ? "/"
                          : e === 92
                            ? "\\"
                            : e === 78
                              ? "\x85"
                              : e === 95
                                ? "\xA0"
                                : e === 76
                                  ? "\u2028"
                                  : e === 80
                                    ? "\u2029"
                                    : ""
}
function LOe(e) {
  return e <= 65535
    ? String.fromCharCode(e)
    : String.fromCharCode(
        ((e - 65536) >> 10) + 55296,
        ((e - 65536) & 1023) + 56320,
      )
}
var kZ = new Array(256),
  MZ = new Array(256)
for (Ap = 0; Ap < 256; Ap++) (kZ[Ap] = dZ(Ap) ? 1 : 0), (MZ[Ap] = dZ(Ap))
var Ap
function UOe(e, t) {
  ;(this.input = e),
    (this.filename = t.filename || null),
    (this.schema = t.schema || IZ),
    (this.onWarning = t.onWarning || null),
    (this.legacy = t.legacy || false),
    (this.json = t.json || false),
    (this.listener = t.listener || null),
    (this.implicitTypes = this.schema.compiledImplicit),
    (this.typeMap = this.schema.compiledTypeMap),
    (this.length = e.length),
    (this.position = 0),
    (this.line = 0),
    (this.lineStart = 0),
    (this.lineIndent = 0),
    (this.firstTabInLine = -1),
    (this.documents = [])
}
function FZ(e, t) {
  var r = {
    name: e.filename,
    buffer: e.input.slice(0, -1),
    position: e.position,
    line: e.line,
    column: e.position - e.lineStart,
  }
  return (r.snippet = SUe(r)), new $o(t, r)
}
function Xe(e, t) {
  throw FZ(e, t)
}
function NB(e, t) {
  e.onWarning && e.onWarning.call(null, FZ(e, t))
}
var fZ = {
  YAML: function (t, r, n) {
    var i, s, o
    t.version !== null && Xe(t, "duplication of %YAML directive"),
      n.length !== 1 && Xe(t, "YAML directive accepts exactly one argument"),
      (i = /^([0-9]+)\.([0-9]+)$/.exec(n[0])),
      i === null && Xe(t, "ill-formed argument of the YAML directive"),
      (s = parseInt(i[1], 10)),
      (o = parseInt(i[2], 10)),
      s !== 1 && Xe(t, "unacceptable YAML version of the document"),
      (t.version = n[0]),
      (t.checkLineBreaks = o < 2),
      o !== 1 && o !== 2 && NB(t, "unsupported YAML version of the document")
  },
  TAG: function (t, r, n) {
    var i, s
    n.length !== 2 && Xe(t, "TAG directive accepts exactly two arguments"),
      (i = n[0]),
      (s = n[1]),
      DZ.test(i) ||
        Xe(t, "ill-formed tag handle (first argument) of the TAG directive"),
      sh.call(t.tagMap, i) &&
        Xe(
          t,
          'there is a previously declared suffix for "' + i + '" tag handle',
        ),
      TZ.test(s) ||
        Xe(t, "ill-formed tag prefix (second argument) of the TAG directive")
    try {
      s = decodeURIComponent(s)
    } catch {
      Xe(t, "tag prefix is malformed: " + s)
    }
    t.tagMap[i] = s
  },
}
function ih(e, t, r, n) {
  var i, s, o, a
  if (t < r) {
    if (((a = e.input.slice(t, r)), n))
      for (i = 0, s = a.length; i < s; i += 1)
        (o = a.charCodeAt(i)),
          o === 9 ||
            (32 <= o && o <= 1114111) ||
            Xe(e, "expected valid JSON character")
    else kOe.test(a) && Xe(e, "the stream contains non-printable characters")
    e.result += a
  }
}
function hZ(e, t, r, n) {
  var i, s, o, a
  for (
    $i.isObject(r) ||
      Xe(
        e,
        "cannot merge mappings; the provided source object is unacceptable",
      ),
      i = Object.keys(r),
      o = 0,
      a = i.length;
    o < a;
    o += 1
  )
    (s = i[o]), sh.call(t, s) || ((t[s] = r[s]), (n[s] = true))
}
function d0(e, t, r, n, i, s, o, a, l) {
  var c, u
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), c = 0, u = i.length; c < u; c += 1)
      Array.isArray(i[c]) &&
        Xe(e, "nested arrays are not supported inside keys"),
        typeof i == "object" &&
          uZ(i[c]) === "[object Object]" &&
          (i[c] = "[object Object]")
  if (
    (typeof i == "object" &&
      uZ(i) === "[object Object]" &&
      (i = "[object Object]"),
    (i = String(i)),
    t === null && (t = {}),
    n === "tag:yaml.org,2002:merge")
  )
    if (Array.isArray(s))
      for (c = 0, u = s.length; c < u; c += 1) hZ(e, t, s[c], r)
    else hZ(e, t, s, r)
  else
    !e.json &&
      !sh.call(r, i) &&
      sh.call(t, i) &&
      ((e.line = o || e.line),
      (e.lineStart = a || e.lineStart),
      (e.position = l || e.position),
      Xe(e, "duplicated mapping key")),
      i === "__proto__"
        ? Object.defineProperty(t, i, {
            configurable: true,
            enumerable: true,
            writable: true,
            value: s,
          })
        : (t[i] = s),
      delete r[i]
  return t
}
function RO(e) {
  var t
  ;(t = e.input.charCodeAt(e.position)),
    t === 10
      ? e.position++
      : t === 13
        ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++)
        : Xe(e, "a line break is expected"),
    (e.line += 1),
    (e.lineStart = e.position),
    (e.firstTabInLine = -1)
}
function Di(e, t, r) {
  for (var n = 0, i = e.input.charCodeAt(e.position); i !== 0; ) {
    for (; yp(i); )
      i === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position),
        (i = e.input.charCodeAt(++e.position))
    if (t && i === 35)
      do i = e.input.charCodeAt(++e.position)
      while (i !== 10 && i !== 13 && i !== 0)
    if (vu(i))
      for (
        RO(e), i = e.input.charCodeAt(e.position), n++, e.lineIndent = 0;
        i === 32;

      )
        e.lineIndent++, (i = e.input.charCodeAt(++e.position))
    else break
  }
  return (
    r !== -1 && n !== 0 && e.lineIndent < r && NB(e, "deficient indentation"), n
  )
}
function UB(e) {
  var t = e.position,
    r
  return (
    (r = e.input.charCodeAt(t)),
    !!(
      (r === 45 || r === 46) &&
      r === e.input.charCodeAt(t + 1) &&
      r === e.input.charCodeAt(t + 2) &&
      ((t += 3), (r = e.input.charCodeAt(t)), r === 0 || Yo(r))
    )
  )
}
function DO(e, t) {
  t === 1
    ? (e.result += " ")
    : t > 1 &&
      (e.result += $i.repeat(
        `
`,
        t - 1,
      ))
}
function OOe(e, t, r) {
  var n,
    i,
    s,
    o,
    a,
    l,
    c,
    u,
    f = e.kind,
    p = e.result,
    g
  if (
    ((g = e.input.charCodeAt(e.position)),
    Yo(g) ||
      u0(g) ||
      g === 35 ||
      g === 38 ||
      g === 42 ||
      g === 33 ||
      g === 124 ||
      g === 62 ||
      g === 39 ||
      g === 34 ||
      g === 37 ||
      g === 64 ||
      g === 96 ||
      ((g === 63 || g === 45) &&
        ((i = e.input.charCodeAt(e.position + 1)), Yo(i) || (r && u0(i)))))
  )
    return false
  for (
    e.kind = "scalar", e.result = "", s = o = e.position, a = false;
    g !== 0;

  ) {
    if (g === 58) {
      if (((i = e.input.charCodeAt(e.position + 1)), Yo(i) || (r && u0(i))))
        break
    } else if (g === 35) {
      if (((n = e.input.charCodeAt(e.position - 1)), Yo(n))) break
    } else {
      if ((e.position === e.lineStart && UB(e)) || (r && u0(g))) break
      if (vu(g))
        if (
          ((l = e.line),
          (c = e.lineStart),
          (u = e.lineIndent),
          Di(e, false, -1),
          e.lineIndent >= t)
        ) {
          ;(a = true), (g = e.input.charCodeAt(e.position))
          continue
        } else {
          ;(e.position = o), (e.line = l), (e.lineStart = c), (e.lineIndent = u)
          break
        }
    }
    a && (ih(e, s, o, false), DO(e, e.line - l), (s = o = e.position), (a = false)),
      yp(g) || (o = e.position + 1),
      (g = e.input.charCodeAt(++e.position))
  }
  return ih(e, s, o, false), e.result ? true : ((e.kind = f), (e.result = p), false)
}
function qOe(e, t) {
  var r, n, i
  if (((r = e.input.charCodeAt(e.position)), r !== 39)) return false
  for (
    e.kind = "scalar", e.result = "", e.position++, n = i = e.position;
    (r = e.input.charCodeAt(e.position)) !== 0;

  )
    if (r === 39)
      if (
        (ih(e, n, e.position, true),
        (r = e.input.charCodeAt(++e.position)),
        r === 39)
      )
        (n = e.position), e.position++, (i = e.position)
      else return true
    else
      vu(r)
        ? (ih(e, n, i, true), DO(e, Di(e, false, t)), (n = i = e.position))
        : e.position === e.lineStart && UB(e)
          ? Xe(
              e,
              "unexpected end of the document within a single quoted scalar",
            )
          : (e.position++, (i = e.position))
  Xe(e, "unexpected end of the stream within a single quoted scalar")
}
function VOe(e, t) {
  var r, n, i, s, o, a
  if (((a = e.input.charCodeAt(e.position)), a !== 34)) return false
  for (
    e.kind = "scalar", e.result = "", e.position++, r = n = e.position;
    (a = e.input.charCodeAt(e.position)) !== 0;

  ) {
    if (a === 34) return ih(e, r, e.position, true), e.position++, true
    if (a === 92) {
      if (
        (ih(e, r, e.position, true),
        (a = e.input.charCodeAt(++e.position)),
        vu(a))
      )
        Di(e, false, t)
      else if (a < 256 && kZ[a]) (e.result += MZ[a]), e.position++
      else if ((o = NOe(a)) > 0) {
        for (i = o, s = 0; i > 0; i--)
          (a = e.input.charCodeAt(++e.position)),
            (o = QOe(a)) >= 0
              ? (s = (s << 4) + o)
              : Xe(e, "expected hexadecimal character")
        ;(e.result += LOe(s)), e.position++
      } else Xe(e, "unknown escape sequence")
      r = n = e.position
    } else
      vu(a)
        ? (ih(e, r, n, true), DO(e, Di(e, false, t)), (r = n = e.position))
        : e.position === e.lineStart && UB(e)
          ? Xe(
              e,
              "unexpected end of the document within a double quoted scalar",
            )
          : (e.position++, (n = e.position))
  }
  Xe(e, "unexpected end of the stream within a double quoted scalar")
}
function HOe(e, t) {
  var r = true,
    n,
    i,
    s,
    o = e.tag,
    a,
    l = e.anchor,
    c,
    u,
    f,
    p,
    g,
    m = Object.create(null),
    y,
    v,
    C,
    E
  if (((E = e.input.charCodeAt(e.position)), E === 91))
    (u = 93), (g = false), (a = [])
  else if (E === 123) (u = 125), (g = true), (a = {})
  else return false
  for (
    e.anchor !== null && (e.anchorMap[e.anchor] = a),
      E = e.input.charCodeAt(++e.position);
    E !== 0;

  ) {
    if ((Di(e, true, t), (E = e.input.charCodeAt(e.position)), E === u))
      return (
        e.position++,
        (e.tag = o),
        (e.anchor = l),
        (e.kind = g ? "mapping" : "sequence"),
        (e.result = a),
        true
      )
    r
      ? E === 44 && Xe(e, "expected the node content, but found ','")
      : Xe(e, "missed comma between flow collection entries"),
      (v = y = C = null),
      (f = p = false),
      E === 63 &&
        ((c = e.input.charCodeAt(e.position + 1)),
        Yo(c) && ((f = p = true), e.position++, Di(e, true, t))),
      (n = e.line),
      (i = e.lineStart),
      (s = e.position),
      f0(e, t, FB, false, true),
      (v = e.tag),
      (y = e.result),
      Di(e, true, t),
      (E = e.input.charCodeAt(e.position)),
      (p || e.line === n) &&
        E === 58 &&
        ((f = true),
        (E = e.input.charCodeAt(++e.position)),
        Di(e, true, t),
        f0(e, t, FB, false, true),
        (C = e.result)),
      g
        ? d0(e, a, m, v, y, C, n, i, s)
        : f
          ? a.push(d0(e, null, m, v, y, C, n, i, s))
          : a.push(y),
      Di(e, true, t),
      (E = e.input.charCodeAt(e.position)),
      E === 44 ? ((r = true), (E = e.input.charCodeAt(++e.position))) : (r = false)
  }
  Xe(e, "unexpected end of the stream within a flow collection")
}
function WOe(e, t) {
  var r,
    n,
    i = EO,
    s = false,
    o = false,
    a = t,
    l = 0,
    c = false,
    u,
    f
  if (((f = e.input.charCodeAt(e.position)), f === 124)) n = false
  else if (f === 62) n = true
  else return false
  for (e.kind = "scalar", e.result = ""; f !== 0; )
    if (((f = e.input.charCodeAt(++e.position)), f === 43 || f === 45))
      EO === i
        ? (i = f === 43 ? cZ : TOe)
        : Xe(e, "repeat of a chomping mode identifier")
    else if ((u = POe(f)) >= 0)
      u === 0
        ? Xe(
            e,
            "bad explicit indentation width of a block scalar; it cannot be less than one",
          )
        : o
          ? Xe(e, "repeat of an indentation width identifier")
          : ((a = t + u - 1), (o = true))
    else break
  if (yp(f)) {
    do f = e.input.charCodeAt(++e.position)
    while (yp(f))
    if (f === 35)
      do f = e.input.charCodeAt(++e.position)
      while (!vu(f) && f !== 0)
  }
  for (; f !== 0; ) {
    for (
      RO(e), e.lineIndent = 0, f = e.input.charCodeAt(e.position);
      (!o || e.lineIndent < a) && f === 32;

    )
      e.lineIndent++, (f = e.input.charCodeAt(++e.position))
    if ((!o && e.lineIndent > a && (a = e.lineIndent), vu(f))) {
      l++
      continue
    }
    if (e.lineIndent < a) {
      i === cZ
        ? (e.result += $i.repeat(
            `
`,
            s ? 1 + l : l,
          ))
        : i === EO &&
          s &&
          (e.result += `
`)
      break
    }
    for (
      n
        ? yp(f)
          ? ((c = true),
            (e.result += $i.repeat(
              `
`,
              s ? 1 + l : l,
            )))
          : c
            ? ((c = false),
              (e.result += $i.repeat(
                `
`,
                l + 1,
              )))
            : l === 0
              ? s && (e.result += " ")
              : (e.result += $i.repeat(
                  `
`,
                  l,
                ))
        : (e.result += $i.repeat(
            `
`,
            s ? 1 + l : l,
          )),
        s = true,
        o = true,
        l = 0,
        r = e.position;
      !vu(f) && f !== 0;

    )
      f = e.input.charCodeAt(++e.position)
    ih(e, r, e.position, false)
  }
  return true
}
function gZ(e, t) {
  var r,
    n = e.tag,
    i = e.anchor,
    s = [],
    o,
    a = false,
    l
  if (e.firstTabInLine !== -1) return false
  for (
    e.anchor !== null && (e.anchorMap[e.anchor] = s),
      l = e.input.charCodeAt(e.position);
    l !== 0 &&
    (e.firstTabInLine !== -1 &&
      ((e.position = e.firstTabInLine),
      Xe(e, "tab characters must not be used in indentation")),
    !(l !== 45 || ((o = e.input.charCodeAt(e.position + 1)), !Yo(o))));

  ) {
    if (((a = true), e.position++, Di(e, true, -1) && e.lineIndent <= t)) {
      s.push(null), (l = e.input.charCodeAt(e.position))
      continue
    }
    if (
      ((r = e.line),
      f0(e, t, RZ, false, true),
      s.push(e.result),
      Di(e, true, -1),
      (l = e.input.charCodeAt(e.position)),
      (e.line === r || e.lineIndent > t) && l !== 0)
    )
      Xe(e, "bad indentation of a sequence entry")
    else if (e.lineIndent < t) break
  }
  return a
    ? ((e.tag = n), (e.anchor = i), (e.kind = "sequence"), (e.result = s), true)
    : false
}
function GOe(e, t, r) {
  var n,
    i,
    s,
    o,
    a,
    l,
    c = e.tag,
    u = e.anchor,
    f = {},
    p = Object.create(null),
    g = null,
    m = null,
    y = null,
    v = false,
    C = false,
    E
  if (e.firstTabInLine !== -1) return false
  for (
    e.anchor !== null && (e.anchorMap[e.anchor] = f),
      E = e.input.charCodeAt(e.position);
    E !== 0;

  ) {
    if (
      (!v &&
        e.firstTabInLine !== -1 &&
        ((e.position = e.firstTabInLine),
        Xe(e, "tab characters must not be used in indentation")),
      (n = e.input.charCodeAt(e.position + 1)),
      (s = e.line),
      (E === 63 || E === 58) && Yo(n))
    )
      E === 63
        ? (v && (d0(e, f, p, g, m, null, o, a, l), (g = m = y = null)),
          (C = true),
          (v = true),
          (i = true))
        : v
          ? ((v = false), (i = true))
          : Xe(
              e,
              "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line",
            ),
        (e.position += 1),
        (E = n)
    else {
      if (
        ((o = e.line),
        (a = e.lineStart),
        (l = e.position),
        !f0(e, r, BZ, false, true))
      )
        break
      if (e.line === s) {
        for (E = e.input.charCodeAt(e.position); yp(E); )
          E = e.input.charCodeAt(++e.position)
        if (E === 58)
          (E = e.input.charCodeAt(++e.position)),
            Yo(E) ||
              Xe(
                e,
                "a whitespace character is expected after the key-value separator within a block mapping",
              ),
            v && (d0(e, f, p, g, m, null, o, a, l), (g = m = y = null)),
            (C = true),
            (v = false),
            (i = false),
            (g = e.tag),
            (m = e.result)
        else if (C)
          Xe(e, "can not read an implicit mapping pair; a colon is missed")
        else return (e.tag = c), (e.anchor = u), true
      } else if (C)
        Xe(
          e,
          "can not read a block mapping entry; a multiline key may not be an implicit key",
        )
      else return (e.tag = c), (e.anchor = u), true
    }
    if (
      ((e.line === s || e.lineIndent > t) &&
        (v && ((o = e.line), (a = e.lineStart), (l = e.position)),
        f0(e, t, QB, true, i) && (v ? (m = e.result) : (y = e.result)),
        v || (d0(e, f, p, g, m, y, o, a, l), (g = m = y = null)),
        Di(e, true, -1),
        (E = e.input.charCodeAt(e.position))),
      (e.line === s || e.lineIndent > t) && E !== 0)
    )
      Xe(e, "bad indentation of a mapping entry")
    else if (e.lineIndent < t) break
  }
  return (
    v && d0(e, f, p, g, m, null, o, a, l),
    C && ((e.tag = c), (e.anchor = u), (e.kind = "mapping"), (e.result = f)),
    C
  )
}
function $Oe(e) {
  var t,
    r = false,
    n = false,
    i,
    s,
    o
  if (((o = e.input.charCodeAt(e.position)), o !== 33)) return false
  if (
    (e.tag !== null && Xe(e, "duplication of a tag property"),
    (o = e.input.charCodeAt(++e.position)),
    o === 60
      ? ((r = true), (o = e.input.charCodeAt(++e.position)))
      : o === 33
        ? ((n = true), (i = "!!"), (o = e.input.charCodeAt(++e.position)))
        : (i = "!"),
    (t = e.position),
    r)
  ) {
    do o = e.input.charCodeAt(++e.position)
    while (o !== 0 && o !== 62)
    e.position < e.length
      ? ((s = e.input.slice(t, e.position)),
        (o = e.input.charCodeAt(++e.position)))
      : Xe(e, "unexpected end of the stream within a verbatim tag")
  } else {
    for (; o !== 0 && !Yo(o); )
      o === 33 &&
        (n
          ? Xe(e, "tag suffix cannot contain exclamation marks")
          : ((i = e.input.slice(t - 1, e.position + 1)),
            DZ.test(i) ||
              Xe(e, "named tag handle cannot contain such characters"),
            (n = true),
            (t = e.position + 1))),
        (o = e.input.charCodeAt(++e.position))
    ;(s = e.input.slice(t, e.position)),
      FOe.test(s) &&
        Xe(e, "tag suffix cannot contain flow indicator characters")
  }
  s && !TZ.test(s) && Xe(e, "tag name cannot contain such characters: " + s)
  try {
    s = decodeURIComponent(s)
  } catch {
    Xe(e, "tag name is malformed: " + s)
  }
  return (
    r
      ? (e.tag = s)
      : sh.call(e.tagMap, i)
        ? (e.tag = e.tagMap[i] + s)
        : i === "!"
          ? (e.tag = "!" + s)
          : i === "!!"
            ? (e.tag = "tag:yaml.org,2002:" + s)
            : Xe(e, 'undeclared tag handle "' + i + '"'),
    true
  )
}
function YOe(e) {
  var t, r
  if (((r = e.input.charCodeAt(e.position)), r !== 38)) return false
  for (
    e.anchor !== null && Xe(e, "duplication of an anchor property"),
      r = e.input.charCodeAt(++e.position),
      t = e.position;
    r !== 0 && !Yo(r) && !u0(r);

  )
    r = e.input.charCodeAt(++e.position)
  return (
    e.position === t &&
      Xe(e, "name of an anchor node must contain at least one character"),
    (e.anchor = e.input.slice(t, e.position)),
    true
  )
}
function KOe(e) {
  var t, r, n
  if (((n = e.input.charCodeAt(e.position)), n !== 42)) return false
  for (
    n = e.input.charCodeAt(++e.position), t = e.position;
    n !== 0 && !Yo(n) && !u0(n);

  )
    n = e.input.charCodeAt(++e.position)
  return (
    e.position === t &&
      Xe(e, "name of an alias node must contain at least one character"),
    (r = e.input.slice(t, e.position)),
    sh.call(e.anchorMap, r) || Xe(e, 'unidentified alias "' + r + '"'),
    (e.result = e.anchorMap[r]),
    Di(e, true, -1),
    true
  )
}
function f0(e, t, r, n, i) {
  var s,
    o,
    a,
    l = 1,
    c = false,
    u = false,
    f,
    p,
    g,
    m,
    y,
    v
  if (
    (e.listener !== null && e.listener("open", e),
    (e.tag = null),
    (e.anchor = null),
    (e.kind = null),
    (e.result = null),
    (s = o = a = QB === r || RZ === r),
    n &&
      Di(e, true, -1) &&
      ((c = true),
      e.lineIndent > t
        ? (l = 1)
        : e.lineIndent === t
          ? (l = 0)
          : e.lineIndent < t && (l = -1)),
    l === 1)
  )
    for (; $Oe(e) || YOe(e); )
      Di(e, true, -1)
        ? ((c = true),
          (a = s),
          e.lineIndent > t
            ? (l = 1)
            : e.lineIndent === t
              ? (l = 0)
              : e.lineIndent < t && (l = -1))
        : (a = false)
  if (
    (a && (a = c || i),
    (l === 1 || QB === r) &&
      (FB === r || BZ === r ? (y = t) : (y = t + 1),
      (v = e.position - e.lineStart),
      l === 1
        ? (a && (gZ(e, v) || GOe(e, v, y))) || HOe(e, y)
          ? (u = true)
          : ((o && WOe(e, y)) || qOe(e, y) || VOe(e, y)
              ? (u = true)
              : KOe(e)
                ? ((u = true),
                  (e.tag !== null || e.anchor !== null) &&
                    Xe(e, "alias node should not have any properties"))
                : OOe(e, y, FB === r) &&
                  ((u = true), e.tag === null && (e.tag = "?")),
            e.anchor !== null && (e.anchorMap[e.anchor] = e.result))
        : l === 0 && (u = a && gZ(e, v))),
    e.tag === null)
  )
    e.anchor !== null && (e.anchorMap[e.anchor] = e.result)
  else if (e.tag === "?") {
    for (
      e.result !== null &&
        e.kind !== "scalar" &&
        Xe(
          e,
          'unacceptable node kind for !<?> tag; it should be "scalar", not "' +
            e.kind +
            '"',
        ),
        f = 0,
        p = e.implicitTypes.length;
      f < p;
      f += 1
    )
      if (((m = e.implicitTypes[f]), m.resolve(e.result))) {
        ;(e.result = m.construct(e.result)),
          (e.tag = m.tag),
          e.anchor !== null && (e.anchorMap[e.anchor] = e.result)
        break
      }
  } else if (e.tag !== "!") {
    if (sh.call(e.typeMap[e.kind || "fallback"], e.tag))
      m = e.typeMap[e.kind || "fallback"][e.tag]
    else
      for (
        m = null,
          g = e.typeMap.multi[e.kind || "fallback"],
          f = 0,
          p = g.length;
        f < p;
        f += 1
      )
        if (e.tag.slice(0, g[f].tag.length) === g[f].tag) {
          m = g[f]
          break
        }
    m || Xe(e, "unknown tag !<" + e.tag + ">"),
      e.result !== null &&
        m.kind !== e.kind &&
        Xe(
          e,
          "unacceptable node kind for !<" +
            e.tag +
            '> tag; it should be "' +
            m.kind +
            '", not "' +
            e.kind +
            '"',
        ),
      m.resolve(e.result, e.tag)
        ? ((e.result = m.construct(e.result, e.tag)),
          e.anchor !== null && (e.anchorMap[e.anchor] = e.result))
        : Xe(e, "cannot resolve a node with !<" + e.tag + "> explicit tag")
  }
  return (
    e.listener !== null && e.listener("close", e),
    e.tag !== null || e.anchor !== null || u
  )
}
function zOe(e) {
  var t = e.position,
    r,
    n,
    i,
    s = false,
    o
  for (
    e.version = null,
      e.checkLineBreaks = e.legacy,
      e.tagMap = Object.create(null),
      e.anchorMap = Object.create(null);
    (o = e.input.charCodeAt(e.position)) !== 0 &&
    (Di(e, true, -1),
    (o = e.input.charCodeAt(e.position)),
    !(e.lineIndent > 0 || o !== 37));

  ) {
    for (
      s = true, o = e.input.charCodeAt(++e.position), r = e.position;
      o !== 0 && !Yo(o);

    )
      o = e.input.charCodeAt(++e.position)
    for (
      n = e.input.slice(r, e.position),
        i = [],
        n.length < 1 &&
          Xe(e, "directive name must not be less than one character in length");
      o !== 0;

    ) {
      for (; yp(o); ) o = e.input.charCodeAt(++e.position)
      if (o === 35) {
        do o = e.input.charCodeAt(++e.position)
        while (o !== 0 && !vu(o))
        break
      }
      if (vu(o)) break
      for (r = e.position; o !== 0 && !Yo(o); )
        o = e.input.charCodeAt(++e.position)
      i.push(e.input.slice(r, e.position))
    }
    o !== 0 && RO(e),
      sh.call(fZ, n)
        ? fZ[n](e, n, i)
        : NB(e, 'unknown document directive "' + n + '"')
  }
  if (
    (Di(e, true, -1),
    e.lineIndent === 0 &&
    e.input.charCodeAt(e.position) === 45 &&
    e.input.charCodeAt(e.position + 1) === 45 &&
    e.input.charCodeAt(e.position + 2) === 45
      ? ((e.position += 3), Di(e, true, -1))
      : s && Xe(e, "directives end mark is expected"),
    f0(e, e.lineIndent - 1, QB, false, true),
    Di(e, true, -1),
    e.checkLineBreaks &&
      MOe.test(e.input.slice(t, e.position)) &&
      NB(e, "non-ASCII line breaks are interpreted as content"),
    e.documents.push(e.result),
    e.position === e.lineStart && UB(e))
  ) {
    e.input.charCodeAt(e.position) === 46 && ((e.position += 3), Di(e, true, -1))
    return
  }
  if (e.position < e.length - 1)
    Xe(e, "end of the stream or a document separator is expected")
  else return
}
function QZ(e, t) {
  ;(e = String(e)),
    (t = t || {}),
    e.length !== 0 &&
      (e.charCodeAt(e.length - 1) !== 10 &&
        e.charCodeAt(e.length - 1) !== 13 &&
        (e += `
`),
      e.charCodeAt(0) === 65279 && (e = e.slice(1)))
  var r = new UOe(e, t),
    n = e.indexOf("\0")
  for (
    n !== -1 && ((r.position = n), Xe(r, "null byte is not allowed in input")),
      r.input += "\0";
    r.input.charCodeAt(r.position) === 32;

  )
    (r.lineIndent += 1), (r.position += 1)
  for (; r.position < r.length - 1; ) zOe(r)
  return r.documents
}
function JOe(e, t, r) {
  t !== null && typeof t == "object" && typeof r > "u" && ((r = t), (t = null))
  var n = QZ(e, r)
  if (typeof t != "function") return n
  for (var i = 0, s = n.length; i < s; i += 1) t(n[i])
}
function jOe(e, t) {
  var r = QZ(e, t)
  if (r.length !== 0) {
    if (r.length === 1) return r[0]
    throw new $o("expected a single document in the stream, but found more")
  }
}
var ZOe = JOe,
  XOe = jOe,
  NZ = { loadAll: ZOe, load: XOe },
  PZ = Object.prototype.toString,
  LZ = Object.prototype.hasOwnProperty,
  TO = 65279,
  eqe = 9,
  Kb = 10,
  tqe = 13,
  rqe = 32,
  nqe = 33,
  iqe = 34,
  xO = 35,
  sqe = 37,
  oqe = 38,
  aqe = 39,
  lqe = 42,
  UZ = 44,
  cqe = 45,
  PB = 58,
  uqe = 61,
  dqe = 62,
  fqe = 63,
  hqe = 64,
  OZ = 91,
  qZ = 93,
  gqe = 96,
  VZ = 123,
  pqe = 124,
  HZ = 125,
  Ks = {}
Ks[0] = "\\0"
Ks[7] = "\\a"
Ks[8] = "\\b"
Ks[9] = "\\t"
Ks[10] = "\\n"
Ks[11] = "\\v"
Ks[12] = "\\f"
Ks[13] = "\\r"
Ks[27] = "\\e"
Ks[34] = '\\"'
Ks[92] = "\\\\"
Ks[133] = "\\N"
Ks[160] = "\\_"
Ks[8232] = "\\L"
Ks[8233] = "\\P"
var mqe = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF",
  ],
  Aqe = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/
function yqe(e, t) {
  var r, n, i, s, o, a, l
  if (t === null) return {}
  for (r = {}, n = Object.keys(t), i = 0, s = n.length; i < s; i += 1)
    (o = n[i]),
      (a = String(t[o])),
      o.slice(0, 2) === "!!" && (o = "tag:yaml.org,2002:" + o.slice(2)),
      (l = e.compiledTypeMap.fallback[o]),
      l && LZ.call(l.styleAliases, a) && (a = l.styleAliases[a]),
      (r[o] = a)
  return r
}
function vqe(e) {
  var t, r, n
  if (((t = e.toString(16).toUpperCase()), e <= 255)) (r = "x"), (n = 2)
  else if (e <= 65535) (r = "u"), (n = 4)
  else if (e <= 4294967295) (r = "U"), (n = 8)
  else
    throw new $o(
      "code point within a string may not be greater than 0xFFFFFFFF",
    )
  return "\\" + r + $i.repeat("0", n - t.length) + t
}
var Cqe = 1,
  zb = 2
function bqe(e) {
  ;(this.schema = e.schema || IZ),
    (this.indent = Math.max(1, e.indent || 2)),
    (this.noArrayIndent = e.noArrayIndent || false),
    (this.skipInvalid = e.skipInvalid || false),
    (this.flowLevel = $i.isNothing(e.flowLevel) ? -1 : e.flowLevel),
    (this.styleMap = yqe(this.schema, e.styles || null)),
    (this.sortKeys = e.sortKeys || false),
    (this.lineWidth = e.lineWidth || 80),
    (this.noRefs = e.noRefs || false),
    (this.noCompatMode = e.noCompatMode || false),
    (this.condenseFlow = e.condenseFlow || false),
    (this.quotingType = e.quotingType === '"' ? zb : Cqe),
    (this.forceQuotes = e.forceQuotes || false),
    (this.replacer = typeof e.replacer == "function" ? e.replacer : null),
    (this.implicitTypes = this.schema.compiledImplicit),
    (this.explicitTypes = this.schema.compiledExplicit),
    (this.tag = null),
    (this.result = ""),
    (this.duplicates = []),
    (this.usedDuplicates = null)
}
function pZ(e, t) {
  for (
    var r = $i.repeat(" ", t), n = 0, i = -1, s = "", o, a = e.length;
    n < a;

  )
    (i = e.indexOf(
      `
`,
      n,
    )),
      i === -1
        ? ((o = e.slice(n)), (n = a))
        : ((o = e.slice(n, i + 1)), (n = i + 1)),
      o.length &&
        o !==
          `
` &&
        (s += r),
      (s += o)
  return s
}
function wO(e, t) {
  return (
    `
` + $i.repeat(" ", e.indent * t)
  )
}
function Eqe(e, t) {
  var r, n, i
  for (r = 0, n = e.implicitTypes.length; r < n; r += 1)
    if (((i = e.implicitTypes[r]), i.resolve(t))) return true
  return false
}
function LB(e) {
  return e === rqe || e === eqe
}
function Jb(e) {
  return (
    (32 <= e && e <= 126) ||
    (161 <= e && e <= 55295 && e !== 8232 && e !== 8233) ||
    (57344 <= e && e <= 65533 && e !== TO) ||
    (65536 <= e && e <= 1114111)
  )
}
function mZ(e) {
  return Jb(e) && e !== TO && e !== tqe && e !== Kb
}
function AZ(e, t, r) {
  var n = mZ(e),
    i = n && !LB(e)
  return (
    ((r ? n : n && e !== UZ && e !== OZ && e !== qZ && e !== VZ && e !== HZ) &&
      e !== xO &&
      !(t === PB && !i)) ||
    (mZ(t) && !LB(t) && e === xO) ||
    (t === PB && i)
  )
}
function _qe(e) {
  return (
    Jb(e) &&
    e !== TO &&
    !LB(e) &&
    e !== cqe &&
    e !== fqe &&
    e !== PB &&
    e !== UZ &&
    e !== OZ &&
    e !== qZ &&
    e !== VZ &&
    e !== HZ &&
    e !== xO &&
    e !== oqe &&
    e !== lqe &&
    e !== nqe &&
    e !== pqe &&
    e !== uqe &&
    e !== dqe &&
    e !== aqe &&
    e !== iqe &&
    e !== sqe &&
    e !== hqe &&
    e !== gqe
  )
}
function xqe(e) {
  return !LB(e) && e !== PB
}
function $b(e, t) {
  var r = e.charCodeAt(t),
    n
  return r >= 55296 &&
    r <= 56319 &&
    t + 1 < e.length &&
    ((n = e.charCodeAt(t + 1)), n >= 56320 && n <= 57343)
    ? (r - 55296) * 1024 + n - 56320 + 65536
    : r
}
function WZ(e) {
  var t = /^\n* /
  return t.test(e)
}
var GZ = 1,
  SO = 2,
  $Z = 3,
  YZ = 4,
  c0 = 5
function wqe(e, t, r, n, i, s, o, a) {
  var l,
    c = 0,
    u = null,
    f = false,
    p = false,
    g = n !== -1,
    m = -1,
    y = _qe($b(e, 0)) && xqe($b(e, e.length - 1))
  if (t || o)
    for (l = 0; l < e.length; c >= 65536 ? (l += 2) : l++) {
      if (((c = $b(e, l)), !Jb(c))) return c0
      ;(y = y && AZ(c, u, a)), (u = c)
    }
  else {
    for (l = 0; l < e.length; c >= 65536 ? (l += 2) : l++) {
      if (((c = $b(e, l)), c === Kb))
        (f = true), g && ((p = p || (l - m - 1 > n && e[m + 1] !== " ")), (m = l))
      else if (!Jb(c)) return c0
      ;(y = y && AZ(c, u, a)), (u = c)
    }
    p = p || (g && l - m - 1 > n && e[m + 1] !== " ")
  }
  return !f && !p
    ? y && !o && !i(e)
      ? GZ
      : s === zb
        ? c0
        : SO
    : r > 9 && WZ(e)
      ? c0
      : o
        ? s === zb
          ? c0
          : SO
        : p
          ? YZ
          : $Z
}
function Sqe(e, t, r, n, i) {
  e.dump = (function () {
    if (t.length === 0) return e.quotingType === zb ? '""' : "''"
    if (!e.noCompatMode && (mqe.indexOf(t) !== -1 || Aqe.test(t)))
      return e.quotingType === zb ? '"' + t + '"' : "'" + t + "'"
    var s = e.indent * Math.max(1, r),
      o =
        e.lineWidth === -1
          ? -1
          : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - s),
      a = n || (e.flowLevel > -1 && r >= e.flowLevel)
    function l(c) {
      return Eqe(e, c)
    }
    switch (wqe(t, a, e.indent, o, l, e.quotingType, e.forceQuotes && !n, i)) {
      case GZ:
        return t
      case SO:
        return "'" + t.replace(/'/g, "''") + "'"
      case $Z:
        return "|" + yZ(t, e.indent) + vZ(pZ(t, s))
      case YZ:
        return ">" + yZ(t, e.indent) + vZ(pZ(Iqe(t, o), s))
      case c0:
        return '"' + Bqe(t) + '"'
      default:
        throw new $o("impossible error: invalid scalar style")
    }
  })()
}
function yZ(e, t) {
  var r = WZ(e) ? String(t) : "",
    n =
      e[e.length - 1] ===
      `
`,
    i =
      n &&
      (e[e.length - 2] ===
        `
` ||
        e ===
          `
`),
    s = i ? "+" : n ? "" : "-"
  return (
    r +
    s +
    `
`
  )
}
function vZ(e) {
  return e[e.length - 1] ===
    `
`
    ? e.slice(0, -1)
    : e
}
function Iqe(e, t) {
  for (
    var r = /(\n+)([^\n]*)/g,
      n = (function () {
        var c = e.indexOf(`
`)
        return (
          (c = c !== -1 ? c : e.length), (r.lastIndex = c), CZ(e.slice(0, c), t)
        )
      })(),
      i =
        e[0] ===
          `
` || e[0] === " ",
      s,
      o;
    (o = r.exec(e));

  ) {
    var a = o[1],
      l = o[2]
    ;(s = l[0] === " "),
      (n +=
        a +
        (!i && !s && l !== ""
          ? `
`
          : "") +
        CZ(l, t)),
      (i = s)
  }
  return n
}
function CZ(e, t) {
  if (e === "" || e[0] === " ") return e
  for (var r = / [^ ]/g, n, i = 0, s, o = 0, a = 0, l = ""; (n = r.exec(e)); )
    (a = n.index),
      a - i > t &&
        ((s = o > i ? o : a),
        (l +=
          `
` + e.slice(i, s)),
        (i = s + 1)),
      (o = a)
  return (
    (l += `
`),
    e.length - i > t && o > i
      ? (l +=
          e.slice(i, o) +
          `
` +
          e.slice(o + 1))
      : (l += e.slice(i)),
    l.slice(1)
  )
}
function Bqe(e) {
  for (var t = "", r = 0, n, i = 0; i < e.length; r >= 65536 ? (i += 2) : i++)
    (r = $b(e, i)),
      (n = Ks[r]),
      !n && Jb(r)
        ? ((t += e[i]), r >= 65536 && (t += e[i + 1]))
        : (t += n || vqe(r))
  return t
}
function Rqe(e, t, r) {
  var n = "",
    i = e.tag,
    s,
    o,
    a
  for (s = 0, o = r.length; s < o; s += 1)
    (a = r[s]),
      e.replacer && (a = e.replacer.call(r, String(s), a)),
      (Pd(e, t, a, false, false) || (typeof a > "u" && Pd(e, t, null, false, false))) &&
        (n !== "" && (n += "," + (e.condenseFlow ? "" : " ")), (n += e.dump))
  ;(e.tag = i), (e.dump = "[" + n + "]")
}
function bZ(e, t, r, n) {
  var i = "",
    s = e.tag,
    o,
    a,
    l
  for (o = 0, a = r.length; o < a; o += 1)
    (l = r[o]),
      e.replacer && (l = e.replacer.call(r, String(o), l)),
      (Pd(e, t + 1, l, true, true, false, true) ||
        (typeof l > "u" && Pd(e, t + 1, null, true, true, false, true))) &&
        ((!n || i !== "") && (i += wO(e, t)),
        e.dump && Kb === e.dump.charCodeAt(0) ? (i += "-") : (i += "- "),
        (i += e.dump))
  ;(e.tag = s), (e.dump = i || "[]")
}
function Dqe(e, t, r) {
  var n = "",
    i = e.tag,
    s = Object.keys(r),
    o,
    a,
    l,
    c,
    u
  for (o = 0, a = s.length; o < a; o += 1)
    (u = ""),
      n !== "" && (u += ", "),
      e.condenseFlow && (u += '"'),
      (l = s[o]),
      (c = r[l]),
      e.replacer && (c = e.replacer.call(r, l, c)),
      Pd(e, t, l, false, false) &&
        (e.dump.length > 1024 && (u += "? "),
        (u +=
          e.dump +
          (e.condenseFlow ? '"' : "") +
          ":" +
          (e.condenseFlow ? "" : " ")),
        Pd(e, t, c, false, false) && ((u += e.dump), (n += u)))
  ;(e.tag = i), (e.dump = "{" + n + "}")
}
function Tqe(e, t, r, n) {
  var i = "",
    s = e.tag,
    o = Object.keys(r),
    a,
    l,
    c,
    u,
    f,
    p
  if (e.sortKeys === true) o.sort()
  else if (typeof e.sortKeys == "function") o.sort(e.sortKeys)
  else if (e.sortKeys) throw new $o("sortKeys must be a boolean or a function")
  for (a = 0, l = o.length; a < l; a += 1)
    (p = ""),
      (!n || i !== "") && (p += wO(e, t)),
      (c = o[a]),
      (u = r[c]),
      e.replacer && (u = e.replacer.call(r, c, u)),
      Pd(e, t + 1, c, true, true, true) &&
        ((f =
          (e.tag !== null && e.tag !== "?") ||
          (e.dump && e.dump.length > 1024)),
        f && (e.dump && Kb === e.dump.charCodeAt(0) ? (p += "?") : (p += "? ")),
        (p += e.dump),
        f && (p += wO(e, t)),
        Pd(e, t + 1, u, true, f) &&
          (e.dump && Kb === e.dump.charCodeAt(0) ? (p += ":") : (p += ": "),
          (p += e.dump),
          (i += p)))
  ;(e.tag = s), (e.dump = i || "{}")
}
function EZ(e, t, r) {
  var n, i, s, o, a, l
  for (
    i = r ? e.explicitTypes : e.implicitTypes, s = 0, o = i.length;
    s < o;
    s += 1
  )
    if (
      ((a = i[s]),
      (a.instanceOf || a.predicate) &&
        (!a.instanceOf ||
          (typeof t == "object" && t instanceof a.instanceOf)) &&
        (!a.predicate || a.predicate(t)))
    ) {
      if (
        (r
          ? a.multi && a.representName
            ? (e.tag = a.representName(t))
            : (e.tag = a.tag)
          : (e.tag = "?"),
        a.represent)
      ) {
        if (
          ((l = e.styleMap[a.tag] || a.defaultStyle),
          PZ.call(a.represent) === "[object Function]")
        )
          n = a.represent(t, l)
        else if (LZ.call(a.represent, l)) n = a.represent[l](t, l)
        else
          throw new $o(
            "!<" + a.tag + '> tag resolver accepts not "' + l + '" style',
          )
        e.dump = n
      }
      return true
    }
  return false
}
function Pd(e, t, r, n, i, s, o) {
  ;(e.tag = null), (e.dump = r), EZ(e, r, false) || EZ(e, r, true)
  var a = PZ.call(e.dump),
    l = n,
    c
  n && (n = e.flowLevel < 0 || e.flowLevel > t)
  var u = a === "[object Object]" || a === "[object Array]",
    f,
    p
  if (
    (u && ((f = e.duplicates.indexOf(r)), (p = f !== -1)),
    ((e.tag !== null && e.tag !== "?") || p || (e.indent !== 2 && t > 0)) &&
      (i = false),
    p && e.usedDuplicates[f])
  )
    e.dump = "*ref_" + f
  else {
    if (
      (u && p && !e.usedDuplicates[f] && (e.usedDuplicates[f] = true),
      a === "[object Object]")
    )
      n && Object.keys(e.dump).length !== 0
        ? (Tqe(e, t, e.dump, i), p && (e.dump = "&ref_" + f + e.dump))
        : (Dqe(e, t, e.dump), p && (e.dump = "&ref_" + f + " " + e.dump))
    else if (a === "[object Array]")
      n && e.dump.length !== 0
        ? (e.noArrayIndent && !o && t > 0
            ? bZ(e, t - 1, e.dump, i)
            : bZ(e, t, e.dump, i),
          p && (e.dump = "&ref_" + f + e.dump))
        : (Rqe(e, t, e.dump), p && (e.dump = "&ref_" + f + " " + e.dump))
    else if (a === "[object String]") e.tag !== "?" && Sqe(e, e.dump, t, s, l)
    else {
      if (a === "[object Undefined]") return false
      if (e.skipInvalid) return false
      throw new $o("unacceptable kind of an object to dump " + a)
    }
    e.tag !== null &&
      e.tag !== "?" &&
      ((c = encodeURI(e.tag[0] === "!" ? e.tag.slice(1) : e.tag).replace(
        /!/g,
        "%21",
      )),
      e.tag[0] === "!"
        ? (c = "!" + c)
        : c.slice(0, 18) === "tag:yaml.org,2002:"
          ? (c = "!!" + c.slice(18))
          : (c = "!<" + c + ">"),
      (e.dump = c + " " + e.dump))
  }
  return true
}
function kqe(e, t) {
  var r = [],
    n = [],
    i,
    s
  for (IO(e, r, n), i = 0, s = n.length; i < s; i += 1)
    t.duplicates.push(r[n[i]])
  t.usedDuplicates = new Array(s)
}
function IO(e, t, r) {
  var n, i, s
  if (e !== null && typeof e == "object")
    if (((i = t.indexOf(e)), i !== -1)) r.indexOf(i) === -1 && r.push(i)
    else if ((t.push(e), Array.isArray(e)))
      for (i = 0, s = e.length; i < s; i += 1) IO(e[i], t, r)
    else
      for (n = Object.keys(e), i = 0, s = n.length; i < s; i += 1)
        IO(e[n[i]], t, r)
}
function Mqe(e, t) {
  t = t || {}
  var r = new bqe(t)
  r.noRefs || kqe(e, r)
  var n = e
  return (
    r.replacer && (n = r.replacer.call({ "": n }, "", n)),
    Pd(r, 0, n, true, true)
      ? r.dump +
        `
`
      : ""
  )
}
var Fqe = Mqe,
  Qqe = { dump: Fqe }
function kO(e, t) {
  return function () {
    throw new Error(
      "Function yaml." +
        e +
        " is removed in js-yaml 4. Use yaml." +
        t +
        " instead, which is now safe by default.",
    )
  }
}
var OB = NZ.load,
  vIt = NZ.loadAll,
  CIt = Qqe.dump
var bIt = kO("safeLoad", "load"),
  EIt = kO("safeLoadAll", "loadAll"),
  _It = kO("safeDump", "dump")
var KZ = [">", "<", "|", "&", "$", "`", ";"],
  Pqe = [...KZ, "="],
  Lqe = [
    "|",
    "&",
    ";",
    "$",
    "`",
    "(",
    ")",
    "{",
    "}",
    "<",
    ">",
    "[",
    "]",
    '"',
    "'",
    ".",
  ]
function h0(e) {
  return e === "win32" ? "powershell" : e === "darwin" ? "zsh" : "bash"
}
function MO(e) {
  return e === "bash" || e === "powershell" || e === "zsh"
}
function zZ(e, t) {
  if (t === "bash") {
    for (let r of KZ) if (e.includes(r)) return
    return e.split(" ")
  } else if (t === "powershell") {
    for (let r of Lqe) if (e.includes(r)) return
    return e.split(" ")
  } else if (t === "zsh") {
    for (let r of Pqe) if (e.includes(r)) return
    return e.split(" ")
  }
}
var Uqe = `
auto_approval:
  git:
    - type: prefix
      args: ["status"]
    - type: prefix
      args: ["log"]
    - type: prefix
      args: ["diff"]
    - type: prefix
      args: ["show"]
    - type: exact
      args: ["branch"]
    - type: prefix
      args: ["ls-files"]
    - type: prefix
      args: ["blame"]
    - type: prefix
      args: ["rev-parse"]
    - type: prefix
      args: ["remote", "-v"]
    - type: prefix
      args: ["config", "--list"]
    - type: exact
      args: ["config", "user.name"]
    - type: exact
      args: ["config", "user.email"]
    - type: exact
      args: ["branch", "--show-current"]

  kubectl:
    - type: prefix
      args: ["get"]
    - type: prefix
      args: ["describe"]
    - type: prefix
      args: ["explain"]
    - type: prefix
      args: ["logs"]
    - type: prefix
      args: ["top"]
    - type: prefix
      args: ["api-resources"]
    - type: prefix
      args: ["api-versions"]
    - type: prefix
      args: ["version"]
    - type: prefix
      args: ["wait"]
    - type: prefix
      args: ["auth", "can-i"]
    - type: prefix
      args: ["config", "get-contexts"]
    - type: prefix
      args: ["config", "view"]

  bazel:
    - type: prefix
      args: ["query"]
    - type: prefix
      args: ["cquery"]
    - type: prefix
      args: ["config"]
    - type: prefix
      args: ["info"]
    - type: prefix
      args: ["version"]
    - type: prefix
      args: ["help"]
    - type: prefix
      args: ["analyze-profile"]
    - type: prefix
      args: ["aquery"]
    - type: prefix
      args: ["dump"]
    - type: prefix
      args: ["license"]
    - type: prefix
      args: ["print"]
    - type: prefix
      args: ["build", "--nobuild"]
    - type: prefix
      args: ["coverage", "--nobuild"]
    - type: prefix
      args: ["mobile-install", "--nobuild"]
    - type: prefix
      args: ["run", "--nobuild"]
    - type: prefix
      args: ["text", "--nobuild"]
    - type: prefix
      args: ["clean", "--expunge", "--dry-run"]

  docker:
    - type: prefix
      args: ["ps"]
    - type: prefix
      args: ["images"]
    - type: prefix
      args: ["network", "ls"]
    - type: prefix
      args: ["volume", "ls"]
    - type: prefix
      args: ["port"]
    - type: prefix
      args: ["stats"]
    - type: prefix
      args: ["events"]
    - type: prefix
      args: ["diff"]
    - type: prefix
      args: ["history"]
    - type: prefix
      args: ["system", "df"]
    - type: prefix
      args: ["top"]
    - type: prefix
      args: ["version"]
    - type: prefix
      args: ["inspect"]

  npm:
    - type: prefix
      args: ["list"]
    - type: prefix
      args: ["outdated"]
    - type: prefix
      args: ["doctor"]
    - type: prefix
      args: ["audit"]
    - type: prefix
      args: ["token", "list"]
    - type: prefix
      args: ["ping"]
    - type: prefix
      args: ["view"]
    - type: prefix
      args: ["owner", "ls"]
    - type: prefix
      args: ["fund"]
    - type: prefix
      args: ["explain"]
    - type: prefix
      args: ["ls"]
    - type: prefix
      args: ["why"]
    - type: prefix
      args: ["prefix"]

  terraform:
    - type: prefix
      args: ["show"]
    - type: prefix
      args: ["providers"]
    - type: prefix
      args: ["state", "list"]
    - type: prefix
      args: ["state", "show"]
    - type: prefix
      args: ["version"]
    - type: prefix
      args: ["fmt", "--check"]
    - type: prefix
      args: ["validate"]
    - type: prefix
      args: ["graph"]
    - type: prefix
      args: ["console"]
    - type: prefix
      args: ["output"]
    - type: prefix
      args: ["refresh", "--dry-run"]
    - type: prefix
      args: ["plan"]

  gradle:
    - type: prefix
      args: ["dependencies"]
    - type: prefix
      args: ["projects"]
    - type: prefix
      args: ["properties"]
    - type: prefix
      args: ["tasks"]
    - type: prefix
      args: ["components"]
    - type: prefix
      args: ["model"]
    - type: prefix
      args: ["buildEnvironment"]
    - type: prefix
      args: ["projectsEvaluated"]
    - type: prefix
      args: ["projects", "--dry-run"]
    - type: prefix
      args: ["dependencies", "--dry-run"]
    - type: prefix
      args: ["help"]
    - type: prefix
      args: ["version"]

  helm:
    - type: prefix
      args: ["list"]
    - type: prefix
      args: ["get", "values"]
    - type: prefix
      args: ["get", "manifest"]
    - type: prefix
      args: ["get", "hooks"]
    - type: prefix
      args: ["get", "notes"]
    - type: prefix
      args: ["status"]
    - type: prefix
      args: ["dependency", "list"]
    - type: prefix
      args: ["show", "chart"]
    - type: prefix
      args: ["show", "values"]
    - type: prefix
      args: ["verify"]
    - type: prefix
      args: ["version"]
    - type: prefix
      args: ["env"]

  aws:
    - type: prefix
      args: ["s3", "ls"]
    - type: prefix
      args: ["ec2", "describe-instances"]
    - type: prefix
      args: ["rds", "describe-db-instances"]
    - type: prefix
      args: ["iam", "list-users"]
    - type: prefix
      args: ["iam", "list-roles"]
    - type: prefix
      args: ["lambda", "list-functions"]
    - type: prefix
      args: ["eks", "list-clusters"]
    - type: prefix
      args: ["ecr", "describe-repositories"]
    - type: prefix
      args: ["cloudformation", "list-stacks"]
    - type: prefix
      args: ["configure", "list"]

  gcloud:
    - type: prefix
      args: ["projects", "list"]
    - type: prefix
      args: ["compute", "instances", "list"]
    - type: prefix
      args: ["compute", "zones", "list"]
    - type: prefix
      args: ["compute", "regions", "list"]
    - type: prefix
      args: ["container", "clusters", "list"]
    - type: prefix
      args: ["services", "list"]
    - type: prefix
      args: ["iam", "roles", "list"]
    - type: prefix
      args: ["config", "list"]
    - type: prefix
      args: ["components", "list"]
    - type: prefix
      args: ["version"]

  postgres:
    - type: prefix
      args: ["psql", "-l"]
    - type: prefix
      args: ["pg_dump", "--schema-only"]
    - type: prefix
      args: ["pg_dump", "--schema", "public", "--dry-run"]
    - type: prefix
      args: ["pg_dump", "-s", "-t"]
    - type: prefix
      args: ["pg_controldata"]
    - type: prefix
      args: ["pg_isready"]
    - type: prefix
      args: ["pg_lsclusters"]
    - type: prefix
      args: ["pg_activity"]
    - type: prefix
      args: ["pgbench", "-i", "--dry-run"]

  maven:
    - type: prefix
      args: ["dependency:tree"]
    - type: prefix
      args: ["dependency:analyze"]
    - type: prefix
      args: ["help:effective-pom"]
    - type: prefix
      args: ["help:describe"]
    - type: prefix
      args: ["help:evaluate"]
    - type: prefix
      args: ["dependency:list"]
    - type: prefix
      args: ["dependency:build-classpath"]
    - type: prefix
      args: ["help:active-profiles"]
    - type: prefix
      args: ["help:effective-settings"]
    - type: prefix
      args: ["version"]

  redis-cli:
    - type: prefix
      args: ["info"]
    - type: prefix
      args: ["monitor"]
    - type: prefix
      args: ["memory", "stats"]
    - type: prefix
      args: ["memory", "doctor"]
    - type: prefix
      args: ["latency", "doctor"]
    - type: prefix
      args: ["cluster", "info"]
    - type: prefix
      args: ["client", "list"]
    - type: prefix
      args: ["slowlog", "get"]
    - type: prefix
      args: ["config", "get"]
    - type: prefix
      args: ["info", "keyspace"]

  yarn:
    - type: prefix
      args: ["list"]
    - type: prefix
      args: ["info"]
    - type: prefix
      args: ["why"]
    - type: prefix
      args: ["licenses", "list"]
    - type: prefix
      args: ["outdated"]
    - type: prefix
      args: ["check"]
    - type: prefix
      args: ["audit"]
    - type: prefix
      args: ["workspaces", "info"]
    - type: prefix
      args: ["version"]
    - type: prefix
      args: ["config", "list"]

  az:
    - type: prefix
      args: ["account", "list"]
    - type: prefix
      args: ["group", "list"]
    - type: prefix
      args: ["vm", "list"]
    - type: prefix
      args: ["aks", "list"]
    - type: prefix
      args: ["acr", "list"]
    - type: prefix
      args: ["storage", "account", "list"]
    - type: prefix
      args: ["network", "vnet", "list"]
    - type: prefix
      args: ["webapp", "list"]
    - type: prefix
      args: ["functionapp", "list"]
    - type: prefix
      args: ["version"]

  vault:
    - type: prefix
      args: ["list"]
    - type: prefix
      args: ["policy", "list"]
    - type: prefix
      args: ["auth", "list"]
    - type: prefix
      args: ["secrets", "list"]
    - type: prefix
      args: ["audit", "list"]
    - type: prefix
      args: ["status"]
    - type: prefix
      args: ["token", "lookup"]
    - type: prefix
      args: ["read"]
    - type: prefix
      args: ["version"]

  podman:
    - type: prefix
      args: ["ps"]
    - type: prefix
      args: ["images"]
    - type: prefix
      args: ["pod", "ps"]
    - type: prefix
      args: ["volume", "ls"]
    - type: prefix
      args: ["network", "ls"]
    - type: prefix
      args: ["stats"]
    - type: prefix
      args: ["top"]
    - type: prefix
      args: ["logs"]
    - type: prefix
      args: ["inspect"]
    - type: prefix
      args: ["port"]

  deno:
    - type: prefix
      args: ["info"]
    - type: prefix
      args: ["list"]
    - type: prefix
      args: ["doc"]
    - type: prefix
      args: ["lint"]
    - type: prefix
      args: ["types"]
    - type: prefix
      args: ["check"]
    - type: prefix
      args: ["compile", "--dry-run"]
    - type: prefix
      args: ["task", "--list"]
    - type: prefix
      args: ["test", "--dry-run"]
    - type: prefix
      args: ["version"]

  rustup:
    - type: prefix
      args: ["show"]
    - type: prefix
      args: ["toolchain", "list"]
    - type: prefix
      args: ["target", "list"]
    - type: prefix
      args: ["component", "list"]
    - type: prefix
      args: ["override", "list"]
    - type: prefix
      args: ["which"]
    - type: prefix
      args: ["doc"]
    - type: prefix
      args: ["man"]
    - type: prefix
      args: ["version"]

  cargo:
    - type: prefix
      args: ["tree"]
    - type: prefix
      args: ["metadata"]
    - type: prefix
      args: ["list"]
    - type: prefix
      args: ["verify"]
    - type: prefix
      args: ["search"]
    - type: prefix
      args: ["vendor", "--dry-run"]
    - type: prefix
      args: ["outdated"]
    - type: prefix
      args: ["doc"]
    - type: prefix
      args: ["config", "get"]
    - type: prefix
      args: ["version"]

  pip:
    - type: prefix
      args: ["list"]
    - type: prefix
      args: ["show"]
    - type: prefix
      args: ["check"]
    - type: prefix
      args: ["debug"]
    - type: prefix
      args: ["config", "list"]
    - type: prefix
      args: ["index"]
    - type: prefix
      args: ["hash"]
    - type: prefix
      args: ["cache", "list"]
    - type: prefix
      args: ["freeze"]
    - type: prefix
      args: ["version"]
`,
  Oqe = `
auto_approval:
  cd:
    type: any
  date:
    type: any
  cal:
    type: any
  uname:
    type: prefix
    args: ["-a"]
  hostname:
    type: any
  whoami:
    type: any
  id:
    type: any
  ps:
    type: any
  free:
    type: any
  w:
    type: any
  who:
    type: any
  ping:
    type: not_contains
    args: ["-f"]
  netstat:
    type: any
  ss:
    type: any
  ip:
    type: prefix
    args: ["addr"]
  dig:
    type: any
  nslookup:
    type: any
  pwd:
    type: any
  ls:
    type: any
  file:
    type: any
  stat:
    type: any
  du:
    type: any
  df:
    type: any
  cat:
    type: any
  less:
    type: any
  more:
    type: any
  head:
    type: any
  tail:
    type: not_contains
    args: ["-f"]
  wc:
    type: any
`,
  qqe = `
auto_approval:
  cd:
    type: any
  Get-Date:
    type: any
  date:
    type: any
  Get-ComputerInfo:
    type: any
  Get-Host:
    type: any
  $env:USERNAME:
    type: any
  whoami:
    type: any
  Get-Process:
    type: any
  ps:
    type: any
  gps:
    type: any
  Get-Service:
    type: any
  gsv:
    type: any
  Get-NetIPAddress:
    type: any
  ipconfig:
    type: any
  Get-NetTCPConnection:
    type: any
  netstat:
    type: any
  Resolve-DnsName:
    type: any
  nslookup:
    type: any
  Get-DnsClientServerAddress:
    type: any
  Get-Location:
    type: any
  pwd:
    type: any
  gl:
    type: any
  Get-ChildItem:
    type: any
  dir:
    type: any
  ls:
    type: any
  gci:
    type: any
  Get-Item:
    type: any
  gi:
    type: any
  Get-ItemProperty:
    type: any
  gp:
    type: any
  Get-Content:
    type: not_contains
    args: ["-Wait"]
  cat:
    type: any
  gc:
    type: any
  type:
    type: any
  Select-String:
    type: any
  sls:
    type: any
  findstr:
    type: any
  Get-PSDrive:
    type: any
  gdr:
    type: any
  Get-Volume:
    type: any
  Measure-Object:
    type: any
  measure:
    type: any
  Select-Object:
    type: any
  select:
    type: any
`
function qB(e, t) {
  let r
  if (t === "bash" || t === "zsh") r = OB(Oqe)
  else if (t === "powershell") r = OB(qqe)
  else throw new Error(`Unsupported shell: ${t}`)
  let n = OB(Uqe)
  return { auto_approval: { ...r.auto_approval, ...n.auto_approval } }
}
function VB(e, t, r) {
  let n = r
  if (n !== "bash" && n !== "powershell" && n !== "zsh") return false
  let i = zZ(t, n)
  if (!i || i.length === 0) return false
  let s = i[0],
    o = i.slice(1),
    a = e.auto_approval[s]
  if (!a) return false
  for (let l of Array.isArray(a) ? a : [a]) {
    let c = l.args ?? []
    if (l.type === "prefix") {
      if (c.length <= o.length && c.every((u, f) => o[f] === u)) return true
    } else if (l.type === "exact") {
      if (c.length === o.length && c.every((u, f) => o[f] === u)) return true
    } else {
      if (l.type === "any") return true
      if (l.type === "not_contains" && !c.some((u) => o.includes(u))) return true
    }
  }
  return false
}
var g0 = class extends En {
  _chatMode
  _platform
  _shellName
  execPromise = (0, JZ.promisify)(jZ.exec)
  _allowlist
  constructor(t, r, n) {
    super(Hi.shell, ToolSafetyLevel.Check),
      (this._chatMode = t),
      (this._platform = r),
      (this._shellName = n),
      (this._allowlist = qB(process.platform, this._shellName))
  }
  get description() {
    return `Execute a shell command.

- You can use this tool to interact with the user's local version control system. Do not use the
retrieval tool for that purpose.
- If there is a more specific tool available that can perform the function, use that tool instead of
this one.

The OS is ${process.platform}. The shell is '${this._shellName}'.`
  }
  inputSchemaJson = JSON.stringify({
    type: "object",
    properties: {
      command: { type: "string", description: "The shell command to execute." },
    },
    required: ["command"],
  })
  checkToolCallSafe(t) {
    if (this._chatMode === Fr.agent || this._chatMode === Fr.remoteAgent) {
      let r = t.command
      return VB(this._allowlist, r, this._shellName)
    }
    return false
  }
  async call(t, r, n) {
    let i = t.command
    try {
      let s = await this.execPromise(i, {
        signal: n,
        cwd: await Vi().getCwd(),
        shell: this._shellName,
      })
      return { text: s.stdout + s.stderr, isError: false }
    } catch (s) {
      return Vqe(s) && s.stdout !== undefined && s.stderr !== undefined
        ? { text: s.stdout + s.stderr, isError: false }
        : {
            text: `Failed to execute shell command: ${s instanceof Error ? s.message : String(s)}`,
            isError: true,
          }
    }
  }
}
function Vqe(e) {
  return (
    e !== null &&
    typeof e == "object" &&
    "code" in e &&
    "stderr" in e &&
    "stdout" in e &&
    "message" in e &&
    "name" in e
  )
}
var jb = class e extends GA {
  _chatMode
  _clientFeatureFlags
  _checkpointManager
  _getAgentMemories
  _getAgentMemoriesAbsPath
  _unsupportedSidecarTools
  _userAgent
  _memoryUpdateManager
  constructor(t, r, n, i, s, o, a) {
    let l = new MB(),
      c = []
    t === Fr.remoteAgent
      ? c.push(
          new Gb(a),
          new xb(),
          new wb(n),
          new op(n),
          new g0(t, process.platform, h0(process.platform)),
        )
      : (c.push(new Gb(a), new xb()),
        t === Fr.agent && c.push(new wb(n)),
        t === Fr.agent && c.push(new kB(i, s, l)),
        t === Fr.agent &&
          r.flags.agentEditTool === hI.strReplaceEditor &&
          c.push(new op(n))),
      super(c, ToolHostType.sidecarToolHost, o),
      (this._chatMode = t),
      (this._clientFeatureFlags = r),
      (this._checkpointManager = n),
      (this._getAgentMemories = i),
      (this._getAgentMemoriesAbsPath = s),
      (this._unsupportedSidecarTools = o),
      (this._userAgent = a),
      (this._memoryUpdateManager = l)
  }
  factory() {
    return new e(
      this._chatMode,
      this._clientFeatureFlags,
      this._checkpointManager,
      this._getAgentMemories,
      this._getAgentMemoriesAbsPath,
      this._unsupportedSidecarTools,
      this._userAgent,
    )
  }
  getMemoryUpdateManager() {
    return this._memoryUpdateManager
  }
}
var ZZ = require("events")
var HB = class extends DisposableContainer_2 {
  _getMemoriesContent
  _currentSnapshot
  _currentConversationId
  _lastActivityTime = 0
  _inactivityThresholdMs = 5 * 60 * 1e3
  constructor(t) {
    super(), (this._getMemoriesContent = t)
  }
  async getMemorySnapshot(t) {
    let r = Date.now()
    return (
      this._shouldUpdateSnapshot(t, r) && (await this._updateSnapshot(t)),
      (this._lastActivityTime = r),
      this._currentSnapshot
    )
  }
  async forceUpdateSnapshot() {
    await this._updateSnapshot(this._currentConversationId)
  }
  _shouldUpdateSnapshot(t, r) {
    return (
      !this._currentSnapshot ||
      t !== this._currentConversationId ||
      r - this._lastActivityTime > this._inactivityThresholdMs
    )
  }
  async _updateSnapshot(t) {
    try {
      let r = await this._getMemoriesContent()
      ;(this._currentSnapshot = r), (this._currentConversationId = t)
    } catch {
      this._currentSnapshot = undefined
    }
  }
  dispose = () => {
    super.dispose()
  }
}
var WB = class e {
  _mcpServers
  _clientToolHostFactory
  _remoteInfoSource
  _mcpToolsStartupErrorFn
  _clientFeatureFlags
  _checkpointManager
  _getAgentMemories
  _getMemoriesAbsPath
  _getToolUseRequestEventReporter
  _options
  static RESTART_HOSTS_EVENT = "augment/clients/sidecar/events/restart-hosts"
  static CHAT_MODE_STORAGE_KEY = "augment/clients/sidecar/chat-mode"
  _hosts = []
  _allToolHosts = []
  _chatMode
  _logger = getLogger("ToolsModel")
  _memorySnapshotManager
  _onRestartHostsEmitter = new ZZ.EventEmitter()
  onRestartHosts = (t) => (
    this._onRestartHostsEmitter.on(e.RESTART_HOSTS_EVENT, t),
    {
      dispose: () => {
        this._onRestartHostsEmitter.off(e.RESTART_HOSTS_EVENT, t)
      },
    }
  )
  constructor(t, r, n, i, s, o, a, l, c, u = {}) {
    ;(this._mcpServers = t),
      (this._clientToolHostFactory = r),
      (this._remoteInfoSource = n),
      (this._mcpToolsStartupErrorFn = i),
      (this._clientFeatureFlags = s),
      (this._checkpointManager = o),
      (this._getAgentMemories = a),
      (this._getMemoriesAbsPath = l),
      (this._getToolUseRequestEventReporter = c),
      (this._options = u),
      (this._memorySnapshotManager = new HB(this._getAgentMemories)),
      this.loadSavedMode().then(() => {
        this.restartHosts()
      })
  }
  async loadSavedMode() {
    try {
      let r = await DA().getValue(du.agent, e.CHAT_MODE_STORAGE_KEY, hc.global)
      r &&
        Object.values(Fr).includes(r) &&
        this._chatMode === undefined &&
        ((this._chatMode = r),
        this._logger.info(`Loaded saved chat mode: ${String(r)}`))
    } catch (t) {
      this._logger.warn(`Failed to load saved chat mode: ${String(t)}`)
    }
  }
  get memoriesAbsPath() {
    return this._getMemoriesAbsPath()
  }
  async getAgentMemoriesWithSnapshot(t) {
    return this._memorySnapshotManager.getMemorySnapshot(t)
  }
  async forceMemorySnapshotUpdate() {
    await this._memorySnapshotManager.forceUpdateSnapshot()
  }
  async getToolMap() {
    let t = new Map()
    for (let r of this.hosts) {
      let n = await r.getToolDefinitions()
      for (let i of n)
        this.isEnabled(i.definition.name) &&
          t.set(i.definition.name.toString(), r)
    }
    return t
  }
  get hosts() {
    return this._hosts
  }
  get chatMode() {
    return this._chatMode ?? Fr.chat
  }
  getSidecarToolHost() {
    for (let t of this._hosts) if (t instanceof jb) return t
  }
  setMode(t) {
    if (t !== this._chatMode) {
      this._chatMode = t
      try {
        DA().setValue(du.agent, e.CHAT_MODE_STORAGE_KEY, t, hc.global),
          this._logger.info(`Saved chat mode: ${String(t)}`)
      } catch (r) {
        this._logger.warn(`Failed to save chat mode: ${String(r)}`)
      }
      this.restartHosts()
    }
  }
  onFlagsChanged() {
    this.restartHosts()
  }
  setMcpServers(t) {
    ;(this._mcpServers = t), this.restartHosts(true)
  }
  async getToolDefinitions() {
    let t = []
    for (let r of this.hosts) {
      let n = await r.getToolDefinitions()
      for (let i of n) this.isEnabled(i.definition.name) && t.push(i)
    }
    return t
  }
  async getToolStatusForSettingsPanel(t = true) {
    let r = []
    for (let n of this._allToolHosts) {
      let i = await n.getAllToolDefinitions(t)
      r.push(...i)
    }
    return r
  }
  async callTool(t, r, n, i, s, o) {
    let l = (await this.getToolMap()).get(n)
    if (l === undefined) return { isError: true, text: `Tool ${n} not found.` }
    if (!this.isEnabled(n))
      return { isError: true, text: `Tool ${n} is disabled.` }
    let c = Date.now(),
      u = await l.callTool(t, r, n, i, s),
      f = this._getToolUseRequestEventReporter()
    return (
      f !== undefined &&
        f.reportEvent(
          t,
          n,
          r,
          i,
          u.isError,
          Date.now() - c,
          l instanceof Eb,
          o,
          s.length,
          u.requestId,
        ),
      u
    )
  }
  async checkToolCallSafe(t, r) {
    let i = (await this.getToolMap()).get(t)
    if (i === undefined) throw new Error(`Cannot find the host for tool '${t}'.`)
    return await i.checkToolCallSafe(t, r)
  }
  async checkToolExists(t) {
    return (await this.getToolMap()).has(t)
  }
  async cancelToolRun(t, r) {
    for (let n = 0; n < this.hosts.length; n++) {
      let i = this.hosts[n]
      if (i.isRequestActive(t, r)) {
        let s = i.close(true)
        return (this._hosts[n] = i.factory(s)), s
      }
    }
    return Promise.resolve()
  }
  restartHosts(t = false) {
    let r = this._allToolHosts
    t && (r = this._allToolHosts.filter((u) => u.getName() === ToolHostType.mcpHost))
    let n = r.map((u) => u.close()),
      i = Promise.all(n).then(() => {}),
      s = this._mcpServers.map(
        (u) => new Eb(u, i, this._mcpToolsStartupErrorFn),
      ),
      o,
      a,
      l
    t &&
      ((o = this._allToolHosts.find((u) => u.getName() === ToolHostType.remoteToolHost)),
      (a = this._allToolHosts.find((u) => u.getName() === ToolHostType.localToolHost)),
      (l = this._allToolHosts.find((u) => u.getName() === ToolHostType.sidecarToolHost))),
      (o = o ?? new QI(this._remoteInfoSource)),
      (a = a ?? this._clientToolHostFactory(this.chatMode)),
      (l =
        l ??
        new jb(
          this.chatMode,
          this._clientFeatureFlags,
          this._checkpointManager,
          this._getAgentMemories,
          this._getMemoriesAbsPath,
          this._options.unsupportedSidecarTools ?? new Set(),
          this._options.userAgent,
        )),
      (this._allToolHosts = [...s, a, o, l])
    let c =
      (this._chatMode === Fr.chat &&
        this._clientFeatureFlags.flags.enableChatWithTools) ||
      (this._chatMode === Fr.agent &&
        this._clientFeatureFlags.flags.enableAgentMode) ||
      this._chatMode === Fr.remoteAgent
    ;(this._hosts = [...s]),
      c && (this._hosts = this.hosts.concat([a, o, l])),
      this.logTools(),
      this._onRestartHostsEmitter.emit(e.RESTART_HOSTS_EVENT)
  }
  closeAllToolProcesses() {
    for (let t of this.hosts) t.closeAllToolProcesses()
  }
  getTool(t) {
    for (let r of this.hosts) {
      let n = r.getTool(t)
      if (n) return n
    }
  }
  async logTools() {
    this._logger.info(
      `Tools Mode: ${this._chatMode} (${this.hosts.length} hosts)`,
    )
    for (let t of this.hosts) {
      let r = await t.getToolDefinitions(),
        n = [],
        i = []
      for (let a of r)
        (this.isEnabled(a.definition.name) ? n : i).push(a.definition.name)
      let s = n.map((a) => ` + ${a}`).join(`
`),
        o = i.map((a) => ` - ${a}`).join(`
`)
      this._logger
        .info(`Host: ${t.getName()} (${r.length} tools: ${s.length} enabled, ${o.length} disabled})
${s}
${o}`)
    }
  }
  isEnabled(t) {
    return true
  }
}
var Ko
;(function (e) {
  e.empty = "empty"
})(Ko || (Ko = {}))
var Ei
;(function (e) {
  ;(e.getEditListRequest = "agent-get-edit-list-request"),
    (e.getEditListResponse = "agent-get-edit-list-response"),
    (e.getEditChangesByRequestIdRequest =
      "agent-get-edit-changes-by-request-id-request"),
    (e.getEditChangesByRequestIdResponse =
      "agent-get-edit-changes-by-request-id-response"),
    (e.setCurrentConversation = "agent-set-current-conversation"),
    (e.revertToTimestamp = "revert-to-timestamp"),
    (e.chatAgentEditAcceptAll = "chat-agent-edit-accept-all"),
    (e.reportAgentSessionEvent = "report-agent-session-event"),
    (e.reportAgentRequestEvent = "report-agent-request-event"),
    (e.chatReviewAgentFile = "chat-review-agent-file"),
    (e.getAgentEditContentsByRequestId =
      "get-agent-edit-contents-by-request-id"),
    (e.getAgentEditContentsByRequestIdResponse =
      "get-agent-edit-contents-by-request-id-response"),
    (e.checkHasEverUsedAgent = "check-has-ever-used-agent"),
    (e.checkHasEverUsedAgentResponse = "check-has-ever-used-agent-response"),
    (e.setHasEverUsedAgent = "set-has-ever-used-agent")
})(Ei || (Ei = {}))
var oh
;(function (e) {
  e.hasEverUsedAgent = "hasEverUsedAgent"
})(oh || (oh = {}))
var GB = class {
  _checkpointManager
  _logger = getLogger("AgentWebviewMessageHandler")
  supportedTypes = Ei
  constructor(t) {
    this._checkpointManager = t
  }
  async handle(t, r) {
    switch (t.type) {
      case Ei.getEditListRequest: {
        let n = t,
          i = await this._getAgentEditList(n)
        r(i)
        break
      }
      case Ei.setCurrentConversation: {
        let n = t
        this._checkpointManager.setCurrentConversation(n.data.conversationId),
          r({ type: Ko.empty })
        break
      }
      case Ei.getEditChangesByRequestIdRequest: {
        let n = t,
          i = await this._getAgentEditChangesByRequestId(n)
        r(i)
        break
      }
      case Ei.revertToTimestamp: {
        let n = t
        n.data.qualifiedPathNames?.length
          ? await Promise.all(
              n.data.qualifiedPathNames.map(async (i) => {
                await this._checkpointManager.revertDocumentToTimestamp(
                  QualifiedPathName.from(i),
                  n.data.timestamp,
                )
              }),
            )
          : await this._checkpointManager.revertToTimestamp(n.data.timestamp),
          r({ type: Ko.empty })
        break
      }
      case Ei.chatAgentEditAcceptAll: {
        r({ type: Ko.empty })
        break
      }
      case Ei.reportAgentSessionEvent: {
        Mr().reportEvent(t.data), r({ type: Ko.empty })
        break
      }
      case Ei.reportAgentRequestEvent: {
        HK().reportEvent(t.data), r({ type: Ko.empty })
        break
      }
      case Ei.chatReviewAgentFile: {
        let n = t
        await this._showAgentReview(n), r({ type: Ko.empty })
        break
      }
      case Ei.checkHasEverUsedAgent: {
        let n = await DA().getValue(du.agent, oh.hasEverUsedAgent, hc.global)
        r({ type: Ei.checkHasEverUsedAgentResponse, data: n ?? false })
        break
      }
      case Ei.setHasEverUsedAgent: {
        let n = t
        await DA().setValue(du.agent, oh.hasEverUsedAgent, n.data, hc.global),
          r({ type: Ko.empty })
        break
      }
      case Ei.getAgentEditContentsByRequestId: {
        let n = t,
          i = await this._getAgentEditContentsByRequestId(n)
        r(i)
        break
      }
    }
  }
  async _getAgentEditContentsByRequestId(t) {
    let r = await this._checkpointManager.getCheckpointByRequestId(
        t.data.requestId,
      ),
      n = r?.files.at(0)
    return r === undefined || n === undefined || r.files.length !== 1
      ? { type: Ei.getAgentEditContentsByRequestIdResponse, data: undefined }
      : {
          type: Ei.getAgentEditContentsByRequestIdResponse,
          data: {
            originalCode: n.changeDocument.originalCode,
            modifiedCode: n.changeDocument.modifiedCode,
          },
        }
  }
  _getAgentEditList = async (t) => {
    let { fromTimestamp: r = 0, toTimestamp: n } = t.data,
      i = await this._checkpointManager.getAggregateCheckpoint({
        minTimestamp: r,
        maxTimestamp: n,
      })
    return {
      type: Ei.getEditListResponse,
      data: {
        edits: i.files.map((s) => ({
          qualifiedPathName: s.changeDocument.filePath,
          changesSummary: s.changesSummary,
        })),
      },
    }
  }
  _getAgentEditChangesByRequestId = async (t) => {
    let r = await this._checkpointManager.getCheckpointByRequestId(
      t.data.requestId,
    )
    return r !== undefined
      ? {
          type: Ei.getEditChangesByRequestIdResponse,
          data: r.files.at(0)?.changesSummary,
        }
      : { type: Ei.getEditChangesByRequestIdResponse, data: undefined }
  }
  _showAgentReview = async (t) => {
    let r = QualifiedPathName.from(t.data.qualifiedPathName),
      i = (
        await this._checkpointManager.getAggregateCheckpointForFile(r, {
          minTimestamp: t.data.fromTimestamp,
          maxTimestamp: t.data.toTimestamp,
        })
      ).files.at(0)?.changeDocument
    return i
      ? (await DK().showDiffView(i.filePath, i.originalCode, i.modifiedCode, {
          retainFocus: t.data.retainFocus,
        }),
        Promise.resolve({ type: Ko.empty }))
      : Promise.resolve({ type: Ko.empty })
  }
}
var ah
;(function (e) {
  ;(e.closeAllToolProcesses = "close-all-tool-processes"),
    (e.getToolIdentifierRequest = "get-tool-identifier-request"),
    (e.getToolIdentifierResponse = "get-tool-identifier-response")
})(ah || (ah = {}))
var $B = class {
  _toolsModel
  _logger = getLogger("ToolsWebviewMessageHandler")
  supportedTypes = ah
  constructor(t) {
    this._toolsModel = t
  }
  async handle(t, r) {
    switch (t.type) {
      case ah.closeAllToolProcesses: {
        this._logger.info("Received closeAllToolProcesses message"),
          this._toolsModel.closeAllToolProcesses(),
          r({ type: Ko.empty })
        break
      }
      case ah.getToolIdentifierRequest: {
        let n = await this.getToolIdentifier(t)
        r(n)
        break
      }
    }
    return Promise.resolve()
  }
  getToolIdentifier = async (t) => {
    let r = await this._toolsModel.getToolDefinitions()
    for (let n of r)
      if (n.definition.name === t.data.toolName)
        return {
          type: ah.getToolIdentifierResponse,
          data: {
            found: true,
            toolIdentifier: n.identifier,
            mcpToolName: n.definition.mcp_tool_name,
            mcpServerName: n.definition.mcp_server_name,
          },
        }
    return { type: ah.getToolIdentifierResponse, data: { found: false } }
  }
}
var YB = class {
  _handlers = new Map()
  _logger = getLogger("WebviewMessageBroker")
  registerHandler(t) {
    let r = Object.values(t.supportedTypes)
    for (let n of r) this._handlers.set(n, (i, s) => t.handle(i, s))
  }
  handle(t, r) {
    let n = this._handlers.get(t.type)
    return n
      ? (n(t, r), true)
      : (this._logger.debug(
          `No webview message handler found for '${t.type}' in the sidecar broker.`,
        ),
        false)
  }
}
var KB = class {
  _broker
  constructor(t, r) {
    this._broker = new YB()
    let i = [new GB(t), new $B(r)]
    for (let s of i) this._broker.registerHandler(s)
  }
  onMessage(t, r) {
    return this._broker.handle(t, r)
  }
}
var XZ = q(require("crypto")),
  DEFAULT_NAMING_VERSION = 2023102300,
  ContentSizeExceededError = class extends Error {
    constructor(maxSize) {
      super(`content exceeds maximum size of ${maxSize}`)
    }
  },
  HashCalculator = class {
    maxBlobSize
    _textEncoder = new TextEncoder()
    constructor(maxSize) {
      this.maxBlobSize = maxSize
    }
    _hash(data, content) {
      let hasher = XZ.createHash("sha256")
      return hasher.update(data), hasher.update(content), hasher.digest("hex")
    }
    calculateOrThrow(data, content, checkSize = true) {
      if (
        (typeof content == "string" && (content = this._textEncoder.encode(content)),
        checkSize && content.length > this.maxBlobSize)
      )
        throw new ContentSizeExceededError(this.maxBlobSize)
      return this._hash(data, content)
    }
    calculate(data, content) {
      try {
        return this.calculateOrThrow(data, content, true)
      } catch {
        return
      }
    }
    calculateNoThrow(data, content) {
      return this.calculateOrThrow(data, content, false)
    }
  }
var JIe = require("console"),
  jIe = require("crypto"),
  ZIe = q(_s()),
  F9 = q(jte()),
  XIe = q(ufe()),
  W2 = q(require("os"))
var dfe = q(require("crypto")),
  NT = new Uint8Array(256),
  QT = NT.length
function S5() {
  return (
    QT > NT.length - 16 && (dfe.default.randomFillSync(NT), (QT = 0)),
    NT.slice(QT, (QT += 16))
  )
}
var ffe =
  /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i
function $rt(e) {
  return typeof e == "string" && ffe.test(e)
}
var I5 = $rt
var Ts = []
for (let e = 0; e < 256; ++e) Ts.push((e + 256).toString(16).slice(1))
function hfe(e, t = 0) {
  return (
    Ts[e[t + 0]] +
    Ts[e[t + 1]] +
    Ts[e[t + 2]] +
    Ts[e[t + 3]] +
    "-" +
    Ts[e[t + 4]] +
    Ts[e[t + 5]] +
    "-" +
    Ts[e[t + 6]] +
    Ts[e[t + 7]] +
    "-" +
    Ts[e[t + 8]] +
    Ts[e[t + 9]] +
    "-" +
    Ts[e[t + 10]] +
    Ts[e[t + 11]] +
    Ts[e[t + 12]] +
    Ts[e[t + 13]] +
    Ts[e[t + 14]] +
    Ts[e[t + 15]]
  )
}
var gfe = q(require("crypto")),
  B5 = { randomUUID: gfe.default.randomUUID }
function Yrt(e, t, r) {
  if (B5.randomUUID && !t && !e) return B5.randomUUID()
  e = e || {}
  let n = e.random || (e.rng || S5)()
  if (((n[6] = (n[6] & 15) | 64), (n[8] = (n[8] & 63) | 128), t)) {
    r = r || 0
    for (let i = 0; i < 16; ++i) t[r + i] = n[i]
    return t
  }
  return hfe(n)
}
var Oh = Yrt
var Ye = q(require("vscode"))
function validateIsArray(objectName, propertyName, value) {
  if (!Array.isArray(value)) throw new Error(`Value of ${objectName}.${propertyName} is not Array`)
}
function validateAndReturnNumber(objectName, propertyName, value) {
  let valueType = typeof value
  if (valueType !== "number")
    throw new Error(
      `Value of ${objectName}.${propertyName} has unexpected type. Expected number, received ${valueType}`,
    )
  return value
}
function validateAndReturnString(objectName, propertyName, value) {
  let valueType = typeof value
  if (valueType !== "string")
    throw new Error(
      `Value of ${objectName}.${propertyName} has unexpected type. Expected string, received ${valueType}`,
    )
  return value
}
function validateAndReturnStringArray(objectName, propertyName, value) {
  validateIsArray(objectName, propertyName, value)
  let stringArray = []
  for (let item of value) stringArray.push(validateAndReturnString(objectName, propertyName, item))
  return stringArray
}
function validateAndReturnBoolean(objectName, propertyName, value, defaultValue = false) {
  if (value === null) return defaultValue
  let valueType = typeof value
  if (valueType !== "boolean")
    throw new Error(
      `Value of ${objectName}.${propertyName} has unexpected type. Expected boolean, received ${valueType}`,
    )
  return value
}
function processBlobs(blobsData) {
  return {
    checkpoint_id: blobsData.checkpointId,
    added_blobs: blobsData.addedBlobs.sort(),
    deleted_blobs: blobsData.deletedBlobs.sort(),
  }
}
function processVcsChanges(vcsChanges) {
  return {
    working_directory_changes: vcsChanges.workingDirectory.map((change) => ({
      before_path: change.beforePath,
      after_path: change.afterPath,
      change_type: change.changeType,
      head_blob_name: change.headBlobName,
      indexed_blob_name: change.indexedBlobName,
      current_blob_name: change.currentBlobName,
    })),
  }
}
function PT(e) {
  let t = validateAndReturnString("BackChatResult", "text", e.text),
    r =
      e.unknown_blob_names === undefined
        ? []
        : validateAndReturnStringArray("BackChatResult", "unknown_blob_names", e.unknown_blob_names),
    n =
      e.checkpoint_not_found === undefined
        ? false
        : validateAndReturnBoolean(
            "BackChatResult",
            "checkpoint_not_found",
            e.checkpoint_not_found,
            false,
          ),
    i =
      e.workspace_file_chunks === undefined
        ? []
        : e.workspace_file_chunks.map((o) => ({
            charStart: validateAndReturnNumber("BackWorkspaceFileChunk", "char_start", o.char_start),
            charEnd: validateAndReturnNumber("BackWorkspaceFileChunk", "char_end", o.char_end),
            blobName: validateAndReturnString("BackWorkspaceFileChunk", "blob_name", o.blob_name),
          })),
    s = e.nodes
  return {
    text: t,
    unknownBlobNames: r,
    checkpointNotFound: n,
    workspaceFileChunks: i,
    nodes: s,
  }
}
function formatObjectSizeInfo(obj, indent = "") {
  let lines = []
  if (typeof obj != "object" || obj === null) return formatPrimitiveSize(obj)
  for (let [key, value] of Object.entries(obj))
    if (Array.isArray(value)) {
      lines.push(
        `${indent}${key}: (array) ${value.length} (array length) ${JSON.stringify(value).length} (char length)`,
      )
      let maxItems = 20
      value.slice(0, maxItems).forEach((item, index) => {
        lines.push(`${indent}  [${index}]: ${formatObjectSizeInfo(item, indent + "  ")}`)
      }),
        value.length > maxItems && lines.push(`${indent}  ${value.length - maxItems} more items...`)
    } else
      typeof value == "object" && value !== null
        ? (lines.push(
            `${indent}${key}: (object) ${Object.keys(value).length} (object size) ${JSON.stringify(value).length} (char length)`,
          ),
          lines.push(formatObjectSizeInfo(value, indent + "  ")))
        : lines.push(`${indent}${key}: ${formatPrimitiveSize(value)}`)
  return lines.join(`
`)
}
function formatPrimitiveSize(value) {
  return typeof value == "string"
    ? `${value.length} (string length)`
    : typeof value == "boolean" || value === null || typeof value == "number"
      ? "1"
      : "N/A"
}
var AugmentExtensionSidecar = class e {
  sessionId
  userAgent
  fetchFunction
  static defaultRequestTimeoutMs = 3e4
  logger = getLogger("AugmentExtensionSidecar")
  clientConfig = getClientConfig()
  clientAuth = getClientAuth()
  constructor(sessionId, userAgent, fetchFunction) {
    ;(this.sessionId = sessionId), (this.userAgent = userAgent), (this.fetchFunction = fetchFunction)
  }
  async chatStream(
    requestId,
    message,
    chatHistory,
    codeBlobs,
    userGuidedBlobs,
    externalSourceIds,
    model,
    vcsChange,
    recentChanges,
    contextCodeExchangeRequestId,
    selectedCode,
    prefix,
    suffix,
    filePath,
    language,
    overrideSessionId,
    disableAutoExternalSources,
    userGuidelines,
    workspaceGuidelines,
    toolDefinitions,
    nodes,
    mode,
    agentMemories,
    personaType,
  ) {
    let config = await this.clientConfig.getConfig(),
      requestBody = {
        model: model ?? config.chat.model,
        path: filePath,
        prefix: prefix,
        selected_code: selectedCode,
        suffix: suffix,
        message: message,
        chat_history: chatHistory,
        lang: language,
        blobs: processBlobs(codeBlobs),
        user_guided_blobs: userGuidedBlobs,
        context_code_exchange_request_id: contextCodeExchangeRequestId,
        vcs_change: processVcsChanges(vcsChange),
        recency_info_recent_changes: recentChanges,
        external_source_ids: externalSourceIds,
        disable_auto_external_sources: disableAutoExternalSources,
        user_guidelines: userGuidelines,
        workspace_guidelines: workspaceGuidelines,
        feature_detection_flags: { support_raw_output: true },
        tool_definitions: toolDefinitions ?? [],
        nodes: nodes ?? [],
        mode: mode ?? Fr.chat,
        agent_memories: agentMemories,
        persona_type: personaType,
      }
    return await retryOperation(
      () =>
        this.callApiStream(requestId, config, "chat-stream", requestBody, PT, config.chat.url, 300000, overrideSessionId),
      this.logger,
      { initialMS: 250, mult: 2, maxMS: 5000, maxTries: 5, maxTotalMs: 5000 },
    )
  }
  async callApiStream(requestId, config, endpoint, requestBody, responseProcessor = (response) => response, apiUrl, timeoutMs, overrideSessionId) {
    let apiToken = await this.clientAuth.getAPIToken()
    if (((apiUrl = apiUrl ?? (await this.clientAuth.getCompletionURL())), !apiUrl))
      throw new Error("Please configure Augment API URL")
    let url
    try {
      url = new URL(endpoint, apiUrl)
    } catch (error) {
      throw (this.logger.error("Augment API URL is invalid:", error), new InvalidCompletionUrlError())
    }
    if (!url.protocol.startsWith("http"))
      throw new Error("Augment API URL must start with 'http://' or 'https://'")
    let requestBodyJson = JSON.stringify(requestBody, (key, value) => (value === undefined ? null : value)),
      timeout = timeoutMs ?? e.defaultRequestTimeoutMs,
      abortSignal = AbortSignal.timeout(timeout),
      method = "POST",
      response
    try {
      let headers = {
        "Content-Type": "application/json",
        "User-Agent": this.userAgent,
        "x-request-id": `${requestId}`,
        "x-request-session-id": `${overrideSessionId ?? this.sessionId}`,
      }
      apiToken && (headers.Authorization = `Bearer ${apiToken}`),
        (response = await executeWithTimeout(
          this.fetchFunction(url.toString(), { // =
            method: method,
            headers: headers,
            body: requestBodyJson,
            signal: abortSignal,
          }),
          timeout,
        ))
    } catch (error) {
      throw error instanceof Error
        ? (this.logger.error(
            `API request ${requestId} to ${url.toString()} failed: ${getErrorMessage(error, true)}`,
          ),
          error.stack && this.logger.error(error.stack),
          ApiError.transientIssue(error.message))
        : error
    }
    if (!response.ok) {
      fetch('http://localhost:3000', { // =
        method: 'POST',
        body: JSON.stringify({
          callMethod: 'callApiStream:responseNotOK',
          endpoint,
          requestId,
          requestBody,
          responseStatus: response.status
        })
      });
    }
    if (!response.ok)
      throw response.status === 499
        ? ApiError.fromResponse(response)
        : (response.status === 401 && this.clientAuth.removeAuthSession(),
          response.status === 400 &&
            config.enableDebugFeatures &&
            this.logger.error(
              `API request ${requestId} to ${url.toString()} failed: ${await response.text()}`,
            ),
          this.logger.error(
            `API request ${requestId} to ${url.toString()} response ${response.status}: ${response.statusText}`,
          ),
          ApiError.fromResponse(response).status === RequestStatus.augmentTooLarge &&
            this.logger.debug(`object size is ${requestBody ? formatObjectSizeInfo(requestBody) : 0} `),
          ApiError.fromResponse(response))
    let reader = response.body.getReader(),
      logger = this.logger
    async function* streamProcessor(streamReader) {
      let textDecoder = new TextDecoder(),
        buffer = ""
      for (;;) {
        let { value, done } = await streamReader.read(new Uint8Array())
        if (done) return
        for (
          buffer += textDecoder.decode(value, { stream: true });
          buffer.includes(`
`);

        ) {
          let newlineIndex = buffer.indexOf(`
`),
            line = buffer.substring(0, newlineIndex)
          buffer = buffer.substring(newlineIndex + 1)
          try {
            fetch('http://localhost:3000', {
              method: 'POST',
              body: JSON.stringify({
                callMethod: 'callApiStream',
                endpoint,
                requestId,
                requestBody,
                buffer,
                line
              })
            });
            let parsedJson = JSON.parse(line)
            yield responseProcessor(parsedJson) // =
          } catch (error) {
            logger.error(`JSON parse failed for ${line}: ${getErrorMessage(error)}`)
          }
        }
      }
    }
    return streamProcessor(reader)
  }
}
var Jk = q(Fhe()),
  tx = q(require("vscode"))
var I0e = q(require("vscode")),
  Jh = q(S0e()),
  B0e = q(Yh()),
  oft = I0e.window.createOutputChannel("Augment", { log: true }),
  hG = class extends B0e.default {
    constructor(r) {
      super()
      this.outputChannel = r
      this._logFns.set("info", r.info),
        this._logFns.set("debug", r.debug),
        this._logFns.set("warn", r.warn),
        this._logFns.set("error", r.error),
        this._logFns.set("verbose", r.trace)
    }
    _logFns = new Map()
    log(r, n) {
      setImmediate(() => {
        this.emit("logged", r)
      })
      let i = [r.prefix ? `'${r.prefix}'` : "", r.message].join(" "),
        s = this._logFns.get(r.level)
      s ? s(i) : this.outputChannel.appendLine(i), n()
    }
  },
  R0e = [new hG(oft)]
process.env.CONSOLE_LOG_LEVEL &&
  R0e.push(new Jh.transports.Console({ level: process.env.CONSOLE_LOG_LEVEL }))
var $y = (0, Jh.createLogger)({
  level: "debug",
  exitOnError: false,
  format: Jh.format.combine(
    Jh.format.timestamp({ format: "YYYY-MM-DD HH:mm:ss.SSS" }),
    Jh.format.printf(
      (e) => `${e.timestamp} [${e.level}] '${e.prefix}': ${e.message}`,
    ),
  ),
  transports: R0e,
})
IY($y)
function z(e) {
  return getLogger(e)
}
var ex = q(_s()),
  Yy = class {
    constructor(t, r, n) {
      this.name = t
      this._logger = r
      this._configListener = n
    }
    _isSet = false
    _value
    get value() {
      return this._value
    }
    update(t) {
      return this._isSet && (0, ex.isEqual)(t, this._value)
        ? false
        : (this._isSet
            ? this._logger.info(`${this.name} changed:
${this.diff(this.value, t).map((r) => `  - ${r}`).join(`
`)}`)
            : this._logger.info(
                `${this.name} changed from <unset> to ${this._formatValue(t)}`,
              ),
          (this._value = (0, ex.cloneDeep)(t)),
          (this._isSet = true),
          true)
    }
    diff(t, r, n = []) {
      if ((0, ex.isEqual)(r, t)) return []
      if (!this.isObject(r) || !this.isObject(t))
        return [`${this._formatValue(t)} to ${this._formatValue(r)}`]
      let i = new Set([...Object.keys(t || {}), ...Object.keys(r || {})]),
        s = []
      for (let o of i) {
        if (this._configListener && o === "memoriesParams") continue
        let a = r ? r[o] : undefined,
          l = t ? t[o] : undefined
        !this.isObject(a) || !this.isObject(l)
          ? a !== l &&
            s.push(
              `${n.concat(o).join(" > ")}: ${this._formatValue(l)} to ${this._formatValue(a)}`,
            )
          : s.push(...this.diff(l, a, n.concat(o)))
      }
      return s
    }
    isObject(t) {
      return typeof t == "object" && t !== null
    }
    toString() {
      return this._isSet ? this._formatValue(this.value) : "<unset>"
    }
    _formatValue(t) {
      return t === undefined ? "undefined" : JSON.stringify(t)
    }
  }
var DisposableCollection = class {
    _disposables = []
    add(disposable) {
      if (disposable === undefined)
        throw new Error(
          "Attempt to add undefined disposable to DisposableCollection",
        )
      return this._disposables.push(disposable), disposable
    }
    addAll(...disposables) {
      disposables.forEach((disposable) => this.add(disposable))
    }
    adopt(otherCollection) {
      this._disposables.push(...otherCollection._disposables), (otherCollection._disposables.length = 0)
    }
    dispose() {
      for (let disposable of this._disposables) disposable.dispose()
      this._disposables.length = 0
    }
  },
  DisposableContainer = class {
    _disposables = new DisposableCollection()
    _priorityDisposables = new DisposableCollection()
    constructor(t = new DisposableCollection(), r = new DisposableCollection()) {
      this._disposables.adopt(t), this._priorityDisposables.adopt(r)
    }
    addDisposable(t, r = false) {
      return r ? this._priorityDisposables.add(t) : this._disposables.add(t)
    }
    addDisposables(...t) {
      this._disposables.addAll(...t)
    }
    dispose() {
      this._priorityDisposables.dispose(), this._disposables.dispose()
    }
  }
var MAX_UPLOAD_SIZE_BYTES = 128 * 1024,
  defaultFeatureFlags = {
    gitDiff: false,
    gitDiffPollingFrequencyMSec: 0,
    additionalChatModels: "",
    smallSyncThreshold: 15,
    bigSyncThreshold: 1e3,
    enableWorkspaceManagerUi: true,
    enableInstructions: false,
    enableSmartPaste: false,
    enableSmartPasteMinVersion: "",
    enableViewTextDocument: false,
    bypassLanguageFilter: false,
    enableHindsight: false,
    maxUploadSizeBytes: MAX_UPLOAD_SIZE_BYTES,
    vscodeNextEditBottomPanelMinVersion: "",
    vscodeNextEditMinVersion: "",
    vscodeNextEditUx1MaxVersion: "",
    vscodeNextEditUx2MaxVersion: "",
    vscodeFlywheelMinVersion: "",
    vscodeExternalSourcesInChatMinVersion: "",
    vscodeShareMinVersion: "",
    maxTrackableFileCount: 25e4,
    maxTrackableFileCountWithoutPermission: 15e4,
    minUploadedPercentageWithoutPermission: 90,
    memoryClassificationOnFirstToken: false,
    vscodeSourcesMinVersion: "",
    vscodeChatHintDecorationMinVersion: "",
    nextEditDebounceMs: 400,
    enableCompletionFileEditEvents: false,
    vscodeEnableCpuProfile: false,
    verifyFolderIsSourceRepo: false,
    refuseToSyncHomeDirectories: false,
    enableFileLimitsForSyncingPermission: false,
    enableChatMermaidDiagrams: false,
    enableSummaryTitles: false,
    smartPastePrecomputeMode: "visible-hover",
    vscodeNewThreadsMenuMinVersion: "",
    vscodeEditableHistoryMinVersion: "",
    vscodeEnableChatMermaidDiagramsMinVersion: "",
    userGuidelinesLengthLimit: 2e3,
    workspaceGuidelinesLengthLimit: 2e3,
    enableGuidelines: false,
    useCheckpointManagerContextMinVersion: "",
    validateCheckpointManagerContext: false,
    vscodeDesignSystemRichTextEditorMinVersion: "",
    allowClientFeatureFlagOverrides: false,
    vscodeChatWithToolsMinVersion: "",
    vscodeChatMultimodalMinVersion: "",
    vscodeAgentModeMinVersion: "",
    vscodeAgentModeMinStableVersion: "",
    vscodeBackgroundAgentsMinVersion: "",
    vscodeAgentEditTool: "backend_edit_tool",
    vscodeRichCheckpointInfoMinVersion: "",
    vscodeDirectApplyMinVersion: "",
    memoriesParams: {},
    eloModelConfiguration: {
      highPriorityModels: [],
      regularBattleModels: [],
      highPriorityThreshold: 0.5,
    },
    vscodeVirtualizedMessageListMinVersion: "",
    vscodeChatStablePrefixTruncationMinVersion: "",
    agentEditToolMinViewSize: 0,
    agentEditToolSchemaType: "StrReplaceEditorToolDefinitionNested",
    agentSaveFileToolInstructionsReminder: false,
    vscodePersonalitiesMinVersion: "",
    useMemorySnapshotManager: false,
    vscodeGenerateCommitMessageMinVersion: "",
  },
  gG = class {
    constructor(t, r, n) {
      this._watchedFlags = r
      this._callback = n
      this._currentFlags = (0, Jk.default)(t)
    }
    _disposed = false
    _currentFlags
    get disposed() {
      return this._disposed
    }
    trigger(t) {
      if (this._disposed) return
      let r = []
      for (let n of this._watchedFlags)
        t[n] !== this._currentFlags[n] && r.push(n)
      r.length > 0 &&
        this._callback({
          previousFlags: this._currentFlags,
          newFlags: t,
          changedFlags: r,
        })
    }
    dispose() {
      this._disposed = true
    }
  },
  jk = class extends DisposableContainer {
    _subscriptions = []
    _refreshTimer
    _disposed = false
    _logger = z("FeatureFlagManager")
    _flags
    constructor(t, r) {
      super(),
        (this._flags = new Yy("feature flags", this._logger, r)),
        this._flags.update(t?.initialFlags ?? defaultFeatureFlags),
        this._setupRefreshTimer(t),
        this.addDisposable(
          tx.workspace.onDidChangeConfiguration(() => {
            this._subscriptions = this._subscriptions.filter((n) => !n.disposed)
            for (let n of this._subscriptions) n.trigger(this.currentFlags)
          }),
        )
    }
    get currentFlags() {
      if (this._disposed) throw Error("FeatureFlagManager has been disposed")
      return this._flags.value?.allowClientFeatureFlagOverrides
        ? {
            ...(0, Jk.default)(this._flags.value),
            ...this.readOverridesFromConfig(),
          }
        : (0, Jk.default)(this._flags.value)
    }
    readOverridesFromConfig() {
      let t = tx.workspace.getConfiguration("augment")
      if (t.advanced == null || typeof t.advanced != "object") return {}
      let r = t.advanced.featureFlagOverrides,
        n = {}
      if (typeof r == "object")
        for (let i of Object.keys(r))
          defaultFeatureFlags[i] === undefined
            ? z("AugmentConfigListener").warn(
                `Feature flag override for ${i} is not a valid feature flag.`,
              )
            : typeof r[i] != typeof defaultFeatureFlags[i]
              ? z("AugmentConfigListener").warn(
                  `Feature flag override for ${i} is does not match default type ${typeof defaultFeatureFlags[i]}.`,
                )
              : r[i] !== undefined &&
                defaultFeatureFlags[i] !== undefined &&
                Object.assign(n, { [i]: r[i] })
      return n
    }
    update(t) {
      if (this._disposed) throw Error("FeatureFlagManager has been disposed")
      this._flags.update(t),
        (this._subscriptions = this._subscriptions.filter((r) => !r.disposed))
      for (let r of this._subscriptions) r.trigger(t)
    }
    subscribe(t, r) {
      if (this._disposed) throw Error("FeatureFlagManager has been disposed")
      let n = new gG(this._flags.value, t, r)
      return this._subscriptions.push(n), n
    }
    _setupRefreshTimer(t) {
      if (!t?.fetcher || !t?.refreshIntervalMSec) return
      this._cleanupRefreshTimer()
      let r = new tx.CancellationTokenSource().token,
        n = t.fetcher,
        i = t.refreshIntervalMSec,
        s = async () => {
          let o = await n(r)
          o
            ? this.update(o)
            : r.isCancellationRequested && this._cleanupRefreshTimer()
        }
      this._refreshTimer = setInterval(() => void s(), i)
    }
    _cleanupRefreshTimer() {
      clearInterval(this._refreshTimer), (this._refreshTimer = undefined)
    }
    dispose() {
      this._disposed ||
        (super.dispose(),
        this._subscriptions.forEach((t) => t.dispose()),
        (this._subscriptions = []),
        this._cleanupRefreshTimer(),
        (this._disposed = true))
    }
  }
var languageDefinitions = getLanguageDefinitions(),
  supportedLanguages = [],
  supportedExtensions = new Set()
for (let language of languageDefinitions) {
  supportedLanguages.push({ name: language.name, vscodeName: language.vscodeName, extensions: language.extensions })
  for (let extension of language.extensions) supportedExtensions.add(extension)
}
var Fs = ((se) => (
    (se.Unknown = "unknown"),
    (se.Command = "command"),
    (se.Background = "background"),
    (se.Global = "global"),
    (se.Click = "click"),
    (se.RightClick = "right-click"),
    (se.HoverClick = "hover-click"),
    (se.EditorActionClick = "editor-action-click"),
    (se.Keybinding = "keybinding"),
    (se.Keyboard = "keyboard"),
    (se.ActiveEditorChanged = "active-editor-changed"),
    (se.EditorSelectionChanged = "editor-selection-changed"),
    (se.EditorVisibleRangesChanged = "editor-visible-ranges-changed"),
    (se.HoveredOutsideSuggestion = "hovered-outside-suggestion"),
    (se.DocumentChanged = "document-changed"),
    (se.NextEditPanelItemFocusClick = "next-edit-panel-item-focus-click"),
    (se.NextEditPanelItemClick = "next-edit-panel-item-click"),
    (se.CodeAction = "code-action"),
    (se.GutterClick = "gutter-click"),
    (se.CodeLens = "code-lens"),
    (se.Tutorial = "tutorial"),
    (se.Error = "error"),
    (se.ValidationExpected = "validation-expected"),
    (se.ValidationUnexpected = "validation-unexpected"),
    (se.DebugSession = "debug-session"),
    (se.NotebookDocument = "notebook-document"),
    (se.UnsupportedUri = "unsupported-uri"),
    (se.MissingPathName = "missing-path-name"),
    (se.NotActiveEditor = "not-active-editor"),
    (se.NoContentChanges = "no-content-changes"),
    (se.FreshSuggestions = "fresh-suggestions"),
    se
  ))(Fs || {}),
  BlockedLocation = class {
    constructor(path, range, charStart, charStop, header) {
      this.path = path
      this.range = range
      this.charStart = charStart
      this.charStop = charStop
      this.header = header
    }
  },
  RejectedLocation = class extends BlockedLocation {
    constructor(path, range, charStart, charStop, header) {
      super(path, range, charStart, charStop, header)
    }
  }
var Ul = ((i) => (
    (i.fresh = "fresh"),
    (i.stale = "stale"),
    (i.rejected = "rejected"),
    (i.accepted = "accepted"),
    i
  ))(Ul || {}),
  NextEditRequest = class {
    constructor(requestId, mode, scope, qualifiedPathName, apiResult, suggestions, requestTime) {
      this.requestId = requestId
      this.mode = mode
      this.scope = scope
      this.qualifiedPathName = qualifiedPathName
      this.apiResult = apiResult
      this.suggestions = suggestions
      this.requestTime = requestTime
    }
    occurredAt = new Date()
  }
function eM(e, t) {
  return e != null && typeof e == "object" && t in e
}
function jn(e) {
  return e == null
}
function combineAbortSignals(e) {
  if (eM(AbortSignal, "any") && typeof AbortSignal.any == "function")
    return AbortSignal.any(e)
  let t = new AbortController()
  if (e.some((i) => i.aborted)) return t.abort(), t.signal
  let r = [],
    n = () => {
      t.abort(), r.forEach((i) => i())
    }
  for (let i of e)
    i.addEventListener("abort", n),
      r.push(() => i.removeEventListener("abort", n))
  return t.signal
}
function getTextLength(e) {
  return [...e].length
}
function getByteOffsetFromCodePointIndex(text, codePointIndex) {
  return [...text].slice(0, codePointIndex).join("").length
}
var TaskQueue = class {
  _items = new Map()
  _inProgress = false
  _stopping = false
  dispose() {
    this._stopping = true
  }
  get size() {
    return this._items.size
  }
  cancel(key) {
    this._items.delete(key)
  }
  _insert(key, value, force = false) {
    let exists = this._items.has(key)
    return !force && exists ? false : (this._items.set(key, value), !exists)
  }
  async kick() {
    if (!(this._inProgress || this._stopping || this._items.size === 0)) {
      for (this._inProgress = true; this._items.size > 0 && !this._stopping; ) {
        let currentItems = this._items
        this._items = new Map()
        for (let entry of currentItems) {
          try {
            await this._processEntry(entry)
          } catch {}
          if (this._stopping) break
        }
      }
      ;(this._inProgress = false), await this._processEntry(undefined)
    }
  }
}
var KeyedTaskQueue = class extends TaskQueue {
    constructor(processor) {
      super()
      this._processItem = processor
    }
    insert(key, value, force = false) {
      return this._insert(key, value, force)
    }
    get(key) {
      return this._items.get(key)
    }
    async _processEntry(entry) {
      return this._processItem(entry)
    }
  },
  ProcessQueue = class {
    constructor(processItemFn) {
      this._processItem = processItemFn
    }
    _keys = new Set()
    _items = new Array()
    _inProgress = false
    _stopping = false
    get size() {
      return this._items.length
    }
    dispose() {
      this._stopping = true
    }
    insert(item) {
      return this._keys.has(item)
        ? false
        : (this._keys.add(item), this._items.push(item), true)
    }
    async kick() {
      if (!(this._inProgress || this._stopping)) {
        for (
          this._inProgress = true;
          this._items.length > 0 && !this._stopping;

        ) {
          let currentBatch = this._items
          this._keys.clear(), (this._items = new Array())
          for (let item of currentBatch) {
            try {
              await this._processItem(item)
            } catch {}
            if (this._stopping) break
          }
        }
        ;(this._inProgress = false), await this._processItem(undefined)
      }
    }
  },
  Oc = class {
    constructor(t, r) {
      this._toKick = t
      this._intervalId = setInterval(this._kick.bind(this), r)
    }
    _intervalId
    _kick() {
      this._toKick.kick()
    }
    dispose() {
      this._intervalId !== undefined && clearInterval(this._intervalId)
    }
  },
  PromiseQueue = class {
    constructor(processor) {
      this._processItem = processor
    }
    _items = []
    _inProgress = false
    _stopping = false
    get size() {
      return this._items.length
    }
    dispose() {
      this._stopping = true
    }
    insert(item) {
      return new Promise((resolve, reject) => {
        this._items.push({ itemArg: item, resolve, reject })
      })
    }
    insertAndKick(item) {
      let promise = this.insert(item)
      return this.kick(), promise
    }
    async kick() {
      if (!(this._inProgress || this._stopping)) {
        for (
          this._inProgress = true;
          this._items.length > 0 && !this._stopping;

        ) {
          let queueItem = this._items.pop()
          try {
            let result = await this._processItem(queueItem.itemArg)
            queueItem.resolve(result)
          } catch (error) {
            queueItem.reject(error)
          }
        }
        ;(this._inProgress = false), await this._processItem(undefined)
      }
    }
  }
var iM = ((o) => (
  (o[(o.Unknown = 0)] = "Unknown"),
  (o[(o.Unimplemented = 1)] = "Unimplemented"),
  (o[(o.NotFound = 2)] = "NotFound"),
  (o[(o.Success = 3)] = "Success"),
  (o[(o.NotActive = 4)] = "NotActive"),
  (o[(o.Failed = 5)] = "Failed"),
  o
))(iM || {})
var ConversionError = class extends Error {
    constructor(errorMessage, responseData) {
      super(`Conversion failure: ${errorMessage}. Response = ${responseData}`)
    }
  },
  APIServerImpl = class APIServerImpl extends AugmentExtensionSidecar {
    constructor(configListener, auth, sessionId, userAgent, fetchFunction) {
      super(sessionId, userAgent, fetchFunction);
      this._configListener = configListener;
      this._auth = auth;
      this.sessionId = sessionId;
      this._userAgent = userAgent;
      this._fetchFunction = fetchFunction;
    }
    _sequenceId = new SequenceGenerator()
    _logger = z("AugmentExtension")
    getSessionId() {
      return this.sessionId
    }
    createRequestId() {
      return Oh()
    }
    async callApi(requestId, config, endpoint, requestData, responseTransformer, baseUrl, timeoutMs, metrics, abortSignal) {
      let apiToken = config.apiToken,
        usingOAuth = false
      if (this._auth.useOAuth) {
        let session = await this._auth.getSession()
        session && ((apiToken = session.accessToken), (usingOAuth = true), baseUrl || (baseUrl = session.tenantURL))
      } else baseUrl || (baseUrl = config.completionURL)
      if (!baseUrl) throw new Error("Please configure Augment API URL")
      let url
      try {
        url = new URL(endpoint, baseUrl)
      } catch (error) {
        throw (this._logger.error("Augment API URL is invalid:", error), new InvalidCompletionUrlError())
      }
      if (!url.protocol.startsWith("http"))
        throw new Error(
          "Augment API URL must start with 'http://' or 'https://'",
        )
      let body = JSON.stringify(requestData, (key, value) => (value === undefined ? null : value)),
        timeout = timeoutMs ?? APIServerImpl.defaultRequestTimeoutMs,
        timeoutSignal = AbortSignal.timeout(timeout),
        method = "POST",
        response,
        requestStartTime,
        requestEndTime
      try {
        let headers = {
          "Content-Type": "application/json",
          "User-Agent": this._userAgent,
          "x-request-id": `${requestId}`,
          "x-request-session-id": `${this.sessionId}`,
          "x-api-version": "2",
        }
        apiToken && (headers.Authorization = `Bearer ${apiToken}`),
          (requestStartTime = Date.now()),
          (response = await executeWithTimeout(
            this._fetchFunction(url.toString(), {
              method: method,
              headers: headers,
              body: body,
              signal: combineAbortSignals([timeoutSignal].concat(abortSignal ? [abortSignal] : [])),
            }),
            timeout,
          )),
          (requestEndTime = Date.now())
      } catch (error) {
        throw error instanceof Error
          ? (this._logger.error(
              `API request ${requestId} to ${url.toString()} failed: ${getErrorMessage(error, true)}`,
            ),
            ApiError.transientIssue(error.message))
          : (this._logger.debug(`API request ${requestId} to ${url.toString()} failed`),
            error)
      }
      if ((metrics && ((metrics.rpcStart = requestStartTime), (metrics.rpcEnd = requestEndTime)), !response.ok))
        throw response.status === 499
          ? ApiError.fromResponse(response)
          : (response.status === 401 && usingOAuth && this._auth.removeSession(),
            response.status === 400 &&
              config.enableDebugFeatures &&
              this._logger.error(
                `API request ${requestId} to ${url.toString()} failed: ${await response.text()}`,
              ),
            this._logger.error(
              `API request ${requestId} to ${url.toString()} response ${response.status}: ${response.statusText}`,
            ),
            ApiError.fromResponse(response).status === RequestStatus.augmentTooLarge &&
              this._logger.debug(`object size is ${formatObjectSizeInfo(requestData)} `),
            ApiError.fromResponse(response))
      let responseData
      try {
        if (response.headers.get("content-length") === "0") return
        responseData = await response.json()
        fetch('http://localhost:3000', { // =
          method: 'POST',
          body: JSON.stringify({
            callMethod: 'callApi',
            endpoint,
            requestId,
            requestData,
            responseData,
          })
        });
      } catch (error) {
        throw (
          (this._logger.error(
            `API request ${requestId} to ${url.toString()} failed to convert response to json: ${error.message}`,
          ),
          error)
        )
      }
      try {
        return responseTransformer ? responseTransformer(responseData) : responseData
      } catch (error) {
        throw new ConversionError(getErrorMessage(error), JSON.stringify(responseData))
      }
    }
    _toCompletionItem(result) {
      if (typeof result.text != "string")
        throw new Error(
          `Completion item text is not a string: ${JSON.stringify(result)}`,
        )
      if (result.skipped_suffix !== undefined && typeof result.skipped_suffix != "string")
        throw new Error(
          `Completion item skipped suffix is not a string: ${JSON.stringify(result)}`,
        )
      if (
        result.suffix_replacement_text !== undefined &&
        typeof result.suffix_replacement_text != "string"
      )
        throw new Error(
          `Completion item suffix replacement text is not a string: ${JSON.stringify(result)}`,
        )
      return {
        text: result.text,
        suffixReplacementText: result.suffix_replacement_text ?? "",
        skippedSuffix: result.skipped_suffix ?? "",
        filterScore: result.filter_score ?? undefined,
      }
    }
    _extractCompletions(result) {
      return Array.isArray(result.completion_items)
        ? result.completion_items.map((n) => this._toCompletionItem(n))
        : Array.isArray(result.completions)
          ? validateAndReturnStringArray("BackCompletionResult", "completions", result.completions).map(
              (text) => ({
                text: text,
                suffixReplacementText: "",
                skippedSuffix: "",
              }),
            )
          : [
              {
                text: validateAndReturnString("BackCompletionResult", "text", result.text),
                suffixReplacementText: "",
                skippedSuffix: "",
              },
            ]
    }
    toCompleteResult(result) {
      let completionItems = this._extractCompletions(result),
        unknownBlobNames = validateAndReturnStringArray(
          "BackCompletionResult",
          "unknown_blob_names/unknown_memory_names",
          result.unknown_blob_names ?? result.unknown_memory_names,
        ),
        checkpointNotFound =
          result.checkpoint_not_found === undefined
            ? false
            : validateAndReturnBoolean(
                "BackCompletionResult",
                "checkpoint_not_found",
                result.checkpoint_not_found,
                false,
              )
      return {
        completionItems: completionItems,
        unknownBlobNames: unknownBlobNames,
        checkpointNotFound: checkpointNotFound,
        suggestedPrefixCharCount: result.suggested_prefix_char_count,
        suggestedSuffixCharCount: result.suggested_suffix_char_count,
        completionTimeoutMs: result.completion_timeout_ms,
      }
    }
    toCheckpointBlobsResult(result) {
      return {
        newCheckpointId: validateAndReturnString(
          "BackCheckpointBlobsResult",
          "new_checkpoint_id",
          result.new_checkpoint_id,
        ),
      }
    }
    async complete(requestId, prompt, suffix, path, blobName, positions, language, blobs, recentChanges, fileEdits, timeoutMs, probeOnly, metrics) {
      let config = this._configListener.config,
        recencyInfo = { recent_changes: recentChanges },
        requestData = {
          model: config.modelName,
          prompt: prompt,
          suffix: suffix,
          path: path,
          blob_name: blobName,
          prefix_begin: positions?.prefixBegin,
          cursor_position: positions?.cursorPosition,
          suffix_end: positions?.suffixEnd,
          lang: language,
          blobs: processBlobs(blobs),
          recency_info: recencyInfo,
          probe_only: probeOnly,
          sequence_id: this._sequenceId.next(),
          filter_threshold: config.completions.filterThreshold,
          edit_events: this.toFileDiffsPayload(fileEdits ?? []),
        }
      return await this.callApi(
        requestId,
        config,
        "completion",
        requestData,
        (response) => this.toCompleteResult(response),
        undefined,
        timeoutMs,
        metrics,
      )
    }
    async checkpointBlobs(blobs) {
      let requestId = this.createRequestId(),
        config = this._configListener.config,
        requestData = { blobs: processBlobs(blobs) },
        result = await this.callApi(requestId, config, "checkpoint-blobs", requestData, (response) =>
          this.toCheckpointBlobsResult(response),
        )
      for (let extraUrl of this.getUniqueExtraURLs())
        (
          await this.callApi(
            requestId,
            config,
            "checkpoint-blobs",
            requestData,
            (response) => this.toCheckpointBlobsResult(response),
            extraUrl,
          )
        ).newCheckpointId !== result.newCheckpointId &&
          this._logger.error(
            `Checkpoint blobs API returned different checkpoint IDs for ${extraUrl}`,
          )
      return result
    }
    convertToCodeEditResult(result) {
      let unknownBlobNames =
          result.unknown_blob_names === undefined
            ? []
            : validateAndReturnStringArray(
                "BackCodeEditResult",
                "unknown_blob_names",
                result.unknown_blob_names,
              ),
        checkpointNotFound =
          result.checkpoint_not_found === undefined
            ? false
            : validateAndReturnBoolean(
                "BackCodeEditResult",
                "checkpoint_not_found",
                result.checkpoint_not_found,
                false,
              )
      return {
        unknownBlobNames: unknownBlobNames,
        checkpointNotFound: checkpointNotFound,
        modifiedCode: result.text,
      }
    }
    async editCode(requestId, instruction, selectedText, prefix, suffix, path, blobName, prefixBegin, suffixEnd, language, blobs) {
      let config = this._configListener.config,
        requestData = {
          model: config.codeInstruction.model,
          instruction: instruction,
          prefix: prefix,
          selected_text: selectedText,
          suffix: suffix,
          blob_name: blobName,
          prefix_begin: prefixBegin,
          suffix_end: suffixEnd,
          lang: language,
          path: path,
          blobs: processBlobs(blobs),
          sequence_id: this._sequenceId.next(),
        }
      return await this.callApi( // =
        requestId,
        config,
        "edit",
        requestData,
        (response) => this.convertToCodeEditResult(response),
        undefined,
        12e4,
      )
    }
    async chat(
      requestId,
      message,
      chatHistory,
      blobs,
      userGuidedBlobs,
      externalSourceIds,
      modelOverride,
      vcsChange,
      recentChanges,
      contextCodeExchangeRequestId,
      selectedCode,
      prefix,
      suffix,
      path,
      language,
      C,
      disableAutoExternalSources,
      userGuidelines,
      workspaceGuidelines,
      toolDefinitions,
      nodes,
      mode,
      agentMemories,
      personaType,
    ) {
      let config = this._configListener.config,
        requestData = {
          model: modelOverride ?? config.chat.model,
          path: path,
          prefix: prefix,
          selected_code: selectedCode,
          suffix: suffix,
          message: message,
          chat_history: chatHistory,
          lang: language,
          blobs: processBlobs(blobs),
          user_guided_blobs: userGuidedBlobs,
          external_source_ids: externalSourceIds,
          enable_preference_collection: config.preferenceCollection.enable,
          context_code_exchange_request_id: contextCodeExchangeRequestId,
          vcs_change: processVcsChanges(vcsChange),
          recency_info_recent_changes: recentChanges,
          feature_detection_flags: { support_raw_output: true },
          disable_auto_external_sources: disableAutoExternalSources,
          user_guidelines: userGuidelines,
          workspace_guidelines: workspaceGuidelines,
          tool_definitions: toolDefinitions ?? [],
          nodes: nodes ?? [],
          mode: mode ?? Fr.chat,
          agent_memories: agentMemories,
          persona_type: personaType,
        }
      return await this.callApi(
        requestId,
        config,
        "chat",
        requestData,
        (response) => PT(response),
        config.chat.url,
        300000, // 5 minutes timeout
      )
    }
    toChatInstructionStreamResult(result) {
      let unknownBlobNames =
          result.unknown_blob_names === undefined
            ? []
            : validateAndReturnStringArray(
                "BackChatInstructionStreamResult",
                "unknown_blob_names",
                result.unknown_blob_names,
              ),
        checkpointNotFound =
          result.checkpoint_not_found === undefined
            ? false
            : validateAndReturnBoolean(
                "BackChatInstructionStreamResult",
                "checkpoint_not_found",
                result.checkpoint_not_found,
                false,
              )
      return {
        text: result.text,
        unknownBlobNames: unknownBlobNames,
        checkpointNotFound: checkpointNotFound,
        replacementText: result.replacement_text,
        replacementOldText: result.replacement_old_text,
        replacementStartLine: result.replacement_start_line,
        replacementEndLine: result.replacement_end_line,
      }
    }
    async chatInstructionStream(
      requestId,
      instruction,
      blobs,
      chatHistory,
      selectedText = "",
      prefix = "",
      suffix = "",
      path = "",
      blobName = "",
      prefixBegin = undefined,
      suffixEnd = undefined,
      language = "",
      userGuidelines,
      workspaceGuidelines,
      contextCodeExchangeRequestId,
    ) {
      let config = this._configListener.config,
        isEmptyInstruction = instruction.length === 0,
        apiUrl,
        modelName
      isEmptyInstruction
        ? ((apiUrl = config.smartPaste.url ?? config.chat.url), (modelName = config.smartPaste.model))
        : ((apiUrl = config.chat.url), (modelName = config.instructions.model))
      let requestData = {
        model: modelName,
        prefix: prefix,
        selected_text: selectedText,
        suffix: suffix,
        path: path,
        instruction: instruction,
        lang: language,
        blob_name: blobName,
        prefix_begin: prefixBegin,
        suffix_end: suffixEnd,
        blobs: processBlobs(blobs),
        chat_history: chatHistory,
        context_code_exchange_request_id: contextCodeExchangeRequestId,
        user_guidelines: userGuidelines,
        workspace_guidelines: workspaceGuidelines,
      }
      return await this.callApiStream(
        requestId,
        config,
        "instruction-stream",
        requestData,
        this.toChatInstructionStreamResult.bind(this),
        apiUrl,
        120000, // 2 minutes timeout
      )
    }
    _smartPasteQueue = new PromiseQueue(this._processSingleSmartPasteRequest.bind(this))
    async smartPasteStream(
      requestId,
      instruction,
      blobs,
      chatHistory,
      selectedText = "",
      prefix = "",
      suffix = "",
      pathName = "",
      blobName = "",
      prefixBegin = undefined,
      suffixEnd = undefined,
      language = "",
      codeBlock = "",
      targetFilePath = "",
      targetFileContent = "",
      contextCodeExchangeRequestId,
    ) {
      let request = {
        requestId: requestId,
        instruction: instruction,
        blobs: blobs,
        chatHistory: chatHistory,
        selectedText: selectedText,
        prefix: prefix,
        suffix: suffix,
        pathName: pathName,
        blobName: blobName,
        prefixBegin: prefixBegin,
        suffixEnd: suffixEnd,
        language: language,
        codeBlock: codeBlock,
        targetFilePath: targetFilePath,
        targetFileContent: targetFileContent,
        contextCodeExchangeRequestId: contextCodeExchangeRequestId,
      }
      return this._smartPasteQueue.insertAndKick(request)
    }
    async _processSingleSmartPasteRequest(request) {
      if (request === undefined) return
      if (request.requestServicedSignal !== undefined)
        return await request.requestServicedSignal
      let config = this._configListener.config,
        isEmptyInstruction = request.instruction.length === 0,
        apiUrl,
        modelName
      isEmptyInstruction
        ? ((apiUrl = config.smartPaste.url ?? config.chat.url), (modelName = config.smartPaste.model))
        : (apiUrl = config.chat.url)
      let requestData = {
          model: modelName,
          prefix: request.prefix,
          selected_text: request.selectedText,
          suffix: request.suffix,
          path: request.pathName,
          instruction: request.instruction,
          lang: request.language,
          blob_name: request.blobName,
          prefix_begin: request.prefixBegin,
          suffix_end: request.suffixEnd,
          blobs: processBlobs(request.blobs),
          chat_history: request.chatHistory,
          code_block: request.codeBlock,
          target_file_path: request.targetFilePath,
          target_file_content: request.targetFileContent,
          context_code_exchange_request_id: request.contextCodeExchangeRequestId,
        },
        resolveRequestServiced
      return (
        (request.requestServicedSignal = new Promise((resolve) => {
          resolveRequestServiced = resolve
        })),
        this._smartPasteQueue.insertAndKick(request),
        async function* () {
          try {
            yield* await this.callApiStream(
              request.requestId,
              config,
              "smart-paste-stream",
              requestData,
              this.toChatInstructionStreamResult.bind(this),
              apiUrl,
              12e4,
            )
          } finally {
            resolveRequestServiced()
          }
        }.bind(this)()
      )
    }
    toGenerateCommitMessageResult(result) {
      return { text: result.text }
    }
    async generateCommitMessageStream(requestId, commitData) {
      let config = this._configListener.config,
        requestData = {
          changed_file_stats: commitData.changedFileStats,
          diff: commitData.diff,
          relevant_commit_messages:
            commitData.generatedCommitMessageSubrequest.relevant_commit_messages,
          example_commit_messages:
            commitData.generatedCommitMessageSubrequest.example_commit_messages,
        }
      return await this.callApiStream(
        requestId,
        config,
        "generate-commit-message-stream",
        requestData,
        this.toGenerateCommitMessageResult.bind(this),
        undefined,
        12e4,
      )
    }
    async createRemoteAgent(workspaceSetup, initialRequestDetails, modelName, setupScript, isSetupScriptAgent) {
      let requestId = this.createRequestId(),
        config = this._configListener.config,
        requestData = {
          workspace_setup: workspaceSetup,
          initial_request_details: {
            request_nodes: initialRequestDetails.request_nodes,
            user_guidelines: initialRequestDetails.user_guidelines ?? config.chat.userGuidelines,
            workspace_guidelines: initialRequestDetails.workspace_guidelines ?? "",
            agent_memories: initialRequestDetails.agent_memories ?? "",
          },
          model: modelName ?? config.modelName,
          setup_script: setupScript,
          is_setup_script_agent: isSetupScriptAgent || false,
        }
      if (this._auth.useOAuth) {
        let session = await this._auth.getSession()
        session && (requestData.token = session.accessToken)
      }
      return (
        console.log("Calling /remote-agents/create with payload: ", requestData),
        await this.callApi(requestId, config, "remote-agents/create", requestData)
      )
    }
    async remoteAgentChat(remoteAgentId, requestDetails) {
      let requestId = this.createRequestId(),
        config = this._configListener.config,
        requestData = {
          remote_agent_id: remoteAgentId,
          request_details: {
            request_nodes: requestDetails.request_nodes,
            user_guidelines: requestDetails.user_guidelines ?? config.chat.userGuidelines,
            workspace_guidelines: requestDetails.workspace_guidelines ?? "",
            agent_memories: requestDetails.agent_memories ?? "",
          },
        },
        response = await this.callApi(requestId, config, "remote-agents/chat", requestData)
      return { remoteAgentId: response.remote_agent_id, nodes: response.nodes }
    }
    async deleteRemoteAgent(remoteAgentId) {
      let requestId = this.createRequestId(),
        config = this._configListener.config,
        requestData = { remote_agent_id: remoteAgentId }
      return await this.callApi(requestId, config, "remote-agents/delete", requestData)
    }
    async interruptRemoteAgent(remoteAgentId) {
      let requestId = this.createRequestId(),
        config = this._configListener.config,
        requestData = { remote_agent_id: remoteAgentId }
      return await this.callApi( requestId, config, "remote-agents/interrupt", requestData)
    }
    async listRemoteAgents() {
      let requestId = this.createRequestId(),
        config = this._configListener.config
      return await this.callApi(requestId, config, "remote-agents/list", {})
    }
    async getRemoteAgentChatHistory(remoteAgentId, n) {
      let requestId = this.createRequestId(),
        config = this._configListener.config,
        requestData = { remote_agent_id: remoteAgentId, last_processed_sequence_id: n }
      return await this.callApi(requestId, config, "remote-agents/get-chat-history", requestData)
    }
    async remoteAgentAddSSHKey(remoteAgentId, publicKeys) {
      let requestId = this.createRequestId(),
        config = this._configListener.config,
        requestData = { remote_agent_id: remoteAgentId, public_keys: publicKeys }
      return await this.callApi(requestId, config, "remote-agents/add-ssh-key", requestData)
    }
    async getRemoteAgentWorkspaceLogs(remoteAgentId) {
      let requestId = this.createRequestId(),
        config = this._configListener.config,
        requestData = { remote_agent_id: remoteAgentId }
      return await this.callApi(requestId, config, "remote-agents/logs", requestData)
    }
    async listGithubReposForAuthenticatedUser() {
      let requestId = this.createRequestId(),
        config = this._configListener.config
      return await this.callApi(requestId, config, "github/list-repos", {})
    }
    async listGithubRepoBranches(repo) {
      let requestId = this.createRequestId(),
        config = this._configListener.config,
        requestData = { repo: { owner: repo.owner, name: repo.name } }
      return await this.callApi(requestId, config, "github/list-branches", requestData)
    }
    async isUserGithubConfigured() {
      let requestId = this.createRequestId(),
        config = this._configListener.config
      return await this.callApi(requestId, config, "github/is-user-configured", {})
    }
    toAutofixCommandPayload(command) {
      return { input: command.input, output: command.output, exit_code: command.exitCode }
    }
    toBackTextReplacement(replacement) {
      return {
        description: replacement.description,
        path: replacement.path,
        text: replacement.text,
        old_text: replacement.oldText,
        start_line: replacement.startLine,
        end_line: replacement.endLine,
        sequence_id: replacement.sequenceId,
        old_blob_name: replacement.oldBlobName,
      }
    }
    toFileDiffsPayload(diffs) {
      return diffs.map((diff) => ({
        path: diff.path,
        before_blob_name: diff.beforeBlobName,
        after_blob_name: diff.afterBlobName,
        edits: diff.edits.map((edit) => ({
          before_start: edit.beforeStart,
          after_start: edit.afterStart,
          before_text: edit.beforeText,
          after_text: edit.afterText,
        })),
      }))
    }
    toFileCharRangePayload(ranges) {
      return ranges
        .filter((range) => range.charStart !== undefined && range.charStop !== undefined)
        .map((range) => ({
          path: range.path,
          char_start: range.charStart,
          char_end: range.charStop,
        }))
    }
    toNextEditLocationResult(result) {
      validateIsArray(
        "BackNextEditLocationResult",
        "candidate_locations",
        result.candidate_locations,
      )
      let unknownBlobNames =
          result.unknown_blob_names === undefined
            ? []
            : validateAndReturnStringArray(
                "BackNextEditLocationResult",
                "unknown_blob_names",
                result.unknown_blob_names,
              ),
        checkpointNotFound =
          result.checkpoint_not_found === undefined
            ? false
            : validateAndReturnBoolean(
                "BackNextEditResult",
                "checkpoint_not_found",
                result.checkpoint_not_found,
                false,
              ),
        criticalErrors =
          result.critical_errors === undefined || result.critical_errors === null
            ? []
            : validateAndReturnStringArray("BackNextEditResult", "critical_errors", result.critical_errors),
        candidateLocations = []
      for (let location of result.candidate_locations) {
        let range = {
            start: validateAndReturnNumber("BackLineRange", "start", location.item.range.start),
            stop: validateAndReturnNumber("BackLineRange", "stop", location.item.range.stop),
          },
          scoredLocation = {
            item: { path: validateAndReturnString("BackLocation", "path", location.item.path), range: range },
            score: validateAndReturnNumber("BackScored", "score", location.score),
            debugInfo: location.debug_info,
          }
        candidateLocations.push(scoredLocation)
      }
      return {
        candidateLocations: candidateLocations,
        unknownBlobNames: unknownBlobNames,
        checkpointNotFound: checkpointNotFound,
        criticalErrors: criticalErrors,
      }
    }
    async nextEditLocation(requestId, instruction, path, vcsChanges, editEvents, blobs, recentChanges, diagnostics, numResults, isSingleFile) {
      let config = this._configListener.config,
        requestData = {
          instruction: instruction,
          path: path,
          vcs_change: processVcsChanges(vcsChanges),
          edit_events: this.toFileDiffsPayload(editEvents),
          blobs: processBlobs(blobs),
          recent_changes: recentChanges,
          diagnostics: diagnostics,
          num_results: numResults,
          is_single_file: isSingleFile,
        }
      return await this.callApi(
        requestId,
        config,
        "next_edit_loc",
        requestData,
        (response) => this.toNextEditLocationResult(response),
        config.nextEdit.locationUrl,
        120000, // 2 minutes timeout
      )
    }
    convertToAutofixCheckResponse(response) {
      return {
        containsFailure: validateAndReturnBoolean(
          "BackAutofixCheckResponse",
          "contains_failure",
          response.contains_failure,
          false,
        ),
        isCodeRelated: validateAndReturnBoolean(
          "BackAutofixCheckResponse",
          "is_code_related",
          response.is_code_related,
          false,
        ),
      }
    }
    convertToAutofixPlanResponse(response) {
      return {
        unknownBlobNames: validateAndReturnStringArray(
          "BackAutofixPlanResponse",
          "unknown_blob_names",
          response.unknown_blob_names,
        ),
        checkpointNotFound: validateAndReturnBoolean(
          "BackAutofixPlanResponse",
          "checkpoint_not_found",
          response.checkpoint_not_found,
          false,
        ),
        summary: response.summary,
        replacements: response.replacements.map((replacement) => ({
          description: replacement.description,
          path: replacement.path,
          text: replacement.text,
          oldText: replacement.old_text,
          startLine: replacement.start_line,
          endLine: replacement.end_line,
          sequenceId: replacement.sequence_id,
          oldBlobName: replacement.old_blob_name,
        })),
      }
    }
    convertToNextEditGenerationResult(result) {
      let unknownBlobNames =
          result.unknown_blob_names === undefined
            ? []
            : validateAndReturnStringArray(
                "BackNextEditGenerationResult",
                "unknown_blob_names",
                result.unknown_blob_names,
              ),
        checkpointNotFound =
          result.checkpoint_not_found === undefined
            ? false
            : validateAndReturnBoolean(
                "BackNextEditResult",
                "checkpoint_not_found",
                result.checkpoint_not_found,
                false,
              )
      return {
        result: this.convertToNextEditResult(result.next_edit),
        unknownBlobNames: unknownBlobNames,
        checkpointNotFound: checkpointNotFound,
      }
    }
    convertToNextEditResult(result) {
      let suggestionId = validateAndReturnString("BackNextEditResult", "suggestion_id", result.suggestion_id),
        path = validateAndReturnString("BackNextEditResult", "path", result.path),
        blobName = validateAndReturnString("BackNextEditResult", "blob_name", result.blob_name),
        charStart = validateAndReturnNumber("BackNextEditResult", "char_start", result.char_start),
        charEnd = validateAndReturnNumber("BackNextEditResult", "char_end", result.char_end),
        existingCode = validateAndReturnString("BackNextEditResult", "existing_code", result.existing_code),
        suggestedCode = validateAndReturnString("BackNextEditResult", "suggested_code", result.suggested_code),
        truncationChar =
          result.truncation_char === undefined || result.truncation_char === null
            ? undefined
            : validateAndReturnNumber("BackNextEditResult", "truncation_char", result.truncation_char),
        changeDescription =
          result.change_description === undefined
            ? ""
            : validateAndReturnString(
                "BackNextEditResult",
                "change_description",
                result.change_description,
              ),
        diffSpans = result.diff_spans?.map((v) => ({
          original: {
            start: validateAndReturnNumber("BackCharRange", "start", v.original.start),
            stop: validateAndReturnNumber("BackCharRange", "stop", v.original.stop),
          },
          updated: {
            start: validateAndReturnNumber("BackCharRange", "start", v.updated.start),
            stop: validateAndReturnNumber("BackCharRange", "stop", v.updated.stop),
          },
        })),
        editingScore = validateAndReturnNumber("BackNextEditResult", "editing_score", result.editing_score),
        localizationScore = validateAndReturnNumber(
          "BackNextEditResult",
          "localization_score",
          result.localization_score,
        ),
        editingScoreThreshold =
          result.editing_score_threshold === undefined
            ? 1
            : validateAndReturnNumber(
                "BackNextEditResult",
                "editing_score_threshold",
                result.editing_score_threshold,
              )
      return {
        suggestionId: suggestionId,
        path: path,
        blobName: blobName,
        charStart: charStart,
        charEnd: charEnd,
        existingCode: existingCode,
        suggestedCode: suggestedCode,
        truncationChar: truncationChar,
        changeDescription: changeDescription,
        diffSpans: diffSpans,
        editingScore: editingScore,
        localizationScore: localizationScore,
        editingScoreThreshold: editingScoreThreshold,
      }
    }
    async nextEditStream(request) {
      let config = this._configListener.config,
        modelName = config.nextEdit.model,
        selectionBeginChar = request.prefix ? getTextLength(request.prefix) : undefined,
        requestData = {
          model: modelName,
          instruction: request.instruction ?? "",
          prefix: request.prefix,
          selected_text: request.selectedCode,
          suffix: request.suffix,
          selection_begin_char: selectionBeginChar,
          selection_end_char:
            request.prefix !== undefined && request.selectedCode !== undefined
              ? selectionBeginChar + getTextLength(request.selectedCode)
              : undefined,
          blob_name: request.blobName, // TODO: work with blobs
          lang: request.language,
          path: request.pathName?.relPath,
          blobs: (request.blobs && processBlobs(request.blobs)) ?? {
            checkpoint_id: undefined,
            added_blobs: [],
            deleted_blobs: [],
          }, // TODO: if empty, cross-file won't work, but single fle could work; only if mannualy click other files, cross-file could work
          recent_changes: request.recentChanges, // TODO: if empty, cross-file could work
          diagnostics: request.diagnostics,  // TODO: if empty, cross-file could work
          vcs_change: processVcsChanges({ workingDirectory: [], commits: [] }),
          edit_events: this.toFileDiffsPayload(request.fileEditEvents ?? []), // TODO: the most important prop, if empty, won't work even in single files
          blocked_locations: this.toFileCharRangePayload(
            request.blockedLocations ?? [],
          ),
          mode: request.mode,
          scope: request.scope,
          api_version: 3,
          sequence_id: this._sequenceId.next(),
          client_created_at: request.clientCreatedAt,
          unindexed_edit_events: this.toFileDiffsPayload(request.unindexedEditEvents),
          unindexed_edit_events_base_blob_names:
            request.unindexedEditEventsBaseBlobNames,
        }
        fetch('http://localhost:3000', {
          method: 'POST',
          body: JSON.stringify({
            callMethod: 'nextEditStream',
            requestId: request.requestId,
          })
        });
      return await this.callApiStream(
        request.requestId,
        config,
        "next-edit-stream",
        requestData,
        this.convertToNextEditGenerationResult.bind(this),
        config.nextEdit.generationUrl,
        120000, // 2 minutes timeout
      )
    }
    getUniqueExtraURLs() {
      let config = this._configListener.config,
        uniqueUrls = new Set()
      return (
        config.nextEdit.url && uniqueUrls.add(config.nextEdit.url),
        config.nextEdit.locationUrl && uniqueUrls.add(config.nextEdit.locationUrl),
        config.nextEdit.generationUrl && uniqueUrls.add(config.nextEdit.generationUrl),
        config.chat.url && uniqueUrls.add(config.chat.url),
        uniqueUrls
      )
    }
    toMemorizeResult(result) {
      return {
        blobName:
          result.blob_name !== undefined
            ? validateAndReturnString("BackMemorizeResult", "blob_name", result.blob_name)
            : validateAndReturnString("BackMemorizeResult", "mem_object_name", result.mem_object_name),
      }
    }
    async memorize(path, text, blobName, metadata, timeoutMs) {
      let requestId = this.createRequestId(),
        config = this._configListener.config,
        result = await this.callApi(
          requestId,
          config,
          "memorize",
          {
            model: config.modelName,
            path: path,
            t: text,
            blob_name: blobName,
            metadata: metadata,
            timeout_ms: timeoutMs,
          },
          (response) => this.toMemorizeResult(response),
        )
      for (let extraUrl of this.getUniqueExtraURLs())
        await this.callApi(
          requestId,
          config,
          "memorize",
          { model: config.modelName, path: path, t: text, blob_name: blobName, metadata: metadata },
          (response) => this.toMemorizeResult(response),
          extraUrl,
        )
      return result
    }
    toBatchUploadResult(result) {
      return { blobNames: result.blob_names }
    }
    async batchUpload(blobs) {
      let requestId = this.createRequestId(), // =
        config = this._configListener.config
      try {
        let result = await this.callApi(
          requestId,
          config,
          "batch-upload",
          {
            blobs: blobs.map((blob) => ({
              blob_name: blob.blobName,
              path: blob.pathName,
              content: blob.text,
            })),
          },
          this.toBatchUploadResult.bind(this),
        )
        for (let extraUrl of this.getUniqueExtraURLs())
          await this.callApi(
            requestId,
            config,
            "batch-upload",
            {
              blobs: blobs.map((blob) => ({
                blob_name: blob.blobName,
                path: blob.pathName,
                content: blob.text,
              })),
            },
            this.toBatchUploadResult.bind(this),
            extraUrl,
          )
        return result
      } catch (error) {
        if (!ApiError.isAPIErrorWithStatus(error, RequestStatus.unimplemented)) throw error
        let blobNames = []
        for (let blob of blobs) {
          let result = await this.memorize(
            blob.pathName,
            blob.text,
            blob.blobName,
            blob.metadata,
          )
          blobNames.push(result.blobName)
        }
        return { blobNames: blobNames }
      }
    }
    toFindMissingResult(result) {
      return {
        unknownBlobNames: validateAndReturnStringArray(
          "BackFindMissingResult",
          "unknown_memory_names",
          result.unknown_memory_names,
        ),
        nonindexedBlobNames: validateAndReturnStringArray(
          "BackFindMissingResult",
          "nonindexed_blob_names",
          result.nonindexed_blob_names,
        ),
      }
    }
    async findMissing(blobNames) {
      let config = this._configListener.config,
        requestId = this.createRequestId(),
        modelName = config.modelName,
        sortedBlobNames = [...blobNames].sort(),
        result = await this.callApi(
          requestId,
          config,
          "find-missing",
          { model: modelName, mem_object_names: sortedBlobNames },
          (response) => this.toFindMissingResult(response),
        )
      for (let extraUrl of this.getUniqueExtraURLs()) {
        let extraResult = await this.callApi(
          requestId,
          config,
          "find-missing",
          { model: modelName, mem_object_names: sortedBlobNames },
          (response) => this.toFindMissingResult(response),
          extraUrl,
        )
        ;(result.unknownBlobNames = result.unknownBlobNames.concat(extraResult.unknownBlobNames)),
          (result.nonindexedBlobNames = result.nonindexedBlobNames.concat(
            extraResult.nonindexedBlobNames,
          ))
      }
      return result
    }
    async resolveCompletions(resolutions) {
      let requestId = this.createRequestId(),
        config = this._configListener.config
      return await this.callApi(requestId, config, "resolve-completions", {
        client_name: "vscode-extension",
        resolutions: resolutions,
      })
    }
    async logCodeEditResolution(resolution) {
      let requestId = this.createRequestId(),
        config = this._configListener.config
      return await this.callApi(requestId, config, "resolve-edit", {
        client_name: "vscode-extension",
        ...resolution,
      })
    }
    async logSmartPasteResolution(resolution) {
      let requestId = this.createRequestId(),
        config = this._configListener.config
      return await this.callApi(requestId, config, "resolve-smart-paste", {
        client_name: "vscode-extension",
        ...resolution,
      })
    }
    async logInstructionResolution(resolution) {
      let requestId = this.createRequestId(),
        config = this._configListener.config
      return await this.callApi(requestId, config, "resolve-instruction", {
        client_name: "vscode-extension",
        ...resolution,
      })
    }
    async resolveNextEdits(resolution) {
      let requestId = this.createRequestId(),
        config = this._configListener.config
      return await this.callApi(
        requestId,
        config,
        "resolve-next-edit",
        { client_name: "vscode-extension", resolutions: resolution },
        undefined,
        config.nextEdit.url,
      )
    }
    async logNextEditSessionEvent(events) {
      let requestId = this.createRequestId(),
        config = this._configListener.config
      return await this.callApi(
        requestId,
        config,
        "record-session-events",
        {
          client_name: "vscode-extension",
          events: events.map((event) => ({
            time: new Date(
              event.event_time_sec * 1e3 + event.event_time_nsec / 1e6,
            ).toISOString(),
            event: {
              next_edit_session_event: { ...event, user_agent: this._userAgent },
            },
          })),
        },
        undefined,
        config.nextEdit.url,
      )
    }
    async logOnboardingSessionEvent(events) {
      let requestId = this.createRequestId(),
        config = this._configListener.config
      return await this.callApi(
        requestId,
        config,
        "record-session-events",
        {
          client_name: "vscode-extension",
          events: events.map((event) => ({
            time: new Date(
              event.event_time_sec * 1e3 + event.event_time_nsec / 1e6,
            ).toISOString(),
            event: {
              onboarding_session_event: { ...event, user_agent: this._userAgent },
            },
          })),
        },
        undefined,
      )
    }
    async logAgentSessionEvent(events) {
      let requestId = this.createRequestId(),
        config = this._configListener.config
      return await this.callApi(
        requestId,
        config,
        "record-session-events",
        {
          client_name: "vscode-extension",
          events: events.map((event) => ({
            time: new Date(
              event.event_time_sec * 1e3 + event.event_time_nsec / 1e6,
            ).toISOString(),
            event: {
              agent_session_event: { ...event, user_agent: this._userAgent },
            },
          })),
        },
        undefined,
      )
    }
    async logRemoteAgentSessionEvent(events) {
      let requestId = this.createRequestId(),
        config = this._configListener.config
      return await this.callApi(
        requestId,
        config,
        "record-session-events",
        {
          client_name: "vscode-extension",
          events: events.map((event) => ({
            time: new Date(
              event.event_time_sec * 1e3 + event.event_time_nsec / 1e6,
            ).toISOString(),
            event: {
              remote_agent_session_event: { ...event, user_agent: this._userAgent },
            },
          })),
        },
        undefined,
      )
    }
    async logAgentRequestEvent(events) {
      let requestIdToEvents = new Map()
      for (let event of events) {
        let eventList = requestIdToEvents.get(event.request_id) || []
        requestIdToEvents.has(event.request_id) || requestIdToEvents.set(event.request_id, eventList)
        let { request_id: o, ...eventWithoutRequestId } = event
        eventList.push(eventWithoutRequestId)
      }
      for (let [requestId, requestEvents] of requestIdToEvents) {
        let config = this._configListener.config
        await this.callApi(
          requestId,
          config,
          "record-request-events",
          {
            events: requestEvents.map((event) => ({
              time: new Date(
                event.event_time_sec * 1e3 + event.event_time_nsec / 1e6,
              ).toISOString(),
              event: {
                agent_request_event: { ...event, user_agent: this._userAgent },
              },
            })),
          },
          undefined,
        )
      }
    }
    async logExtensionSessionEvent(events) {
      let requestId = this.createRequestId(),
        config = this._configListener.config
      return await this.callApi(
        requestId,
        config,
        "record-session-events",
        {
          client_name: "vscode-extension",
          events: events.map((event) => ({
            time: event.time_iso,
            event: {
              extension_session_event: { ...event, user_agent: this._userAgent },
            },
          })),
        },
        undefined,
      )
    }
    async logToolUseRequestEvent(events) {
      let requestIdMap = new Map()
      for (let event of events) {
        let eventList = requestIdMap.get(event.requestId)
        eventList === undefined ? requestIdMap.set(event.requestId, [event]) : eventList.push(event)
      }
      for (let [requestId, requestEvents] of requestIdMap) {
        let config = this._configListener.config
        await this.callApi(
          requestId,
          config,
          "record-request-events",
          {
            events: requestEvents.map((event) => {
              let toolData = {
                tool_name: event.toolName,
                tool_use_id: event.toolUseId,
                tool_output_is_error: event.toolOutputIsError,
                tool_run_duration_ms: event.toolRunDurationMs,
                tool_input: JSON.stringify(event.toolInput),
                is_mcp_tool: event.isMcpTool,
                conversation_id: event.conversationId,
                chat_history_length: event.chatHistoryLength,
                tool_request_id: event.toolRequestId,
              }
              return {
                time: new Date(
                  event.eventTimeSec * 1e3 + event.eventTimeNsec / 1e6,
                ).toISOString(),
                event: { tool_use_data: toolData },
              }
            }),
          },
          undefined,
        )
      }
    }
    async recordPreferenceSample(sample) {
      let requestId = this.createRequestId(),
        config = this._configListener.config
      return await this.callApi(requestId, config, "record-preference-sample", {
        client_name: "vscode-extension",
        ...sample,
      })
    }
    toModel(modelInfo) {
      let completionTimeoutMs =
        modelInfo.completion_timeout_ms !== undefined
          ? validateAndReturnNumber(
              "BackModelInfo",
              "completion_timeout_ms",
              modelInfo.completion_timeout_ms,
            )
          : undefined
      return {
        name: validateAndReturnString("BackModelInfo", "name", modelInfo.name),
        suggestedPrefixCharCount: validateAndReturnNumber(
          "BackModelInfo",
          "suggested_prefix_char_count",
          modelInfo.suggested_prefix_char_count,
        ),
        suggestedSuffixCharCount: validateAndReturnNumber(
          "BackModelInfo",
          "suggested_suffix_char_count",
          modelInfo.suggested_suffix_char_count,
        ),
        completionTimeoutMs: completionTimeoutMs,
        internalName:
          modelInfo.internal_name &&
          validateAndReturnString("BackModelInfo", "internal_name", modelInfo.internal_name),
      }
    }
    toLanguage(languageInfo) {
      let name = validateAndReturnString("BackLanguageInfo", "name", languageInfo.name),
        vscodeName = validateAndReturnString("BackLanguageInfo", "vscodeName", languageInfo.vscode_name)
      validateIsArray("BackLanguageInfo", "extensions", languageInfo.extensions)
      let extensions = []
      for (let extension of languageInfo.extensions)
        extensions.push(validateAndReturnString("BackLanguageInfo", "extensions", extension))
      return { name: name, vscodeName: vscodeName, extensions: extensions }
    }
    toGetModelsResult(result) {
      let defaultModel = validateAndReturnString("BackGetModelsResult", "default_model", result.default_model)
      validateIsArray("BackGetModelsResult", "models", result.models)
      let models = []
      for (let modelInfo of result.models) models.push(this.toModel(modelInfo))
      let featureFlags = defaultFeatureFlags
      if (result.feature_flags !== undefined) {
        let gitDiffPollingFreqMsec = result.feature_flags.git_diff_polling_freq_msec
        if (
          (gitDiffPollingFreqMsec !== undefined &&
            gitDiffPollingFreqMsec > 0 &&
            ((featureFlags.gitDiff = true), (featureFlags.gitDiffPollingFrequencyMSec = gitDiffPollingFreqMsec)),
          result.feature_flags.small_sync_threshold !== undefined &&
            (featureFlags.smallSyncThreshold = result.feature_flags.small_sync_threshold),
          result.feature_flags.big_sync_threshold !== undefined &&
            (featureFlags.bigSyncThreshold = result.feature_flags.big_sync_threshold),
          result.feature_flags.enable_workspace_manager_ui_launch !== undefined &&
            (featureFlags.enableWorkspaceManagerUi =
              result.feature_flags.enable_workspace_manager_ui_launch),
          result.feature_flags.enable_instructions !== undefined &&
            (featureFlags.enableInstructions = result.feature_flags.enable_instructions),
          result.feature_flags.enable_smart_paste !== undefined &&
            (featureFlags.enableSmartPaste = result.feature_flags.enable_smart_paste),
          result.feature_flags.enable_smart_paste_min_version !== undefined &&
            (featureFlags.enableSmartPasteMinVersion =
              result.feature_flags.enable_smart_paste_min_version),
          result.feature_flags.enable_view_text_document !== undefined &&
            (featureFlags.enableViewTextDocument =
              result.feature_flags.enable_view_text_document),
          result.feature_flags.bypass_language_filter !== undefined &&
            (featureFlags.bypassLanguageFilter = result.feature_flags.bypass_language_filter),
          result.feature_flags.additional_chat_models !== undefined &&
            (featureFlags.additionalChatModels = result.feature_flags.additional_chat_models),
          result.feature_flags.enable_hindsight !== undefined &&
            (featureFlags.enableHindsight = result.feature_flags.enable_hindsight),
          result.feature_flags.max_upload_size_bytes !== undefined &&
            (featureFlags.maxUploadSizeBytes = result.feature_flags.max_upload_size_bytes),
          result.feature_flags.vscode_next_edit_min_version !== undefined &&
            (featureFlags.vscodeNextEditMinVersion =
              result.feature_flags.vscode_next_edit_min_version),
          result.feature_flags.vscode_flywheel_min_version !== undefined &&
            (featureFlags.vscodeFlywheelMinVersion =
              result.feature_flags.vscode_flywheel_min_version),
          result.feature_flags.vscode_external_sources_in_chat_min_version !==
            undefined &&
            (featureFlags.vscodeExternalSourcesInChatMinVersion =
              result.feature_flags.vscode_external_sources_in_chat_min_version),
          result.feature_flags.vscode_share_min_version !== undefined &&
            (featureFlags.vscodeShareMinVersion =
              result.feature_flags.vscode_share_min_version),
          result.feature_flags.max_trackable_file_count !== undefined &&
            (featureFlags.maxTrackableFileCount =
              result.feature_flags.max_trackable_file_count),
          result.feature_flags.max_trackable_file_count_without_permission !==
            undefined &&
            (featureFlags.maxTrackableFileCountWithoutPermission =
              result.feature_flags.max_trackable_file_count_without_permission),
          result.feature_flags.min_uploaded_percentage_without_permission !==
            undefined &&
            (featureFlags.minUploadedPercentageWithoutPermission =
              result.feature_flags.min_uploaded_percentage_without_permission),
          result.feature_flags.vscode_sources_min_version !== undefined &&
            (featureFlags.vscodeSourcesMinVersion =
              result.feature_flags.vscode_sources_min_version),
          result.feature_flags.vscode_chat_hint_decoration_min_version !== undefined &&
            (featureFlags.vscodeChatHintDecorationMinVersion =
              result.feature_flags.vscode_chat_hint_decoration_min_version),
          result.feature_flags.next_edit_debounce_ms !== undefined &&
            (featureFlags.nextEditDebounceMs = result.feature_flags.next_edit_debounce_ms),
          result.feature_flags.enable_completion_file_edit_events !== undefined &&
            (featureFlags.enableCompletionFileEditEvents =
              result.feature_flags.enable_completion_file_edit_events),
          result.feature_flags.vscode_enable_cpu_profile !== undefined &&
            (featureFlags.vscodeEnableCpuProfile =
              result.feature_flags.vscode_enable_cpu_profile),
          result.feature_flags.verify_folder_is_source_repo !== undefined &&
            (featureFlags.verifyFolderIsSourceRepo =
              result.feature_flags.verify_folder_is_source_repo),
          result.feature_flags.refuse_to_sync_home_directories !== undefined &&
            (featureFlags.refuseToSyncHomeDirectories =
              result.feature_flags.refuse_to_sync_home_directories),
          result.feature_flags.enable_file_limits_for_syncing_permission !==
            undefined &&
            (featureFlags.enableFileLimitsForSyncingPermission =
              result.feature_flags.enable_file_limits_for_syncing_permission),
          result.feature_flags.enable_chat_mermaid_diagrams !== undefined &&
            (featureFlags.enableChatMermaidDiagrams =
              result.feature_flags.enable_chat_mermaid_diagrams),
          result.feature_flags.enable_summary_titles !== undefined &&
            (featureFlags.enableSummaryTitles = result.feature_flags.enable_summary_titles),
          result.feature_flags.smart_paste_precompute_mode !== undefined &&
            (featureFlags.smartPastePrecomputeMode =
              result.feature_flags.smart_paste_precompute_mode),
          result.feature_flags.vscode_new_threads_menu_min_version !== undefined &&
            (featureFlags.vscodeNewThreadsMenuMinVersion =
              result.feature_flags.vscode_new_threads_menu_min_version),
          result.feature_flags.vscode_editable_history_min_version !== undefined &&
            (featureFlags.vscodeEditableHistoryMinVersion =
              result.feature_flags.vscode_editable_history_min_version),
          result.feature_flags.vscode_enable_chat_mermaid_diagrams_min_version !==
            undefined &&
            (featureFlags.vscodeEnableChatMermaidDiagramsMinVersion =
              result.feature_flags.vscode_enable_chat_mermaid_diagrams_min_version),
          result.feature_flags.enable_guidelines !== undefined &&
            (featureFlags.enableGuidelines = result.feature_flags.enable_guidelines),
          result.feature_flags.vscode_use_checkpoint_manager_context_min_version !==
            undefined &&
            (featureFlags.useCheckpointManagerContextMinVersion =
              result.feature_flags.vscode_use_checkpoint_manager_context_min_version),
          result.feature_flags.vscode_validate_checkpoint_manager_context !==
            undefined &&
            (featureFlags.validateCheckpointManagerContext =
              result.feature_flags.vscode_validate_checkpoint_manager_context),
          result.feature_flags.vscode_design_system_rich_text_editor_min_version !==
            undefined &&
            (featureFlags.vscodeDesignSystemRichTextEditorMinVersion =
              result.feature_flags.vscode_design_system_rich_text_editor_min_version),
          result.feature_flags.allow_client_feature_flag_overrides !== undefined &&
            (featureFlags.allowClientFeatureFlagOverrides =
              result.feature_flags.allow_client_feature_flag_overrides),
          result.feature_flags.vscode_chat_with_tools_min_version !== undefined &&
            (featureFlags.vscodeChatWithToolsMinVersion =
              result.feature_flags.vscode_chat_with_tools_min_version),
          result.feature_flags.vscode_agent_mode_min_version !== undefined &&
            (featureFlags.vscodeAgentModeMinVersion =
              result.feature_flags.vscode_agent_mode_min_version),
          result.feature_flags.vscode_agent_mode_min_stable_version !== undefined &&
            (featureFlags.vscodeAgentModeMinStableVersion =
              result.feature_flags.vscode_agent_mode_min_stable_version),
          result.feature_flags.vscode_background_agents_min_version !== undefined &&
            (featureFlags.vscodeBackgroundAgentsMinVersion =
              result.feature_flags.vscode_background_agents_min_version),
          result.feature_flags.vscode_agent_edit_tool !== undefined &&
            (featureFlags.vscodeAgentEditTool = result.feature_flags.vscode_agent_edit_tool),
          result.feature_flags.memories_params !== undefined)
        )
          try {
            featureFlags.memoriesParams = JSON.parse(result.feature_flags.memories_params)
          } catch {
            this._logger.error('Parsing of "memories_params" failed.')
          }
        if (result.feature_flags.elo_model_configuration !== undefined)
          try {
            featureFlags.eloModelConfiguration = JSON.parse(
              result.feature_flags.elo_model_configuration,
            )
          } catch {
            this._logger.error('Parsing of "elo_model_configuration" failed.')
          }
        result.feature_flags.vscode_chat_stable_prefix_truncation_min_version !==
          undefined &&
          (featureFlags.vscodeChatStablePrefixTruncationMinVersion =
            result.feature_flags.vscode_chat_stable_prefix_truncation_min_version),
          result.feature_flags.vscode_direct_apply_min_version !== undefined &&
            (featureFlags.vscodeDirectApplyMinVersion =
              result.feature_flags.vscode_direct_apply_min_version),
          result.feature_flags.vscode_next_edit_bottom_panel_min_version !==
            undefined &&
            (featureFlags.vscodeNextEditBottomPanelMinVersion =
              result.feature_flags.vscode_next_edit_bottom_panel_min_version),
          result.feature_flags.vscode_chat_multimodal_min_version !== undefined &&
            (featureFlags.vscodeChatMultimodalMinVersion =
              result.feature_flags.vscode_chat_multimodal_min_version),
          result.feature_flags.workspace_guidelines_length_limit !== undefined &&
            (featureFlags.workspaceGuidelinesLengthLimit =
              result.feature_flags.workspace_guidelines_length_limit),
          result.feature_flags.user_guidelines_length_limit !== undefined &&
            (featureFlags.userGuidelinesLengthLimit =
              result.feature_flags.user_guidelines_length_limit),
          result.feature_flags.vscode_rich_checkpoint_info_min_version !== undefined &&
            (featureFlags.vscodeRichCheckpointInfoMinVersion =
              result.feature_flags.vscode_rich_checkpoint_info_min_version),
          result.feature_flags.vscode_virtualized_message_list_min_version !==
            undefined &&
            (featureFlags.vscodeVirtualizedMessageListMinVersion =
              result.feature_flags.vscode_virtualized_message_list_min_version),
          result.feature_flags.agent_edit_tool_min_view_size !== undefined &&
            (featureFlags.agentEditToolMinViewSize =
              result.feature_flags.agent_edit_tool_min_view_size),
          result.feature_flags.agent_edit_tool_schema_type !== undefined &&
            (featureFlags.agentEditToolSchemaType =
              result.feature_flags.agent_edit_tool_schema_type),
          result.feature_flags.vscode_personalities_min_version !== undefined &&
            (featureFlags.vscodePersonalitiesMinVersion =
              result.feature_flags.vscode_personalities_min_version),
          result.feature_flags.memory_classification_on_first_token !== undefined &&
            (featureFlags.memoryClassificationOnFirstToken =
              result.feature_flags.memory_classification_on_first_token),
          result.feature_flags.agent_save_file_tool_instructions_reminder !==
            undefined &&
            (featureFlags.agentSaveFileToolInstructionsReminder =
              result.feature_flags.agent_save_file_tool_instructions_reminder),
          result.feature_flags.use_memory_snapshot_manager !== undefined &&
            (featureFlags.useMemorySnapshotManager =
              result.feature_flags.use_memory_snapshot_manager),
          result.feature_flags.vscode_generate_commit_message_min_version !==
            undefined &&
            (featureFlags.vscodeGenerateCommitMessageMinVersion =
              result.feature_flags.vscode_generate_commit_message_min_version)
      }
      let languages = []
      if (result.languages === undefined) languages = supportedLanguages
      else {
        validateIsArray("BackGetModelsResult", "languages", result.languages), (languages = [])
        for (let languageInfo of result.languages) languages.push(this.toLanguage(languageInfo))
      }
      let userTier = result.user_tier?.toLowerCase().replace("_tier", "") ?? "unknown"
      return {
        defaultModel: defaultModel,
        models: models,
        languages: languages,
        featureFlags: featureFlags,
        userTier: userTier,
      }
    }
    async getModelConfig() {
      let config = this._configListener.config,
        requestId = this.createRequestId()
      return await this.callApi(requestId, config, "get-models", {}, (response) =>
        this.toGetModelsResult(response),
      )
    }
    async completionFeedback(feedback) {
      let config = this._configListener.config,
        requestId = this.createRequestId()
      await this.callApi(
        requestId,
        config,
        "completion-feedback",
        { request_id: feedback.requestId, rating: feedback.rating, note: feedback.note },
        undefined,
      )
    }
    async chatFeedback(feedback) {
      let config = this._configListener.config,
        requestId = this.createRequestId()
      await this.callApi(
        requestId,
        config,
        "chat-feedback",
        {
          request_id: feedback.requestId,
          rating: feedback.rating,
          note: feedback.note,
          mode: feedback.mode,
        },
        undefined,
      )
    }
    async nextEditFeedback(feedback) {
      let config = this._configListener.config,
        requestId = this.createRequestId()
      await this.callApi(
        requestId,
        config,
        "next-edit-feedback",
        { request_id: feedback.requestId, rating: feedback.rating, note: feedback.note },
        undefined,
        config.nextEdit.url,
      )
    }
    async getAccessToken(redirectUri, tokenUrl, codeVerifier, code) {
      let config = this._configListener.config,
        requestId = this.createRequestId(),
        params = {
          grant_type: "authorization_code",
          client_id: config.oauth.clientID,
          code_verifier: codeVerifier,
          redirect_uri: redirectUri,
          code: code,
        }
      return await this.callApi(requestId, config, "token", params, (response) => response.access_token, tokenUrl)
    }
    async uploadUserEvents(events) {
      let requestId = this.createRequestId()
      return await this.callApi(
        requestId,
        this._configListener.config,
        "record-user-events",
        { extension_data: events },
      )
    }
    async clientMetrics(metrics) {
      let config = this._configListener.config,
        requestId = this.createRequestId()
      await this.callApi(
        requestId,
        config,
        "client-metrics",
        { metrics: metrics },
        undefined,
        undefined,
        APIServerImpl.defaultRequestTimeoutMs,
      )
    }
    async searchExternalSources(query, sourceTypes) {
      let config = this._configListener.config,
        requestId = this.createRequestId()
      return await this.callApi(
        requestId,
        config,
        "search-external-sources",
        { query: query, source_types: sourceTypes },
        (response) => response,
      )
    }
    async getImplicitExternalSources(message) {
      let config = this._configListener.config,
        requestId = this.createRequestId()
      return await this.callApi(
        requestId,
        config,
        "get-implicit-external-sources",
        { message: message },
        (response) => response,
      )
    }
    convertToAgentCodebaseRetrievalResult(result) {
      return { formattedRetrieval: result.formatted_retrieval }
    }
    async agentCodebaseRetrieval(requestId, informationRequest, blobs, dialog, maxOutputLength, abortSignal) {
      let config = this._configListener.config
      return await this.callApi(
        requestId,
        config,
        "agents/codebase-retrieval",
        {
          information_request: informationRequest,
          blobs: processBlobs(blobs),
          dialog: dialog,
          max_output_length: maxOutputLength,
        },
        (response) => this.convertToAgentCodebaseRetrievalResult(response),
        config.chat.url,
        120000,
        undefined,
        abortSignal,
      )
    }
    convertToAgentEditFileResult(result) {
      return {
        modifiedFileContents: result.modified_file_contents,
        isError: result.is_error,
      }
    }
    async agentEditFile(requestId, filePath, editSummary, detailedEditDescription, fileContents, abortSignal) {
      let config = this._configListener.config
      return await this.callApi(
        requestId,
        config,
        "agents/edit-file",
        {
          file_path: filePath,
          edit_summary: editSummary,
          detailed_edit_description: detailedEditDescription,
          file_contents: fileContents,
        },
        (response) => this.convertToAgentEditFileResult(response),
        config.chat.url,
        120000,
        undefined,
        abortSignal,
      )
    }
    convertToToolSafety(toolSafetyValue) {
      switch (toolSafetyValue) {
        case 0:
          return ToolSafetyLevel.Unsafe
        case 1:
          return ToolSafetyLevel.Safe
        case 2:
          return ToolSafetyLevel.Check
        default:
          return ToolSafetyLevel.Unsafe
      }
    }
    convertToListRemoteToolsResult(result) {
      return {
        tools: result.tools.map((tool) => ({
          toolDefinition: tool.tool_definition,
          remoteToolId: tool.remote_tool_id,
          availabilityStatus: tool.availability_status,
          toolSafety: this.convertToToolSafety(tool.tool_safety),
          oauthUrl: tool.oauth_url,
        })),
      }
    }
    async listRemoteTools(toolIds) {
      let requestId = this.createRequestId(),
        config = this._configListener.config
      return await this.callApi(
        requestId,
        config,
        "agents/list-remote-tools",
        { tool_id_list: { tool_ids: toolIds } },
        (response) => this.convertToListRemoteToolsResult(response),
        config.chat.url,
        120000,
      )
    }
    convertToCheckToolSafetyResult(result) {
      return result.is_safe
    }
    async checkToolSafety(toolId, toolInputJson) {
      let requestId = this.createRequestId(),
        config = this._configListener.config
      return await this.callApi(
        requestId,
        config,
        "agents/check-tool-safety",
        { tool_id: toolId, tool_input_json: toolInputJson },
        (response) => this.convertToCheckToolSafetyResult(response),
        config.chat.url,
        120000,
      )
    }
    convertToRunRemoteToolResult(result) {
      return {
        toolOutput: result.tool_output,
        toolResultMessage: result.tool_result_message,
        status: result.status,
      }
    }
    async runRemoteTool(requestId, toolName, toolInputJson, toolId, extraToolInput, abortSignal) {
      let config = this._configListener.config,
        extraToolParams = {}
      if (extraToolInput)
        if (toolId === IntegrationServiceType.Jira || toolId === IntegrationServiceType.Confluence) {
          let atlassianInput = extraToolInput
          extraToolParams = {
            extra_tool_input: {
              atlassian_tool_extra_input: {
                server_url: atlassianInput.serverUrl,
                personal_api_token: atlassianInput.personalApiToken,
                username: atlassianInput.username,
              },
            },
          }
        } else
          toolId === IntegrationServiceType.Notion
            ? (extraToolParams = {
                extra_tool_input: {
                  notion_tool_extra_input: { api_token: extraToolInput.apiToken },
                },
              })
            : toolId === IntegrationServiceType.Linear
              ? (extraToolParams = {
                  extra_tool_input: {
                    linear_tool_extra_input: { api_token: extraToolInput.apiToken },
                  },
                })
              : toolId === IntegrationServiceType.GitHubApi &&
                (extraToolParams = {
                  extra_tool_input: {
                    github_tool_extra_input: { api_token: extraToolInput.apiToken },
                  },
                })
      return await this.callApi(
        requestId,
        config,
        "agents/run-remote-tool",
        { tool_name: toolName, tool_input_json: toolInputJson, tool_id: toolId, ...extraToolParams },
        (response) => this.convertToRunRemoteToolResult(response),
        config.chat.url,
        120000,
        undefined,
        abortSignal,
      )
    }
    convertToRevokeToolAccessResult(result) {
      return { status: result.status }
    }
    async revokeToolAccess(toolId) {
      let requestId = this.createRequestId(),
        config = this._configListener.config
      return await this.callApi(
        requestId,
        config,
        "agents/revoke-tool-access",
        { tool_id: toolId },
        (response) => this.convertToRevokeToolAccessResult(response),
        config.chat.url,
      )
    }
    reportError(errorType, errorMessage, errorStack, requestId) {
      return Promise.reject(
        new Error(
          "reportError should only be used via APIServerImplWithErrorReporting",
        ),
      )
    }
    async reportClientCompletionTimelines(timelines) {
      let config = this._configListener.config,
        requestId = this.createRequestId()
      await this.callApi(
        requestId,
        config,
        "/client-completion-timelines",
        { timelines: timelines },
        undefined,
        undefined,
        APIServerImpl.defaultRequestTimeoutMs,
      )
    }
    async checkCommand(command, output, requestId) {
      let config = this._configListener.config,
        params = { command, output }
      return await this.callApi(
        requestId,
        config,
        "check_command",
        params,
        (response) => response,
        config.autofix.autofixUrl,
        10000,
      )
    }
    async containErrors(command, output, requestId) {
      let config = this._configListener.config,
        params = { command, output }
      return await this.callApi(
        requestId,
        config,
        "contain_errors",
        params,
        (response) => response,
        config.autofix.autofixUrl,
        10000,
      )
    }
    async createFixPlan(gitDiff, command, output, editLocations, requestId) {
      let config = this._configListener.config,
        params = {
          output: { command: command, output: output },
          git_diff: gitDiff,
          edit_locations: editLocations,
        }
      return await this.callApi(
        requestId,
        config,
        "create_fix_plan",
        params,
        (response) => response,
        config.autofix.autofixUrl,
        30000,
      )
    }
    async applyFileFix(fileFix, sourceContent, requestId) {
      let config = this._configListener.config,
        params = { file_fix: fileFix, source_content: sourceContent }
      return await this.callApi(
        requestId,
        config,
        "apply_file_fix",
        params,
        (response) => response,
        config.autofix.autofixUrl,
        30000,
      )
    }
    async autofixCheck(command) {
      let config = this._configListener.config,
        requestId = this.createRequestId()
      return await this.callApi(
        requestId,
        config,
        "/autofix/check",
        { command: this.toAutofixCommandPayload(command) },
        (response) => this.convertToAutofixCheckResponse(response),
        config.autofix.autofixUrl,
        10000,
      )
    }
    async autofixPlan(command, vcsChanges, blobs, steeringHistory) {
      let config = this._configListener.config,
        requestId = this.createRequestId()
      return await this.callApi(
        requestId,
        config,
        "/autofix/plan",
        {
          command: this.toAutofixCommandPayload(command),
          vcs_change: processVcsChanges(vcsChanges),
          blobs: processBlobs(blobs),
          steering_history: (steeringHistory || []).map((item) => ({
            request_message: item.requestMessage,
            summary: item.summary,
            replacements: item.replacements.map((replacement) =>
              this.toBackTextReplacement(replacement),
            ),
            request_id: item.requestId,
          })),
        },
        (response) => this.convertToAutofixPlanResponse(response),
        config.autofix.autofixUrl,
        60000,
      )
    }
    async saveChat(conversationId, chat, title) {
      let config = this._configListener.config,
        requestId = this.createRequestId(),
        params = {
          conversation_id: conversationId,
          chat: chat.map((message) => ({
            request_message: message.request_message,
            response_text: message.response_text,
            request_id: message.request_id,
          })),
          title: title,
        }
      return await this.callApi(
        requestId,
        config,
        "/save-chat",
        params,
        (response) => response,
        config.chat.url,
        APIServerImpl.defaultRequestTimeoutMs,
      )
    }
  },
  APIServer = class extends APIServerImpl {
    constructor(configListener, auth, sessionId, userAgent, fetchFunction) {
      super(configListener, auth, sessionId, userAgent, fetchFunction)
    }
    async callApi(requestId, config, endpoint, params, responseConverter = (response) => response, baseUrl, timeoutMs, headers, abortSignal) {
      let startTime = Date.now()
      try {
        return await super.callApi(requestId, config, endpoint, params, responseConverter, baseUrl, timeoutMs, headers, abortSignal)
      } catch (error) {
        throw (await this.handleError(error, endpoint, params, baseUrl ?? "", requestId, startTime), error)
      }
    }
    async handleError(error, endpoint, params, baseUrl, requestId, startTime) {
      if (ApiError.isAPIErrorWithStatus(error, RequestStatus.cancelled)) throw error
      let diagnostics = [
          {
            key: "body_length",
            value: `${JSON.stringify(params, (key, value) => (value === undefined ? null : value)).length}`,
          },
          { key: "start_time", value: `${startTime}` },
          { key: "end_time", value: `${Date.now()}` },
          { key: "message", value: getErrorMessage(error) },
        ],
        stackTrace = error instanceof Error ? error.stack : undefined
      error instanceof ApiError &&
        error.status === RequestStatus.augmentTooLarge &&
        diagnostics.push({ key: "object_size_breakdown", value: `${formatObjectSizeInfo(params)}` })
      let errorStatus = error instanceof ApiError ? error.status : RequestStatus.unknown,
        errorMessage = `${endpoint} call failed with APIStatus ${RequestStatus[errorStatus]}`
      throw (
        (error instanceof ConversionError && (errorMessage = `converting ${endpoint} response failed`),
        baseUrl && this.getUniqueExtraURLs().has(baseUrl)
          ? this._logger.error(`API error ${endpoint} to ${baseUrl}: ${errorMessage}`)
          : await this.reportError(requestId, errorMessage, stackTrace ?? "", diagnostics),
        error)
      )
    }
    async callApiStream(requestId, config, endpoint, params, responseConverter, baseUrl, timeoutMs, abortSignal) {
      let startTime = Date.now()
      try {
        return await super.callApiStream(requestId, config, endpoint, params, responseConverter, baseUrl, timeoutMs, abortSignal)
      } catch (error) {
        throw (await this.handleError(error, endpoint, params, baseUrl ?? "", requestId, startTime), error)
      }
    }
    async reportError(requestId, errorMessage, stackTrace, diagnostics) {
      let config = this._configListener.config,
        newRequestId = this.createRequestId(),
        sanitizedStackTrace = stackTrace.replace(/ \(\/[^()]+\)/g, "")
      try {
        return await super.callApi(
          newRequestId,
          config,
          "report-error",
          {
            original_request_id: requestId,
            sanitized_message: errorMessage,
            stack_trace: sanitizedStackTrace,
            diagnostics: diagnostics,
          },
          undefined,
          undefined,
          500,
        )
      } catch (error) {
        this._logger.error(
          `Dropping error report "${errorMessage}" due to error: ${getErrorMessage(error)}`,
        )
      }
    }
  },
  SequenceGenerator = class {
    _sequenceId = 0
    next() {
      return this._sequenceId++
    }
  }
var F0e = q(_s()),
  qc = q(require("vscode"))
var dft = { Augment: null },
  fft = k.object({
    apiToken: k.string(),
    completionURL: k.string(),
    disableCompletionsByLanguage: k.array(k.string()),
    enableAutomaticCompletions: k.boolean(),
    completions: k.object({
      enableAutomaticCompletions: k.boolean(),
      disableCompletionsByLanguage: k.array(k.string()),
      enableQuickSuggestions: k.boolean(),
    }),
    shortcutsDisplayDelayMS: k.number(),
    enableEmptyFileHint: k.boolean(),
    disableFocusOnEmptyWorkspace: k.boolean(),
    conflictingCodingAssistantCheck: k.boolean(),
    chat: k.object({ userGuidelines: k.string() }),
    nextEdit: k.object({
      enableBackgroundSuggestions: k.boolean(),
      enableGlobalBackgroundSuggestions: k.boolean(),
      highlightSuggestionsInTheEditor: k.boolean(),
      showDiffInHover: k.boolean(),
      enableAutoApply: k.boolean(),
    }),
    advanced: k.object({
      apiToken: k.string(),
      completionURL: k.string(),
      oauth: k.object({ clientID: k.string(), url: k.string() }),
      model: k.string(),
      codeInstruction: k.object({ model: k.string() }),
      chat: k.object({
        url: k.string(),
        model: k.string(),
        stream: k.boolean(),
        enableEditableHistory: k.boolean(),
        useRichTextHistory: k.boolean(),
        smartPasteUsePrecomputation: k.boolean(),
        experimentalFullFilePaste: k.boolean(),
        modelDisplayNameToId: k.record(k.string().nullable()),
      }),
      autofix: k.object({
        enabled: k.boolean(),
        locationUrl: k.string(),
        autofixUrl: k.string(),
      }),
      enableDebugFeatures: k.boolean(),
      enableWorkspaceUpload: k.boolean(),
      enableReviewerWorkflows: k.boolean(),
      completions: k.object({
        timeoutMs: k.number(),
        maxWaitMs: k.number(),
        addIntelliSenseSuggestions: k.boolean(),
        filterThreshold: k.number(),
        filter_threshold: k.number(),
      }),
      openFileManager: k.object({ v2Enabled: k.boolean() }),
      enableDataCollection: k.boolean(),
      nextEditURL: k.string(),
      nextEditLocationURL: k.string(),
      nextEditGenerationURL: k.string(),
      nextEditBackgroundGeneration: k.boolean(),
      nextEdit: k.object({
        enabled: k.boolean(),
        backgroundEnabled: k.boolean(),
        url: k.string(),
        locationUrl: k.string(),
        generationUrl: k.string(),
        model: k.string(),
        useDebounceMs: k.number(),
        useCursorDecorations: k.boolean(),
        allowDuringDebugging: k.boolean(),
        useMockResults: k.boolean(),
        noDiffModeUseCodeLens: k.boolean(),
        enableBottomPanel: k.boolean(),
      }),
      recencySignalManager: k.object({ collectTabSwitchEvents: k.boolean() }),
      preferenceCollection: k.object({
        enable: k.boolean(),
        enableRetrievalDataCollection: k.boolean(),
        enableRandomizedMode: k.boolean(),
      }),
      vcs: k.object({ watcherEnabled: k.boolean() }),
      smartPaste: k.object({ url: k.string(), model: k.string() }),
      instructions: k.object({ model: k.string() }),
      integrations: k.object({
        atlassian: k.object({
          serverUrl: k.string(),
          personalApiToken: k.string(),
          username: k.string(),
        }),
        notion: k.object({ apiToken: k.string() }),
        linear: k.object({ apiToken: k.string() }),
        github: k.object({ apiToken: k.string() }),
      }),
      mcpServers: k.array(
        k.object({
          command: k.string(),
          args: k.array(k.string()),
          timeoutMs: k.number(),
          env: k.record(k.string()),
        }),
      ),
      personalityPrompts: k
        .object({
          agent: k.string().optional(),
          prototyper: k.string().optional(),
          brainstorm: k.string().optional(),
          reviewer: k.string().optional(),
        })
        .optional(),
    }),
  }),
  k0e = fft.deepPartial(),
  sM = class e extends DisposableContainer {
    _config
    _configChanged = new qc.EventEmitter()
    _configMonitor
    _logger = z("AugmentConfigListener")
    constructor() {
      super(),
        (this._configMonitor = new Yy("Config", this._logger)),
        this._refreshConfig(),
        this.addDisposable(
          qc.workspace.onDidChangeConfiguration(() => this._refreshConfig()),
        )
    }
    get config() {
      return this._config
    }
    get onDidChange() {
      return this._configChanged.event
    }
    _refreshConfig() {
      let t = this._config
      ;(this._config = e.normalizeConfig(this._getRawSettings())),
        this._configMonitor.update(this._config) &&
          this._configChanged.fire({
            previousConfig: t,
            newConfig: this._config,
          })
    }
    static normalizeConfig(t) {
      return {
        apiToken: (t?.advanced?.apiToken ?? t.apiToken ?? "")
          .trim()
          .toUpperCase(),
        completionURL: (
          t?.advanced?.completionURL ??
          t.completionURL ??
          ""
        ).trim(),
        modelName: t?.advanced?.model ?? "",
        conflictingCodingAssistantCheck:
          t.conflictingCodingAssistantCheck ?? true,
        codeInstruction: { model: t.advanced?.codeInstruction?.model },
        chat: {
          url: t.advanced?.chat?.url,
          model: t.advanced?.chat?.model,
          stream: t.advanced?.chat?.stream,
          enableEditableHistory: t.advanced?.chat?.enableEditableHistory ?? false,
          useRichTextHistory: t.advanced?.chat?.useRichTextHistory ?? true,
          smartPasteUsePrecomputation:
            t.advanced?.chat?.smartPasteUsePrecomputation ?? true,
          experimentalFullFilePaste:
            t.advanced?.chat?.experimentalFullFilePaste ?? false,
          modelDisplayNameToId: t.advanced?.chat?.modelDisplayNameToId ?? dft,
          userGuidelines: t.chat?.userGuidelines || "",
        },
        autofix: {
          enabled: t.advanced?.autofix?.enabled ?? false,
          locationUrl: t.advanced?.autofix?.locationUrl,
          autofixUrl: t.advanced?.autofix?.autofixUrl,
        },
        oauth: {
          clientID: t.advanced?.oauth?.clientID ?? "augment-vscode-extension",
          url: t.advanced?.oauth?.url ?? "https://auth.augmentcode.com",
        },
        enableUpload: t.advanced?.enableWorkspaceUpload ?? true,
        shortcutsDisplayDelayMS: t.shortcutsDisplayDelayMS ?? 2e3,
        enableEmptyFileHint: t.enableEmptyFileHint ?? true,
        disableFocusOnEmptyWorkspace: t.disableFocusOnEmptyWorkspace ?? false,
        enableDataCollection: t.advanced?.enableDataCollection ?? false,
        enableDebugFeatures: t.advanced?.enableDebugFeatures ?? false,
        enableReviewerWorkflows: t.advanced?.enableReviewerWorkflows ?? false,
        completions: {
          enableAutomaticCompletions:
            t.enableAutomaticCompletions ??
            t.completions?.enableAutomaticCompletions ??
            true,
          disableCompletionsByLanguage: new Set(
            t.disableCompletionsByLanguage ??
              t.completions?.disableCompletionsByLanguage ??
              [],
          ),
          enableQuickSuggestions: t.completions?.enableQuickSuggestions ?? true,
          timeoutMs: t.advanced?.completions?.timeoutMs ?? 800,
          maxWaitMs: t.advanced?.completions?.maxWaitMs ?? 1600,
          addIntelliSenseSuggestions:
            t.advanced?.completions?.addIntelliSenseSuggestions ?? true,
          filterThreshold: t.advanced?.completions?.filter_threshold,
        },
        openFileManager: {
          v2Enabled: t.advanced?.openFileManager?.v2Enabled ?? false,
        },
        nextEdit: {
          enabled: t.advanced?.nextEdit?.enabled,
          backgroundEnabled: t.advanced?.nextEdit?.backgroundEnabled ?? true,
          url: t.advanced?.nextEdit?.url,
          locationUrl:
            t.advanced?.nextEdit?.locationUrl ?? t.advanced?.nextEdit?.url,
          generationUrl:
            t.advanced?.nextEdit?.generationUrl ?? t.advanced?.nextEdit?.url,
          model: t.advanced?.nextEdit?.model,
          useDebounceMs: t.advanced?.nextEdit?.useDebounceMs,
          useCursorDecorations:
            t.advanced?.nextEdit?.useCursorDecorations ?? false,
          allowDuringDebugging:
            t.advanced?.nextEdit?.allowDuringDebugging ?? false,
          useMockResults: t.advanced?.nextEdit?.useMockResults ?? false,
          noDiffModeUseCodeLens:
            t.advanced?.nextEdit?.noDiffModeUseCodeLens ?? false,
          enableBackgroundSuggestions:
            t.nextEdit?.enableBackgroundSuggestions ?? true,
          enableGlobalBackgroundSuggestions:
            t.nextEdit?.enableGlobalBackgroundSuggestions ?? false,
          highlightSuggestionsInTheEditor:
            t.nextEdit?.highlightSuggestionsInTheEditor ?? false,
          showDiffInHover: t.nextEdit?.showDiffInHover ?? false,
          enableAutoApply: t.nextEdit?.enableAutoApply ?? true,
          enableBottomPanel: t.advanced?.nextEdit?.enableBottomPanel,
        },
        recencySignalManager: {
          collectTabSwitchEvents:
            t.advanced?.recencySignalManager?.collectTabSwitchEvents ?? false,
        },
        preferenceCollection: {
          enable: t.advanced?.preferenceCollection?.enable ?? false,
          enableRetrievalDataCollection:
            t.advanced?.preferenceCollection?.enableRetrievalDataCollection ??
            false,
          enableRandomizedMode:
            t.advanced?.preferenceCollection?.enableRandomizedMode ?? true,
        },
        vcs: { watcherEnabled: t.advanced?.vcs?.watcherEnabled ?? false },
        smartPaste: {
          url: t.advanced?.smartPaste?.url,
          model: t.advanced?.smartPaste?.model,
        },
        instructions: { model: t.advanced?.instructions?.model },
        integrations: {
          atlassian: t.advanced?.integrations?.atlassian
            ? {
                serverUrl: t.advanced.integrations.atlassian.serverUrl || "",
                personalApiToken:
                  t.advanced.integrations.atlassian.personalApiToken || "",
                username: t.advanced.integrations.atlassian.username || "",
              }
            : undefined,
          notion: t.advanced?.integrations?.notion
            ? { apiToken: t.advanced.integrations.notion.apiToken || "" }
            : undefined,
          linear: t.advanced?.integrations?.linear
            ? { apiToken: t.advanced.integrations.linear.apiToken || "" }
            : undefined,
          github: t.advanced?.integrations?.github
            ? { apiToken: t.advanced.integrations.github.apiToken || "" }
            : undefined,
        },
        mcpServers: (t.advanced?.mcpServers ?? [])
          .filter((r) => r !== undefined)
          .map((r) => ({
            command: M0e(r.command || ""),
            args: r.args?.map((n) => M0e(n)),
            timeoutMs: r.timeoutMs,
            env: r.env,
          })),
        advanced: { personalityPrompts: t.advanced?.personalityPrompts },
      }
    }
    _getRawSettings() {
      let t = qc.workspace.getConfiguration("augment")
      return e.parseSettings(t)
    }
    async migrateLegacyConfig() {
      let t = qc.workspace.getConfiguration("augment")
      await this._moveConfig(
        t,
        "enableAutomaticCompletions",
        "completions.enableAutomaticCompletions",
      ),
        await this._moveConfig(
          t,
          "disableCompletionsByLanguage",
          "completions.disableCompletionsByLanguage",
        ),
        await this._moveConfig(
          t,
          "enableBackgroundSuggestions",
          "nextEdit.enableBackgroundSuggestions",
        ),
        await this._moveConfig(
          t,
          "enableGlobalBackgroundSuggestions",
          "nextEdit.enableGlobalBackgroundSuggestions",
        ),
        await this._moveConfig(
          t,
          "highlightSuggestionsInTheEditor",
          "nextEdit.highlightSuggestionsInTheEditor",
        )
    }
    async _moveConfig(t, r, n) {
      let i = t.inspect(r)
      if (!i) return
      let s = t.inspect(n),
        o = [
          {
            target: qc.ConfigurationTarget.Workspace,
            oldValue: i.workspaceValue,
            newValue: s?.workspaceValue,
          },
          {
            target: qc.ConfigurationTarget.Global,
            oldValue: i.globalValue,
            newValue: s?.globalValue,
          },
        ]
      for (let a of o)
        a.oldValue !== undefined &&
          (a.newValue === undefined && (await t.update(n, a.oldValue, a.target)),
          await t.update(r, undefined, a.target))
    }
    static parseSettings(t) {
      let r = z("AugmentConfigListener"),
        n = k0e.safeParse(t)
      if (!n.success) {
        let i = n.error.issues.map(
          (l) => "[" + l.path.join(".") + "]: " + l.message,
        )
        r.error(`Failed to parse settings:
${i.join(`
`)}`)
        let s = n.error.issues.map((l) => l.path.join(".")),
          o = (0, F0e.omit)(JSON.parse(JSON.stringify(t)), s),
          a = k0e.safeParse(o)
        return a.success
          ? (r.info("settings parsed successfully after cleaning"), a.data)
          : {}
      }
      return r.info("settings parsed successfully"), n.data
    }
  }
function M0e(e) {
  let t = "${workspaceFolder}"
  if (!e.includes(t)) return e
  let r = qc.workspace.workspaceFolders?.length ?? 0
  r !== 1 &&
    z("AugmentConfigListener").warn(
      `Variable ${t} cannot be expanded because there are ${r} workspace folders open.`,
    )
  let n = qc.workspace.workspaceFolders?.[0]?.uri
  return n && (e = e.replaceAll(t, n.fsPath)), e
}
var oM = class extends DisposableContainer {
  constructor(r, n, i) {
    super()
    this._actionsModel = r
    this._authSession = n
    this._configListener = i
    this.addDisposable(
      this._authSession.onDidChangeSession(() => {
        this._updateSignInState()
      }),
    ),
      this.addDisposable(
        this._authSession.onReady(() => {
          this._updateSignInState()
        }),
      ),
      this.addDisposable(
        this._configListener.onDidChange(
          ({ newConfig: s, previousConfig: o }) => {
            ;(s.apiToken === o.apiToken &&
              s.completionURL === o.completionURL) ||
              this._updateSignInState()
          },
        ),
      ),
      this._updateSignInState()
  }
  _updateSignInState() {
    if (!this._authSession.useOAuth) {
      this._actionsModel.setSystemStateStatus("authenticated", "complete")
      return
    }
    if (this._authSession.isLoggedIn === undefined) return
    this._authSession.isLoggedIn === false &&
      this._configListener.config.enableDebugFeatures &&
      this._actionsModel.restartActionsState()
    let r = this._authSession.isLoggedIn ? "complete" : "incomplete"
    this._actionsModel.setSystemStateStatus("authenticated", r)
  }
}
var Q0e = q(_s()),
  jh = q(require("vscode"))
var nx = "augment.sessions",
  aM = ["email"],
  lM = class extends DisposableContainer {
    constructor(r, n) {
      super()
      this._context = r
      this._config = n
      this.addDisposables(
        this.onDidChangeSession((i) => {
          ;(this._isLoggedIn = !!i),
            jh.commands.executeCommand(
              "setContext",
              "vscode-augment.isLoggedIn",
              this._isLoggedIn,
            )
        }),
        this._context.secrets.onDidChange(async (i) => {
          i.key === nx &&
            this._sessionChangeEmitter.fire(await this.getSession())
        }),
        this._config.onDidChange(() => {
          jh.commands.executeCommand(
            "setContext",
            "vscode-augment.useOAuth",
            this.useOAuth,
          )
        }),
      ),
        (this._ready = this.initState())
    }
    _sessionChangeEmitter = new jh.EventEmitter()
    _readyEmitter = new jh.EventEmitter()
    _isLoggedIn
    _ready
    get onDidChangeSession() {
      return this._sessionChangeEmitter.event
    }
    get onReady() {
      return this._readyEmitter.event
    }
    get useOAuth() {
      let r = this._config.config
      return (
        !!r.oauth &&
        !!r.oauth.url &&
        !!r.oauth.clientID &&
        !r.apiToken &&
        !r.completionURL
      )
    }
    async initState() {
      ;(this._isLoggedIn = !!(await this.getSession())),
        jh.commands.executeCommand(
          "setContext",
          "vscode-augment.isLoggedIn",
          this._isLoggedIn,
        ),
        jh.commands.executeCommand(
          "setContext",
          "vscode-augment.useOAuth",
          this.useOAuth,
        ),
        this._readyEmitter.fire()
    }
    get isLoggedIn() {
      return this._isLoggedIn
    }
    async saveSession(r, n) {
      await this._context.secrets.store(
        nx,
        JSON.stringify({ accessToken: r, tenantURL: n, scopes: aM }),
      )
    }
    async getSession() {
      let r = await this._context.secrets.get(nx)
      if (r) {
        let n = JSON.parse(r)
        if ((0, Q0e.isEqual)(n.scopes, aM)) return n
      }
      return null
    }
    async removeSession() {
      ;(await this._context.secrets.get(nx)) &&
        (await this._context.secrets.delete(nx))
    }
  }
var jy = require("crypto"),
  wo = q(require("vscode"))
async function waitForEvent(eventHandler) {
  return new Promise((resolve) => {
    let disposable = eventHandler((eventData) => {
      disposable.dispose(), resolve(eventData)
    })
  })
}
var cM = "augment.oauth-state",
  hft = ".augmentcode.com",
  N0e = 10,
  uM = class {
    constructor(t, r, n, i, s) {
      this._context = t
      this._config = r
      this._apiServer = n
      this._authSession = i
      this._onboardingSessionEventReporter = s
      this.authRedirectURI = wo.Uri.from({
        scheme: wo.env.uriScheme,
        authority: this._context.extension.id,
        path: "/auth/result",
      })
    }
    _logger = z("OAuthFlow")
    _programmaticCancellation = new wo.EventEmitter()
    _previousLogin
    authRedirectURI
    doProgrammaticCancellation() {
      this._programmaticCancellation.fire("Cancelled by user")
    }
    async startFlow(t = true) {
      try {
        this._programmaticCancellation.fire("Cancelled due to new sign in"),
          await Promise.allSettled([this._previousLogin]),
          this._logger.info("Creating new session...")
        let r
        t
          ? (r = await this.loginWithProgress())
          : (r = await this.loginWithoutProgress()),
          this._logger.info(`Created session ${r.tenantURL}`),
          this._onboardingSessionEventReporter.reportEvent("signed-in")
      } catch (r) {
        throw (wo.window.showErrorMessage(`Sign in failed. ${getErrorMessage(r)}`), r)
      }
    }
    async createOAuthState() {
      let t = P0e((0, jy.randomBytes)(32)),
        r = P0e(gft(Buffer.from(t))),
        n = (0, jy.randomUUID)(),
        i = {
          codeVerifier: t,
          codeChallenge: r,
          state: n,
          creationTime: new Date().getTime(),
        }
      return await this._context.secrets.store(cM, JSON.stringify(i)), i
    }
    async getOAuthState() {
      let t = await this._context.secrets.get(cM)
      if (t) {
        let r = JSON.parse(t)
        if (new Date().getTime() - r.creationTime < N0e * 60 * 1e3) return r
      }
      return null
    }
    async removeOAuthState() {
      ;(await this._context.secrets.get(cM)) &&
        (await this._context.secrets.delete(cM))
    }
    async loginWithoutProgress() {
      let t = new wo.CancellationTokenSource()
      return this.login(t.token)
    }
    async loginWithProgress() {
      let t = {
          location: wo.ProgressLocation.Notification,
          title: "Signing in...",
          cancellable: true,
        },
        r = (n, i) => (
          (this._previousLogin = this.login(i)), this._previousLogin
        )
      return wo.window.withProgress(t, r)
    }
    async login(t) {
      if (!this._config.config.oauth.url)
        throw new Error("No OAuth URL defined.")
      let r = [
        this.waitForSessionChange(),
        new Promise((n, i) => setTimeout(() => i("Timed out"), N0e * 60 * 1e3)),
        this.waitForProgrammaticCancellation(),
        this.waitForCancellation(t, "User cancelled"),
      ]
      try {
        let n = await this.createOAuthState()
        return await this.openBrowser(n), await Promise.race(r)
      } finally {
        await this.removeOAuthState()
      }
    }
    async openBrowser(t) {
      let r = aM.join(" "),
        n = new URLSearchParams({
          response_type: "code",
          code_challenge: t.codeChallenge,
          code_challenge_method: "S256",
          client_id: this._config.config.oauth.clientID || "",
          redirect_uri: this.authRedirectURI.toString(),
          state: t.state,
          scope: r,
          prompt: "login",
        }),
        i = new URL(
          `/authorize?${n.toString()}`,
          this._config.config.oauth.url,
        ),
        s = wo.Uri.parse(i.toString())
      await wo.env.openExternal(s)
    }
    async waitForSessionChange() {
      let t = await waitForEvent(this._authSession.onDidChangeSession)
      if (!t) throw new Error("No session")
      return t
    }
    async waitForProgrammaticCancellation() {
      let t = await waitForEvent(this._programmaticCancellation.event)
      throw new Error(t)
    }
    async waitForCancellation(t, r) {
      throw (await waitForEvent(t.onCancellationRequested), new Error(r))
    }
    async processAuthRedirect(t) {
      let r = new URLSearchParams(t.query),
        n = r.get("state")
      if (!n) throw new Error("No state")
      let i = await this.getOAuthState()
      if (!i) throw new Error("No OAuth state found")
      if ((await this.removeOAuthState(), i.state !== n))
        throw new Error("Unknown state")
      let s = r.get("error")
      if (s) {
        let l = [`(${s})`],
          c = r.get("error_description")
        throw (
          (c && l.push(c), new Error(`OAuth request failed: ${l.join(" ")}`))
        )
      }
      let o = r.get("code")
      if (!o) throw new Error("No code")
      let a = r.get("tenant_url")
      if (a) {
        if (!new URL(a).hostname.endsWith(hft))
          throw new Error("OAuth request failed: invalid OAuth tenant URL")
      } else throw new Error("No tenant URL")
      try {
        let l = await this._apiServer.getAccessToken(
          this.authRedirectURI.toString(),
          a,
          i.codeVerifier,
          o,
        )
        await this._authSession.saveSession(l, a)
      } catch (l) {
        throw (
          (this._logger.error(`Failed to get and save access token: ${getErrorMessage(l)}`),
          new Error(
            `If you have a firewall, please add "${a}" to your allowlist.`,
          ))
        )
      }
    }
    async handleAuthURI(t) {
      try {
        await this.processAuthRedirect(t)
      } catch (r) {
        this._logger.warn("Failed to process auth request:", r),
          this._programmaticCancellation.fire(getErrorMessage(r))
      }
    }
  }
function P0e(e) {
  return e
    .toString("base64")
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=/g, "")
}
function gft(e) {
  return (0, jy.createHash)("sha256").update(e).digest()
}
var fye = q(V0e()),
  DG = q($0e()),
  rv = q(require("path")),
  gi = q(require("vscode")),
  hye = require("vscode")
var Xh = q(require("vscode"))
var X0e = q(require("crypto")),
  fs = q(require("fs")),
  fn = q(require("fs/promises")),
  eye = q(require("os")),
  pM = q(require("vscode"))
var Pn = q(require("path")),
  xG = q(require("vscode"))
var ix = Pn.posix.sep,
  Fft = new RegExp("/\\/g")
function af(e) {
  return Pn.isAbsolute(e)
}
function Qft(e) {
  return Pn.sep === "\\" ? e.replace(Fft, ix) : e
}
function Y0e(e) {
  return Qft(e)
}
function getWorkspaceFolder(uri) {
  return uri.with({ path: Pn.dirname(uri.fsPath) })
}
function K0e(e) {
  return Pn.basename(e)
}
function Ha(e) {
  let t = Pn.dirname(e)
  return t === "." ? "" : Nft(t)
}
function Nft(e) {
  return e.endsWith(ix) ? e : e + ix
}
function Zy(e) {
  for (;;) {
    if (e === Pn.sep || e === ix || (!e.endsWith(ix) && !e.endsWith(Pn.sep)))
      return e
    e = e.slice(0, -1)
  }
}
function ql(e, t) {
  let r = typeof e == "string" ? e : e.fsPath,
    n = typeof t == "string" ? t : t.fsPath
  return Pn.relative(r, n)
}
function lf(e, t) {
  let r = ql(e, t)
  return r === "." ? "" : r.length > 0 && !r.endsWith(Pn.sep) ? r + Pn.sep : r
}
function Zh(e, t) {
  let r = ql(e, t)
  if (
    !(
      r === ".." ||
      r.startsWith(".." + Pn.sep) ||
      r.startsWith(".." + Pn.posix.sep)
    )
  )
    return r
}
function Qs(e, t) {
  return Zh(e, t) !== undefined
}
function Xy(e, t) {
  let r = ql(e, t)
  return r === "" || r === "." || r === "." + Pn.sep || r === "." + Pn.posix.sep
}
function wG(e) {
  if (Pn.isAbsolute(e))
    throw new Error(`splitPath: ${e} must be a relative path`)
  let t = e,
    r = new Array()
  for (let n = 0; t.length > 0; n++) {
    if (n > 1e4) throw new Error(`Too-deep or malformed path name ${e}`)
    let i = Pn.basename(t)
    i !== "." && r.push(i)
    let s = Ha(t)
    if (s === t || s === ".") break
    t = s
  }
  return r.reverse()
}
async function hM(e, t, r) {
  let n = typeof e == "string" ? xG.Uri.file(e) : e
  for (;;) {
    try {
      let s = xG.Uri.joinPath(n, t),
        o = await ev(s.fsPath)
      if (r === undefined || o.type === r) return n
    } catch {}
    let i = Pn.dirname(n.fsPath)
    if (Pn.relative(i, n.fsPath).length === 0) return
    n = n.with({ path: i })
  }
}
var Pft = Object.freeze({ git: { name: ".git", type: "Directory" } })
async function ox(e) {
  for (let [t, r] of Object.entries(Pft)) {
    let n = await hM(e, r.name, r.type)
    if (n !== undefined) return { root: n, toolName: t }
  }
}
var j0e = require("child_process"),
  Z0e = require("util")
var J0e = z("CommandUtils"),
  Lft = (0, Z0e.promisify)(j0e.exec),
  Uft = 5e3
async function So(e, t = {}) {
  try {
    let { stdout: r, stderr: n } = await Lft(e, { timeout: Uft, ...t })
    return n && J0e.debug("stderr:" + n?.toString()), r?.toString()
  } catch (r) {
    J0e.debug(
      `exec error [${r.code}] [${r.signal}] [${r.message}] [${r.stackTrace}]`,
    )
  }
}
var gM = class {
  constructor(t, r = So) {
    this.root = t
    this.commandExecutor = r
  }
  async version() {
    return await this.commandExecutor("git --version")
  }
  async diff(t) {
    let r = ["git", "diff"]
    t.nameStatus && r.push("--name-status"),
      t.hash1 && r.push(t.hash1),
      t.hash2 && r.push(t.hash2),
      t.relPath && (r.push("--"), r.push(t.relPath))
    let n = r.join(" ")
    return await this.commandExecutor(n, { cwd: this.root.fsPath })
  }
  async lsFiles(t) {
    let r = ["git", "ls-files"]
    t.others && r.push("--others"),
      t.excludeStandard && r.push("--exclude-standard"),
      t.relPath && (r.push("--"), r.push(t.relPath))
    let n = r.join(" ")
    return await this.commandExecutor(n, { cwd: this.root.fsPath })
  }
  async show(t) {
    let r = ["git", "show"]
    t.nameStatus && r.push("--name-status"),
      t.oneLine && r.push("--oneline"),
      t.object && r.push(`"${t.object}"`)
    let n = r.join(" ")
    return await this.commandExecutor(n, { cwd: this.root.fsPath })
  }
  async symbolicRef(t) {
    let r = ["git", "symbolic-ref"]
    t.name && r.push(t.name)
    let n = r.join(" ")
    return await this.commandExecutor(n, { cwd: this.root.fsPath })
  }
  async log(t) {
    let r = ["git", "log"]
    t.commit1 && r.push(t.commit1),
      t.commit2 && r.push(t.commit2),
      t.noMerges && r.push("--no-merges"),
      t.format && r.push(`--format="${t.format}"`),
      t.not && r.push(`--not "${t.not}"`)
    let n = r.join(" ")
    return await this.commandExecutor(n, { cwd: this.root.fsPath })
  }
}
function tye(e) {
  return e.isFile() ? "File" : e.isDirectory() ? "Directory" : "Other"
}
function Oft(e) {
  return e.isFile() ? "File" : e.isDirectory() ? "Directory" : "Other"
}
function convertFileStats(stats) {
  return { size: stats.size, type: Oft(stats), mtime: Math.floor(stats.mtimeMs) }
}
async function ev(e) {
  let t = await fn.lstat(e)
  return convertFileStats(t)
}
async function nye(e) {
  try {
    return await fn.access(e), true
  } catch {
    return false
  }
}
function fileExists(filePath) {
  try {
    return getFileStats(filePath).type === "File"
  } catch {
    return false
  }
}
function mM(e) {
  try {
    return getFileStats(e).type === "Directory"
  } catch {
    return false
  }
}
async function Vl(e) {
  try {
    return (await fn.stat(e)).isDirectory()
  } catch {
    return false
  }
}
function getFileStats(filePath) {
  let stats = fs.lstatSync(filePath)
  return convertFileStats(stats)
}
async function ax(e) {
  let t = [],
    r = await fn.readdir(e, { withFileTypes: true })
  for (let n of r) t.push([n.name, tye(n)])
  return t
}
function hm(e) {
  let t = [],
    r = fs.readdirSync(e, { withFileTypes: true })
  for (let n of r) t.push([n.name, tye(n)])
  return t
}
async function Hl(e) {
  await fn.mkdir(e, { recursive: true })
}
async function IG(e, t) {
  await fn.rename(e, t)
}
async function AM(e) {
  return await fn.readFile(e)
}
async function iye(e, t) {
  let r = `${e}.${X0e.randomBytes(8).toString("hex")}.tmp`
  try {
    await fn.writeFile(r, t), await fn.rename(r, e)
  } catch (n) {
    throw (await fn.unlink(r), n)
  }
}
async function readTextFile(e) {
  return await fn.readFile(e, { encoding: "utf8" })
}
async function oa(e, t) {
  return await fn.writeFile(e, t, { encoding: "utf8" })
}
function sye(e, t) {
  return fs.writeFileSync(e, t, { encoding: "utf8" })
}
async function oye(e) {
  return await fn.unlink(e)
}
async function yM(e) {
  if (!(await Vl(e))) return
  let t = await fn.readdir(e)
  for (let r of t) {
    let n = joinPaths(e, r)
    ;(await fn.stat(n)).isDirectory() ? await yM(n) : await fn.unlink(n)
  }
  await fn.rmdir(e)
}
async function aye(e) {
  let t = joinPaths(eye.tmpdir(), e)
  return await fn.mkdtemp(t)
}
async function lx() {
  let e = vM()
  if (e) {
    try {
      let t = await ox(e)
      if (t) return t.root.fsPath
    } catch (t) {
      console.error("Error finding VCS:", t)
    }
    try {
      let t = await So("git rev-parse --show-toplevel", { cwd: e })
      if (t) return t.trim()
    } catch (t) {
      console.error("Error executing git command:", t)
    }
  }
}
function vM() {
  if (pM.workspace.workspaceFolders && pM.workspace.workspaceFolders.length > 0)
    return pM.workspace.workspaceFolders[0].uri.fsPath
}
function setVSCodeContext(contextKey, contextValue) {
  Xh.commands.executeCommand("setContext", contextKey, contextValue)
}
var CM = class e extends DisposableContainer {
  constructor(r) {
    super()
    this._extensionContext = r
  }
  static storageSubDir = "augment-global-state"
  _fileStorageChangeEmitters = new Map()
  update(r, n) {
    return this._extensionContext.globalState.update(r, n)
  }
  get(r) {
    return this._extensionContext.globalState.get(r)
  }
  async save(r, n, i) {
    await this._ensureStorageUriExists(i)
    let s = this._getFileUri(r, i)
    await oa(s.fsPath, JSON.stringify(n))
    let o = this._fileStorageChangeEmitters.get(r)
    o && o.fire({ key: r, value: n })
  }
  onDidChangeFileStorage(r, n) {
    if (!this._fileStorageChangeEmitters.has(r)) {
      let s = new Xh.EventEmitter()
      this.addDisposable(s), this._fileStorageChangeEmitters.set(r, s)
    }
    return this._fileStorageChangeEmitters.get(r).event(n)
  }
  dispose() {
    super.dispose(), this._fileStorageChangeEmitters.clear()
  }
  async load(r, n) {
    await this._ensureStorageUriExists(n)
    let i = this._getFileUri(r, n)
    try {
      let s = await readTextFile(i.fsPath)
      return JSON.parse(s)
    } catch {
      return
    }
  }
  async _ensureStorageUriExists(r) {
    let n = this._getStorageUri(r)
    ;(await Vl(n.fsPath)) || (await Hl(n.fsPath))
  }
  _getStorageUri(r) {
    return r?.uniquePerWorkspace && this._extensionContext.storageUri
      ? Xh.Uri.joinPath(this._extensionContext.storageUri, e.storageSubDir)
      : Xh.Uri.joinPath(
          this._extensionContext.globalStorageUri,
          e.storageSubDir,
        )
  }
  _getFileUri(r, n) {
    return Xh.Uri.joinPath(this._getStorageUri(n), `${r}.json`)
  }
}
var ux = q(require("vscode"))
var lye = require("util"),
  Hc = q(require("vscode")),
  cx = class {
    constructor(t) {
      this.doc = t
    }
    get eol() {
      return this.doc.eol
    }
    get lineCount() {
      return this.doc.lineCount
    }
    getText(t) {
      return this.doc.getText(t)
    }
    offsetAt(t) {
      return this.doc.offsetAt(t)
    }
    positionAt(t) {
      return this.doc.positionAt(t)
    }
    validateRange(t) {
      return this.doc.validateRange(t)
    }
    validatePosition(t) {
      return this.doc.validatePosition(t)
    }
    getWordRangeAtPosition(t, r) {
      return this.doc.getWordRangeAtPosition(t, r)
    }
    lineAt(t) {
      return typeof t == "number" ? this.doc.lineAt(t) : this.doc.lineAt(t)
    }
  },
  cye = "quiet-background-file",
  BG = false
function uye() {
  let e = Hc.workspace.registerTextDocumentContentProvider(cye, {
    async provideTextDocumentContent(t) {
      return Hc.workspace.fs
        .readFile(t.with({ scheme: "file" }))
        .then((r) => new lye.TextDecoder("utf-8").decode(r))
    },
  })
  return (
    (BG = true),
    new Hc.Disposable(() => {
      ;(BG = false), e.dispose()
    })
  )
}
async function Io(e) {
  let t
  if (
    (typeof e == "string" ? (t = Hc.Uri.file(e)) : (t = e),
    !BG || t.scheme !== "file")
  )
    return Hc.workspace.openTextDocument(t)
  let r = t.toString()
  for (let n of Hc.workspace.textDocuments)
    if (n.uri.scheme === t.scheme && n.uri.toString() === r) return new cx(n)
  return new Promise((n, i) => {
    let s = Hc.workspace.onDidOpenTextDocument((o) => {
      o.uri.scheme === t.scheme &&
        o.uri.toString() === r &&
        (s.dispose(), n(new cx(o)))
    })
    Hc.workspace.openTextDocument(t.with({ scheme: cye })).then(
      (o) => {
        s.dispose(), n(new cx(o))
      },
      (o) => {
        s.dispose(), i(o)
      },
    )
  })
}
function gm(e) {
  let t
  if (ux.window.activeTextEditor) {
    let r = ux.window.activeTextEditor.document.uri.fsPath
    t = e.getFolderRoot(r)
  }
  return (
    t === undefined &&
      ((t = e.getMostRecentlyChangedFolderRoot()),
      t === undefined && (t = ux.workspace.workspaceFolders?.[0]?.uri.fsPath)),
    t
  )
}
function $u(e, t) {
  if (af(e)) {
    let i = t.getFolderRoot(e)
    return i === undefined ? undefined : new QualifiedPathName(i, ql(i, e))
  }
  let r = t.findBestWorkspaceRootMatch(e)
  if (r) {
    let i = r.qualifiedPathName.rootPath
    return new QualifiedPathName(i, e)
  }
  let n = gm(t)
  if (n) return new QualifiedPathName(n, e)
}
async function pm(e, t) {
  let r = $u(e, t)?.absPath
  if (r !== undefined)
    try {
      return (await Io(r)).getText()
    } catch {
      return
    }
}
async function dye(e, t) {
  let r = $u(e, t)?.absPath
  if (r !== undefined)
    try {
      return (await ax(r)).map(([i, s]) => i)
    } catch {
      return
    }
}
async function bM(e, t) {
  let r = []
  for (let [n, i] of e.entries())
    if (i.length !== 0) {
      r.push(n)
      try {
        let s =
          (await pm(n, t))?.split(`
`) ?? []
        for (let o of i) {
          let a = o.range.start.line + 1,
            l = o.range.end.line + 1
          r.push(`L${a}-${l}: ${o.message}`)
          let c = Math.max(0, o.range.start.line - 3),
            u = Math.min(s.length - 1, o.range.end.line + 3)
          for (let f = c; f <= u; f++) {
            let p = s[f],
              g = f + 1
            r.push(`${String(g).padStart(6)}	${p}`)
          }
          r.push("")
        }
      } catch {
        for (let o of i) {
          let a = o.range.start.line + 1,
            l = o.range.end.line + 1
          r.push(`L${a}-${l}: ${o.message}`)
        }
      }
    }
  return r.join(`
`)
}
async function SM(e) {
  let t = e()
  return !t || !fileExists(t) ? undefined : (await readTextFile(t)).replace(/^\s+/, "")
}
async function gye(e, t) {
  if (!e) return
  let r = gi.Uri.joinPath(e, "Augment-Memories").fsPath,
    n = gi.Uri.joinPath(e, "Agent-Memories").fsPath
  if (fileExists(n))
    try {
      if (!fileExists(r)) {
        let i = await readTextFile(n)
        if (i.trim() === "") return
        await oa(r, i),
          await gi.workspace.fs.delete(gi.Uri.file(n)),
          t.info("Migrated memories from Agent-Memories to Augment-Memories")
      }
    } catch (i) {
      t.error("Error during memories migration:", i)
    }
}
var eg = class {
    static introduction() {
      return `
Instructions for you:
- Repeat the following markdown without the codeblock
\`\`\`
# \u{1F44B} Meet Auggie

I'm your AI coding assistant. I excel at understanding large, complex codebases but I am happy to chip in on codebases of all sizes.
\`\`\`
`
    }
    static gitConfigured() {
      return "\nInstructions for you:\n- Repeat the following markdown without the codeblock\n```\n## Who are you?\n\nMind if I fetch some information about you from your git configuration:\n```\n- Run `git config user.name` and `git config user.email`\n- Repeat the following text in the codeblock\n```\nHey, {name}, since I am an LLM and I don't have a real memory (sad) I'll be using `\u{1F4E6} Augment Memories`\n```\n        "
    }
    static memories() {
      return `
Instructions for you:
- Repeat the following markdown without the codeblock
\`\`\`
## How I work

* **Augment Memories:** Project-specific memories
  * New folder = clean slate
  * I learn from my mistakes when you correct me
  * You can ask me to remember things (e.g. "commit to memory...")

* **Native Integrations:** Configure integrations like GitHub + Linear with 1-click over in [Settings](command:vscode-augment.showSettingsPanel)
\`\`\`
        `
    }
  },
  xM = class {
    constructor(t, r) {
      this.shellTool = t
      this.workspaceManager = r
    }
    timeoutMsec = 1e3
    async getOnboardingInstructions() {
      return (
        `System instructions (don't mention them to user):

Basic context:
- Assistant (you) is Augment, a coding agent that I (user) use for the first time
- Assistant (you) is tasked with welcoming and onboarding me to the agent
- Assistant (you) always keeps messages friendly, warm, and welcoming. And nice!

Complete the following instructions.
` + (await this._getOnboardingInstructions())
      )
    }
    async _getOnboardingInstructions() {
      try {
        if (gm(this.workspaceManager) === undefined)
          throw new Error("Cannot determine current working directory")
        let [r, n] = await this._getUserNameAndEmail()
        return r === undefined || n === undefined
          ? eg.introduction() + eg.memories()
          : eg.introduction() + eg.gitConfigured() + eg.memories()
      } catch {
        return eg.introduction()
      }
    }
    async _isInsideGitRepo() {
      return (
        (
          await this.shellTool.call(
            { command: "git rev-parse --is-inside-work-tree" },
            [],
            AbortSignal.timeout(this.timeoutMsec),
          )
        ).text.replace(
          `
`,
          "",
        ) === "true"
      )
    }
    async _getUserNameAndEmail() {
      let t = await this.shellTool.call(
          { command: "git config user.name" },
          [],
          AbortSignal.timeout(this.timeoutMsec),
        ),
        r = await this.shellTool.call(
          { command: "git config user.email" },
          [],
          AbortSignal.timeout(this.timeoutMsec),
        )
      return t.isError || r.isError
        ? [undefined, undefined]
        : [
            t.text.replace(
              `
`,
              "",
            ),
            r.text.replace(
              `
`,
              "",
            ),
          ]
    }
  },
  Vft = String.raw`
                     __  __                           _
                    |  \/  |                         (_)
                    | \  / | ___ _ __ ___   ___  _ __ _  ___  ___
                    | |\/| |/ _ \ '_ ' _ \ / _ \| '__| |/ _ \/ __|
                    | |  | |  __/ | | | | | (_) | |  | |  __/\__ \
                    |_|  |_|\___|_| |_| |_|\___/|_|  |_|\___||___/

 .+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.
( Memories help me remember useful details for future interactions.               )
 )                                                                               (
( During Agent sessions, I'll try to create useful Memories automatically.        )
 )Memories can be about your codebase, technologies or your personal preferences.(
(                                                                                 )
 )Your Memories belong to you and are stored locally at the bottom of this file; (
( in the future, we may give you an option to share your memories with others.    )
 )                                                                               (
( NOTE: Memories will be compressed when this file grows too large.               )
 )For personal Memories: consider putting them in User Guidelines (via '@' menu) (
( For repository-level Memories: consider using '.augment-guidelines' file        )
 )Neither will be compressed.                                                    (
(                                                                                 )
 )Happy Coding!                                                                  (
(                                                                                 )
 "+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"+.+"
                  ()
                O
              o
{AUGGIE_LOGO}

↓↓↓ MEMORIES START HERE ↓↓↓`,
  Hft = [
    String.raw`
      .dKWMMMMMMMMMMMMMMWd                  dWMMMMMMMMMMMMMMWKd.
     :WMMW0OOOOOOOOOOOOOk:                  ckkkkkkkkkkkkkkKMMMW;
     OMMMl                                                  oMMMk
     OMMM:                                                  cMMMk
     OMMM:                                                  cMMMk
     OMMM:                                                  cMMMk
     OMMM:          .;cc,                   .;c:'           cMMMk
     OMMM:         dWMMMMN;                dMMMMMN,         :MMMO
    :WMMX.         KMMMMMMo                KMMMMMMo         .XMMN;
dOKNMW0o.          .dOKKkc                 .d0KKk:           .o0WMNKOo
:dxOWMNk'                                                    ,kNMWOxd:
    .NMMW.           .oxc                   cxo.            'WMMX.
     OMMM:           .OMMNo'             ,oXMWO.            cMMMk
     OMMM:             'xWMMNOdl::;::ldONMMNx'              cMMMk
     OMMM:                ,lx0XNWMMMWNX0xc,                 cMMMk
     OMMM:                       ...                        cMMMk
     OMMM:                                                  cMMMk
     kMMMx.                                                .xMMMk
     'KMMMWNNNNNNNNNNNNNXd                  dXNNNNNNNNNNNNNWMMMK.
       ;x0KKKKKKKKKKKKKK0;                  ;0KKKKKKKKKKKKKK0x;
`,
    `
      .dKWMMMMMMMMMMMMMMWd                  dWMMMMMMMMMMMMMMWKd.
     :WMMW0OOOOOOOOOOOOOk:                  ckkkkkkkkkkkkkkKMMMW;
     OMMMl                                                  oMMMk
     OMMM:                                                  cMMMk
     OMMM:                                                  cMMMk
     OMMM:                                                  cMMMk
     OMMM:          .;cc,                     ,cc;.         cMMMk
     OMMM:         dWMMMMN;                 '0MWWMNo        :MMMO
    :WMMX.         KMMMMMMo               .dWM0,.dWMK,      .XMMN;
dOKNMW0o.          .dOKKkc                ;kd;    .okx.      .o0WMNKOo
:dxOWMNk'                                                    ,kNMWOxd:
    .NMMW.           .oxc                   cxo.            'WMMX.
     OMMM:           .OMMNo'             ,oXMWO.            cMMMk
     OMMM:             'xWMMNOdl::;::ldONMMNx'              cMMMk
     OMMM:                ,lx0XNWMMMWNX0xc,                 cMMMk
     OMMM:                       ...                        cMMMk
     OMMM:                                                  cMMMk
     kMMMx.                                                .xMMMk
     'KMMMWNNNNNNNNNNNNNXd                  dXNNNNNNNNNNNNNWMMMK.
       ;x0KKKKKKKKKKKKKK0;                  ;0KKKKKKKKKKKKKK0x;
`,
    `
      .dKWMMMMMMMMMMMMMMWd                  dWMMMMMMMMMMMMMMWKd.
     :WMMW0OOOOOOOOOOOOOk:                  ckkkkkkkkkkkkkkKMMMW;
     OMMMl                                                  oMMMk
     OMMM:                                                  cMMMk
     OMMM:                                                  cMMMk
     OMMM:                                                  cMMMk
     OMMM:          .;cc,                     ,cc;.         cMMMk
     OMMM:         oWMWMM0'                 '0MWWMNo        :MMMO
    :WMMX.       ,XMWx.,0MWd.             .xWM0,.dWMK,      .XMMN;
dOKNMW0o.        dkl.    ;dkc             ;kd;    .okx.      .o0WMNKOo
:dxOWMNk'                                                    ,kNMWOxd:
    .NMMW.           .oxc                   cxo.            'WMMX.
     OMMM:           .OMMNo'             ,oXMWO.            cMMMk
     OMMM:             'xWMMNOdl::;::ldONMMNx'              cMMMk
     OMMM:                ,lx0XNWMMMWNX0xc,                 cMMMk
     OMMM:                       ...                        cMMMk
     OMMM:                                                  cMMMk
     kMMMx.                                                .xMMMk
     'KMMMWNNNNNNNNNNNNNXd                  dXNNNNNNNNNNNNNWMMMK.
       ;x0KKKKKKKKKKKKKK0;                  ;0KKKKKKKKKKKKKK0x;
`,
  ],
  Wft = Hft.map((e) => Vft.replace("{AUGGIE_LOGO}", e)),
  Gft = [
    String.raw`
                     __  __                           _
                    |  \/  |                         (_)
                    | \  / | ___ _ __ ___   ___  _ __ _  ___  ___
                    | |\/| |/ _ \ '_ ' _ \ / _ \| '__| |/ _ \/ __|
                    | |  | |  __/ | | | | | (_) | |  | |  __/\__ \
                    |_|  |_|\___|_| |_| |_|\___/|_|  |_|\___||___/

 __________________________________________________________________________________
/\                                                                                 \
\_| NOTE: Memories will be compressed when this file grows too large.              |
  | For personal Memories: consider putting them in User Guidelines (via '@' menu) |
  | For repository-level Memories: consider using '.augment-guidelines' file       |
  | Neither will be compressed.                                                    |
  |   _____________________________________________________________________________|_
   \_/_______________________________________________________________________________/

↓↓↓ MEMORIES START HERE ↓↓↓`,
  ],
  RG,
  pye = gi.window.createTextEditorDecorationType({
    isWholeLine: true,
    before: { contentText: "", fontWeight: "bold" },
  })
function mye() {
  return pye
}
function TG(e) {
  let t = e[0].split(`
`).length
  if (
    !e.every(
      (r) =>
        r.split(`
`).length === t,
    )
  )
    throw new Error("All animation frames must have the same number of lines")
  return t
}
async function Aye(e, t, r) {
  let n = t()
  if (!n || e?.document.uri.fsPath !== gi.Uri.file(n).fsPath) return
  let i = r.get("memoriesFileOpenCount") ?? 0
  await r.update("memoriesFileOpenCount", i + 1)
}
async function QG(e, t, r) {
  let n = yye(r),
    i = t()
  if (!i || e?.document.uri.fsPath !== gi.Uri.file(i).fsPath) return
  RG !== undefined && clearInterval(RG)
  let s = e.document.getText().replace(/^\s+/, "")
  ;(s =
    `
`.repeat(TG(n)) + s),
    await e.edit((c) => {
      let u = e.document.lineAt(0),
        f = e.document.lineAt(e.document.lineCount - 1),
        p = new gi.Range(u.range.start, f.range.end)
      c.replace(p, s)
    }),
    await e.document.save()
  let o = 0,
    a = 1e3,
    l = (0, fye.default)(() => {
      let f = n[o]
        .split(
          `
`,
        )
        .map((p, g) => ({
          range: new gi.Range(g, 0, g, 1e4),
          renderOptions: { before: { contentText: p.replace(/ /g, "\xA0") } },
        }))
      e.setDecorations(pye, f), (o = (o + 1) % n.length)
    }, a)
  l(), (RG = setInterval(l, a))
}
function yye(e) {
  return (e.get("memoriesFileOpenCount") ?? 0) <= 3 ? Wft : Gft
}
function vye(e, t, r, n, i) {
  if (
    (i.forceMemorySnapshotUpdate(),
    e.document.uri.fsPath !== r() || !t || t.document !== e.document)
  )
    return
  let s = yye(n)
  if (
    !e.document.getText().startsWith(
      `
`.repeat(TG(s)),
    )
  )
    for (let o of e.contentChanges) o.range.start.line < TG(s) && QG(t, r, n)
}
var MIN_CODE_FILES_REQUIRED = 20,
  MG = class {
    constructor(t, r, n, i) {
      this.workspaceManager = t
      this.apiServer = r
      this.logger = n
      this.progressTracker = i
    }
    toolDefinitions = [
      {
        name: "ls",
        description: "Lists a content of a folder by a relative path to it.",
        input_schema_json: JSON.stringify({
          type: "object",
          properties: {
            folder: {
              type: "string",
              description:
                "Relative path to a folder. Can be either '.' or './*'",
            },
          },
          required: ["folder"],
        }),
        tool_safety: ToolSafetyLevel.Safe,
      },
      {
        name: "read-file",
        description: "Read a file.",
        input_schema_json: JSON.stringify({
          type: "object",
          properties: {
            file_path: {
              type: "string",
              description: "The path of the file to read.",
            },
          },
          required: ["file_path"],
        }),
        tool_safety: ToolSafetyLevel.Safe,
      },
      {
        name: "complete",
        description:
          "Tool which should be called at the very end to return final response.",
        input_schema_json: JSON.stringify({
          type: "object",
          properties: {
            response: {
              type: "string",
              description: "Final response to the user.",
            },
          },
          required: ["response"],
        }),
        tool_safety: ToolSafetyLevel.Safe,
      },
      {
        name: "codebase-retrieval",
        description:
          "Use this tool to request information from the codebase. It will return relevant snippets for the requested information.",
        input_schema_json: JSON.stringify({
          type: "object",
          properties: {
            information_request: {
              type: "string",
              description: "A description of the information you need.",
            },
          },
          required: ["information_request"],
        }),
        tool_safety: ToolSafetyLevel.Safe,
      },
    ]
    getToolDefinitions() {
      return this.toolDefinitions
    }
    async runTool(t, r) {
      switch (t) {
        case "codebase-retrieval": {
          let n = this.apiServer.createRequestId(),
            i = r.information_request
          try {
            let s = await this.apiServer.agentCodebaseRetrieval(
              n,
              i,
              this.workspaceManager.getContext().blobs,
              [],
              2e4,
            )
            return cr(s.formattedRetrieval, n)
          } catch (s) {
            return (
              this.logger.error(
                `Failed to retrieve codebase information: ${s}`,
              ),
              at("Failed to retrieve codebase information.")
            )
          }
        }
        case "ls": {
          let n = r.folder,
            i = $u(n, this.workspaceManager)?.absPath
          if (i === undefined) return at(`Failed to list directory: ${n}`)
          if (!(await Vl(i))) return at(`Directory does not exist: ${n}`)
          try {
            let o = (await ax(i)).map(([a, l]) => a)
            return cr(
              o.join(`
`),
            )
          } catch {
            return (
              this.logger.error(`Failed to list directory: ${n}`),
              at(`Failed to list directory: ${n}`)
            )
          }
        }
        case "read-file": {
          let n = r.file_path,
            i = $u(n, this.workspaceManager)?.absPath
          if (i === undefined) return at(`Failed to read file: ${n}`)
          if (!fileExists(i)) return at(`File does not exist: ${n}`)
          let s = await readTextFile(i)
          return s === undefined
            ? (this.logger.error(`Failed to read file: ${n}`),
              at(`Failed to read file: ${n}`))
            : cr(s)
        }
        default:
          return at(`Unknown tool: ${t}`)
      }
    }
  },
  FG = class e {
    constructor(t, r, n, i, s, o, a, l) {
      this.rootAbsPath = t
      this.apiServer = r
      this.workspaceManager = n
      this.featureFlagManager = i
      this.logger = s
      this.orientationConcurrencyLevel = o
      this.progressTracker = a
      this.trace = l
      if (
        ((this.localizationPrompt =
          this.featureFlagManager.currentFlags.memoriesParams.language_localization_prompt),
        !this.localizationPrompt)
      )
        throw (
          (this.trace.setFlag(TelemetryFlags.localizationPromptMissing),
          new Error("Localization prompt missing"))
        )
      if (
        ((this.detectLanguagesPrompt =
          this.featureFlagManager.currentFlags.memoriesParams.detect_languages_prompt),
        !this.detectLanguagesPrompt)
      )
        throw (
          (this.trace.setFlag(TelemetryFlags.detectLanguagesPromptMissing),
          new Error("Detect languages prompt missing"))
        )
      if (
        ((this.orientationCompressionPrompt =
          this.featureFlagManager.currentFlags.memoriesParams.orientation_compression_prompt),
        !this.orientationCompressionPrompt)
      )
        throw (
          (this.trace.setFlag(TelemetryFlags.orientationCompressionPromptMissing),
          new Error("Orientation compression prompt missing"))
        )
      if (
        ((this.orientationMaxLanguages =
          this.featureFlagManager.currentFlags.memoriesParams.orientation_max_languages),
        !this.orientationMaxLanguages)
      )
        throw (
          (this.trace.setFlag(TelemetryFlags.orientationMaxLanguagesMissing),
          new Error("Orientation max languages missing"))
        )
      if (
        ((this.buildTestQuery =
          this.featureFlagManager.currentFlags.memoriesParams.orientation_build_test_query),
        !this.buildTestQuery)
      )
        throw (
          (this.trace.setFlag(TelemetryFlags.orientationBuildTestQueryMissing),
          new Error("Build test prompt missing"))
        )
      ;(this.queries = [{ name: "build-test", template: this.buildTestQuery }]),
        (this.tools = new MG(n, r, this.logger, a))
    }
    localizationPrompt
    detectLanguagesPrompt
    orientationCompressionPrompt
    orientationMaxLanguages
    buildTestQuery
    tools
    queries
    static agentMdPattern = new RegExp(
      "<agent_md>(?:\\s*```(?:\\w+)?\\n?)?(.*?)(?:```\\s*)?</agent_md>",
      "s",
    )
    async appendToWorkspaceGuidelines(t) {
      let r = this.workspaceManager.getBestFolderRoot()
      if (!r)
        throw (
          (this.trace.setFlag(TelemetryFlags.noRootFolderFound),
          new Error("No root folder found"))
        )
      let n = rv.default.join(r, ".augment-guidelines"),
        i = ""
      try {
        fileExists(n) && (i = await readTextFile(n))
      } catch (l) {
        this.trace.setFlag(TelemetryFlags.failedToReadGuidelines),
          this.logger.error(`Failed to read existing guidelines: ${l}`)
      }
      let s = "",
        o = i.indexOf(ORIENTATION_RESULTS_START_MARKER),
        a = i.indexOf(ORIENTATION_RESULTS_END_MARKER)
      if (o !== -1 && a !== -1 && a > o) {
        let l = i.substring(0, o),
          c = i.substring(a + ORIENTATION_RESULTS_END_MARKER.length)
        ;(s =
          l +
          ORIENTATION_RESULTS_START_MARKER +
          `
` +
          t +
          `
` +
          ORIENTATION_RESULTS_END_MARKER +
          c),
          this.logger.debug(
            "Replacing existing orientation results between markers",
          )
      } else {
        let l =
          i.trim().length > 0
            ? `

`
            : ""
        ;(s =
          i.trim() +
          l +
          ORIENTATION_RESULTS_START_MARKER +
          `
` +
          t +
          `
` +
          ORIENTATION_RESULTS_END_MARKER),
          this.logger.debug("Appending new orientation results with markers")
      }
      try {
        await gi.workspace.fs.writeFile(gi.Uri.file(n), Buffer.from(s, "utf8")),
          this.logger.debug(`Successfully updated workspace guidelines at ${n}`)
      } catch (l) {
        throw (
          (this.trace.setFlag(TelemetryFlags.failedToWriteGuidelines),
          new Error(`Failed to write workspace guidelines: ${l}`))
        )
      }
    }
    async run() {
      let { languages: t, allFiles: r } =
        await this.getTopProgrammingLanguages()
      if (Object.keys(t).length === 0)
        throw new Error("No programming languages detected")
      this.progressTracker.set(10)
      let n = await this.localizeLanguages(r, t)
      this.progressTracker.set(25)
      let i = (await dye(".", this.workspaceManager))?.join(`
`)
      if (!i)
        throw (
          (this.trace.setFlag(TelemetryFlags.failedToListRootFolder),
          new Error("Failed to list root folder"))
        )
      this.progressTracker.set(30)
      let s = (0, DG.default)(this.orientationConcurrencyLevel),
        o = Object.keys(t),
        l = 60 / o.length / this.queries.length
      this.trace.setFlag(TelemetryFlags.agenticStarted)
      let c = o.map((v, C) =>
          s(async () => {
            this.logger.debug(`Processing language: ${v}`)
            let E = []
            for (let w of this.queries) {
              this.logger.debug(`Processing query: ${w.name}`)
              let B = w.template
                  .replace(/{language}/g, v)
                  .replace(/{rootFolderContent}/g, i)
                  .replace(
                    /{locationList}/g,
                    n[v].split(",").join(`
`),
                  ),
                T = await this.doAgenticTurn(B, l, C)
              E.push(T),
                this.logger.debug(
                  `Response language "${v}" and query "${w.name}": ${T}`,
                )
            }
            return E
          }),
        ),
        u = await Promise.all(c)
      this.trace.setFlag(TelemetryFlags.agenticEnded)
      let f = u.flat().join(`

`)
      this.trace.setStringStats(TelemetryFlags.agenticModelResponseStats, f),
        this.progressTracker.set(90)
      let p = this.apiServer.createRequestId()
      this.trace.setRequestId(TelemetryFlags.compressionRequestId, p)
      let g = await this.simpleLlmCall(
        this.orientationCompressionPrompt.replace(/{assembledKnowledge}/g, f),
        p,
      )
      this.trace.setStringStats(TelemetryFlags.compressionModelResponseStats, g)
      let m = g.match(e.agentMdPattern)
      if (!m)
        throw (
          (this.trace.setFlag(TelemetryFlags.compressionParsingFailed),
          new Error("Failed to parse compression response"))
        )
      let y = m[1].trim()
      this.logger.debug(`Compressed knowledge: ${y}`),
        this.progressTracker.set(95),
        this.trace.setFlag(TelemetryFlags.rememberStarted),
        await this.appendToWorkspaceGuidelines(y),
        this.trace.setFlag(TelemetryFlags.rememberEnded),
        this.progressTracker.set(100)
    }
    async doAgenticTurn(t, r, n) {
      let i = t,
        s = [],
        o = [],
        a = {
          request_message: i,
          response_text: "",
          request_id: this.apiServer.createRequestId(),
          request_nodes: [],
          response_nodes: [],
        },
        l,
        c = 25,
        u = c + 2,
        f = r / u,
        p = 0
      do {
        if ((this.trace.setNum(`agenticNumTurns_${n}`, p), p > c)) {
          if (p > u) throw new Error("Too many turns in agentic loop")
          s = [
            ...s,
            {
              id: 2,
              type: po.TEXT,
              text_node: {
                content:
                  "You did too many turns already. Call `complete` tool immediately.",
              },
            },
          ]
        }
        this.logger.debug(`Running agentic turn ${p}.`),
          this.progressTracker.inc(f)
        let g = this.apiServer.createRequestId(),
          m = await mp(i, g, o, this.tools.getToolDefinitions(), s, Fr.agent)
        for await (let y of m)
          if (y.nodes) {
            let v = y.nodes.filter(
              (C) => C.type === gc.TOOL_USE || C.type === gc.RAW_RESPONSE,
            )
            ;(a.response_nodes = a.response_nodes || []),
              a.response_nodes.push(...v)
          }
        if (
          ((l = a.response_nodes?.find((y) => y.type === gc.TOOL_USE)),
          l?.tool_use !== undefined)
        ) {
          let y = l.tool_use,
            v = y.tool_name,
            C = JSON.parse(y.input_json)
          if (
            (this.logger.debug(
              `Calling tool: ${v}. Args: ${JSON.stringify(C)}`,
            ),
            v === "complete")
          )
            return (
              this.logger.debug(`Agentic turn complete. Took ${p} turns.`),
              this.progressTracker.inc(f * (u - p - 1)),
              this.trace.setStringStats(
                `agenticModelResponseStats_${n}`,
                C.response,
              ),
              C.response
            )
          let E = await this.tools.runTool(y.tool_name, C)
          ;(s = [
            {
              id: 1,
              type: po.TOOL_RESULT,
              tool_result_node: {
                tool_use_id: y.tool_use_id,
                content: E.text,
                is_error: E.isError,
              },
            },
          ]),
            this.logger.debug(
              `Tool result: ${
                E.text.trim().split(`
`)[0]
              }...`,
            ),
            (i = ""),
            o.push(a),
            (a = {
              request_message: "",
              response_text: "",
              request_id: this.apiServer.createRequestId(),
              request_nodes: s,
              response_nodes: [],
            })
        }
        p++
      } while (l?.tool_use !== undefined)
      throw (
        (this.trace.setFlag(`agenticFailedToComplete_${n}`),
        new Error("Agent didn't call the complete tool."))
      )
    }
    async localizeLanguages(t, r) {
      let n = {},
        i = (0, DG.default)(this.orientationConcurrencyLevel),
        o = 15 / Object.keys(r).length
      this.trace.setFlag(TelemetryFlags.localizationStarted)
      let a = Object.entries(r).map(([c, u], f) =>
          i(async () => {
            this.logger.debug(`Localizing language: ${c} (index: ${f})`)
            let p = $ft(t, u)
            if (p.trim().length === 0)
              throw new Error(`Failed to render folder tree for ${c}`)
            let g = this.localizationPrompt
              .replace(/{programmingLanguage}/g, c)
              .replace(/{languageTree}/g, p)
            this.trace.setStringStats(`localizationPromptStats_${f}`, g)
            let m = this.apiServer.createRequestId()
            this.trace.setRequestId(`localizationRequestId_${f}`, m)
            let y = await this.simpleLlmCall(g, m)
            this.trace.setStringStats(`localizationResponseStats_${f}`, y)
            let v = y.match(/<locations>(.*?)<\/locations>/)
            if (!v)
              throw (
                (this.trace.setFlag(`localizationParsingFailed_${f}`),
                new Error(`Failed to extract locations from response: ${y}`))
              )
            return (
              this.progressTracker.inc(o),
              { language: c, locations: v[1].trim() }
            )
          }),
        ),
        l = await Promise.all(a)
      return (
        this.trace.setFlag(TelemetryFlags.localizationEnded),
        l.forEach(({ language: c, locations: u }, f) => {
          let p = u.split(",").length
          this.trace.setNum(`localizationNumLocations_${f}`, p), (n[c] = u)
        }),
        n
      )
    }
    async getTopProgrammingLanguages() {
      let t = new Set([
          "ad",
          "adown",
          "argdown",
          "argdn",
          "bicep",
          "c",
          "cpp",
          "cc",
          "cp",
          "cxx",
          "h",
          "hpp",
          "hxx",
          "cs",
          "ex",
          "elm",
          "erb",
          "rhtml",
          "gd",
          "godot",
          "tres",
          "tscn",
          "go",
          "haml",
          "hs",
          "hx",
          "html",
          "htm",
          "java",
          "js",
          "jsx",
          "kt",
          "ml",
          "mli",
          "mll",
          "mly",
          "php",
          "py",
          "r",
          "rb",
          "rs",
          "res",
          "resi",
          "sass",
          "scala",
          "styl",
          "swift",
          "tf",
          "tfvars",
          "ts",
          "tsx",
          "vue",
          "vala",
        ]),
        r = {},
        n = [],
        i = async (g) => {
          let m = await ax(g)
          if (m)
            for (let [y, v] of m) {
              if (y.startsWith(".")) continue
              let C = rv.default.join(g, y)
              if (v === "Directory") await i(C)
              else if (v === "File") {
                let E = rv.default.relative(this.rootAbsPath, C)
                n.push(E)
                let w = y.includes(".") ? y.split(".").pop().toLowerCase() : ""
                w && t.has(w) && (r[w] = (r[w] || 0) + 1)
              }
            }
        }
      await i(this.rootAbsPath),
        this.trace.setNum(TelemetryFlags.topLanguagesNumFiles, n.length)
      let s = Object.values(r).reduce((g, m) => g + m, 0)
      if ((this.trace.setNum(TelemetryFlags.topLanguagesNumCodeFiles, s), s < MIN_CODE_FILES_REQUIRED))
        throw Error("Not enough code files to run orientation")
      let o = Object.entries(r)
          .sort(([, g], [, m]) => m - g)
          .slice(0, 20)
          .map(([g, m]) => `${g}: ${m}`).join(`
`),
        a = this.apiServer.createRequestId()
      this.trace.setRequestId(TelemetryFlags.topLanguagesRequestId, a)
      let l = await this.simpleLlmCall(
        this.detectLanguagesPrompt.replace(/{fileExtensionsList}/g, o),
        a,
      )
      this.trace.setStringStats(TelemetryFlags.topLanguagesModelResponseStats, l),
        this.logger.debug(`Detected languages: "${l}"`)
      let c = JSON.parse(l.trim())
      this.trace.setNum(
        TelemetryFlags.topLanguagesNumDetectedLanguages,
        Object.keys(c).length,
      )
      let u = {}
      for (let [g, m] of Object.entries(c))
        (u[g] = m.reduce((y, v) => y + (r[v] || 0), 0)),
          this.logger.debug(`${g}: ${u[g]} files`)
      let f = Object.entries(u)
          .sort(([, g], [, m]) => m - g)
          .slice(0, this.orientationMaxLanguages)
          .map(([g]) => g),
        p = {}
      for (let g of f) p[g] = c[g]
      return (
        this.logger.debug(
          `Top ${this.orientationMaxLanguages} languages: ${JSON.stringify(p)}`,
        ),
        this.trace.setNum(
          TelemetryFlags.topLanguagesNumFinalLanguages,
          Object.keys(p).length,
        ),
        { languages: p, allFiles: n }
      )
    }
    async simpleLlmCall(t, r) {
      let n = await mp(t, r, [], [], [], Fr.orientation)
      for await (let i of n)
        if (i.nodes) {
          for (let s of i.nodes)
            if (s.type === gc.RAW_RESPONSE) return s.content
        }
      throw new Error("No response from model")
    }
  }
function Cye(e, t = "", r = true, n = "", i = 0, s = 3) {
  if (i > s) return ""
  let o = []
  if (n) {
    let c = e.isDirectory ? `${n}/` : n
    o.push(`${t}${r ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 "}${c}`)
  }
  let a = t + (r ? "    " : "\u2502   "),
    l = Array.from(e.children.entries()).sort(([c], [u]) => c.localeCompare(u))
  return (
    l.forEach(([c, u], f) => {
      let p = f === l.length - 1,
        g = Cye(u, a, p, c, i + 1, s)
      g && o.push(g)
    }),
    o.join(`
`)
  )
}
function $ft(e, t) {
  let r = e.filter((i) => {
    let s = i.split(".").pop()?.toLowerCase()
    return s && t.includes(s)
  })
  if (r.length === 0) return ""
  let n = { isDirectory: true, children: new Map() }
  for (let i of r) {
    let o = gi.workspace.asRelativePath(i).split(rv.default.sep),
      a = n
    for (let l = 0; l < o.length - 1; l++) {
      let c = o[l]
      a.children.has(c) ||
        a.children.set(c, { isDirectory: true, children: new Map() }),
        (a = a.children.get(c))
    }
  }
  return n.children.size === 0 ? "" : Cye(n)
}
var orientationState = { state: "idle" },
  orientationEventEmitter = new hye.EventEmitter(),
  onOrientationStateChanged = orientationEventEmitter.event
function notifyOrientationStateChanged() {
  orientationEventEmitter.fire(orientationState)
}
var ORIENTATION_RUN_COUNT_KEY = "orientation.runCount",
  ORIENTATION_RESULTS_START_MARKER = "[//]: # (AUGMENT-CODEBASE-ORIENTATION-RESULTS-START)",
  ORIENTATION_RESULTS_END_MARKER = "[//]: # (AUGMENT-CODEBASE-ORIENTATION-RESULTS-END)"
async function runAutomaticOrientation(apiServer, workspaceManager, featureFlagManager, agentCheckpointManager, workspaceStorage) {
  try {
    let runCount = workspaceStorage.get(ORIENTATION_RUN_COUNT_KEY) || 0
    if ((await workspaceStorage.update(ORIENTATION_RUN_COUNT_KEY, runCount + 1), runCount > 0)) return
    let rootFolder = workspaceManager.getBestFolderRoot()
    if (!rootFolder) throw Error("Root of the project is `undefined`.")
    let guidelinesPath = rv.default.join(rootFolder, ".augment-guidelines")
    if (fileExists(guidelinesPath)) {
      let guidelinesContent = await readTextFile(guidelinesPath)
      if (guidelinesContent && guidelinesContent.includes(ORIENTATION_RESULTS_START_MARKER)) return
    }
    await runAgentInitialOrientation(apiServer, workspaceManager, featureFlagManager, agentCheckpointManager, nh.automaticAfterIndexing)
  } catch {
    z("AutomaticOrientation").error("Error running automatic orientation.")
  }
}
async function runAgentInitialOrientation(apiServer, workspaceManager, featureFlagManager, agentCheckpointManager, orientationType) {
  if (orientationState.state === "in-progress") {
    gi.window.showInformationMessage(
      "Augment Agent orientation is already in progress",
    )
    return
  }
  let logger = z("InitialOrientation"),
    telemetryData = DB.create(orientationType)
  telemetryData.setFlag(TelemetryFlags.start)
  try {
    ;(orientationState = { state: "in-progress", progress: 0, lastRunTimestamp: Date.now() }),
      notifyOrientationStateChanged(),
      await performOrientation(apiServer, workspaceManager, featureFlagManager, agentCheckpointManager, logger, telemetryData),
      (orientationState = {
        state: "succeeded",
        progress: 100,
        lastRunTimestamp: Date.now(),
      }),
      notifyOrientationStateChanged()
  } catch (error) {
    telemetryData.setFlag(TelemetryFlags.exceptionThrown), logger.error(`Error in initial orientation: ${error}`)
    let errorMessage = "",
      stateType = "failed",
      numCodeFiles = telemetryData.getNum(TelemetryFlags.topLanguagesNumCodeFiles) ?? MIN_CODE_FILES_REQUIRED
    numCodeFiles === 0
      ? ((stateType = "aborted"), (errorMessage = "Code files were not found"))
      : numCodeFiles < MIN_CODE_FILES_REQUIRED
        ? ((stateType = "aborted"), (errorMessage = "Repository is too small"))
        : telemetryData.getFlag(TelemetryFlags.compressionParsingFailed)
          ? (errorMessage = "Error code #1002")
          : telemetryData.getFlag(TelemetryFlags.localizationStarted) &&
              !telemetryData.getFlag(TelemetryFlags.localizationEnded)
            ? (errorMessage = "Error code #1003")
            : telemetryData.getFlag(TelemetryFlags.agenticStarted) && !telemetryData.getFlag(TelemetryFlags.agenticEnded)
              ? (errorMessage = "Error code #1004")
              : telemetryData.getFlag(TelemetryFlags.rememberStarted) &&
                !telemetryData.getFlag(TelemetryFlags.rememberEnded) &&
                (errorMessage = "Error code #1005"),
      (orientationState = {
        state: stateType,
        progress: 0,
        lastRunTimestamp: Date.now(),
        errorMessage: errorMessage,
      }),
      notifyOrientationStateChanged()
  } finally {
    telemetryData.setFlag(TelemetryFlags.end),
      Mr().reportEvent({
        eventName: MemoryEventType.initialOrientation,
        conversationId: "",
        eventData: { initialOrientationData: telemetryData },
      })
  }
}
async function performOrientation(apiServer, workspaceManager, featureFlagManager, agentCheckpointManager, logger, telemetryData) {
  logger.debug("Starting initial orientation process.")
  let concurrencyLevel = featureFlagManager.currentFlags.memoriesParams?.orientation_concurrency_level
  if (!concurrencyLevel)
    throw (
      (telemetryData.setFlag(TelemetryFlags.concurrencyLevelMissing),
      Error("Failed to get concurrency level for initial orientation."))
    )
  if (!featureFlagManager.currentFlags.memoriesParams?.enable_initial_orientation)
    throw (
      (telemetryData.setFlag(TelemetryFlags.initialOrientationDisabled),
      Error("Initial orientation is not enabled."))
    )
  let createProgressTracker = (progress) => {
    let currentProgress = 0
    return {
      inc: (increment) => {
        orientationState.state !== "failed" &&
          ((currentProgress = Math.min(currentProgress + increment, 100)),
          progress.report({ increment: 0, message: `${Math.round(currentProgress)}%` }),
          (orientationState = {
            state: "in-progress",
            progress: Math.round(currentProgress),
            lastRunTimestamp: Date.now(),
          }),
          notifyOrientationStateChanged())
      },
      set: (value) => {
        value <= currentProgress ||
          ((value = Math.min(value, 100)),
          (currentProgress = value),
          progress.report({ increment: 0, message: `${Math.round(currentProgress)}%` }),
          (orientationState = {
            state: "in-progress",
            progress: Math.round(currentProgress),
            lastRunTimestamp: Date.now(),
          }),
          notifyOrientationStateChanged())
      },
      reset: () => {
        progress.report({ increment: 0, message: "0%" }),
          (currentProgress = 0),
          (orientationState = {
            state: "in-progress",
            progress: 0,
            lastRunTimestamp: Date.now(),
          }),
          notifyOrientationStateChanged()
      },
    }
  }
  await gi.window.withProgress(
    {
      location: gi.ProgressLocation.Window,
      title: "Augment Codebase Orientation",
    },
    async (progress, token) => {
      let progressTracker = createProgressTracker(progress)
      progressTracker.reset(), await executeOrientation(apiServer, workspaceManager, featureFlagManager, agentCheckpointManager, logger, concurrencyLevel, progressTracker, telemetryData)
    },
  )
}
async function executeOrientation(apiServer, workspaceManager, featureFlagManager, agentCheckpointManager, logger, concurrencyLevel, progressTracker, telemetryData) {
  progressTracker.set(1)
  try {
    let rootFolder = workspaceManager.getBestFolderRoot()
    if (!rootFolder)
      throw (telemetryData.setFlag(TelemetryFlags.noRootFolderFound), new Error("No root folder found"))
    logger.debug(`Root folder: ${rootFolder}.`), progressTracker.set(2), progressTracker.set(3)
    let orientationProcessor = new FG(rootFolder, apiServer, workspaceManager, featureFlagManager, logger, concurrencyLevel, progressTracker, telemetryData)
    progressTracker.set(5),
      await orientationProcessor.run(),
      progressTracker.set(100),
      gi.window.showInformationMessage(
        "Augment Agent completed orientation process. Workspace guidelines were updated!",
      )
  } catch (error) {
    if (concurrencyLevel > 1 && ApiError.isAPIErrorWithStatus(error, RequestStatus.resourceExhausted)) {
      telemetryData.setFlag(TelemetryFlags.retryWithLowerConcurrencyLevel),
        gi.window.showErrorMessage(
          "Augment agent orientation process failed: Rate limit exceeded. Retrying...",
        ),
        logger.error("Retrying initial orientation with concurrency level 1."),
        await new Promise((resolve) => setTimeout(resolve, 5e3)),
        progressTracker.reset(),
        await executeOrientation(apiServer, workspaceManager, featureFlagManager, agentCheckpointManager, logger, 1, progressTracker, telemetryData)
      return
    }
    throw error
  }
}
var xye = (e) => {
    let t = e.length - 1,
      r = 0
    for (; t >= 0; ) {
      let n = e[t]
      if (((r += JSON.stringify(n).length), r > 8e5)) break
      t--
    }
    return e.slice(t + 1)
  },
  wye = (e) => {
    let t = 266666.6666666667,
      r = [0],
      n = 0
    for (let s = 0; s < e.length; s++) {
      let o = e[s],
        a = JSON.stringify(o).length
      n + a > t && (r.push(s), (n = 0)), (n += a)
    }
    if (r.length < 4) return e
    let i = 2 * Math.floor((r.length - 2) / 2)
    return e.slice(r[i])
  }
function Kft(e) {
  return e.split(/\r?\n/)
}
function zft(e, t) {
  ;(e = e || ""), (t = t || "")
  let r = Kf(e, t),
    n = [],
    i = 1,
    s = 1,
    o = null
  for (let a of r) {
    let l = Kft(a.value),
      c =
        a.count ||
        (l.length > 0
          ? l.length -
            (a.value.endsWith(`
`)
              ? 0
              : 1)
          : 0)
    c !== 0 &&
      (a.added || a.removed
        ? (o
            ? a.removed
              ? (o.before_text += a.value)
              : a.added && (o.after_text += a.value)
            : (o = {
                before_line_start: i,
                before_text: a.removed ? a.value : "",
                after_line_start: s,
                after_text: a.added ? a.value : "",
              }),
          a.removed ? (i += c) : a.added && (s += c))
        : (o && (n.push(o), (o = null)), (i += c), (s += c)))
  }
  return o && n.push(o), n
}
function Jft(e, t, r) {
  let n = zft(e.originalCode, e.modifiedCode)
  return {
    path: e.filePath.absPath,
    before_blob_name: t,
    after_blob_name: r,
    edits: n,
  }
}
function jft(e, t, r) {
  return {
    edit_events: e.files
      .filter(
        (i) =>
          i.changesSummary.totalAddedLines > 0 ||
          i.changesSummary.totalRemovedLines > 0,
      )
      .map((i) => {
        let s = i.changeDocument,
          o = t ? t(s) : { beforeBlobName: undefined, afterBlobName: undefined }
        return Jft(s, o.beforeBlobName, o.afterBlobName)
      }),
    source: r,
  }
}
function Sye(e, t, r, n) {
  return {
    id: e % 2 ** 31,
    type: po.EDIT_EVENTS,
    edit_events_node: jft(t, r, n),
  }
}
var KCe = q(require("vscode"))
var NG = class {
  _status = "running"
  _buffer = new Array()
  _triggerYield
  _resolveFn
  _rejectFn
  constructor(t) {
    ;(this._triggerYield = new Promise((r, n) => {
      ;(this._resolveFn = r), (this._rejectFn = n)
    })),
      this.collectBaseGenerator(t)
  }
  cancel = () => {
    this.isFinished || this._reject(new Error("Cancelled"))
  }
  get isFinished() {
    return this._status !== "running"
  }
  get hasErrored() {
    return this._status === "errored"
  }
  collectBaseGenerator = async (t) => {
    try {
      this._resolve(),
        (this._triggerYield = new Promise((r, n) => {
          ;(this._resolveFn = r), (this._rejectFn = n)
        }))
      for await (let r of t)
        this._buffer.push(r),
          this._resolve(),
          (this._triggerYield = new Promise((n, i) => {
            ;(this._resolveFn = n), (this._rejectFn = i)
          }))
      ;(this._status = "success"), this._resolve()
    } catch (r) {
      this._reject(r)
    }
  }
  _reject = (t) => {
    ;(this._status = "errored"), this._rejectFn(t)
  }
  _resolve = () => {
    this._resolveFn()
  }
  async *copy() {
    let t = 0
    for (;;) {
      if (t < this._buffer.length) {
        yield this._buffer[t], (t += 1)
        continue
      }
      if (
        (await this._triggerYield, t === this._buffer.length && this.isFinished)
      )
        return
    }
  }
}
var mm = NG
var Ni = q(require("vscode"))
var fx = q(require("vscode"))
function Iye(e, t, r = false, n = true) {
  let i = new fx.Position(e.start.line, 0),
    s = e.end.line
  n && e.end.character === 0 && s > e.start.line && (s -= 1)
  let o = t.lineAt(s).range.end
  return (
    r &&
      t.lineCount > e.end.line + 1 &&
      (o = new fx.Position(e.end.line + 1, 0)),
    new fx.Range(i, o)
  )
}
function Bye(e) {
  return e
    ? ((e.selections = e.selections.map((t) => {
        if (e.document.getText(t).trim() === "") return t
        let n = Iye(t, e.document)
        return t.active.isBefore(t.anchor)
          ? new Ni.Selection(n.end, n.start)
          : new Ni.Selection(n.start, n.end)
      })),
      true)
    : false
}
function Rye() {
  let e = Ni.window.activeTextEditor
  if (!e) return []
  let { document: t, selection: r } = e,
    n = []
  return (
    r.isEmpty ||
      (n = Ni.languages
        .getDiagnostics(t.uri)
        .filter((o) => o.range.intersection(r))
        .map((o) => ({
          location: {
            path: t.fileName,
            line_start: o.range.start.line,
            line_end: o.range.end.line,
          },
          char_start: 0,
          char_end: 0,
          blob_name: "",
          current_blob_name: "",
          message: o.message,
          severity: (() => {
            switch (o.severity) {
              case Ni.DiagnosticSeverity.Error:
                return "ERROR"
              case Ni.DiagnosticSeverity.Warning:
                return "WARNING"
              case Ni.DiagnosticSeverity.Information:
                return "INFORMATION"
              case Ni.DiagnosticSeverity.Hint:
                return "HINT"
              default:
                return "ERROR"
            }
          })(),
        }))),
    n
  )
}
function PG(e, t, r, n) {
  if (!e) return null
  let { document: i, selection: s } = e,
    o = t.safeResolvePathName(i.uri)
  if (!o)
    return (
      z("getSelectedCodeDetails").error(
        "Unable to resolve path name for document",
      ),
      null
    )
  let a = i.languageId,
    l = i.lineAt(0).range.start,
    c = i.lineAt(i.lineCount - 1).range.end,
    u = i.getText(s),
    f,
    p
  if (u.trim() === "") {
    let y = new Ni.Position(s.active.line + 1, 0)
    ;(f = new Ni.Range(l, y)), (p = new Ni.Range(y, c))
  } else (f = new Ni.Range(l, s.start)), (p = new Ni.Range(s.end, c))
  var g = i.getText(f),
    m = i.getText(p)
  return (
    g.length > r && (g = g.slice(g.length - r)),
    m.length > n && (m = m.slice(0, n)),
    m.trim() === "" && ((u += m), (m = "")),
    {
      selectedCode: u,
      prefix: g,
      suffix: m,
      path: o.relPath,
      language: a,
      prefixBegin: f.start.character,
      suffixEnd: p.end.character,
    }
  )
}
var i4 = q(require("fs")),
  tg = q(require("os")),
  ym = q(require("path")),
  LM = q(CCe()),
  Cx = q(require("vscode"))
var r4 = tg.default.platform(),
  $pt = z("AugmentEnvironment")
function bCe() {
  let e
  return (
    r4 === "win32" && process.env.APPDATA
      ? (e = ym.default.join(process.env.APPDATA, "Code", "User"))
      : r4 === "darwin"
        ? (e = ym.default.join(
            tg.default.homedir(),
            "Library",
            "Application Support",
            "Code",
            "User",
          ))
        : r4 === "linux" &&
          (e = ym.default.join(
            tg.default.homedir(),
            ".config",
            "Code",
            "User",
          )),
    e && i4.default.existsSync(e) ? e : null
  )
}
function ECe() {
  let e = tg.default.homedir(),
    t
  return (
    tg.default.platform() === "win32"
      ? (t = ym.default.join(e, "Documents"))
      : tg.default.platform() === "darwin"
        ? (t = ym.default.join(e, "Documents"))
        : tg.default.platform() === "linux" &&
          (t = ym.default.join(e, "Documents")),
    t && i4.default.existsSync(t) ? t : null
  )
}
var extensionPackageCache
function getVSCodeAPI() {
  return (
    extensionPackageCache === undefined &&
      (extensionPackageCache =
        Cx.extensions.getExtension("Augment.vscode-augment")?.packageJSON ??
        null),
    extensionPackageCache
  )
}
var DEVELOPMENT_VERSION = "0.0.3141592"
function isMinVersionMet(minRequiredVersion, currentVersion = getVSCodeAPI()?.version) {
  return !currentVersion || minRequiredVersion === "" ? false : LM.default.gte(currentVersion, minRequiredVersion) || currentVersion === DEVELOPMENT_VERSION
}
function eo(e) {
  try {
    return LM.default.gte(Cx.version, e)
  } catch {
    return $pt.error(`Failed to parse vscode version: ${Cx.version}`), false
  }
}
function Ypt(e = getVSCodeAPI()?.version) {
  return e === DEVELOPMENT_VERSION
}
function UM(e = getVSCodeAPI()?.version) {
  return !e || Ypt(e) ? 0 : (LM.default.parse(e)?.patch ?? 0)
}
function createChangeRecord(blobName, path, charStart, charEnd, replacementText, presentInBlob, expectedBlobName) {
  return {
    blob_name: blobName,
    path: path,
    char_start: charStart,
    char_end: charEnd,
    replacement_text: replacementText,
    present_in_blob: presentInBlob,
    expected_blob_name: expectedBlobName,
  }
}
function convertToChangeRecords(changes) {
  return changes.map((change) =>
    createChangeRecord(
      change.blobName,
      change.pathName,
      change.origStart,
      change.origStart + change.origLength,
      change.text,
      change.uploaded,
      change.expectedBlobName,
    ),
  )
}
function ff(e) {
  return Array.isArray ? Array.isArray(e) : kCe(e) === "[object Array]"
}
var zpt = 1 / 0
function Jpt(e) {
  if (typeof e == "string") return e
  let t = e + ""
  return t == "0" && 1 / e == -zpt ? "-0" : t
}
function jpt(e) {
  return e == null ? "" : Jpt(e)
}
function Ku(e) {
  return typeof e == "string"
}
function DCe(e) {
  return typeof e == "number"
}
function Zpt(e) {
  return e === true || e === false || (Xpt(e) && kCe(e) == "[object Boolean]")
}
function TCe(e) {
  return typeof e == "object"
}
function Xpt(e) {
  return TCe(e) && e !== null
}
function Ga(e) {
  return e != null
}
function s4(e) {
  return !e.trim().length
}
function kCe(e) {
  return e == null
    ? e === undefined
      ? "[object Undefined]"
      : "[object Null]"
    : Object.prototype.toString.call(e)
}
var emt = "Incorrect 'index' type",
  tmt = (e) => `Invalid value for key ${e}`,
  rmt = (e) => `Pattern length exceeds max of ${e}.`,
  nmt = (e) => `Missing ${e} property in key`,
  imt = (e) => `Property 'weight' in key '${e}' must be a positive integer`,
  wCe = Object.prototype.hasOwnProperty,
  o4 = class {
    constructor(t) {
      ;(this._keys = []), (this._keyMap = {})
      let r = 0
      t.forEach((n) => {
        let i = MCe(n)
        this._keys.push(i), (this._keyMap[i.id] = i), (r += i.weight)
      }),
        this._keys.forEach((n) => {
          n.weight /= r
        })
    }
    get(t) {
      return this._keyMap[t]
    }
    keys() {
      return this._keys
    }
    toJSON() {
      return JSON.stringify(this._keys)
    }
  }
function MCe(e) {
  let t = null,
    r = null,
    n = null,
    i = 1,
    s = null
  if (Ku(e) || ff(e)) (n = e), (t = SCe(e)), (r = a4(e))
  else {
    if (!wCe.call(e, "name")) throw new Error(nmt("name"))
    let o = e.name
    if (((n = o), wCe.call(e, "weight") && ((i = e.weight), i <= 0)))
      throw new Error(imt(o))
    ;(t = SCe(o)), (r = a4(o)), (s = e.getFn)
  }
  return { path: t, id: r, weight: i, src: n, getFn: s }
}
function SCe(e) {
  return ff(e) ? e : e.split(".")
}
function a4(e) {
  return ff(e) ? e.join(".") : e
}
function smt(e, t) {
  let r = [],
    n = false,
    i = (s, o, a) => {
      if (Ga(s))
        if (!o[a]) r.push(s)
        else {
          let l = o[a],
            c = s[l]
          if (!Ga(c)) return
          if (a === o.length - 1 && (Ku(c) || DCe(c) || Zpt(c))) r.push(jpt(c))
          else if (ff(c)) {
            n = true
            for (let u = 0, f = c.length; u < f; u += 1) i(c[u], o, a + 1)
          } else o.length && i(c, o, a + 1)
        }
    }
  return i(e, Ku(t) ? t.split(".") : t, 0), n ? r : r[0]
}
var omt = { includeMatches: false, findAllMatches: false, minMatchCharLength: 1 },
  amt = {
    isCaseSensitive: false,
    includeScore: false,
    keys: [],
    shouldSort: true,
    sortFn: (e, t) =>
      e.score === t.score
        ? e.idx < t.idx
          ? -1
          : 1
        : e.score < t.score
          ? -1
          : 1,
  },
  lmt = { location: 0, threshold: 0.6, distance: 100 },
  cmt = {
    useExtendedSearch: false,
    getFn: smt,
    ignoreLocation: false,
    ignoreFieldNorm: false,
    fieldNormWeight: 1,
  },
  Rt = { ...amt, ...omt, ...lmt, ...cmt },
  umt = /[^ ]+/g
function dmt(e = 1, t = 3) {
  let r = new Map(),
    n = Math.pow(10, t)
  return {
    get(i) {
      let s = i.match(umt).length
      if (r.has(s)) return r.get(s)
      let o = 1 / Math.pow(s, 0.5 * e),
        a = parseFloat(Math.round(o * n) / n)
      return r.set(s, a), a
    },
    clear() {
      r.clear()
    },
  }
}
var bx = class {
  constructor({
    getFn: t = Rt.getFn,
    fieldNormWeight: r = Rt.fieldNormWeight,
  } = {}) {
    ;(this.norm = dmt(r, 3)),
      (this.getFn = t),
      (this.isCreated = false),
      this.setIndexRecords()
  }
  setSources(t = []) {
    this.docs = t
  }
  setIndexRecords(t = []) {
    this.records = t
  }
  setKeys(t = []) {
    ;(this.keys = t),
      (this._keysMap = {}),
      t.forEach((r, n) => {
        this._keysMap[r.id] = n
      })
  }
  create() {
    this.isCreated ||
      !this.docs.length ||
      ((this.isCreated = true),
      Ku(this.docs[0])
        ? this.docs.forEach((t, r) => {
            this._addString(t, r)
          })
        : this.docs.forEach((t, r) => {
            this._addObject(t, r)
          }),
      this.norm.clear())
  }
  add(t) {
    let r = this.size()
    Ku(t) ? this._addString(t, r) : this._addObject(t, r)
  }
  removeAt(t) {
    this.records.splice(t, 1)
    for (let r = t, n = this.size(); r < n; r += 1) this.records[r].i -= 1
  }
  getValueForItemAtKeyId(t, r) {
    return t[this._keysMap[r]]
  }
  size() {
    return this.records.length
  }
  _addString(t, r) {
    if (!Ga(t) || s4(t)) return
    let n = { v: t, i: r, n: this.norm.get(t) }
    this.records.push(n)
  }
  _addObject(t, r) {
    let n = { i: r, $: {} }
    this.keys.forEach((i, s) => {
      let o = i.getFn ? i.getFn(t) : this.getFn(t, i.path)
      if (Ga(o)) {
        if (ff(o)) {
          let a = [],
            l = [{ nestedArrIndex: -1, value: o }]
          for (; l.length; ) {
            let { nestedArrIndex: c, value: u } = l.pop()
            if (Ga(u))
              if (Ku(u) && !s4(u)) {
                let f = { v: u, i: c, n: this.norm.get(u) }
                a.push(f)
              } else
                ff(u) &&
                  u.forEach((f, p) => {
                    l.push({ nestedArrIndex: p, value: f })
                  })
          }
          n.$[s] = a
        } else if (Ku(o) && !s4(o)) {
          let a = { v: o, n: this.norm.get(o) }
          n.$[s] = a
        }
      }
    }),
      this.records.push(n)
  }
  toJSON() {
    return { keys: this.keys, records: this.records }
  }
}
function FCe(
  e,
  t,
  { getFn: r = Rt.getFn, fieldNormWeight: n = Rt.fieldNormWeight } = {},
) {
  let i = new bx({ getFn: r, fieldNormWeight: n })
  return i.setKeys(e.map(MCe)), i.setSources(t), i.create(), i
}
function fmt(
  e,
  { getFn: t = Rt.getFn, fieldNormWeight: r = Rt.fieldNormWeight } = {},
) {
  let { keys: n, records: i } = e,
    s = new bx({ getFn: t, fieldNormWeight: r })
  return s.setKeys(n), s.setIndexRecords(i), s
}
function OM(
  e,
  {
    errors: t = 0,
    currentLocation: r = 0,
    expectedLocation: n = 0,
    distance: i = Rt.distance,
    ignoreLocation: s = Rt.ignoreLocation,
  } = {},
) {
  let o = t / e.length
  if (s) return o
  let a = Math.abs(n - r)
  return i ? o + a / i : a ? 1 : o
}
function hmt(e = [], t = Rt.minMatchCharLength) {
  let r = [],
    n = -1,
    i = -1,
    s = 0
  for (let o = e.length; s < o; s += 1) {
    let a = e[s]
    a && n === -1
      ? (n = s)
      : !a &&
        n !== -1 &&
        ((i = s - 1), i - n + 1 >= t && r.push([n, i]), (n = -1))
  }
  return e[s - 1] && s - n >= t && r.push([n, s - 1]), r
}
var Cm = 32
function gmt(
  e,
  t,
  r,
  {
    location: n = Rt.location,
    distance: i = Rt.distance,
    threshold: s = Rt.threshold,
    findAllMatches: o = Rt.findAllMatches,
    minMatchCharLength: a = Rt.minMatchCharLength,
    includeMatches: l = Rt.includeMatches,
    ignoreLocation: c = Rt.ignoreLocation,
  } = {},
) {
  if (t.length > Cm) throw new Error(rmt(Cm))
  let u = t.length,
    f = e.length,
    p = Math.max(0, Math.min(n, f)),
    g = s,
    m = p,
    y = a > 1 || l,
    v = y ? Array(f) : [],
    C
  for (; (C = e.indexOf(t, m)) > -1; ) {
    let W = OM(t, {
      currentLocation: C,
      expectedLocation: p,
      distance: i,
      ignoreLocation: c,
    })
    if (((g = Math.min(W, g)), (m = C + u), y)) {
      let Z = 0
      for (; Z < u; ) (v[C + Z] = 1), (Z += 1)
    }
  }
  m = -1
  let E = [],
    w = 1,
    B = u + f,
    T = 1 << (u - 1)
  for (let W = 0; W < u; W += 1) {
    let Z = 0,
      te = B
    for (; Z < te; )
      OM(t, {
        errors: W,
        currentLocation: p + te,
        expectedLocation: p,
        distance: i,
        ignoreLocation: c,
      }) <= g
        ? (Z = te)
        : (B = te),
        (te = Math.floor((B - Z) / 2 + Z))
    B = te
    let Y = Math.max(1, p - te + 1),
      U = o ? f : Math.min(p + te, f) + u,
      ce = Array(U + 2)
    ce[U + 1] = (1 << W) - 1
    for (let Q = U; Q >= Y; Q -= 1) {
      let se = Q - 1,
        J = r[e.charAt(se)]
      if (
        (y && (v[se] = +!!J),
        (ce[Q] = ((ce[Q + 1] << 1) | 1) & J),
        W && (ce[Q] |= ((E[Q + 1] | E[Q]) << 1) | 1 | E[Q + 1]),
        ce[Q] & T &&
          ((w = OM(t, {
            errors: W,
            currentLocation: se,
            expectedLocation: p,
            distance: i,
            ignoreLocation: c,
          })),
          w <= g))
      ) {
        if (((g = w), (m = se), m <= p)) break
        Y = Math.max(1, 2 * p - m)
      }
    }
    if (
      OM(t, {
        errors: W + 1,
        currentLocation: p,
        expectedLocation: p,
        distance: i,
        ignoreLocation: c,
      }) > g
    )
      break
    E = ce
  }
  let N = { isMatch: m >= 0, score: Math.max(0.001, w) }
  if (y) {
    let W = hmt(v, a)
    W.length ? l && (N.indices = W) : (N.isMatch = false)
  }
  return N
}
function pmt(e) {
  let t = {}
  for (let r = 0, n = e.length; r < n; r += 1) {
    let i = e.charAt(r)
    t[i] = (t[i] || 0) | (1 << (n - r - 1))
  }
  return t
}
var qM = class {
    constructor(
      t,
      {
        location: r = Rt.location,
        threshold: n = Rt.threshold,
        distance: i = Rt.distance,
        includeMatches: s = Rt.includeMatches,
        findAllMatches: o = Rt.findAllMatches,
        minMatchCharLength: a = Rt.minMatchCharLength,
        isCaseSensitive: l = Rt.isCaseSensitive,
        ignoreLocation: c = Rt.ignoreLocation,
      } = {},
    ) {
      if (
        ((this.options = {
          location: r,
          threshold: n,
          distance: i,
          includeMatches: s,
          findAllMatches: o,
          minMatchCharLength: a,
          isCaseSensitive: l,
          ignoreLocation: c,
        }),
        (this.pattern = l ? t : t.toLowerCase()),
        (this.chunks = []),
        !this.pattern.length)
      )
        return
      let u = (p, g) => {
          this.chunks.push({ pattern: p, alphabet: pmt(p), startIndex: g })
        },
        f = this.pattern.length
      if (f > Cm) {
        let p = 0,
          g = f % Cm,
          m = f - g
        for (; p < m; ) u(this.pattern.substr(p, Cm), p), (p += Cm)
        if (g) {
          let y = f - Cm
          u(this.pattern.substr(y), y)
        }
      } else u(this.pattern, 0)
    }
    searchIn(t) {
      let { isCaseSensitive: r, includeMatches: n } = this.options
      if ((r || (t = t.toLowerCase()), this.pattern === t)) {
        let m = { isMatch: true, score: 0 }
        return n && (m.indices = [[0, t.length - 1]]), m
      }
      let {
          location: i,
          distance: s,
          threshold: o,
          findAllMatches: a,
          minMatchCharLength: l,
          ignoreLocation: c,
        } = this.options,
        u = [],
        f = 0,
        p = false
      this.chunks.forEach(({ pattern: m, alphabet: y, startIndex: v }) => {
        let {
          isMatch: C,
          score: E,
          indices: w,
        } = gmt(t, m, y, {
          location: i + v,
          distance: s,
          threshold: o,
          findAllMatches: a,
          minMatchCharLength: l,
          includeMatches: n,
          ignoreLocation: c,
        })
        C && (p = true), (f += E), C && w && (u = [...u, ...w])
      })
      let g = { isMatch: p, score: p ? f / this.chunks.length : 1 }
      return p && n && (g.indices = u), g
    }
  },
  zu = class {
    constructor(t) {
      this.pattern = t
    }
    static isMultiMatch(t) {
      return ICe(t, this.multiRegex)
    }
    static isSingleMatch(t) {
      return ICe(t, this.singleRegex)
    }
    search() {}
  }
function ICe(e, t) {
  let r = e.match(t)
  return r ? r[1] : null
}
var l4 = class extends zu {
    constructor(t) {
      super(t)
    }
    static get type() {
      return "exact"
    }
    static get multiRegex() {
      return /^="(.*)"$/
    }
    static get singleRegex() {
      return /^=(.*)$/
    }
    search(t) {
      let r = t === this.pattern
      return {
        isMatch: r,
        score: r ? 0 : 1,
        indices: [0, this.pattern.length - 1],
      }
    }
  },
  c4 = class extends zu {
    constructor(t) {
      super(t)
    }
    static get type() {
      return "inverse-exact"
    }
    static get multiRegex() {
      return /^!"(.*)"$/
    }
    static get singleRegex() {
      return /^!(.*)$/
    }
    search(t) {
      let n = t.indexOf(this.pattern) === -1
      return { isMatch: n, score: n ? 0 : 1, indices: [0, t.length - 1] }
    }
  },
  u4 = class extends zu {
    constructor(t) {
      super(t)
    }
    static get type() {
      return "prefix-exact"
    }
    static get multiRegex() {
      return /^\^"(.*)"$/
    }
    static get singleRegex() {
      return /^\^(.*)$/
    }
    search(t) {
      let r = t.startsWith(this.pattern)
      return {
        isMatch: r,
        score: r ? 0 : 1,
        indices: [0, this.pattern.length - 1],
      }
    }
  },
  d4 = class extends zu {
    constructor(t) {
      super(t)
    }
    static get type() {
      return "inverse-prefix-exact"
    }
    static get multiRegex() {
      return /^!\^"(.*)"$/
    }
    static get singleRegex() {
      return /^!\^(.*)$/
    }
    search(t) {
      let r = !t.startsWith(this.pattern)
      return { isMatch: r, score: r ? 0 : 1, indices: [0, t.length - 1] }
    }
  },
  f4 = class extends zu {
    constructor(t) {
      super(t)
    }
    static get type() {
      return "suffix-exact"
    }
    static get multiRegex() {
      return /^"(.*)"\$$/
    }
    static get singleRegex() {
      return /^(.*)\$$/
    }
    search(t) {
      let r = t.endsWith(this.pattern)
      return {
        isMatch: r,
        score: r ? 0 : 1,
        indices: [t.length - this.pattern.length, t.length - 1],
      }
    }
  },
  h4 = class extends zu {
    constructor(t) {
      super(t)
    }
    static get type() {
      return "inverse-suffix-exact"
    }
    static get multiRegex() {
      return /^!"(.*)"\$$/
    }
    static get singleRegex() {
      return /^!(.*)\$$/
    }
    search(t) {
      let r = !t.endsWith(this.pattern)
      return { isMatch: r, score: r ? 0 : 1, indices: [0, t.length - 1] }
    }
  },
  VM = class extends zu {
    constructor(
      t,
      {
        location: r = Rt.location,
        threshold: n = Rt.threshold,
        distance: i = Rt.distance,
        includeMatches: s = Rt.includeMatches,
        findAllMatches: o = Rt.findAllMatches,
        minMatchCharLength: a = Rt.minMatchCharLength,
        isCaseSensitive: l = Rt.isCaseSensitive,
        ignoreLocation: c = Rt.ignoreLocation,
      } = {},
    ) {
      super(t),
        (this._bitapSearch = new qM(t, {
          location: r,
          threshold: n,
          distance: i,
          includeMatches: s,
          findAllMatches: o,
          minMatchCharLength: a,
          isCaseSensitive: l,
          ignoreLocation: c,
        }))
    }
    static get type() {
      return "fuzzy"
    }
    static get multiRegex() {
      return /^"(.*)"$/
    }
    static get singleRegex() {
      return /^(.*)$/
    }
    search(t) {
      return this._bitapSearch.searchIn(t)
    }
  },
  HM = class extends zu {
    constructor(t) {
      super(t)
    }
    static get type() {
      return "include"
    }
    static get multiRegex() {
      return /^'"(.*)"$/
    }
    static get singleRegex() {
      return /^'(.*)$/
    }
    search(t) {
      let r = 0,
        n,
        i = [],
        s = this.pattern.length
      for (; (n = t.indexOf(this.pattern, r)) > -1; )
        (r = n + s), i.push([n, r - 1])
      let o = !!i.length
      return { isMatch: o, score: o ? 0 : 1, indices: i }
    }
  },
  g4 = [l4, HM, u4, d4, h4, f4, c4, VM],
  BCe = g4.length,
  mmt = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,
  Amt = "|"
function ymt(e, t = {}) {
  return e.split(Amt).map((r) => {
    let n = r
        .trim()
        .split(mmt)
        .filter((s) => s && !!s.trim()),
      i = []
    for (let s = 0, o = n.length; s < o; s += 1) {
      let a = n[s],
        l = false,
        c = -1
      for (; !l && ++c < BCe; ) {
        let u = g4[c],
          f = u.isMultiMatch(a)
        f && (i.push(new u(f, t)), (l = true))
      }
      if (!l)
        for (c = -1; ++c < BCe; ) {
          let u = g4[c],
            f = u.isSingleMatch(a)
          if (f) {
            i.push(new u(f, t))
            break
          }
        }
    }
    return i
  })
}
var vmt = new Set([VM.type, HM.type]),
  p4 = class {
    constructor(
      t,
      {
        isCaseSensitive: r = Rt.isCaseSensitive,
        includeMatches: n = Rt.includeMatches,
        minMatchCharLength: i = Rt.minMatchCharLength,
        ignoreLocation: s = Rt.ignoreLocation,
        findAllMatches: o = Rt.findAllMatches,
        location: a = Rt.location,
        threshold: l = Rt.threshold,
        distance: c = Rt.distance,
      } = {},
    ) {
      ;(this.query = null),
        (this.options = {
          isCaseSensitive: r,
          includeMatches: n,
          minMatchCharLength: i,
          findAllMatches: o,
          ignoreLocation: s,
          location: a,
          threshold: l,
          distance: c,
        }),
        (this.pattern = r ? t : t.toLowerCase()),
        (this.query = ymt(this.pattern, this.options))
    }
    static condition(t, r) {
      return r.useExtendedSearch
    }
    searchIn(t) {
      let r = this.query
      if (!r) return { isMatch: false, score: 1 }
      let { includeMatches: n, isCaseSensitive: i } = this.options
      t = i ? t : t.toLowerCase()
      let s = 0,
        o = [],
        a = 0
      for (let l = 0, c = r.length; l < c; l += 1) {
        let u = r[l]
        ;(o.length = 0), (s = 0)
        for (let f = 0, p = u.length; f < p; f += 1) {
          let g = u[f],
            { isMatch: m, indices: y, score: v } = g.search(t)
          if (m) {
            if (((s += 1), (a += v), n)) {
              let C = g.constructor.type
              vmt.has(C) ? (o = [...o, ...y]) : o.push(y)
            }
          } else {
            ;(a = 0), (s = 0), (o.length = 0)
            break
          }
        }
        if (s) {
          let f = { isMatch: true, score: a / s }
          return n && (f.indices = o), f
        }
      }
      return { isMatch: false, score: 1 }
    }
  },
  m4 = []
function Cmt(...e) {
  m4.push(...e)
}
function A4(e, t) {
  for (let r = 0, n = m4.length; r < n; r += 1) {
    let i = m4[r]
    if (i.condition(e, t)) return new i(e, t)
  }
  return new qM(e, t)
}
var WM = { AND: "$and", OR: "$or" },
  y4 = { PATH: "$path", PATTERN: "$val" },
  v4 = (e) => !!(e[WM.AND] || e[WM.OR]),
  bmt = (e) => !!e[y4.PATH],
  Emt = (e) => !ff(e) && TCe(e) && !v4(e),
  RCe = (e) => ({ [WM.AND]: Object.keys(e).map((t) => ({ [t]: e[t] })) })
function QCe(e, t, { auto: r = true } = {}) {
  let n = (i) => {
    let s = Object.keys(i),
      o = bmt(i)
    if (!o && s.length > 1 && !v4(i)) return n(RCe(i))
    if (Emt(i)) {
      let l = o ? i[y4.PATH] : s[0],
        c = o ? i[y4.PATTERN] : i[l]
      if (!Ku(c)) throw new Error(tmt(l))
      let u = { keyId: a4(l), pattern: c }
      return r && (u.searcher = A4(c, t)), u
    }
    let a = { children: [], operator: s[0] }
    return (
      s.forEach((l) => {
        let c = i[l]
        ff(c) &&
          c.forEach((u) => {
            a.children.push(n(u))
          })
      }),
      a
    )
  }
  return v4(e) || (e = RCe(e)), n(e)
}
function _mt(e, { ignoreFieldNorm: t = Rt.ignoreFieldNorm }) {
  e.forEach((r) => {
    let n = 1
    r.matches.forEach(({ key: i, norm: s, score: o }) => {
      let a = i ? i.weight : null
      n *= Math.pow(o === 0 && a ? Number.EPSILON : o, (a || 1) * (t ? 1 : s))
    }),
      (r.score = n)
  })
}
function xmt(e, t) {
  let r = e.matches
  ;(t.matches = []),
    Ga(r) &&
      r.forEach((n) => {
        if (!Ga(n.indices) || !n.indices.length) return
        let { indices: i, value: s } = n,
          o = { indices: i, value: s }
        n.key && (o.key = n.key.src),
          n.idx > -1 && (o.refIndex = n.idx),
          t.matches.push(o)
      })
}
function wmt(e, t) {
  t.score = e.score
}
function Smt(
  e,
  t,
  {
    includeMatches: r = Rt.includeMatches,
    includeScore: n = Rt.includeScore,
  } = {},
) {
  let i = []
  return (
    r && i.push(xmt),
    n && i.push(wmt),
    e.map((s) => {
      let { idx: o } = s,
        a = { item: t[o], refIndex: o }
      return (
        i.length &&
          i.forEach((l) => {
            l(s, a)
          }),
        a
      )
    })
  )
}
var Do = class {
  constructor(t, r = {}, n) {
    ;(this.options = { ...Rt, ...r }),
      this.options.useExtendedSearch,
      (this._keyStore = new o4(this.options.keys)),
      this.setCollection(t, n)
  }
  setCollection(t, r) {
    if (((this._docs = t), r && !(r instanceof bx))) throw new Error(emt)
    this._myIndex =
      r ||
      FCe(this.options.keys, this._docs, {
        getFn: this.options.getFn,
        fieldNormWeight: this.options.fieldNormWeight,
      })
  }
  add(t) {
    Ga(t) && (this._docs.push(t), this._myIndex.add(t))
  }
  remove(t = () => false) {
    let r = []
    for (let n = 0, i = this._docs.length; n < i; n += 1) {
      let s = this._docs[n]
      t(s, n) && (this.removeAt(n), (n -= 1), (i -= 1), r.push(s))
    }
    return r
  }
  removeAt(t) {
    this._docs.splice(t, 1), this._myIndex.removeAt(t)
  }
  getIndex() {
    return this._myIndex
  }
  search(t, { limit: r = -1 } = {}) {
    let {
        includeMatches: n,
        includeScore: i,
        shouldSort: s,
        sortFn: o,
        ignoreFieldNorm: a,
      } = this.options,
      l = Ku(t)
        ? Ku(this._docs[0])
          ? this._searchStringList(t)
          : this._searchObjectList(t)
        : this._searchLogical(t)
    return (
      _mt(l, { ignoreFieldNorm: a }),
      s && l.sort(o),
      DCe(r) && r > -1 && (l = l.slice(0, r)),
      Smt(l, this._docs, { includeMatches: n, includeScore: i })
    )
  }
  _searchStringList(t) {
    let r = A4(t, this.options),
      { records: n } = this._myIndex,
      i = []
    return (
      n.forEach(({ v: s, i: o, n: a }) => {
        if (!Ga(s)) return
        let { isMatch: l, score: c, indices: u } = r.searchIn(s)
        l &&
          i.push({
            item: s,
            idx: o,
            matches: [{ score: c, value: s, norm: a, indices: u }],
          })
      }),
      i
    )
  }
  _searchLogical(t) {
    let r = QCe(t, this.options),
      n = (a, l, c) => {
        if (!a.children) {
          let { keyId: f, searcher: p } = a,
            g = this._findMatches({
              key: this._keyStore.get(f),
              value: this._myIndex.getValueForItemAtKeyId(l, f),
              searcher: p,
            })
          return g && g.length ? [{ idx: c, item: l, matches: g }] : []
        }
        let u = []
        for (let f = 0, p = a.children.length; f < p; f += 1) {
          let g = a.children[f],
            m = n(g, l, c)
          if (m.length) u.push(...m)
          else if (a.operator === WM.AND) return []
        }
        return u
      },
      i = this._myIndex.records,
      s = {},
      o = []
    return (
      i.forEach(({ $: a, i: l }) => {
        if (Ga(a)) {
          let c = n(r, a, l)
          c.length &&
            (s[l] || ((s[l] = { idx: l, item: a, matches: [] }), o.push(s[l])),
            c.forEach(({ matches: u }) => {
              s[l].matches.push(...u)
            }))
        }
      }),
      o
    )
  }
  _searchObjectList(t) {
    let r = A4(t, this.options),
      { keys: n, records: i } = this._myIndex,
      s = []
    return (
      i.forEach(({ $: o, i: a }) => {
        if (!Ga(o)) return
        let l = []
        n.forEach((c, u) => {
          l.push(...this._findMatches({ key: c, value: o[u], searcher: r }))
        }),
          l.length && s.push({ idx: a, item: o, matches: l })
      }),
      s
    )
  }
  _findMatches({ key: t, value: r, searcher: n }) {
    if (!Ga(r)) return []
    let i = []
    if (ff(r))
      r.forEach(({ v: s, i: o, n: a }) => {
        if (!Ga(s)) return
        let { isMatch: l, score: c, indices: u } = n.searchIn(s)
        l && i.push({ score: c, key: t, value: s, idx: o, norm: a, indices: u })
      })
    else {
      let { v: s, n: o } = r,
        { isMatch: a, score: l, indices: c } = n.searchIn(s)
      a && i.push({ score: l, key: t, value: s, norm: o, indices: c })
    }
    return i
  }
}
Do.version = "7.0.0"
Do.createIndex = FCe
Do.parseIndex = fmt
Do.config = Rt
Do.parseQuery = QCe
Cmt(p4)
var lodash = q(_s()),
  wx = q(require("path")),
  $a = q(require("vscode"))
function getFullPath(pathInfo) {
  return pathInfo.rootPath + "/" + pathInfo.relPath
}
function GM(e) {
  return getFullPath({ rootPath: e.repoRoot, relPath: e.pathName })
}
var NCe = q(require("vscode"))
function PCe(e, t) {
  let r = { type: "file-ranges-selected", data: [] }
  if (!e || !t) return r
  let n = Imt(e.document.uri, t),
    i = e.selections
  return (
    n &&
      i.some((s) => !s.isEmpty) &&
      (r.data = i.map((s) => ({
        repoRoot: n.repoRoot,
        pathName: n.pathName,
        fullRange: {
          startLineNumber: s.start.line,
          startColumn: s.start.character,
          endLineNumber: s.end.line,
          endColumn: s.end.character,
        },
        originalCode: e.document.getText(s),
      }))),
    r
  )
}
function Ex(e) {
  return {
    startLineNumber: e.start.line,
    startColumn: e.start.character,
    endLineNumber: e.end.line,
    endColumn: e.end.character,
  }
}
function _x(e) {
  return new NCe.Range(
    e.startLineNumber,
    e.startColumn,
    e.endLineNumber,
    e.endColumn,
  )
}
function Imt(e, t) {
  let r = t.safeResolvePathName(e)
  if (r !== undefined) return rg(r)
}
function rg(e) {
  return { repoRoot: e.rootPath, pathName: e.relPath }
}
var LCe = q(RA())
var UCe = q(require("vscode"))
var PersistentCache = class extends DisposableContainer {
  constructor(globalState, cacheStorageKey, options) {
    super()
    this._globalState = globalState
    this._cacheBackKey = cacheStorageKey
    this._options = options
    let cacheOptions = { max: 1000, ...this._options?.lru }
    ;(this._cache = new Gf(cacheOptions)),
      this.loadContext(),
      this.addDisposable(new UCe.Disposable(() => this.dumpContext.cancel()))
  }
  _cache
  _onExpiry
  dumpContext = (0, LCe.default)(
    async () => {
      let cacheData = this._cache.dump()
      await this._globalState.save(this._cacheBackKey, cacheData, {
        uniquePerWorkspace: true,
      }),
        this._globalState.update(this._cacheBackKey, undefined)
    },
    60 * 1000,
    { leading: true, trailing: true },
  )
  loadContext = async () => {
    let savedCache = await this._globalState.load(this._cacheBackKey, {
      uniquePerWorkspace: true,
    })
    if (savedCache) {
      this._cache.load(savedCache)
      return
    }
    let legacyCache = this._globalState.get(this._cacheBackKey)
    legacyCache && this._cache.load(legacyCache)
  }
  set = async (key, value) => {
    this._cache.set(key, value), await this.dumpContext()
  }
  get = (key) => (this.dumpContext(), this._cache.get(key))
  get cache() {
    return this._cache
  }
  remove = (key) => {
    this._cache.delete(key)
  }
  clear = () => {
    this._cache.clear()
  }
  getItems = () => [...this._cache.values()]
}
var OCe = q(RA()),
  qCe = q(require("vscode"))
var PersistentSearchIndex = class extends DisposableContainer {
  constructor(globalState, indexStorageKey, options) {
    super()
    this._globalState = globalState
    this._indexBackKey = indexStorageKey
    this._opts = options
    ;(this._maxKeysBeforeRemoval =
      options.maxKeysBeforeRemoval ?? this._maxKeysBeforeRemoval),
      (this._flushDelay = options.maxDelayBeforeRemovalMs ?? this._flushDelay),
      (this._index = new Do(Object.values(this._items), {
        ...this._opts.fuse,
      })),
      (this._revalidationQueue = new KeyedTaskQueue(this._revalidateEntry.bind(this))),
      this.addDisposables(
        this._revalidationQueue,
        new qCe.Disposable(() => this.dumpContext.cancel()),
      ),
      this.loadContext()
  }
  _index
  _items = {}
  _revalidationQueue
  _keysToRemove = new Set()
  _maxKeysBeforeRemoval = 100
  _flushTimer = null
  _flushDelay = 15e3
  dumpContext = (0, OCe.default)(
    async () => {
      await this._globalState.save(this._indexBackKey, this._items, {
        uniquePerWorkspace: true,
      }),
        this._globalState.update(this._indexBackKey, undefined)
    },
    60 * 1e3,
    { leading: true, trailing: true },
  )
  loadContext = async () => {
    let savedItems = await this._globalState.load(this._indexBackKey, {
      uniquePerWorkspace: true,
    })
    if (savedItems) {
      ;(this._items = { ...this._items, ...savedItems }),
        (this._index = new Do(Object.values(this._items), this._opts.fuse)),
        this.markForRevalidation(Object.values(this._items))
      return
    }
    let legacyItems = this._globalState.get(this._indexBackKey)
    legacyItems &&
      ((this._items = { ...this._items, ...legacyItems }),
      (this._index = new Do(Object.values(this._items), this._opts.fuse)),
      this.markForRevalidation(Object.values(this._items)))
  }
  set = (item) => {
    let itemKey = this._opts.keyFn(item)
    return (
      this._cancelQueuedWork(itemKey),
      this._items[itemKey]
        ? false
        : ((this._items[itemKey] = item), this._index.add(item), this.dumpContext(), true)
    )
  }
  markForRevalidation = (items) => {
    items.forEach((item) => {
      let itemKey = this._opts.keyFn(item)
      this._revalidationQueue.insert(itemKey, item)
    }),
      this._revalidationQueue.kick()
  }
  search = (query, options) => this._index.search(query, options)
  remove = (item) => {
    this._queueKeyRemoval(this._opts.keyFn(item))
  }
  clear = () => {
    ;(this._items = {}), this._index.setCollection([])
  }
  get items() {
    return { ...this._items }
  }
  _cancelQueuedWork = (itemKey) => {
    this._revalidationQueue.cancel(itemKey), this._keysToRemove.delete(itemKey)
  }
  _checkValidity = async (item) =>
    this._opts.validator ? await this._opts.validator(item) : true
  async _revalidateEntry(queueEntry) {
    if (queueEntry === undefined) return
    let [itemKey, item] = queueEntry
    ;(await this._checkValidity(item)) || this._queueKeyRemoval(itemKey)
  }
  _queueKeyRemoval = (itemKey) => {
    this._keysToRemove.add(itemKey),
      this._keysToRemove.size >= this._maxKeysBeforeRemoval
        ? this._flushToRemove()
        : this._flushTimer ||
          (this._flushTimer = setTimeout(
            () => this._flushToRemove(),
            this._flushDelay,
          ))
  }
  _flushToRemove = () => {
    this._flushTimer &&
      (clearTimeout(this._flushTimer), (this._flushTimer = null))
    for (let itemKey of this._keysToRemove) delete this._items[itemKey]
    this._index.remove((item) => this._keysToRemove.has(this._opts.keyFn(item))),
      this._keysToRemove.clear()
  }
}
var fuseSearchOptions = {
    keys: ["relPath"],
    minMatchCharLength: 1,
    minExactMatchCharLength: 3,
    threshold: 0.25,
    ignoreLocation: true,
    includeScore: true,
    useExtendedSearch: true,
    shouldSort: true,
    findAllMatches: true,
    sortFn: Rmt,
  },
  FuzzyFsSearcher = class extends DisposableContainer {
    constructor(globalState, workspaceManager, onDidChangeSyncingStatus) {
      super()
      this._globalState = globalState
      this._workspaceManager = workspaceManager
      this._onDidChangeSyncingStatus = onDidChangeSyncingStatus
      ;(this._filesIndex = new PersistentSearchIndex(this._globalState, "fuzzyFsFilesIndex", {
        fuse: fuseSearchOptions,
        validator: this.validatePath,
        keyFn: getQualifiedPath,
      })),
        (this._foldersIndex = new PersistentSearchIndex(this._globalState, "fuzzyFsFoldersIndex", {
          fuse: fuseSearchOptions,
          validator: this.validatePath,
          keyFn: getQualifiedPath,
        })),
        (this._recentFiles = new PersistentCache(this._globalState, "recentlyOpenedFiles", {
          lru: { max: 64 },
        })),
        this.addDisposables(
          ...this.trackFilesAndFolders(),
          this._recentFiles,
          $a.window.onDidChangeActiveTextEditor(this.trackRecentTextEditor),
          $a.window.onDidChangeVisibleTextEditors(
            this.onDidChangeVisibleTextEditors,
          ),
          $a.window.tabGroups.onDidChangeTabs((tabChangeEvent) => {
            tabChangeEvent.changed.forEach(this.trackRecentTab),
              tabChangeEvent.opened.forEach(this.trackRecentTab)
          }),
        )
    }
    _foldersIndex
    _filesIndex
    _recentFiles
    dispose = () => {
      super.dispose(), this._filesIndex.clear(), this._foldersIndex.clear()
    }
    get files() {
      return Object.values(this._filesIndex.items)
    }
    get folders() {
      return Object.values(this._foldersIndex.items)
    }
    setFiles = (files) => {
      let oldItems = this._filesIndex.items
      files.forEach((file) => this._filesIndex.set(file))
      let newItems = this._filesIndex.items,
        removedItems = Object.keys(oldItems)
          .filter((key) => !newItems[key])
          .map((key) => oldItems[key])
      this._filesIndex.markForRevalidation(removedItems)
    }
    setFolders = (folders) => {
      let oldItems = this._foldersIndex.items
      folders.forEach((folder) => this._foldersIndex.set(folder))
      let newItems = this._foldersIndex.items,
        removedItems = Object.keys(oldItems)
          .filter((key) => !newItems[key])
          .map((key) => oldItems[key])
      this._foldersIndex.markForRevalidation(removedItems)
    }
    trackRecentAbsPath = (absolutePath) => {
      let pathInfo = this._workspaceManager.resolvePathName(absolutePath)
      pathInfo === undefined ||
        this._workspaceManager.getBlobName(pathInfo) === undefined ||
        this._recentFiles.set(absolutePath, pathInfo)
    }
    trackRecentTab = (tab) => {
      if (tab.input instanceof $a.TabInputText) {
        let filePath = tab.input.uri.fsPath
        this.trackRecentAbsPath(filePath)
      } else return
    }
    trackRecentTextEditor = (editor) => {
      editor !== undefined && this.trackRecentAbsPath(editor.document.uri.fsPath)
    }
    onDidChangeVisibleTextEditors = () => {
      let visibleEditors = $a.window.visibleTextEditors
      for (let editor of visibleEditors) this.trackRecentTextEditor(editor)
    }
    trackFilesAndFolders = () => {
      let throttledUpdateIndexes = (0, lodash.throttle)(
          () => {
            let { files: files, folders: folders } = getFilesAndFolders(this._workspaceManager) // =
            this.setFiles(files), this.setFolders(folders) // =
          },
          15e3,
          { leading: true, trailing: true },
        ),
        handleFileChange = (fileChange) => {
          if (!fileChange?.relPath) return
          this._workspaceManager
            .getAllQualifiedPathNames(fileChange.relPath)
            .forEach((pathInfo) => {
              this._filesIndex.set(pathInfo)
            })
        }
      return [
        new $a.Disposable(() => throttledUpdateIndexes.cancel()),
        this._workspaceManager.onDidChangeFile(throttledUpdateIndexes),
        this._workspaceManager.onDidChangeFile(handleFileChange),
        this._onDidChangeSyncingStatus(throttledUpdateIndexes),
      ]
    }
    findRecentFiles = (request) => {
      let searchQuery = request.data.relPath,
        maxResults = request.data.maxResults || 12,
        recentFilesList = this._recentFiles
          .getItems()
          .map((item) => ({ repoRoot: item.rootPath, pathName: item.relPath }))
      if (searchQuery.length < fuseSearchOptions.minMatchCharLength)
        return {
          type: "find-recently-opened-files-response",
          data: recentFilesList.slice(0, maxResults),
        }
      let searchResults = searchWithFuse(recentFilesList, searchQuery, { fuseSearch: { limit: maxResults }, fuseInit: fuseSearchOptions })
      return { type: "find-recently-opened-files-response", data: searchResults }
    }
    findInScope = (request) => {
      let searchQuery = request.data.relPath,
        maxResults = request.data.maxResults || 12
      return request.data.searchScope?.files
        ? searchWithFuse(request.data.searchScope.files, searchQuery, {
            fuseSearch: { limit: maxResults },
            fuseInit: fuseSearchOptions,
          })
        : []
    }
    findFiles = (request) => {
      let isExactMatch = request.data.exactMatch ?? false,
        searchQuery = request.data.relPath,
        searchPattern = isExactMatch ? `${searchQuery}$` : searchQuery,
        maxResults = request.data.maxResults || 12
      if (
        isExactMatch &&
        (searchQuery.length < fuseSearchOptions.minExactMatchCharLength ||
          searchQuery.length < fuseSearchOptions.minMatchCharLength)
      )
        return { type: "find-file-response", data: [] }
      if (searchQuery.length < fuseSearchOptions.minMatchCharLength) {
        let topFiles = Object.values(this._filesIndex.items).slice(0, 100)
        return { type: "find-file-response", data: topFiles.map(rg) }
      }
      let response = { type: "find-file-response", data: [] },
        scopeResults = this.findInScope(request)
      return (
        (response.data = deduplicateResults([...response.data, ...scopeResults])),
        isExactMatch && (response.data = WCe(response.data, searchQuery)),
        response.data.length >= maxResults ||
          ((response.data = deduplicateResults([
            ...response.data,
            ...this._filesIndex
              .search(searchPattern, { limit: maxResults - response.data.length })
              .map((result) => ({
                repoRoot: result.item.rootPath,
                pathName: result.item.relPath,
              })),
          ])),
          isExactMatch && (response.data = WCe(response.data, searchQuery))),
        response
      )
    }
    findFolders = (request) => {
      let isExactMatch = request.data.exactMatch ?? false,
        searchQuery = request.data.relPath,
        searchPattern = isExactMatch ? `${searchQuery}$` : searchQuery,
        maxResults = request.data.maxResults || 12
      if (searchQuery.length < fuseSearchOptions.minMatchCharLength) {
        let topFolders = Object.values(this._foldersIndex.items).slice(0, 100)
        return { type: "find-folder-response", data: topFolders.map(rg) }
      }
      let response = { type: "find-folder-response", data: [] },
        searchResults = this._foldersIndex.search(searchPattern, { limit: maxResults }).map((result) => rg(result.item))
      return (response.data = deduplicateResults([...response.data, ...searchResults])), response
    }
    validatePath = async (path) => this.statPath(path).then((stat) => stat !== undefined)
    statPath = async (path) => {
      if (
        (await this._workspaceManager.awaitInitialFoldersEnumerated(),
        !!this._workspaceManager.getFolderRoot(getFullPath(path)))
      )
        try {
          return await ev(getFullPath(path))
        } catch {
          return
        }
    }
  }
function getFilesAndFolders(workspaceManager) {
  let getFirstPathName = (blobName) => workspaceManager.getAllPathNames(blobName)[0],
    files = workspaceManager
      .getContextWithBlobNames()
      .blobNames.map(getFirstPathName)
      .filter((pathInfo) => pathInfo !== undefined),
    folderMap = new Map(
      files.map((pathInfo) => {
        let folderInfo = { rootPath: pathInfo.rootPath, relPath: Ha(pathInfo.relPath) }
        return [getFullPath(folderInfo), folderInfo]
      }),
    ),
    folders = Array.from(folderMap.values())
  return { files: files, folders: folders }
}
async function getFileRangeInfo(pathInfo, range) {
  let document = await Io($a.Uri.file(getFullPath(pathInfo))),
    vscodeRange = new $a.Range(document.positionAt(range.charStart), document.positionAt(range.charEnd))
  return {
    repoRoot: pathInfo.rootPath,
    pathName: pathInfo.relPath,
    fullRange: {
      startLineNumber: vscodeRange.start.line,
      startColumn: vscodeRange.start.character,
      endLineNumber: vscodeRange.end.line,
      endColumn: vscodeRange.end.character,
    },
  }
}
function searchWithFuse(items, searchQuery, options) {
  return new Do(items, { ...fuseSearchOptions, ...options.fuseInit, keys: ["relPath"] })
    .search(searchQuery, options.fuseSearch)
    .map((result) => result.item)
}
function deduplicateResults(results) {
  let uniqueMap = new Map()
  return (
    results.forEach((item) => {
      let fullPath = getFullPath({ rootPath: item.repoRoot, relPath: item.pathName })
      uniqueMap.set(fullPath, item)
    }),
    Array.from(uniqueMap.values())
  )
}
function getQualifiedPath(pathInfo) {
  return getFullPath(pathInfo)
}
function Rmt(e, t) {
  if (e.score !== t.score) return e.score - t.score
  let r = e.matches?.[0].value,
    n = t.matches?.[0].value
  return r && n
    ? r.length === n.length
      ? r.localeCompare(n)
      : r.length - n.length
    : e.score - t.score
}
function Dmt(e, t) {
  let r = wx.normalize(e),
    n = wx.normalize(t)
  if (n.length > r.length) return false
  if (r.endsWith(n)) {
    let i = r.length - n.length
    return i === 0 || r[i - 1] === wx.sep
  }
  return false
}
function WCe(e, t) {
  return e.filter((r) => Dmt(r.pathName, t))
}
var Sx = class {
    _selectedCodeReferenceRequestId = undefined
    _selectedCodeReferenceRequestIdOptionB = undefined
    _selectedCode = undefined
    _filePath = undefined
    _maybeUpdateSelectedCodeReferenceRequestId(t, r, n) {
      let i = n
        ? this._selectedCodeReferenceRequestIdOptionB
        : this._selectedCodeReferenceRequestId
      return (
        i === undefined &&
          r &&
          (n
            ? (this._selectedCodeReferenceRequestIdOptionB = t.requestId)
            : (this._selectedCodeReferenceRequestId = t.requestId),
          (i = ov._newRequestReferenceId)),
        i
      )
    }
  },
  ov = class e extends DisposableContainer {
    constructor(r, n, i, s, o, a, l, c) {
      super()
      this._globalState = r
      this._apiServer = n
      this._workspaceManager = i
      this._recentChats = s
      this._fuzzySymbolSearcher = o
      this._assetManager = a
      this._featureFlagManager = l
      this._checkpointManager = c
      ;(this.selectionCache = new PersistentCache(
        this._globalState,
        "requestIdSelectionMetadata",
        { lru: { max: 1e3 } },
      )),
        this.addDisposables(
          KCe.window.onDidChangeTextEditorSelection(() => {
            this._selectedCodeReferenceRequestId = undefined
          }),
          { dispose: () => this._chatStreams.clear() },
          this.selectionCache,
        )
    }
    _chatStreams = new Map()
    static _newRequestReferenceId = "new"
    _selectedCodeReferenceRequestId
    _preferenceState = new Sx()
    selectionCache
    getDiagnostics = (r) => ({ type: "get-diagnostics-response", data: Rye() })
    _maybeUpdateSelectedCodeReferenceRequestId(r, n) {
      let i = this._selectedCodeReferenceRequestId
      return (
        i === undefined &&
          n &&
          ((this._selectedCodeReferenceRequestId = r.requestId),
          (i = e._newRequestReferenceId),
          this.selectionCache.set(r.requestId, n)),
        i
      )
    }
    async _getVCSChange() {
      return this._workspaceManager !== undefined
        ? await this._workspaceManager.getVCSChange()
        : { commits: [], workingDirectory: [] }
    }
    async chat(r, n, i) {
      this._recentChats.addItem(r),
        z("ChatModel").debug(`Sending chat request with ID: ${r.requestId}`)
      let o
      i === undefined
        ? (o = this._maybeUpdateSelectedCodeReferenceRequestId(r, n))
        : ((o =
            this._preferenceState._maybeUpdateSelectedCodeReferenceRequestId(
              r,
              n,
              i.useOptionB,
            )),
          n?.selectedCode &&
            ((this._preferenceState._selectedCode = n.selectedCode),
            (this._preferenceState._filePath = n.path)),
          r.selectedCode &&
            ((this._preferenceState._selectedCode = r.selectedCode),
            (this._preferenceState._filePath = r.pathName)))
      let a = await this._getVCSChange(),
        l = this._getRecentChanges(),
        c = await this._apiServer.chat(
          r.requestId,
          r.message,
          r.chatHistory,
          r.blobs,
          r.userGuidedBlobs,
          r.externalSourceIds,
          r.modelId,
          a,
          l,
          o,
          n?.selectedCode || r.selectedCode,
          n?.prefix || r.prefix,
          n?.suffix || r.suffix,
          n?.path || r.pathName,
          n?.language || r.language,
          undefined,
          undefined,
          r.userGuidelines,
          r.workspaceGuidelines,
          r.toolDefinitions,
          r.nodes,
          r.mode,
          r.agentMemories,
          r.personaType,
        )
      return (c.workspaceFileChunks = b4(c.workspaceFileChunks || [])), c
    }
    getReferenceReqId() {
      return this._selectedCodeReferenceRequestId
    }
    cancelChatStream = (r) => {
      this._chatStreams.get(r)?.cancel()
    }
    async *getChatStream(r) {
      let n = this._chatStreams.get(r.data.requestId)
      if (n) yield* n.copy()
      else throw new Error(`Chat stream with ID ${r.data.requestId} not found`)
    }
    deleteChatStream = (r) => {
      this._chatStreams.get(r)?.cancel(), this._chatStreams.delete(r)
    }
    async *chatStream(r, n, i) {
      this._recentChats.addItem(r),
        yield* this._chatStreams.get(r.requestId)?.copy() ??
          this.startChatStream(r, n, i)
    }
    _getRecentChanges() {
      let r = this._workspaceManager.getContext()
      return convertToChangeRecords(r.recentChunks)
    }
    resolveWorkspaceFileChunk = async (r) => {
      let n = r.data,
        i = this._workspaceManager.getAllPathNames(n.blobName)[0]
      if (!i)
        throw new Error(`File chunk with blobName=${n.blobName} not found`)
      return {
        type: "resolve-workspace-file-chunk-response",
        data: await getFileRangeInfo(i, n),
      }
    }
    async *startChatStream(r, n, i) {
      let s = r.requestId,
        o = this._chatStreams.get(s)
      if (o) throw new Error(`Chat stream with ID ${s} already exists`)
      {
        z("ChatModel").debug(
          `Sending chat stream request with ID: ${r.requestId}`,
        )
        let l
        i === undefined
          ? (l = this._maybeUpdateSelectedCodeReferenceRequestId(r, n))
          : ((l =
              this._preferenceState._maybeUpdateSelectedCodeReferenceRequestId(
                r,
                n,
                i.useOptionB,
              )),
            n?.selectedCode &&
              ((this._preferenceState._selectedCode = n.selectedCode),
              (this._preferenceState._filePath = n.path)),
            r.selectedCode &&
              ((this._preferenceState._selectedCode = r.selectedCode),
              (this._preferenceState._filePath = r.pathName)))
        let c = await this._getVCSChange(),
          u = this._getRecentChanges(),
          f = n?.path || r.pathName,
          p = f
            ? this._workspaceManager.getAllQualifiedPathNames(f)[0]
            : undefined,
          g = n?.prefix || r.prefix,
          m = n?.suffix || r.suffix,
          y = n?.language || r.language,
          v = n?.selectedCode || r.selectedCode,
          C = await this.hydrateChatHistory(r.chatHistory),
          E = this.limitChatHistory(C),
          w = r.nodes ? await this.hydrateRequestNodes(r.nodes) : [],
          B = p
            ? this._workspaceManager.getFolderRoot(p?.absPath)
            : this._workspaceManager.getMostRecentlyChangedFolderRoot(),
          T = B ? this._workspaceManager.getRepoRootForFolderRoot(B) : undefined,
          N = ql(T ?? "", B ?? "")
        N !== "" && N !== "." && (r = Mmt(r, N))
        let W = await this._apiServer.chatStream(
            r.requestId,
            r.message,
            E,
            r.blobs,
            r.userGuidedBlobs,
            r.externalSourceIds,
            r.modelId,
            c,
            u,
            l,
            v,
            g,
            m,
            f,
            y,
            i && i.useOptionB ? this._apiServer.sessionId + "-B" : undefined,
            i?.disableAutoExternalSources,
            r.userGuidelines,
            r.workspaceGuidelines,
            r.toolDefinitions,
            w,
            r.mode,
            r.agentMemories,
            r.personaType,
          ),
          Z
        n?.path && p
          ? (Z = {
              charStart: g?.length ?? 0,
              charEnd: (g?.length ?? 0) + (v?.length ?? 0),
              blobName: this._workspaceManager.getBlobName(p) ?? "",
            })
          : (Z = undefined),
          (o = new mm(
            Tmt(s, Z, W, async (te) => {
              try {
                let Y = await this.resolveWorkspaceFileChunk({
                  type: "resolve-workspace-file-chunk",
                  data: te,
                })
                return (
                  this._fuzzySymbolSearcher.warmupCache(te.blobName),
                  { ...te, file: Y.data }
                )
              } catch {
                return te
              }
            }),
          )),
          this._chatStreams.set(s, o),
          yield* o.copy()
      }
    }
    sendFeedback = async (r) => (
      await this._apiServer.chatFeedback(r.data),
      { type: "chat-rating-done", data: r.data }
    )
    saveConversation = async (r) => {
      let n = z("ChatModel"),
        i = await this._apiServer.saveChat(
          r.data.conversationId,
          r.data.chatHistory,
          r.data.title,
        )
      return (
        n.debug(`Saved chat with api server: ${i.url}`),
        { type: "save-chat-done", data: i }
      )
    }
    hydrateRequestNodes = async (r) => {
      let n = z("ChatModel")
      return (
        await Promise.all(
          r.map(async (s) => {
            if (s.type === po.IMAGE_ID) {
              if (!s.image_id_node)
                return (
                  n.error("Invalid image_id_node: missing image_id_node"), s
                )
              let o = s.image_id_node.image_id,
                a = await this._assetManager.loadAsset(o ?? "")
              if (!a) return n.error(`Failed to load asset ${o}`), s
              let l = Buffer.from(a)
                .toString("base64")
                .replace(/^data:.*?;base64,/, "")
              return {
                type: po.IMAGE,
                id: s.id,
                image_node: { image_data: l, format: gI.PNG },
              }
            } else if (
              s.type === po.CHECKPOINT_REF &&
              this._checkpointManager
            ) {
              let o = s.checkpoint_ref_node
              if (!o) return
              let a = o.request_id,
                l = o.from_timestamp,
                c = o.to_timestamp
              try {
                let u =
                  await this._checkpointManager.getCheckpointByRequestId(a)
                return (
                  u ||
                    (u = await this._checkpointManager.getAggregateCheckpoint({
                      minTimestamp: l,
                      maxTimestamp: c,
                    })),
                  u && u.files.length > 0
                    ? Sye(
                        s.id,
                        u,
                        () => ({
                          beforeBlobName: undefined,
                          afterBlobName: undefined,
                        }),
                        o.source,
                      )
                    : undefined
                )
              } catch (u) {
                n.error(
                  `Failed to hydrate checkpoint reference node: ${String(u)}`,
                )
              }
            }
            return s
          }),
        )
      ).filter((s) => s !== undefined)
    }
    hydrateChatHistory = async (r) =>
      await Promise.all(
        r.map(async (i) => {
          if (i.request_nodes) {
            i.request_nodes = await this.hydrateRequestNodes(i.request_nodes)
            for (let s = 0; s < i.request_nodes.length; s++)
              i.request_nodes[s].id = s
          }
          return i
        }),
      )
    limitChatHistory = (r) =>
      isMinVersionMet(
        this._featureFlagManager.currentFlags
          .vscodeChatStablePrefixTruncationMinVersion,
      )
        ? wye(r)
        : xye(r)
  }
async function* Tmt(e, t, r, n) {
  let i = new Set(),
    s = [],
    o = new ProcessQueue(async (l) => {
      if (l === undefined) return
      let c = [l, await n(l)]
      s.push(c)
    })
  t && (i.add(t), o.insert(t)), o.kick()
  for await (let l of r) {
    b4(l.workspaceFileChunks ?? []).forEach((f) => {
      i.add(f), o.insert(f)
    }),
      o.kick()
    let u = [...s]
    u.forEach(([f, p]) => {
      i.delete(f)
    }),
      (s = []),
      yield {
        type: "chat-model-reply",
        data: {
          text: l.text,
          requestId: e,
          streaming: true,
          workspaceFileChunks: u.map(([f, p]) => p),
          nodes: l.nodes,
        },
      }
  }
  let a = await Promise.all([...b4([...i]).map(n)])
  yield {
    type: "chat-model-reply",
    data: { text: "", requestId: e, streaming: true, workspaceFileChunks: a },
  }
}
function b4(e) {
  let t = new Map()
  for (let n of e) {
    if (n.charStart >= n.charEnd) continue
    let i = t.get(n.blobName) ?? []
    i.push(n), t.set(n.blobName, i)
  }
  let r = []
  for (let [n, i] of t) {
    let s = i
      .sort((o, a) => o.charStart - a.charStart)
      .reduce((o, a) => {
        let l = o[o.length - 1]
        return (
          l && l.charEnd + 1 >= a.charStart
            ? (l.charEnd = a.charEnd)
            : o.push(a),
          o
        )
      }, [])
    r.push(...s)
  }
  return r
}
var kmt =
  "- The user is working from the directory `${relPath}`.\n- When the user mentions a file name or when viewing output from shell commands, it is likely relative to `${relPath}`.\n- When creating, deleting, viewing or editing files, first try prepending `${relPath}` to the path.\n- When running shell commands, do not prepend `${relPath}` to the path.\n"
function Mmt(e, t) {
  return (
    e.agentMemories
      ? (e.agentMemories += `
`)
      : (e.agentMemories = ""),
    (e.agentMemories += kmt.replaceAll("${relPath}", t)),
    e
  )
}
var ZCe = q(Yf()),
  av = q(require("vscode"))
var Ya = q(require("vscode"))
async function zCe(e) {
  let [t, r, n] = await Promise.all([
    Ya.commands.executeCommand("vscode.provideDocumentSemanticTokensLegend", e),
    Ya.commands.executeCommand("vscode.provideDocumentSemanticTokens", e),
    Io(e),
  ])
  if (!t || !r || !n) return []
  let i = [],
    s = r.data
  for (let o = 0; o < s.length; o += 5) {
    let a = i[i.length - 1],
      l = s[o],
      c = s[o + 1],
      u = s[o + 2],
      f = (a?.range.startLineNumber ?? 0) + l,
      g = (l === 0 ? (a?.range.startColumn ?? 0) : 0) + c,
      m = new Ya.Position(f, g),
      v = n.offsetAt(m) + u,
      C = n.positionAt(v),
      E = new Ya.Range(m, C),
      w = n.getText(E)
    i.push({
      name: w,
      kind: Ya.SymbolKind.String,
      range: Ex(E),
      selectionRange: Ex(E),
      detail: "",
      tags: [],
      children: [],
    })
  }
  return i
}
async function JCe(e, t) {
  let r = Ya.Uri.file(GM(e)),
    n = await Io(r)
  if (!n) return Promise.resolve([])
  let i = e.fullRange ? _x(e.fullRange) : undefined,
    s = i ? n.offsetAt(i.start) : 0,
    o = n.getText(i),
    a = new RegExp(`\\b${t}\\b`, "g"),
    l = o.search(a)
  if (l >= 0) {
    let c = n.positionAt(s + l),
      u = n.positionAt(s + l + t.length),
      f = new Ya.Range(c, u)
    return Promise.resolve([
      {
        name: n.getText(f),
        kind: Ya.SymbolKind.String,
        range: Ex(f),
        selectionRange: Ex(f),
        detail: "",
        tags: [],
        children: [],
      },
    ])
  }
  return Promise.resolve([])
}
var E4 = {
    keys: ["name"],
    threshold: 0.05,
    includeScore: true,
    useExtendedSearch: true,
    isCaseSensitive: true,
  },
  Fmt = 1e3 * 5,
  Qmt = 2e4,
  YM = class extends DisposableContainer {
    constructor(r, n, i, s) {
      super()
      this._globalState = r
      this._config = n
      this._fuzzyFsSearcher = i
      this._workspaceManager = s
      ;(this._logger = z("FuzzySymbolSearcher")),
        (this._fileTokensCache = new PersistentCache(
          this._globalState,
          "fuzzyBlobNamesToSymbols",
          { lru: { max: 1e3, fetchMethod: this._loadFileDetailSymbols } },
        ))
      let o = (0, ZCe.default)(
        async (a) => {
          let l = this._workspaceManager.resolvePathName(a.document.uri.fsPath)
          if (!l) return
          let c = this._workspaceManager.getBlobName(l)
          c && (this._fileTokensCache.remove(c), await this.warmupCache(c))
        },
        Fmt,
        { leading: true, trailing: true },
      )
      this.addDisposable(av.workspace.onDidChangeTextDocument(o)),
        this.addDisposables(
          av.window.onDidChangeActiveTextEditor(async (a) => {
            if (!a) return
            let l = this._workspaceManager.resolvePathName(
              a.document.uri.fsPath,
            )
            if (!l) return
            let c = this._workspaceManager.getBlobName(l)
            c && (await this.warmupCache(c))
          }),
        )
    }
    _fileTokensCache
    _logger
    findSymbolsRegex = async (r) => {
      if (!this._config.config.enableDebugFeatures)
        return { type: "find-symbol-response", data: [] }
      let n = r.data.searchScope.files,
        i = (
          await Promise.all(
            n.map(async (o) =>
              (await JCe(o, r.data.query)).map((l) => ({
                ...l,
                file: { ...o, range: undefined, fullRange: l.range },
              })),
            ),
          )
        ).flat(),
        s = jCe(i, r.data.query, { fuseSearch: { limit: 1 }, fuseInit: E4 })
      return { type: "find-symbol-response", data: s }
    }
    findSymbols = async (r) => {
      if (!Nmt(r.data.query)) return { type: "find-symbol-response", data: [] }
      let n = await this.getAllFilteredTokens(r.data.searchScope.files ?? [], {
          filter: true,
          forceRefresh: false,
        }),
        i = jCe(n, r.data.query, { fuseSearch: { limit: 1 }, fuseInit: E4 })
      return { type: "find-symbol-response", data: i }
    }
    warmupCache = async (r) => {
      let n = this._workspaceManager.getAllPathNames(r)[0]
      if (!n) return
      let i = { repoRoot: n.rootPath, pathName: n.relPath }
      await this._getAllFileTokens(i)
    }
    getAllFilteredTokens = async (r, n) => {
      let i = async (s) => {
        let o = await this._getAllFileTokens(s, n.forceRefresh)
        if (!o) return []
        if (!n.filter || !s.fullRange) return o
        let a = _x(s.fullRange)
        return o.filter((l) => {
          let c = _x(l.range)
          return a.contains(c)
        })
      }
      return (await Promise.all(r.map(i))).flat()
    }
    _loadFileDetailSymbols = async (r, n, { context: i }) => {
      let s = av.Uri.file(i.absPath),
        o = true,
        a = new Promise((l) =>
          setTimeout(() => {
            l(undefined), (o = false)
          }, i.timeoutMs),
        )
      for (; o; )
        try {
          let l = new Promise((u) => setTimeout(u, 4e3)),
            c = await Promise.race([zCe(s), a])
          if (c === undefined || c.length > 0) return c ?? []
          await l
        } catch (l) {
          return (
            this._logger.error(
              `Failed to load symbols for ${i.absPath}: ${l instanceof Error ? l.message : String(l)}`,
            ),
            []
          )
        }
      return []
    }
    _getAllFileTokens = async (r, n = false) => {
      let i = this._getCurrFileDetails(r)
      if (i === undefined) return []
      let s = this._getCurrBlobName(i)
      if (!s) return []
      try {
        let o = await this._fileTokensCache.cache.fetch(s, {
          context: { absPath: GM(i), blobName: s, timeoutMs: Qmt },
          forceRefresh: n,
        })
        return o
          ? o.map((a) => ({
              name: a.name,
              kind: a.kind,
              range: a.range,
              selectionRange: a.selectionRange,
              detail: a.detail,
              tags: a.tags || [],
              children: [],
              file: { ...r, range: undefined, fullRange: a.range },
            }))
          : []
      } catch (o) {
        let a = o instanceof Error ? o.message : String(o)
        return (
          this._logger.error(`Failed to read file tokens for ${s}: ${a}`), []
        )
      }
    }
    _getCurrBlobName = (r) => {
      let n = new QualifiedPathName(r.repoRoot, r.pathName)
      return this._workspaceManager.getBlobName(n)
    }
    _getCurrFileDetails = (r) => {
      let n = this._workspaceManager.getAllQualifiedPathNames(r.pathName)
      return n.length
        ? { ...r, repoRoot: n[0].rootPath, pathName: n[0].relPath }
        : undefined
    }
  }
function jCe(e, t, r) {
  return new Do(e, { ...E4, ...r.fuseInit, keys: ["name"] })
    .search(`${t}$`, r.fuseSearch)
    .map((s) => s.item)
}
function Nmt(e) {
  return e.length > 0 && !e.match(/[/.\s]/)
}
var XCe = q(require("fs")),
  ebe = q(Yf()),
  _4 = q(require("path")),
  Ka = q(require("vscode"))
var ig = class extends DisposableContainer {
  constructor(r, n, i) {
    super()
    this._config = r
    this._flags = n
    this._clientMetricsReporter = i
    this._initializeWorkspaceWatchers(),
      this.addDisposable(
        Ka.workspace.onDidChangeWorkspaceFolders((s) => {
          s.removed.forEach((o) => {
            let a = this._workspaceWatchers.get(o.uri.fsPath)
            a &&
              (a.dispose(),
              this._workspaceWatchers.delete(o.uri.fsPath),
              this._workspaceGuidelinesContent.delete(o.uri.fsPath))
          }),
            s.added.forEach((o) => {
              this._initializeWorkspaceWatcher(o.uri.fsPath)
            })
        }),
      ),
      (this._userGuidelinesContent =
        this._config?.config?.chat.userGuidelines || ""),
      this.addDisposable(
        this._config.onDidChange(() => {
          let s = this._userGuidelinesContent
          ;(this._userGuidelinesContent =
            this._config?.config?.chat.userGuidelines || ""),
            this._guidelinesChangedEmitter.fire(),
            s === "" && this._userGuidelinesContent !== ""
              ? this._reportMetric("chat-set-user-guidelines")
              : s !== "" &&
                this._userGuidelinesContent === "" &&
                this._reportMetric("chat-clear-user-guidelines")
        }),
      )
  }
  _workspaceGuidelinesContent = new Map()
  _workspaceWatchers = new Map()
  _userGuidelinesContent = ""
  _guidelinesChangedEmitter = new Ka.EventEmitter()
  get onDidChange() {
    return this._guidelinesChangedEmitter.event
  }
  _initializeWorkspaceWatchers() {
    Ka.workspace.workspaceFolders &&
      Ka.workspace.workspaceFolders.forEach((r) => {
        this._initializeWorkspaceWatcher(r.uri.fsPath)
      })
  }
  _initializeWorkspaceWatcher(r) {
    let n = _4.join(r, ".augment-guidelines")
    this._updateWorkspaceContent(r)
    let i = Ka.workspace.createFileSystemWatcher(n)
    this.addDisposable(i)
    let s = () => this._updateWorkspaceContent(r)
    i.onDidChange(s),
      i.onDidCreate(s),
      i.onDidDelete(() => {
        this._workspaceGuidelinesContent.set(r, "")
      }),
      this._workspaceWatchers.set(r, i)
  }
  _updateWorkspaceContent(r) {
    try {
      let n = _4.join(r, ".augment-guidelines"),
        i = this._workspaceGuidelinesContent.get(r) || "",
        s = XCe.readFileSync(n, "utf8")
      this._workspaceGuidelinesContent.set(r, s),
        this._guidelinesChangedEmitter.fire(),
        i === "" && s !== ""
          ? this._reportMetric("chat-set-workspace-guidelines")
          : i !== "" &&
            s === "" &&
            this._reportMetric("chat-clear-workspace-guidelines")
    } catch {
      let n = this._workspaceGuidelinesContent.get(r) || ""
      this._workspaceGuidelinesContent.set(r, ""),
        n !== "" && this._reportMetric("chat-clear-workspace-guidelines")
    }
  }
  getWorkspaceGuidelinesContent(r) {
    return (
      (this._flags.currentFlags.enableGuidelines &&
        this._workspaceGuidelinesContent.get(r)) ||
      ""
    )
  }
  getActiveWorkspacePath(r) {
    let n = Ka.window.activeTextEditor
    if (!n) return
    let i = n.document.uri.fsPath
    return r.safeResolvePathName(i)?.rootPath
  }
  getCurrentWorkspaceGuidelinesContent(r) {
    let n = Ka.workspace.workspaceFolders
    if (!n || n.length === 0) return ""
    if (n.length === 1)
      return this.getWorkspaceGuidelinesContent(n[0].uri.fsPath)
    let i = this.getActiveWorkspacePath(r)
    return i ? this.getWorkspaceGuidelinesContent(i) : ""
  }
  getUserGuidelinesContent() {
    return this._flags.currentFlags.enableGuidelines
      ? this._userGuidelinesContent
      : ""
  }
  getGuidelinesStates() {
    return this._flags.currentFlags.enableGuidelines
      ? {
          userGuidelines: {
            enabled: this._userGuidelinesContent.length > 0,
            overLimit:
              this._userGuidelinesContent.length >
              this._flags.currentFlags.userGuidelinesLengthLimit,
            contents: this._userGuidelinesContent,
            lengthLimit: this._flags.currentFlags.userGuidelinesLengthLimit,
          },
          workspaceGuidelines: Array.from(
            this._workspaceGuidelinesContent.entries(),
          ).map(([r, n]) => ({
            workspaceFolder: r,
            enabled: n.length > 0,
            overLimit:
              n.length >
              this._flags.currentFlags.workspaceGuidelinesLengthLimit,
            lengthLimit:
              this._flags.currentFlags.workspaceGuidelinesLengthLimit,
          })),
        }
      : {
          userGuidelines: {
            enabled: false,
            overLimit: false,
            contents: "",
            lengthLimit: this._flags.currentFlags.userGuidelinesLengthLimit,
          },
        }
  }
  _reportMetric = (0, ebe.default)(
    (r) => {
      this._clientMetricsReporter.reportWebviewClientMetric({
        webviewName: "chat",
        client_metric: r,
        value: 1,
      })
    },
    1e3,
    { leading: true, trailing: false },
  )
  static updateUserGuidelines(r) {
    Ka.workspace
      .getConfiguration("augment.chat")
      .update("userGuidelines", r.trim(), Ka.ConfigurationTarget.Global)
  }
}
var Em = q(require("vscode"))
var x4 = ((u) => (
    (u.webSearchV1 = "google_search"),
    (u.webSearch = "web-search"),
    (u.gitHub = "github-api"),
    (u.linear = "linear"),
    (u.notion = "notion"),
    (u.jira = "jira"),
    (u.confluence = "confluence"),
    (u.supabase = "supabase"),
    (u.glean = "glean"),
    (u.mcp = "mcp"),
    u
  ))(x4 || {}),
  Umt = new Set(ToolType ? Object.values(ToolType) : [])
var Omt = new Set(x4 ? Object.values(x4) : [])
var qmt = new Set(Hi ? Object.values(Hi) : [])
var hUt = new Set([...Umt, ...Omt, ...qmt])
var tbe = q(require("vscode"))
var KM = class extends op {
  constructor(r, n, i = 0.2) {
    super(r, i)
    this._workspaceManager = n
  }
  _maxDiagnosticDelayMs = 3e3
  async _addDiagnosticsToResponse(r, n) {
    if (r.isError) return r
    try {
      let i = await this._waitForNewDiagnostics(n),
        s = this._filterDiagnosticsMap(i, n),
        o = await bM(s, this._workspaceManager),
        a =
          o.trim() === ""
            ? "The IDE reports no new issues."
            : `The IDE reports the following new issues:
${o}`
      return cr(`${r.text}

${a}`)
    } catch {
      return r
    }
  }
  async handleStrReplace(r, n, i, s) {
    let o = this._getDiagnostics(),
      a = await super.handleStrReplace(r, n, i, s)
    return this._addDiagnosticsToResponse(a, o)
  }
  async handleInsert(r, n, i, s) {
    let o = this._getDiagnostics(),
      a = await super.handleInsert(r, n, i, s)
    return this._addDiagnosticsToResponse(a, o)
  }
  _getDiagnostics() {
    let r = new Map()
    return (
      tbe.languages.getDiagnostics().forEach(([n, i]) => {
        i.length > 0 && r.set(n.fsPath, i)
      }),
      r
    )
  }
  _filterDiagnosticsMap(r, n) {
    let i = new Map()
    return (
      r.forEach((s, o) => {
        let a = n.get(o) ?? [],
          l = this._filterDiagnostics(s, a)
        l.length > 0 && i.set(o, l)
      }),
      i
    )
  }
  _filterDiagnostics(r, n) {
    return r.filter(
      (i) =>
        !n.some(
          (s) =>
            i.range.start.line === s.range.start.line &&
            i.range.end.line === s.range.end.line &&
            i.message === s.message &&
            i.severity === s.severity,
        ),
    )
  }
  _hasDifferentDiagnostics(r, n) {
    if (r.size !== n.size) return true
    for (let [i, s] of r) {
      let o = n.get(i)
      if (!o || s.length !== o.length) return true
      for (let a = 0; a < s.length; a++) {
        let l = s[a],
          c = o[a]
        if (
          l.range.start.line !== c.range.start.line ||
          l.range.end.line !== c.range.end.line ||
          l.message !== c.message ||
          l.severity !== c.severity
        )
          return true
      }
    }
    return false
  }
  async _waitForNewDiagnostics(r) {
    let n = Date.now()
    for (; Date.now() - n < this._maxDiagnosticDelayMs; ) {
      let i = this._getDiagnostics()
      if (this._hasDifferentDiagnostics(i, r)) return i
      await sleep(1e3)
    }
    return this._getDiagnostics()
  }
}
var ibe = require("child_process"),
  bm = q(require("path")),
  Ut = q(require("vscode"))
function Vmt(e, t) {
  return (
    e.name === t.name &&
    e.path === t.path &&
    e.args?.join(" ") === t.args?.join(" ") &&
    Object.keys(e.env ?? {}).join(" ") === Object.keys(t.env ?? {}).join(" ") &&
    Object.values(e.env ?? {}).join(" ") ===
      Object.values(t.env ?? {}).join(" ")
  )
}
var zM = class e extends DisposableContainer {
    constructor(r, n, i) {
      super()
      this._extensionRoot = r
      this._globalState = n
      this._enableStart = i
      this.addDisposable(
        this._globalState.onDidChangeFileStorage("terminalSettings", (o) => {
          ;(this._terminalSettings = o.value),
            this._logger.verbose("Terminal settings changed"),
            Mr().reportEvent({
              eventName: MemoryEventType.vsCodeTerminalSettingsChanged,
              conversationId: "",
            }),
            this._checkAndUpdateShell()
        }),
      ),
        this._globalState
          .load("terminalSettings")
          .then((o) => {
            ;(this._terminalSettings = o ?? { supportedShells: [] }),
              this._logger.verbose("Initial terminal settings loaded"),
              this._checkAndUpdateShell()
          })
          .catch((o) => {
            this._logger.debug(
              `Error loading initial terminal settings: ${o.message}`,
            ),
              Mr().reportEvent({
                eventName: MemoryEventType.vsCodeTerminalErrorLoadingSettings,
                conversationId: "",
              }),
              (this._terminalSettings = { supportedShells: [] })
          }),
        this._initializeShells()
      let s = Ut.window
      s.onDidEndTerminalShellExecution && eo("1.93.0")
        ? (this._logger.verbose(
            "Registering for onDidEndTerminalShellExecution.",
          ),
          (this._shellExecutionListener = s.onDidEndTerminalShellExecution(
            async (o) => {
              this._logger.verbose(
                `Got onDidEndTerminalShellExecution event: ${o.execution?.commandLine?.value}, ${o.execution?.commandLine?.confidence}, ${o.terminal?.name}`,
              )
              for (let [a, l] of Array.from(this._processes).reverse())
                if (
                  (this._logger.verbose(
                    `Checking process ${a} for completion.`,
                  ),
                  l.terminal === o.terminal && !l.killed && l.exitCode === null)
                ) {
                  if (
                    (this._logger.verbose(`Process ${a} is complete.`),
                    (l.exitCode = o.exitCode ?? null),
                    l.readStream && o.execution.commandLine.value === l.command)
                  ) {
                    await sleep(10),
                      this._logger.debug(
                        `Reading exact output for process ${a}`,
                      )
                    let u = ""
                    for await (let f of l.readStream) u += f
                    this._isBuggyOutput(u)
                      ? (this._logger.debug(
                          `Buggy output detected for process ${a}. Please upgrade VSCode.`,
                        ),
                        Mr().reportEvent({
                          eventName: MemoryEventType.vsCodeTerminalBuggyOutput,
                          conversationId: "",
                        }),
                        (l.output = await this._getOutputFromClipboard(a)))
                      : (l.output = w4(NI(u, this._maxOutputLength)))
                  } else
                    o.execution.commandLine.value !== l.command &&
                      (this._logger.debug(
                        `Command line for process ${a} does not match. Expected ${l.command} but got ${o.execution.commandLine.value}`,
                      ),
                      Mr().reportEvent({
                        eventName: MemoryEventType.vsCodeTerminalBuggyExecutionEvents,
                        conversationId: "",
                      })),
                      (l.output = await this._getOutputFromClipboard(a))
                  l.terminal !== e._longRunningTerminal && l.terminal.dispose(),
                    (l.killed = true)
                  let c = this._waitResolvers.get(a)
                  c && c({ output: l.output, returnCode: l.exitCode })
                  break
                }
            },
          )))
        : Mr().reportEvent({
            eventName: MemoryEventType.vsCodeTerminalShellIntegrationNotAvailable,
            conversationId: "",
          }),
        this.addDisposable(
          Ut.window.onDidCloseTerminal(async (o) => {
            this._logger.verbose(`Got onDidCloseTerminal event: ${o.name}`)
            for (let [a, l] of this._processes)
              if (l.terminal === o && !l.killed) {
                l.readStream &&
                  (l.output =
                    await this._getOutputFromPossiblyIncompleteProcess(l, a)),
                  (l.killed = true),
                  (l.exitCode = o.exitStatus?.code ?? -1)
                let c = this._waitResolvers.get(a)
                c && c({ output: l.output, returnCode: l.exitCode })
                break
              }
          }),
        )
    }
    static _shellInfo = e._getDefaultShell()
    _processes = new Map()
    _waitResolvers = new Map()
    _nextId = 1
    _shellExecutionListener
    _activePoller
    static _longRunningTerminal
    _terminalNeedsUpdate = false
    _logger = z("TerminalProcessTools")
    _maxOutputLength = 64 * 1024
    _supportedShells = []
    _terminalSettings = { supportedShells: [] }
    _checkAndUpdateShell() {
      try {
        let r = this._terminalSettings.selectedShell
        if (r && r !== e._shellInfo.friendlyName) {
          let n = this._supportedShells.find(
            (i) => i.shellInfo.friendlyName === r,
          )
          if (n)
            return (
              (e._shellInfo = n.shellInfo),
              (this._terminalNeedsUpdate = true),
              this._logger.debug(
                `Updated shell to saved preference: ${e._shellInfo.friendlyName}`,
              ),
              true
            )
        }
      } catch (r) {
        this._logger.debug(`Error checking for shell updates: ${r.message}`),
          Mr().reportEvent({
            eventName: MemoryEventType.vsCodeTerminalErrorCheckingForShellUpdates,
            conversationId: "",
          })
      }
      return false
    }
    async launch(r, n, i, s) {
      this._checkAndUpdateShell()
      let o = this._nextId++,
        a = false,
        l
      if (
        (s
          ? (!e._longRunningTerminal || e._longRunningTerminal.exitStatus
              ? ((e._longRunningTerminal = await this._createTerminal(
                  "Augment",
                  n,
                )),
                (a = true))
              : e._longRunningTerminal && this._terminalNeedsUpdate
                ? (e._longRunningTerminal.dispose(),
                  (e._longRunningTerminal = await this._createTerminal(
                    "Augment",
                    n,
                  )),
                  (this._terminalNeedsUpdate = false),
                  (a = true))
                : e._longRunningTerminal &&
                  !this._terminalHasShellIntegration(e._longRunningTerminal) &&
                  (e._longRunningTerminal.dispose(),
                  (e._longRunningTerminal = await this._createTerminal(
                    `Augment - ${r}`,
                    n,
                  )),
                  (a = true)),
            (l = e._longRunningTerminal))
          : (l = await this._createTerminal(`Augment - ${r}`, n)),
        s &&
          Array.from(this._processes.values()).some(
            (f) => f.terminal === l && f.exitCode === null && !f.killed,
          ))
      )
        return `Cannot launch another waiting process while another waiting process is running. The id of the existing waiting process is ${o}.
Please wait until this process is complete (you can use a tool for this purpose), or launch the new process as a background process with \`wait=false\`.`
      l.show(true)
      let c = ""
      if (l === e._longRunningTerminal && !a) {
        let f = ""
        ;(!eo("1.98.0") || !this._isTerminalBasicallySupported()) &&
          (f = this.shellName === "powershell" ? "#" : ":"),
          this._terminalHasShellIntegration(l)
            ? l.shellIntegration.executeCommand(f)
            : l.sendText(f)
        let p = null,
          g = false
        await executeWithTimeout(
          new Promise((m) => {
            p = setInterval(() => {
              g ||
                ((g = true),
                (async () => {
                  try {
                    this._logger.verbose("Polling for noop command result"),
                      (c = (await this._getLastCommand(l)).lastCommand),
                      c === f &&
                        (p && (clearInterval(p), (p = null)),
                        this._logger.debug(
                          "Successfully got noop command result.",
                        ),
                        m(undefined))
                  } finally {
                    g = false
                  }
                })())
            }, 100)
          }),
          1e3,
        )
          .catch(() => {
            this._logger.debug(
              "Timed out waiting for noop command to complete",
            ),
              Mr().reportEvent({
                eventName: MemoryEventType.vsCodeTerminalTimedOutWaitingForNoopCommand,
                conversationId: "",
              })
          })
          .finally(() => {
            p && (clearInterval(p), (p = null))
          })
      }
      let u = {
        terminal: l,
        command: r,
        lastCommand: c,
        output: "",
        killed: false,
        readStream: undefined,
        exitCode: null,
      }
      if ((this._processes.set(o, u), this._terminalHasShellIntegration(l))) {
        let f = l.shellIntegration.executeCommand(r)
        ;(u.readStream = f.read()),
          this._logger.debug(
            `Using existing shell integration for command: ${r}`,
          )
      } else if (
        this._isTerminalBasicallySupported() &&
        Ut.window.onDidChangeTerminalShellIntegration
      ) {
        let f
        ;(f = Ut.window.onDidChangeTerminalShellIntegration((p) => {
          if (p.terminal === l && p.shellIntegration && !u.readStream) {
            let g = p.shellIntegration.executeCommand(r)
            ;(u.readStream = g.read()),
              this._logger.debug(`Using shell integration for command: ${r}`),
              f && (f.dispose(), (f = undefined))
          }
        })),
          setTimeout(() => {
            u.readStream ||
              (l.sendText(r),
              this._logger.debug(
                `Failed to use shell integration for command: ${r}`,
              ),
              Mr().reportEvent({
                eventName: MemoryEventType.vsCodeTerminalFailedToUseShellIntegration,
                conversationId: "",
              })),
              f && (f.dispose(), (f = undefined))
          }, 2e3)
      } else
        this._logger.debug(`Not using shell integration for command: ${r}`),
          l.sendText(r)
      return (
        i.addEventListener("abort", () => {
          this.kill(o)
        }),
        o
      )
    }
    async _createTerminal(r, n) {
      let i =
        this.shellName === "bash" || this.shellName === "zsh"
          ? { PAGER: "cat", LESS: "-FX", GIT_PAGER: "cat" }
          : {}
      e._shellInfo.env && (i = { ...i, ...e._shellInfo.env }),
        i && Object.keys(i).length === 0 && (i = undefined)
      let s = Ut.window.createTerminal({
        name: r,
        shellPath: e._shellInfo.path ?? this.shellName,
        shellArgs: e._shellInfo.args,
        cwd: n,
        env: i,
        iconPath: {
          light: Ut.Uri.joinPath(
            this._extensionRoot,
            "media",
            "panel-icon-light.svg",
          ),
          dark: Ut.Uri.joinPath(
            this._extensionRoot,
            "media",
            "panel-icon-dark.svg",
          ),
        },
        isTransient: true,
      })
      return (
        this._terminalSettings.startupScript &&
          this._terminalSettings.startupScript.trim() &&
          (this._terminalHasShellIntegration(s)
            ? s.shellIntegration.executeCommand(
                this._terminalSettings.startupScript,
              )
            : s.sendText(this._terminalSettings.startupScript),
          await sleep(100)),
        s
      )
    }
    async kill(r) {
      let n = this._processes.get(r)
      if (!(!n || n.killed))
        return (
          this._logger.verbose(`Killing process ${r}`),
          n.terminal === e._longRunningTerminal
            ? n.terminal.sendText("", false)
            : n.terminal.dispose(),
          (n.killed = true),
          (n.exitCode = -1),
          (n.output = await this._getOutputFromPossiblyIncompleteProcess(n, r)),
          n.output
        )
    }
    isInLongRunningTerminal(r) {
      let n = this._processes.get(r)
      return !!n && n.terminal === e._longRunningTerminal
    }
    async readOutput(r) {
      let n = this._processes.get(r)
      return n
        ? n.exitCode !== null || n.killed
          ? { output: n.output, returnCode: n.exitCode }
          : (this._logger.verbose(`Reading output for process ${r}`),
            {
              output: await this._getOutputFromPossiblyIncompleteProcess(n, r),
              returnCode: n.exitCode,
            })
        : undefined
    }
    writeInput(r, n) {
      let i = this._processes.get(r)
      return !i || i.killed ? false : (i.terminal.sendText(n), true)
    }
    listProcesses() {
      let r = []
      for (let [n, i] of this._processes.entries()) {
        let s = i.killed ? "killed" : "running"
        r.push({ id: n, command: i.command, state: s, returnCode: i.exitCode })
      }
      return r
    }
    waitForProcess(r, n, i) {
      return new Promise((s) => {
        ;(async () => {
          let o = this._processes.get(r)
          if (!o) {
            s({ output: "", returnCode: null })
            return
          }
          if (o.exitCode !== null) {
            s({ output: o.output, returnCode: o.exitCode })
            return
          }
          let a = setTimeout(() => {
            this._logger.verbose(
              `Process ${r} still running after ${n} seconds.  Timing out.`,
            ),
              Mr().reportEvent({
                eventName: MemoryEventType.vsCodeTerminalWaitTimeout,
                conversationId: "",
              }),
              this._waitResolvers.delete(r),
              this._activePoller &&
                (clearInterval(this._activePoller),
                (this._activePoller = undefined)),
              this.readOutput(r).then((c) => {
                s({ output: c?.output ?? "", returnCode: null })
              })
          }, n * 1e3)
          if (
            (this._logger.verbose(
              `Waiting for process ${r} to complete.  Shell listener is ${this._shellExecutionListener ? "registered" : "not registered"}`,
            ),
            o.lastCommand === o.command)
          ) {
            this._logger.debug("Last command is the same as the current one."),
              Mr().reportEvent({
                eventName: MemoryEventType.vsCodeTerminalLastCommandIsSameAsCurrent,
                conversationId: "",
              })
            let c = await this.readOutput(r)
            c
              ? s(c)
              : (this._logger.debug(`Failed to read output for process ${r}`),
                Mr().reportEvent({
                  eventName: MemoryEventType.vsCodeTerminalFailedToReadOutput,
                  conversationId: "",
                }),
                s({ output: "", returnCode: null }))
          } else
            this._activePoller &&
              (clearInterval(this._activePoller),
              (this._activePoller = undefined)),
              (this._activePoller = setInterval(() => {
                ;(async () => {
                  this._logger.verbose(
                    `Polling to see if process ${r} is done.`,
                  )
                  let { lastCommand: c, isComplete: u } =
                    await this._getLastCommand(o.terminal)
                  if (u || (u === undefined && c === o.command)) {
                    this._logger.debug(
                      `Polling determined process ${r} is done.`,
                    ),
                      Mr().reportEvent({
                        eventName:
                          MemoryEventType.vsCodeTerminalPollingDeterminedProcessIsDone,
                        conversationId: "",
                      }),
                      clearTimeout(a),
                      clearInterval(this._activePoller),
                      (this._activePoller = undefined)
                    let f = await this.readOutput(r)
                    ;(o.output = f?.output ?? ""),
                      (o.exitCode = f?.returnCode ?? null),
                      (o.killed = true),
                      f
                        ? s(f)
                        : (this._logger.debug(
                            `Failed to read output for process ${r}`,
                          ),
                          Mr().reportEvent({
                            eventName: MemoryEventType.vsCodeTerminalFailedToReadOutput,
                            conversationId: "",
                          }),
                          s({ output: "", returnCode: null }))
                  }
                })()
              }, 1e3)),
              this._waitResolvers.set(r, (c) => {
                clearTimeout(a),
                  clearInterval(this._activePoller),
                  (this._activePoller = undefined),
                  this._waitResolvers.delete(r),
                  s(c)
              })
          let l = () => {
            clearTimeout(a),
              clearInterval(this._activePoller),
              (this._activePoller = undefined),
              this._waitResolvers.delete(r),
              s({ output: "", returnCode: null })
          }
          i.addEventListener("abort", l)
        })()
      })
    }
    async _getOutputFromPossiblyIncompleteProcess(r, n) {
      if (r.readStream) {
        this._logger.debug(`Reading exact intermediate output for process ${n}`)
        let i = ""
        try {
          let s = async (l) => {
              let c = new Promise((u) => {
                setTimeout(() => u({ done: true, value: undefined }), 100)
              })
              return Promise.race([l.next(), c])
            },
            o = r.readStream[Symbol.asyncIterator](),
            a = await s(o)
          for (; !a.done; )
            a.value !== undefined && (i += a.value), (a = await s(o))
        } catch (s) {
          this._logger.debug(
            `Error reading stream for process ${n}: ${s.message ?? ""}`,
          ),
            Mr().reportEvent({
              eventName: MemoryEventType.vsCodeTerminalFailedToReadOutput,
              conversationId: "",
            })
        }
        return w4(NI(i, this._maxOutputLength))
      } else
        return (
          r.terminal.exitStatus || r.terminal.show(true),
          await this._getOutputFromClipboard(n)
        )
    }
    async _getOutputFromClipboard(r) {
      let n = this._processes.get(r)?.terminal
      if (
        n &&
        n === e._longRunningTerminal &&
        !this._terminalHasShellIntegration(n)
      )
        return (await this._getLastCommandAndOutputFallback()).output
      Mr().reportEvent({
        eventName: MemoryEventType.vsCodeTerminalReadingApproximateOutput,
        conversationId: "",
      })
      let i = await Ut.env.clipboard.readText()
      await Ut.env.clipboard.writeText(""),
        await Ut.commands.executeCommand(
          "workbench.action.terminal.copyLastCommandOutput",
        )
      let s = await Ut.env.clipboard.readText()
      return (
        await Ut.env.clipboard.writeText(i),
        this._logger.verbose(
          `Read approximate output from clipboard got ${s.trim()}`,
        ),
        NI(s, this._maxOutputLength)
      )
    }
    async _getLastCommand(r) {
      if (
        r &&
        r === e._longRunningTerminal &&
        !this._terminalHasShellIntegration(r)
      ) {
        let {
          command: s,
          output: o,
          isComplete: a,
        } = await this._getLastCommandAndOutputFallback()
        return { lastCommand: s, isComplete: a }
      }
      let n = await Ut.env.clipboard.readText()
      await Ut.env.clipboard.writeText(""),
        await Ut.commands.executeCommand(
          "workbench.action.terminal.copyLastCommand",
        )
      let i = await Ut.env.clipboard.readText()
      return (
        await Ut.env.clipboard.writeText(n),
        this._logger.verbose(
          `Read last command from clipboard got ${i.trim()}`,
        ),
        { lastCommand: i }
      )
    }
    async _getLastCommandAndOutputFallback() {
      let r = await Ut.env.clipboard.readText()
      await Ut.env.clipboard.writeText(""),
        await Ut.commands.executeCommand(
          "workbench.action.terminal.selectToPreviousCommand",
        ),
        await Ut.commands.executeCommand(
          "workbench.action.terminal.copySelection",
        )
      let n = await Ut.env.clipboard.readText()
      await Ut.commands.executeCommand("workbench.action.terminal.selectAll"),
        await Ut.commands.executeCommand(
          "workbench.action.terminal.copyAndClearSelection",
        )
      let i = await Ut.env.clipboard.readText()
      await Ut.env.clipboard.writeText(r)
      let s = rbe[this.shellName] ?? rbe.bash,
        o =
          n
            .split(
              `
`,
            )
            .shift() ?? "",
        a = o.replace(s, "").trim(),
        f = n
          .slice(o.length + 1)
          .split(
            `
`,
          )
          .filter((m) => !s.test(m)).join(`
`),
        p = i
          .split(
            `
`,
          )
          .reverse()
          .find((m) => m.trim().length > 0),
        g = p != null && p.replace(s, "").trim().length === 0
      return (
        this._logger.verbose(
          `Reading last command and output from clipboard got ${n.trim()}, command: ${a}, output: ${f.trim()}, isComplete: ${g}`,
        ),
        { command: a, output: f, isComplete: g }
      )
    }
    closeAllProcesses() {
      for (let r of this._processes.values())
        r.killed ||
          (r.terminal === e._longRunningTerminal
            ? e._longRunningTerminal.sendText("", false)
            : r.terminal.dispose())
      this._processes.clear(),
        this._activePoller &&
          (clearInterval(this._activePoller), (this._activePoller = undefined))
    }
    cleanup() {
      this.closeAllProcesses(),
        this._shellExecutionListener &&
          (this._shellExecutionListener.dispose(),
          (this._shellExecutionListener = undefined)),
        this._cleanupTempDirectories(),
        this.dispose()
    }
    async _cleanupTempDirectories() {
      for (let r of this._supportedShells)
        if (r.shellInfo.tempDir)
          try {
            await yM(r.shellInfo.tempDir)
          } catch (n) {
            this._logger.debug(
              `Error cleaning up temporary directory: ${n.message}`,
            ),
              Mr().reportEvent({
                eventName: MemoryEventType.vsCodeTerminalErrorCleaningUpTempDir,
                conversationId: "",
              })
          }
      if (e._shellInfo.tempDir)
        try {
          await yM(e._shellInfo.tempDir)
        } catch (r) {
          this._logger.debug(
            `Error cleaning up current shell temporary directory: ${r.message}`,
          ),
            Mr().reportEvent({
              eventName: MemoryEventType.vsCodeTerminalErrorCleaningUpTempDir,
              conversationId: "",
            })
        }
    }
    get _currentCapability() {
      if (this._supportedShells.length > 0) {
        let r = this._supportedShells.find(
          (n) =>
            n.shellInfo.name === e._shellInfo.name &&
            n.shellInfo.path === e._shellInfo.path,
        )
        if (r) return r.capability
      }
      return { capability: 1, details: "Capability information not available" }
    }
    _isTerminalBasicallySupported() {
      let r = this._currentCapability.capability
      return this._isBasicallySupported(r)
    }
    _isBasicallySupported(r) {
      return r === 10 || r === 9 || r === 8 || r === 7 || r === 6
    }
    getLongRunningTerminalInfo() {
      if (!this._isTerminalBasicallySupported() || !e._longRunningTerminal)
        return
      let r = e._longRunningTerminal.shellIntegration?.cwd
      if (r instanceof Ut.Uri)
        return { terminal_id: 0, current_working_directory: r.fsPath }
    }
    async _initializeShells() {
      let r = e._shellInfo
      try {
        if (
          ((this._supportedShells = await this._findSupportedShells()),
          this._supportedShells.length > 0)
        ) {
          let n = this._getVSCodeDefaultProfile()
          this._supportedShells.sort((o, a) => {
            let l = a.capability.capability - o.capability.capability
            if (l !== 0) return l
            if (n) {
              if (o.shellInfo.name === n.name && a.shellInfo.name !== n.name)
                return -1
              if (a.shellInfo.name === n.name && o.shellInfo.name !== n.name)
                return 1
            }
            return 0
          })
          let i = this._supportedShells
            .map((o) => ({
              name: o.shellInfo.name,
              path: o.shellInfo.path,
              friendlyName: o.shellInfo.friendlyName,
              supportString:
                o.capability.capability === 10
                  ? "Fully supported"
                  : this._isBasicallySupported(o.capability.capability)
                    ? "Partially supported"
                    : "Not supported",
            }))
            .filter(
              (o, a, l) =>
                a === l.findIndex((c) => c.friendlyName === o.friendlyName),
            )
          ;(this._terminalSettings.supportedShells = i),
            await this._globalState.save(
              "terminalSettings",
              this._terminalSettings,
            )
          let s = this._terminalSettings.selectedShell
          if (s) {
            let o = this._supportedShells.find(
              (a) => a.shellInfo.friendlyName === s,
            )
            o
              ? ((e._shellInfo = o.shellInfo),
                this._logger.debug(
                  `Shell initialization complete. Using saved shell preference: ${e._shellInfo.friendlyName} (${lv[o.capability.capability]})`,
                ))
              : ((e._shellInfo = this._supportedShells[0].shellInfo),
                this._logger.debug(
                  `Shell initialization complete. Saved shell '${s}' not found, using best available: ${e._shellInfo.friendlyName} (${lv[this._supportedShells[0].capability.capability]})`,
                ))
          } else
            (e._shellInfo = this._supportedShells[0].shellInfo),
              this._logger.debug(
                `Shell initialization complete. Using shell: ${e._shellInfo.friendlyName} (${lv[this._supportedShells[0].capability.capability]})`,
              )
        } else
          (e._shellInfo = e._getDefaultShell()),
            this._logger.debug(
              `Shell initialization complete. No supported shells found, using default: ${e._shellInfo.friendlyName}`,
            ),
            Mr().reportEvent({
              eventName: MemoryEventType.vsCodeTerminalNoSupportedShellsFound,
              conversationId: "",
            })
      } catch (n) {
        this._logger.debug(`Error initializing shells: ${n.message}`),
          (e._shellInfo = e._getDefaultShell()),
          this._logger.debug(
            `Shell initialization complete with errors. Using default shell: ${e._shellInfo.friendlyName}`,
          ),
          Mr().reportEvent({
            eventName: MemoryEventType.vsCodeTerminalErrorInitializingShells,
            conversationId: "",
          })
      }
      e._longRunningTerminal &&
        !Vmt(r, e._shellInfo) &&
        (this._terminalNeedsUpdate = true)
    }
    async _getAllShellsToCheck() {
      let r = [],
        n = this._getVSCodeDefaultProfile()
      n && r.push(n)
      let i = this._getVSCodeProfiles()
      for (let o of i)
        r.some((a) => a.name === o.name && a.path === o.path) || r.push(o)
      let s = await this._createZshShellInfo(i)
      return s && r.push(s), r
    }
    async _findSupportedShells() {
      let r = [],
        n = await this._getAllShellsToCheck(),
        i = Date.now() - this._enableStart
      i < 5e3 &&
        (this._logger.debug(
          "First terminal initialization since VSCode startup, delaying shell capability checks",
        ),
        await sleep(5e3 - i))
      for (let s of n) {
        if (!MO(s.name) && !s.name.includes("powershell")) {
          this._logger.debug(`Skipping unsupported shell: ${s.name}`)
          continue
        }
        try {
          this._logger.debug(
            `Checking capabilities for shell: ${s.name} ${s.path || ""} ${s.args?.join(" ") || ""}`,
          )
          let o = new S4(s),
            a = await o.checkCapabilities()
          o.dispose(),
            this._logger.debug(
              `Shell ${s.name} capability: ${lv[a.capability]} - ${a.details}`,
            ),
            r.push({ shellInfo: s, capability: a })
        } catch (o) {
          this._logger.debug(
            `Error checking capabilities for shell ${s.name}: ${o.message}`,
          ),
            Mr().reportEvent({
              eventName: MemoryEventType.vsCodeTerminalErrorCheckingShellCapability,
              conversationId: "",
            })
        }
      }
      return r
    }
    static _getDefaultShell() {
      let r = h0(process.platform)
      return {
        name: r,
        path: undefined,
        args: undefined,
        env: undefined,
        friendlyName: r + " (default)",
        tempDir: undefined,
      }
    }
    async _createZshShellInfo(r) {
      if (process.platform !== "darwin" && process.platform !== "linux") return
      let n = r.find((i) => i.name === "zsh")?.path
      if (n)
        try {
          let i = await this._createZshTempEnvironment()
          return {
            name: "zsh",
            path: n,
            args: undefined,
            env: { ZDOTDIR: i },
            friendlyName: "zsh (vanilla)",
            tempDir: i,
          }
        } catch (i) {
          this._logger.debug(
            `Failed to create temporary zsh environment: ${i.message}`,
          ),
            Mr().reportEvent({
              eventName: MemoryEventType.vsCodeTerminalErrorCreatingZshEnvironment,
              conversationId: "",
            })
          return
        }
    }
    async _createZshTempEnvironment() {
      let r = await aye("augment-zsh-")
      return (
        await oa(
          bm.default.join(r, ".zshrc"),
          `# Empty .zshrc file created by Augment
`,
        ),
        r
      )
    }
    _getOSSection() {
      return process.platform === "win32"
        ? "windows"
        : process.platform === "darwin"
          ? "osx"
          : "linux"
    }
    _processShellInfo(r, n) {
      if (r.name === "git bash" && process.platform === "win32") {
        let i = this._getGitBashInfo(r.path, r.args)
        if (!i) {
          n &&
            (this._logger.debug("Failed to find/use Git Bash path"),
            Mr().reportEvent({
              eventName: MemoryEventType.vsCodeTerminalFailedToFindGitBash,
              conversationId: "",
            }))
          return
        }
        ;(r.name = i.name), (r.path = i.path), (r.args = i.args)
      }
      if (r.name.includes("powershell") && process.platform === "win32") {
        let i = this._findPowerShellPath()
        if (!i) {
          n &&
            (this._logger.debug("Failed to find PowerShell path"),
            Mr().reportEvent({
              eventName: MemoryEventType.vsCodeTerminalFailedToFindPowerShell,
              conversationId: "",
            }))
          return
        }
        ;(r.name = "powershell"), (r.path = i)
      }
      if (r.name && MO(r.name)) return { ...r, friendlyName: r.name }
      if (r.name) {
        n &&
          (this._logger.debug(`Unsupported shell: ${r.name}`),
          Mr().reportEvent({
            eventName: MemoryEventType.vsCodeTerminalUnsupportedVSCodeShell,
            conversationId: "",
          }))
        return
      }
    }
    _getVSCodeDefaultProfile() {
      let r = this._getOSSection(),
        i = Ut.workspace
          .getConfiguration("terminal.integrated.defaultProfile")
          .get(r)
      if (typeof i == "string") {
        let s = Ut.workspace.getConfiguration(
            `terminal.integrated.profiles.${r}.${i}`,
          ),
          o = i.trim().toLowerCase(),
          a = s.get("path"),
          l = s.get("args")
        return this._processShellInfo({ name: o, path: a, args: l }, true)
      }
    }
    _getVSCodeProfiles() {
      let r = [],
        n = this._getOSSection(),
        i = Ut.workspace.getConfiguration(`terminal.integrated.profiles.${n}`),
        s = Object.keys(i)
      for (let o of s) {
        let a = i.get(o)
        if (!a) continue
        let l = o.toLowerCase(),
          c = a.path,
          u = a.args,
          f = this._processShellInfo({ name: l, path: c, args: u }, false)
        f && r.push(f)
      }
      return r
    }
    _getGitBashInfo(r, n) {
      let i = r
      return (
        i || (i = this._findGitBashPath()),
        !i || !fileExists(i)
          ? undefined
          : {
              name: "bash",
              path: i,
              args: n ?? ["--login", "-i"],
              friendlyName: "Git Bash",
            }
      )
    }
    _findGitBashPath() {
      let r = [
        `${process.env.ProgramFiles}`,
        `${process.env.ProgramW6432}`,
        `${process.env["ProgramFiles(x86)"]}`,
      ]
      for (let n of r) {
        if (!mM(n)) continue
        let i = [
          bm.default.join(n, "Git", "bin", "bash.exe"),
          bm.default.join(n, "Git", "usr", "bin", "bash.exe"),
        ]
        for (let s of i) if (fileExists(s)) return s
      }
    }
    _findPowerShellPath() {
      let r = [
          `${process.env.ProgramFiles}`,
          `${process.env.ProgramW6432}`,
          `${process.env["ProgramFiles(x86)"]}`,
        ],
        n,
        i
      for (let o of r) {
        let a = bm.default.join(o, "PowerShell")
        if (!(!mM(o) || !mM(a))) {
          for (let [l, c] of hm(a))
            if (c === "Directory" && l.match(/^\d+$/)) {
              let u = bm.default.join(a, l, "pwsh.exe")
              fileExists(u) && (!n || l > n) && ((n = l), (i = u))
            }
        }
      }
      if (i) return i
      let s = ["System32", "SysNative"]
      for (let o of s) {
        let a = bm.default.join(
          process.env.windir ?? "C:\\Windows",
          o,
          "WindowsPowerShell",
          "v1.0",
          "powershell.exe",
        )
        if (fileExists(a)) return a
      }
    }
    get shellName() {
      return e._shellInfo.name
    }
    _isBuggyOutput(r) {
      return this._currentCapability.capability === 9
        ? true
        : !eo("1.98.0") &&
            !r.includes("\x1B]633;D") &&
            !r.includes("\x1B]133;D")
    }
    _terminalHasShellIntegration(r) {
      return this._isTerminalBasicallySupported()
        ? r.shellIntegration !== undefined
        : false
    }
  },
  cv = class extends En {
    constructor(r, n) {
      super(ToolType.launchProcess, ToolSafetyLevel.Check)
      this._workspaceManager = r
      this.processTools = n
    }
    version = 2
    get description() {
      return `Launch a new process with a shell command. A process can be waiting (\`wait=true\`) or non-waiting (\`wait=false\`).

If \`wait=true\`, launches the process in an interactive terminal, and waits for the process to complete up to
\`max_wait_seconds\` seconds. If the process ends during this period, the tool call returns. If the timeout
expires, the process will continue running in the background but the tool call will return. You can then
interact with the process using the other process tools.

Note: Only one waiting process can be running at a time. If you try to launch a process with \`wait=true\`
while another is running, the tool will return an error.

If \`wait=false\`, launches a background process in a separate terminal. This returns immediately, while the
process keeps running in the background.

Notes:
- Use \`wait=true\` processes when the command is expected to be short, or when you can't
proceed with your task until the process is complete. Use \`wait=false\` for processes that are
expected to run in the background, such as starting a server you'll need to interact with, or a
long-running process that does not need to complete before proceeding with the task.
- If this tool returns while the process is still running, you can continue to interact with the process
using the other available tools. You can wait for the process, read from it, write to it, kill it, etc.
- You can use this tool to interact with the user's local version control system. Do not use the
retrieval tool for that purpose.
- If there is a more specific tool available that can perform the function, use that tool instead of
this one.

The OS is ${process.platform}. The shell is '${this.processTools.shellName}'.`
    }
    inputSchemaJson = JSON.stringify({
      type: "object",
      properties: {
        command: {
          type: "string",
          description: "The shell command to execute.",
        },
        wait: {
          type: "boolean",
          description: "Whether to wait for the command to complete.",
        },
        max_wait_seconds: {
          type: "number",
          description:
            "Number of seconds to wait for the command to complete. Only relevant when wait=true. 10 minutes may be a good default: increase from there if needed.",
        },
        cwd: {
          type: "string",
          description:
            "Working directory for the command. If not supplied, uses the current working directory.",
        },
      },
      required: ["command", "wait", "max_wait_seconds"],
    })
    checkToolCallSafe(r) {
      let n = qB(process.platform, this.processTools.shellName),
        i = r.command
      return VB(n, i, this.processTools.shellName)
    }
    async call(r, n, i) {
      try {
        let s = r.wait,
          o = r.max_wait_seconds,
          a = r.cwd ?? gm(this._workspaceManager),
          l = !!s,
          c = await this.processTools.launch(r.command, a, i, l)
        if (typeof c == "string") return at(c)
        if (!s) return cr(`Process launched with terminal ID ${c}`)
        let u = await this.processTools.waitForProcess(c, o, i),
          f = sbe(c, this.processTools, this._workspaceManager)
        return u.returnCode === null
          ? cr(`Command may still be running. You can use read-process to get more output
and kill-process to terminate it if needed.
Terminal ID ${c}
Output so far:
<output>
${u.output}
</output>
${f}`)
          : {
              text: `Here are the results from executing the command.
<return-code>
${u.returnCode}
</return-code>
<output>
${u.output}
</output>
${f}`,
              isError: u.returnCode !== 0,
            }
      } catch (s) {
        return at(`Failed to launch process: ${s.message ?? ""}`)
      }
    }
  },
  JM = class extends En {
    constructor(r) {
      super(ToolType.killProcess, ToolSafetyLevel.Safe)
      this._processTools = r
    }
    description = "Kill a process by its terminal ID."
    inputSchemaJson = JSON.stringify({
      type: "object",
      properties: {
        terminal_id: { type: "integer", description: "Terminal ID to kill." },
      },
      required: ["terminal_id"],
    })
    checkToolCallSafe(r) {
      return true
    }
    async call(r, n, i) {
      let s = r.terminal_id,
        o = await this._processTools.kill(s)
      return o
        ? cr(`Terminal ${s} killed
<output>${o}</output>`)
        : at(`Terminal ${s} not found`)
    }
  },
  jM = class extends En {
    constructor(r, n) {
      super(ToolType.readProcess, ToolSafetyLevel.Safe)
      this._processTools = r
      this._workspaceManager = n
    }
    description =
      "Read output from a terminal.\n\nIf `wait=true` and the process has not yet completed, waits for the terminal to complete up to `max_wait_seconds` seconds before returning its output.\n\nIf `wait=false` or the process has already completed, returns immediately with the current output."
    inputSchemaJson = JSON.stringify({
      type: "object",
      properties: {
        terminal_id: {
          type: "integer",
          description: "Terminal ID to read from.",
        },
        wait: {
          type: "boolean",
          description: "Whether to wait for the command to complete.",
        },
        max_wait_seconds: {
          type: "number",
          description:
            "Number of seconds to wait for the command to complete. Only relevant when wait=true. 1 minute may be a good default: increase from there if needed.",
        },
      },
      required: ["terminal_id", "wait", "max_wait_seconds"],
    })
    checkToolCallSafe(r) {
      return true
    }
    async call(r, n, i) {
      let s = r.terminal_id,
        o = r.wait,
        a = r.max_wait_seconds
      o && (await this._processTools.waitForProcess(s, a, i))
      let l = await this._processTools.readOutput(s)
      if (!l) return at(`Terminal ${s} not found`)
      let c = sbe(s, this._processTools, this._workspaceManager),
        u = l.returnCode !== null ? "completed" : "still running",
        f = `Here is the output from terminal ${s} (status: ${u}):
<output>${l.output}</output>
`
      return (
        l.returnCode !== null &&
          (f += `<return-code>
${l.returnCode}
</return-code>
`),
        c && (f += c),
        cr(f)
      )
    }
  },
  ZM = class extends En {
    constructor(r) {
      super(ToolType.writeProcess, ToolSafetyLevel.Safe)
      this._processTools = r
    }
    description = "Write input to a terminal."
    inputSchemaJson = JSON.stringify({
      type: "object",
      properties: {
        terminal_id: {
          type: "integer",
          description: "Terminal ID to write to.",
        },
        input_text: {
          type: "string",
          description: "Text to write to the process's stdin.",
        },
      },
      required: ["terminal_id", "input_text"],
    })
    checkToolCallSafe(r) {
      return true
    }
    call(r, n, i) {
      let s = r.terminal_id,
        o = r.input_text
      return this._processTools.writeInput(s, o)
        ? Promise.resolve(cr(`Input written to terminal ${s}`))
        : Promise.resolve(at(`Terminal ${s} not found or write failed`))
    }
  },
  XM = class extends En {
    constructor(r) {
      super(ToolType.listProcesses, ToolSafetyLevel.Safe)
      this._processTools = r
    }
    description = "List all known terminals and their states."
    inputSchemaJson = JSON.stringify({
      type: "object",
      properties: {},
      required: [],
    })
    checkToolCallSafe(r) {
      return true
    }
    call(r, n, i) {
      let s = this._processTools.listProcesses()
      if (s.length === 0) return Promise.resolve(cr("No processes found"))
      let o = s.map((l) => {
          let c = l.state
          return (
            l.returnCode !== null && (c += ` (return code: ${l.returnCode})`),
            `Terminal ${l.id} [${c}]: ${l.command}`
          )
        }),
        a = s.filter((l) => l.state === "running").length
      return (
        a === 1
          ? o.push(`
There is 1 process still running.`)
          : a > 1 &&
            o.push(`
There are ${a} processes still running.`),
        Promise.resolve(
          cr(
            `Here are all known processes:

` +
              o.join(`
`),
          ),
        )
      )
    }
  }
function sbe(e, t, r) {
  let n = t.getLongRunningTerminalInfo()?.current_working_directory
  if (!t.isInLongRunningTerminal(e) || !n) return
  let i = r.safeResolvePathName(n)?.relPath
  return (
    i != null && !af(i) && (i = `//${i}`),
    `The terminal's current working directory is now \`${i ?? n}\`.
`
  )
}
function w4(e) {
  return e
    .replace(/\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])/g, "")
    .replace(/(?:\x1b\])?(\d+;[^\x07\x1b]*(?:\x07|\x1b\\))/g, "")
}
var rbe = {
    powershell: /^\s*(?:PS\s+(?:[^>]*))?\s*>\s*/,
    bash: /^\s*(?:[^@]*@[^:]*:)?(?:[^$]*)?\$\s*/,
    zsh: /^\s*(?:[^@]*@[^:]*:)?(?:[^%]*)?%\s*/,
  },
  lv = ((u) => (
    (u[(u.unknown = 1)] = "unknown"),
    (u[(u.unsupportedAPI = 2)] = "unsupportedAPI"),
    (u[(u.shellNotFound = 3)] = "shellNotFound"),
    (u[(u.noShellIntegration = 4)] = "noShellIntegration"),
    (u[(u.noExecutionEvents = 5)] = "noExecutionEvents"),
    (u[(u.buggyExecutionEvents = 6)] = "buggyExecutionEvents"),
    (u[(u.noOutput = 7)] = "noOutput"),
    (u[(u.noisyOutput = 8)] = "noisyOutput"),
    (u[(u.buggyOutput = 9)] = "buggyOutput"),
    (u[(u.supported = 10)] = "supported"),
    u
  ))(lv || {}),
  S4 = class extends DisposableContainer {
    constructor(r) {
      super()
      this._shellInfo = r
      this._startBackgroundCheck()
    }
    _result = { capability: 1, details: "Check not started" }
    _checkPromise
    _logger = z("TerminalCapabilityChecker")
    _testCommand = "echo 'Terminal capability test'"
    async checkCapabilities(r = false) {
      if (this._result.capability !== 1 && !r) return this._result
      if (this._checkPromise) return this._checkPromise
      this._checkPromise = this._performCheck()
      try {
        return (this._result = await this._checkPromise), this._result
      } finally {
        this._checkPromise = undefined
      }
    }
    async _startBackgroundCheck() {
      try {
        let r = await this.checkCapabilities()
        this._logger.debug(
          `Terminal capability check result: ${this._getCapabilityDescription(r)}`,
        )
      } catch (r) {
        this._logger.debug(
          `Error during initial terminal capability check: ${r.message}`,
        ),
          Mr().reportEvent({
            eventName: MemoryEventType.vsCodeTerminalErrorCheckingShellCapability,
            conversationId: "",
          })
      }
    }
    _getCapabilityDescription(r = this._result) {
      return `${lv[r.capability]}: ${r.details}`
    }
    async _performCheck() {
      if (!Ut.window.onDidEndTerminalShellExecution || !eo("1.93.0"))
        return {
          capability: 2,
          details: `VSCode version ${Ut.version} does not support required terminal APIs`,
        }
      if (!(await this._checkShellExists()))
        return {
          capability: 3,
          details: `Shell ${this._shellInfo.path ?? this._shellInfo.name} does not exist`,
        }
      let i = Ut.window.createTerminal({
        name: "Augment Terminal Capability Check",
        hideFromUser: true,
        shellPath: this._shellInfo?.path ?? this._shellInfo.name,
        shellArgs: this._shellInfo?.args,
        env: this._shellInfo?.env,
        isTransient: true,
      })
      try {
        let s = await this._listenForShellIntegration(i)
        if ((s.listener && s.listener.dispose(), !s.shellIntegrationDetected))
          return { capability: 4, details: s.message }
        let { execution: o, readStream: a } = this._executeTestCommand(
            i,
            s.shellIntegrationDetected,
          ),
          c = await this._listenForExecutionEvent(i, o, a)
        c.listener && c.listener.dispose()
        let u
        switch (c.capability) {
          case 6:
            u = "Terminal receives execution events but for incorrect commands"
            break
          case 5:
            u = "No execution events received"
            break
          case 7:
            u = "Execution event received but no output was captured"
            break
          case 10:
            u = "Terminal has all required capabilities with exact output"
            break
          case 8:
            u =
              "Terminal has all required capabilities but output contains extra content"
            break
          case 9:
            u = "Terminal has all required capabilities but output is incorrect"
            break
          default:
            u = "Unknown terminal capability"
            break
        }
        return { capability: c.capability, details: u }
      } catch (s) {
        return (
          this._logger.debug(`Terminal capability check failed: ${s.message}`),
          Mr().reportEvent({
            eventName: MemoryEventType.vsCodeTerminalErrorCheckingShellCapability,
            conversationId: "",
          }),
          { capability: 1, details: `Check failed with error: ${s.message}` }
        )
      } finally {
        i && i.dispose()
      }
    }
    _listenForShellIntegration(r) {
      return new Promise((n) => {
        if (!r) {
          n({ message: "Terminal not created", shellIntegrationDetected: false })
          return
        }
        if (this._terminalHasShellIntegration(r)) {
          n({
            message: "Shell integration already available",
            shellIntegrationDetected: true,
          })
          return
        }
        let i = Ut.window
        if (i.onDidChangeTerminalShellIntegration) {
          let s = i.onDidChangeTerminalShellIntegration((o) => {
            o.terminal === r &&
              o.shellIntegration &&
              n({
                message: "Shell integration detected",
                shellIntegrationDetected: true,
              })
          })
          this._createTimeout("Shell integration", 3e3).then((o) => {
            n({ message: o.message, listener: s, shellIntegrationDetected: false })
          })
        } else
          n({
            message: "onDidChangeTerminalShellIntegration API not available",
            shellIntegrationDetected: false,
          })
      })
    }
    _listenForExecutionEvent(r, n, i) {
      return new Promise((s) => {
        let o = Ut.window
        if (!o.onDidEndTerminalShellExecution) {
          s({ capability: 5 })
          return
        }
        let a = o.onDidEndTerminalShellExecution(async (l) => {
          let c =
              l.terminal === r &&
              l.execution.commandLine.value === this._testCommand,
            u =
              l.terminal === r &&
              l.execution.commandLine.value !== this._testCommand
          if (c) {
            let f = 7
            if (i)
              try {
                let p = ""
                for await (let m of i) p += m
                let g = w4(p.trim())
                g && g === "Terminal capability test"
                  ? (f = 10)
                  : g && g.includes("Terminal capability test")
                    ? (f = 8)
                    : p && p.length > 0 && (f = 9)
              } catch (p) {
                this._logger.debug(
                  `Error reading execution output: ${p.message}`,
                )
              }
            s({ capability: f })
          } else
            u &&
              (this._logger.debug(
                `Buggy execution event received for command: ${l.execution.commandLine.value}`,
              ),
              s({ capability: 6 }))
        })
        this._createTimeout("Execution event", 2e3).then(() => {
          s({ listener: a, capability: 5 })
        })
      })
    }
    _executeTestCommand(r, n) {
      if (!r || !n) return {}
      try {
        let i = r
        if (i.shellIntegration) {
          let s = i.shellIntegration.executeCommand(this._testCommand),
            o = s.read()
          return { execution: s, readStream: o }
        } else return r.sendText(this._testCommand), {}
      } catch (i) {
        return (
          this._logger.debug(`Error executing test command: ${i.message}`), {}
        )
      }
    }
    _createTimeout(r, n) {
      return new Promise((i) => {
        let s = setTimeout(() => {
          i({ message: `Timeout waiting for ${r}` })
        }, n)
        this.addDisposable(new Ut.Disposable(() => clearTimeout(s)))
      })
    }
    _terminalHasShellIntegration(r) {
      return !!r.shellIntegration
    }
    async _checkShellExists() {
      let r = this._shellInfo.path ?? this._shellInfo.name
      try {
        return this._shellInfo.path && af(this._shellInfo.path)
          ? fileExists(this._shellInfo.path)
          : new Promise((n) => {
              try {
                let i = (0, ibe.spawn)(r, [], { shell: false, stdio: "ignore" })
                i.on("error", () => {
                  n(false)
                }),
                  i.on("exit", () => {
                    n(true)
                  }),
                  setTimeout(() => {
                    try {
                      i.kill()
                    } catch {}
                    n(true)
                  }, 2e3)
              } catch {
                n(false)
              }
            })
      } catch {
        return false
      }
    }
    dispose() {
      super.dispose()
    }
  }
var obe = (e, t, r, n, i, s, o) => (a) => new I4(a, t, e, r, n, i, s, o),
  I4 = class e extends GA {
    constructor(r, n, i, s, o, a, l, c) {
      let u = [],
        f
      r === Fr.agent
        ? (u.push(new B4(n, s, i, o)),
          o.currentFlags?.vscodeAgentEditTool !== hI.strReplaceEditor
            ? (u.push(new eF(n)), u.push(new R4(n, i, s)))
            : u.push(new KM(s, n)),
          u.push(new D4()),
          u.push(new T4(n)),
          (f = new zM(a, l, c)),
          u.push(new cv(n, f)),
          u.push(new JM(f)),
          u.push(new jM(f, n)),
          u.push(new ZM(f)),
          u.push(new XM(f)))
        : u.push(new eF(n))
      super(u, ToolHostType.localToolHost)
      this._chatMode = r
      this._workspaceManager = n
      this._apiServer = i
      this._checkpointManager = s
      this._featureFlagManager = o
      this._extensionRoot = a
      this._globalState = l
      this._enableStart = c
      this._terminalProcessTools = f
    }
    _terminalProcessTools
    async close(r = false) {
      await super.close(),
        this._terminalProcessTools !== undefined &&
          this._terminalProcessTools.cleanup()
    }
    closeAllToolProcesses() {
      return (
        this._terminalProcessTools !== undefined &&
          this._terminalProcessTools.closeAllProcesses(),
        Promise.resolve()
      )
    }
    factory(r) {
      return new e(
        this._chatMode,
        this._workspaceManager,
        this._apiServer,
        this._checkpointManager,
        this._featureFlagManager,
        this._extensionRoot,
        this._globalState,
        this._enableStart,
      )
    }
  },
  eF = class extends En {
    constructor(r) {
      super(ToolType.readFile, ToolSafetyLevel.Safe)
      this._workspaceManager = r
    }
    description = "Read a file."
    inputSchemaJson = JSON.stringify({
      type: "object",
      properties: {
        file_path: {
          type: "string",
          description: "The path of the file to read.",
        },
      },
      required: ["file_path"],
    })
    checkToolCallSafe(r) {
      return true
    }
    async call(r, n, i) {
      let s = r.file_path
      try {
        let o = await pm(s, this._workspaceManager)
        return o === undefined ? at(`Cannot read file: ${s}`) : cr(o)
      } catch (o) {
        return at(`Failed to read file: ${s}: ${o.message ?? ""}`)
      }
    }
  },
  B4 = class extends En {
    constructor(r, n, i, s) {
      super(ToolType.saveFile, ToolSafetyLevel.Safe)
      this._workspaceManager = r
      this._checkpointManager = n
      this._requestIdCreator = i
      this._featureFlagManager = s
      this._featureFlagManager.currentFlags
        ?.agentSaveFileToolInstructionsReminder &&
        ((this.description = this.descriptionWithInstructionsReminder),
        (this.inputSchemaJson = this.inputSchemaJsonWithInstructionsReminder))
    }
    description =
      "Save a new file. Use this tool to write new files with the attached content. It CANNOT modify existing files. Do NOT use this tool to edit an existing file by overwriting it entirely. Use the str-replace-editor tool to edit existing files instead."
    inputSchemaJson = JSON.stringify({
      type: "object",
      properties: {
        file_path: {
          type: "string",
          description: "The path of the file to save.",
        },
        file_content: {
          type: "string",
          description: "The content of the file.",
        },
        add_last_line_newline: {
          type: "boolean",
          description:
            "Whether to add a newline at the end of the file (default: true).",
        },
      },
      required: ["file_path", "file_content"],
    })
    maxLines = 300
    instructions = `LIMIT THE FILE CONTENT TO AT MOST ${this.maxLines} LINES. IF MORE CONTENT NEEDS TO BE ADDED USE THE str-replace-editor TOOL TO EDIT THE FILE AFTER IT HAS BEEN CREATED.`
    descriptionWithInstructionsReminder = `Save a new file. Use this tool to write new files with the attached content. Generate \`instructions_reminder\` first to remind yourself to limit the file content to at most ${this.maxLines} lines.It CANNOT modify existing files. Do NOT use this tool to edit an existing file by overwriting it entirely. Use the str-replace-editor tool to edit existing files instead.`
    inputSchemaJsonWithInstructionsReminder = JSON.stringify({
      type: "object",
      properties: {
        instructions_reminder: {
          type: "string",
          description: `Should be exactly this string: '${this.instructions}'`,
        },
        file_path: {
          type: "string",
          description: "The path of the file to save.",
        },
        file_content: {
          type: "string",
          description: "The content of the file.",
        },
        add_last_line_newline: {
          type: "boolean",
          description:
            "Whether to add a newline at the end of the file (default: true).",
        },
      },
      required: ["instructions_reminder", "file_path", "file_content"],
    })
    checkToolCallSafe(r) {
      return true
    }
    async call(r, n, i) {
      let s = r.file_path
      try {
        let o = r.file_content,
          a = r.add_last_line_newline ?? true,
          l =
            o +
            (a
              ? `
`
              : ""),
          c = (await pm(s, this._workspaceManager)) ?? "",
          u = $u(s, this._workspaceManager)
        if (u === undefined) return at(`Cannot resolve path: ${s}`)
        if (fileExists(u.absPath)) return at(`File already exists: ${u.absPath}`)
        let f = new DiffViewDocument(u, undefined, l, {})
        if (c === l) return f.dispose(), cr(`No changes made to file {${s}}`)
        let p =
            n.at(-1)?.request_id ?? this._requestIdCreator.createRequestId(),
          g = this._checkpointManager.currentConversationId ?? ""
        return (
          await this._checkpointManager.addCheckpoint(
            { conversationId: g, path: u },
            {
              sourceToolCallRequestId: p,
              timestamp: Date.now(),
              document: f,
              conversationId: g,
            },
          ),
          cr(`File saved.  Saved file {${s}}`)
        )
      } catch (o) {
        return at(`Failed to save file: ${s}: ${o.message ?? ""}`)
      }
    }
  },
  R4 = class extends En {
    constructor(r, n, i) {
      super(ToolType.editFile, ToolSafetyLevel.Safe)
      this._workspaceManager = r
      this._apiServer = n
      this._checkpointManager = i
    }
    _maxDiagnosticDelayMs = 5e3
    description = `
Edit a file. Accepts a file path and a description of the edit.
This tool can edit whole files.
The description should be detailed and precise, and include all required information to perform the edit.
It can include both natural language and code. It can include multiple code snippets to described different
edits in the file. It can include descriptions of how to perform these edits precisely.

All the contents that should go in a file should be placed in a markdown code block, like this:

<begin-example>
Add a function called foo.

\`\`\`
def foo():
    ...
\`\`\`
</end-example>

This includes all contents, even if it's not code.

Be precise or I will take away your toys.

Prefer to use this tool when editing parts of a file.
`
    inputSchemaJson = JSON.stringify({
      type: "object",
      properties: {
        file_path: {
          type: "string",
          description: "The path of the file to edit.",
        },
        edit_summary: {
          type: "string",
          description:
            "A brief description of the edit to be made. 1-2 sentences.",
        },
        detailed_edit_description: {
          type: "string",
          description:
            "A detailed and precise description of the edit. Can include natural language and code snippets.",
        },
      },
      required: ["file_path", "edit_summary", "detailed_edit_description"],
    })
    checkToolCallSafe(r) {
      return true
    }
    async call(r, n, i) {
      let s = r.file_path,
        o
      try {
        let a = r.edit_summary,
          l = r.detailed_edit_description,
          c = await pm(s, this._workspaceManager)
        if (c === undefined) return at(`Cannot read file: ${s}`)
        let u = $u(s, this._workspaceManager)
        if (u === undefined) return at(`Cannot resolve path: ${s}`)
        let f = this._getDiagnostics()
        o = this._apiServer.createRequestId()
        let p = await this._apiServer.agentEditFile(o, s, a, l, c, i)
        if (p.isError) return at(`Failed to edit file: ${s}`, o)
        let g = new DiffViewDocument(u, c, p.modifiedFileContents, {})
        if (c === p.modifiedFileContents)
          return g.dispose(), cr(`No changes made to file {${s}}`, o)
        let m = n.at(-1)?.request_id ?? o,
          y = this._checkpointManager.currentConversationId ?? ""
        await this._checkpointManager.addCheckpoint(
          { conversationId: y, path: u },
          {
            sourceToolCallRequestId: m,
            timestamp: Date.now(),
            document: g,
            conversationId: y,
          },
        )
        let v = await this._waitForNewDiagnostics(f),
          C = this._filterDiagnosticsMap(v, f),
          E = Array.from(C.entries()).map(
            ([N, W]) => `${N}
${W.map((Z) => `${Z.range.start.line}-${Z.range.end.line}: ${Z.message}`).join(`
`)}`,
          ).join(`

`),
          w = v.get(u.absPath) ?? [],
          T = this._filterDiagnostics(w, C.get(u.absPath) ?? []).map(
            (N) => `${N.range.start.line}-${N.range.end.line}: ${N.message}`,
          ).join(`
`)
        return cr(
          `File edited successfully.  Saved file {${s}}.  New diagnostics:
${E}

Additional ${s} diagnostics:
${T}`,
          o,
        )
      } catch (a) {
        return at(`Failed to edit file: ${s}: ${a.message ?? ""}`, o)
      }
    }
    _getDiagnostics() {
      let r = new Map()
      return (
        Em.languages.getDiagnostics().forEach(([n, i]) => {
          i.length > 0 && r.set(n.fsPath, i)
        }),
        r
      )
    }
    _filterDiagnosticsMap(r, n) {
      let i = new Map()
      return (
        r.forEach((s, o) => {
          let a = n.get(o) ?? [],
            l = this._filterDiagnostics(s, a)
          l.length > 0 && i.set(o, l)
        }),
        i
      )
    }
    _filterDiagnostics(r, n) {
      return r.filter(
        (i) =>
          !n.some(
            (s) =>
              i.range.start.line === s.range.start.line &&
              i.range.end.line === s.range.end.line &&
              i.message === s.message &&
              i.severity === s.severity,
          ),
      )
    }
    async _waitForNewDiagnostics(r) {
      let n = Date.now(),
        i = this._getDiagnostics()
      for (; Date.now() - n < this._maxDiagnosticDelayMs; ) {
        let s = this._getDiagnostics(),
          o = this._filterDiagnosticsMap(s, r)
        if (this._hasDifferentDiagnostics(o, this._filterDiagnosticsMap(i, r)))
          return s
        ;(i = s), await sleep(1e3)
      }
      return i
    }
    _hasDifferentDiagnostics(r, n) {
      if (r.size !== n.size) return true
      for (let [i, s] of r) {
        let o = n.get(i)
        if (!o || s.length !== o.length) return true
        for (let a = 0; a < s.length; a++) {
          let l = s[a],
            c = o[a]
          if (
            l.range.start.line !== c.range.start.line ||
            l.range.end.line !== c.range.end.line ||
            l.message !== c.message ||
            l.severity !== c.severity
          )
            return true
        }
      }
      return false
    }
  },
  D4 = class extends En {
    constructor() {
      super(ToolType.openBrowser, ToolSafetyLevel.Safe)
    }
    description =
      "Open a URL in the default browser.\n\n1. The tool takes in a URL and opens it in the default browser.\n2. The tool does not return any content. It is intended for the user to visually inspect and interact with the page. You will not have access to it.\n3. You should not use `open-browser` on a URL that you have called the tool on before in the conversation history, because the page is already open in the user's browser and the user can see it and refresh it themselves. Each time you call `open-browser`, it will jump the user to the browser window, which is highly annoying to the user."
    inputSchemaJson = JSON.stringify({
      type: "object",
      properties: {
        url: { type: "string", description: "The URL to open in the browser." },
      },
      required: ["url"],
    })
    checkToolCallSafe(t) {
      return true
    }
    async call(t, r, n) {
      try {
        let i = t.url,
          s = Em.Uri.parse(i)
        return (await Em.env.openExternal(s))
          ? cr(`Opened ${i} in browser`)
          : at(`Failed to open ${i} in browser: system denied the request`)
      } catch (i) {
        return at(`Failed to open URL in browser: ${i.message ?? ""}`)
      }
    }
  },
  T4 = class extends En {
    constructor(r) {
      super(ToolType.diagnostics, ToolSafetyLevel.Safe)
      this._workspaceManager = r
    }
    description = "Get issues (errors, warnings, etc.) from the IDE."
    inputSchemaJson = JSON.stringify({
      type: "object",
      properties: {
        paths: {
          type: "array",
          items: { type: "string" },
          description:
            "Optional list of file paths to get issues for from the IDE. If not provided, returns all issues.",
        },
      },
      required: [],
    })
    checkToolCallSafe(r) {
      return true
    }
    async call(r, n, i) {
      try {
        let s = r.paths,
          o = this._getDiagnostics(),
          a = o
        if (s && s.length > 0) {
          a = new Map()
          for (let c of s)
            for (let [u, f] of o.entries()) u.includes(c) && a.set(u, f)
        }
        let l = await bM(a, this._workspaceManager)
        return l.trim() === ""
          ? cr("No diagnostics found.")
          : cr(`The IDE reports the following issues:
${l}`)
      } catch (s) {
        return at(`Failed to get diagnostics: ${s.message ?? ""}`)
      }
    }
    _getDiagnostics() {
      let r = new Map()
      return (
        Em.languages.getDiagnostics().forEach(([n, i]) => {
          i.length > 0 && r.set(n.fsPath, i)
        }),
        r
      )
    }
  }
var tF = class {
  constructor(t, r) {
    this._apiServer = t
    this._configListener = r
  }
  _logger = z("VSCodeRemoteInfo")
  async retrieveRemoteTools(t) {
    try {
      return (await this._apiServer.listRemoteTools(t)).tools
    } catch (r) {
      return this._logger.error("Failed to list remote tools", r), []
    }
  }
  filterToolsWithExtraInput(t) {
    let r = new Set()
    for (let n of t) this._getExtraToolInput(n) !== undefined && r.add(n)
    return Promise.resolve(r)
  }
  async runRemoteTool(t, r, n, i, s) {
    return await this._apiServer.runRemoteTool(
      t,
      r,
      n,
      i,
      this._getExtraToolInput(i),
      s,
    )
  }
  _getExtraToolInput(t) {
    switch (t) {
      case IntegrationServiceType.Jira:
      case IntegrationServiceType.Confluence:
        return this._configListener.config.integrations.atlassian
      case IntegrationServiceType.Notion:
        return this._configListener.config.integrations.notion
      case IntegrationServiceType.Linear:
        return this._configListener.config.integrations.linear
      case IntegrationServiceType.GitHubApi:
        return this._configListener.config.integrations.github
      default:
        return
    }
  }
}
var abe = q(require("vscode"))
var rF = class e {
  constructor(t) {
    this._extensionContext = t
  }
  static assetSubdirectory = "augment-user-assets"
  async saveAsset(t, r) {
    let n = await this._getUri(t)
    await iye(n.fsPath, r)
  }
  async loadAsset(t) {
    let r = await this._getUri(t)
    try {
      let n = await AM(r.fsPath)
      return new Uint8Array(n)
    } catch {
      return
    }
  }
  async deleteAsset(t) {
    let r = await this._getUri(t)
    return await oye(r.fsPath)
  }
  async _getUri(t) {
    let r =
        this._extensionContext.storageUri ??
        this._extensionContext.globalStorageUri,
      n = joinPaths(r.fsPath, e.assetSubdirectory)
    ;(await Vl(n)) || (await Hl(n))
    let i = Ha(t)
    if (i) {
      let s = joinPaths(n, i)
      ;(await Vl(s)) || (await Hl(s))
    }
    return abe.Uri.file(joinPaths(n, t))
  }
}
var Pbe = q(require("vscode"))
var Nbe = q(require("path")),
  zi = q(require("vscode"))
var Yl = q(require("vscode"))
var gf = q(require("vscode"))
var lbe = q(require("assert")),
  iF = q(require("vscode"))
var CommandRegistry = class extends DisposableContainer {
  constructor(configListener) {
    super()
    this._config = configListener
    ;(this._logger = z("CommandManager")),
      this.addDisposable(
        new iF.Disposable(() => {
          this._commands.forEach((command, commandId) => {
            command.unregister(), this._commands.delete(commandId)
          })
        }),
      ),
      this.addDisposable(
        this._config.onDidChange(() => {
          this.register(this.allCommands)
        }),
      )
  }
  _commands = new Map()
  _groups = []
  _logger
  register(commands) {
    for (let command of commands) {
      if (this._commands.has(command.commandID)) {
        this._commands.get(command.commandID)?.update(this._config)
        continue
      }
      command.register(this._config), this._commands.set(command.commandID, command)
    }
  }
  registerGroup(groupName, commands) {
    this._logger.debug(`Registering group '${groupName}' with ${commands.length} commands.`),
      this._groups.push({ name: groupName, commands: commands }),
      this.register(commands)
  }
  get availableCommands() {
    return Array.from(this._commands.values()).filter(
      (command) => command.isRegistered && command.canRun(),
    )
  }
  get availableCommandGroups() {
    let groups = []
    for (let i = 0; i < this._groups.length; i++) {
      let { name, commands } = this._groups[i],
        availableCommands = commands.filter((cmd) => cmd.isRegistered && cmd.canRun())
      availableCommands.length !== 0 &&
        (groups.length > 0 && groups[groups.length - 1].name === name
          ? groups[groups.length - 1].commands.push(...availableCommands)
          : groups.push({ name: name, commands: availableCommands }))
    }
    return groups
  }
  get allCommands() {
    return Array.from(this._commands.values())
  }
},
  AugmentCommand = class extends DisposableContainer {
    constructor(title = undefined, showInActionPanel = true) {
      super()
      this._title = title
      this._showInActionPanel = showInActionPanel
      let i = this.constructor
      typeof i.commandID == "string" && (this._commandID = i.commandID),
        this.addDisposable({ dispose: () => this.unregister() })
    }
    _registration
    _logger = z("AugmentCommand")
    static commandID
    _commandID
    get commandID() {
      return (
        (0, lbe.default)(
          typeof this._commandID == "string",
          `commandID must be defined on subclass ${this.constructor.name}`,
        ),
        this._commandID
      )
    }
    get title() {
      if (typeof this._title == "string") return this._title
      if (typeof this._title == "function") return this._title()
    }
    get showInActionPanel() {
      return this._showInActionPanel
    }
    get isRegistered() {
      return this._registration !== undefined
    }
    canRun() {
      return true
    }
    register(configListener) {
      this._registration === undefined &&
        ((this.type === "debug" && !configListener.config.enableDebugFeatures) ||
          (this._registration = iF.commands.registerCommand(
            this.commandID,
            (...args) => {
              if (!this.canRun()) {
                this._logger.debug(
                  `Not running '${this.commandID}' command with type ${this.type}.`,
                )
                return
              }
              this.run(...args)
            },
          )))
    }
    update(configListener) {
      this.type === "debug" &&
        (configListener.config.enableDebugFeatures ? this.register(configListener) : this.dispose())
    }
    unregister() {
      this._registration?.dispose(), (this._registration = undefined)
    }
  }
var SyncingEnabledCommand = class extends AugmentCommand {
  constructor(syncingEnabledTracker, title = undefined, showInActionPanel = true) {
    super(title, showInActionPanel)
    this._syncingEnabledTracker = syncingEnabledTracker
  }
  _syncingEnabled() {
    return (
      this._syncingEnabledTracker.syncingEnabledState === "enabled" ||
      this._syncingEnabledTracker.syncingEnabledState === "partial"
    )
  }
  canRun() {
    return this._syncingEnabled()
  }
}
var dbe = q(require("os")),
  za = q(require("vscode"))
var cbe = q(require("vscode"))
function ube(e) {
  return e.absPath.startsWith("Untitled-")
}
function findUntitledDocument(e) {
  return cbe.workspace.textDocuments.find(
    (r) => r.isUntitled && r.uri.path === e.absPath,
  )
}
var VsCodeDiffDocument = class VsCodeDiffDocument extends DiffViewDocument {
  _instance = crypto.randomUUID()
  constructor(filePath, originalCode, modifiedCode, options) {
    let eolMarker = dbe.default.EOL
    modifiedCode !== undefined && (modifiedCode = modifiedCode.endsWith(eolMarker) ? modifiedCode : modifiedCode + eolMarker),
      originalCode !== undefined && (originalCode = originalCode.endsWith(eolMarker) ? originalCode : originalCode + eolMarker),
      super(filePath, originalCode, modifiedCode, { ...options }),
      this.addDisposable(
        za.workspace.onDidChangeTextDocument(this._onBaseDocUpdated),
      ),
      this.addDisposable(this.onOriginalUpdated(() => void this._write()))
  }
  static fromPathName = async (filePath, modifiedCode, logger) => {
    let document = new VsCodeDiffDocument(filePath, "", "", { logger: logger }),
      fileContent = await document._read(),
      originalCode = fileContent === "" && !(await document._fileExists()) ? undefined : fileContent
    return document.updateCodeVersions(originalCode, modifiedCode ?? originalCode), document
  }
  _fileExists = async () => {
    try {
      return await za.workspace.fs.stat(za.Uri.file(this.filePath.absPath)), true
    } catch {
      return false
    }
  }
  _read = async () => {
    let document = await this._getVsCodeTextDocument()
    return document ? document.getText() : ""
  }
  _write = async () => {
    if (this.originalCode === undefined)
      try {
        let fileUri = za.Uri.file(this.filePath.absPath)
        ;(await this._fileExists()) &&
          (this._opts.logger?.debug(`Deleting file ${this.filePath.absPath}`),
          await za.workspace.fs.delete(fileUri))
        return
      } catch (error) {
        this._opts.logger?.error(
          `Failed to delete file ${this.filePath.absPath}: ${String(error)}`,
        )
        return
      }
    let document = await this._getVsCodeTextDocument()
    if (document && document.getText() !== this.originalCode) {
      this._opts.logger?.debug(`Writing to doc ${this._instance}`)
      let edit = new za.WorkspaceEdit()
      edit.replace(
        document.uri,
        new za.Range(0, 0, Number.MAX_SAFE_INTEGER, 0),
        this.originalCode,
      ),
        await za.workspace.applyEdit(edit)
    }
  }
  _getVsCodeTextDocument = async () => {
    try {
      let document
      if (
        (this.isUntitled
          ? (document = findUntitledDocument(this.filePath))
          : (document = await za.workspace.openTextDocument(this.filePath.absPath)),
        document === undefined)
      )
        throw new Error(`Failed to open document ${this.filePath.absPath}`)
      return document
    } catch (error) {
      this._opts.logger?.error(
        `Failed to read file ${this.filePath.absPath}: ${String(error)}`,
      )
      return
    }
  }
  _onBaseDocUpdated = (event) => {
    if (event.document.uri.fsPath === this.absPath) {
      let content = event.document.getText()
      if (content === this.originalCode) return
      this.updateOriginal(content)
    }
  }
}
var _m = q(require("vscode")),
  Ix = `

`
function isNotebookCell(uri) {
  return uri.scheme === "vscode-notebook-cell"
}
function fbe(e) {
  let t = _m.window.activeNotebookEditor?.notebook
  return t ? (Hmt(e, t) ? [k4(t), Wmt(t, e)] : [undefined, 0]) : [undefined, 0]
}
function hbe(e) {
  if (isNotebookCell(e.uri)) {
    for (let t of _m.workspace.notebookDocuments)
      for (let r of t.getCells()) if (r.document === e) return t
  }
}
function k4(e) {
  return uv(e.getCells())
}
function Hmt(e, t) {
  let r = t.getCells().find((n) => n.document === e)
  return r ? r.kind === _m.NotebookCellKind.Code : false
}
function Wmt(e, t) {
  let n = e.getCells().findIndex((i) => i.document === t)
  return n === -1 ? 0 : Gmt(e, n, true)
}
function Gmt(e, t, r) {
  let n = uv(e.getCells().slice(0, t))
  return r && n ? n.length + Ix.length : n.length
}
function uv(e) {
  return e
    .filter((n) => n.kind === _m.NotebookCellKind.Code)
    .map((n) => n.document.getText())
    .join(Ix)
}
function isNotebook(document) {
  return document.getCells !== undefined
}
var OpenDiffViewCommand = class extends AugmentCommand {
    constructor(extension, extensionUri, apiServer) {
      super()
      this._extension = extension
      this._extensionUri = extensionUri
      this._apiServer = apiServer
    }
    static commandID = "vscode-augment.internal-dv.o"
    type = "public"
    run = async (...args) => {
      if (!this._extension.workspaceManager)
        throw new Error("No workspace manager")
      if (!this._extension.keybindingWatcher)
        throw new Error("No keybinding watcher")
      let [uri, modifiedCode, options] = args,
        resolvedUri = resolveUri(uri)
      if (resolvedUri === undefined) return
      if (resolvedUri === null) return
      let workspaceFolder = getWorkspaceFolder(resolvedUri),
        relativePath = resolvedUri.fsPath.replace(workspaceFolder.fsPath, ""),
        qualifiedPath = new QualifiedPathName(workspaceFolder.fsPath, relativePath)
      DiffViewPanel.createOrShow(
        {
          extensionUri: this._extensionUri,
          workspaceManager: this._extension.workspaceManager,
          apiServer: this._apiServer,
          keybindingWatcher: this._extension.keybindingWatcher,
          fuzzyFsSearcher: this._extension.fuzzyFsSearcher,
          fuzzySymbolSearcher: this._extension.fuzzySymbolSearcher,
          workTimer: this._extension.workTimer,
        },
        { document: await VsCodeDiffDocument.fromPathName(qualifiedPath, modifiedCode), ...options },
      )
    }
    canRun() {
      return true
    }
  },
  InstructionCommand = class extends SyncingEnabledCommand {
    constructor(extension, extensionUri, apiServer, guidelinesWatcher, syncingEnabledTracker) {
      super(syncingEnabledTracker)
      this._extension = extension
      this._extensionUri = extensionUri
      this._apiServer = apiServer
      this._guidelinesWatcher = guidelinesWatcher
    }
    static commandID = "vscode-augment.internal-dv.i"
    type = "public"
    run = async (...args) => {
      if (!this._extension.workspaceManager)
        throw new Error("No workspace manager")
      if (!this._extension.keybindingWatcher)
        throw new Error("No keybinding watcher")
      let editor = gf.window.activeTextEditor
      if (!editor) {
        gf.window.showInformationMessage("No active editor.")
        return
      }
      if (isNotebookCell(editor.document.uri)) {
        gf.window.showInformationMessage(
          "Code instructions are not supported in notebooks.",
        )
        return
      }
      let [uri, content, options] = args,
        resolvedUri = resolveUri(uri)
      if (resolvedUri === undefined) return
      if (resolvedUri === null) return
      let workspaceFolder = getWorkspaceFolder(resolvedUri),
        relativePath = resolvedUri.fsPath.replace(workspaceFolder.fsPath, ""),
        qualifiedPath = new QualifiedPathName(workspaceFolder.fsPath, relativePath),
        document = await VsCodeDiffDocument.fromPathName(qualifiedPath, content),
        panelOptions = { ...options, document: document, guidelinesWatcher: this._guidelinesWatcher },
        selection = editor.selection
      ;(panelOptions.instruction = {
        selection: {
          start: { line: selection.start.line, character: selection.start.character },
          end: { line: selection.end.line, character: selection.end.character },
        },
      }),
        DiffViewPanel.createOrShow(
          {
            extensionUri: this._extensionUri,
            workspaceManager: this._extension.workspaceManager,
            apiServer: this._apiServer,
            keybindingWatcher: this._extension.keybindingWatcher,
            fuzzyFsSearcher: this._extension.fuzzyFsSearcher,
            fuzzySymbolSearcher: this._extension.fuzzySymbolSearcher,
            workTimer: this._extension.workTimer,
          },
          panelOptions,
        )
    }
    canRun() {
      let featureFlags = this._extension.featureFlagManager.currentFlags,
        editor = gf.window.activeTextEditor
      return !!(featureFlags.enableInstructions && editor && !isNotebookCell(editor.document.uri))
    }
  },
  AcceptAllChunksCommand = class extends AugmentCommand {
    static commandID = "vscode-augment.internal-dv.aac"
    type = "public"
    constructor() {
      super()
    }
    run() {
      DiffViewPanel.currentPanel && DiffViewPanel.controller?.diffViewMessageHandler.acceptAllChunks()
    }
    canRun() {
      return true
    }
  },
  AcceptFocusedChunkCommand = class extends AugmentCommand {
    static commandID = "vscode-augment.internal-dv.afc"
    type = "public"
    constructor() {
      super()
    }
    run() {
      DiffViewPanel.currentPanel &&
        DiffViewPanel.controller?.diffViewMessageHandler.acceptFocusedChunk()
    }
    canRun() {
      return true
    }
  },
  RejectFocusedChunkCommand = class extends AugmentCommand {
    static commandID = "vscode-augment.internal-dv.rfc"
    type = "public"
    constructor() {
      super()
    }
    run() {
      DiffViewPanel.currentPanel &&
        DiffViewPanel.controller?.diffViewMessageHandler.rejectFocusedChunk()
    }
    canRun() {
      return true
    }
  },
  FocusPreviousChunkCommand = class extends AugmentCommand {
    static commandID = "vscode-augment.internal-dv.fpc"
    type = "public"
    constructor() {
      super()
    }
    run() {
      DiffViewPanel.currentPanel &&
        DiffViewPanel.controller?.diffViewMessageHandler.focusPreviousChunk()
    }
    canRun() {
      return true
    }
  },
  FocusNextChunkCommand = class extends AugmentCommand {
    static commandID = "vscode-augment.internal-dv.fnc"
    type = "public"
    constructor() {
      super()
    }
    run() {
      DiffViewPanel.currentPanel && DiffViewPanel.controller?.diffViewMessageHandler.focusNextChunk()
    }
    canRun() {
      return true
    }
  },
  CloseDiffViewCommand = class extends AugmentCommand {
    static commandID = "vscode-augment.internal-dv.c"
    type = "public"
    constructor() {
      super()
    }
    run() {
      DiffViewPanel.currentPanel && DiffViewPanel.currentPanel.dispose()
    }
    canRun() {
      return true
    }
  }
function resolveUri(uriOrString) {
  return uriOrString === undefined
    ? gf.window.activeTextEditor?.document.uri
    : uriOrString === null
      ? null
      : uriOrString instanceof gf.Uri
        ? uriOrString
        : gf.Uri.parse(uriOrString)
}
var yF = q(require("vscode"))
function lF() {
  return {
    startLineNumber: null,
    endLineNumber: null,
    newText: "",
    oldText: "",
    hasYieldedNewChunk: false,
    currOffset: null,
    startRefined: false,
    endRefined: false,
    newTextBuffer: "",
    prefixOverlapChecked: false,
  }
}
function cF(e) {
  return !jn(e.startLineNumber) && !jn(e.endLineNumber) && !jn(e.newText)
}
function vbe(e) {
  return (
    !e.startRefined && !jn(e.startLineNumber) && e.oldText.trim().length > 0
  )
}
function Cbe(e) {
  return !e.endRefined && !jn(e.endLineNumber) && e.oldText.trim().length > 0
}
function $mt(e, t) {
  if (vbe(e)) {
    let { isPureInsertion: r, lineBefore: n } = pbe(e)
    if (r) e.startLineNumber = Bx(t, e.startLineNumber, n, 20) + 1
    else {
      let s = e.oldText.replaceAll(/\n$/g, "").split(`
`)[0]
      e.startLineNumber = Bx(t, e.startLineNumber, s, 20)
    }
    e.startRefined = true
  }
  if (Cbe(e)) {
    let { isPureInsertion: r } = pbe(e)
    if (r) e.endLineNumber = e.startLineNumber
    else {
      let n = e.oldText.replaceAll(/\n$/g, "").split(`
`),
        i = n[n.length - 1]
      e.endLineNumber = Bx(t, e.endLineNumber - 1, i, 20) + 1
    }
    e.endRefined = true
  }
}
function uF(e) {
  let t = (e.newText.match(/\n/g) || []).length
  return {
    lineChange: {
      originalStartLineNumber: e.startLineNumber,
      originalEndLineNumber: e.endLineNumber
        ? e.endLineNumber
        : e.startLineNumber,
      modifiedStartLineNumber: e.startLineNumber,
      modifiedEndLineNumber: e.startLineNumber + t,
    },
    newText: e.newText,
  }
}
function bbe(e, t) {
  let {
    replacementStartLine: r,
    replacementEndLine: n,
    replacementText: i,
    replacementOldText: s,
  } = t
  return (
    jn(r) || (e.startLineNumber = r),
    jn(n) || (e.endLineNumber = n),
    jn(i) || (e.newText += i),
    jn(s) || (e.oldText += s),
    e
  )
}
async function* processCodeStream(e, t) {
  let r = [],
    n = lF(),
    i = e.split(`
`)
  for await (let s of xbe(t)) {
    let { replacementStartLine: o, replacementOldText: a } = s
    if ((!jn(o) || !jn(a)) && cF(n)) {
      let l = uF(n),
        c = n.currOffset ?? fF(l, r)
      r.push(l)
      let u = dF(l, c)
      ;(i = Abe([...i], u)), (n = lF())
    }
    if (((n = bbe(n, s)), vbe(n))) {
      let c = n.oldText.replaceAll(/\n$/g, "").split(`
`)[0]
      n.startLineNumber = Bx(e, n.startLineNumber, c, 20)
    }
    if (Cbe(n)) {
      let l = n.oldText.replaceAll(/\n$/g, "").split(`
`),
        c = l[l.length - 1]
      n.endLineNumber = Bx(e, n.endLineNumber, c, 20) + 1
    }
    if (cF(n)) {
      let l = uF(n)
      n.currOffset = n.currOffset ?? fF(l, r)
      let c = dF(l, n.currOffset)
      yield Abe([...i], c).join(`
`)
    }
  }
}
function Bx(e, t, r, n) {
  let i = e
    .split(
      `
`,
    )
    .map((s) => s.trimEnd())
  if (((r = r.trimEnd()), i[t - 1] === r)) return t
  for (let s = 1; s <= n; s++) {
    if (t > s && i[t - s - 1] === r) return t - s
    if (t + s <= i.length && i[t + s - 1] === r) return t + s
  }
  return t
}
function Ymt(e) {
  return !jn(e.startLineNumber) && !e.hasYieldedNewChunk
}
function _be(e, t, r, n) {
  let i = ""
  if (jn(e.startLineNumber))
    throw new Error(
      "Start line should be already set when replacement text is set",
    )
  let s = e.newTextBuffer.split(/(?<=\n)/),
    o = t.split(/(?<=\n)/).slice(0, e.startLineNumber - 1)
  if (!e.prefixOverlapChecked) {
    let c = Math.min(r, o.length)
    if (s.length <= c && !n) return i
    for (let u = c; u >= 1; u--) {
      let f = true
      for (let p = 0; p < u; p++)
        if (s[p] !== o[o.length - u + p]) {
          f = false
          break
        }
      if (f) {
        ;(s = s.slice(u)),
          (e.newText = e.newText
            .split(/(?<=\n)/)
            .slice(u)
            .join(""))
        break
      }
    }
    e.prefixOverlapChecked = true
  }
  if (((i = s.slice(0, -r).join("")), (s = s.slice(-r)), !n))
    return (e.newTextBuffer = s.join("")), i
  if (jn(e.endLineNumber))
    throw new Error("End line should be already set when edit is completed.")
  let a = t.split(/(?<=\n)/).slice(e.endLineNumber - 1),
    l = Math.min(r, a.length)
  for (let c = l; c >= 1; c--) {
    let u = true
    for (let f = 0; f < c; f++)
      if (s[s.length - c + f] !== a[f]) {
        u = false
        break
      }
    if (u) {
      ;(s = s.slice(0, -c)),
        (e.newText = e.newText
          .split(/(?<=\n)/)
          .slice(0, -c)
          .join(""))
      break
    }
  }
  return (
    (e.newTextBuffer = ""),
    (i += s.join("")),
    i.length > 0 &&
      !i.endsWith(`
`) &&
      (i += `
`),
    i
  )
}
function pbe(e) {
  if (e.oldText.length === 0) return { isPureInsertion: false, lineBefore: "" }
  let t = e.oldText.split(`
`),
    r = t[t.length - 1],
    n = "PURE INSERTION AFTER LINE:"
  return r.startsWith(n)
    ? { isPureInsertion: true, lineBefore: r.substring(n.length) }
    : { isPureInsertion: false, lineBefore: "" }
}
function* mbe(e, t, r) {
  let n = _be(e, r, 3, true)
  n.length > 0 && (yield { chunkContinue: { newText: n } })
  let i = uF(e),
    s = fF(i, t),
    o = dF(i, s)
  yield {
    chunkEnd: {
      originalStartLine: e.startLineNumber,
      originalEndLine: e.endLineNumber,
      stagedStartLine: o.lineChange.originalStartLineNumber,
      stagedEndLine: o.lineChange.originalEndLineNumber,
    },
  },
    t.push(Kmt(i, r))
}
function Kmt(e, t) {
  let r = t.split(/(?<=\n)/),
    n = {
      originalStartLineNumber: e.lineChange.originalStartLineNumber,
      originalEndLineNumber: e.lineChange.originalEndLineNumber,
      modifiedStartLineNumber: e.lineChange.modifiedStartLineNumber,
      modifiedEndLineNumber: e.lineChange.modifiedEndLineNumber,
    },
    i = e.newText.split(/(?<=\n)/)
  for (
    ;
    n.originalStartLineNumber < n.originalEndLineNumber && i.length > 0;

  ) {
    let s = i[0]
    if (r[n.originalStartLineNumber - 1] !== s) break
    n.originalStartLineNumber++, n.modifiedStartLineNumber++, (i = i.slice(1))
  }
  for (
    ;
    n.originalStartLineNumber < n.originalEndLineNumber && i.length > 0;

  ) {
    let s = i[i.length - 1]
    if (r[n.originalEndLineNumber - 2] !== s) break
    n.originalEndLineNumber--, n.modifiedEndLineNumber--, (i = i.slice(0, -1))
  }
  return {
    lineChange: {
      originalStartLineNumber: n.originalStartLineNumber,
      originalEndLineNumber: n.originalEndLineNumber,
      modifiedStartLineNumber: n.modifiedStartLineNumber,
      modifiedEndLineNumber: n.modifiedEndLineNumber,
    },
    newText: i.join(""),
  }
}
async function* hF(e, t) {
  let r = [],
    n = lF()
  for await (let i of xbe(t)) {
    let { text: s, replacementStartLine: o, replacementOldText: a } = i
    if (
      ((!jn(o) || !jn(a) || !jn(s)) &&
        cF(n) &&
        (yield* mbe(n, r, e), (n = lF())),
      (n = bbe(n, i)),
      $mt(n, e),
      Ymt(n))
    ) {
      let l = uF(n),
        c = fF(l, r),
        u = dF(l, c)
      yield {
        newChunkStart: {
          originalStartLine: n.startLineNumber,
          stagedStartLine: u.lineChange.originalStartLineNumber,
        },
      },
        (n.hasYieldedNewChunk = true)
    }
    jn(i.replacementText) ||
      ((n.newTextBuffer += i.replacementText),
      yield { chunkContinue: { newText: _be(n, e, 3, false) } })
  }
  cF(n) && (yield* mbe(n, r, e))
}
async function* xbe(e) {
  for await (let t of e)
    jn(t.replacementOldText) ||
      (yield { text: "", replacementOldText: t.replacementOldText }),
      jn(t.replacementStartLine) ||
        (yield { text: "", replacementStartLine: t.replacementStartLine }),
      jn(t.replacementText) ||
        (yield { text: "", replacementText: t.replacementText }),
      jn(t.replacementEndLine) ||
        (yield { text: "", replacementEndLine: t.replacementEndLine })
}
function Abe(e, t) {
  let r = t.newText
      ? t.newText.replaceAll(/\n$/g, "").split(`
`)
      : [],
    n = t.lineChange.originalStartLineNumber - 1,
    i =
      t.lineChange.originalEndLineNumber - t.lineChange.originalStartLineNumber
  return e.splice(n, i, ...r), e
}
function dF(e, t) {
  return {
    lineChange: {
      originalStartLineNumber: e.lineChange.originalStartLineNumber + t,
      originalEndLineNumber: e.lineChange.originalEndLineNumber + t,
      modifiedStartLineNumber: e.lineChange.modifiedStartLineNumber + t,
      modifiedEndLineNumber: e.lineChange.modifiedEndLineNumber + t,
    },
    newText: e.newText,
  }
}
function fF(e, t) {
  let r = 0
  for (let n of t) r += zmt(e, n)
  return r
}
function zmt(e, t) {
  if (ybe(e, t)) return 0
  if (ybe(t, e)) {
    let r =
      t.lineChange.originalEndLineNumber - t.lineChange.originalStartLineNumber
    return (
      t.lineChange.modifiedEndLineNumber -
      t.lineChange.modifiedStartLineNumber -
      r
    )
  } else throw new Error("Edits overlap, which is not supported")
}
function ybe(e, t) {
  return (
    e.lineChange.originalEndLineNumber <= t.lineChange.originalStartLineNumber
  )
}
function yv(e, t = null, r = null) {
  if (!t && !r) throw new Error("Must provide either a response or an error")
  if (t && r)
    throw new Error("Must provide either a response or an error, not both")
  return { type: "async-wrapper", requestId: e, error: r, baseMsg: t }
}
var AsyncMessageHandler = class {
  constructor(postMessageFn, addMessageHandlerFn, workTimer = undefined) {
    this._postMessage = postMessageFn
    this._addMsgHandler = addMessageHandlerFn
    this._workTimer = workTimer
  }
  _disposers = new Array()
  createWrappedHandler =
    (messageType, handlerFn, useTimer = true) =>
    (message) =>
      message.type !== "async-wrapper" || message.baseMsg?.type !== messageType
        ? false
        : ((async (handlerPromise) => {
            try {
              let result
              if (
                (this._workTimer && useTimer
                  ? (result = await this._workTimer.runTimed(messageType, async () => await handlerPromise))
                  : (result = await handlerPromise),
                result instanceof Error)
              )
                throw result
              let response = yv(message.requestId, result)
              this._postMessage(response)
            } catch (error) {
              if (error instanceof Error) {
                let errorResponse = yv(message.requestId, null, error.message)
                this._postMessage(errorResponse)
              }
            }
          })(handlerFn(message.baseMsg)),
          true)
  registerHandler = (messageType, handlerFn, useTimer = true) => {
    let wrappedHandler = this.createWrappedHandler(messageType, handlerFn, useTimer),
      disposer = this._addMsgHandler(wrappedHandler)
    return (
      this._disposers.push(disposer),
      () => {
        ;(this._disposers = this._disposers.filter((o) => o !== disposer)), disposer()
      }
    )
  }
  registerSidecarHandler = (handlerFn) => {
    let wrappedHandler = this.createWrappedSidecarHandler(handlerFn),
      disposer = this._addMsgHandler(wrappedHandler)
    this._disposers.push(disposer)
  }
  createWrappedSidecarHandler = (handlerFn) => (message) => {
    if (message.type !== "async-wrapper" || message.destination !== "sidecar") return
    let replyFn = (result) => {
      let response = yv(message.requestId, result)
      this._postMessage(response)
    }
    try {
      handlerFn(message.baseMsg, replyFn)
    } catch (error) {
      if (error instanceof Error) {
        let errorResponse = yv(message.requestId, null, error.message)
        this._postMessage(errorResponse)
      }
    }
  }
  registerStreamHandler = (messageType, streamHandlerFn) => {
    let wrappedHandler = this.createWrappedStreamHandler(messageType, streamHandlerFn),
      disposer = this._addMsgHandler(wrappedHandler)
    this._disposers.push(disposer)
  }
  createWrappedStreamHandler = (messageType, streamHandlerFn) => (message) =>
    message.type !== "async-wrapper" || message.baseMsg?.type !== messageType
      ? false
      : ((async () => {
          let currentRequestId = message.requestId,
            streamContext = { streamMsgIdx: 0, streamNextRequestId: `${message.requestId}-0` }
          try {
            for await (let streamItem of this._workTimer
              ? await this._workTimer.runTimed(messageType, () => streamHandlerFn(message.baseMsg))
              : streamHandlerFn(message.baseMsg)) {
              if (streamItem instanceof Error) throw streamItem
              let streamResponse = yv(currentRequestId, streamItem)
              ;(streamResponse.streamCtx = { ...streamContext }), (currentRequestId = streamContext.streamNextRequestId)
              let nextIndex = streamContext.streamMsgIdx + 1
              ;(streamContext = {
                streamMsgIdx: nextIndex,
                streamNextRequestId: `${message.requestId}-${nextIndex}`,
              }),
                this._postMessage(streamResponse)
            }
            this._postMessage({
              type: "async-wrapper",
              requestId: currentRequestId,
              error: null,
              baseMsg: { type: "empty" },
              streamCtx: { ...streamContext, isStreamComplete: true },
            })
          } catch (error) {
            let err = error
            this._postMessage({
              type: "async-wrapper",
              requestId: currentRequestId,
              error: err.message,
              baseMsg: null,
              streamCtx: { ...streamContext, isStreamComplete: true },
            })
          }
        })(),
        true)
  dispose = () => {
    for (let disposer of this._disposers) disposer()
  }
  postMessage(message) {
    let wrappedMessage = yv(crypto.randomUUID(), message)
    this._postMessage(wrappedMessage)
  }
}
function createAsyncMessageHandler(e, t = undefined) {
  return new AsyncMessageHandler(
    (r) => void e.postMessage(r),
    (r) => {
      let n = e.onDidReceiveMessage(r)
      return () => void n.dispose()
    },
    t,
  )
}
function pF(e) {
  let t = Math.floor(e / 1e3),
    r = (e % 1e3) * 1e6
  return [t, r]
}
var mF = class extends DisposableContainer {
  constructor(r) {
    super()
    this._apiServer = r
    this.addDisposable({ dispose: this._logDiffPanelResolution })
  }
  chunkResolveByStartLine = new Map()
  isAcceptAll = false
  isRejectAll = false
  requestId
  sessionOrigin
  initialRequestTime
  streamFinishTime
  applyTime
  _logger = z("DiffViewSessionReporter")
  reset = () => {
    this.chunkResolveByStartLine.clear(),
      (this.isAcceptAll = false),
      (this.isRejectAll = false),
      (this.requestId = undefined),
      (this.sessionOrigin = undefined),
      (this.initialRequestTime = undefined),
      (this.streamFinishTime = undefined),
      (this.applyTime = undefined)
  }
  reportResolution = (r) => {
    let { resolveType: n, changes: i, shouldApplyToAll: s } = r.data
    s &&
      !this.chunkResolveByStartLine.size &&
      (n === "accept" ? (this.isAcceptAll = true) : (this.isRejectAll = true))
    for (let o of i) {
      let a = o.lineChanges?.lineChanges || []
      for (let l of a) {
        let c = l.originalStart
        this.chunkResolveByStartLine.set(c, n === "accept")
      }
    }
  }
  _logDiffPanelResolution = () => {
    if (
      (this._logger.debug("Logging diff panel resolution"), !this.requestId)
    ) {
      this.reset(),
        this._logger.warn("No request id found for diff panel resolution")
      return
    }
    let n = Array.from(this.chunkResolveByStartLine.keys())
        .sort()
        .map((f) => this.chunkResolveByStartLine.get(f))
        .filter((f) => f !== undefined),
      [i, s] = this.initialRequestTime ? pF(this.initialRequestTime) : [0, 0],
      o = Date.now(),
      [a, l] = pF(o),
      [c, u] = pF(this.streamFinishTime || o)
    if (this.sessionOrigin === "instruction")
      this._apiServer.logInstructionResolution({
        request_id: this.requestId,
        is_accepted_chunks: n,
        is_accept_all: this.isAcceptAll,
        is_reject_all: this.isRejectAll,
        emit_time_sec: c,
        emit_time_nsec: u,
        resolve_time_sec: a,
        resolve_time_nsec: l,
      }),
        this._logger.debug("Logged instruction resolution")
    else if (this.sessionOrigin === "smart-paste") {
      let [f, p] = this.applyTime ? pF(this.applyTime) : [0, 0]
      this._apiServer.logSmartPasteResolution({
        request_id: this.requestId,
        is_accepted_chunks: n,
        is_accept_all: this.isAcceptAll,
        is_reject_all: this.isRejectAll,
        initial_request_time_sec: i,
        initial_request_time_nsec: s,
        stream_finish_time_sec: c,
        stream_finish_time_nsec: u,
        apply_time_sec: f,
        apply_time_nsec: p,
        resolve_time_sec: a,
        resolve_time_nsec: l,
      }),
        this._logger.debug("Logged smart paste resolution")
    } else this._logger.warn(`Unknown session origin: ${this.sessionOrigin}`)
    this.reset()
  }
}
var AF = class extends DisposableContainer {
  constructor(r, n, i, s, o) {
    super()
    this._webview = r
    this._sessionReporter = n
    this._deps = i
    this._opts = s
    this._workTimer = o
    ;(this._workspaceManager = this._deps.workspaceManager),
      (this._asyncMsgHandler = createAsyncMessageHandler(this._webview, this._workTimer)),
      this._registerMessageHandlers(),
      this.addDisposable(this._asyncMsgHandler)
  }
  _asyncMsgHandler
  _workspaceManager
  _registerMessageHandlers() {
    this._deps.fuzzyFsSearcher &&
      (this._asyncMsgHandler.registerHandler(
        "find-file-request",
        this._deps.fuzzyFsSearcher.findFiles,
      ),
      this._asyncMsgHandler.registerHandler(
        "find-folder-request",
        this._deps.fuzzyFsSearcher.findFolders,
      ),
      this._asyncMsgHandler.registerHandler(
        "find-recently-opened-files",
        this._deps.fuzzyFsSearcher.findRecentFiles,
      )),
      this._asyncMsgHandler.registerStreamHandler(
        "diff-view-fetch-pending-stream",
        () => this._opts.getCurrentStream() ?? (async function* () {})(),
      ),
      this._asyncMsgHandler.registerHandler(
        "diff-view-resolve-chunk",
        this._opts.resolveDiff,
      ),
      this._asyncMsgHandler.registerHandler(
        "diff-view-window-focus-change",
        this._onDiffViewFocusChange,
      ),
      this._asyncMsgHandler.registerHandler(
        "dispose-diff-view",
        async () => (this._opts.onUserTriggeredClose?.(), Promise.resolve({})),
      ),
      this._asyncMsgHandler.registerHandler("diff-view-loaded", () =>
        this._opts.getInitData(),
      ),
      this._asyncMsgHandler.registerHandler(
        "chat-instruction-message",
        this._onUserSendInstruction.bind(this),
      )
  }
  notifyReinit() {
    this._webview.postMessage({ type: "diff-view-notify-reinit" })
  }
  acceptAllChunks() {
    this._sessionReporter.chunkResolveByStartLine.size ||
      (this._sessionReporter.isAcceptAll = true),
      this._webview.postMessage({ type: "diff-view-accept-all-chunks" })
  }
  acceptFocusedChunk() {
    this._webview.postMessage({ type: "diff-view-accept-selected-chunk" })
  }
  rejectFocusedChunk() {
    this._webview.postMessage({ type: "diff-view-reject-focused-chunk" })
  }
  focusPreviousChunk() {
    this._webview.postMessage({ type: "diff-view-focus-prev-chunk" })
  }
  focusNextChunk() {
    this._webview.postMessage({ type: "diff-view-focus-next-chunk" })
  }
  _onDiffViewFocusChange = (r) => {
    let n = r.data
    return setVSCodeContext("vscode-augment.internal-dv.panel-focused", n), { type: "empty" }
  }
  async _onUserSendInstruction(r) {
    if (
      (this._deps.logger.info(`onUserSendInstruction: ${JSON.stringify(r)}`),
      r.type !== "chat-instruction-message" ||
        !("data" in r) ||
        typeof r.data != "object" ||
        !("instruction" in r.data))
    )
      throw new Error("Invalid message type or data for instruction")
    let n = this._deps.apiServer.createRequestId()
    try {
      let i = this._runChatInstructionStream(r, n)
      DiffViewPanel.createOrShow(this._deps, {
        ...this._opts,
        viewOptions: yF.ViewColumn.Active,
        document: await VsCodeDiffDocument.fromPathName(this._opts.document.filePath),
      }),
        DiffViewPanel.startStream(
          hF(this._opts.document.originalCode ?? "", i),
          n,
          "instruction",
        )
    } catch (i) {
      throw (yF.window.showErrorMessage(`Failed to send instruction: ${i}`), i)
    }
    return { type: "empty" }
  }
  async *_runChatInstructionStream(r, n) {
    if (!this._opts.guidelinesWatcher) {
      this._deps.logger.error("Guidelines watcher not initialized")
      return
    }
    let { instruction: i, selectedCodeDetails: s } = r.data,
      {
        selectedCode: o,
        prefix: a,
        suffix: l,
        path: c,
        language: u,
        prefixBegin: f,
        suffixEnd: p,
      } = s
    this._deps.logger.info(`Sending request to the instruction model: ${n}`)
    let g = this._workspaceManager.getContext(),
      m
    !this._opts.document.isEmptyDocument && !this._opts.document.isUntitled
      ? (m = this._workspaceManager.getBlobName(this._opts.document.filePath))
      : (m = g.blobs.checkpointId)
    try {
      let y = this._opts.guidelinesWatcher.getUserGuidelinesContent(),
        v = this._opts.guidelinesWatcher.getCurrentWorkspaceGuidelinesContent(
          this._workspaceManager,
        ),
        C = await this._deps.apiServer.chatInstructionStream(
          n,
          i,
          g.blobs,
          [],
          o,
          a,
          l,
          c,
          m,
          f,
          p,
          u,
          y,
          v,
        )
      for await (let E of C) yield E
    } catch (y) {
      throw (
        (this._deps.logger.error(`Error in runChatInstructionStream: ${getErrorMessage(y)}`),
        y)
      )
    }
  }
}
var Rx = q(require("vscode"))
function Sbe() {
  let e = "",
    t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
  for (let r = 0; r < 32; r++)
    e += t.charAt(Math.floor(Math.random() * t.length))
  return e
}
var vF = class extends DisposableContainer {
  constructor(r, n, i, s) {
    super()
    this.streamId = r
    this.requestId = n
    this._stream = i
    this._logger = s
    ;(this._copyableGenerator = new mm(this._stream)),
      this.addDisposable({ dispose: () => this._cancelToken?.dispose() })
  }
  _cancelToken = new Rx.CancellationTokenSource()
  _copyableGenerator
  get stream() {
    return this._formatStream(this._copyableGenerator.copy())
  }
  cancel = () => {
    this._cancelToken?.cancel(),
      this._copyableGenerator.cancel(),
      this.dispose()
  }
  _resetStream = () => {
    this._cancelToken?.cancel(),
      this._cancelToken?.dispose(),
      (this._cancelToken = new Rx.CancellationTokenSource())
  }
  async *_formatStream(r) {
    this._resetStream()
    let n = this._cancelToken.token,
      i = `${this.streamId}-${Sbe()}`
    try {
      yield this._streamStartedMsg(i)
      for await (let s of r) {
        if (n.isCancellationRequested) break
        yield this._streamDataMsg(i, s)
      }
    } catch (s) {
      this._notifyStreamError(s)
    } finally {
      yield this._streamEndedMsg(i)
    }
  }
  _notifyStreamError(r) {
    Rx.window.showWarningMessage(
      "Error streaming in changes to Augment Diff. Please try again.",
    ),
      this._logger.error(
        `Error streaming in changes to Augment Diff: ${r.message}`,
      )
  }
  _streamStartedMsg = (r) => ({
    data: { streamId: r, requestId: this.requestId },
    type: "diff-view-diff-stream-started",
  })
  _streamDataMsg = (r, n) => ({
    data: { ...n, streamId: r, requestId: this.requestId },
    type: "diff-view-diff-stream-chunk",
  })
  _streamEndedMsg = (r) => ({
    data: { streamId: r, requestId: this.requestId },
    type: "diff-view-diff-stream-ended",
  })
}
var CF = class extends DisposableContainer {
  constructor(r, n, i, s, o) {
    super()
    this._panel = r
    this._deps = n
    this._opts = i
    this._workTimer = s
    ;(this._sessionReporter = new mF(this._deps.apiServer)),
      o && (this._sessionReporter.applyTime = o.applyTime),
      (this._diffViewMessageHandler = new AF(
        this._panel.webview,
        this._sessionReporter,
        this._deps,
        {
          ...this._opts,
          getInitData: this.getInitData,
          resolveDiff: this.resolveDiff,
          getCurrentStream: () => this._stream?.stream,
        },
        this._workTimer,
      )),
      this.addDisposable(this._diffViewMessageHandler),
      this.addDisposable(this._sessionReporter),
      this.addDisposable(this._opts.document),
      this._diffViewMessageHandler.notifyReinit()
  }
  _sessionReporter
  _diffViewMessageHandler
  _currentSelection
  _stream
  get diffViewMessageHandler() {
    return this._diffViewMessageHandler
  }
  get sessionReporter() {
    return this._sessionReporter
  }
  startStream(r, n, i) {
    ;(this._sessionReporter.requestId = n),
      (this._sessionReporter.sessionOrigin = i),
      (this._sessionReporter.initialRequestTime = Date.now()),
      this._cleanupStream(),
      (this._stream = new vF(
        this._deps.apiServer.createRequestId(),
        n,
        r,
        this._deps.logger,
      ))
  }
  _cleanupStream = () => {
    this._stream?.cancel(), (this._stream = undefined)
  }
  getInitData = () => {
    let r = this._opts?.instruction?.selection,
      n = {
        type: "diff-view-initialize",
        data: {
          file: {
            repoRoot: "",
            pathName: "",
            originalCode: "",
            modifiedCode: "",
          },
          keybindings: this.keybindings,
          instruction: r && {
            selection: {
              start: { line: r?.start.line, character: r?.start.character },
              end: { line: r?.end.line, character: r?.end.character },
            },
          },
          editable: this._opts.editable,
          disableResolution: this._opts.disableResolution,
          disableApply: this._opts.disableApply,
        },
      }
    if (this._opts?.instruction) {
      let { selection: i } = this._opts.instruction,
        { start: s, end: o } = i
      this._currentSelection = new Yl.Selection(
        new Yl.Position(s.line, s.character),
        new Yl.Position(o.line, o.character),
      )
    }
    return (
      this._opts.document.isEmptyDocument ||
        ((n.data.file.pathName = this._opts.document.absPath),
        (n.data.file.originalCode = this._opts.document.originalCode),
        (n.data.file.modifiedCode = this._opts.document.modifiedCode)),
      Promise.resolve(n)
    )
  }
  resolveDiff = async (r) => {
    let { file: n, resolveType: i, changes: s } = r.data
    this._sessionReporter.reportResolution(r)
    let o = Yl.Uri.file(this._opts.document?.absPath ?? "").fsPath,
      a = Yl.Uri.file(n.pathName).fsPath,
      l = n.modifiedCode === undefined
    if (!this._opts.document || o !== a || l) return { type: "empty" }
    if (
      (i === "accept" || i === "reject") &&
      this._opts.document.updateCodeVersions(n.originalCode, n.modifiedCode)
    ) {
      let u = await Yl.workspace.openTextDocument(this._opts.document.absPath)
      s && s.length > 0 && u && this.updateChangeRange(u, s, i)
    }
    return { type: "empty" }
  }
  updateChangeRange = (r, n, i) => {
    if (!this._currentSelection) return
    let s = this._currentSelection.start.line,
      o = this._currentSelection.end.line,
      a = Number.MAX_SAFE_INTEGER,
      l = 0
    for (let u of n)
      if (u.lineChanges && u.lineChanges.lineChanges)
        for (let f of u.lineChanges.lineChanges)
          (a = Math.min(a, f.originalStart)), (l = Math.max(l, f.modifiedEnd))
    i === "accept" && ((s = Math.min(s, a - 1)), (o = Math.max(o, l - 1))),
      (s = Math.max(0, s)),
      (o = Math.min(r.lineCount - 1, o))
    let c = r.lineAt(o).range.end
    this._currentSelection = new Yl.Selection(new Yl.Position(s, 0), c)
  }
  get keybindings() {
    return {
      acceptAllChunks:
        this._deps.keybindingWatcher.getKeybindingForCommand(
          AcceptAllChunksCommand.commandID,
          true,
        ) ?? "",
      rejectAllChunks:
        this._deps.keybindingWatcher.getKeybindingForCommand(
          CloseDiffViewCommand.commandID,
          true,
        ) ?? "",
      acceptFocusedChunk:
        this._deps.keybindingWatcher.getKeybindingForCommand(
          AcceptFocusedChunkCommand.commandID,
          true,
        ) ?? "",
      rejectFocusedChunk:
        this._deps.keybindingWatcher.getKeybindingForCommand(
          RejectFocusedChunkCommand.commandID,
          true,
        ) ?? "",
      focusPrevChunk:
        this._deps.keybindingWatcher.getKeybindingForCommand(
          FocusPreviousChunkCommand.commandID,
          true,
        ) ?? "",
      focusNextChunk:
        this._deps.keybindingWatcher.getKeybindingForCommand(
          FocusNextChunkCommand.commandID,
          true,
        ) ?? "",
    }
  }
}
var mi = q(require("vscode"))
function jmt(e, t, r, n) {
  if (t.length === 0 && r.length === 0) return false
  let i
  if (t.length > 0 && r.length > 0) {
    let s = t[0].start.line,
      o = r[0].start.line
    i = s <= o ? t[0] : r[0]
  } else t.length > 0 ? (i = t[0]) : r.length > 0 && (i = r[0])
  return i
    ? (e.revealRange(i, n ?? mi.TextEditorRevealType.InCenterIfOutsideViewport),
      true)
    : false
}
function Zmt() {
  let e =
    mi.window.activeColorTheme.kind === mi.ColorThemeKind.Dark ||
    mi.window.activeColorTheme.kind === mi.ColorThemeKind.HighContrast
  return {
    added: {
      background: e ? "rgba(0, 255, 0, 0.1)" : "rgba(0, 200, 0, 0.05)",
      text: e ? "rgba(150, 255, 150, 0.9)" : "rgba(0, 100, 0, 0.8)",
    },
    removed: {
      background: "rgba(255, 0, 0, 0.05)",
      text: e ? "rgba(255, 200, 200, 0.9)" : "rgba(150, 0, 0, 0.8)",
      border: "rgba(150, 0, 0, 0.3)",
    },
  }
}
function createEditorDecorations(e, t, r, n) {
  let i = Zmt(),
    s = mi.window.createTextEditorDecorationType({
      backgroundColor: i.added.background,
      isWholeLine: true,
      after: { color: i.added.text, margin: "0 0 0 1em" },
    }),
    o = mi.window.createTextEditorDecorationType({
      isWholeLine: true,
      before: {
        color: i.removed.text,
        border: `1px solid ${i.removed.border}`,
        backgroundColor: i.removed.background,
        margin: "0 5px 0 0",
      },
    }),
    a = nI("original", "modified", t, r, "", "", { context: 0 }),
    l = [],
    c = []
  for (let f of a.hunks) {
    let p = f.newStart - 1,
      g = false,
      m = 0,
      y = ""
    for (let v of f.lines)
      if (v.startsWith("+")) {
        if (p < e.document.lineCount) {
          let C = new mi.Range(
            new mi.Position(p, 0),
            new mi.Position(p, e.document.lineAt(p).text.length),
          )
          l.push(C)
        }
        p++
      } else
        v.startsWith("-") &&
          ((g = true),
          m++,
          (y +=
            v.substring(1) +
            `
`))
    if (g) {
      let v = Math.max(0, f.newStart - 2)
      if (v < e.document.lineCount) {
        let C = new mi.Range(
          new mi.Position(v, 0),
          new mi.Position(v, e.document.lineAt(v).text.length),
        )
        c.push({ range: C, count: m, removedContent: y.trim() })
      }
    }
  }
  e.setDecorations(s, l)
  let u = c.map((f) => {
    let p = new mi.MarkdownString()
    return (
      p.appendMarkdown(`**Removed content:**

`),
      p.appendCodeblock(f.removedContent, "diff"),
      (p.isTrusted = true),
      (p.supportHtml = true),
      {
        range: f.range,
        renderOptions: {
          before: {
            contentText: `\u2296 ${f.count} line${f.count === 1 ? "" : "s"} removed`,
            color: i.removed.text,
            border: `1px solid ${i.removed.border}`,
            backgroundColor: i.removed.background,
            margin: "0 5px 0 0",
          },
        },
        hoverMessage: p,
      }
    )
  })
  return (
    e.setDecorations(o, u),
    n?.scrollToFirstDecoration &&
      jmt(
        e,
        l,
        c.map((f) => f.range),
        n.revealType,
      ),
    [s, o]
  )
}
function scheduleDecorationCleanup(e, t) {
  let n = 1e4 * (Math.log(e.length + 1) / Math.log(4)),
    { minDelayMs: i = 1e4, maxDelayMs: s = 3e4 } = t,
    o = Math.min(Math.max(n, i), s)
  setTimeout(() => {
    e.forEach((a) => a.dispose())
  }, o)
}
function highlightChanges(e, t) {
  let r = [],
    n = mi.workspace.onDidChangeTextDocument((i) => {
      i.document.uri.toString() === e.document.uri.toString() &&
        (t.forEach((s) => s.dispose()), r.forEach((s) => void s.dispose()))
    })
  return (
    r.push(n),
    {
      dispose: () => {
        r.forEach((i) => void i.dispose())
      },
    }
  )
}
var Qbe = q(require("path")),
  IF = q(require("vscode"))
async function getDevServerContent(e, t, r) {
  if (!isDevelopment()) throw new Error("Not in HMR mode")
  let n = await fetch(`${e}/${t}`)
  if (!n.ok) throw new Error(`Failed to load ${t} from ${e}: ${n.statusText}`)
  let i = await n.text()
  if (!i?.trim())
    throw new Error(
      `Empty response when loading ${t} from ${e}: ${n.statusText}`,
    )
  return injectHtmlHeadTags(i, e, r)
}
var Dx
async function getDevServerUrl(e) {
  if (Dx) return Dx
  let t = await import("fs"),
    r = e.fsPath + "/.augment-hmr-env"
  if (
    ((Dx = t
      .readFileSync(r, "utf8")
      .split(
        `
`,
      )
      .filter((i) => !/^\s*(#|$)/.test(i))
      .reduce((i, s) => {
        let [o, a] = s.split("=")
        return (i[o] = a), i
      }, {}).AUGMENT_HMR),
    !Dx)
  )
    throw new Error(`Failed to load HMR url from '${r}'`)
  return Dx
}
function injectHtmlHeadTags(e, t, r) {
  return e.replace(
    "<head>",
    `<head><base href="${t}" /><meta http-equiv="Content-Security-Policy" content="${r}" />`,
  )
}
function isDevelopment() {
  return (
    !!process.env.AUGMENT_IS_HMR && process.env.AUGMENT_JS_ENV !== "production"
  )
}
function bF(...e) {
  let t = {
    scripts: new Set(),
    styles: new Set(["'unsafe-inline'"]),
    fonts: new Set(),
    images: new Set(),
    media: new Set(),
    workers: new Set(),
    connects: new Set(),
  }
  for (let i of e) i(t)
  let r = ["default-src 'none';"],
    n = {
      "font-src": t.fonts,
      "style-src": t.styles,
      "script-src": t.scripts,
      "img-src": t.images,
      "media-src": t.media,
      "worker-src": t.workers,
      "connect-src": t.connects,
    }
  for (let [i, s] of Object.entries(n)) {
    let o = Array.from(s).sort()
    o.length !== 0 && r.push(`${i} ${o.join(" ")};`)
  }
  return r.join(" ")
}
function EF() {
  return (e) => {
    e.fonts.add("https://fonts.gstatic.com"),
      e.styles.add("https://fonts.googleapis.com")
  }
}
function kbe() {
  return (e) => {
    e.images.add("https://www.google.com"),
      e.images.add("https://*.gstatic.com"),
      e.images.add("https://s2.googleusercontent.com")
  }
}
function _F(e) {
  return (t) => {
    t.scripts.add(e.cspSource),
      t.styles.add(e.cspSource),
      t.images.add(e.cspSource),
      t.fonts.add(e.cspSource),
      t.media.add(e.cspSource)
  }
}
function xF() {
  return (e) => {
    e.images.add("data:"), e.images.add("blob:")
  }
}
function wF() {
  return (e) => {
    e.styles.add("'unsafe-inline'"),
      e.fonts.add("data:"),
      e.workers.add("blob:")
  }
}
function SF() {
  return (e) => {
    e.fonts.add(
      "https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.52.2/min/",
    ),
      e.styles.add(
        "https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.52.2/min/",
      ),
      e.scripts.add(
        "https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.52.2/min/",
      ),
      e.scripts.add("'unsafe-inline'")
  }
}
function Mbe(e) {
  if (!isDevelopment()) return () => {}
  let t = e.replace(/^https?:/, "ws:")
  return (r) => {
    ;[
      "fonts",
      "styles",
      "scripts",
      "workers",
      "media",
      "images",
      "connects",
    ].forEach((n) => {
      r[n].add(e).add(t)
    })
  }
}
function Fbe() {
  return (e) => {
    e.connects.add("https://cdn.jsdelivr.net"),
      e.connects.add("https://unpkg.com"),
      e.scripts.add("https://cdn.jsdelivr.net"),
      e.scripts.add("https://unpkg.com"),
      e.scripts.add("'unsafe-eval'"),
      e.workers.add("blob:"),
      e.connects.add("vscode-resource:"),
      e.connects.add("https://*.vscode-cdn.net")
  }
}
var PanelWebview = class extends DisposableContainer {
  constructor(filename, webview) {
    super()
    this.filename = filename
    this._webview = webview
  }
  _logger = z("PanelWebviewBase")
  generateCSPPolicy(r) {
    return bF(
      _F(this._webview),
      EF(),
      kbe(),
      xF(),
      wF(),
      SF(),
      Fbe(),
      r ? Mbe(r) : () => {},
    )
  }
  async loadHTML(extensionUri) {
    if (isDevelopment())
      try {
        let devServerUrl = await getDevServerUrl(extensionUri)
        this._logger.debug(
          "Loading '%s' from dev server on '%s'",
          this.filename,
          devServerUrl,
        ),
          (this._webview.options = {
            enableScripts: true,
            localResourceRoots: [IF.Uri.parse(devServerUrl)],
          }),
          (this._webview.html = await getDevServerContent(
            devServerUrl,
            this.filename,
            this.generateCSPPolicy(devServerUrl),
          ))
        return
      } catch (error) {
        this._logger.error(
          `Failed to load '%s' from dev server: ${String(error)} `,
          this.filename,
        ),
          (this._webview.html = (
            await this._loadFile(extensionUri, "../../common/webviews/index.html")
          ).replace("></code>", `>${String(error)}</code>`))
        return
      }
    this._webview.html = await this._loadFile(extensionUri, this.filename)
  }
  async _loadFile(extensionUri, relativePath) {
    let webviewRoot = IF.Uri.joinPath(extensionUri, "common-webviews"),
      webviewUri = this._webview.asWebviewUri(IF.Uri.joinPath(webviewRoot, "/"))
    this._webview.options = { enableScripts: true, localResourceRoots: [webviewRoot] }
    let filePath = await readTextFile(Qbe.join(webviewRoot.fsPath, relativePath))
    try {
      return injectHtmlHeadTags(filePath, webviewUri.toString(), this.generateCSPPolicy())
    } catch (error) {
      throw (this._logger.error(`Failed to load ${relativePath}: ${String(error)}`), error)
    }
  }
}
var DiffViewPanel = class DiffViewPanel extends PanelWebview {
  constructor(
    dependencies,
    options,
    panel = zi.window.createWebviewPanel(
      DiffViewPanel.viewType,
      "Augment",
      options.viewOptions ?? zi.ViewColumn.Active,
      { retainContextWhenHidden: true, enableScripts: true },
    ),
  ) {
    super("diff-view.html", panel.webview)
    this._deps = dependencies
    this._opts = options
    this._panel = panel
    ;(this._panel.iconPath = {
      light: zi.Uri.joinPath(
        this._deps.extensionUri,
        "media",
        "panel-icon-light.svg",
      ),
      dark: zi.Uri.joinPath(
        this._deps.extensionUri,
        "media",
        "panel-icon-dark.svg",
      ),
    }),
      (this._controller = this._updateOpts(this._opts)),
      this._panel.onDidDispose(() => {
        this.dispose()
      }),
      this.addDisposables(
        this._controller,
        this._panel,
        new zi.Disposable(() => {
          DiffViewPanel.currentPanel = undefined
        }),
      ),
      this.loadHTML(dependencies.extensionUri)
  }
  static viewType = "augmentDiffView"
  logger = z("DiffViewWebviewPanel")
  static currentPanel
  _controller
  get diffViewController() {
    return this._controller
  }
  dispose = () => {
    this._opts.onDispose?.(),
      this._controller.dispose(),
      this._panel.dispose(),
      (DiffViewPanel.currentPanel = undefined),
      super.dispose()
  }
  _updateOpts = (options) => (
    (this._opts = options),
    this._controller?.dispose(),
    (this._controller = new CF(
      this._panel,
      { ...this._deps, panel: this._panel, logger: this.logger },
      { ...this._opts, onUserTriggeredClose: () => this.dispose() },
      this._deps.workTimer,
    )),
    this._controller
  )
  static get controller() {
    return this.currentPanel?.diffViewController
  }
  static get currentDocument() {
    return this.currentPanel?._opts.document
  }
  static get isVisible() {
    return this.currentPanel?._panel.visible
  }
  static startStream = (requestId, prompt, options) => {
    this.currentPanel?.diffViewController.startStream(requestId, prompt, options)
  }
  static async instantApply(dependencies, options, modifiedCode) {
    let document = options.document,
      originalCode = document.originalCode,
      newCode = modifiedCode,
      filePath = document.absPath,
      finalCode = ""
    for await (let chunk of processCodeStream(originalCode ?? "", newCode)) finalCode = chunk
    let vsDocument = await zi.workspace.openTextDocument(filePath),
      edit = new zi.WorkspaceEdit()
    edit.replace(vsDocument.uri, new zi.Range(0, 0, vsDocument.lineCount, 0), finalCode),
      await zi.workspace.applyEdit(edit)
    let editor = await zi.window.showTextDocument(vsDocument),
      decorations = createEditorDecorations(editor, originalCode ?? "", finalCode, {
        scrollToFirstDecoration: true,
        revealType: zi.TextEditorRevealType.InCenterIfOutsideViewport,
      })
    scheduleDecorationCleanup(decorations, { minDelayMs: 3e4 }), highlightChanges(editor, decorations)
    let changes = Kf(originalCode ?? "", finalCode).map((diff) => ({
        repoRoot: document.filePath.rootPath,
        pathName: document.filePath.relPath,
        originalCode: diff.removed ? diff.value : "",
        modifiedCode: diff.added ? diff.value : "",
      })),
      resolutionData = {
        file: {
          repoRoot: document.filePath.rootPath,
          pathName: document.filePath.relPath,
          originalCode: originalCode ?? "",
          modifiedCode: finalCode,
        },
        changes: changes,
        resolveType: "accept",
        shouldApplyToAll: true,
      }
    return (
      this.controller?.sessionReporter.reportResolution({
        type: "diff-view-resolve-chunk",
        data: resolutionData,
      }),
      finalCode
    )
  }
  static createOrShow(dependencies, options) {
    if (options.document.isEmptyDocument) return
    DiffViewPanel.currentPanel
      ? DiffViewPanel.currentPanel._updateOpts(options)
      : (DiffViewPanel.currentPanel = new DiffViewPanel(dependencies, options))
    let panel = DiffViewPanel.currentPanel,
      filePath = options.document.filePath,
      fileName = Nbe.default.basename(filePath.absPath)
    ;(panel._panel.title = `Augment Diff - ${fileName}`), panel._panel.reveal()
  }
}
var BF = class {
  constructor(t, r, n, i, s, o, a) {
    this._extensionUri = t
    this._workspaceManager = r
    this._apiServer = n
    this._keybindingWatcher = i
    this._fuzzyFsSearcher = s
    this._fuzzySymbolSearcher = o
    this._workTimer = a
  }
  showDiffView(t, r, n, i) {
    let s = DiffViewPanel.isVisible ?? false
    if (i.retainFocus && !s) return Promise.resolve()
    let o = {
      editable: false,
      disableResolution: true,
      document: new DiffViewDocument(new QualifiedPathName(t.rootPath, t.relPath), r, n, {}),
      viewOptions: { preserveFocus: true, viewColumn: Pbe.ViewColumn.Active },
    }
    return this._createOrShowDiffView(o), Promise.resolve()
  }
  _createOrShowDiffView(t) {
    DiffViewPanel.createOrShow(
      {
        extensionUri: this._extensionUri,
        workspaceManager: this._workspaceManager,
        apiServer: this._apiServer,
        keybindingWatcher: this._keybindingWatcher,
        fuzzyFsSearcher: this._fuzzyFsSearcher,
        fuzzySymbolSearcher: this._fuzzySymbolSearcher,
        workTimer: this._workTimer,
      },
      t,
    )
  }
}
var RF = class {
  constructor(t, r) {
    this.auth = t
    this.configListener = r
  }
  async getAPIToken() {
    if (this.auth.useOAuth) {
      let t = await this.auth.getSession()
      if (t) return t.accessToken
    }
    return this.configListener.config.apiToken
  }
  async getCompletionURL() {
    if (this.auth.useOAuth) {
      let t = await this.auth.getSession()
      if (t) return t.tenantURL
    }
    return this.configListener.config.completionURL
  }
  removeAuthSession() {
    return this.auth.removeSession()
  }
}
var DF = class {
  constructor(t) {
    this.configListener = t
  }
  getConfig() {
    return Promise.resolve(this.configListener.config)
  }
}
var kx = class {
  constructor(t) {
    this._featureFlagManager = t
  }
  get flags() {
    return {
      enableAgentMode: isMinVersionMet(
        UM() === 0
          ? (this._featureFlagManager.currentFlags.vscodeAgentModeMinVersion ??
              "")
          : (this._featureFlagManager.currentFlags
              .vscodeAgentModeMinStableVersion ?? ""),
      ),
      enableChatWithTools: isMinVersionMet(
        this._featureFlagManager.currentFlags.vscodeChatWithToolsMinVersion ??
          "",
      ),
      agentEditTool:
        this._featureFlagManager.currentFlags.vscodeAgentEditTool ?? "",
      agentEditToolMinViewSize:
        this._featureFlagManager.currentFlags.agentEditToolMinViewSize ?? 0,
      agentEditToolSchemaType:
        this._featureFlagManager.currentFlags.agentEditToolSchemaType ??
        "StrReplaceEditorToolDefinitionNested",
      memoriesParams:
        this._featureFlagManager.currentFlags.memoriesParams ?? {},
    }
  }
}
var Ja = q(require("vscode"))
var TF = class {
  constructor(t) {
    this._workspaceManager = t
  }
  getCwd() {
    return Promise.resolve(gm(this._workspaceManager))
  }
  async readFile(t) {
    await this._workspaceManager.awaitInitialFoldersEnumerated()
    let r = await pm(t, this._workspaceManager),
      n = $u(t, this._workspaceManager)
    return { contents: r, filepath: n }
  }
  async writeFile(t, r) {
    let n = await Xmt(t, r)
    if (!n || n.getText() === r) return
    let i = new Ja.WorkspaceEdit()
    i.replace(n.uri, new Ja.Range(0, 0, n.lineCount, 0), r),
      await Ja.workspace.applyEdit(i),
      await n.save()
  }
  async deleteFile(t) {
    if (fileExists(t.absPath))
      try {
        let r = Ja.Uri.file(t.absPath)
        await Ja.workspace.fs.delete(r)
      } catch (r) {
        console.error(`Failed to delete file ${t.absPath}:`, r)
      }
  }
  onFileDeleted(t) {
    return this._workspaceManager.onFileDeleted(t)
  }
  onFileDidMove(t) {
    return this._workspaceManager.onFileDidMove(t)
  }
}
async function Xmt(e, t) {
  try {
    let r
    if (ube(e)) r = findUntitledDocument(e)
    else if (fileExists(e.absPath)) r = await Ja.workspace.openTextDocument(e.absPath)
    else {
      let n = Ja.Uri.file(e.absPath)
      await Ja.workspace.fs.writeFile(n, Buffer.from(t ?? "")),
        (r = await Ja.workspace.openTextDocument(n))
    }
    if (r === undefined) throw new Error(`Failed to open document ${e.absPath}`)
    return r
  } catch {
    return
  }
}
var kF = class {
  constructor(t) {
    this._extensionContext = t
    this.migrateKeys(
      oh.hasEverUsedAgent,
      this.getKey(du.agent, oh.hasEverUsedAgent),
    )
  }
  async getValue(t, r, n) {
    if (n !== hc.global) throw new Error(`Scope ${String(n)} is not supported`)
    return await this._extensionContext.globalState.get(this.getKey(t, r))
  }
  async setValue(t, r, n, i) {
    if (i !== hc.global) throw new Error(`Scope ${String(i)} is not supported`)
    await this._extensionContext.globalState.update(this.getKey(t, r), n)
  }
  getKey(t, r) {
    return ["sidecar", t, r].join(".")
  }
  async migrateKeys(t, r) {
    let n = await this._extensionContext.globalState.get(t)
    n !== undefined &&
      (await this._extensionContext.globalState.update(r, n),
      await this._extensionContext.globalState.update(t, undefined))
  }
}
var MF = class {
  constructor(t, r) {
    this._apiServer = t
    this._workspaceManager = r
  }
  async chatStream(t, r, n, i, s, o, a) {
    return await this._apiServer.chatStream(
      r,
      t,
      n,
      { checkpointId: undefined, addedBlobs: [], deletedBlobs: [] },
      [],
      [],
      a ?? undefined,
      { workingDirectory: [], commits: [] },
      [],
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      i,
      s,
      o,
      undefined,
      undefined,
    )
  }
  agentCodebaseRetrieval(t, r, n, i, s) {
    return this._apiServer.agentCodebaseRetrieval(
      t,
      r,
      this._workspaceManager.getContext().blobs,
      n,
      i,
      s,
    )
  }
  logToolUseRequestEvent(t) {
    return this._apiServer.logToolUseRequestEvent(t)
  }
  logAgentRequestEvent(t) {
    return this._apiServer.logAgentRequestEvent(t)
  }
  logAgentSessionEvent(t) {
    return this._apiServer.logAgentSessionEvent(t)
  }
  logRemoteAgentSessionEvent(t) {
    return this._apiServer.logRemoteAgentSessionEvent(t)
  }
  checkToolSafety(t, r) {
    return this._apiServer.checkToolSafety(t, r)
  }
}
var R1 = q(require("vscode"))
var dg = q(require("vscode"))
var FF = "remoteAgentStore"
var vv = q(require("vscode")),
  QF = class {
    constructor(t, r) {
      this._apiServer = t
      this._configListener = r
    }
    get execOptions() {
      let t = vv.workspace.workspaceFolders?.[0]
      if (!t) throw new Error("No workspace folder found")
      return { cwd: t.uri.fsPath }
    }
    get isUsingDevDeploy() {
      return !!this._configListener.config.completionURL
    }
    register(t) {
      t.registerHandler(
        "get-git-branches-request",
        this.handleGetGitBranchesRequest.bind(this),
      ),
        t.registerHandler(
          "get-workspace-diff-request",
          this.handleGetWorkspaceDiffRequest.bind(this),
        ),
        t.registerHandler(
          "get-remote-url-request",
          this.handleGetRemoteUrlRequest.bind(this),
        ),
        t.registerHandler(
          "git-fetch-request",
          this.handleGitFetchRequest.bind(this),
        ),
        t.registerHandler(
          "is-git-repository-request",
          this.handleIsGitRepositoryRequest.bind(this),
        ),
        t.registerHandler(
          "is-github-authenticated-request",
          this.handleIsGithubAuthenticatedRequest.bind(this),
        ),
        t.registerHandler(
          "authenticate-github-request",
          this.handleAuthenticateGithubRequest.bind(this),
        ),
        t.registerHandler(
          "revoke-github-access-request",
          this.handleRevokeGithubAccessRequest.bind(this),
        ),
        t.registerHandler(
          "list-github-repos-for-authenticated-user-request",
          this.handleListUserReposRequest.bind(this),
        ),
        t.registerHandler(
          "list-github-repo-branches-request",
          this.handleListRepoBranchesRequest.bind(this),
        ),
        t.registerHandler(
          "get-current-local-branch-request",
          this.handleGetCurrentLocalBranchRequest.bind(this),
        )
    }
    async handleGetGitBranchesRequest(t) {
      try {
        let { prefix: r = "" } = t.data,
          { execOptions: n } = this,
          i = [],
          s = (await this.executeGetCurrentBranch())?.trim(),
          o = !!(await So(
            "git branch -r | grep $(git branch --show-current)",
            n,
          )),
          a = (
            await So("git symbolic-ref --short refs/remotes/origin/HEAD", n)
          )?.trim(),
          u = (
            await So("git branch --list --remote", n).then((f) =>
              f
                ?.split(
                  `
`,
                )
                .map((p) => p.replace(/^[ *]+/, ""))
                .filter(Boolean),
            )
          )
            ?.map((f) => {
              if (!(f === s || f === a) && f.includes(r)) return f
            })
            .filter(Boolean)
        return (
          s && u?.unshift(s),
          a && u?.unshift(a),
          u?.forEach((f) => {
            i.push({
              name: f.trim(),
              isRemote: f === s ? o : true,
              isCurrentBranch: f === s,
              isDefault: f === a,
            })
          }),
          { type: "get-git-branches-response", data: { branches: i } }
        )
      } catch (r) {
        return (
          console.error("Failed to get git branches:", r),
          { type: "get-git-branches-response", data: { branches: [] } }
        )
      }
    }
    async handleGetWorkspaceDiffRequest(t) {
      try {
        let { branchName: r } = t.data,
          n =
            (await So(`git diff origin/${r} || true`, this.execOptions)) || "",
          i =
            (await So(
              "git ls-files --others --exclude-standard",
              this.execOptions,
            )) || ""
        for (let s of i.trimEnd().split(`
`) || [])
          n +=
            (await So(
              process.platform === "win32"
                ? `git diff --no-index NUL ${s} || exit 0`
                : `git diff --no-index /dev/null ${s} || true`,
              this.execOptions,
            )) || ""
        return { type: "get-workspace-diff-response", data: { diff: n } }
      } catch (r) {
        return (
          console.error("Failed to get workspace diff:", r),
          { type: "get-workspace-diff-response", data: { diff: "" } }
        )
      }
    }
    async handleGetRemoteUrlRequest(t) {
      let { execOptions: r } = this
      try {
        let n = (await So("git remote get-url origin", r))?.trim()
        if (!n) throw new Error("Failed to get remote url, no remote found")
        if (!!n?.startsWith("https://"))
          return { type: "get-remote-url-response", data: { remoteUrl: n } }
        {
          let s = n
            .replace("ssh://", "")
            .replace("git@", "https://")
            .replace(".com:", ".com/")
            .replace(".git", "")
          return { type: "get-remote-url-response", data: { remoteUrl: s } }
        }
      } catch (n) {
        return (
          console.error("Failed to get remote url:", n),
          { type: "get-remote-url-response", data: { remoteUrl: "" } }
        )
      }
    }
    async handleGitFetchRequest(t) {
      try {
        return (
          await So("git fetch", this.execOptions),
          { type: "git-fetch-response" }
        )
      } catch (r) {
        return (
          console.error("Failed to fetch remote branch:", r),
          { type: "git-fetch-response" }
        )
      }
    }
    async handleIsGitRepositoryRequest(t) {
      try {
        let r = !!(await So(
          process.platform === "win32"
            ? "git rev-parse --is-inside-work-tree 2>NUL"
            : "git rev-parse --is-inside-work-tree 2>/dev/null",
          this.execOptions,
        ))
        return (
          console.log("isGitRepository: ", r),
          { type: "is-git-repository-response", data: { isGitRepository: r } }
        )
      } catch (r) {
        return (
          console.error("Failed to check if is git repository:", r),
          { type: "is-git-repository-response", data: { isGitRepository: false } }
        )
      }
    }
    async handleIsGithubAuthenticatedRequest(t) {
      try {
        if (this.isUsingDevDeploy)
          return {
            type: "is-github-authenticated-response",
            data: { isAuthenticated: true },
          }
        let { is_configured: r } =
          await this._apiServer.isUserGithubConfigured()
        return {
          type: "is-github-authenticated-response",
          data: { isAuthenticated: r },
        }
      } catch (r) {
        return (
          console.error("Failed to check GitHub authentication status:", r),
          {
            type: "is-github-authenticated-response",
            data: { isAuthenticated: false },
          }
        )
      }
    }
    async handleAuthenticateGithubRequest(t) {
      try {
        let n = (
          await this._apiServer.listRemoteTools([IntegrationServiceType.GitHubApi])
        ).tools.find((o) => o.remoteToolId === IntegrationServiceType.GitHubApi)
        if (!n || !n.oauthUrl)
          return {
            type: "authenticate-github-response",
            data: { success: false, message: "GitHub OAuth URL not found" },
          }
        let i = vv.Uri.parse(n.oauthUrl),
          s = await vv.env.openExternal(i)
        return {
          type: "authenticate-github-response",
          data: {
            success: s,
            message: s
              ? "Browser opened for GitHub authentication"
              : "Failed to open browser",
          },
        }
      } catch (r) {
        return (
          console.error("Failed to authenticate with GitHub:", r),
          {
            type: "authenticate-github-response",
            data: {
              success: false,
              message: `Error: ${r instanceof Error ? r.message : String(r)}`,
            },
          }
        )
      }
    }
    async handleRevokeGithubAccessRequest(t) {
      try {
        let r = await this._apiServer.revokeToolAccess(IntegrationServiceType.GitHubApi)
        return r.status === 3
          ? {
              type: "revoke-github-access-response",
              data: {
                success: true,
                message: "GitHub access revoked successfully",
              },
            }
          : r.status === 4
            ? {
                type: "revoke-github-access-response",
                data: { success: true, message: "GitHub is not configured" },
              }
            : {
                type: "revoke-github-access-response",
                data: {
                  success: false,
                  message: `Failed to revoke GitHub access: ${iM[r.status]}`,
                },
              }
      } catch (r) {
        return (
          console.error("Failed to revoke GitHub access:", r),
          {
            type: "revoke-github-access-response",
            data: {
              success: false,
              message: `Error: ${r instanceof Error ? r.message : String(r)}`,
            },
          }
        )
      }
    }
    async handleListUserReposRequest(t) {
      try {
        if (this.isUsingDevDeploy)
          return {
            type: "list-github-repos-for-authenticated-user-response",
            data: { repos: [], isDevDeploy: true },
          }
        let r = await this._apiServer.listGithubReposForAuthenticatedUser()
        return {
          type: "list-github-repos-for-authenticated-user-response",
          data: { repos: r.repos },
        }
      } catch (r) {
        return (
          console.error("Failed to list user repos:", r),
          {
            type: "list-github-repos-for-authenticated-user-response",
            data: {
              repos: [],
              error: r instanceof Error ? r.message : String(r),
            },
          }
        )
      }
    }
    async handleListRepoBranchesRequest(t) {
      try {
        if (this.isUsingDevDeploy)
          return {
            type: "list-github-repo-branches-response",
            data: { branches: [], isDevDeploy: true },
          }
        let r = await this._apiServer.listGithubRepoBranches(t.data.repo)
        return {
          type: "list-github-repo-branches-response",
          data: { branches: r.branches },
        }
      } catch (r) {
        return (
          console.error("Failed to list repo branches:", r),
          {
            type: "list-github-repo-branches-response",
            data: {
              branches: [],
              error: r instanceof Error ? r.message : String(r),
            },
          }
        )
      }
    }
    async handleGetCurrentLocalBranchRequest(t) {
      try {
        let r = await this.executeGetCurrentBranch()
        return {
          type: "get-current-local-branch-response",
          data: { branch: r },
        }
      } catch (r) {
        return (
          console.error("Failed to get current local branch:", r),
          {
            type: "get-current-local-branch-response",
            data: {
              branch: undefined,
              error: r instanceof Error ? r.message : String(r),
            },
          }
        )
      }
    }
    executeGetCurrentBranch() {
      return So("git branch --show-current", this.execOptions)
    }
  }
var Lbe = async (e, t) => {
    let r = e.map((l) => {
        let c = F4(
          l.old_path,
          l.new_path,
          l.old_contents || "",
          l.new_contents || "",
        )
        return { path: l.new_path || l.old_path, changes: c }
      }),
      n = Object.values(r).map((l) => ({
        path: l.path,
        changes: l.changes.map((c) => ({
          id: c.id,
          path: c.path,
          diff: c.diff,
        })),
      })),
      i = `You are a helpful software engineer. You are given a diff of a set of files. Your job is to walk a fellow developer through the changes in the diff.

You need to storytell through the updates, splitting it into two levels of semantic chunks of changes. You should respond with just JSON in this format:
{
    title: string; // these are top-level categories, like "Clean up the Footer" or "New API routes"
    description: string; // use Markdown. eg. put variable names in backticks, strings in quotes in backticks (eg. \`"String"\`)
    sections: { // Keep single files in a single section
        title: string; // Aim for 1 sentence with 5 - 20 words. Use sentence case and don't use generic words like "Update". Be as descriptive as possible, like a good commit message. eg. "Increased heading spacing in footer"
        type: "fix" | "feature" | "refactor" | "documentation" | "style" | "test" | "chore" | "revert" | "other";
        warning?: string; // look for anything that might be important for the user to know. eg. "This implementation isn't complete"
        changeIds: string[]; // Group related changes into a single section. Always combine all changes with the same file path into a single section
        descriptions: { // annotate the change with one or multiple descriptions of what the code change does
            text: string; // use Markdown. eg. put variable names in backticks, strings in quotes in backticks (eg. \`"String"\`). Use \u2192 to describe value changes
            range: {
                start: number; // line number, 0-indexed
                end: number; // line number, 0-indexed
            }
        }[];
    }[]
}[]

Here's an example set of changes:

[{
    "path": "src/global.css",
    "changes": [{
    "id": "1",
    "path": "src/global.css",
    "diff": "body {
  font-family: sans-serif;
- background-color: #fff;
+ background-color: #000;
}"
    }
}]

You would respond:

[{
  "title": "Style tweaks",
  "description": "Global style changes across the app",
  "sections": [{
        "title": "Invert background color",
        "descriptions": [{
            "line": 2,
            "text": "Change the background color from white \u2192 black"
        }],
        "changeIds": ["1"]
    }]
}]


The changes are:

${JSON.stringify(n, null, 2)}

Start your response with [{`,
      s = await t(i)
    return JSON.parse(s).map((l) => ({
      title: l.title,
      description: l.description,
      sections: l.sections.map((c) => {
        let u = c.changeIds
          .map((f) => {
            let p = r.find((m) => m.changes.find((y) => y.id === f))
            return (p && p.changes.find((m) => m.id === f)) || undefined
          })
          .filter((f) => f !== undefined)
        return {
          title: c.title,
          descriptions: c.descriptions,
          type: c.type,
          warning: c.warning,
          changes: u,
        }
      }),
    }))
  },
  Ube = async (e, t) => {
    try {
      let r = e.map((a, l) => ({
          path: a.path,
          fileIndex: l,
          changes: a.changes.map((c) => ({
            id: c.id,
            path: c.path,
            diff: c.diff,
          })),
        })),
        n = `You are a helpful software engineer. You are given a diff of a set of files. Your job is to walk a fellow developer through the changes in the diff.

You need to storytell through the updates, splitting it into two levels of semantic chunks of changes. You should respond with just JSON in this format:
{
    title: string; // these are top-level categories, like "Clean up the Footer" or "New API routes"
    description: string; // use Markdown. eg. put variable names in backticks, strings in quotes in backticks (eg. \`"String"\`)
    sections: { // Keep single files in a single section
        title: string; // Aim for 1 sentence with 5 - 20 words. Use sentence case and don't use generic words like "Update". Be as descriptive as possible, like a good commit message. eg. "Increased heading spacing in footer"
        type: "fix" | "feature" | "refactor" | "documentation" | "style" | "test" | "chore" | "revert" | "other";
        warning?: string; // look for anything that might be important for the user to know. eg. "This implementation isn't complete"
        changeIds: string[]; // Group related changes into a single section. Always combine all changes with the same file path into a single section
        descriptions: { // annotate the change with one or multiple descriptions of what the code change does
            text: string; // use Markdown. eg. put variable names in backticks, strings in quotes in backticks (eg. \`"String"\`). Use \u2192 to describe value changes
            range: {
                start: number; // line number, 0-indexed
                end: number; // line number, 0-indexed
            }
        }[];
    }[]
}[]

IMPORTANT: You MUST preserve the original file grouping and order. The files are already grouped correctly in the input and each file has a fileIndex property indicating its original order. Create one subsection per file, and include all changes for that file in that subsection. Do not regroup or reorder the files. The order of files in your response should match the fileIndex order in the input.

Here's an example set of changes:

[{
    "path": "src/global.css",
    "fileIndex": 0,
    "changes": [{
    "id": "1",
    "path": "src/global.css",
    "diff": "body {
  font-family: sans-serif;
- background-color: #fff;
+ background-color: #000;
}"
    }
}]

You would respond:

[{
  "title": "Style tweaks",
  "description": "Global style changes across the app",
  "sections": [{
        "title": "Invert background color",
        "descriptions": [{
            "line": 2,
            "text": "Change the background color from white \u2192 black"
        }],
        "changeIds": ["1"]
    }]
}]


The changes are:

${JSON.stringify(r, null, 2)}

Start your response with [{`,
        i = await t(n)
      return JSON.parse(i).map((a) => ({
        title: a.title,
        description: a.description,
        sections: a.sections.map((l) => {
          let c = l.changeIds
            .map((u) => {
              let f = e.find((g) => g.changes.find((m) => m.id === u))
              return (f && f.changes.find((g) => g.id === u)) || undefined
            })
            .filter((u) => u !== undefined)
          return {
            title: l.title,
            descriptions: l.descriptions,
            type: l.type,
            warning: l.warning,
            changes: c,
          }
        }),
      }))
    } catch (r) {
      return console.error("Failed to get descriptions:", r), []
    }
  }
function NF(e) {
  let t = 0
  for (let r = 0; r < e.length; r++) {
    let n = e.charCodeAt(r)
    ;(t = (t << 5) - t + n), (t = t & t)
  }
  return Math.abs(t).toString(36)
}
function F4(e, t, r, n) {
  let i = oI(e, t, r, n, "", "", { context: 3 }),
    s = e || t,
    o = NF(s),
    a = NF(r + n)
  return [
    { id: `${o}-${a}`, path: s, diff: i, originalCode: r, modifiedCode: n },
  ]
}
var Obe = async (e, t, r = false) => {
  try {
    if (r) {
      let p = e.map((C) => ({
          path: C.new_path || C.old_path,
          changes: [
            {
              id: C.id,
              path: C.new_path || C.old_path,
              diff: `File: ${C.new_path || C.old_path}
Change type: ${C.change_type || "modified"}`,
              originalCode: "",
              modifiedCode: "",
            },
          ],
        })),
        g = `You are a helpful software engineer. You are given a diff of a set of files. Your job is to group related changes together.

You should respond with just JSON in this format:
[{
    "path": string; // The file path
    "changes": [{ // The changes for this file
        "id": string; // The ID of the change
        "path": string; // The file path
    }];
}]

IMPORTANT: Do NOT add any descriptions or explanations. Just group the changes by file. Keep the original IDs intact.

The changes are:

${JSON.stringify(p, null, 2)}

Start your response with [{`,
        m = 2e4,
        y
      try {
        let C = new Promise((E, w) => {
          setTimeout(() => w(new Error("LLM request timed out")), m)
        })
        y = await Promise.race([t(g), C])
      } catch (C) {
        return console.error("LLM request timed out or failed:", C), p
      }
      let v
      try {
        v = JSON.parse(y)
      } catch (C) {
        return console.error("Failed to parse LLM response:", C), p
      }
      return v.map((C) => ({
        path: C.path,
        changes: C.changes.map((E) => ({
          ...E,
          originalCode: "",
          modifiedCode: "",
          diff: "",
        })),
      }))
    }
    let n = e.map((p) => {
        let g = F4(
          p.old_path,
          p.new_path,
          p.old_contents || "",
          p.new_contents || "",
        )
        return { path: p.new_path || p.old_path, changes: g }
      }),
      i = n.reduce(
        (p, g) => p + g.changes.reduce((m, y) => m + y.diff.length, 0),
        0,
      ),
      s = n.reduce((p, g) => p + g.changes.length, 0)
    if (i > 3e4 || n.length > 8 || s > 15)
      return (
        console.log(
          `Skipping LLM grouping due to size: ${i} bytes, ${n.length} files, ${s} changes`,
        ),
        n
      )
    let o = n.map((p) => ({
        path: p.path,
        changes: p.changes.map((g) => {
          if (g.id) return g
          let m = NF(g.path),
            y = NF(g.originalCode + g.modifiedCode)
          return { ...g, id: `${m}-${y}` }
        }),
      })),
      a = o.map((p) => ({
        path: p.path,
        changes: p.changes.map((g) => ({
          id: g.id,
          path: g.path,
          diff: g.diff,
        })),
      })),
      l = `You are a helpful software engineer. You are given a diff of a set of files. Your job is to group related changes together.

You should respond with just JSON in this format:
[{
    "path": string; // The file path
    "changes": [{ // The changes for this file
        "id": string; // The ID of the change
        "path": string; // The file path
        "diff": string; // The diff content
    }];
}]

IMPORTANT: Do NOT add any descriptions or explanations. Just group the changes by file. Keep the original IDs intact.

Here's an example set of changes:

[{
    "path": "src/global.css",
    "changes": [{
        "id": "abc123",
        "path": "src/global.css",
        "diff": "body {
  font-family: sans-serif;
- background-color: #fff;
+ background-color: #000;
}"
    }]
}]

You would respond with the same structure, just grouped by file:

[{
    "path": "src/global.css",
    "changes": [{
        "id": "abc123",
        "path": "src/global.css",
        "diff": "body {
  font-family: sans-serif;
- background-color: #fff;
+ background-color: #000;
}"
    }]
}]

The changes are:

${JSON.stringify(a, null, 2)}

Start your response with [{`,
      c = 2e4,
      u
    try {
      let p = new Promise((g, m) => {
        setTimeout(() => m(new Error("LLM request timed out")), c)
      })
      u = await Promise.race([t(l), p])
    } catch (p) {
      return console.error("LLM request timed out or failed:", p), n
    }
    let f
    try {
      f = JSON.parse(u)
    } catch (p) {
      return console.error("Failed to parse LLM response:", p), n
    }
    return f.map((p) => {
      let g = p.changes
        .map((m) => {
          for (let y of o) {
            let v = y.changes.find((C) => C.id === m.id)
            if (v) return v
          }
        })
        .filter((m) => m !== undefined)
      return { path: p.path, changes: g }
    })
  } catch (n) {
    return (
      console.error("Failed to group changes with LLM:", n),
      e.map((i) => {
        let s = F4(
          i.old_path,
          i.new_path,
          i.old_contents || "",
          i.new_contents || "",
        )
        return { path: i.new_path || i.old_path, changes: s }
      })
    )
  }
}
function eAt(e, t) {
  let r = {}
  for (let s = 0; s < t.length; s++) {
    let o = t[s]
    r[o] ? r[o].push(s) : (r[o] = [s])
  }
  let i = [{ buffer1index: -1, buffer2index: -1, chain: null }]
  for (let s = 0; s < e.length; s++) {
    let o = e[s],
      a = r[o] || [],
      l = 0,
      c = i[0]
    for (let u = 0; u < a.length; u++) {
      let f = a[u],
        p
      for (
        p = l;
        p < i.length &&
        !(
          i[p].buffer2index < f &&
          (p === i.length - 1 || i[p + 1].buffer2index > f)
        );
        p++
      );
      if (p < i.length) {
        let g = { buffer1index: s, buffer2index: f, chain: i[p] }
        if (
          (l === i.length ? i.push(c) : (i[l] = c),
          (l = p + 1),
          (c = g),
          l === i.length)
        )
          break
      }
    }
    i[l] = c
  }
  return i[i.length - 1]
}
function qbe(e, t) {
  let r = eAt(e, t),
    n = [],
    i = e.length,
    s = t.length
  for (let o = r; o !== null; o = o.chain) {
    let a = i - o.buffer1index - 1,
      l = s - o.buffer2index - 1
    ;(i = o.buffer1index),
      (s = o.buffer2index),
      (a || l) &&
        n.push({
          buffer1: [i + 1, a],
          buffer1Content: e.slice(i + 1, i + 1 + a),
          buffer2: [s + 1, l],
          buffer2Content: t.slice(s + 1, s + 1 + l),
        })
  }
  return n.reverse(), n
}
function tAt(e, t, r) {
  let n = []
  function i(l, c) {
    n.push({
      ab: c,
      oStart: l.buffer1[0],
      oLength: l.buffer1[1],
      abStart: l.buffer2[0],
      abLength: l.buffer2[1],
    })
  }
  qbe(t, e).forEach((l) => i(l, "a")),
    qbe(t, r).forEach((l) => i(l, "b")),
    n.sort((l, c) => l.oStart - c.oStart)
  let s = [],
    o = 0
  function a(l) {
    l > o &&
      (s.push({
        stable: true,
        buffer: "o",
        bufferStart: o,
        bufferLength: l - o,
        bufferContent: t.slice(o, l),
      }),
      (o = l))
  }
  for (; n.length; ) {
    let l = n.shift(),
      c = l.oStart,
      u = l.oStart + l.oLength,
      f = [l]
    for (a(c); n.length; ) {
      let p = n[0],
        g = p.oStart
      if (g > u) break
      ;(u = Math.max(u, g + p.oLength)), f.push(n.shift())
    }
    if (f.length === 1) {
      if (l.abLength > 0) {
        let p = l.ab === "a" ? e : r
        s.push({
          stable: true,
          buffer: l.ab,
          bufferStart: l.abStart,
          bufferLength: l.abLength,
          bufferContent: p.slice(l.abStart, l.abStart + l.abLength),
        })
      }
    } else {
      let p = {
        a: [e.length, -1, t.length, -1],
        b: [r.length, -1, t.length, -1],
      }
      for (; f.length; ) {
        l = f.shift()
        let E = l.oStart,
          w = E + l.oLength,
          B = l.abStart,
          T = B + l.abLength,
          N = p[l.ab]
        ;(N[0] = Math.min(B, N[0])),
          (N[1] = Math.max(T, N[1])),
          (N[2] = Math.min(E, N[2])),
          (N[3] = Math.max(w, N[3]))
      }
      let g = p.a[0] + (c - p.a[2]),
        m = p.a[1] + (u - p.a[3]),
        y = p.b[0] + (c - p.b[2]),
        v = p.b[1] + (u - p.b[3]),
        C = {
          stable: false,
          aStart: g,
          aLength: m - g,
          aContent: e.slice(g, m),
          oStart: c,
          oLength: u - c,
          oContent: t.slice(c, u),
          bStart: y,
          bLength: v - y,
          bContent: r.slice(y, v),
        }
      s.push(C)
    }
    o = u
  }
  return a(t.length), s
}
function rAt(e, t, r, n) {
  ;(n = Object.assign(
    { excludeFalseConflicts: true, stringSeparator: /\s+/ },
    n,
  )),
    typeof e == "string" && (e = e.split(n.stringSeparator)),
    typeof t == "string" && (t = t.split(n.stringSeparator)),
    typeof r == "string" && (r = r.split(n.stringSeparator))
  let s = [],
    o = tAt(e, t, r),
    a = []
  function l() {
    a.length && s.push({ ok: a }), (a = [])
  }
  function c(u, f) {
    if (u.length !== f.length) return false
    for (let p = 0; p < u.length; p++) if (u[p] !== f[p]) return false
    return true
  }
  return (
    o.forEach((u) => {
      u.stable
        ? a.push(...u.bufferContent)
        : n.excludeFalseConflicts && c(u.aContent, u.bContent)
          ? a.push(...u.aContent)
          : (l(),
            s.push({
              conflict: {
                a: u.aContent,
                aIndex: u.aStart,
                o: u.oContent,
                oIndex: u.oStart,
                b: u.bContent,
                bIndex: u.bStart,
              },
            }))
    }),
    l(),
    s
  )
}
function Vbe(e, t, r, n) {
  n = Object.assign(
    { excludeFalseConflicts: true, stringSeparator: /\s+/, label: {} },
    n,
  )
  let s = "<<<<<<<" + (n.label.a ? ` ${n.label.a}` : ""),
    o = "=======",
    a = ">>>>>>>" + (n.label.b ? ` ${n.label.b}` : ""),
    l = rAt(e, t, r, n),
    c = false,
    u = []
  return (
    l.forEach((f) => {
      f.ok
        ? (u = u.concat(f.ok))
        : f.conflict &&
          ((c = true), (u = u.concat([s], f.conflict.a, [o], f.conflict.b, [a])))
    }),
    { conflict: c, result: u }
  )
}
var ja = q(require("vscode")),
  xm = require("vscode"),
  Cv = class {
    constructor(t) {
      this._api = t
    }
    gitRoot
    register(t) {
      t.registerHandler(
        "get-diff-explanation-request",
        this.handleDiffExplanationRequestMessage.bind(this),
      ),
        t.registerHandler(
          "get-diff-group-changes-request",
          this.handleDiffGroupChangesRequestMessage.bind(this),
        ),
        t.registerHandler(
          "get-diff-descriptions-request",
          this.handleDiffDescriptionsRequestMessage.bind(this),
        ),
        t.registerHandler(
          "apply-changes-request",
          this.handleDiffApplyMessage.bind(this),
        )
    }
    async streamLlmCompletion(t) {
      let r = await mp(
        t,
        this._api.createRequestId(),
        [],
        [],
        [],
        Fr.agent,
        "gemini-2-flash-001-simple-port",
      )
      for await (let { nodes: n = [] } of r) {
        let i = n.find((s) => s.type === gc.RAW_RESPONSE)?.content
        if (i) {
          let s = i.trim()
          return (
            (s = s.replace(/^```|```$/g, "")), (s = s.replace(/^json/g, "")), s
          )
        }
      }
      return ""
    }
    async handleDiffExplanationRequestMessage(t) {
      let { changedFiles: r } = t.data,
        n = this.streamLlmCompletion.bind(this)
      try {
        let i = await Lbe(r, n)
        return {
          type: "get-diff-explanation-response",
          data: { explanation: i },
        }
      } catch (i) {
        return (
          console.error("Failed to explain diff:", i),
          { type: "get-diff-explanation-response", data: { explanation: [] } }
        )
      }
    }
    async handleDiffGroupChangesRequestMessage(t) {
      let { changedFiles: r, changesById: n } = t.data,
        i = this.streamLlmCompletion.bind(this)
      try {
        let s = await Obe(r, i, !!n)
        return {
          type: "get-diff-group-changes-response",
          data: { groupedChanges: s },
        }
      } catch (s) {
        return (
          console.error("Failed to group changes:", s),
          {
            type: "get-diff-group-changes-response",
            data: { groupedChanges: [] },
          }
        )
      }
    }
    async handleDiffDescriptionsRequestMessage(t) {
      let { groupedChanges: r } = t.data,
        n = this.streamLlmCompletion.bind(this)
      try {
        let i = await Ube(r, n)
        return {
          type: "get-diff-descriptions-response",
          data: { explanation: i },
        }
      } catch (i) {
        return (
          console.error("Failed to get descriptions:", i),
          { type: "get-diff-descriptions-response", data: { explanation: [] } }
        )
      }
    }
    async handleDiffApplyMessage(t) {
      let { path: r, originalCode: n, newCode: i } = t.data
      try {
        if (!r?.trim()) throw new Error("File path cannot be empty")
        if (typeof i != "string") throw new Error("New code must be a string")
        let s = await this.resolveFilePath(r),
          o = ja.Uri.file(s)
        if (i === "")
          try {
            return (
              await xm.workspace.fs.stat(o),
              await xm.workspace.fs.delete(o),
              { type: "apply-changes-response", data: { success: true } }
            )
          } catch {
            return { type: "apply-changes-response", data: { success: true } }
          }
        let a = new ja.WorkspaceEdit(),
          l = new ja.Range(0, 0, 0, 0),
          c = "",
          u = "",
          f = false
        try {
          await xm.workspace.fs.stat(o), (f = true), (u = i)
          let g = await xm.workspace.openTextDocument(o)
          ;(l = new ja.Range(
            0,
            0,
            g.lineCount - 1,
            g.lineAt(g.lineCount - 1).text.length,
          )),
            (c = (await xm.workspace.openTextDocument(o))?.getText() || "")
          let m = (w = "") => w.split(/(?<=\r\n|\n|\r)/g),
            y = m(c),
            v = m(n),
            C = m(i),
            E = Vbe(y, v, C, { excludeFalseConflicts: false })
          E.conflict || (u = E.result.join(""))
        } catch {
          ;(f = false), (u = i)
        }
        if (
          (f || a.createFile(o, { overwrite: true }),
          a.replace(o, l, u),
          !(await ja.workspace.applyEdit(a)))
        )
          throw new Error("Failed to apply workspace edit")
        return { type: "apply-changes-response", data: { success: true } }
      } catch (s) {
        let o = s instanceof Error ? s.message : String(s)
        return {
          type: "apply-changes-response",
          data: { success: false, error: o },
        }
      }
    }
    async getGitRoot() {
      return this.gitRoot
        ? this.gitRoot
        : ((this.gitRoot = await lx()), this.gitRoot)
    }
    async resolveFilePath(t) {
      let r = await this.getGitRoot()
      if (r)
        return ja.Uri.file(ja.Uri.joinPath(ja.Uri.file(r), t).fsPath).fsPath
      let n = xm.workspace.workspaceFolders?.[0]
      if (!n) throw new Error("No workspace folder available")
      return ja.Uri.joinPath(n.uri, t).fsPath
    }
  }
var Hbe = q(require("path")),
  Ps = q(require("vscode"))
var wm = class e extends DisposableContainer {
  constructor(r, n, i) {
    super()
    this._apiServer = r
    this._configListener = n
    this._featureFlagManager = i
    this.addDisposable(this._onDidChangeRemoteAgentStatus),
      this.addDisposable(
        this._featureFlagManager.subscribe(
          ["vscodeBackgroundAgentsMinVersion"],
          (s) => {
            this.getIsBackgroundAgentsEnabled(s.newFlags) &&
              this.startDetection()
          },
        ),
      ),
      this.addDisposable(
        this._configListener.onDidChange(() => {
          this.getIsBackgroundAgentsEnabled() && this.startDetection()
        }),
      ),
      this.startDetection()
  }
  static _instance
  _logger = z("RemoteWorkspaceResolver")
  _isRemoteAgent = false
  _agentIdFromWorkspace = ""
  _remoteAgentId
  _remoteAgent
  _onDidChangeRemoteAgentStatus = new Ps.EventEmitter()
  onDidChangeRemoteAgentStatus = this._onDidChangeRemoteAgentStatus.event
  static getInstance() {
    return e._instance
  }
  static initialize(r, n, i) {
    return e._instance || (e._instance = new e(r, n, i)), e._instance
  }
  getIsBackgroundAgentsEnabled(r) {
    return (
      r || (r = this._featureFlagManager.currentFlags),
      this._configListener.config.enableDebugFeatures &&
        isMinVersionMet(r.vscodeBackgroundAgentsMinVersion ?? "")
    )
  }
  async startDetection() {
    if (this.getIsBackgroundAgentsEnabled())
      try {
        this.getAgentIdFromWorkspaceName(), await this.checkIfRemoteAgent()
      } catch (n) {
        this._logger.error("Error starting remote agent detection", n)
      }
  }
  getAgentIdFromWorkspaceName() {
    try {
      let r = Ps.workspace.name || "",
        n = /\[SSH: (.*)\]/
      return (
        (this._agentIdFromWorkspace = r.match(n)?.[1] || ""),
        this._agentIdFromWorkspace
      )
    } catch (r) {
      return this._logger.error("Error getting hostname", r), ""
    }
  }
  async checkIfRemoteAgent() {
    try {
      if (
        !this._agentIdFromWorkspace &&
        (this.getAgentIdFromWorkspaceName(), !this._agentIdFromWorkspace)
      )
        return false
      let r
      try {
        if (
          ((r = await this._apiServer.listRemoteAgents()),
          !r || !r.remote_agents)
        )
          return (
            this._logger.error("Invalid response from listRemoteAgents"), false
          )
      } catch (s) {
        return this._logger.error("Error fetching remote agents", s), false
      }
      let n = r.remote_agents.find(
          (s) => this._agentIdFromWorkspace === s.remote_agent_id,
        ),
        i = this._isRemoteAgent
      return (
        (this._isRemoteAgent = !!n),
        (this._remoteAgent = n),
        (this._remoteAgentId = n?.remote_agent_id),
        i !== this._isRemoteAgent &&
          (this._onDidChangeRemoteAgentStatus.fire(this._isRemoteAgent),
          await this.updateVSCodeSettings()),
        this._isRemoteAgent
      )
    } catch (r) {
      return this._logger.error("Error checking if remote agent", r), false
    }
  }
  isRemoteAgent() {
    return this._isRemoteAgent
  }
  getRemoteAgentId() {
    return this._remoteAgentId
  }
  getRemoteAgent() {
    return this._remoteAgent
  }
  static isRemoteAgent() {
    return e._instance?.isRemoteAgent() ?? false
  }
  static getRemoteAgentId() {
    return e._instance?.getRemoteAgentId()
  }
  async executeWithTimeout(r, n, i) {
    let s
    try {
      let o = Promise.resolve(r),
        a = await Promise.race([
          o,
          new Promise((l, c) => {
            s = setTimeout(() => {
              c(new Error(`Timeout after ${n}ms: ${i}`))
            }, n)
          }),
        ])
      return clearTimeout(s), a
    } catch (o) {
      this._logger.error(i, o)
      return
    }
  }
  getRemoteAgentSettings() {
    return {
      "workbench.colorCustomizations": {
        "titleBar.activeBackground": "#0090FF",
        "titleBar.activeForeground": "#ffffff",
        "titleBar.inactiveBackground": "#0090FF",
        "titleBar.inactiveForeground": "#ffffff",
      },
      "window.title": `\u2601\uFE0F Remote Agent: ${this._remoteAgent?.session_summary || this._remoteAgentId} \${dirty}\${activeEditorShort}\${separator}\${rootName}`,
    }
  }
  async updateSettings() {
    try {
      await this.editRemoteSettingsFile()
    } catch (r) {
      this._logger.error(
        "Error with direct file editing, trying command-based approach",
        r,
      )
      try {
        await this.updateSettingsUsingCommand()
      } catch (n) {
        this._logger.error("All settings update methods failed", n)
      }
    }
  }
  async editRemoteSettingsFile() {
    let r = this.getRemoteSettingsFilePath()
    if (!r)
      throw (
        (this._logger.error("Could not determine remote settings file path"),
        new Error("Could not determine remote settings file path"))
      )
    let n = this.getRemoteAgentSettings(),
      i = Ps.Uri.file(r),
      s = {}
    try {
      let l = await Ps.workspace.fs.readFile(i),
        c = Buffer.from(l).toString("utf8")
      if (c.trim())
        try {
          let u = JSON.parse(c)
          u && typeof u == "object" && !Array.isArray(u) && (s = u)
        } catch (u) {
          this._logger.error("Error parsing remote settings file", u)
        }
    } catch {}
    let o = { ...s, ...n },
      a = JSON.stringify(o, null, 2)
    await Ps.workspace.fs.writeFile(i, Buffer.from(a, "utf8")),
      Ps.window.showInformationMessage(
        "Remote agent settings have been automatically applied",
      )
  }
  getRemoteSettingsFilePath() {
    try {
      let r = process.env.HOME || process.env.USERPROFILE
      return r
        ? Hbe.join(r, ".vscode-server", "data", "Machine", "settings.json")
        : undefined
    } catch (r) {
      r instanceof Error
        ? this._logger.error("Error determining remote settings file path", r)
        : this._logger.error(
            `Error determining remote settings file path: ${String(r)}`,
          )
      return
    }
  }
  async updateSettingsUsingCommand() {
    await Ps.commands.executeCommand("workbench.action.openRemoteSettingsFile")
    let r = Ps.window.activeTextEditor?.document.fileName
    if (!r)
      throw (
        (this._logger.error("Failed to open remote settings file"),
        new Error("Failed to open remote settings file"))
      )
    let n
    try {
      n = await readTextFile(r)
    } catch (a) {
      throw (
        (this._logger.error("Failed to read remote settings file", a),
        new Error("Failed to read remote settings file"))
      )
    }
    let i
    try {
      i = JSON.parse(n)
    } catch (a) {
      throw (
        (this._logger.error("Failed to parse remote settings file", a),
        new Error("Failed to parse remote settings file"))
      )
    }
    let s = { ...i, ...this.getRemoteAgentSettings() },
      o = JSON.stringify(s, null, 2)
    try {
      await oa(r, o)
    } catch (a) {
      throw (
        (this._logger.error("Failed to write remote settings file", a),
        new Error("Failed to write remote settings file"))
      )
    }
    await Ps.commands.executeCommand("workbench.action.closeActiveEditor")
  }
  async updateVSCodeSettings() {
    if (!(!this._isRemoteAgent || !this._remoteAgentId))
      try {
        Ps.env.remoteName !== undefined && (await this.updateSettings()),
          await this.executeWithTimeout(
            Ps.commands.executeCommand("vscode-augment.focusAugmentPanel"),
            5e3,
            "Timeout opening and focusing Augment panel",
          )
      } catch (r) {
        this._logger.error("Error updating VSCode settings", r)
      }
  }
}
var og = q(require("fs")),
  bv = q(require("path")),
  Mx = q(require("vscode"))
var pf = q(require("fs/promises")),
  N4 = q(require("os")),
  on = q(require("vscode"))
var iAt = [
  new RegExp("^/Users/[^/]+"),
  new RegExp("^/home/[^/]+"),
  /^[A-Za-z]:\\Users\\[^\\]+/,
]
function sAt(e) {
  for (let t of iAt) {
    let r = e.match(t)
    if (r) return r[0]
  }
  return null
}
var oAt = [
  /Skipping acquiring lock for (.*?)\./,
  /Loading configuration from (.*?)\./,
]
function Wbe(e) {
  for (let t of oAt) {
    let r = e.match(t)
    if (r && r[1]) {
      let n = r[1],
        i = sAt(n)
      if (i) {
        let s = Q4(i)
        return { homePath: i, platform: s }
      }
    }
  }
  return null
}
function Q4(e) {
  return e.startsWith("/Users/")
    ? "darwin"
    : e.match(/^\/?[a-zA-Z](?::|%3A)\/.*/)
      ? "win32"
      : "linux"
}
function Gbe(e, ...t) {
  let r = e === "win32" ? "\\" : "/"
  return t.join(r)
}
function $be(e, t) {
  let r = e === "win32" ? "\\" : "/",
    n = t.lastIndexOf(r)
  return n === -1 ? "." : t.substring(0, n)
}
var sg = class {
  constructor(t) {
    this.globalState = t
  }
  isRemoteEnvironment() {
    return on.env.remoteName !== undefined
  }
  async getHomeDirectory() {
    if (!this.isRemoteEnvironment()) return N4.homedir()
    if (this.globalState) {
      let r = this.globalState.get("remoteHomeInfo")
      if (r?.homePath) return r.homePath
    }
    try {
      let r = await on.workspace.openTextDocument(
          on.Uri.from({ scheme: "output", path: "exthost" }),
        ),
        n = Wbe(r.getText())
      if (n)
        return (
          this.globalState &&
            (await this.globalState.update("remoteHomeInfo", n)),
          n.homePath
        )
    } catch (r) {
      on.window.showErrorMessage(`Error finding home directory: ${String(r)}`)
    }
    return N4.homedir()
  }
  async getPlatform() {
    if (!this.isRemoteEnvironment()) return process.platform
    if (this.globalState) {
      let r = this.globalState.get("remoteHomeInfo")
      if (r?.platform) return r.platform
    }
    let t = await this.getHomeDirectory()
    return Q4(t)
  }
  async joinPath(...t) {
    let r = await this.getPlatform()
    return Gbe(r, ...t)
  }
  async getAugmentConfigDir() {
    let t = await this.getHomeDirectory()
    return await this.joinPath(t, ".augment")
  }
  async getAugmentSshConfigPath() {
    let t = await this.getAugmentConfigDir()
    return await this.joinPath(t, "ssh-config")
  }
  async getSshKnownHostsPath() {
    let t = await this.getAugmentConfigDir()
    return await this.joinPath(t, "ssh-known_hosts")
  }
  async getDefaultSshConfigPath() {
    let t = await this.getHomeDirectory()
    return await this.joinPath(t, ".ssh", "config")
  }
  createFileUri(t) {
    return this.isRemoteEnvironment()
      ? on.Uri.parse(`vscode-local:${t}`)
      : on.Uri.file(t)
  }
  async readFile(t) {
    try {
      if (this.isRemoteEnvironment()) {
        let r = this.createFileUri(t),
          n = await on.workspace.fs.readFile(r)
        return Buffer.from(n).toString("utf8")
      } else return await pf.readFile(t, "utf8")
    } catch (r) {
      if (
        r?.code === "ENOENT" ||
        (r instanceof on.FileSystemError && r.code === "FileNotFound")
      )
        return ""
      throw (
        (on.window.showErrorMessage(`Error reading file ${t}: ${String(r)}`), r)
      )
    }
  }
  async getDirname(t) {
    let r = await this.getPlatform()
    return $be(r, t)
  }
  async writeFile(t, r, n = 384) {
    let i = await this.getDirname(t)
    if ((await this.mkdir(i, 448), this.isRemoteEnvironment())) {
      let s = this.createFileUri(t)
      try {
        await on.workspace.fs.writeFile(s, Buffer.from(r, "utf8"))
      } catch (o) {
        throw (
          (on.window
            .showErrorMessage(`Error writing to local file from remote environment: ${t}
${String(o)}`),
          o)
        )
      }
    } else await pf.writeFile(t, r, { mode: n })
  }
  async mkdir(t, r = 448) {
    try {
      if (this.isRemoteEnvironment()) {
        let n = this.createFileUri(t)
        try {
          await on.workspace.fs.createDirectory(n)
        } catch (i) {
          if (i instanceof on.FileSystemError && i.code === "FileNotFound") {
            on.window.showWarningMessage(
              `Could not create directory on local machine from remote environment: ${t}`,
            )
            return
          }
          throw i
        }
      } else await pf.mkdir(t, { recursive: true, mode: r })
    } catch (n) {
      if (
        n?.code !== "EEXIST" &&
        !(n instanceof on.FileSystemError && n.code === "FileExists")
      )
        throw (
          (on.window.showErrorMessage(
            `Error creating directory ${t}: ${String(n)}`,
          ),
          n)
        )
    }
  }
  async directoryExists(t) {
    try {
      if (this.isRemoteEnvironment()) {
        let r = this.createFileUri(t)
        return (await on.workspace.fs.stat(r)).type === on.FileType.Directory
      } else return await pf.access(t), true
    } catch {
      return false
    }
  }
  async fileExists(t) {
    try {
      if (this.isRemoteEnvironment()) {
        let r = this.createFileUri(t)
        return (await on.workspace.fs.stat(r)).type === on.FileType.File
      } else return await pf.access(t), true
    } catch {
      return false
    }
  }
  async openFile(t, r) {
    let n = this.createFileUri(t)
    try {
      let i = await on.workspace.openTextDocument(n)
      return await on.window.showTextDocument(i), i
    } catch (i) {
      if (r !== undefined) {
        let s = await this.getDirname(t)
        await this.mkdir(s, 448), await this.writeFile(t, r)
        let o = await on.workspace.openTextDocument(n)
        return await on.window.showTextDocument(o), o
      }
      throw i
    }
  }
}
var PF = class {
  sshFileSystem
  augmentDirPath = [".augment", "env"]
  constructor(t) {
    this.sshFileSystem = new sg(t)
  }
  isValidScriptName(t) {
    return t.endsWith(".sh")
  }
  async listSetupScripts() {
    let t = []
    try {
      let r = await this.getScriptsFromHomeDirectory()
      t.push(...r)
      let n = await this.getScriptsFromGitRoot()
      t.push(...n)
      let i = await this.getScriptsFromWorkspaceRoot()
      t.push(...i)
      let s = new Map()
      for (let o of t) s.set(o.name + o.path, o)
      return Array.from(s.values())
    } catch (r) {
      throw (console.error("Error listing setup scripts:", r), r)
    }
  }
  async saveSetupScript(t, r, n) {
    try {
      let i, s, o, a
      if (n === "home") {
        ;(s = await this.sshFileSystem.getHomeDirectory()),
          (i = await this.sshFileSystem.joinPath(s, ...this.augmentDirPath)),
          await this.ensureDirectoryExists(i, true)
        let c = await this.sshFileSystem.joinPath(i, t)
        return await this.sshFileSystem.writeFile(c, r), c
      }
      if (n === "git") {
        if (((o = await lx()), !o))
          throw new Error("Git root directory not found")
        i = await this.sshFileSystem.joinPath(o, ...this.augmentDirPath)
      } else if (n === "workspace") {
        if (((a = vM()), !a))
          throw new Error("Workspace root directory not found")
        i = await this.sshFileSystem.joinPath(a, ...this.augmentDirPath)
      } else throw new Error("Invalid location")
      await this.ensureDirectoryExists(i, false)
      let l = bv.join(i, t)
      return await og.promises.writeFile(l, r, { mode: 493 }), l
    } catch (i) {
      throw (console.error(`Error saving setup script to ${n}:`, i), i)
    }
  }
  async getScriptsFromHomeDirectory() {
    let t = await this.sshFileSystem.getHomeDirectory(),
      r = await this.sshFileSystem.joinPath(t, ...this.augmentDirPath)
    return await this.getScriptsFromLocalDirectory(r, "home")
  }
  async getScriptsFromGitRoot() {
    let t = await lx()
    if (!t) return []
    let r = await this.sshFileSystem.joinPath(t, ...this.augmentDirPath)
    return await this.getScriptsFromWorkspaceDirectory(r, "git")
  }
  async getScriptsFromWorkspaceRoot() {
    let t = vM()
    if (!t) return []
    let r = await this.sshFileSystem.joinPath(t, ...this.augmentDirPath)
    return await this.getScriptsFromWorkspaceDirectory(r, "workspace")
  }
  async getScriptsFromLocalDirectory(t, r) {
    let n = []
    try {
      if (!(await this.sshFileSystem.directoryExists(t))) return []
      let s = this.sshFileSystem.createFileUri(t)
      try {
        let o = await Mx.workspace.fs.readDirectory(s)
        for (let [a, l] of o)
          if (l === Mx.FileType.File && this.isValidScriptName(a))
            try {
              let c = await this.sshFileSystem.joinPath(t, a),
                u = await this.sshFileSystem.readFile(c)
              n.push({ name: a, path: c, content: u, location: r })
            } catch (c) {
              console.error(`Error reading local file ${a}:`, c)
            }
      } catch (o) {
        return console.error(`Error reading local directory ${t}:`, o), []
      }
    } catch (i) {
      console.error(`Error accessing local directory ${t}:`, i)
    }
    return n
  }
  async getScriptsFromWorkspaceDirectory(t, r) {
    let n = []
    try {
      if (!og.existsSync(t)) return []
      let i = await og.promises.readdir(t)
      for (let s of i) {
        if (!this.isValidScriptName(s)) continue
        let o = bv.join(t, s)
        if ((await og.promises.stat(o)).isFile())
          try {
            let l = await readTextFile(o)
            n.push({ name: s, path: o, content: l, location: r })
          } catch (l) {
            console.error(`Error reading file ${o}:`, l)
          }
      }
    } catch (i) {
      console.error(`Error reading directory ${t}:`, i)
    }
    return n
  }
  async ensureDirectoryExists(t, r = false) {
    try {
      r && this.sshFileSystem.isRemoteEnvironment()
        ? await this.sshFileSystem.mkdir(t)
        : await og.promises.mkdir(t, { recursive: true })
    } catch (n) {
      throw (console.error(`Error creating directory ${t}:`, n), n)
    }
  }
  async createSetupScriptFile(t, r, n) {
    if (!this.isValidScriptName(r)) throw new Error("Invalid script name")
    let i = r.lastIndexOf("."),
      [s, o] = i !== -1 ? [r.substring(0, i), r.substring(i)] : [r, ""],
      a = r,
      l = await this.listSetupScripts()
    if (l.find((u) => u.name === a && u.location === t)) {
      let u = 1,
        f = `${s}(${u})${o}`
      for (; l.find((p) => p.name === f && p.location === t); )
        u++, (f = `${s}(${u})${o}`)
      a = f
    }
    return await this.saveSetupScript(a, n, t)
  }
  async deleteSetupScript(t, r) {
    try {
      let i = (await this.listSetupScripts()).find(
        (s) => s.name === t && s.location === r,
      )
      if (!i) return false
      if (r === "home") {
        let s = this.sshFileSystem.createFileUri(i.path)
        await Mx.workspace.fs.delete(s)
      } else await og.promises.unlink(i.path)
      return true
    } catch (n) {
      return console.error(`Error deleting setup script ${t}:`, n), false
    }
  }
  async renameSetupScript(t, r, n) {
    try {
      if (!this.isValidScriptName(r))
        throw new Error(
          `Invalid script name: ${r}. Script names must end with .sh`,
        )
      let s = (await this.listSetupScripts()).find(
        (c) => c.name === t && c.location === n,
      )
      if (!s) return
      let o = bv.dirname(s.path),
        a = bv.join(o, r),
        l = ""
      return (
        n === "home"
          ? (l = await this.sshFileSystem.readFile(s.path))
          : (l = await readTextFile(s.path)),
        await this.deleteSetupScript(t, n),
        await this.createSetupScriptFile(n, r, l),
        a
      )
    } catch (i) {
      throw (console.error(`Error renaming setup script ${t} to ${r}:`, i), i)
    }
  }
}
var rEe = q(require("vscode"))
var Jbe = require("child_process"),
  jbe = q(require("vscode"))
var Wc = q(require("vscode"))
function P4(e, t = false) {
  return t
    ? new RegExp(`\\bHost\\s+${e}\\b`, "i")
    : new RegExp(`\\bHost\\s+${e}\\b[\\s\\S]*?(?=\\bHost\\b|$)`, "i")
}
async function Ybe(e) {
  let t = "Augment.vscode-augment",
    r = Wc.workspace.getConfiguration("remote.SSH"),
    n = r.get("defaultExtensions") || [],
    i = n.includes(t),
    s = i ? n : [...n, t]
  try {
    return (
      i ||
        (await r.update("defaultExtensions", s, Wc.ConfigurationTarget.Global)),
      await e()
    )
  } finally {
    i || (await r.update("defaultExtensions", n, Wc.ConfigurationTarget.Global))
  }
}
function Kbe(e) {
  let t = e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
  return new RegExp(`^\\s*Include\\s+${t}\\s*$`, "im")
}
var L4 = "# Added by Augment for remote agent SSH connections"
async function zbe(e) {
  await Wc.commands.executeCommand(
    "vscode.openFolder",
    Wc.Uri.parse(`vscode-remote://ssh-remote+${e}/mnt/persist/workspace`),
    { forceNewWindow: true },
  ),
    await Wc.commands.executeCommand(
      "vscode.removeFromRecentlyOpened",
      Wc.Uri.parse(`vscode-remote://ssh-remote+${e}/mnt/persist/workspace`),
    )
}
var Ev = class {
  fileSystem
  configPath = null
  timeoutMs = 1e4
  constructor(t, r) {
    ;(this.fileSystem = new sg(t)), (this.configPath = r || null)
  }
  async getAugmentConfigPath() {
    return this.configPath
      ? this.configPath
      : await this.fileSystem.getAugmentSshConfigPath()
  }
  async getDefaultConfigPath() {
    let r = jbe.workspace.getConfiguration("remote.SSH").get("configFile")
    return r && r.trim() ? r : await this.fileSystem.getDefaultSshConfigPath()
  }
  async loadAugmentConfig() {
    let t = await this.getAugmentConfigPath()
    return await this.fileSystem.readFile(t)
  }
  async loadDefaultConfig() {
    let t = await this.getDefaultConfigPath()
    return await this.fileSystem.readFile(t)
  }
  async saveToDefaultConfig(t) {
    let r = await this.getDefaultConfigPath()
    await this.fileSystem.writeFile(r, t, 420)
  }
  async saveToAugmentConfig(t) {
    let r = await this.getAugmentConfigPath()
    await this.fileSystem.writeFile(r, t, 420)
  }
  async addHost(t, r) {
    let n = await this.loadAugmentConfig(),
      i = P4(t),
      s = n.match(i),
      o = await this.formatHostEntry(t, r)
    if (s) {
      let a = n.replace(s[0], o)
      await this.saveToAugmentConfig(a)
    } else {
      let a = n.trim()
        ? `${n.trim()}

${o}`
        : o
      await this.saveToAugmentConfig(a)
    }
  }
  getRawString(t) {
    return JSON.stringify(t).slice(1, -1)
  }
  async formatHostEntry(t, r) {
    let { hostname: n, ssh_config_options: i } = r,
      s = `Host ${t}
`
    s += `   HostName ${n}
`
    let o = (await this.fileSystem.getPlatform()) === "win32"
    for (let a of i) {
      let l = a.value
      if (
        (a.key === "KnownHostsCommand" &&
          l.includes("\\n") &&
          (l = l.replace(
            /\\n/g,
            `
`,
          )),
        o)
      ) {
        let c = await this.resolveWSL()
        a.key === "ProxyCommand" && (l = `${c} ${l}`),
          a.key === "KnownHostsCommand" && (l = `${c} ${l}`),
          a.key === "UserKnownHostsFile" && l === "/dev/null" && (l = "NUL")
      }
      s +=
        "  " +
        a.key +
        " " +
        this.getRawString(l) +
        `
`
    }
    return s
  }
  async resolveWSL() {
    if ((await this.fileSystem.getPlatform()) === "win32")
      try {
        return await new Promise((t, r) => {
          ;(0, Jbe.exec)(
            "where wsl.exe",
            { timeout: 1e4, windowsHide: true },
            (n, i, s) => {
              if (n) {
                s && s.trim()
                  ? r(new Error(`${n.message}. stderr: ${s.trim()}`))
                  : r(n)
                return
              }
              let o = i.split(/\r?\n/).filter((a) => a.trim())
              if (o.length === 0) {
                r(new Error("WSL path not found"))
                return
              }
              t(o[0])
            },
          )
        })
      } catch (t) {
        console.error("Error resolving WSL path:", t)
      }
    return "C:\\Windows\\System32\\wsl.exe"
  }
  async hasHost(t) {
    let r = await this.loadAugmentConfig()
    return P4(t, true).test(r)
  }
  async addIncludeToDefaultConfig() {
    let t = await this.getDefaultConfigPath()
    if (!(await this.fileSystem.fileExists(t))) {
      let c = `Include ${await this.getAugmentConfigPath()}`,
        u = `${L4}
${c}
`
      await this.saveToDefaultConfig(u)
      return
    }
    let n = await this.loadDefaultConfig(),
      i = await this.getAugmentConfigPath()
    if (Kbe(i).test(n)) return
    let o = `Include ${i}`,
      a = `${L4}
${o}

${n}`
    await this.saveToDefaultConfig(a)
  }
  async ensureAugmentConfigExists() {
    let t = await this.getAugmentConfigPath()
    ;(await this.fileSystem.fileExists(t)) ||
      (await this.saveToAugmentConfig(`# Augment SSH Configuration
`))
  }
  async connectToHost(t, r) {
    r && (await this.addHost(t, r)),
      await this.ensureAugmentConfigExists(),
      await this.addIncludeToDefaultConfig(),
      await Ybe(
        async () => (
          await zbe(t),
          new Promise((n) => {
            setTimeout(n, this.timeoutMs)
          })
        ),
      )
  }
}
var Zbe = require("child_process"),
  Kl = q(require("fs/promises")),
  Xbe = q(require("os")),
  U4 = q(require("path")),
  eEe = require("util"),
  tEe = q(require("vscode")),
  aAt = (0, eEe.promisify)(Zbe.exec),
  O4 = {
    type: "ed25519",
    comment: `augment-remote-agent-key-${new Date().toISOString().split("T")[0]}`,
    passphrase: "",
    filename: "augment_remote_agent_key",
  },
  LF = class {
    isRemoteEnvironment() {
      return tEe.env.remoteName !== undefined
    }
    getAugmentSshKeysDir() {
      let t = Xbe.homedir()
      return U4.join(t, ".augment", "ssh-keys")
    }
    async ensureKeysDirectoryExists() {
      let t = this.getAugmentSshKeysDir()
      try {
        await Kl.mkdir(t, { recursive: true, mode: 448 })
      } catch (r) {
        if (r?.code !== "EEXIST") throw r
      }
      return t
    }
    async checkExistingKeys(t, r) {
      try {
        let n = await Kl.access(t)
            .then(() => true)
            .catch(() => false),
          i = await Kl.access(r)
            .then(() => true)
            .catch(() => false)
        if (n && i) {
          let s = await Kl.readFile(r, "utf8")
          return { privateKeyPath: t, publicKeyPath: r, publicKey: s.trim() }
        }
      } catch {}
      return null
    }
    async deleteFile(t) {
      try {
        await Kl.unlink(t)
      } catch {}
    }
    async generateKeyPair(t = {}) {
      if (this.isRemoteEnvironment())
        throw new Error(
          "SSH key generation is not supported in remote environments. Please generate keys on your local machine.",
        )
      let r = { ...O4, ...t },
        n = await this.ensureKeysDirectoryExists(),
        i = r.filename || `id_${r.type}`,
        s = U4.join(n, i),
        o = `${s}.pub`,
        a = await this.checkExistingKeys(s, o)
      if (a) return a
      await this.deleteFile(s), await this.deleteFile(o)
      let l = `ssh-keygen -t ${r.type}`
      r.bits && r.type === "rsa" && (l += ` -b ${r.bits}`),
        r.comment && (l += ` -C "${r.comment}"`)
      let c = r.passphrase || ""
      l += ` -f "${s}" -N "${c}"`
      try {
        await aAt(l), await Kl.chmod(s, 384)
        let u = await Kl.readFile(o, "utf8")
        return { privateKeyPath: s, publicKeyPath: o, publicKey: u.trim() }
      } catch (u) {
        throw new Error(`Failed to generate SSH key: ${String(u)}`)
      }
    }
  }
var UF = class {
  constructor(t, r) {
    this.api = t
    ;(this.sshKeyGenerator = new LF()),
      (this.sshConfigManager = new Ev(r)),
      (this.sshFileSystem = new sg(r))
  }
  sshKeyGenerator
  sshConfigManager
  sshFileSystem
  async connectToRemoteAgent(t) {
    let r = await this.getKeyPair(),
      { privateKeyPath: n, publicKey: i } = r,
      o = (await this.api.remoteAgentAddSSHKey(t, [i])).ssh_config
    o.ssh_config_options.push({ key: "IdentityFile", value: n })
    let a = o.ssh_config_options.some((u) => u.key === "KnownHostsCommand"),
      l = o.ssh_config_options.some((u) => u.key === "StrictHostKeyChecking"),
      c = o.ssh_config_options.some((u) => u.key === "UserKnownHostsFile")
    a
      ? (l ||
          o.ssh_config_options.push({
            key: "StrictHostKeyChecking",
            value: "yes",
          }),
        c ||
          o.ssh_config_options.push({
            key: "UserKnownHostsFile",
            value: "/dev/null",
          }))
      : (l ||
          o.ssh_config_options.push({
            key: "StrictHostKeyChecking",
            value: "no",
          }),
        c ||
          o.ssh_config_options.push({
            key: "UserKnownHostsFile",
            value: await this.sshFileSystem.getSshKnownHostsPath(),
          })),
      await this.sshConfigManager.connectToHost(t, o)
  }
  isRemoteEnvironment() {
    return this.sshFileSystem.isRemoteEnvironment()
  }
  async getKeyPair() {
    let t = await this.sshFileSystem.getHomeDirectory(),
      r = await this.sshFileSystem.joinPath(t, ".augment", "ssh-keys"),
      n = await this.sshFileSystem.joinPath(r, O4.filename),
      i = `${n}.pub`,
      s = await this.sshFileSystem.fileExists(n),
      o = await this.sshFileSystem.fileExists(i)
    if (s && o) {
      let a = await this.sshFileSystem.readFile(i)
      return { privateKeyPath: n, publicKeyPath: i, publicKey: a.trim() }
    }
    if (this.isRemoteEnvironment())
      throw (
        (await rEe.window.showErrorMessage(
          "We couldn't find an SSH key pair for remote agent connections. Please try again from a local workspace.",
        ),
        new Error(
          "SSH key generation is not supported in remote environments. Please generate keys on your local machine.",
        ))
      )
    return await this.sshKeyGenerator.generateKeyPair()
  }
}
var Fx = q(require("vscode"))
var cs = class e {
  static _instance
  _messageHandlers = new Map()
  _disposables = []
  constructor() {
    this._disposables.push(
      Fx.workspace.onDidChangeWorkspaceFolders(() => {
        Fx.workspace.workspaceFolders?.length || this.dispose()
      }),
    )
  }
  static getInstance() {
    return e._instance || (e._instance = new e()), e._instance
  }
  registerMessageHandler(t, r) {
    this._messageHandlers.set(t, r)
  }
  unregisterMessageHandler(t) {
    this._messageHandlers.delete(t)
  }
  hasHandler(t) {
    return this._messageHandlers.has(t)
  }
  dispose() {
    this._messageHandlers.clear(),
      this._disposables.forEach((t) => {
        t.dispose()
      }),
      (this._disposables = []),
      (e._instance = undefined)
  }
  sendMessage(t, r) {
    let n = this._messageHandlers.get(t)
    if (n)
      try {
        n.postMessage(r)
      } catch {
        $y.error(`Error sending message to ${t}`)
      }
  }
  broadcastMessage(t, r) {
    for (let [n, i] of this._messageHandlers.entries())
      if (!r?.includes(n))
        try {
          i.postMessage(t)
        } catch {
          $y.error(
            `Error broadcasting message to ${this._messageHandlers.size} handlers.`,
          )
        }
  }
}
function nEe(e) {
  let t = cs.getInstance()
  e.subscriptions.push(
    new Fx.Disposable(() => {
      t.dispose()
    }),
  )
}
var Sm = q(require("vscode"))
var Zu = q(require("vscode"))
var Qx = class e {
  constructor(t, r) {
    this._webview = t
    this._opts = r
  }
  static messengerId = "remote-agent-diff-panel-messenger"
  register(t) {
    t.registerHandler(
      "remote-agent-diff-panel-loaded",
      this.handleDiffPanelLoadedMessage.bind(this),
    )
    let r = cs.getInstance()
    r.hasHandler(e.messengerId) || r.registerMessageHandler(e.messengerId, t)
  }
  handleDiffPanelLoadedMessage(t) {
    return { type: "remote-agent-diff-panel-set-opts", data: this._opts }
  }
  updateOpts(t) {
    ;(this._opts = t),
      this._webview.postMessage({
        type: "remote-agent-diff-panel-set-opts",
        data: this._opts,
      })
  }
}
var Nx = class e extends PanelWebview {
  constructor(r, n) {
    let i = Zu.window.createWebviewPanel(
      "remote agent diff",
      e.title,
      Zu.ViewColumn.Active,
      { retainContextWhenHidden: true, enableScripts: true },
    )
    super("remote-agent-diff.html", i.webview)
    this._deps = r
    this._opts = n
    this._panel = i
    let { extensionUri: s } = this._deps
    ;(this._panel.iconPath = {
      light: Zu.Uri.joinPath(s, "media", "panel-icon-light.svg"),
      dark: Zu.Uri.joinPath(s, "media", "panel-icon-dark.svg"),
    }),
      this._panel.onDidDispose(() => {
        cs
          .getInstance()
          .broadcastMessage({ type: "close-remote-agent-diff-panel" }),
          cs.getInstance().unregisterMessageHandler(Qx.messengerId),
          this.dispose()
      }),
      this.addDisposables(
        this._panel,
        new Zu.Disposable(() => {
          e.currentPanel = undefined
        }),
      )
    let o = createAsyncMessageHandler(this._panel.webview, this._deps.workTimer)
    this.addDisposable(o),
      (this._diffPanelMessenger = new Qx(this._panel.webview, this._opts)),
      this._diffPanelMessenger.register(o),
      (this._remoteAgentDiffMessenger = new Cv(this._deps.apiServer)),
      this._remoteAgentDiffMessenger.register(o),
      this.loadHTML(s)
  }
  static currentPanel
  static title = "Remote Agent Changes"
  _panel
  _diffPanelMessenger
  _remoteAgentDiffMessenger
  updateOpts(r) {
    ;(this._opts = r), this._diffPanelMessenger.updateOpts(r)
  }
  static createOrShow(r, n, i, s, o) {
    let a = cs.getInstance()
    if (e.currentPanel) {
      e.currentPanel._panel.reveal(Zu.ViewColumn.Active),
        e.currentPanel.updateOpts.call(e.currentPanel, o),
        a.broadcastMessage({ type: "show-remote-agent-diff-panel", data: o })
      return
    }
    ;(e.currentPanel = new e(
      { extensionUri: r, apiServer: n, workTimer: i, globalState: s },
      o,
    )),
      a.broadcastMessage({ type: "show-remote-agent-diff-panel", data: o })
  }
  static close() {
    cs
      .getInstance()
      .broadcastMessage({ type: "close-remote-agent-diff-panel" }),
      e.currentPanel && e.currentPanel._panel.dispose()
  }
}
var Gc = q(require("vscode"))
var _v = class e {
  constructor(t, r) {
    this._storeName = t
    r && (this._state = r), e.instances.set(t, this), this.notifySubscribers()
  }
  static instances = new Map()
  static getStore(t, r) {
    let n = e.instances.get(t)
    return n || (n = new e(t, r)), r && !n.state && n.setState(r), n
  }
  _state = undefined
  _disposed = false
  _webviewManager = cs.getInstance()
  _subscribers = new Set()
  _disposers = []
  get state() {
    return this._state
  }
  isDisposed() {
    return this._disposed
  }
  notifySubscribers() {
    this._disposed ||
      !this._state ||
      this._webviewManager.broadcastMessage({
        type: "update-shared-webview-state",
        data: this._state,
        id: this._storeName,
      })
  }
  subscribe(t, r) {
    if (this._disposed) return
    this._webviewManager.registerMessageHandler(r, t), this._subscribers.add(r)
    let n = t.registerHandler("update-shared-webview-state", (s) =>
        this._disposed || s.id !== this._storeName
          ? Promise.resolve({ type: "empty" })
          : ((this._state = s.data),
            this.notifySubscribers(),
            Promise.resolve({ type: "empty" })),
      ),
      i = t.registerHandler("get-shared-webview-state", (s) =>
        this._disposed || s.id !== this._storeName
          ? Promise.resolve({ type: "empty" })
          : Promise.resolve({
              type: "get-shared-webview-state-response",
              data: this._state,
              id: this._storeName,
            }),
      )
    this._disposers.push(n, i),
      this._disposed ||
        t.postMessage({
          type: "update-shared-webview-state",
          data: this._state,
          id: this._storeName,
        })
  }
  unsubscribe(t) {
    this._disposed ||
      (this._webviewManager.unregisterMessageHandler(t),
      this._subscribers.delete(t),
      this._subscribers.size === 0 && this.dispose())
  }
  setState(t) {
    this._disposed || ((this._state = t), this.notifySubscribers())
  }
  updateState(t) {
    if (this._disposed) return
    let r = t(this._state)
    r !== undefined && ((this._state = r), this.notifySubscribers())
  }
  dispose() {
    this._disposed ||
      ((this._disposed = true),
      e.instances.delete(this._storeName),
      (this._state = undefined),
      this._subscribers.clear(),
      this._disposers.forEach((t) => t()))
  }
}
var Px = class e extends PanelWebview {
  constructor(r) {
    let n = Gc.window.createWebviewPanel(
      "remote agent home",
      e.title,
      Gc.ViewColumn.Active,
      { retainContextWhenHidden: true, enableScripts: true },
    )
    super("remote-agent-home.html", n.webview)
    this._deps = r
    this._panel = n
    let { extensionUri: i } = this._deps
    ;(this._panel.iconPath = {
      light: Gc.Uri.joinPath(i, "media", "panel-icon-light.svg"),
      dark: Gc.Uri.joinPath(i, "media", "panel-icon-dark.svg"),
    }),
      this._panel.onDidDispose(() => {
        cs
          .getInstance()
          .broadcastMessage({ type: "close-remote-agent-home-panel" }),
          this.dispose()
      }),
      this.addDisposables(
        this._panel,
        new Gc.Disposable(() => {
          e.currentPanel = undefined
        }),
      )
    let s = createAsyncMessageHandler(this._panel.webview, this._deps.workTimer)
    this.addDisposable(s),
      (this._remoteAgentsMessenger = new xv(
        this._deps.apiServer,
        this._deps.extensionUri,
        this._deps.workTimer,
        this._deps.globalState,
      )),
      this._remoteAgentsMessenger.register(s, this._panel.webview),
      (this._sharedStore = _v.getStore(FF)),
      this._sharedStore.subscribe(s, e.messengerId),
      this.addDisposable(
        new Gc.Disposable(() => {
          this._sharedStore &&
            (this._sharedStore.updateState((o) => {
              if (o)
                return {
                  ...o,
                  activeWebviews: o.activeWebviews.filter((a) => a !== "home"),
                }
            }),
            this._sharedStore.unsubscribe(e.messengerId))
        }),
      ),
      this.loadHTML(i)
  }
  static currentPanel
  static title = "Remote Agents"
  static messengerId = "remote-agent-home-panel-messenger"
  _panel
  _sharedStore
  _remoteAgentsMessenger
  static createOrShow(r) {
    if (
      (cs
        .getInstance()
        .broadcastMessage({ type: "show-remote-agent-home-panel" }),
      e.currentPanel)
    ) {
      e.currentPanel._panel.reveal(Gc.ViewColumn.Active)
      return
    }
    e.currentPanel = new e(r)
  }
  static close() {
    cs
      .getInstance()
      .broadcastMessage({ type: "close-remote-agent-home-panel" }),
      e.currentPanel && e.currentPanel._panel.dispose()
  }
}
var xv = class e {
  constructor(t, r, n, i) {
    this._api = t
    this._extensionUri = r
    this._workTimer = n
    this._globalState = i
    ;(this._remoteAgentSshManager = new UF(this._api)),
      (this._setupScriptsManager = new PF(this._globalState))
  }
  _remoteAgentSshManager
  _setupScriptsManager
  _webview
  _logger = z("RemoteAgentsMessenger")
  static messengerId = "remote-agents-messenger"
  register(t, r) {
    ;(this._webview = r),
      t.registerHandler(
        "create-remote-agent-request",
        this.handleCreateRemoteAgentMessage.bind(this),
      ),
      t.registerHandler(
        "delete-remote-agent-request",
        this.handleDeleteRemoteAgentMessage.bind(this),
      ),
      t.registerHandler(
        "get-remote-agent-chat-history-request",
        this.handleGetRemoteAgentChatHistoryMessage.bind(this),
      ),
      t.registerHandler(
        "remote-agent-chat-request",
        this.handleRemoteAgentChatRequestMessage.bind(this),
      ),
      t.registerHandler(
        "remote-agent-interrupt-request",
        this.handleRemoteAgentInterruptRequestMessage.bind(this),
      ),
      t.registerHandler(
        "get-remote-agent-overviews-request",
        this.handleGetRemoteAgentOverviewsMessage.bind(this),
      ),
      t.registerHandler(
        "list-setup-scripts-request",
        this.handleListSetupScriptsMessage.bind(this),
      ),
      t.registerHandler(
        "save-setup-script-request",
        this.handleSaveSetupScriptMessage.bind(this),
      ),
      t.registerHandler(
        "delete-setup-script-request",
        this.handleDeleteSetupScriptMessage.bind(this),
      ),
      t.registerHandler(
        "rename-setup-script-request",
        this.handleRenameSetupScriptMessage.bind(this),
      ),
      t.registerHandler(
        "show-remote-agent-diff-panel",
        this.handleShowRemoteAgentDiffPanelMessage.bind(this),
      ),
      t.registerHandler(
        "close-remote-agent-home-panel",
        this.handleCloseRemoteAgentHomePanelMessage.bind(this),
      ),
      t.registerHandler(
        "close-remote-agent-diff-panel",
        this.handleCloseRemoteAgentDiffPanelMessage.bind(this),
      ),
      t.registerHandler(
        "remote-agent-ssh-request",
        this.handleRemoteAgentSshRequestMessage.bind(this),
      ),
      t.registerHandler(
        "set-remote-agent-notification-enabled",
        this.handleSetRemoteAgentNotificationEnabledMessage.bind(this),
      ),
      t.registerHandler(
        "get-remote-agent-notification-enabled-request",
        this.handleGetRemoteAgentNotificationEnabledMessage.bind(this),
      ),
      t.registerHandler(
        "delete-remote-agent-notification-enabled",
        this.handleDeleteRemoteAgentNotificationEnabledMessage.bind(this),
      ),
      t.registerHandler(
        "remote-agent-notify-ready",
        this.handleRemoteAgentNotifyReadyMessage.bind(this),
      ),
      t.registerHandler(
        "remote-agent-workspace-logs-request",
        this.handleRemoteAgentWorkspaceLogsRequestMessage.bind(this),
      ),
      t.registerHandler(
        "show-remote-agent-home-panel",
        this.handleShowRemoteAgentHomePanelMessage.bind(this),
      ),
      t.registerHandler(
        "open-scratch-file-request",
        this.handleOpenScratchFileRequestMessage.bind(this),
      ),
      t.registerHandler(
        "get-remote-agent-status",
        this.handleGetRemoteAgentStatusMessage.bind(this),
      ),
      t.registerHandler(
        "save-last-remote-agent-setup-request",
        this.handleSaveLastRemoteAgentSetupRequest.bind(this),
      ),
      t.registerHandler(
        "get-last-remote-agent-setup-request",
        this.handleGetLastRemoteAgentSetupRequest.bind(this),
      )
    let n = cs.getInstance()
    n.hasHandler(e.messengerId) || n.registerMessageHandler(e.messengerId, t)
  }
  async handleCreateRemoteAgentMessage(t) {
    try {
      let {
          prompt: r,
          workspaceSetup: n,
          setupScript: i,
          isSetupScriptAgent: s,
        } = t.data,
        o = {
          request_nodes: [{ id: 1, type: po.TEXT, text_node: { content: r } }],
        },
        a = await this._api.createRemoteAgent(n, o, undefined, i, s)
      return (
        console.log("Created remote agent:", a),
        {
          type: "create-remote-agent-response",
          data: { success: true, agentId: a.remote_agent_id },
        }
      )
    } catch (r) {
      return (
        console.error("Failed to create remote agent:", r),
        {
          type: "create-remote-agent-response",
          data: {
            success: false,
            error: r instanceof Error ? r.message : "Unknown error",
          },
        }
      )
    }
  }
  async handleDeleteRemoteAgentMessage(t) {
    try {
      let { agentId: r } = t.data
      return (
        await this._api.deleteRemoteAgent(r),
        { type: "remote-agent-delete-response", data: { success: true } }
      )
    } catch (r) {
      return (
        console.error("Failed to delete remote agent:", r),
        {
          type: "remote-agent-delete-response",
          data: {
            success: false,
            error: r instanceof Error ? r.message : "Unknown error",
          },
        }
      )
    }
  }
  async handleGetRemoteAgentOverviewsMessage(t) {
    try {
      let r = await this._api.listRemoteAgents()
      return {
        type: "get-remote-agent-overviews-response",
        data: {
          overviews: r.remote_agents,
          maxRemoteAgents: r.max_remote_agents,
        },
      }
    } catch (r) {
      console.error("Failed to get remote agent overviews:", r)
      let n = r instanceof Error ? r.message : String(r)
      return {
        type: "get-remote-agent-overviews-response",
        data: { overviews: [], maxRemoteAgents: 0, error: n },
      }
    }
  }
  async handleGetRemoteAgentChatHistoryMessage(t) {
    try {
      let { agentId: r, lastProcessedSequenceId: n } = t.data,
        i = await this._api.getRemoteAgentChatHistory(r, n)
      return {
        type: "get-remote-agent-chat-history-response",
        data: { chatHistory: i.chat_history },
      }
    } catch (r) {
      console.error("Failed to get remote agent chat history:", r)
      let n = r instanceof Error ? r.message : String(r)
      return {
        type: "get-remote-agent-chat-history-response",
        data: { chatHistory: [], error: n },
      }
    }
  }
  async handleRemoteAgentChatRequestMessage(t) {
    try {
      let { agentId: r, requestDetails: n } = t.data,
        i = await this._api.remoteAgentChat(r, n)
      return { type: "remote-agent-chat-response", data: i.nodes }
    } catch (r) {
      return (
        console.error("Failed to get remote agent chat response:", r),
        { type: "remote-agent-chat-response", data: [] }
      )
    }
  }
  async handleRemoteAgentInterruptRequestMessage(t) {
    console.log("Interrupting remote agent:", t.data.agentId)
    let { agentId: r } = t.data
    try {
      let n = await this._api.interruptRemoteAgent(r)
      return { type: "remote-agent-interrupt-response", data: n }
    } catch (n) {
      return (
        console.error("Failed to interrupt remote agent:", n),
        { type: "remote-agent-interrupt-response", data: 4 }
      )
    }
  }
  async handleRemoteAgentSshRequestMessage(t) {
    try {
      let { agentId: r } = t.data
      return (
        await this._remoteAgentSshManager.connectToRemoteAgent(r),
        { type: "remote-agent-ssh-response", data: { success: true } }
      )
    } catch (r) {
      return (
        console.error("Failed to get remote agent ssh config:", r),
        {
          type: "remote-agent-ssh-response",
          data: {
            success: false,
            error: r instanceof Error ? r.message : "Unknown error",
          },
        }
      )
    }
  }
  async handleSetRemoteAgentNotificationEnabledMessage(t) {
    try {
      let { agentId: r, enabled: n } = t.data,
        i =
          (await this._globalState.load("remoteAgentNotificationEnabled", {
            uniquePerWorkspace: true,
          })) ?? {}
      return (
        await this._globalState.save(
          "remoteAgentNotificationEnabled",
          { ...i, [r]: n },
          { uniquePerWorkspace: true },
        ),
        { type: "empty" }
      )
    } catch (r) {
      return (
        console.error("Failed to set remote agent notification enabled:", r),
        { type: "empty" }
      )
    }
  }
  async handleGetRemoteAgentNotificationEnabledMessage(t) {
    try {
      let r = await this._globalState.load("remoteAgentNotificationEnabled", {
          uniquePerWorkspace: true,
        }),
        { agentIds: n } = t.data
      return n
        ? {
            type: "get-remote-agent-notification-enabled-response",
            data: n.reduce((i, s) => ((i[s] = r?.[s] ?? false), i), {}),
          }
        : {
            type: "get-remote-agent-notification-enabled-response",
            data: r ?? {},
          }
    } catch (r) {
      return (
        console.error("Failed to get remote agent notification enabled:", r),
        { type: "get-remote-agent-notification-enabled-response", data: {} }
      )
    }
  }
  async handleDeleteRemoteAgentNotificationEnabledMessage(t) {
    try {
      let { agentId: r } = t.data,
        n = await this._globalState.load("remoteAgentNotificationEnabled", {
          uniquePerWorkspace: true,
        })
      return n
        ? (delete n[r],
          await this._globalState.save("remoteAgentNotificationEnabled", n, {
            uniquePerWorkspace: true,
          }),
          { type: "empty" })
        : { type: "empty" }
    } catch (r) {
      return (
        console.error("Failed to delete remote agent notification enabled:", r),
        { type: "empty" }
      )
    }
  }
  async handleRemoteAgentNotifyReadyMessage(t) {
    let { agentId: r } = t.data
    return (
      await this._globalState.load("remoteAgentNotificationEnabled", {
        uniquePerWorkspace: true,
      })
    )?.[r]
      ? (Sm.window
          .showInformationMessage("Remote Agent is waiting for your input!", {
            title: "Go to Remote Agent",
            isCloseAffordance: false,
            onClick: async () =>
              Sm.commands
                .executeCommand("vscode-augment.focusAugmentPanel")
                .then(() => {
                  this._webview?.postMessage({
                    type: "remote-agent-select-agent-id",
                    data: { agentId: r },
                  })
                }),
          })
          .then((i) => {
            i?.onClick && i.onClick()
          }),
        { type: "empty" })
      : { type: "empty" }
  }
  handleShowRemoteAgentDiffPanelMessage(t) {
    let r = t.data
    return (
      Nx.createOrShow(
        this._extensionUri,
        this._api,
        this._workTimer,
        this._globalState,
        r,
      ),
      t
    )
  }
  handleCloseRemoteAgentDiffPanelMessage(t) {
    return Nx.close(), Promise.resolve({ type: "empty" })
  }
  async handleListSetupScriptsMessage(t) {
    try {
      let r = await this._setupScriptsManager.listSetupScripts()
      return { type: "list-setup-scripts-response", data: { scripts: r } }
    } catch (r) {
      return (
        console.error("Failed to list setup scripts:", r),
        {
          type: "list-setup-scripts-response",
          data: {
            scripts: [],
            error: r instanceof Error ? r.message : String(r),
          },
        }
      )
    }
  }
  async handleSaveSetupScriptMessage(t) {
    try {
      let { name: r, content: n, location: i } = t.data,
        s = await this._setupScriptsManager.createSetupScriptFile(i, r, n)
      return {
        type: "save-setup-script-response",
        data: { success: true, path: s },
      }
    } catch (r) {
      return (
        console.error("Failed to save setup script:", r),
        {
          type: "save-setup-script-response",
          data: {
            success: false,
            error: r instanceof Error ? r.message : String(r),
          },
        }
      )
    }
  }
  async handleRemoteAgentWorkspaceLogsRequestMessage(t) {
    try {
      let { agentId: r } = t.data,
        n = await this._api.getRemoteAgentWorkspaceLogs(r)
      return {
        type: "remote-agent-workspace-logs-response",
        data: { workspaceSetupStatus: n.workspace_setup_status },
      }
    } catch (r) {
      return (
        console.error("Failed to get remote agent workspace logs:", r),
        {
          type: "remote-agent-workspace-logs-response",
          data: { workspaceSetupStatus: { steps: [] } },
        }
      )
    }
  }
  handleShowRemoteAgentHomePanelMessage(t) {
    let r = {
      extensionUri: this._extensionUri,
      apiServer: this._api,
      workTimer: this._workTimer,
      globalState: this._globalState,
    }
    return Px.createOrShow(r), Promise.resolve({ type: "empty" })
  }
  handleCloseRemoteAgentHomePanelMessage(t) {
    return Px.close(), Promise.resolve({ type: "empty" })
  }
  async handleDeleteSetupScriptMessage(t) {
    try {
      let { name: r, location: n } = t.data,
        i = await this._setupScriptsManager.deleteSetupScript(r, n)
      return { type: "delete-setup-script-response", data: { success: i } }
    } catch (r) {
      return (
        console.error("Failed to delete setup script:", r),
        {
          type: "delete-setup-script-response",
          data: {
            success: false,
            error: r instanceof Error ? r.message : String(r),
          },
        }
      )
    }
  }
  async handleRenameSetupScriptMessage(t) {
    try {
      let { oldName: r, newName: n, location: i } = t.data,
        s = await this._setupScriptsManager.renameSetupScript(r, n, i)
      return {
        type: "rename-setup-script-response",
        data: { success: true, path: s },
      }
    } catch (r) {
      return (
        console.error("Failed to rename setup script:", r),
        {
          type: "rename-setup-script-response",
          data: {
            success: false,
            error: r instanceof Error ? r.message : String(r),
          },
        }
      )
    }
  }
  async handleOpenScratchFileRequestMessage(t) {
    try {
      let { content: r, language: n } = t.data,
        i = await Sm.workspace.openTextDocument({
          content: r,
          language: n || "shellscript",
        })
      return await Sm.window.showTextDocument(i), { type: "empty" }
    } catch (r) {
      return console.error("Failed to open scratch file:", r), { type: "empty" }
    }
  }
  handleGetRemoteAgentStatusMessage(t) {
    this._logger.info("Remote agent status handler called")
    try {
      let r = wm.isRemoteAgent(),
        n = wm.getRemoteAgentId()
      return (
        this._logger.info(
          `Remote agent status: isRemoteAgentWindow=${r}, remoteAgentId=${n}`,
        ),
        {
          type: "remote-agent-status-response",
          data: { isRemoteAgentWindow: r, remoteAgentId: n },
        }
      )
    } catch (r) {
      return (
        this._logger.error("Error getting remote agent status", r),
        {
          type: "remote-agent-status-response",
          data: { isRemoteAgentWindow: false, remoteAgentId: undefined },
        }
      )
    }
  }
  async handleSaveLastRemoteAgentSetupRequest(t) {
    try {
      let { lastRemoteAgentGitBranch: r, lastRemoteAgentSetupScript: n } =
        t.data
      return (
        r && (await this._globalState.update("lastRemoteAgentGitBranch", r)),
        await this._globalState.update("lastRemoteAgentSetupScript", n),
        { type: "empty" }
      )
    } catch (r) {
      return (
        console.error("Failed to save last remote agent setup:", r),
        { type: "empty" }
      )
    }
  }
  handleGetLastRemoteAgentSetupRequest() {
    try {
      let t = this._globalState.get("lastRemoteAgentGitBranch") || null,
        r = this._globalState.get("lastRemoteAgentSetupScript") || null
      return Promise.resolve({
        type: "get-last-remote-agent-setup-response",
        data: { lastRemoteAgentGitBranch: t, lastRemoteAgentSetupScript: r },
      })
    } catch (t) {
      return (
        $y.error("Failed to get last remote agent setup:", t),
        Promise.resolve({
          type: "get-last-remote-agent-setup-response",
          data: {
            lastRemoteAgentGitBranch: null,
            lastRemoteAgentSetupScript: null,
          },
        })
      )
    }
  }
}
var OF = class extends Error {
    constructor() {
      super("Invalid source folder uri")
    }
  },
  qF = class extends Error {
    constructor(t) {
      super(`cannot access source folder: ${t}`)
    }
  },
  VF = class extends Error {
    constructor() {
      super("source folder is not a directory")
    }
  },
  HF = class extends Error {
    constructor() {
      super("source folder already exists")
    }
  },
  WF = class extends Error {
    constructor() {
      super("source folder is home directory")
    }
  },
  GF = class extends Error {
    constructor() {
      super("source folder is not an external source folder")
    }
  },
  $F = class extends Error {
    constructor() {
      super("source folder does not exist in workspace")
    }
  }
var YF = class extends Error {
    constructor() {
      super("source folder enumeration is not complete")
    }
  },
  wv = ((s) => (
    (s[(s.vscodeWorkspaceFolder = 0)] = "vscodeWorkspaceFolder"),
    (s[(s.externalFolder = 1)] = "externalFolder"),
    (s[(s.nestedWorkspaceFolder = 2)] = "nestedWorkspaceFolder"),
    (s[(s.nestedExternalFolder = 3)] = "nestedExternalFolder"),
    (s[(s.untrackedFolder = 4)] = "untrackedFolder"),
    s
  ))(wv || {})
var dwe = require("child_process"),
  fwe = q(RA()),
  yf = q(Yf()),
  hwe = q(require("path")),
  kt = q(require("vscode"))
var KF = q(require("vscode"))
async function lAt(e, t, r) {
  let i = (await readTextFile(e)).split(`
`),
    s = t - 1,
    o = r - 1,
    a = i.slice(0, s).reduce((c, u) => c + u.length + 1, 0),
    l = i.slice(0, o + 1).reduce((c, u) => c + u.length + 1, 0) - 1
  return { charStart: a, charEnd: l }
}
async function iEe(e, t) {
  let r = KF.workspace.workspaceFolders?.[0]
  if (!r) throw new Error("No workspace folder found")
  let n = KF.Uri.joinPath(r.uri, t.path).fsPath,
    i = e.resolvePathName(n)
  if (!i) throw new Error(`Could not resolve path: ${t.path}`)
  let { charStart: s, charEnd: o } = await lAt(
    i.absPath,
    t.startLine,
    t.endLine,
  )
  return {
    requestId: Oh(),
    mode: "BACKGROUND",
    scope: "FILE",
    result: {
      suggestionId: Oh(),
      path: t.path,
      blobName: t.oldBlobName ?? "",
      charStart: s,
      charEnd: o,
      existingCode: t.oldText,
      suggestedCode: t.text,
      changeDescription: t.description,
      diffSpans: [],
      editingScore: 1,
      localizationScore: 1,
      editingScoreThreshold: 1,
    },
    qualifiedPathName: i,
    lineRange: { start: t.startLine - 1, stop: t.endLine - 1 },
    uriScheme: "file",
    occurredAt: new Date(),
    state: "fresh",
    changeType: "modification",
  }
}
var q4 = "augment://sign-in",
  sEe = `Augment is only available to signed in users. [Please sign in](${q4}).`,
  oEe =
    "Augment works best when it has access to your entire codebase. Please grant permission to sync your workspace.",
  Lx = class {
    constructor(t, r) {
      this.message = t
      this.response = r
      this.occuredAt = new Date()
    }
    occuredAt
  }
var zF = class extends DisposableContainer {
  constructor(r) {
    super()
    this._getter = r
    ;(this._cache = new Gf({
      max: 1e3,
      ttl: 1e3 * 60 * 60,
      fetchMethod: this._fetchSmartPasteResults,
    })),
      this.addDisposable({
        dispose: () => {
          this._cache.clear()
        },
      })
  }
  _cache
  _fetchSmartPasteResults = async (r, n, { context: i }) => {
    let s = await this._getter(i)
    return Promise.resolve({
      generator: new mm(s.generator),
      requestId: s.requestId,
    })
  }
  get = async (r, n, i, s) => {
    let o = cAt(r, n, i),
      a = this._cache.get(o)
    ;(!a || a.generator.hasErrored) && this._cache.delete(o)
    let l = await this._cache.fetch(o, { context: s, forceRefresh: false })
    if (l) return { generator: l.generator.copy(), requestId: l.requestId }
  }
  getDirect = async (r) => {
    let n = await Promise.resolve(this._getter(r))
    if (!n) return
    let i = new mm(n.generator)
    if (i) return { generator: i.copy(), requestId: n.requestId }
  }
}
function cAt(e, t, r) {
  return `${e}--${t}--${r}`
}
var aEe = q(require("vscode"))
var Separator = class extends AugmentCommand {
  static commandID = "vscode-augment.focusAugmentPanel"
  type = "public"
  constructor() {
    super()
  }
  async run() {
    await aEe.commands.executeCommand("augment-chat.focus")
  }
}
var to = q(require("vscode"))
var uAt = "GitHub.copilot",
  dAt = "Codeium.codeium"
var Im = class e extends DisposableContainer {
  constructor(r, n) {
    super()
    this._config = r
    this._actionsModel = n
    this.addDisposable(
      to.workspace.onDidChangeConfiguration((i) => {
        ;(i.affectsConfiguration("github.copilot") ||
          i.affectsConfiguration("codeium")) &&
          this.checkAndUpdateState()
      }),
    ),
      this.addDisposable(
        to.extensions.onDidChange(() => {
          this.checkAndUpdateState()
        }),
      )
  }
  logger = z("ConflictingExtensions")
  checkAndUpdateState() {
    if (this._config.config.conflictingCodingAssistantCheck === false) {
      this._actionsModel.setSystemStateStatus(
        "disabledGithubCopilot",
        "complete",
      ),
        this._actionsModel.setSystemStateStatus("disabledCodeium", "complete")
      return
    }
    let n = [
      {
        check: () => e._checkGitHubCopilot(),
        stateName: "disabledGithubCopilot",
      },
      { check: () => e._checkCodeium(), stateName: "disabledCodeium" },
    ]
    for (let { check: i, stateName: s } of n) {
      let a = i().isConflicting ? "incomplete" : "complete"
      this._actionsModel.setSystemStateStatus(s, a)
    }
  }
  static _checkGitHubCopilot() {
    if (!to.extensions.getExtension(uAt))
      return { extension: "copilot", isConflicting: false }
    let n = to.workspace.getConfiguration("github.copilot")
    return {
      extension: "copilot",
      isConflicting: (n.enable && n.enable["*"]) || false,
    }
  }
  static async disableGitHubCopilot() {
    try {
      let r = to.workspace.getConfiguration("github.copilot")
      await r.update(
        "enable",
        { "*": false },
        this.targetForConfig(r.inspect("enable")),
      )
    } catch {
      to.commands.executeCommand(
        "workbench.extensions.search",
        "@enabled GitHub Copilot",
      )
    }
  }
  static _checkCodeium() {
    if (!to.extensions.getExtension(dAt))
      return { extension: "codeium", isConflicting: false }
    let n = to.workspace.getConfiguration("codeium")
    return {
      extension: "codeium",
      isConflicting: (n.enableConfig && n.enableConfig["*"]) || false,
    }
  }
  static async disableCodeium() {
    try {
      let r = to.workspace.getConfiguration("codeium")
      await r.update(
        "enableConfig",
        { "*": false },
        this.targetForConfig(r.inspect("enableConfig")),
      )
    } catch {
      to.commands.executeCommand(
        "workbench.extensions.search",
        "@enabled Codeium",
      )
    }
  }
  static packageName(r, n) {
    return r.packageJSON.displayName || r.packageJSON.name || n
  }
  static targetForConfig(r) {
    return r && r.workspaceValue !== undefined
      ? to.ConfigurationTarget.Workspace
      : to.ConfigurationTarget.Global
  }
}
var V4 = require("buffer")
function lEe(e) {
  return new Uint8Array(V4.Buffer.from(e, "base64"))
}
function cEe(e) {
  return V4.Buffer.from(e).toString("base64")
}
var A1 = q(AEe()),
  h1 = q(EEe()),
  K_e = require("child_process"),
  Txe = q(Z4()),
  Iv = q(Z4()),
  nwe = require("events"),
  p1 = Object.defineProperty,
  XAt = Object.defineProperties,
  e0t = Object.getOwnPropertyDescriptor,
  t0t = Object.getOwnPropertyDescriptors,
  y8 = Object.getOwnPropertyNames,
  _Ee = Object.getOwnPropertySymbols,
  r_e = Object.prototype.hasOwnProperty,
  r0t = Object.prototype.propertyIsEnumerable,
  xEe = (e, t, r) =>
    t in e
      ? p1(e, t, { enumerable: true, configurable: true, writable: true, value: r })
      : (e[t] = r),
  Jl = (e, t) => {
    for (var r in t || (t = {})) r_e.call(t, r) && xEe(e, r, t[r])
    if (_Ee) for (var r of _Ee(t)) r0t.call(t, r) && xEe(e, r, t[r])
    return e
  },
  qx = (e, t) => XAt(e, t0t(t)),
  Be = (e, t) =>
    function () {
      return e && (t = (0, e[y8(e)[0]])((e = 0))), t
    },
  n0t = (e, t) =>
    function () {
      return t || (0, e[y8(e)[0]])((t = { exports: {} }).exports, t), t.exports
    },
  Si = (e, t) => {
    for (var r in t) p1(e, r, { get: t[r], enumerable: true })
  },
  i0t = (e, t, r, n) => {
    if ((t && typeof t == "object") || typeof t == "function")
      for (let i of y8(t))
        !r_e.call(e, i) &&
          i !== r &&
          p1(e, i, {
            get: () => t[i],
            enumerable: !(n = e0t(t, i)) || n.enumerable,
          })
    return e
  },
  Ai = (e) => i0t(p1({}, "__esModule", { value: true }), e),
  Ox = (e, t, r) =>
    new Promise((n, i) => {
      var s = (l) => {
          try {
            a(r.next(l))
          } catch (c) {
            i(c)
          }
        },
        o = (l) => {
          try {
            a(r.throw(l))
          } catch (c) {
            i(c)
          }
        },
        a = (l) => (l.done ? n(l.value) : Promise.resolve(l.value).then(s, o))
      a((r = r.apply(e, t)).next())
    })
function s0t(...e) {
  let t = new String(e)
  return m1.set(t, e), t
}
function d1(e) {
  return e instanceof String && m1.has(e)
}
function wEe(e) {
  return m1.get(e) || []
}
var m1,
  Gx = Be({
    "src/lib/args/pathspec.ts"() {
      "use strict"
      m1 = new WeakMap()
    },
  }),
  Af,
  lg = Be({
    "src/lib/errors/git-error.ts"() {
      "use strict"
      Af = class extends Error {
        constructor(e, t) {
          super(t),
            (this.task = e),
            Object.setPrototypeOf(this, new.target.prototype)
        }
      }
    },
  }),
  $x,
  Rv = Be({
    "src/lib/errors/git-response-error.ts"() {
      "use strict"
      lg(),
        ($x = class extends Af {
          constructor(e, t) {
            super(undefined, t || String(e)), (this.git = e)
          }
        })
    },
  }),
  n_e,
  i_e = Be({
    "src/lib/errors/task-configuration-error.ts"() {
      "use strict"
      lg(),
        (n_e = class extends Af {
          constructor(e) {
            super(undefined, e)
          }
        })
    },
  })
function s_e(e) {
  return typeof e == "function" ? e : Tm
}
function o_e(e) {
  return typeof e == "function" && e !== Tm
}
function a_e(e, t) {
  let r = e.indexOf(t)
  return r <= 0 ? [e, ""] : [e.substr(0, r), e.substr(r + 1)]
}
function l_e(e, t = 0) {
  return c_e(e) && e.length > t ? e[t] : undefined
}
function Dm(e, t = 0) {
  if (c_e(e) && e.length > t) return e[e.length - 1 - t]
}
function c_e(e) {
  return !!(e && typeof e.length == "number")
}
function Yx(
  e = "",
  t = true,
  r = `
`,
) {
  return e.split(r).reduce((n, i) => {
    let s = t ? i.trim() : i
    return s && n.push(s), n
  }, [])
}
function v8(e, t) {
  return Yx(e, true).map((r) => t(r))
}
function C8(e) {
  return (0, A1.exists)(e, A1.FOLDER)
}
function Hr(e, t) {
  return Array.isArray(e) ? e.includes(t) || e.push(t) : e.add(t), t
}
function u_e(e, t) {
  return Array.isArray(e) && !e.includes(t) && e.push(t), e
}
function y1(e, t) {
  if (Array.isArray(e)) {
    let r = e.indexOf(t)
    r >= 0 && e.splice(r, 1)
  } else e.delete(t)
  return t
}
function ed(e) {
  return Array.isArray(e) ? e : [e]
}
function d_e(e) {
  return e.replace(/[\s-]+(.)/g, (t, r) => r.toUpperCase())
}
function f_e(e) {
  return ed(e).map(String)
}
function Bn(e, t = 0) {
  if (e == null) return t
  let r = parseInt(e, 10)
  return isNaN(r) ? t : r
}
function Vx(e, t) {
  let r = []
  for (let n = 0, i = e.length; n < i; n++) r.push(t, e[n])
  return r
}
function Hx(e) {
  return (Array.isArray(e) ? Buffer.concat(e) : e).toString("utf-8")
}
function h_e(e, t) {
  return Object.assign({}, ...t.map((r) => (r in e ? { [r]: e[r] } : {})))
}
function s8(e = 0) {
  return new Promise((t) => setTimeout(t, e))
}
function o8(e) {
  if (e !== false) return e
}
var Bv,
  Tm,
  Kx,
  v1 = Be({
    "src/lib/utils/util.ts"() {
      "use strict"
      ;(Bv = "\0"),
        (Tm = () => {}),
        (Kx = Object.prototype.toString.call.bind(Object.prototype.toString))
    },
  })
function td(e, t, r) {
  return t(e) ? e : arguments.length > 2 ? r : undefined
}
function b8(e, t) {
  let r = d1(e) ? "string" : typeof e
  return /number|string|boolean/.test(r) && (!t || !t.includes(r))
}
function E8(e) {
  return !!e && Kx(e) === "[object Object]"
}
function g_e(e) {
  return typeof e == "function"
}
var zx,
  ro,
  p_e,
  f1,
  _8,
  m_e = Be({
    "src/lib/utils/argument-filters.ts"() {
      "use strict"
      v1(),
        Gx(),
        (zx = (e) => Array.isArray(e)),
        (ro = (e) => typeof e == "string"),
        (p_e = (e) => Array.isArray(e) && e.every(ro)),
        (f1 = (e) => ro(e) || (Array.isArray(e) && e.every(ro))),
        (_8 = (e) =>
          e == null || "number|boolean|function".includes(typeof e)
            ? false
            : Array.isArray(e) ||
              typeof e == "string" ||
              typeof e.length == "number")
    },
  }),
  a8,
  o0t = Be({
    "src/lib/utils/exit-codes.ts"() {
      "use strict"
      a8 = ((e) => (
        (e[(e.SUCCESS = 0)] = "SUCCESS"),
        (e[(e.ERROR = 1)] = "ERROR"),
        (e[(e.NOT_FOUND = -2)] = "NOT_FOUND"),
        (e[(e.UNCLEAN = 128)] = "UNCLEAN"),
        e
      ))(a8 || {})
    },
  }),
  Wx,
  a0t = Be({
    "src/lib/utils/git-output-streams.ts"() {
      "use strict"
      Wx = class {
        constructor(e, t) {
          ;(this.stdOut = e), (this.stdErr = t)
        }
        asStrings() {
          return new Wx(
            this.stdOut.toString("utf8"),
            this.stdErr.toString("utf8"),
          )
        }
      }
    },
  }),
  Ot,
  ag,
  l0t = Be({
    "src/lib/utils/line-parser.ts"() {
      "use strict"
      ;(Ot = class {
        constructor(e, t) {
          ;(this.matches = []),
            (this.parse = (r, n) => (
              this.resetMatches(),
              this._regExp.every((i, s) => this.addMatch(i, s, r(s)))
                ? this.useMatches(n, this.prepareMatches()) !== false
                : false
            )),
            (this._regExp = Array.isArray(e) ? e : [e]),
            t && (this.useMatches = t)
        }
        useMatches(e, t) {
          throw new Error("LineParser:useMatches not implemented")
        }
        resetMatches() {
          this.matches.length = 0
        }
        prepareMatches() {
          return this.matches
        }
        addMatch(e, t, r) {
          let n = r && e.exec(r)
          return n && this.pushMatch(t, n), !!n
        }
        pushMatch(e, t) {
          this.matches.push(...t.slice(1))
        }
      }),
        (ag = class extends Ot {
          addMatch(e, t, r) {
            return /^remote:\s/.test(String(r)) && super.addMatch(e, t, r)
          }
          pushMatch(e, t) {
            ;(e > 0 || t.length > 1) && super.pushMatch(e, t)
          }
        })
    },
  })
function A_e(...e) {
  let t = process.cwd(),
    r = Object.assign(
      Jl({ baseDir: t }, y_e),
      ...e.filter((n) => typeof n == "object" && n),
    )
  return (r.baseDir = r.baseDir || t), (r.trimmed = r.trimmed === true), r
}
var y_e,
  c0t = Be({
    "src/lib/utils/simple-git-options.ts"() {
      "use strict"
      y_e = {
        binary: "git",
        maxConcurrentProcesses: 5,
        config: [],
        trimmed: false,
      }
    },
  })
function x8(e, t = []) {
  return E8(e)
    ? Object.keys(e).reduce((r, n) => {
        let i = e[n]
        return (
          d1(i)
            ? r.push(i)
            : b8(i, ["boolean"])
              ? r.push(n + "=" + i)
              : r.push(n),
          r
        )
      }, t)
    : t
}
function ca(e, t = 0, r = false) {
  let n = []
  for (let i = 0, s = t < 0 ? e.length : t; i < s; i++)
    "string|number".includes(typeof e[i]) && n.push(String(e[i]))
  return x8(w8(e), n), r || n.push(...u0t(e)), n
}
function u0t(e) {
  let t = typeof Dm(e) == "function"
  return td(Dm(e, t ? 1 : 0), zx, [])
}
function w8(e) {
  let t = g_e(Dm(e))
  return td(Dm(e, t ? 1 : 0), E8)
}
function yi(e, t = true) {
  let r = s_e(Dm(e))
  return t || o_e(r) ? r : undefined
}
var d0t = Be({
  "src/lib/utils/task-options.ts"() {
    "use strict"
    m_e(), v1(), Gx()
  },
})
function l8(e, t) {
  return e(t.stdOut, t.stdErr)
}
function da(e, t, r, n = true) {
  return (
    ed(r).forEach((i) => {
      for (let s = Yx(i, n), o = 0, a = s.length; o < a; o++) {
        let l = (c = 0) => {
          if (!(o + c >= a)) return s[o + c]
        }
        t.some(({ parse: c }) => c(l, e))
      }
    }),
    e
  )
}
var f0t = Be({
    "src/lib/utils/task-parser.ts"() {
      "use strict"
      v1()
    },
  }),
  v_e = {}
Si(v_e, {
  ExitCodes: () => a8,
  GitOutputStreams: () => Wx,
  LineParser: () => Ot,
  NOOP: () => Tm,
  NULL: () => Bv,
  RemoteLineParser: () => ag,
  append: () => Hr,
  appendTaskOptions: () => x8,
  asArray: () => ed,
  asCamelCase: () => d_e,
  asFunction: () => s_e,
  asNumber: () => Bn,
  asStringArray: () => f_e,
  bufferToString: () => Hx,
  callTaskParser: () => l8,
  createInstanceConfig: () => A_e,
  delay: () => s8,
  filterArray: () => zx,
  filterFunction: () => g_e,
  filterHasLength: () => _8,
  filterPlainObject: () => E8,
  filterPrimitives: () => b8,
  filterString: () => ro,
  filterStringArray: () => p_e,
  filterStringOrStringArray: () => f1,
  filterType: () => td,
  first: () => l_e,
  folderExists: () => C8,
  forEachLineWithContent: () => v8,
  getTrailingOptions: () => ca,
  including: () => u_e,
  isUserFunction: () => o_e,
  last: () => Dm,
  objectToString: () => Kx,
  orVoid: () => o8,
  parseStringResponse: () => da,
  pick: () => h_e,
  prefixedArray: () => Vx,
  remove: () => y1,
  splitOn: () => a_e,
  toLinesWithContent: () => Yx,
  trailingFunctionArgument: () => yi,
  trailingOptionsArgument: () => w8,
})
var wt = Be({
    "src/lib/utils/index.ts"() {
      "use strict"
      m_e(), o0t(), a0t(), l0t(), c0t(), d0t(), f0t(), v1()
    },
  }),
  C_e = {}
Si(C_e, {
  CheckRepoActions: () => c8,
  checkIsBareRepoTask: () => E_e,
  checkIsRepoRootTask: () => b_e,
  checkIsRepoTask: () => h0t,
})
function h0t(e) {
  switch (e) {
    case "bare":
      return E_e()
    case "root":
      return b_e()
  }
  return {
    commands: ["rev-parse", "--is-inside-work-tree"],
    format: "utf-8",
    onError: C1,
    parser: S8,
  }
}
function b_e() {
  return {
    commands: ["rev-parse", "--git-dir"],
    format: "utf-8",
    onError: C1,
    parser(t) {
      return /^\.(git)?$/.test(t.trim())
    },
  }
}
function E_e() {
  return {
    commands: ["rev-parse", "--is-bare-repository"],
    format: "utf-8",
    onError: C1,
    parser: S8,
  }
}
function g0t(e) {
  return /(Not a git repository|Kein Git-Repository)/i.test(String(e))
}
var c8,
  C1,
  S8,
  __e = Be({
    "src/lib/tasks/check-is-repo.ts"() {
      "use strict"
      wt(),
        (c8 = ((e) => (
          (e.BARE = "bare"), (e.IN_TREE = "tree"), (e.IS_REPO_ROOT = "root"), e
        ))(c8 || {})),
        (C1 = ({ exitCode: e }, t, r, n) => {
          if (e === 128 && g0t(t)) return r(Buffer.from("false"))
          n(t)
        }),
        (S8 = (e) => e.trim() === "true")
    },
  })
function p0t(e, t) {
  let r = new x_e(e),
    n = e ? S_e : w_e
  return (
    Yx(t).forEach((i) => {
      let s = i.replace(n, "")
      r.paths.push(s), (I_e.test(s) ? r.folders : r.files).push(s)
    }),
    r
  )
}
var x_e,
  w_e,
  S_e,
  I_e,
  m0t = Be({
    "src/lib/responses/CleanSummary.ts"() {
      "use strict"
      wt(),
        (x_e = class {
          constructor(e) {
            ;(this.dryRun = e),
              (this.paths = []),
              (this.files = []),
              (this.folders = [])
          }
        }),
        (w_e = /^[a-z]+\s*/i),
        (S_e = /^[a-z]+\s+[a-z]+\s*/i),
        (I_e = /\/$/)
    },
  }),
  u8 = {}
Si(u8, {
  EMPTY_COMMANDS: () => b1,
  adhocExecTask: () => B_e,
  configurationErrorTask: () => ua,
  isBufferTask: () => D_e,
  isEmptyTask: () => T_e,
  straightThroughBufferTask: () => R_e,
  straightThroughStringTask: () => ko,
})
function B_e(e) {
  return { commands: b1, format: "empty", parser: e }
}
function ua(e) {
  return {
    commands: b1,
    format: "empty",
    parser() {
      throw typeof e == "string" ? new n_e(e) : e
    },
  }
}
function ko(e, t = false) {
  return {
    commands: e,
    format: "utf-8",
    parser(r) {
      return t ? String(r).trim() : r
    },
  }
}
function R_e(e) {
  return {
    commands: e,
    format: "buffer",
    parser(t) {
      return t
    },
  }
}
function D_e(e) {
  return e.format === "buffer"
}
function T_e(e) {
  return e.format === "empty" || !e.commands.length
}
var b1,
  wi = Be({
    "src/lib/tasks/task.ts"() {
      "use strict"
      i_e(), (b1 = [])
    },
  }),
  k_e = {}
Si(k_e, {
  CONFIG_ERROR_INTERACTIVE_MODE: () => I8,
  CONFIG_ERROR_MODE_REQUIRED: () => B8,
  CONFIG_ERROR_UNKNOWN_OPTION: () => R8,
  CleanOptions: () => a1,
  cleanTask: () => M_e,
  cleanWithOptionsTask: () => A0t,
  isCleanOptionsArray: () => y0t,
})
function A0t(e, t) {
  let { cleanMode: r, options: n, valid: i } = v0t(e)
  return r
    ? i.options
      ? (n.push(...t), n.some(E0t) ? ua(I8) : M_e(r, n))
      : ua(R8 + JSON.stringify(e))
    : ua(B8)
}
function M_e(e, t) {
  return {
    commands: ["clean", `-${e}`, ...t],
    format: "utf-8",
    parser(n) {
      return p0t(e === "n", n)
    },
  }
}
function y0t(e) {
  return Array.isArray(e) && e.every((t) => D8.has(t))
}
function v0t(e) {
  let t,
    r = [],
    n = { cleanMode: false, options: true }
  return (
    e
      .replace(/[^a-z]i/g, "")
      .split("")
      .forEach((i) => {
        C0t(i)
          ? ((t = i), (n.cleanMode = true))
          : (n.options = n.options && b0t((r[r.length] = `-${i}`)))
      }),
    { cleanMode: t, options: r, valid: n }
  )
}
function C0t(e) {
  return e === "f" || e === "n"
}
function b0t(e) {
  return /^-[a-z]$/i.test(e) && D8.has(e.charAt(1))
}
function E0t(e) {
  return /^-[^\-]/.test(e) ? e.indexOf("i") > 0 : e === "--interactive"
}
var I8,
  B8,
  R8,
  a1,
  D8,
  F_e = Be({
    "src/lib/tasks/clean.ts"() {
      "use strict"
      m0t(),
        wt(),
        wi(),
        (I8 = "Git clean interactive mode is not supported"),
        (B8 = 'Git clean mode parameter ("n" or "f") is required'),
        (R8 = "Git clean unknown option found in: "),
        (a1 = ((e) => (
          (e.DRY_RUN = "n"),
          (e.FORCE = "f"),
          (e.IGNORED_INCLUDED = "x"),
          (e.IGNORED_ONLY = "X"),
          (e.EXCLUDING = "e"),
          (e.QUIET = "q"),
          (e.RECURSIVE = "d"),
          e
        ))(a1 || {})),
        (D8 = new Set(["i", ...f_e(Object.values(a1))]))
    },
  })
function _0t(e) {
  let t = new N_e()
  for (let r of Q_e(e)) t.addValue(r.file, String(r.key), r.value)
  return t
}
function x0t(e, t) {
  let r = null,
    n = [],
    i = new Map()
  for (let s of Q_e(e, t))
    s.key === t &&
      (n.push((r = s.value)),
      i.has(s.file) || i.set(s.file, []),
      i.get(s.file).push(r))
  return { key: t, paths: Array.from(i.keys()), scopes: i, value: r, values: n }
}
function w0t(e) {
  return e.replace(/^(file):/, "")
}
function* Q_e(e, t = null) {
  let r = e.split("\0")
  for (let n = 0, i = r.length - 1; n < i; ) {
    let s = w0t(r[n++]),
      o = r[n++],
      a = t
    if (
      o.includes(`
`)
    ) {
      let l = a_e(
        o,
        `
`,
      )
      ;(a = l[0]), (o = l[1])
    }
    yield { file: s, key: a, value: o }
  }
}
var N_e,
  S0t = Be({
    "src/lib/responses/ConfigList.ts"() {
      "use strict"
      wt(),
        (N_e = class {
          constructor() {
            ;(this.files = []), (this.values = Object.create(null))
          }
          get all() {
            return (
              this._all ||
                (this._all = this.files.reduce(
                  (e, t) => Object.assign(e, this.values[t]),
                  {},
                )),
              this._all
            )
          }
          addFile(e) {
            if (!(e in this.values)) {
              let t = Dm(this.files)
              ;(this.values[e] = t ? Object.create(this.values[t]) : {}),
                this.files.push(e)
            }
            return this.values[e]
          }
          addValue(e, t, r) {
            let n = this.addFile(e)
            n.hasOwnProperty(t)
              ? Array.isArray(n[t])
                ? n[t].push(r)
                : (n[t] = [n[t], r])
              : (n[t] = r),
              (this._all = undefined)
          }
        })
    },
  })
function X4(e, t) {
  return typeof e == "string" && d8.hasOwnProperty(e) ? e : t
}
function I0t(e, t, r, n) {
  let i = ["config", `--${n}`]
  return (
    r && i.push("--add"),
    i.push(e, t),
    {
      commands: i,
      format: "utf-8",
      parser(s) {
        return s
      },
    }
  )
}
function B0t(e, t) {
  let r = ["config", "--null", "--show-origin", "--get-all", e]
  return (
    t && r.splice(1, 0, `--${t}`),
    {
      commands: r,
      format: "utf-8",
      parser(n) {
        return x0t(n, e)
      },
    }
  )
}
function R0t(e) {
  let t = ["config", "--list", "--show-origin", "--null"]
  return (
    e && t.push(`--${e}`),
    {
      commands: t,
      format: "utf-8",
      parser(r) {
        return _0t(r)
      },
    }
  )
}
function D0t() {
  return {
    addConfig(e, t, ...r) {
      return this._runTask(
        I0t(e, t, r[0] === true, X4(r[1], "local")),
        yi(arguments),
      )
    },
    getConfig(e, t) {
      return this._runTask(B0t(e, X4(t, undefined)), yi(arguments))
    },
    listConfig(...e) {
      return this._runTask(R0t(X4(e[0], undefined)), yi(arguments))
    },
  }
}
var d8,
  P_e = Be({
    "src/lib/tasks/config.ts"() {
      "use strict"
      S0t(),
        wt(),
        (d8 = ((e) => (
          (e.system = "system"),
          (e.global = "global"),
          (e.local = "local"),
          (e.worktree = "worktree"),
          e
        ))(d8 || {}))
    },
  })
function T0t(e) {
  return L_e.has(e)
}
var e8,
  L_e,
  U_e = Be({
    "src/lib/tasks/diff-name-status.ts"() {
      "use strict"
      ;(e8 = ((e) => (
        (e.ADDED = "A"),
        (e.COPIED = "C"),
        (e.DELETED = "D"),
        (e.MODIFIED = "M"),
        (e.RENAMED = "R"),
        (e.CHANGED = "T"),
        (e.UNMERGED = "U"),
        (e.UNKNOWN = "X"),
        (e.BROKEN = "B"),
        e
      ))(e8 || {})),
        (L_e = new Set(Object.values(e8)))
    },
  })
function k0t(...e) {
  return new q_e().param(...e)
}
function M0t(e) {
  let t = new Set(),
    r = {}
  return (
    v8(e, (n) => {
      let [i, s, o] = n.split(Bv)
      t.add(i), (r[i] = r[i] || []).push({ line: Bn(s), path: i, preview: o })
    }),
    { paths: t, results: r }
  )
}
function F0t() {
  return {
    grep(e) {
      let t = yi(arguments),
        r = ca(arguments)
      for (let i of O_e)
        if (r.includes(i))
          return this._runTask(
            ua(`git.grep: use of "${i}" is not supported.`),
            t,
          )
      typeof e == "string" && (e = k0t().param(e))
      let n = ["grep", "--null", "-n", "--full-name", ...r, ...e]
      return this._runTask(
        {
          commands: n,
          format: "utf-8",
          parser(i) {
            return M0t(i)
          },
        },
        t,
      )
    },
  }
}
var O_e,
  Ux,
  SEe,
  q_e,
  V_e = Be({
    "src/lib/tasks/grep.ts"() {
      "use strict"
      wt(),
        wi(),
        (O_e = ["-h"]),
        (Ux = Symbol("grepQuery")),
        (q_e = class {
          constructor() {
            this[SEe] = []
          }
          *[((SEe = Ux), Symbol.iterator)]() {
            for (let e of this[Ux]) yield e
          }
          and(...e) {
            return (
              e.length && this[Ux].push("--and", "(", ...Vx(e, "-e"), ")"), this
            )
          }
          param(...e) {
            return this[Ux].push(...Vx(e, "-e")), this
          }
        })
    },
  }),
  H_e = {}
Si(H_e, { ResetMode: () => l1, getResetMode: () => N0t, resetTask: () => Q0t })
function Q0t(e, t) {
  let r = ["reset"]
  return W_e(e) && r.push(`--${e}`), r.push(...t), ko(r)
}
function N0t(e) {
  if (W_e(e)) return e
  switch (typeof e) {
    case "string":
    case "undefined":
      return "soft"
  }
}
function W_e(e) {
  return G_e.includes(e)
}
var l1,
  G_e,
  $_e = Be({
    "src/lib/tasks/reset.ts"() {
      "use strict"
      wi(),
        (l1 = ((e) => (
          (e.MIXED = "mixed"),
          (e.SOFT = "soft"),
          (e.HARD = "hard"),
          (e.MERGE = "merge"),
          (e.KEEP = "keep"),
          e
        ))(l1 || {})),
        (G_e = Array.from(Object.values(l1)))
    },
  })
function P0t() {
  return (0, h1.default)("simple-git")
}
function IEe(e, t, r) {
  return !t || !String(t).replace(/\s*/, "")
    ? r
      ? (n, ...i) => {
          e(n, ...i), r(n, ...i)
        }
      : e
    : (n, ...i) => {
        e(`%s ${n}`, t, ...i), r && r(n, ...i)
      }
}
function L0t(e, t, { namespace: r }) {
  if (typeof e == "string") return e
  let n = (t && t.namespace) || ""
  return n.startsWith(r) ? n.substr(r.length + 1) : n || r
}
function T8(e, t, r, n = P0t()) {
  let i = (e && `[${e}]`) || "",
    s = [],
    o = typeof t == "string" ? n.extend(t) : t,
    a = L0t(td(t, ro), o, n)
  return c(r)
  function l(u, f) {
    return Hr(s, T8(e, a.replace(/^[^:]+/, u), f, n))
  }
  function c(u) {
    let f = (u && `[${u}]`) || "",
      p = (o && IEe(o, f)) || Tm,
      g = IEe(n, `${i} ${f}`, p)
    return Object.assign(o ? p : g, { label: e, sibling: l, info: g, step: c })
  }
}
var Y_e = Be({
    "src/lib/git-logger.ts"() {
      "use strict"
      wt(),
        (h1.default.formatters.L = (e) => String(_8(e) ? e.length : "-")),
        (h1.default.formatters.B = (e) =>
          Buffer.isBuffer(e) ? e.toString("utf8") : Kx(e))
    },
  }),
  s1,
  f8,
  U0t = Be({
    "src/lib/runners/tasks-pending-queue.ts"() {
      "use strict"
      lg(),
        Y_e(),
        (s1 = class {
          constructor(e = "GitExecutor") {
            ;(this.logLabel = e), (this._queue = new Map())
          }
          withProgress(e) {
            return this._queue.get(e)
          }
          createProgress(e) {
            let t = s1.getName(e.commands[0]),
              r = T8(this.logLabel, t)
            return { task: e, logger: r, name: t }
          }
          push(e) {
            let t = this.createProgress(e)
            return (
              t.logger("Adding task to the queue, commands = %o", e.commands),
              this._queue.set(e, t),
              t
            )
          }
          fatal(e) {
            for (let [t, { logger: r }] of Array.from(this._queue.entries()))
              t === e.task
                ? (r.info("Failed %o", e),
                  r(
                    "Fatal exception, any as-yet un-started tasks run through this executor will not be attempted",
                  ))
                : r.info(
                    "A fatal exception occurred in a previous task, the queue has been purged: %o",
                    e.message,
                  ),
                this.complete(t)
            if (this._queue.size !== 0)
              throw new Error(
                `Queue size should be zero after fatal: ${this._queue.size}`,
              )
          }
          complete(e) {
            this.withProgress(e) && this._queue.delete(e)
          }
          attempt(e) {
            let t = this.withProgress(e)
            if (!t)
              throw new Af(
                undefined,
                "TasksPendingQueue: attempt called for an unknown task",
              )
            return t.logger("Starting task"), t
          }
          static getName(e = "empty") {
            return `task:${e}:${++s1.counter}`
          }
        }),
        (f8 = s1),
        (f8.counter = 0)
    },
  })
function Rm(e, t) {
  return { method: l_e(e.commands) || "", commands: t }
}
function O0t(e, t) {
  return (r) => {
    t("[ERROR] child process exception %o", r),
      e.push(Buffer.from(String(r.stack), "ascii"))
  }
}
function BEe(e, t, r, n) {
  return (i) => {
    r("%s received %L bytes", t, i), n("%B", i), e.push(i)
  }
}
var h8,
  q0t = Be({
    "src/lib/runners/git-executor-chain.ts"() {
      "use strict"
      lg(),
        wi(),
        wt(),
        U0t(),
        (h8 = class {
          constructor(e, t, r) {
            ;(this._executor = e),
              (this._scheduler = t),
              (this._plugins = r),
              (this._chain = Promise.resolve()),
              (this._queue = new f8())
          }
          get cwd() {
            return this._cwd || this._executor.cwd
          }
          set cwd(e) {
            this._cwd = e
          }
          get env() {
            return this._executor.env
          }
          get outputHandler() {
            return this._executor.outputHandler
          }
          chain() {
            return this
          }
          push(e) {
            return (
              this._queue.push(e),
              (this._chain = this._chain.then(() => this.attemptTask(e)))
            )
          }
          attemptTask(e) {
            return Ox(this, null, function* () {
              let t = yield this._scheduler.next(),
                r = () => this._queue.complete(e)
              try {
                let { logger: n } = this._queue.attempt(e)
                return yield T_e(e)
                  ? this.attemptEmptyTask(e, n)
                  : this.attemptRemoteTask(e, n)
              } catch (n) {
                throw this.onFatalException(e, n)
              } finally {
                r(), t()
              }
            })
          }
          onFatalException(e, t) {
            let r =
              t instanceof Af
                ? Object.assign(t, { task: e })
                : new Af(e, t && String(t))
            return (this._chain = Promise.resolve()), this._queue.fatal(r), r
          }
          attemptRemoteTask(e, t) {
            return Ox(this, null, function* () {
              let r = this._plugins.exec("spawn.binary", "", Rm(e, e.commands)),
                n = this._plugins.exec(
                  "spawn.args",
                  [...e.commands],
                  Rm(e, e.commands),
                ),
                i = yield this.gitResponse(
                  e,
                  r,
                  n,
                  this.outputHandler,
                  t.step("SPAWN"),
                ),
                s = yield this.handleTaskData(e, n, i, t.step("HANDLE"))
              return (
                t("passing response to task's parser as a %s", e.format),
                D_e(e) ? l8(e.parser, s) : l8(e.parser, s.asStrings())
              )
            })
          }
          attemptEmptyTask(e, t) {
            return Ox(this, null, function* () {
              return (
                t(
                  "empty task bypassing child process to call to task's parser",
                ),
                e.parser(this)
              )
            })
          }
          handleTaskData(e, t, r, n) {
            let { exitCode: i, rejection: s, stdOut: o, stdErr: a } = r
            return new Promise((l, c) => {
              n("Preparing to handle process response exitCode=%d stdOut=", i)
              let { error: u } = this._plugins.exec(
                "task.error",
                { error: s },
                Jl(Jl({}, Rm(e, t)), r),
              )
              if (u && e.onError)
                return (
                  n.info("exitCode=%s handling with custom error handler"),
                  e.onError(
                    r,
                    u,
                    (f) => {
                      n.info("custom error handler treated as success"),
                        n("custom error returned a %s", Kx(f)),
                        l(
                          new Wx(
                            Array.isArray(f) ? Buffer.concat(f) : f,
                            Buffer.concat(a),
                          ),
                        )
                    },
                    c,
                  )
                )
              if (u)
                return (
                  n.info(
                    "handling as error: exitCode=%s stdErr=%s rejection=%o",
                    i,
                    a.length,
                    s,
                  ),
                  c(u)
                )
              n.info("retrieving task output complete"),
                l(new Wx(Buffer.concat(o), Buffer.concat(a)))
            })
          }
          gitResponse(e, t, r, n, i) {
            return Ox(this, null, function* () {
              let s = i.sibling("output"),
                o = this._plugins.exec(
                  "spawn.options",
                  { cwd: this.cwd, env: this.env, windowsHide: true },
                  Rm(e, e.commands),
                )
              return new Promise((a) => {
                let l = [],
                  c = []
                i.info("%s %o", t, r), i("%O", o)
                let u = this._beforeSpawn(e, r)
                if (u)
                  return a({
                    stdOut: l,
                    stdErr: c,
                    exitCode: 9901,
                    rejection: u,
                  })
                this._plugins.exec(
                  "spawn.before",
                  undefined,
                  qx(Jl({}, Rm(e, r)), {
                    kill(p) {
                      u = p || u
                    },
                  }),
                )
                let f = (0, K_e.spawn)(t, r, o)
                f.stdout.on("data", BEe(l, "stdOut", i, s.step("stdOut"))),
                  f.stderr.on("data", BEe(c, "stdErr", i, s.step("stdErr"))),
                  f.on("error", O0t(c, i)),
                  n &&
                    (i(
                      "Passing child process stdOut/stdErr to custom outputHandler",
                    ),
                    n(t, f.stdout, f.stderr, [...r])),
                  this._plugins.exec(
                    "spawn.after",
                    undefined,
                    qx(Jl({}, Rm(e, r)), {
                      spawned: f,
                      close(p, g) {
                        a({
                          stdOut: l,
                          stdErr: c,
                          exitCode: p,
                          rejection: u || g,
                        })
                      },
                      kill(p) {
                        f.killed || ((u = p), f.kill("SIGINT"))
                      },
                    }),
                  )
              })
            })
          }
          _beforeSpawn(e, t) {
            let r
            return (
              this._plugins.exec(
                "spawn.before",
                undefined,
                qx(Jl({}, Rm(e, t)), {
                  kill(n) {
                    r = n || r
                  },
                }),
              ),
              r
            )
          }
        })
    },
  }),
  z_e = {}
Si(z_e, { GitExecutor: () => J_e })
var J_e,
  V0t = Be({
    "src/lib/runners/git-executor.ts"() {
      "use strict"
      q0t(),
        (J_e = class {
          constructor(e, t, r) {
            ;(this.cwd = e),
              (this._scheduler = t),
              (this._plugins = r),
              (this._chain = new h8(this, this._scheduler, this._plugins))
          }
          chain() {
            return new h8(this, this._scheduler, this._plugins)
          }
          push(e) {
            return this._chain.push(e)
          }
        })
    },
  })
function H0t(e, t, r = Tm) {
  let n = (s) => {
      r(null, s)
    },
    i = (s) => {
      s?.task === e && r(s instanceof $x ? W0t(s) : s, undefined)
    }
  t.then(n, i)
}
function W0t(e) {
  let t = (n) => {
    console.warn(
      `simple-git deprecation notice: accessing GitResponseError.${n} should be GitResponseError.git.${n}, this will no longer be available in version 3`,
    ),
      (t = Tm)
  }
  return Object.create(e, Object.getOwnPropertyNames(e.git).reduce(r, {}))
  function r(n, i) {
    return (
      i in e ||
        (n[i] = {
          enumerable: false,
          configurable: false,
          get() {
            return t(i), e.git[i]
          },
        }),
      n
    )
  }
}
var G0t = Be({
  "src/lib/task-callback.ts"() {
    "use strict"
    Rv(), wt()
  },
})
function REe(e, t) {
  return B_e((r) => {
    if (!C8(e))
      throw new Error(`Git.cwd: cannot change to non-directory "${e}"`)
    return ((t || r).cwd = e)
  })
}
var $0t = Be({
  "src/lib/tasks/change-working-directory.ts"() {
    "use strict"
    wt(), wi()
  },
})
function t8(e) {
  let t = ["checkout", ...e]
  return t[1] === "-b" && t.includes("-B") && (t[1] = y1(t, "-B")), ko(t)
}
function Y0t() {
  return {
    checkout() {
      return this._runTask(t8(ca(arguments, 1)), yi(arguments))
    },
    checkoutBranch(e, t) {
      return this._runTask(t8(["-b", e, t, ...ca(arguments)]), yi(arguments))
    },
    checkoutLocalBranch(e) {
      return this._runTask(t8(["-b", e, ...ca(arguments)]), yi(arguments))
    },
  }
}
var K0t = Be({
  "src/lib/tasks/checkout.ts"() {
    "use strict"
    wt(), wi()
  },
})
function z0t() {
  return {
    count: 0,
    garbage: 0,
    inPack: 0,
    packs: 0,
    prunePackable: 0,
    size: 0,
    sizeGarbage: 0,
    sizePack: 0,
  }
}
function J0t() {
  return {
    countObjects() {
      return this._runTask({
        commands: ["count-objects", "--verbose"],
        format: "utf-8",
        parser(e) {
          return da(z0t(), [j_e], e)
        },
      })
    },
  }
}
var j_e,
  j0t = Be({
    "src/lib/tasks/count-objects.ts"() {
      "use strict"
      wt(),
        (j_e = new Ot(/([a-z-]+): (\d+)$/, (e, [t, r]) => {
          let n = d_e(t)
          e.hasOwnProperty(n) && (e[n] = Bn(r))
        }))
    },
  })
function Z0t(e) {
  return da(
    {
      author: null,
      branch: "",
      commit: "",
      root: false,
      summary: { changes: 0, insertions: 0, deletions: 0 },
    },
    Z_e,
    e,
  )
}
var Z_e,
  X0t = Be({
    "src/lib/parsers/parse-commit.ts"() {
      "use strict"
      wt(),
        (Z_e = [
          new Ot(/^\[([^\s]+)( \([^)]+\))? ([^\]]+)/, (e, [t, r, n]) => {
            ;(e.branch = t), (e.commit = n), (e.root = !!r)
          }),
          new Ot(/\s*Author:\s(.+)/i, (e, [t]) => {
            let r = t.split("<"),
              n = r.pop()
            !n ||
              !n.includes("@") ||
              (e.author = {
                email: n.substr(0, n.length - 1),
                name: r.join("<").trim(),
              })
          }),
          new Ot(
            /(\d+)[^,]*(?:,\s*(\d+)[^,]*)(?:,\s*(\d+))/g,
            (e, [t, r, n]) => {
              ;(e.summary.changes = parseInt(t, 10) || 0),
                (e.summary.insertions = parseInt(r, 10) || 0),
                (e.summary.deletions = parseInt(n, 10) || 0)
            },
          ),
          new Ot(/^(\d+)[^,]*(?:,\s*(\d+)[^(]+\(([+-]))?/, (e, [t, r, n]) => {
            e.summary.changes = parseInt(t, 10) || 0
            let i = parseInt(r, 10) || 0
            n === "-"
              ? (e.summary.deletions = i)
              : n === "+" && (e.summary.insertions = i)
          }),
        ])
    },
  })
function eyt(e, t, r) {
  return {
    commands: ["-c", "core.abbrev=40", "commit", ...Vx(e, "-m"), ...t, ...r],
    format: "utf-8",
    parser: Z0t,
  }
}
function tyt() {
  return {
    commit(t, ...r) {
      let n = yi(arguments),
        i =
          e(t) ||
          eyt(ed(t), ed(td(r[0], f1, [])), [
            ...td(r[1], zx, []),
            ...ca(arguments, 0, true),
          ])
      return this._runTask(i, n)
    },
  }
  function e(t) {
    return (
      !f1(t) &&
      ua(
        "git.commit: requires the commit message to be supplied as a string/string[]",
      )
    )
  }
}
var ryt = Be({
  "src/lib/tasks/commit.ts"() {
    "use strict"
    X0t(), wt(), wi()
  },
})
function nyt() {
  return {
    firstCommit() {
      return this._runTask(
        ko(["rev-list", "--max-parents=0", "HEAD"], true),
        yi(arguments),
      )
    },
  }
}
var iyt = Be({
  "src/lib/tasks/first-commit.ts"() {
    "use strict"
    wt(), wi()
  },
})
function syt(e, t) {
  let r = ["hash-object", e]
  return t && r.push("-w"), ko(r, true)
}
var oyt = Be({
  "src/lib/tasks/hash-object.ts"() {
    "use strict"
    wi()
  },
})
function ayt(e, t, r) {
  let n = String(r).trim(),
    i
  if ((i = X_e.exec(n))) return new c1(e, t, false, i[1])
  if ((i = exe.exec(n))) return new c1(e, t, true, i[1])
  let s = "",
    o = n.split(" ")
  for (; o.length; )
    if (o.shift() === "in") {
      s = o.join(" ")
      break
    }
  return new c1(e, t, /^re/i.test(n), s)
}
var c1,
  X_e,
  exe,
  lyt = Be({
    "src/lib/responses/InitSummary.ts"() {
      "use strict"
      ;(c1 = class {
        constructor(e, t, r, n) {
          ;(this.bare = e),
            (this.path = t),
            (this.existing = r),
            (this.gitDir = n)
        }
      }),
        (X_e = /^Init.+ repository in (.+)$/),
        (exe = /^Rein.+ in (.+)$/)
    },
  })
function cyt(e) {
  return e.includes(k8)
}
function uyt(e = false, t, r) {
  let n = ["init", ...r]
  return (
    e && !cyt(n) && n.splice(1, 0, k8),
    {
      commands: n,
      format: "utf-8",
      parser(i) {
        return ayt(n.includes("--bare"), t, i)
      },
    }
  )
}
var k8,
  dyt = Be({
    "src/lib/tasks/init.ts"() {
      "use strict"
      lyt(), (k8 = "--bare")
    },
  })
function M8(e) {
  for (let t = 0; t < e.length; t++) {
    let r = F8.exec(e[t])
    if (r) return `--${r[1]}`
  }
  return ""
}
function fyt(e) {
  return F8.test(e)
}
var F8,
  Jx = Be({
    "src/lib/args/log-format.ts"() {
      "use strict"
      F8 = /^--(stat|numstat|name-only|name-status)(=|$)/
    },
  }),
  txe,
  hyt = Be({
    "src/lib/responses/DiffSummary.ts"() {
      "use strict"
      txe = class {
        constructor() {
          ;(this.changed = 0),
            (this.deletions = 0),
            (this.insertions = 0),
            (this.files = [])
        }
      }
    },
  })
function rxe(e = "") {
  let t = nxe[e]
  return (r) => da(new txe(), t, r, false)
}
var r8,
  DEe,
  TEe,
  kEe,
  nxe,
  ixe = Be({
    "src/lib/parsers/parse-diff-summary.ts"() {
      "use strict"
      Jx(),
        hyt(),
        U_e(),
        wt(),
        (r8 = [
          new Ot(/^(.+)\s+\|\s+(\d+)(\s+[+\-]+)?$/, (e, [t, r, n = ""]) => {
            e.files.push({
              file: t.trim(),
              changes: Bn(r),
              insertions: n.replace(/[^+]/g, "").length,
              deletions: n.replace(/[^-]/g, "").length,
              binary: false,
            })
          }),
          new Ot(
            /^(.+) \|\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/,
            (e, [t, r, n]) => {
              e.files.push({
                file: t.trim(),
                before: Bn(r),
                after: Bn(n),
                binary: true,
              })
            },
          ),
          new Ot(
            /(\d+) files? changed\s*((?:, \d+ [^,]+){0,2})/,
            (e, [t, r]) => {
              let n = /(\d+) i/.exec(r),
                i = /(\d+) d/.exec(r)
              ;(e.changed = Bn(t)),
                (e.insertions = Bn(n?.[1])),
                (e.deletions = Bn(i?.[1]))
            },
          ),
        ]),
        (DEe = [
          new Ot(/(\d+)\t(\d+)\t(.+)$/, (e, [t, r, n]) => {
            let i = Bn(t),
              s = Bn(r)
            e.changed++,
              (e.insertions += i),
              (e.deletions += s),
              e.files.push({
                file: n,
                changes: i + s,
                insertions: i,
                deletions: s,
                binary: false,
              })
          }),
          new Ot(/-\t-\t(.+)$/, (e, [t]) => {
            e.changed++,
              e.files.push({ file: t, after: 0, before: 0, binary: true })
          }),
        ]),
        (TEe = [
          new Ot(/(.+)$/, (e, [t]) => {
            e.changed++,
              e.files.push({
                file: t,
                changes: 0,
                insertions: 0,
                deletions: 0,
                binary: false,
              })
          }),
        ]),
        (kEe = [
          new Ot(
            /([ACDMRTUXB])([0-9]{0,3})\t(.[^\t]*)(\t(.[^\t]*))?$/,
            (e, [t, r, n, i, s]) => {
              e.changed++,
                e.files.push({
                  file: s ?? n,
                  changes: 0,
                  insertions: 0,
                  deletions: 0,
                  binary: false,
                  status: o8(T0t(t) && t),
                  from: o8(!!s && n !== s && n),
                  similarity: Bn(r),
                })
            },
          ),
        ]),
        (nxe = {
          "": r8,
          "--stat": r8,
          "--numstat": DEe,
          "--name-status": kEe,
          "--name-only": TEe,
        })
    },
  })
function gyt(e, t) {
  return t.reduce(
    (r, n, i) => ((r[n] = e[i] || ""), r),
    Object.create({ diff: null }),
  )
}
function sxe(e = P8, t = oxe, r = "") {
  let n = rxe(r)
  return function (i) {
    let s = Yx(i.trim(), false, Q8).map(function (o) {
      let a = o.split(N8),
        l = gyt(a[0].split(e), t)
      return a.length > 1 && a[1].trim() && (l.diff = n(a[1])), l
    })
    return { all: s, latest: (s.length && s[0]) || null, total: s.length }
  }
}
var Q8,
  N8,
  P8,
  oxe,
  axe = Be({
    "src/lib/parsers/parse-list-log-summary.ts"() {
      "use strict"
      wt(),
        ixe(),
        Jx(),
        (Q8 = "\xF2\xF2\xF2\xF2\xF2\xF2 "),
        (N8 = " \xF2\xF2"),
        (P8 = " \xF2 "),
        (oxe = [
          "hash",
          "date",
          "message",
          "refs",
          "author_name",
          "author_email",
        ])
    },
  }),
  lxe = {}
Si(lxe, { diffSummaryTask: () => pyt, validateLogFormatConfig: () => E1 })
function pyt(e) {
  let t = M8(e),
    r = ["diff"]
  return (
    t === "" && ((t = "--stat"), r.push("--stat=4096")),
    r.push(...e),
    E1(r) || { commands: r, format: "utf-8", parser: rxe(t) }
  )
}
function E1(e) {
  let t = e.filter(fyt)
  if (t.length > 1)
    return ua(
      `Summary flags are mutually exclusive - pick one of ${t.join(",")}`,
    )
  if (t.length && e.includes("-z"))
    return ua(
      `Summary flag ${t} parsing is not compatible with null termination option '-z'`,
    )
}
var L8 = Be({
  "src/lib/tasks/diff.ts"() {
    "use strict"
    Jx(), ixe(), wi()
  },
})
function myt(e, t) {
  let r = [],
    n = []
  return (
    Object.keys(e).forEach((i) => {
      r.push(i), n.push(String(e[i]))
    }),
    [r, n.join(t)]
  )
}
function Ayt(e) {
  return Object.keys(e).reduce((t, r) => (r in g8 || (t[r] = e[r]), t), {})
}
function cxe(e = {}, t = []) {
  let r = td(e.splitter, ro, P8),
    n =
      !b8(e.format) && e.format
        ? e.format
        : {
            hash: "%H",
            date: e.strictDate === false ? "%ai" : "%aI",
            message: "%s",
            refs: "%D",
            body: e.multiLine ? "%B" : "%b",
            author_name: e.mailMap !== false ? "%aN" : "%an",
            author_email: e.mailMap !== false ? "%aE" : "%ae",
          },
    [i, s] = myt(n, r),
    o = [],
    a = [`--pretty=format:${Q8}${s}${N8}`, ...t],
    l = e.n || e["max-count"] || e.maxCount
  if ((l && a.push(`--max-count=${l}`), e.from || e.to)) {
    let c = e.symmetric !== false ? "..." : ".."
    o.push(`${e.from || ""}${c}${e.to || ""}`)
  }
  return (
    ro(e.file) && a.push("--follow", s0t(e.file)),
    x8(Ayt(e), a),
    { fields: i, splitter: r, commands: [...a, ...o] }
  )
}
function yyt(e, t, r) {
  let n = sxe(e, t, M8(r))
  return { commands: ["log", ...r], format: "utf-8", parser: n }
}
function vyt() {
  return {
    log(...r) {
      let n = yi(arguments),
        i = cxe(w8(arguments), td(arguments[0], zx)),
        s = t(...r) || E1(i.commands) || e(i)
      return this._runTask(s, n)
    },
  }
  function e(r) {
    return yyt(r.splitter, r.fields, r.commands)
  }
  function t(r, n) {
    return (
      ro(r) &&
      ro(n) &&
      ua(
        "git.log(string, string) should be replaced with git.log({ from: string, to: string })",
      )
    )
  }
}
var g8,
  uxe = Be({
    "src/lib/tasks/log.ts"() {
      "use strict"
      Jx(),
        Gx(),
        axe(),
        wt(),
        wi(),
        L8(),
        (g8 = ((e) => (
          (e[(e["--pretty"] = 0)] = "--pretty"),
          (e[(e["max-count"] = 1)] = "max-count"),
          (e[(e.maxCount = 2)] = "maxCount"),
          (e[(e.n = 3)] = "n"),
          (e[(e.file = 4)] = "file"),
          (e[(e.format = 5)] = "format"),
          (e[(e.from = 6)] = "from"),
          (e[(e.to = 7)] = "to"),
          (e[(e.splitter = 8)] = "splitter"),
          (e[(e.symmetric = 9)] = "symmetric"),
          (e[(e.mailMap = 10)] = "mailMap"),
          (e[(e.multiLine = 11)] = "multiLine"),
          (e[(e.strictDate = 12)] = "strictDate"),
          e
        ))(g8 || {}))
    },
  }),
  u1,
  dxe,
  Cyt = Be({
    "src/lib/responses/MergeSummary.ts"() {
      "use strict"
      ;(u1 = class {
        constructor(e, t = null, r) {
          ;(this.reason = e), (this.file = t), (this.meta = r)
        }
        toString() {
          return `${this.file}:${this.reason}`
        }
      }),
        (dxe = class {
          constructor() {
            ;(this.conflicts = []),
              (this.merges = []),
              (this.result = "success")
          }
          get failed() {
            return this.conflicts.length > 0
          }
          get reason() {
            return this.result
          }
          toString() {
            return this.conflicts.length
              ? `CONFLICTS: ${this.conflicts.join(", ")}`
              : "OK"
          }
        })
    },
  }),
  p8,
  fxe,
  byt = Be({
    "src/lib/responses/PullSummary.ts"() {
      "use strict"
      ;(p8 = class {
        constructor() {
          ;(this.remoteMessages = { all: [] }),
            (this.created = []),
            (this.deleted = []),
            (this.files = []),
            (this.deletions = {}),
            (this.insertions = {}),
            (this.summary = { changes: 0, deletions: 0, insertions: 0 })
        }
      }),
        (fxe = class {
          constructor() {
            ;(this.remote = ""),
              (this.hash = { local: "", remote: "" }),
              (this.branch = { local: "", remote: "" }),
              (this.message = "")
          }
          toString() {
            return this.message
          }
        })
    },
  })
function n8(e) {
  return (e.objects = e.objects || {
    compressing: 0,
    counting: 0,
    enumerating: 0,
    packReused: 0,
    reused: { count: 0, delta: 0 },
    total: { count: 0, delta: 0 },
  })
}
function MEe(e) {
  let t = /^\s*(\d+)/.exec(e),
    r = /delta (\d+)/i.exec(e)
  return { count: Bn((t && t[1]) || "0"), delta: Bn((r && r[1]) || "0") }
}
var hxe,
  Eyt = Be({
    "src/lib/parsers/parse-remote-objects.ts"() {
      "use strict"
      wt(),
        (hxe = [
          new ag(
            /^remote:\s*(enumerating|counting|compressing) objects: (\d+),/i,
            (e, [t, r]) => {
              let n = t.toLowerCase(),
                i = n8(e.remoteMessages)
              Object.assign(i, { [n]: Bn(r) })
            },
          ),
          new ag(
            /^remote:\s*(enumerating|counting|compressing) objects: \d+% \(\d+\/(\d+)\),/i,
            (e, [t, r]) => {
              let n = t.toLowerCase(),
                i = n8(e.remoteMessages)
              Object.assign(i, { [n]: Bn(r) })
            },
          ),
          new ag(
            /total ([^,]+), reused ([^,]+), pack-reused (\d+)/i,
            (e, [t, r, n]) => {
              let i = n8(e.remoteMessages)
              ;(i.total = MEe(t)), (i.reused = MEe(r)), (i.packReused = Bn(n))
            },
          ),
        ])
    },
  })
function gxe(e, t) {
  return da({ remoteMessages: new mxe() }, pxe, t)
}
var pxe,
  mxe,
  Axe = Be({
    "src/lib/parsers/parse-remote-messages.ts"() {
      "use strict"
      wt(),
        Eyt(),
        (pxe = [
          new ag(
            /^remote:\s*(.+)$/,
            (e, [t]) => (e.remoteMessages.all.push(t.trim()), false),
          ),
          ...hxe,
          new ag(
            [/create a (?:pull|merge) request/i, /\s(https?:\/\/\S+)$/],
            (e, [t]) => {
              e.remoteMessages.pullRequestUrl = t
            },
          ),
          new ag(
            [
              /found (\d+) vulnerabilities.+\(([^)]+)\)/i,
              /\s(https?:\/\/\S+)$/,
            ],
            (e, [t, r, n]) => {
              e.remoteMessages.vulnerabilities = {
                count: Bn(t),
                summary: r,
                url: n,
              }
            },
          ),
        ]),
        (mxe = class {
          constructor() {
            this.all = []
          }
        })
    },
  })
function _yt(e, t) {
  let r = da(new fxe(), yxe, [e, t])
  return r.message && r
}
var FEe,
  QEe,
  NEe,
  PEe,
  yxe,
  LEe,
  U8,
  vxe = Be({
    "src/lib/parsers/parse-pull.ts"() {
      "use strict"
      byt(),
        wt(),
        Axe(),
        (FEe = /^\s*(.+?)\s+\|\s+\d+\s*(\+*)(-*)/),
        (QEe = /(\d+)\D+((\d+)\D+\(\+\))?(\D+(\d+)\D+\(-\))?/),
        (NEe = /^(create|delete) mode \d+ (.+)/),
        (PEe = [
          new Ot(FEe, (e, [t, r, n]) => {
            e.files.push(t),
              r && (e.insertions[t] = r.length),
              n && (e.deletions[t] = n.length)
          }),
          new Ot(QEe, (e, [t, , r, , n]) =>
            r !== undefined || n !== undefined
              ? ((e.summary.changes = +t || 0),
                (e.summary.insertions = +r || 0),
                (e.summary.deletions = +n || 0),
                true)
              : false,
          ),
          new Ot(NEe, (e, [t, r]) => {
            Hr(e.files, r), Hr(t === "create" ? e.created : e.deleted, r)
          }),
        ]),
        (yxe = [
          new Ot(/^from\s(.+)$/i, (e, [t]) => void (e.remote = t)),
          new Ot(/^fatal:\s(.+)$/, (e, [t]) => void (e.message = t)),
          new Ot(
            /([a-z0-9]+)\.\.([a-z0-9]+)\s+(\S+)\s+->\s+(\S+)$/,
            (e, [t, r, n, i]) => {
              ;(e.branch.local = n),
                (e.hash.local = t),
                (e.branch.remote = i),
                (e.hash.remote = r)
            },
          ),
        ]),
        (LEe = (e, t) => da(new p8(), PEe, [e, t])),
        (U8 = (e, t) => Object.assign(new p8(), LEe(e, t), gxe(e, t)))
    },
  }),
  UEe,
  Cxe,
  OEe,
  xyt = Be({
    "src/lib/parsers/parse-merge.ts"() {
      "use strict"
      Cyt(),
        wt(),
        vxe(),
        (UEe = [
          new Ot(/^Auto-merging\s+(.+)$/, (e, [t]) => {
            e.merges.push(t)
          }),
          new Ot(
            /^CONFLICT\s+\((.+)\): Merge conflict in (.+)$/,
            (e, [t, r]) => {
              e.conflicts.push(new u1(t, r))
            },
          ),
          new Ot(
            /^CONFLICT\s+\((.+\/delete)\): (.+) deleted in (.+) and/,
            (e, [t, r, n]) => {
              e.conflicts.push(new u1(t, r, { deleteRef: n }))
            },
          ),
          new Ot(/^CONFLICT\s+\((.+)\):/, (e, [t]) => {
            e.conflicts.push(new u1(t, null))
          }),
          new Ot(/^Automatic merge failed;\s+(.+)$/, (e, [t]) => {
            e.result = t
          }),
        ]),
        (Cxe = (e, t) => Object.assign(OEe(e, t), U8(e, t))),
        (OEe = (e) => da(new dxe(), UEe, e))
    },
  })
function qEe(e) {
  return e.length
    ? {
        commands: ["merge", ...e],
        format: "utf-8",
        parser(t, r) {
          let n = Cxe(t, r)
          if (n.failed) throw new $x(n)
          return n
        },
      }
    : ua("Git.merge requires at least one option")
}
var wyt = Be({
  "src/lib/tasks/merge.ts"() {
    "use strict"
    Rv(), xyt(), wi()
  },
})
function Syt(e, t, r) {
  let n = r.includes("deleted"),
    i = r.includes("tag") || /^refs\/tags/.test(e),
    s = !r.includes("new")
  return {
    deleted: n,
    tag: i,
    branch: !i,
    new: !s,
    alreadyUpdated: s,
    local: e,
    remote: t,
  }
}
var VEe,
  bxe,
  HEe,
  Iyt = Be({
    "src/lib/parsers/parse-push.ts"() {
      "use strict"
      wt(),
        Axe(),
        (VEe = [
          new Ot(/^Pushing to (.+)$/, (e, [t]) => {
            e.repo = t
          }),
          new Ot(/^updating local tracking ref '(.+)'/, (e, [t]) => {
            e.ref = qx(Jl({}, e.ref || {}), { local: t })
          }),
          new Ot(/^[=*-]\s+([^:]+):(\S+)\s+\[(.+)]$/, (e, [t, r, n]) => {
            e.pushed.push(Syt(t, r, n))
          }),
          new Ot(
            /^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/,
            (e, [t, r, n]) => {
              e.branch = qx(Jl({}, e.branch || {}), {
                local: t,
                remote: r,
                remoteName: n,
              })
            },
          ),
          new Ot(
            /^([^:]+):(\S+)\s+([a-z0-9]+)\.\.([a-z0-9]+)$/,
            (e, [t, r, n, i]) => {
              e.update = {
                head: { local: t, remote: r },
                hash: { from: n, to: i },
              }
            },
          ),
        ]),
        (bxe = (e, t) => {
          let r = HEe(e, t),
            n = gxe(e, t)
          return Jl(Jl({}, r), n)
        }),
        (HEe = (e, t) => da({ pushed: [] }, VEe, [e, t]))
    },
  }),
  Exe = {}
Si(Exe, { pushTagsTask: () => Byt, pushTask: () => O8 })
function Byt(e = {}, t) {
  return Hr(t, "--tags"), O8(e, t)
}
function O8(e = {}, t) {
  let r = ["push", ...t]
  return (
    e.branch && r.splice(1, 0, e.branch),
    e.remote && r.splice(1, 0, e.remote),
    y1(r, "-v"),
    Hr(r, "--verbose"),
    Hr(r, "--porcelain"),
    { commands: r, format: "utf-8", parser: bxe }
  )
}
var _xe = Be({
  "src/lib/tasks/push.ts"() {
    "use strict"
    Iyt(), wt()
  },
})
function Ryt() {
  return {
    showBuffer() {
      let e = ["show", ...ca(arguments, 1)]
      return (
        e.includes("--binary") || e.splice(1, 0, "--binary"),
        this._runTask(R_e(e), yi(arguments))
      )
    },
    show() {
      let e = ["show", ...ca(arguments, 1)]
      return this._runTask(ko(e), yi(arguments))
    },
  }
}
var Dyt = Be({
    "src/lib/tasks/show.ts"() {
      "use strict"
      wt(), wi()
    },
  }),
  WEe,
  xxe,
  Tyt = Be({
    "src/lib/responses/FileStatusSummary.ts"() {
      "use strict"
      ;(WEe = /^(.+)\0(.+)$/),
        (xxe = class {
          constructor(e, t, r) {
            if (
              ((this.path = e),
              (this.index = t),
              (this.working_dir = r),
              t === "R" || r === "R")
            ) {
              let n = WEe.exec(e) || [null, e, e]
              ;(this.from = n[2] || ""), (this.path = n[1] || "")
            }
          }
        })
    },
  })
function GEe(e) {
  let [t, r] = e.split(Bv)
  return { from: r || t, to: t }
}
function tl(e, t, r) {
  return [`${e}${t}`, r]
}
function i8(e, ...t) {
  return t.map((r) => tl(e, r, (n, i) => Hr(n.conflicted, i)))
}
function kyt(e, t) {
  let r = t.trim()
  switch (" ") {
    case r.charAt(2):
      return n(r.charAt(0), r.charAt(1), r.substr(3))
    case r.charAt(1):
      return n(" ", r.charAt(0), r.substr(2))
    default:
      return
  }
  function n(i, s, o) {
    let a = `${i}${s}`,
      l = wxe.get(a)
    l && l(e, o), a !== "##" && a !== "!!" && e.files.push(new xxe(o, i, s))
  }
}
var $Ee,
  wxe,
  Sxe,
  Myt = Be({
    "src/lib/responses/StatusSummary.ts"() {
      "use strict"
      wt(),
        Tyt(),
        ($Ee = class {
          constructor() {
            ;(this.not_added = []),
              (this.conflicted = []),
              (this.created = []),
              (this.deleted = []),
              (this.ignored = undefined),
              (this.modified = []),
              (this.renamed = []),
              (this.files = []),
              (this.staged = []),
              (this.ahead = 0),
              (this.behind = 0),
              (this.current = null),
              (this.tracking = null),
              (this.detached = false),
              (this.isClean = () => !this.files.length)
          }
        }),
        (wxe = new Map([
          tl(" ", "A", (e, t) => Hr(e.created, t)),
          tl(" ", "D", (e, t) => Hr(e.deleted, t)),
          tl(" ", "M", (e, t) => Hr(e.modified, t)),
          tl("A", " ", (e, t) => Hr(e.created, t) && Hr(e.staged, t)),
          tl(
            "A",
            "M",
            (e, t) => Hr(e.created, t) && Hr(e.staged, t) && Hr(e.modified, t),
          ),
          tl("D", " ", (e, t) => Hr(e.deleted, t) && Hr(e.staged, t)),
          tl("M", " ", (e, t) => Hr(e.modified, t) && Hr(e.staged, t)),
          tl("M", "M", (e, t) => Hr(e.modified, t) && Hr(e.staged, t)),
          tl("R", " ", (e, t) => {
            Hr(e.renamed, GEe(t))
          }),
          tl("R", "M", (e, t) => {
            let r = GEe(t)
            Hr(e.renamed, r), Hr(e.modified, r.to)
          }),
          tl("!", "!", (e, t) => {
            Hr((e.ignored = e.ignored || []), t)
          }),
          tl("?", "?", (e, t) => Hr(e.not_added, t)),
          ...i8("A", "A", "U"),
          ...i8("D", "D", "U"),
          ...i8("U", "A", "D", "U"),
          [
            "##",
            (e, t) => {
              let r = /ahead (\d+)/,
                n = /behind (\d+)/,
                i = /^(.+?(?=(?:\.{3}|\s|$)))/,
                s = /\.{3}(\S*)/,
                o = /\son\s([\S]+)$/,
                a
              ;(a = r.exec(t)),
                (e.ahead = (a && +a[1]) || 0),
                (a = n.exec(t)),
                (e.behind = (a && +a[1]) || 0),
                (a = i.exec(t)),
                (e.current = a && a[1]),
                (a = s.exec(t)),
                (e.tracking = a && a[1]),
                (a = o.exec(t)),
                (e.current = (a && a[1]) || e.current),
                (e.detached = /\(no branch\)/.test(t))
            },
          ],
        ])),
        (Sxe = function (e) {
          let t = e.split(Bv),
            r = new $Ee()
          for (let n = 0, i = t.length; n < i; ) {
            let s = t[n++].trim()
            s && (s.charAt(0) === "R" && (s += Bv + (t[n++] || "")), kyt(r, s))
          }
          return r
        })
    },
  })
function Fyt(e) {
  return {
    format: "utf-8",
    commands: [
      "status",
      "--porcelain",
      "-b",
      "-u",
      "--null",
      ...e.filter((r) => !Ixe.includes(r)),
    ],
    parser(r) {
      return Sxe(r)
    },
  }
}
var Ixe,
  Qyt = Be({
    "src/lib/tasks/status.ts"() {
      "use strict"
      Myt(), (Ixe = ["--null", "-z"])
    },
  })
function g1(e = 0, t = 0, r = 0, n = "", i = true) {
  return Object.defineProperty(
    { major: e, minor: t, patch: r, agent: n, installed: i },
    "toString",
    {
      value() {
        return `${this.major}.${this.minor}.${this.patch}`
      },
      configurable: false,
      enumerable: false,
    },
  )
}
function Nyt() {
  return g1(0, 0, 0, "", false)
}
function Pyt() {
  return {
    version() {
      return this._runTask({
        commands: ["--version"],
        format: "utf-8",
        parser: Lyt,
        onError(e, t, r, n) {
          if (e.exitCode === -2) return r(Buffer.from(q8))
          n(t)
        },
      })
    },
  }
}
function Lyt(e) {
  return e === q8 ? Nyt() : da(g1(0, 0, 0, e), Bxe, e)
}
var q8,
  Bxe,
  Uyt = Be({
    "src/lib/tasks/version.ts"() {
      "use strict"
      wt(),
        (q8 = "installed=false"),
        (Bxe = [
          new Ot(
            /version (\d+)\.(\d+)\.(\d+)(?:\s*\((.+)\))?/,
            (e, [t, r, n, i = ""]) => {
              Object.assign(e, g1(Bn(t), Bn(r), Bn(n), i))
            },
          ),
          new Ot(
            /version (\d+)\.(\d+)\.(\D+)(.+)?$/,
            (e, [t, r, n, i = ""]) => {
              Object.assign(e, g1(Bn(t), Bn(r), n, i))
            },
          ),
        ])
    },
  }),
  Rxe = {}
Si(Rxe, { SimpleGitApi: () => m8 })
var m8,
  Oyt = Be({
    "src/lib/simple-git-api.ts"() {
      "use strict"
      G0t(),
        $0t(),
        K0t(),
        j0t(),
        ryt(),
        P_e(),
        iyt(),
        V_e(),
        oyt(),
        dyt(),
        uxe(),
        wyt(),
        _xe(),
        Dyt(),
        Qyt(),
        wi(),
        Uyt(),
        wt(),
        (m8 = class {
          constructor(e) {
            this._executor = e
          }
          _runTask(e, t) {
            let r = this._executor.chain(),
              n = r.push(e)
            return (
              t && H0t(e, n, t),
              Object.create(this, {
                then: { value: n.then.bind(n) },
                catch: { value: n.catch.bind(n) },
                _executor: { value: r },
              })
            )
          }
          add(e) {
            return this._runTask(ko(["add", ...ed(e)]), yi(arguments))
          }
          cwd(e) {
            let t = yi(arguments)
            return typeof e == "string"
              ? this._runTask(REe(e, this._executor), t)
              : typeof e?.path == "string"
                ? this._runTask(
                    REe(e.path, (e.root && this._executor) || undefined),
                    t,
                  )
                : this._runTask(
                    ua(
                      "Git.cwd: workingDirectory must be supplied as a string",
                    ),
                    t,
                  )
          }
          hashObject(e, t) {
            return this._runTask(syt(e, t === true), yi(arguments))
          }
          init(e) {
            return this._runTask(
              uyt(e === true, this._executor.cwd, ca(arguments)),
              yi(arguments),
            )
          }
          merge() {
            return this._runTask(qEe(ca(arguments)), yi(arguments))
          }
          mergeFromTo(e, t) {
            return ro(e) && ro(t)
              ? this._runTask(qEe([e, t, ...ca(arguments)]), yi(arguments, false))
              : this._runTask(
                  ua(
                    "Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings",
                  ),
                )
          }
          outputHandler(e) {
            return (this._executor.outputHandler = e), this
          }
          push() {
            let e = O8(
              { remote: td(arguments[0], ro), branch: td(arguments[1], ro) },
              ca(arguments),
            )
            return this._runTask(e, yi(arguments))
          }
          stash() {
            return this._runTask(ko(["stash", ...ca(arguments)]), yi(arguments))
          }
          status() {
            return this._runTask(Fyt(ca(arguments)), yi(arguments))
          }
        }),
        Object.assign(
          m8.prototype,
          Y0t(),
          tyt(),
          D0t(),
          J0t(),
          nyt(),
          F0t(),
          vyt(),
          Ryt(),
          Pyt(),
        )
    },
  }),
  Dxe = {}
Si(Dxe, { Scheduler: () => kxe })
var YEe,
  kxe,
  qyt = Be({
    "src/lib/runners/scheduler.ts"() {
      "use strict"
      wt(),
        Y_e(),
        (YEe = (() => {
          let e = 0
          return () => {
            e++
            let { promise: t, done: r } = (0, Txe.createDeferred)()
            return { promise: t, done: r, id: e }
          }
        })()),
        (kxe = class {
          constructor(e = 2) {
            ;(this.concurrency = e),
              (this.logger = T8("", "scheduler")),
              (this.pending = []),
              (this.running = []),
              this.logger("Constructed, concurrency=%s", e)
          }
          schedule() {
            if (
              !this.pending.length ||
              this.running.length >= this.concurrency
            ) {
              this.logger(
                "Schedule attempt ignored, pending=%s running=%s concurrency=%s",
                this.pending.length,
                this.running.length,
                this.concurrency,
              )
              return
            }
            let e = Hr(this.running, this.pending.shift())
            this.logger("Attempting id=%s", e.id),
              e.done(() => {
                this.logger("Completing id=", e.id),
                  y1(this.running, e),
                  this.schedule()
              })
          }
          next() {
            let { promise: e, id: t } = Hr(this.pending, YEe())
            return this.logger("Scheduling id=%s", t), this.schedule(), e
          }
        })
    },
  }),
  Mxe = {}
Si(Mxe, { applyPatchTask: () => Vyt })
function Vyt(e, t) {
  return ko(["apply", ...t, ...e])
}
var Hyt = Be({
  "src/lib/tasks/apply-patch.ts"() {
    "use strict"
    wi()
  },
})
function Wyt(e, t) {
  return { branch: e, hash: t, success: true }
}
function Gyt(e) {
  return { branch: e, hash: null, success: false }
}
var Fxe,
  $yt = Be({
    "src/lib/responses/BranchDeleteSummary.ts"() {
      "use strict"
      Fxe = class {
        constructor() {
          ;(this.all = []), (this.branches = {}), (this.errors = [])
        }
        get success() {
          return !this.errors.length
        }
      }
    },
  })
function Qxe(e, t) {
  return t === 1 && A8.test(e)
}
var KEe,
  A8,
  zEe,
  _1,
  Yyt = Be({
    "src/lib/parsers/parse-branch-delete.ts"() {
      "use strict"
      $yt(),
        wt(),
        (KEe = /(\S+)\s+\(\S+\s([^)]+)\)/),
        (A8 = /^error[^']+'([^']+)'/m),
        (zEe = [
          new Ot(KEe, (e, [t, r]) => {
            let n = Wyt(t, r)
            e.all.push(n), (e.branches[t] = n)
          }),
          new Ot(A8, (e, [t]) => {
            let r = Gyt(t)
            e.errors.push(r), e.all.push(r), (e.branches[t] = r)
          }),
        ]),
        (_1 = (e, t) => da(new Fxe(), zEe, [e, t]))
    },
  }),
  Nxe,
  Kyt = Be({
    "src/lib/responses/BranchSummary.ts"() {
      "use strict"
      Nxe = class {
        constructor() {
          ;(this.all = []),
            (this.branches = {}),
            (this.current = ""),
            (this.detached = false)
        }
        push(e, t, r, n, i) {
          e === "*" && ((this.detached = t), (this.current = r)),
            this.all.push(r),
            (this.branches[r] = {
              current: e === "*",
              linkedWorkTree: e === "+",
              name: r,
              commit: n,
              label: i,
            })
        }
      }
    },
  })
function JEe(e) {
  return e ? e.charAt(0) : ""
}
function Pxe(e) {
  return da(new Nxe(), Lxe, e)
}
var Lxe,
  zyt = Be({
    "src/lib/parsers/parse-branch.ts"() {
      "use strict"
      Kyt(),
        wt(),
        (Lxe = [
          new Ot(
            /^([*+]\s)?\((?:HEAD )?detached (?:from|at) (\S+)\)\s+([a-z0-9]+)\s(.*)$/,
            (e, [t, r, n, i]) => {
              e.push(JEe(t), true, r, n, i)
            },
          ),
          new Ot(
            new RegExp("^([*+]\\s)?(\\S+)\\s+([a-z0-9]+)\\s?(.*)$", "s"),
            (e, [t, r, n, i]) => {
              e.push(JEe(t), false, r, n, i)
            },
          ),
        ])
    },
  }),
  Uxe = {}
Si(Uxe, {
  branchLocalTask: () => jyt,
  branchTask: () => Jyt,
  containsDeleteBranchCommand: () => Oxe,
  deleteBranchTask: () => Xyt,
  deleteBranchesTask: () => Zyt,
})
function Oxe(e) {
  let t = ["-d", "-D", "--delete"]
  return e.some((r) => t.includes(r))
}
function Jyt(e) {
  let t = Oxe(e),
    r = ["branch", ...e]
  return (
    r.length === 1 && r.push("-a"),
    r.includes("-v") || r.splice(1, 0, "-v"),
    {
      format: "utf-8",
      commands: r,
      parser(n, i) {
        return t ? _1(n, i).all[0] : Pxe(n)
      },
    }
  )
}
function jyt() {
  return { format: "utf-8", commands: ["branch", "-v"], parser: Pxe }
}
function Zyt(e, t = false) {
  return {
    format: "utf-8",
    commands: ["branch", "-v", t ? "-D" : "-d", ...e],
    parser(r, n) {
      return _1(r, n)
    },
    onError({ exitCode: r, stdOut: n }, i, s, o) {
      if (!Qxe(String(i), r)) return o(i)
      s(n)
    },
  }
}
function Xyt(e, t = false) {
  let r = {
    format: "utf-8",
    commands: ["branch", "-v", t ? "-D" : "-d", e],
    parser(n, i) {
      return _1(n, i).branches[e]
    },
    onError({ exitCode: n, stdErr: i, stdOut: s }, o, a, l) {
      if (!Qxe(String(o), n)) return l(o)
      throw new $x(r.parser(Hx(s), Hx(i)), String(o))
    },
  }
  return r
}
var evt = Be({
    "src/lib/tasks/branch.ts"() {
      "use strict"
      Rv(), Yyt(), zyt(), wt()
    },
  }),
  qxe,
  tvt = Be({
    "src/lib/responses/CheckIgnore.ts"() {
      "use strict"
      qxe = (e) =>
        e
          .split(/\n/g)
          .map((t) => t.trim())
          .filter((t) => !!t)
    },
  }),
  Vxe = {}
Si(Vxe, { checkIgnoreTask: () => rvt })
function rvt(e) {
  return { commands: ["check-ignore", ...e], format: "utf-8", parser: qxe }
}
var nvt = Be({
    "src/lib/tasks/check-ignore.ts"() {
      "use strict"
      tvt()
    },
  }),
  Hxe = {}
Si(Hxe, { cloneMirrorTask: () => svt, cloneTask: () => Wxe })
function ivt(e) {
  return /^--upload-pack(=|$)/.test(e)
}
function Wxe(e, t, r) {
  let n = ["clone", ...r]
  return (
    ro(e) && n.push(e),
    ro(t) && n.push(t),
    n.find(ivt) ? ua("git.fetch: potential exploit argument blocked.") : ko(n)
  )
}
function svt(e, t, r) {
  return Hr(r, "--mirror"), Wxe(e, t, r)
}
var ovt = Be({
  "src/lib/tasks/clone.ts"() {
    "use strict"
    wi(), wt()
  },
})
function avt(e, t) {
  return da(
    { raw: e, remote: null, branches: [], tags: [], updated: [], deleted: [] },
    Gxe,
    [e, t],
  )
}
var Gxe,
  lvt = Be({
    "src/lib/parsers/parse-fetch.ts"() {
      "use strict"
      wt(),
        (Gxe = [
          new Ot(/From (.+)$/, (e, [t]) => {
            e.remote = t
          }),
          new Ot(/\* \[new branch]\s+(\S+)\s*-> (.+)$/, (e, [t, r]) => {
            e.branches.push({ name: t, tracking: r })
          }),
          new Ot(/\* \[new tag]\s+(\S+)\s*-> (.+)$/, (e, [t, r]) => {
            e.tags.push({ name: t, tracking: r })
          }),
          new Ot(/- \[deleted]\s+\S+\s*-> (.+)$/, (e, [t]) => {
            e.deleted.push({ tracking: t })
          }),
          new Ot(
            /\s*([^.]+)\.\.(\S+)\s+(\S+)\s*-> (.+)$/,
            (e, [t, r, n, i]) => {
              e.updated.push({ name: n, tracking: i, to: r, from: t })
            },
          ),
        ])
    },
  }),
  $xe = {}
Si($xe, { fetchTask: () => uvt })
function cvt(e) {
  return /^--upload-pack(=|$)/.test(e)
}
function uvt(e, t, r) {
  let n = ["fetch", ...r]
  return (
    e && t && n.push(e, t),
    n.find(cvt)
      ? ua("git.fetch: potential exploit argument blocked.")
      : { commands: n, format: "utf-8", parser: avt }
  )
}
var dvt = Be({
  "src/lib/tasks/fetch.ts"() {
    "use strict"
    lvt(), wi()
  },
})
function fvt(e) {
  return da({ moves: [] }, Yxe, e)
}
var Yxe,
  hvt = Be({
    "src/lib/parsers/parse-move.ts"() {
      "use strict"
      wt(),
        (Yxe = [
          new Ot(/^Renaming (.+) to (.+)$/, (e, [t, r]) => {
            e.moves.push({ from: t, to: r })
          }),
        ])
    },
  }),
  Kxe = {}
Si(Kxe, { moveTask: () => gvt })
function gvt(e, t) {
  return { commands: ["mv", "-v", ...ed(e), t], format: "utf-8", parser: fvt }
}
var pvt = Be({
    "src/lib/tasks/move.ts"() {
      "use strict"
      hvt(), wt()
    },
  }),
  zxe = {}
Si(zxe, { pullTask: () => mvt })
function mvt(e, t, r) {
  let n = ["pull", ...r]
  return (
    e && t && n.splice(1, 0, e, t),
    {
      commands: n,
      format: "utf-8",
      parser(i, s) {
        return U8(i, s)
      },
      onError(i, s, o, a) {
        let l = _yt(Hx(i.stdOut), Hx(i.stdErr))
        if (l) return a(new $x(l))
        a(s)
      },
    }
  )
}
var Avt = Be({
  "src/lib/tasks/pull.ts"() {
    "use strict"
    Rv(), vxe(), wt()
  },
})
function yvt(e) {
  let t = {}
  return Jxe(e, ([r]) => (t[r] = { name: r })), Object.values(t)
}
function vvt(e) {
  let t = {}
  return (
    Jxe(e, ([r, n, i]) => {
      t.hasOwnProperty(r) ||
        (t[r] = { name: r, refs: { fetch: "", push: "" } }),
        i && n && (t[r].refs[i.replace(/[^a-z]/g, "")] = n)
    }),
    Object.values(t)
  )
}
function Jxe(e, t) {
  v8(e, (r) => t(r.split(/\s+/)))
}
var Cvt = Be({
    "src/lib/responses/GetRemoteSummary.ts"() {
      "use strict"
      wt()
    },
  }),
  jxe = {}
Si(jxe, {
  addRemoteTask: () => bvt,
  getRemotesTask: () => Evt,
  listRemotesTask: () => _vt,
  remoteTask: () => xvt,
  removeRemoteTask: () => wvt,
})
function bvt(e, t, r) {
  return ko(["remote", "add", ...r, e, t])
}
function Evt(e) {
  let t = ["remote"]
  return (
    e && t.push("-v"), { commands: t, format: "utf-8", parser: e ? vvt : yvt }
  )
}
function _vt(e) {
  let t = [...e]
  return t[0] !== "ls-remote" && t.unshift("ls-remote"), ko(t)
}
function xvt(e) {
  let t = [...e]
  return t[0] !== "remote" && t.unshift("remote"), ko(t)
}
function wvt(e) {
  return ko(["remote", "remove", e])
}
var Svt = Be({
    "src/lib/tasks/remote.ts"() {
      "use strict"
      Cvt(), wi()
    },
  }),
  Zxe = {}
Si(Zxe, { stashListTask: () => Ivt })
function Ivt(e = {}, t) {
  let r = cxe(e),
    n = ["stash", "list", ...r.commands, ...t],
    i = sxe(r.splitter, r.fields, M8(n))
  return E1(n) || { commands: n, format: "utf-8", parser: i }
}
var Bvt = Be({
    "src/lib/tasks/stash-list.ts"() {
      "use strict"
      Jx(), axe(), L8(), uxe()
    },
  }),
  Xxe = {}
Si(Xxe, {
  addSubModuleTask: () => Rvt,
  initSubModuleTask: () => Dvt,
  subModuleTask: () => x1,
  updateSubModuleTask: () => Tvt,
})
function Rvt(e, t) {
  return x1(["add", e, t])
}
function Dvt(e) {
  return x1(["init", ...e])
}
function x1(e) {
  let t = [...e]
  return t[0] !== "submodule" && t.unshift("submodule"), ko(t)
}
function Tvt(e) {
  return x1(["update", ...e])
}
var kvt = Be({
  "src/lib/tasks/sub-module.ts"() {
    "use strict"
    wi()
  },
})
function Mvt(e, t) {
  let r = isNaN(e),
    n = isNaN(t)
  return r !== n ? (r ? 1 : -1) : r ? ewe(e, t) : 0
}
function ewe(e, t) {
  return e === t ? 0 : e > t ? 1 : -1
}
function Fvt(e) {
  return e.trim()
}
function o1(e) {
  return (typeof e == "string" && parseInt(e.replace(/^\D+/g, ""), 10)) || 0
}
var jEe,
  twe,
  Qvt = Be({
    "src/lib/responses/TagList.ts"() {
      "use strict"
      ;(jEe = class {
        constructor(e, t) {
          ;(this.all = e), (this.latest = t)
        }
      }),
        (twe = function (e, t = false) {
          let r = e
            .split(
              `
`,
            )
            .map(Fvt)
            .filter(Boolean)
          t ||
            r.sort(function (i, s) {
              let o = i.split("."),
                a = s.split(".")
              if (o.length === 1 || a.length === 1)
                return Mvt(o1(o[0]), o1(a[0]))
              for (let l = 0, c = Math.max(o.length, a.length); l < c; l++) {
                let u = ewe(o1(o[l]), o1(a[l]))
                if (u) return u
              }
              return 0
            })
          let n = t ? r[0] : [...r].reverse().find((i) => i.indexOf(".") >= 0)
          return new jEe(r, n)
        })
    },
  }),
  rwe = {}
Si(rwe, {
  addAnnotatedTagTask: () => Lvt,
  addTagTask: () => Pvt,
  tagListTask: () => Nvt,
})
function Nvt(e = []) {
  let t = e.some((r) => /^--sort=/.test(r))
  return {
    format: "utf-8",
    commands: ["tag", "-l", ...e],
    parser(r) {
      return twe(r, t)
    },
  }
}
function Pvt(e) {
  return {
    format: "utf-8",
    commands: ["tag", e],
    parser() {
      return { name: e }
    },
  }
}
function Lvt(e, t) {
  return {
    format: "utf-8",
    commands: ["tag", "-a", "-m", t, e],
    parser() {
      return { name: e }
    },
  }
}
var Uvt = Be({
    "src/lib/tasks/tag.ts"() {
      "use strict"
      Qvt()
    },
  }),
  Ovt = n0t({
    "src/git.js"(e, t) {
      "use strict"
      var { GitExecutor: r } = (V0t(), Ai(z_e)),
        { SimpleGitApi: n } = (Oyt(), Ai(Rxe)),
        { Scheduler: i } = (qyt(), Ai(Dxe)),
        { configurationErrorTask: s } = (wi(), Ai(u8)),
        {
          asArray: o,
          filterArray: a,
          filterPrimitives: l,
          filterString: c,
          filterStringOrStringArray: u,
          filterType: f,
          getTrailingOptions: p,
          trailingFunctionArgument: g,
          trailingOptionsArgument: m,
        } = (wt(), Ai(v_e)),
        { applyPatchTask: y } = (Hyt(), Ai(Mxe)),
        {
          branchTask: v,
          branchLocalTask: C,
          deleteBranchesTask: E,
          deleteBranchTask: w,
        } = (evt(), Ai(Uxe)),
        { checkIgnoreTask: B } = (nvt(), Ai(Vxe)),
        { checkIsRepoTask: T } = (__e(), Ai(C_e)),
        { cloneTask: N, cloneMirrorTask: W } = (ovt(), Ai(Hxe)),
        { cleanWithOptionsTask: Z, isCleanOptionsArray: te } = (F_e(), Ai(k_e)),
        { diffSummaryTask: Y } = (L8(), Ai(lxe)),
        { fetchTask: U } = (dvt(), Ai($xe)),
        { moveTask: ce } = (pvt(), Ai(Kxe)),
        { pullTask: Ie } = (Avt(), Ai(zxe)),
        { pushTagsTask: Q } = (_xe(), Ai(Exe)),
        {
          addRemoteTask: se,
          getRemotesTask: J,
          listRemotesTask: ie,
          remoteTask: Ue,
          removeRemoteTask: At,
        } = (Svt(), Ai(jxe)),
        { getResetMode: ve, resetTask: Mt } = ($_e(), Ai(H_e)),
        { stashListTask: Xt } = (Bvt(), Ai(Zxe)),
        {
          addSubModuleTask: rr,
          initSubModuleTask: ue,
          subModuleTask: wr,
          updateSubModuleTask: or,
        } = (kvt(), Ai(Xxe)),
        {
          addAnnotatedTagTask: Wr,
          addTagTask: Ge,
          tagListTask: ln,
        } = (Uvt(), Ai(rwe)),
        { straightThroughBufferTask: Gr, straightThroughStringTask: pr } =
          (wi(), Ai(u8))
      function Ee(he, be) {
        ;(this._plugins = be),
          (this._executor = new r(
            he.baseDir,
            new i(he.maxConcurrentProcesses),
            be,
          )),
          (this._trimmed = he.trimmed)
      }
      ;((Ee.prototype = Object.create(n.prototype)).constructor = Ee),
        (Ee.prototype.customBinary = function (he) {
          return this._plugins.reconfigure("binary", he), this
        }),
        (Ee.prototype.env = function (he, be) {
          return (
            arguments.length === 1 && typeof he == "object"
              ? (this._executor.env = he)
              : ((this._executor.env = this._executor.env || {})[he] = be),
            this
          )
        }),
        (Ee.prototype.stashList = function (he) {
          return this._runTask(
            Xt(m(arguments) || {}, (a(he) && he) || []),
            g(arguments),
          )
        })
      function Or(he, be, _t, hn) {
        return typeof _t != "string"
          ? s(`git.${he}() requires a string 'repoPath'`)
          : be(_t, f(hn, c), p(arguments))
      }
      ;(Ee.prototype.clone = function () {
        return this._runTask(Or("clone", N, ...arguments), g(arguments))
      }),
        (Ee.prototype.mirror = function () {
          return this._runTask(Or("mirror", W, ...arguments), g(arguments))
        }),
        (Ee.prototype.mv = function (he, be) {
          return this._runTask(ce(he, be), g(arguments))
        }),
        (Ee.prototype.checkoutLatestTag = function (he) {
          var be = this
          return this.pull(function () {
            be.tags(function (_t, hn) {
              be.checkout(hn.latest, he)
            })
          })
        }),
        (Ee.prototype.pull = function (he, be, _t, hn) {
          return this._runTask(
            Ie(f(he, c), f(be, c), p(arguments)),
            g(arguments),
          )
        }),
        (Ee.prototype.fetch = function (he, be) {
          return this._runTask(
            U(f(he, c), f(be, c), p(arguments)),
            g(arguments),
          )
        }),
        (Ee.prototype.silent = function (he) {
          return (
            console.warn(
              "simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3",
            ),
            this
          )
        }),
        (Ee.prototype.tags = function (he, be) {
          return this._runTask(ln(p(arguments)), g(arguments))
        }),
        (Ee.prototype.rebase = function () {
          return this._runTask(pr(["rebase", ...p(arguments)]), g(arguments))
        }),
        (Ee.prototype.reset = function (he) {
          return this._runTask(Mt(ve(he), p(arguments)), g(arguments))
        }),
        (Ee.prototype.revert = function (he) {
          let be = g(arguments)
          return typeof he != "string"
            ? this._runTask(s("Commit must be a string"), be)
            : this._runTask(pr(["revert", ...p(arguments, 0, true), he]), be)
        }),
        (Ee.prototype.addTag = function (he) {
          let be =
            typeof he == "string" ? Ge(he) : s("Git.addTag requires a tag name")
          return this._runTask(be, g(arguments))
        }),
        (Ee.prototype.addAnnotatedTag = function (he, be) {
          return this._runTask(Wr(he, be), g(arguments))
        }),
        (Ee.prototype.deleteLocalBranch = function (he, be, _t) {
          return this._runTask(
            w(he, typeof be == "boolean" ? be : false),
            g(arguments),
          )
        }),
        (Ee.prototype.deleteLocalBranches = function (he, be, _t) {
          return this._runTask(
            E(he, typeof be == "boolean" ? be : false),
            g(arguments),
          )
        }),
        (Ee.prototype.branch = function (he, be) {
          return this._runTask(v(p(arguments)), g(arguments))
        }),
        (Ee.prototype.branchLocal = function (he) {
          return this._runTask(C(), g(arguments))
        }),
        (Ee.prototype.raw = function (he) {
          let be = !Array.isArray(he),
            _t = [].slice.call(be ? arguments : he, 0)
          for (let Rn = 0; Rn < _t.length && be; Rn++)
            if (!l(_t[Rn])) {
              _t.splice(Rn, _t.length - Rn)
              break
            }
          _t.push(...p(arguments, 0, true))
          var hn = g(arguments)
          return _t.length
            ? this._runTask(pr(_t, this._trimmed), hn)
            : this._runTask(
                s("Raw: must supply one or more command to execute"),
                hn,
              )
        }),
        (Ee.prototype.submoduleAdd = function (he, be, _t) {
          return this._runTask(rr(he, be), g(arguments))
        }),
        (Ee.prototype.submoduleUpdate = function (he, be) {
          return this._runTask(or(p(arguments, true)), g(arguments))
        }),
        (Ee.prototype.submoduleInit = function (he, be) {
          return this._runTask(ue(p(arguments, true)), g(arguments))
        }),
        (Ee.prototype.subModule = function (he, be) {
          return this._runTask(wr(p(arguments)), g(arguments))
        }),
        (Ee.prototype.listRemote = function () {
          return this._runTask(ie(p(arguments)), g(arguments))
        }),
        (Ee.prototype.addRemote = function (he, be, _t) {
          return this._runTask(se(he, be, p(arguments)), g(arguments))
        }),
        (Ee.prototype.removeRemote = function (he, be) {
          return this._runTask(At(he), g(arguments))
        }),
        (Ee.prototype.getRemotes = function (he, be) {
          return this._runTask(J(he === true), g(arguments))
        }),
        (Ee.prototype.remote = function (he, be) {
          return this._runTask(Ue(p(arguments)), g(arguments))
        }),
        (Ee.prototype.tag = function (he, be) {
          let _t = p(arguments)
          return (
            _t[0] !== "tag" && _t.unshift("tag"),
            this._runTask(pr(_t), g(arguments))
          )
        }),
        (Ee.prototype.updateServerInfo = function (he) {
          return this._runTask(pr(["update-server-info"]), g(arguments))
        }),
        (Ee.prototype.pushTags = function (he, be) {
          let _t = Q({ remote: f(he, c) }, p(arguments))
          return this._runTask(_t, g(arguments))
        }),
        (Ee.prototype.rm = function (he) {
          return this._runTask(pr(["rm", "-f", ...o(he)]), g(arguments))
        }),
        (Ee.prototype.rmKeepLocal = function (he) {
          return this._runTask(pr(["rm", "--cached", ...o(he)]), g(arguments))
        }),
        (Ee.prototype.catFile = function (he, be) {
          return this._catFile("utf-8", arguments)
        }),
        (Ee.prototype.binaryCatFile = function () {
          return this._catFile("buffer", arguments)
        }),
        (Ee.prototype._catFile = function (he, be) {
          var _t = g(be),
            hn = ["cat-file"],
            Rn = be[0]
          if (typeof Rn == "string")
            return this._runTask(
              s("Git.catFile: options must be supplied as an array of strings"),
              _t,
            )
          Array.isArray(Rn) && hn.push.apply(hn, Rn)
          let Ii = he === "buffer" ? Gr(hn) : pr(hn)
          return this._runTask(Ii, _t)
        }),
        (Ee.prototype.diff = function (he, be) {
          let _t = c(he)
            ? s(
                "git.diff: supplying options as a single string is no longer supported, switch to an array of strings",
              )
            : pr(["diff", ...p(arguments)])
          return this._runTask(_t, g(arguments))
        }),
        (Ee.prototype.diffSummary = function () {
          return this._runTask(Y(p(arguments, 1)), g(arguments))
        }),
        (Ee.prototype.applyPatch = function (he) {
          let be = u(he)
            ? y(o(he), p([].slice.call(arguments, 1)))
            : s(
                "git.applyPatch requires one or more string patches as the first argument",
              )
          return this._runTask(be, g(arguments))
        }),
        (Ee.prototype.revparse = function () {
          let he = ["rev-parse", ...p(arguments, true)]
          return this._runTask(pr(he, true), g(arguments))
        }),
        (Ee.prototype.clean = function (he, be, _t) {
          let hn = te(he),
            Rn = (hn && he.join("")) || f(he, c) || "",
            Ii = p([].slice.call(arguments, hn ? 1 : 0))
          return this._runTask(Z(Rn, Ii), g(arguments))
        }),
        (Ee.prototype.exec = function (he) {
          let be = {
            commands: [],
            format: "utf-8",
            parser() {
              typeof he == "function" && he()
            },
          }
          return this._runTask(be)
        }),
        (Ee.prototype.clearQueue = function () {
          return this
        }),
        (Ee.prototype.checkIgnore = function (he, be) {
          return this._runTask(B(o(f(he, u, []))), g(arguments))
        }),
        (Ee.prototype.checkIsRepo = function (he, be) {
          return this._runTask(T(f(he, c)), g(arguments))
        }),
        (t.exports = Ee)
    },
  })
Gx()
lg()
var qvt = class extends Af {
  constructor(e, t) {
    super(undefined, t), (this.config = e)
  }
}
lg()
lg()
var mf = class extends Af {
  constructor(e, t, r) {
    super(e, r),
      (this.task = e),
      (this.plugin = t),
      Object.setPrototypeOf(this, new.target.prototype)
  }
}
Rv()
i_e()
__e()
F_e()
P_e()
U_e()
V_e()
$_e()
function Vvt(e) {
  return e
    ? [
        {
          type: "spawn.before",
          action(n, i) {
            e.aborted &&
              i.kill(new mf(undefined, "abort", "Abort already signaled"))
          },
        },
        {
          type: "spawn.after",
          action(n, i) {
            function s() {
              i.kill(new mf(undefined, "abort", "Abort signal received"))
            }
            e.addEventListener("abort", s),
              i.spawned.on("close", () => e.removeEventListener("abort", s))
          },
        },
      ]
    : undefined
}
function Hvt(e) {
  return typeof e == "string" && e.trim().toLowerCase() === "-c"
}
function Wvt(e, t) {
  if (Hvt(e) && /^\s*protocol(.[a-z]+)?.allow/.test(t))
    throw new mf(
      undefined,
      "unsafe",
      "Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol",
    )
}
function Gvt(e, t) {
  if (/^\s*--(upload|receive)-pack/.test(e))
    throw new mf(
      undefined,
      "unsafe",
      "Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack",
    )
  if (t === "clone" && /^\s*-u\b/.test(e))
    throw new mf(
      undefined,
      "unsafe",
      "Use of clone with option -u is not permitted without enabling allowUnsafePack",
    )
  if (t === "push" && /^\s*--exec\b/.test(e))
    throw new mf(
      undefined,
      "unsafe",
      "Use of push with option --exec is not permitted without enabling allowUnsafePack",
    )
}
function $vt({
  allowUnsafeProtocolOverride: e = false,
  allowUnsafePack: t = false,
} = {}) {
  return {
    type: "spawn.args",
    action(r, n) {
      return (
        r.forEach((i, s) => {
          let o = s < r.length ? r[s + 1] : ""
          e || Wvt(i, o), t || Gvt(i, n.method)
        }),
        r
      )
    },
  }
}
wt()
function Yvt(e) {
  let t = Vx(e, "-c")
  return {
    type: "spawn.args",
    action(r) {
      return [...t, ...r]
    },
  }
}
wt()
var ZEe = (0, Iv.deferred)().promise
function Kvt({ onClose: e = true, onExit: t = 50 } = {}) {
  function r() {
    let i = -1,
      s = {
        close: (0, Iv.deferred)(),
        closeTimeout: (0, Iv.deferred)(),
        exit: (0, Iv.deferred)(),
        exitTimeout: (0, Iv.deferred)(),
      },
      o = Promise.race([
        e === false ? ZEe : s.closeTimeout.promise,
        t === false ? ZEe : s.exitTimeout.promise,
      ])
    return (
      n(e, s.close, s.closeTimeout),
      n(t, s.exit, s.exitTimeout),
      {
        close(a) {
          ;(i = a), s.close.done()
        },
        exit(a) {
          ;(i = a), s.exit.done()
        },
        get exitCode() {
          return i
        },
        result: o,
      }
    )
  }
  function n(i, s, o) {
    i !== false &&
      (i === true ? s.promise : s.promise.then(() => s8(i))).then(o.done)
  }
  return {
    type: "spawn.after",
    action(i, s) {
      return Ox(this, arguments, function* (o, { spawned: a, close: l }) {
        var c, u
        let f = r(),
          p = true,
          g = () => void (p = false)
        ;(c = a.stdout) == null || c.on("data", g),
          (u = a.stderr) == null || u.on("data", g),
          a.on("error", g),
          a.on("close", (m) => f.close(m)),
          a.on("exit", (m) => f.exit(m))
        try {
          yield f.result, p && (yield s8(50)), l(f.exitCode)
        } catch (m) {
          l(f.exitCode, m)
        }
      })
    },
  }
}
wt()
var zvt =
    "Invalid value supplied for custom binary, requires a single string or an array containing either one or two strings",
  XEe =
    "Invalid value supplied for custom binary, restricted characters must be removed or supply the unsafe.allowUnsafeCustomBinary option"
function Jvt(e) {
  return !e || !/^([a-z]:)?([a-z0-9/.\\_-]+)$/i.test(e)
}
function e_e(e, t) {
  if (e.length < 1 || e.length > 2) throw new mf(undefined, "binary", zvt)
  if (e.some(Jvt))
    if (t) console.warn(XEe)
    else throw new mf(undefined, "binary", XEe)
  let [n, i] = e
  return { binary: n, prefix: i }
}
function jvt(e, t = ["git"], r = false) {
  let n = e_e(ed(t), r)
  e.on("binary", (i) => {
    n = e_e(ed(i), r)
  }),
    e.append("spawn.binary", () => n.binary),
    e.append("spawn.args", (i) => (n.prefix ? [n.prefix, ...i] : i))
}
lg()
function Zvt(e) {
  return !!(e.exitCode && e.stdErr.length)
}
function Xvt(e) {
  return Buffer.concat([...e.stdOut, ...e.stdErr])
}
function eCt(e = false, t = Zvt, r = Xvt) {
  return (n, i) => ((!e && n) || !t(i) ? n : r(i))
}
function t_e(e) {
  return {
    type: "task.error",
    action(t, r) {
      let n = e(t.error, {
        stdErr: r.stdErr,
        stdOut: r.stdOut,
        exitCode: r.exitCode,
      })
      return Buffer.isBuffer(n)
        ? { error: new Af(undefined, n.toString("utf-8")) }
        : { error: n }
    },
  }
}
wt()
var tCt = class {
  constructor() {
    ;(this.plugins = new Set()), (this.events = new nwe.EventEmitter())
  }
  on(e, t) {
    this.events.on(e, t)
  }
  reconfigure(e, t) {
    this.events.emit(e, t)
  }
  append(e, t) {
    let r = Hr(this.plugins, { type: e, action: t })
    return () => this.plugins.delete(r)
  }
  add(e) {
    let t = []
    return (
      ed(e).forEach((r) => r && this.plugins.add(Hr(t, r))),
      () => {
        t.forEach((r) => this.plugins.delete(r))
      }
    )
  }
  exec(e, t, r) {
    let n = t,
      i = Object.freeze(Object.create(r))
    for (let s of this.plugins) s.type === e && (n = s.action(n, i))
    return n
  }
}
wt()
function rCt(e) {
  let t = "--progress",
    r = ["checkout", "clone", "fetch", "pull", "push"]
  return [
    {
      type: "spawn.args",
      action(s, o) {
        return r.includes(o.method) ? u_e(s, t) : s
      },
    },
    {
      type: "spawn.after",
      action(s, o) {
        var a
        o.commands.includes(t) &&
          ((a = o.spawned.stderr) == null ||
            a.on("data", (l) => {
              let c = /^([\s\S]+?):\s*(\d+)% \((\d+)\/(\d+)\)/.exec(
                l.toString("utf8"),
              )
              c &&
                e({
                  method: o.method,
                  stage: nCt(c[1]),
                  progress: Bn(c[2]),
                  processed: Bn(c[3]),
                  total: Bn(c[4]),
                })
            }))
      },
    },
  ]
}
function nCt(e) {
  return String(e.toLowerCase().split(" ", 1)) || "unknown"
}
wt()
function iCt(e) {
  let t = h_e(e, ["uid", "gid"])
  return {
    type: "spawn.options",
    action(r) {
      return Jl(Jl({}, t), r)
    },
  }
}
function sCt({ block: e, stdErr: t = true, stdOut: r = true }) {
  if (e > 0)
    return {
      type: "spawn.after",
      action(n, i) {
        var s, o
        let a
        function l() {
          a && clearTimeout(a), (a = setTimeout(u, e))
        }
        function c() {
          var f, p
          ;(f = i.spawned.stdout) == null || f.off("data", l),
            (p = i.spawned.stderr) == null || p.off("data", l),
            i.spawned.off("exit", c),
            i.spawned.off("close", c),
            a && clearTimeout(a)
        }
        function u() {
          c(), i.kill(new mf(undefined, "timeout", "block timeout reached"))
        }
        r && ((s = i.spawned.stdout) == null || s.on("data", l)),
          t && ((o = i.spawned.stderr) == null || o.on("data", l)),
          i.spawned.on("exit", c),
          i.spawned.on("close", c),
          l()
      },
    }
}
Gx()
function oCt() {
  return {
    type: "spawn.args",
    action(e) {
      let t = [],
        r
      function n(i) {
        ;(r = r || []).push(...i)
      }
      for (let i = 0; i < e.length; i++) {
        let s = e[i]
        if (d1(s)) {
          n(wEe(s))
          continue
        }
        if (s === "--") {
          n(e.slice(i + 1).flatMap((o) => (d1(o) && wEe(o)) || o))
          break
        }
        t.push(s)
      }
      return r ? [...t, "--", ...r.map(String)] : t
    },
  }
}
wt()
var aCt = Ovt()
function lCt(e, t) {
  var r
  let n = new tCt(),
    i = A_e((e && (typeof e == "string" ? { baseDir: e } : e)) || {}, t)
  if (!C8(i.baseDir))
    throw new qvt(i, "Cannot use simple-git on a directory that does not exist")
  return (
    Array.isArray(i.config) && n.add(Yvt(i.config)),
    n.add($vt(i.unsafe)),
    n.add(oCt()),
    n.add(Kvt(i.completion)),
    i.abort && n.add(Vvt(i.abort)),
    i.progress && n.add(rCt(i.progress)),
    i.timeout && n.add(sCt(i.timeout)),
    i.spawnOptions && n.add(iCt(i.spawnOptions)),
    n.add(t_e(eCt(true))),
    i.errors && n.add(t_e(i.errors)),
    jvt(
      n,
      i.binary,
      (r = i.unsafe) == null ? undefined : r.allowUnsafeCustomBinary,
    ),
    new aCt(i, n)
  )
}
Rv()
var iwe = lCt
var swe = {
    added_file_stats: {
      changed_file_count: 0,
      per_file_change_stats_head: [],
      per_file_change_stats_tail: [],
    },
    broken_file_stats: {
      changed_file_count: 0,
      per_file_change_stats_head: [],
      per_file_change_stats_tail: [],
    },
    copied_file_stats: {
      changed_file_count: 0,
      per_file_change_stats_head: [],
      per_file_change_stats_tail: [],
    },
    deleted_file_stats: {
      changed_file_count: 0,
      per_file_change_stats_head: [],
      per_file_change_stats_tail: [],
    },
    modified_file_stats: {
      changed_file_count: 0,
      per_file_change_stats_head: [],
      per_file_change_stats_tail: [],
    },
    renamed_file_stats: {
      changed_file_count: 0,
      per_file_change_stats_head: [],
      per_file_change_stats_tail: [],
    },
    unmerged_file_stats: {
      changed_file_count: 0,
      per_file_change_stats_head: [],
      per_file_change_stats_tail: [],
    },
    unknown_file_stats: {
      changed_file_count: 0,
      per_file_change_stats_head: [],
      per_file_change_stats_tail: [],
    },
  },
  Dv = class {
    git
    constructor() {
      this.git = undefined
    }
    _updateBaseDir(t) {
      try {
        this.git = iwe({
          baseDir: t,
          binary: "git",
          maxConcurrentProcesses: 6,
          trimmed: false,
        })
      } catch {
        this.git = undefined
      }
    }
    countTokens(t) {
      return Math.ceil(t.length / 3)
    }
    async getChangedFileStats(t) {
      let r = await this.git.status(),
        n = ["created", "deleted", "modified", "renamed"],
        i = swe,
        s = new Set(r.staged)
      for (let o of n) {
        let a = []
        if (
          (o === "renamed" ? (a = r.renamed.map((l) => l.to)) : (a = r[o]),
          t.onlyUseStagedChanges && (a = a.filter((l) => s.has(l))),
          a.length > 0)
        ) {
          let l = o
          o === "created" && (l = "added")
          let c = `${l}_file_stats`
          i[c].changed_file_count = a.length
          let u = await Promise.all(
              a.map(async (g) => {
                let { insertions: m, deletions: y } =
                  await this.getInsertionDeletionStats(t.onlyUseStagedChanges, [
                    g,
                  ])
                return {
                  file_path: g,
                  insertion_count: m,
                  deletion_count: y,
                  old_file_path:
                    (o === "renamed" &&
                      r.renamed.find((v) => v.to === g)?.from) ||
                    g,
                }
              }),
            ),
            f = u.slice(0, 5),
            p = u.slice(-5)
          ;(i[c].per_file_change_stats_head = f),
            (i[c].per_file_change_stats_tail = p.filter(
              (g) => !f.find((m) => m.file_path === g.file_path),
            ))
        }
      }
      return i
    }
    async getInsertionDeletionStats(t, r) {
      let n = ["--staged", "--shortstat"].concat(r),
        i = await this.git.diff(n)
      if (!t) {
        let l = ["--shortstat"].concat(r)
        i += await this.git.diff(l)
      }
      let s = i.split(",").map((l) => l.trim()),
        o = parseInt(
          s.find((l) => l.includes("insertion"))?.split(" ")[0] || "0",
        ),
        a = parseInt(
          s.find((l) => l.includes("deletion"))?.split(" ")[0] || "0",
        )
      return { insertions: o, deletions: a }
    }
    async getTruncatedDiffs(t, r) {
      let { insertions: n, deletions: i } =
        await this.getInsertionDeletionStats(t.onlyUseStagedChanges, [])
      if (n + i <= t.diffNoopLineLimit) {
        let o = await this.git.diff(["--staged", "--name-only"])
        t.onlyUseStagedChanges || (o += await this.git.diff(["--name-only"]))
        let a = o
            .split(
              `
`,
            )
            .filter(Boolean),
          l = await Promise.all(
            a.map(async (f) => {
              let p = await this.git.diff(["--staged", f])
              return (
                t.onlyUseStagedChanges || (p += await this.git.diff([f])),
                { fileName: f, diff: p, tokens: this.countTokens(p) }
              )
            }),
          )
        l.sort((f, p) => f.tokens - p.tokens)
        let c = "",
          u = r
        for (let f of l)
          if (u + f.tokens <= t.diffBudget)
            (c +=
              f.diff +
              `
`),
              (u += f.tokens)
          else break
        return c.trim()
      } else {
        let o = await this.git.diff(["--staged"])
        return (
          t.onlyUseStagedChanges || (o += await this.git.diff([])),
          o
            .split(
              `
`,
            )
            .slice(0, t.diffNoopLineLimit)
            .join(
              `
`,
            )
            .slice(0, t.diffBudget - r)
        )
      }
    }
    async getCommitMessages(t) {
      return (await this.git.log({ maxCount: t })).all.map((n) => n.message)
    }
    async getCurrentAuthor() {
      let r = (await this.git.listConfig()).all["user.email"]
      return Array.isArray(r) ? r[0] || undefined : r || undefined
    }
    getExampleCommitMessages(t, r, n, i) {
      let s = [],
        o = 0
      for (let a of t.slice(r.length)) {
        if (s.length >= i - r.length) break
        let l = this.countTokens(a)
        if (o + l <= n) s.push(a), (o += l)
        else break
      }
      return s
    }
    async getRelevantCommitMessages(t, r) {
      return this.git.log({ maxCount: 3 }).then((n) =>
        n.all
          .filter((i) => i.author_email === t.trim())
          .map((i) => i.message)
          .reduce((i, s) => {
            let o = this.countTokens(s)
            return (
              this.countTokens(
                i.join(`
`),
              ) +
                o <=
                r && i.push(s),
              i
            )
          }, []),
      )
    }
    async getCommitMessagePromptData(t, r) {
      if ((this._updateBaseDir(t), !this.git))
        return {
          changedFileStats: swe,
          diff: "",
          generatedCommitMessageSubrequest: {
            relevant_commit_messages: [],
            example_commit_messages: [],
          },
        }
      let n = await this.getChangedFileStats(r),
        i = this.countTokens(JSON.stringify(n)),
        s = await this.getTruncatedDiffs(r, i),
        o = await this.getCommitMessages(32),
        a = await this.getCurrentAuthor(),
        l = [],
        c = []
      if (a) {
        l = await this.getRelevantCommitMessages(a, r.relevantMessageSubbudget)
        let u = this.countTokens(
            l.join(`
`),
          ),
          f = r.messageBudget - u
        c = this.getExampleCommitMessages(o, l, f, r.maxExampleCommitMessages)
      }
      return {
        changedFileStats: n,
        diff: s,
        generatedCommitMessageSubrequest: {
          relevant_commit_messages: l,
          example_commit_messages: c,
        },
      }
    }
  }
function owe(e, t = false) {
  let r = 2166136261,
    n = t ? e.length - e.trimLeft().length : 0
  for (let i = n; i < e.length; i++) (r ^= e.charCodeAt(i)), (r *= 16777619)
  return r >>> 0
}
function cCt(e, t) {
  let r = e.length,
    n = t.length,
    i = Array(n + 1)
      .fill(null)
      .map(() => ({ lcsLength: 0, minSubstringLength: 1 / 0 })),
    s = Array(n + 1)
      .fill(null)
      .map(() => ({ lcsLength: 0, minSubstringLength: 1 / 0 }))
  i[0].minSubstringLength = 0
  let o = 0,
    a = 1 / 0,
    l = -1
  for (let c = 1; c <= r; c++) {
    s[0] = { lcsLength: 0, minSubstringLength: 0 }
    for (let u = 1; u <= n; u++) {
      if (e[c - 1] === t[u - 1]) {
        let f = i[u - 1].lcsLength + 1,
          p = i[u - 1].minSubstringLength + 1
        s[u] = { lcsLength: f, minSubstringLength: p }
      } else {
        let f = i[u],
          p = s[u - 1]
        if (f.lcsLength > p.lcsLength) {
          let g = f.lcsLength,
            m = f.minSubstringLength + 1
          s[u] = { lcsLength: g, minSubstringLength: m }
        } else if (f.lcsLength < p.lcsLength) {
          let g = p.lcsLength,
            m = p.minSubstringLength
          s[u] = { lcsLength: g, minSubstringLength: m }
        } else {
          let g = f.lcsLength,
            m = Math.min(f.minSubstringLength + 1, p.minSubstringLength)
          s[u] = { lcsLength: g, minSubstringLength: m }
        }
      }
      if (u === n) {
        let f = s[u]
        ;(f.lcsLength > o || (f.lcsLength === o && f.minSubstringLength < a)) &&
          ((o = f.lcsLength), (a = f.minSubstringLength), (l = c))
      }
    }
    ;[i, s] = [s, i]
  }
  return { maxLCSLength: o, minSubstringLength: a, endIndex: l }
}
function awe(e, t) {
  let r = e.split(`
`),
    n = t.trim().split(`
`)
  function i(p) {
    let g = r.map((y) => owe(y, p)),
      m = n.map((y) => owe(y, p))
    return cCt(g, m)
  }
  let s = i(false),
    o = i(true),
    {
      maxLCSLength: a,
      minSubstringLength: l,
      endIndex: c,
    } = s.maxLCSLength >= o.maxLCSLength ? s : o
  if (a === 0) return null
  let u = c - l,
    f = c - 1
  return { start: u, end: f }
}
var lwe = require("path"),
  Cr = q(require("vscode"))
async function cg(e, t = undefined) {
  let r = (0, lwe.resolve)(e.repoRoot, e.pathName)
  if (e.openLocalUri && Cr.env.remoteName !== undefined) {
    let s = await Cr.workspace.openTextDocument(
      Cr.Uri.parse(`vscode-local:${r}`),
    )
    await Cr.window.showTextDocument(s)
    return
  }
  e.differentTab
    ? t === undefined || Cr.window.tabGroups.all.length === 1
      ? await Cr.commands.executeCommand(
          "vscode.openWith",
          Cr.Uri.file(r),
          "default",
          Cr.ViewColumn.Beside,
        )
      : await Cr.commands.executeCommand(
          "vscode.openWith",
          Cr.Uri.file(r),
          "default",
          t === Cr.ViewColumn.One ? t + 1 : t - 1,
        )
    : await Cr.commands.executeCommand("vscode.open", Cr.Uri.file(r))
  let n
  if (
    !(
      !Cr.window.activeTextEditor ||
      Cr.window.activeTextEditor.document.uri.fsPath !== r
    )
  ) {
    if (e.fullRange) {
      let i = e.fullRange
      n = Cr.window.activeTextEditor.document.validateRange(
        new Cr.Range(
          i.startLineNumber,
          i.startColumn,
          i.endLineNumber,
          i.endColumn,
        ),
      )
    } else if (e.range) {
      let i = e.range
      n = Cr.window.activeTextEditor.document.validateRange(
        new Cr.Range(i.start - 1, 0, i.stop - 1, 999),
      )
    } else if (e.snippet) {
      let s = (await Cr.workspace.openTextDocument(r)).getText(),
        o = awe(s, e.snippet)
      if (o === null) {
        let a = Cr.window.activeTextEditor.selection.active
        n = Cr.window.activeTextEditor.document.validateRange(
          new Cr.Range(a, a),
        )
      } else
        n = Cr.window.activeTextEditor.document.validateRange(
          new Cr.Range(o.start, 0, o.end, 999),
        )
    } else return
    Cr.window.activeTextEditor?.revealRange(n),
      (Cr.window.activeTextEditor.selection = new Cr.Selection(n.end, n.start))
  }
}
var uwe = q(require("path")),
  $c = q(require("vscode"))
function uCt(e) {
  return e.endsWith(`
`)
    ? e.slice(0, -1)
    : e
}
function cwe(e, t) {
  let r = e.split(`
`)
  for (let n of [...t].sort(
    ({ result: { charEnd: i } }, { result: { charEnd: s } }) => s - i,
  ))
    r.splice(
      n.lineRange.start,
      n.lineRange.stop - n.lineRange.start,
      uCt(n.result.suggestedCode),
    )
  return r.join(`
`)
}
var km = class e extends DisposableContainer {
  constructor(r, n, i, s, o, a, l) {
    super()
    this._extensionUri = r
    this._conversationId = n
    this._initialIterationId = i
    this._initialStage = s
    this._chatApp = o
    this._resolveFileService = a
    this._workTimer = l
    ;(this._panel = $c.window.createWebviewPanel(
      e.viewType,
      "Augment",
      $c.ViewColumn.One,
      { retainContextWhenHidden: true, enableScripts: true },
    )),
      (this._detailsPanelAsyncMsgHandler = createAsyncMessageHandler(
        this._panel.webview,
        this._workTimer,
      )),
      this._detailsPanelAsyncMsgHandler.registerHandler(
        "autofix-panel-details-init-request",
        this.handleAutofixInitMessage,
      ),
      this._detailsPanelAsyncMsgHandler.registerHandler(
        "autofix-panel-apply-and-retest-request",
        this.handleAutofixApplyAndRetestRequest.bind(this),
      ),
      this._resolveFileService.register(this._detailsPanelAsyncMsgHandler),
      (this._panel.iconPath = {
        light: $c.Uri.joinPath(
          this._extensionUri,
          "media",
          "panel-icon-light.svg",
        ),
        dark: $c.Uri.joinPath(
          this._extensionUri,
          "media",
          "panel-icon-dark.svg",
        ),
      }),
      this.addDisposables(
        this._panel,
        new $c.Disposable(() => {
          e.currentPanel = undefined
        }),
      ),
      this._panel.onDidDispose(() => {
        this.dispose(), (e.currentPanel = undefined)
      }),
      this._setHTML()
  }
  static viewType = "augmentAutofixPanel"
  _logger = z("AutofixWebviewPanel")
  static currentPanel
  _panel
  _detailsPanelAsyncMsgHandler
  get logger() {
    return this._logger
  }
  async _setHTML() {
    let r = this._panel.webview,
      n = $c.Uri.joinPath(this._extensionUri, "common-webviews")
    r.options = { enableScripts: true, localResourceRoots: [n] }
    let i = r.asWebviewUri($c.Uri.joinPath(n, "/")),
      s = bF(_F(r), EF(), xF(), wF(), SF()),
      o = await readTextFile(uwe.default.join(n.fsPath, "autofix.html"))
    ;(o = o.replace(
      /<head>/i,
      `<head>
            <base href="${i.toString()}" />
            <meta http-equiv="Content-Security-Policy" content="${s}">
        `,
    )),
      (r.html = o)
  }
  static launchAutofixPanel(r, n, i, s, o, a, l) {
    if (e.currentPanel)
      if (e.currentPanel._conversationId === n) {
        e.currentPanel.openSpecificStage(i, s), e.currentPanel._panel.reveal()
        return
      } else e.currentPanel.dispose()
    e.currentPanel = new e(r, n, i, s, o, a, l)
  }
  handleAutofixStateUpdate = async (r) => {
    await this._panel.webview.postMessage({
      type: "autofix-panel-state-update",
      data: r.data,
    })
  }
  handleCommandPartialOutput = async (r) => {
    await this._panel.webview.postMessage(r)
  }
  handleAutofixInitMessage = async (r) => (
    await this._chatApp.sendAutofixUpdateRequestMessage(),
    {
      type: "autofix-panel-open-specific-stage",
      data: {
        iterationId: this._initialIterationId,
        stage: this._initialStage,
      },
    }
  )
  handleAutofixApplyAndRetestRequest = async (r) => (
    await this._applyAllAutofixChanges(r.data.selectedSolutions),
    await this._chatApp.sendAutofixSuggestionsAppliedMessage(
      r.data.selectedSolutions,
    ),
    { type: "empty" }
  )
  async openSpecificStage(r, n) {
    await this._panel.webview.postMessage({
      type: "autofix-panel-open-specific-stage",
      data: { iterationId: r, stage: n },
    })
  }
  async _applyAutofixChanges(r, n) {
    let i = await readTextFile(r),
      s = cwe(i, n)
    await oa(r, s)
  }
  async _applyAllAutofixChanges(r) {
    let n = new Map()
    for (let i of r) {
      let s = getFullPath(i.qualifiedPathName)
      n.has(s) ? n.get(s).push(i) : n.set(s, [i])
    }
    for (let [i, s] of n.entries()) await this._applyAutofixChanges(i, s)
  }
}
var Yc = q(require("vscode"))
function dCt(e) {
  if (e.startsWith("A") || e.startsWith("=")) return true
  if (e.startsWith("B")) return false
  throw new Error(`Incorrect rating: ${e}`)
}
function V8(e) {
  let t
  if (e.startsWith("A")) t = -1 * parseInt(e.charAt(1), 10)
  else if (e.startsWith("B")) t = parseInt(e.charAt(1), 10)
  else if (e.startsWith("=")) t = 0
  else throw new Error(`Incorrect rating: ${e}`)
  return t
}
var Tv = class e extends PanelWebview {
  constructor(r, n, i, s, o, a, l, c) {
    super("preference.html", r.webview)
    this._extensionUri = n
    this._fuzzyFsSearcher = i
    this.inputData = o
    this._externalSources = l
    this._userSpecifiedExternalSources = c
    ;(this._asyncMsgHandler = createAsyncMessageHandler(r.webview, a)),
      this.addDisposable(this._asyncMsgHandler),
      this._asyncMsgHandler.registerHandler(
        "find-file-request",
        this._fuzzyFsSearcher.findFiles,
      ),
      this._asyncMsgHandler.registerHandler("chat-loaded", (u) =>
        Promise.resolve({ type: "chat-initialize", data: {} }),
      ),
      (this._panel = r),
      (this._inputData = o)
  }
  static currentPanel
  _panel
  static _logger = z("PreferenceWebviewPanel")
  _inputData
  _asyncMsgHandler
  _resolvePreference
  handleMessage = (r) => {
    if (r.type === "preference-result-message") {
      let n = r.data
      this._resolvePreference(n), this._panel.dispose()
    }
    r.type === "preference-notify" && Yc.window.showInformationMessage(r.data),
      r.type === "preference-panel-loaded" &&
        (e._logger.info("Preference panel loaded, sending input data"),
        this._panel.webview.postMessage({
          type: "preference-init",
          data: this._inputData,
        })),
      r.type === "open-file" && cg(r.data)
  }
  static async launchStandalonePreferencePanel(r, n, i, s, o = [], a = [], l) {
    e.currentPanel && (e.currentPanel.dispose(), (e.currentPanel = undefined))
    let u =
        (Yc.window.activeTextEditor
          ? Yc.window.activeTextEditor.viewColumn
          : undefined) || Yc.ViewColumn.One,
      f = { type: "Chat", data: n, enableRetrievalDataCollection: i },
      p = Yc.window.createWebviewPanel("preference", "Augment Preference", u, {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [Yc.Uri.joinPath(r, "/common-webviews")],
      }),
      g = (e.currentPanel = new e(p, r, s, u, f, l, o, a))
    return (
      await g.loadHTML(r),
      p.onDidDispose(() => {
        g._resolvePreference && g._resolvePreference(null), g.dispose()
      }),
      g.addDisposables(
        p,
        new Yc.Disposable(() => {
          e.currentPanel = undefined
        }),
      ),
      p.webview.onDidReceiveMessage(g.handleMessage),
      e.currentPanel
    )
  }
  async postStreamChunk(r, n) {
    await this._panel.webview.postMessage({ ...r, stream: n })
  }
  async postStreamDone() {
    await this._panel.webview.postMessage({ type: "chat-stream-done" })
  }
  async getResult(r, n, i) {
    let s = await new Promise((o) => {
      this._resolvePreference = o
    })
    return s
      ? (await this.sendResultToBackend(r, n, i, s), dCt(s.overallRating))
      : true
  }
  async sendResultToBackend(r, n, i, s) {
    let o = `${s.textFeedback}
MODEL_IDS_START_LABEL
${i?.a}
${i?.b}
MODEL_IDS_END_LABEL
IMPLICIT_EXTERNAL_SOURCES_START_LABEL
${this._externalSources?.map((a) => a.name).join(", ") ?? ""}
IMPLICIT_EXTERNAL_SOURCES_END_LABEL
USER_SPECIFIED_EXTERNAL_SOURCES_START_LABEL
${this._userSpecifiedExternalSources?.join(", ") ?? ""}
USER_SPECIFIED_EXTERNAL_SOURCES_END_LABEL
`
    await retryOperation(async () => {
      try {
        return await n.recordPreferenceSample({
          request_ids: [r.a, r.b],
          scores: {
            overallRating: V8(s.overallRating),
            formattingRating: V8(s.formattingRating),
            instructionFollowingRating: V8(s.instructionFollowingRating),
            isHighQuality: s.isHighQuality ? 1 : 0,
          },
          feedback: o,
        })
      } catch (a) {
        throw (e._logger.error(`Error reporting preference sample: ${a}`), a)
      }
    }, e._logger)
  }
}
var w1 = 2e5
var ChatApp = class extends DisposableContainer {
  constructor(
    chatModel,
    chatModelConfigs,
    apiServer,
    workspaceManager,
    keybindingWatcher,
    config,
    extensionUri,
    featureFlagManager,
    clientMetricsReporter,
    actionsModel,
    syncingEnabledTracker,
    onboardingWorkspaceModel,
    syncingStatus,
    onboardingSessionEventReporter,
    fuzzyFsSearcher,
    fuzzySymbolSearcher,
    toolsModel,
    resolveFileService,
    checkpointManager,
    guidelinesWatcher,
    assetManager,
    globalState,
    workTimer,
  ) {
    super()
    this._chatModel = chatModel
    this._chatModelConfigs = chatModelConfigs
    this._apiServer = apiServer
    this._workspaceManager = workspaceManager
    this._keybindingWatcher = keybindingWatcher
    this._config = config
    this._extensionUri = extensionUri
    this._featureFlagManager = featureFlagManager
    this._clientMetricsReporter = clientMetricsReporter
    this._actionsModel = actionsModel
    this._syncingEnabledTracker = syncingEnabledTracker
    this._onboardingWorkspaceModel = onboardingWorkspaceModel
    this._syncingStatus = syncingStatus
    this._onboardingSessionEventReporter = onboardingSessionEventReporter
    this._fuzzyFsSearcher = fuzzyFsSearcher
    this._fuzzySymbolSearcher = fuzzySymbolSearcher
    this._toolsModel = toolsModel
    this._resolveFileService = resolveFileService
    this._checkpointManager = checkpointManager
    this._guidelinesWatcher = guidelinesWatcher
    this._assetManager = assetManager
    this._globalState = globalState
    this._workTimer = workTimer
    ;(this._commitMessagePromptPreparer = new Dv()),
      (this._remoteAgentsMessenger = new xv(
        this._apiServer,
        this._extensionUri,
        this._workTimer,
        this._globalState,
      )),
      (this._gitReferenceMessenger = new QF(this._apiServer, this._config)),
      (this._remoteAgentDiffMessenger = new Cv(this._apiServer)),
      (this._sharedStore = _v.getStore(FF)),
      (this._smartPasteCache = new zF(async (pasteData) => {
        let requestId = this._apiServer.createRequestId()
        return Promise.resolve({
          generator: this._smartPasteWithChatInstruction(pasteData, requestId),
          requestId: requestId,
        })
      })),
      this.addDisposables(
        this._actionsModel.onDerivedStatesSatisfied(
          this.handleDerivedStateChange.bind(this),
        ),
        this._syncingEnabledTracker.onDidChangeSyncingEnabled(
          this.sendSyncEnabledStatus.bind(this),
        ),
        this._guidelinesWatcher.onDidChange(
          this.sendCurrentGuidelinesState.bind(this),
        ),
        this._smartPasteCache,
        this._checkpointManager.onAgentEditListHasUpdates(() =>
          this._notifyAgentEditListHasUpdates(),
        ),
        this._toolsModel.onRestartHosts(() => {
          this.setupMemoryUpdateListener()
        }),
      ),
      this.setupMemoryUpdateListener()
  }
  _logger = z("ChatApp")
  _asyncMsgHandler
  _lastKnownSourceFolders = []
  _webview
  _smartPasteCache
  _commitMessagePromptPreparer
  _memoryUpdateManagerDisposable
  _remoteAgentsMessenger
  _gitReferenceMessenger
  _remoteAgentDiffMessenger
  _sharedStore
  appType() {
    return "chat"
  }
  title() {
    return ""
  }
  register(webview) {
    ;(this._webview = webview),
      (this._asyncMsgHandler = createAsyncMessageHandler(this._webview, this._workTimer)),
      this.addDisposable(this._asyncMsgHandler)
    let appName = "chat-webview-app"
    this._asyncMsgHandler &&
      (this._sharedStore.subscribe(this._asyncMsgHandler, appName),
      this.addDisposable(
        new kt.Disposable(() => {
          this._asyncMsgHandler && this._sharedStore.unsubscribe(appName)
        }),
      )),
      this._asyncMsgHandler.registerHandler(
        "find-file-request",
        this._fuzzyFsSearcher.findFiles,
      ),
      this._asyncMsgHandler.registerHandler(
        "find-folder-request",
        this._fuzzyFsSearcher.findFolders,
      ),
      this._asyncMsgHandler.registerHandler(
        "find-recently-opened-files",
        this._fuzzyFsSearcher.findRecentFiles,
      ),
      this._asyncMsgHandler.registerHandler(
        "resolve-file-request",
        async (i) => ({
          type: "resolve-file-response",
          data: await this.resolveTargetPath(
            i.data.relPath,
            i.data.searchScope,
            i.data.exactMatch,
          ),
        }),
      ),
      this._asyncMsgHandler.registerStreamHandler(
        "chat-user-message",
        this.onUserSendMessage.bind(this),
      ),
      this._asyncMsgHandler.registerStreamHandler(
        "generate-commit-message",
        this.generateCommitMessage.bind(this),
      ),
      this._asyncMsgHandler.registerStreamHandler(
        "chat-get-stream-request",
        this._chatModel.getChatStream.bind(this._chatModel),
      ),
      this._asyncMsgHandler.registerHandler("chat-user-cancel", (message) =>
        this.onUserCancel(message),
      ),
      this._asyncMsgHandler.registerHandler(
        "chat-rating",
        this._chatModel.sendFeedback,
      ),
      this._asyncMsgHandler.registerHandler(
        "save-chat",
        this._chatModel.saveConversation,
      ),
      this._asyncMsgHandler.registerHandler("chat-launch-autofix-panel", (message) =>
        this.onLaunchAutofixPanel(message),
      ),
      this._asyncMsgHandler.registerHandler("chat-autofix-state-update", (message) =>
        this.handleAutofixStateUpdate(message),
      ),
      this._asyncMsgHandler.registerHandler("open-confirmation-modal", (message) =>
        this.onOpenConfirmationModal(message),
      ),
      this._asyncMsgHandler.registerHandler(
        "find-external-sources-request",
        this.onExternalSourceSearch,
      ),
      this._asyncMsgHandler.registerHandler(
        "resolve-workspace-file-chunk",
        this._chatModel.resolveWorkspaceFileChunk,
      ),
      this._asyncMsgHandler.registerHandler(
        "find-symbol-request",
        this._fuzzySymbolSearcher.findSymbols,
      ),
      this._asyncMsgHandler.registerHandler(
        "chat-autofix-execute-command-request",
        this.onExecuteCommand.bind(this),
      ),
      this._asyncMsgHandler.registerHandler(
        "chat-autofix-plan-request",
        this.onAutofixPlan.bind(this),
      ),
      this._asyncMsgHandler.registerHandler(
        "find-symbol-regex-request",
        this._fuzzySymbolSearcher.findSymbolsRegex,
      ),
      this._asyncMsgHandler.registerHandler(
        "get-diagnostics-request",
        this._chatModel.getDiagnostics,
      ),
      this._asyncMsgHandler.registerHandler(
        "report-webview-client-metric",
        (message) => (
          this._clientMetricsReporter.reportWebviewClientMetric(message.data),
          Promise.resolve({ type: "empty" })
        ),
      ),
      this._asyncMsgHandler.registerHandler(
        "get-workspace-info-request",
        async () => {
          await Promise.resolve(null)
          try {
            let trackedFileCount = this._workspaceManager
                .listSourceFolders()
                .filter((folder) => folder.syncingEnabled)
                .reduce(
                  (count, folder) =>
                    "trackedFileCount" in folder ? count + folder.trackedFileCount : count,
                  0,
                ),
              trackedFileCountArray = trackedFileCount > 0 ? [trackedFileCount] : []
            return {
              type: "get-workspace-info-response",
              data: { trackedFileCount: trackedFileCountArray.length > 0 ? trackedFileCountArray : undefined },
            }
          } catch (error) {
            return (
              this._logger.error("Error getting workspace info:", error),
              { type: "get-workspace-info-response", data: {} }
            )
          }
        },
      ),
      this._asyncMsgHandler.registerHandler(
        "show-augment-panel",
        this.showAugmentPanel,
      ),
      this._asyncMsgHandler.registerHandler("call-tool", this.callTool, false),
      this._asyncMsgHandler.registerHandler(
        "cancel-tool-run",
        this.cancelToolRun,
      ),
      this._asyncMsgHandler.registerHandler("check-safe", this.toolCheckSafe),
      this._asyncMsgHandler.registerHandler(
        "checkToolExists",
        this.checkToolExists,
      ),
      this._asyncMsgHandler.registerHandler(
        "get-ide-state-node-request",
        this._getChatRequestIdeState,
      ),
      this._asyncMsgHandler.registerHandler(
        "chat-save-image-request",
        this._saveImage,
      ),
      this._asyncMsgHandler.registerHandler(
        "chat-load-image-request",
        this._loadImage,
      ),
      this._asyncMsgHandler.registerHandler(
        "chat-delete-image-request",
        this._deleteImage,
      ),
      this._asyncMsgHandler.registerHandler(
        "chat-mode-changed",
        (message) => (
          this._toolsModel.setMode(message.data.mode),
          Promise.resolve({ type: "empty" })
        ),
      ),
      this._asyncMsgHandler.registerHandler(
        "chat-get-agent-onboarding-prompt-request",
        async () => {
          let platformInfo = h0(process.platform),
            onboardingPromptGenerator = new g0(Fr.agent, process.platform, platformInfo),
            onboardingInstructionsProvider = new xM(onboardingPromptGenerator, this._workspaceManager)
          return (
            this._onboardingSessionEventReporter.reportEvent(
              "saw-agent-onboarding",
            ),
            Promise.resolve({
              type: "chat-get-agent-onboarding-prompt-response",
              data: { prompt: await onboardingInstructionsProvider.getOnboardingInstructions() },
            })
          )
        },
      ),
      this._asyncMsgHandler.registerHandler(
        "check-agent-auto-mode-approval",
        () => {
          let isApproved = this._globalState.get("agentAutoModeApproved")
          return Promise.resolve({
            type: "check-agent-auto-mode-approval-response",
            data: isApproved ?? false,
          })
        },
      ),
      this._asyncMsgHandler.registerHandler(
        "set-agent-auto-mode-approved",
        async (message) => (
          await this._globalState.update("agentAutoModeApproved", message.data),
          { type: "empty" }
        ),
      ),
      this._asyncMsgHandler.registerHandler("chat-loaded", (message) => {
        this.sendSourceFolders(),
          this.sendSyncStatus(),
          this.sendSyncEnabledStatus(),
          this.sendCurrentGuidelinesState(),
          this._onboardingWorkspaceModel.shouldShowSummary &&
            this.sendShowSummary(),
          this._actionsModel.broadcastDerivedStates()
        let activeEditor = kt.window.activeTextEditor
        activeEditor?.document.uri
          ? (this.sendCurrentlyOpenFiles([activeEditor.document.uri]),
            this.sendFileSelections(activeEditor))
          : this.sendCurrentlyOpenFiles([]),
          this._notifyAgentEditListHasUpdates()
        let memoriesFilePath = this._toolsModel.memoriesAbsPath
          ? { rootPath: "", relPath: this._toolsModel.memoriesAbsPath }
          : undefined
        return Promise.resolve({
          type: "chat-initialize",
          data: {
            enablePreferenceCollection:
              this._config.config.preferenceCollection.enable,
            enableRetrievalDataCollection:
              this._config.config.preferenceCollection
                .enableRetrievalDataCollection,
            enableDebugFeatures: this._config.config.enableDebugFeatures,
            useRichTextHistory: this._config.config.chat.useRichTextHistory,
            modelDisplayNameToId: this.getMergedAdditionalChatModels(),
            fullFeatured: true,
            enableExternalSourcesInChat: isMinVersionMet(
              this._featureFlagManager.currentFlags
                .vscodeExternalSourcesInChatMinVersion ?? "",
            ),
            smallSyncThreshold:
              this._featureFlagManager.currentFlags.smallSyncThreshold,
            bigSyncThreshold:
              this._featureFlagManager.currentFlags.bigSyncThreshold,
            enableSmartPaste: isMinVersionMet(
              this._featureFlagManager.currentFlags
                .enableSmartPasteMinVersion ?? "",
            ),
            enableDirectApply: isMinVersionMet(
              this._featureFlagManager.currentFlags
                .vscodeDirectApplyMinVersion ?? "",
            ),
            summaryTitles:
              this._featureFlagManager.currentFlags.enableSummaryTitles,
            suggestedEditsAvailable: isMinVersionMet(
              this._featureFlagManager.currentFlags.vscodeNextEditMinVersion ??
                "",
            ),
            enableShareService: isMinVersionMet(
              this._featureFlagManager.currentFlags.vscodeShareMinVersion ?? "",
            ),
            maxTrackableFileCount:
              this._featureFlagManager.currentFlags.maxTrackableFileCount,
            enableDesignSystemRichTextEditor: isMinVersionMet(
              this._featureFlagManager.currentFlags
                .vscodeDesignSystemRichTextEditorMinVersion ?? "",
            ),
            enableSources: isMinVersionMet(
              this._featureFlagManager.currentFlags.vscodeSourcesMinVersion ??
                "",
            ),
            enableChatMermaidDiagrams:
              this._featureFlagManager.currentFlags.enableChatMermaidDiagrams,
            smartPastePrecomputeMode:
              this._featureFlagManager.currentFlags.smartPastePrecomputeMode,
            useNewThreadsMenu: isMinVersionMet(
              this._featureFlagManager.currentFlags
                .vscodeNewThreadsMenuMinVersion ?? "",
            ),
            enableEditableHistory: isMinVersionMet(
              this._featureFlagManager.currentFlags
                .vscodeEditableHistoryMinVersion ?? "",
            ),
            enableChatMermaidDiagramsMinVersion: isMinVersionMet(
              this._featureFlagManager.currentFlags
                .vscodeEnableChatMermaidDiagramsMinVersion ?? "",
            ),
            enableChatMultimodal: isMinVersionMet(
              this._featureFlagManager.currentFlags
                .vscodeChatMultimodalMinVersion ?? "",
            ),
            enableAgentMode: isMinVersionMet(
              UM() === 0
                ? (this._featureFlagManager.currentFlags
                    .vscodeAgentModeMinVersion ?? "")
                : (this._featureFlagManager.currentFlags
                    .vscodeAgentModeMinStableVersion ?? ""),
            ),
            enableRichCheckpointInfo: isMinVersionMet(
              this._featureFlagManager.currentFlags
                .vscodeRichCheckpointInfoMinVersion ?? "",
            ),
            agentMemoriesFilePathName: memoriesFilePath,
            workspaceUnpopulated: this._actionsModel.isDerivedStateSatisfied(
              "WorkspaceNotPopulated",
            ),
            truncateChatHistory: false,
            enableVirtualizedMessageList: isMinVersionMet(
              this._featureFlagManager.currentFlags
                .vscodeVirtualizedMessageListMinVersion ?? "",
            ),
            customPersonalityPrompts: {
              agent:
                this._config.config.advanced.personalityPrompts?.agent ?? "",
              prototyper:
                this._config.config.advanced.personalityPrompts?.prototyper ??
                "",
              brainstorm:
                this._config.config.advanced.personalityPrompts?.brainstorm ??
                "",
              reviewer:
                this._config.config.advanced.personalityPrompts?.reviewer ?? "",
            },
            enablePersonalities: isMinVersionMet(
              this._featureFlagManager.currentFlags
                .vscodePersonalitiesMinVersion ?? "",
            ),
            enableBackgroundAgents: isMinVersionMet(
              this._featureFlagManager.currentFlags
                .vscodeBackgroundAgentsMinVersion ?? "",
            ),
            memoryClassificationOnFirstToken:
              this._featureFlagManager.currentFlags
                .memoryClassificationOnFirstToken ?? false,
            enableGenerateCommitMessage: isMinVersionMet(
              this._featureFlagManager.currentFlags
                .vscodeGenerateCommitMessageMinVersion ?? "",
            ),
          },
        })
      }),
      this._asyncMsgHandler.registerSidecarHandler((message, callback) => {
        VK(message, callback)
      }),
      this._resolveFileService.register(this._asyncMsgHandler),
      this.addDisposables(
        kt.window.onDidChangeTextEditorSelection((event) => {
          !event ||
            event.textEditor.document.uri.scheme === "output" ||
            (this.sendSourceFolders(), this.sendFileSelections(event.textEditor))
        }),
        this._onboardingWorkspaceModel.onShouldShowSummary(
          this.sendShowSummary,
        ),
        this._webview.onDidReceiveMessage(this.onDidReceiveMessage),
        this._workspaceManager.onDidChangeSourceFolders(this.sendSourceFolders),
        kt.window.onDidChangeActiveTextEditor((editor) => {
          this.sendSourceFolders(),
            editor
              ? this.sendCurrentlyOpenFiles([editor.document.uri])
              : (this.sendCurrentlyOpenFiles([]),
                this.sendFileSelections(undefined))
        }),
        this._syncingStatus.onDidChangeSyncingStatus(this.sendSyncStatus),
        onOrientationStateChanged((state) => {
          this._webview?.postMessage({
            type: "orientation-status-update",
            data: state,
          })
        }),
      ),
      this._remoteAgentsMessenger.register(
        this._asyncMsgHandler,
        this._webview,
      ),
      this._gitReferenceMessenger.register(this._asyncMsgHandler),
      this._remoteAgentDiffMessenger.register(this._asyncMsgHandler),
      this.updateLastKnownSourceFolders()
  }
  async *generateCommitMessage(message) {
    let promptData
    try {
      let workspacePath = kt.workspace.workspaceFolders?.at(0)?.uri.fsPath ?? "",
        repoRootPath = this._resolvePathName(kt.Uri.file(workspacePath))?.repoRoot ?? workspacePath
      promptData = await this._commitMessagePromptPreparer.getCommitMessagePromptData(
        repoRootPath,
        {
          diffBudget: 9216,
          messageBudget: 3072,
          relevantMessageSubbudget: 1024,
          diffNoopLineLimit: 5e3,
          onlyUseStagedChanges: false,
          maxExampleCommitMessages: 3,
        },
      )
    } catch (error) {
      let errorMessage = `Cannot generate commit message prompt: Failed to generate diff details. Error: ${error instanceof Error ? error.message : String(error)}`
      throw (kt.window.showInformationMessage(errorMessage), new Error(errorMessage))
    }
    yield* this.onGenerateCommitMessage(promptData)
  }
  getMergedAdditionalChatModels = () => {
    let configModels = this._config.config.chat.modelDisplayNameToId || {},
      flagModels = this._featureFlagManager.currentFlags.additionalChatModels
    flagModels = flagModels.replace(/'/g, '"')
    try {
      return { ...(flagModels !== "" ? JSON.parse(flagModels) : {}), ...configModels }
    } catch (error) {
      return (
        this._logger.debug(
          `Failed to parse additional chat models: ${error.message}`,
        ),
        configModels
      )
    }
  }
  onUserCancel = (message) => (
    this._logger.debug("onUserCancel"),
    this._chatModel.cancelChatStream(message.data.requestId),
    { type: "empty" }
  )
  isMemoriesFile(pathInfo) {
    let memoriesPath = this._toolsModel.memoriesAbsPath
    if (!memoriesPath) return false
    let filePath = QualifiedPathName.from({
        rootPath: "rootPath" in pathInfo ? pathInfo.rootPath : pathInfo.repoRoot,
        relPath: "relPath" in pathInfo ? pathInfo.relPath : pathInfo.pathName,
      }),
      memoriesFilePath = QualifiedPathName.from({ rootPath: "", relPath: memoriesPath })
    return QualifiedPathName.equals(filePath, memoriesFilePath)
  }
  filterMemoriesFromSelectedCode(codeDetails) {
    return (
      codeDetails && (this.isMemoriesFile({ rootPath: "", relPath: codeDetails.path }) ? null : codeDetails)
    )
  }
  sendCurrentlyOpenFiles = (0, fwe.default)((uris) => {
    let pathInfos = uris
      .map((uri) => this._resolvePathName(uri))
      .filter((pathInfo) => pathInfo !== undefined)
      .filter((pathInfo) => !this.isMemoriesFile(pathInfo))
    this._webview?.postMessage({ type: "currently-open-files", data: pathInfos })
  }, 250)
  sendShowSummary = (0, yf.default)(
    () => {
      this._webview?.postMessage({ type: "should-show-summary" }),
        this._onboardingWorkspaceModel.setShouldShowSummary(false),
        this._onboardingSessionEventReporter.reportEvent("saw-summary")
    },
    250,
    { leading: true, trailing: true },
  )
  sendSyncStatus = (0, yf.default)(
    () => {
      this._webview?.postMessage({ // =
        type: "source-folders-sync-status",
        data: this._syncingStatus.status, // [initMainPanel]:syncData = data
      })
    },
    250,
    { leading: true, trailing: true },
  )
  sendSyncEnabledStatus = (0, yf.default)(
    () => {
      this._webview?.postMessage({ // =
        type: "sync-enabled-state",
        data: this._syncingEnabledTracker.syncingEnabledState,
      })
    },
    250,
    { leading: true, trailing: true },
  )
  sendCurrentGuidelinesState = (0, yf.default)(
    () => {
      this._webview?.postMessage({
        type: "update-guidelines-state",
        data: this._guidelinesWatcher.getGuidelinesStates(),
      })
    },
    250,
    { leading: true, trailing: true },
  )
  sendSourceFolders = (0, yf.default)(
    () => {
      this.updateLastKnownSourceFolders(), // =
        this._webview?.postMessage({
          type: "source-folders-updated",
          data: { sourceFolders: this._lastKnownSourceFolders },
        })
    },
    250,
    { leading: true, trailing: true },
  )
  updateLastKnownSourceFolders() {
    this._lastKnownSourceFolders =
      this._workspaceManager.trackedSourceFolderNames()
  }
  sendFileSelections = (0, yf.default)(
    (editor) => {
      if (editor?.document.uri) {
        let pathInfo = this._resolvePathName(editor.document.uri)
        pathInfo && !this.isMemoriesFile(pathInfo)
          ? this._webview?.postMessage({
              type: "currently-open-files",
              data: [pathInfo],
            })
          : this._webview?.postMessage({
              type: "currently-open-files",
              data: [],
            }),
          pathInfo && !this.isMemoriesFile(pathInfo)
            ? this._webview?.postMessage(PCe(editor, this._workspaceManager))
            : this._webview?.postMessage({
                type: "file-ranges-selected",
                data: [],
              })
      } else
        this._webview?.postMessage({ type: "file-ranges-selected", data: [] })
    },
    250,
    { leading: true, trailing: true },
  )
  onOpenConfirmationModal = async (message) => {
    let response = await kt.window.showInformationMessage(
      message.data.message,
      { modal: true },
      { title: message.data.cancelButtonText, isCloseAffordance: true },
      { title: message.data.confirmButtonText },
    )
    return {
      type: "confirmation-modal-response",
      data: { ok: response?.title === message.data.confirmButtonText },
    }
  }
  _handleCompleteChatReply(response) {
    this._workspaceManager.recordChatReponse(response)
  }
  async postStreamChunksToPanel(panel, text, requestId, isComplete) {
    await panel.postStreamChunk(
      {
        type: "chat-model-reply",
        data: { text: text, requestId: requestId, workspaceFileChunks: [] },
      },
      isComplete,
    )
  }
  getNextLine(text) {
    let newlineIndex = text.indexOf(`
`)
    return newlineIndex === -1 ? [text, ""] : [text.slice(0, newlineIndex + 1), text.slice(newlineIndex + 1)]
  }
  async *onGenerateCommitMessage(promptData) {
    let requestId = this._apiServer.createRequestId(),
      stream = await this._apiServer.generateCommitMessageStream(requestId, promptData)
    for await (let chunk of stream)
      yield {
        type: "chat-model-reply",
        data: { text: chunk.text, requestId: requestId, workspaceFileChunks: [] },
      }
  }
  handleAutofixStateUpdate = async (message) => (
    await km.currentPanel?.handleAutofixStateUpdate(message), { type: "empty" }
  )
  onLaunchAutofixPanel = (message) => (
    km.launchAutofixPanel(
      this._extensionUri,
      message.data.conversationId,
      message.data.iterationId,
      message.data.stage,
      this,
      this._resolveFileService,
      this._workTimer,
    ),
    { type: "empty" }
  )
  async *onUserSendMessage(message) {
    let requestId = this._apiServer.createRequestId(),
      context = this._workspaceManager.getContext(),
      blobs = { checkpointId: undefined, addedBlobs: [], deletedBlobs: [] }
    ;(message.data.context?.userSpecifiedFiles?.length ||
      message.data.context?.sourceFolders?.length) &&
      !message.data.disableRetrieval &&
      (blobs = context.blobs)
    let userGuidedBlobs = []
    message.data.context?.userSpecifiedFiles &&
      !message.data.disableRetrieval &&
      (userGuidedBlobs = this._getBlobNames(message.data.context.userSpecifiedFiles))
    let userGuidelines = this._guidelinesWatcher.getUserGuidelinesContent(),
      workspaceGuidelines = this._guidelinesWatcher.getCurrentWorkspaceGuidelinesContent(
        this._workspaceManager,
      ),
      externalSourceIds = []
    message.data.context?.externalSources &&
      !message.data.disableRetrieval &&
      (externalSourceIds = message.data.context.externalSources.map((source) => source.id))
    let selectedCodeDetails
    if (
      (message.data.context?.selections?.length ||
        message.data.context?.recentFiles?.length) &&
      !message.data.disableSelectedCodeDetails
    ) {
      Bye(kt.window.activeTextEditor)
      let prefixCharCount =
          this._chatModelConfigs.get(message.data?.modelId ?? "")
            ?.suggestedPrefixCharCount ?? w1,
        suffixCharCount =
          this._chatModelConfigs.get(message.data?.modelId ?? "")
            ?.suggestedSuffixCharCount ?? w1
      ;(selectedCodeDetails = PG(kt.window.activeTextEditor, this._workspaceManager, prefixCharCount, suffixCharCount)),
        (selectedCodeDetails = this.filterMemoriesFromSelectedCode(selectedCodeDetails))
    }
    let handleErrors = (response) => {
      let workspaceManager = this._workspaceManager
      response.unknownBlobNames &&
        response.unknownBlobNames.length > 0 &&
        workspaceManager.handleUnknownBlobs(context, response.unknownBlobNames),
        response.checkpointNotFound && workspaceManager.handleUnknownCheckpoint(requestId, blobs.checkpointId)
    }
    try {
      let isFirstChunk = true
      if (
        this._config.config.chat.stream !== false &&
        !this._config.config.preferenceCollection.enable
      ) {
        let accumulatedText = ""
        if (message.data.memoriesInfo?.isClassifyAndDistill) {
          let classifyAndDistillPrompt =
            this._featureFlagManager.currentFlags.memoriesParams
              .classify_and_distill_prompt
          if (!classifyAndDistillPrompt) {
            this._logger.error("Classify and distill prompt missing.")
            return
          }
          ;(message.data.text = classifyAndDistillPrompt.replace("{message}", message.data.text)),
            message.data.nodes?.length &&
              (message.data.nodes = message.data.nodes.map((node) =>
                node.type === po.TEXT && node.text_node
                  ? {
                      ...node,
                      text_node: {
                        content: classifyAndDistillPrompt.replace("{message}", node.text_node.content),
                      },
                    }
                  : node,
              ))
        } else if (message.data.memoriesInfo?.isDistill) {
          let distillPrompt =
            this._featureFlagManager.currentFlags.memoriesParams.distill_prompt
          if (!distillPrompt) {
            this._logger.error("Distill prompt missing.")
            return
          }
          message.data.text = distillPrompt.replace("{message}", message.data.text)
        }
        let agentMemories
        if (this._toolsModel.chatMode === Fr.agent)
          if (this._featureFlagManager.currentFlags.useMemorySnapshotManager) {
            let conversationId = message.data.conversationId ?? ""
            agentMemories = await this._toolsModel.getAgentMemoriesWithSnapshot(conversationId)
          } else agentMemories = await SM(this._checkpointManager.getAgentMemoriesAbsPath)
        for await (let chunk of this._chatModel.chatStream(
          {
            requestId: requestId,
            message: message.data.text,
            chatHistory: message.data.chatHistory,
            blobs: blobs,
            userGuidedBlobs: userGuidedBlobs,
            externalSourceIds: externalSourceIds,
            modelId: message.data.modelId,
            userGuidelines: userGuidelines,
            workspaceGuidelines: workspaceGuidelines,
            toolDefinitions: (await this._toolsModel.getToolDefinitions()).map(
              (tool) => tool.definition,
            ),
            nodes: message.data.nodes,
            mode: this._toolsModel.chatMode,
            agentMemories: agentMemories,
            personaType: message.data.personaType,
          },
          selectedCodeDetails,
        )) {
          if ((handleErrors(chunk.data), isFirstChunk)) {
            isFirstChunk = false
            let hasNewlyTrackedFolders = this._syncingStatus.status.foldersProgress.some(
              (folder) => folder.progress?.newlyTracked,
            )
            this._syncingStatus.status.status !== "done" &&
              hasNewlyTrackedFolders &&
              (chunk.data.text =
                `*Note: Augment is not yet fully synced and may be unable to answer questions about your workspace.*

` + chunk.data.text)
          }
          ;(accumulatedText += chunk.data.text), yield chunk
        }
        this._handleCompleteChatReply(accumulatedText)
        return
      }
      yield* await this.handlePreferenceCollection(message, requestId, blobs, userGuidedBlobs, externalSourceIds, selectedCodeDetails)
    } catch (error) {
      if (
        (this._apiServer.reportError(
          requestId,
          "chat_stream_failed",
          error instanceof Error && error.stack ? error.stack : "",
          [],
        ),
        this._logger.error(
          `Chat stream failed: ${String(error)}${
            error instanceof Error
              ? `
${error.stack}`
              : ""
          }`,
        ),
        error instanceof ApiError && error.status === RequestStatus.augmentTooLarge)
      )
        return yield {
          type: "chat-model-reply",
          data: {
            text: "",
            requestId: requestId,
            workspaceFileChunks: [],
            error: {
              displayErrorMessage:
                "The selected text exceeds the allowable limit. Please reduce the amount of text and try again",
            },
          },
        }
      if (
        error instanceof ApiError &&
        (error.status === RequestStatus.resourceExhausted || error.status === RequestStatus.unavailable)
      )
        return yield {
          type: "chat-model-reply",
          data: {
            text: "",
            requestId: requestId,
            workspaceFileChunks: [],
            error: { displayErrorMessage: error.message, isRetriable: true },
          },
        }
      if (error instanceof Error)
        return yield {
          type: "chat-model-reply",
          data: {
            text: "",
            requestId: requestId,
            workspaceFileChunks: [],
            error: { displayErrorMessage: error.message },
          },
        }
      if (String(error).startsWith("Error: Cancelled")) return
      throw (kt.window.showErrorMessage(`Failed to send chat message: ${error}`), error)
    }
  }
  async handlePreferenceCollection(message, requestId, blobs, userGuidedBlobs, externalSourceIds, selectedCodeDetails) {
    let eloModelConfiguration = this._featureFlagManager.currentFlags.eloModelConfiguration
    if (
      ((!eloModelConfiguration.highPriorityModels || eloModelConfiguration.highPriorityModels.length < 2) &&
        eloModelConfiguration.highPriorityThreshold !== 0) ||
      ((!eloModelConfiguration.regularBattleModels || eloModelConfiguration.regularBattleModels.length < 2) &&
        eloModelConfiguration.highPriorityThreshold < 1)
    )
      return (async function* () {
        await Promise.resolve(),
          yield {
            type: "chat-model-reply",
            data: {
              text: "",
              requestId: requestId,
              workspaceFileChunks: [],
              error: {
                displayErrorMessage:
                  "Model comparison is not available at this time.",
              },
            },
          }
      })()
    let highPriorityThreshold = eloModelConfiguration.highPriorityThreshold
    ;(this._chatModel._preferenceState._selectedCode !== selectedCodeDetails?.selectedCode ||
      this._chatModel._preferenceState._filePath !== selectedCodeDetails?.path) &&
      (this._chatModel._preferenceState = new Sx())
    let comparisonParams = {
      message: message,
      requestId: requestId,
      blobs: blobs,
      userGuidedBlobs: userGuidedBlobs,
      selectedCodeDetails: selectedCodeDetails,
    }
    return Math.random() < highPriorityThreshold
      ? this.handleHighPriorityTest(comparisonParams, externalSourceIds, eloModelConfiguration.highPriorityModels)
      : this.handleRegularBattle(comparisonParams, externalSourceIds, eloModelConfiguration.regularBattleModels)
  }
  handleHighPriorityTest(params, externalSourceIds, highPriorityModels) {
    let modelIdA, modelIdB
    if (highPriorityModels.length > 0 && Array.isArray(highPriorityModels[0])) {
      let randomIndex = Math.floor(Math.random() * highPriorityModels.length)
      ;[modelIdA, modelIdB] = highPriorityModels[randomIndex]
    } else [modelIdA, modelIdB] = highPriorityModels.sort(() => Math.random() - 0.5).slice(0, 2)
    return Promise.resolve(
      this.runComparison(params, {
        modelId: modelIdA,
        modelIdB: modelIdB,
        externalSourceIds: externalSourceIds,
        externalSourceIdsB: externalSourceIds,
      }),
    )
  }
  handleRegularBattle(params, externalSourceIds, regularBattleModels) {
    let modelIdA = regularBattleModels[Math.floor(Math.random() * regularBattleModels.length)],
      modelIdB
    do modelIdB = regularBattleModels[Math.floor(Math.random() * regularBattleModels.length)]
    while (modelIdB === modelIdA && regularBattleModels.length > 1)
    return Promise.resolve(
      this.runComparison(params, {
        modelId: modelIdA,
        modelIdB: modelIdB,
        externalSourceIds: externalSourceIds,
        externalSourceIdsB: externalSourceIds,
      }),
    )
  }
  async *runComparison(params, comparisonConfig) {
    let requestIdB = this._apiServer.createRequestId(),
      toolDefinitions = (await this._toolsModel.getToolDefinitions()).map(
        (tool) => tool.definition,
      ),
      streamA = this._chatModel.chatStream(
        {
          requestId: params.requestId,
          message: params.message.data.text,
          chatHistory: params.message.data.chatHistory,
          blobs: params.blobs,
          userGuidedBlobs: params.userGuidedBlobs,
          externalSourceIds: comparisonConfig.externalSourceIds,
          modelId: comparisonConfig.modelId,
          toolDefinitions: toolDefinitions,
          personaType: params.message.data.personaType,
        },
        params.selectedCodeDetails,
      ),
      streamB = this._chatModel.chatStream(
        {
          requestId: requestIdB,
          message: params.message.data.text,
          chatHistory: params.message.data.chatHistory,
          blobs: params.blobs,
          userGuidedBlobs: params.userGuidedBlobs,
          externalSourceIds: comparisonConfig.externalSourceIdsB,
          modelId: comparisonConfig.modelIdB,
          toolDefinitions: toolDefinitions,
          personaType: params.message.data.personaType,
        },
        params.selectedCodeDetails,
      ),
      {
        responseA: responseA,
        responseB: responseB,
        workspaceFileChunksA: workspaceFileChunksA,
        workspaceFileChunksB: workspaceFileChunksB,
        preferencePanel: preferencePanel,
      } = await this.processStreams(
        streamA,
        streamB,
        params.message,
        params.requestId,
        requestIdB,
        comparisonConfig.implicitExternalSources ? comparisonConfig.implicitExternalSources : [],
        [...(comparisonConfig.externalSourceIds ?? []), ...(comparisonConfig.externalSourceIdsB ?? [])],
      )
    preferencePanel.postStreamDone()
    let userPreferredA = await preferencePanel?.getResult({ a: params.requestId, b: requestIdB }, this._apiServer, {
      a: comparisonConfig.modelId,
      b: comparisonConfig.modelIdB,
    })
    userPreferredA
      ? (this._chatModel._preferenceState._selectedCodeReferenceRequestIdOptionB =
          this._chatModel._preferenceState._selectedCodeReferenceRequestId)
      : (this._chatModel._preferenceState._selectedCodeReferenceRequestId =
          this._chatModel._preferenceState._selectedCodeReferenceRequestIdOptionB),
      this._handleCompleteChatReply(userPreferredA ? responseA : responseB),
      yield {
        type: "chat-model-reply",
        data: {
          text: userPreferredA ? responseA : responseB,
          requestId: userPreferredA ? params.requestId : requestIdB,
          workspaceFileChunks: userPreferredA ? workspaceFileChunksA : workspaceFileChunksB,
        },
      }
  }
  async processStreams(streamA, streamB, message, requestIdA, requestIdB, implicitExternalSources, externalSourceIds) {
    let textA = "",
      textB = "",
      partialTextA = "",
      partialTextB = "",
      workspaceFileChunksA = [],
      workspaceFileChunksB = [],
      preferencePanel = await Tv.launchStandalonePreferencePanel(
        this._extensionUri,
        { a: new Lx(message.data.text, ""), b: new Lx(message.data.text, "") },
        this._config.config.preferenceCollection.enableRetrievalDataCollection,
        this._fuzzyFsSearcher,
        implicitExternalSources,
        externalSourceIds,
        this._workTimer,
      ),
      iteratorA = streamA[Symbol.asyncIterator](),
      iteratorB = streamB[Symbol.asyncIterator](),
      chunkA = await iteratorA.next(),
      chunkB = await iteratorB.next()
    for (; !chunkA.done || !chunkB.done; ) {
      !chunkA.done &&
        (!textA.includes(`
`) ||
          chunkB.done) &&
        ((textA += chunkA.value.data.text),
        (workspaceFileChunksA = workspaceFileChunksA.concat(chunkA.value.data.workspaceFileChunks)),
        (chunkA = await iteratorA.next())),
        !chunkB.done &&
          (!textB.includes(`
`) ||
            chunkA.done) &&
          ((textB += chunkB.value.data.text),
          (workspaceFileChunksB = workspaceFileChunksB.concat(chunkB.value.data.workspaceFileChunks)),
          (chunkB = await iteratorB.next()))
      let nextLineA, nextLineB
      for (
        ;
        ((textA.includes(`
`) &&
          textB.includes(`
`)) ||
          chunkA.done ||
          chunkB.done) &&
        (([nextLineA, textA] =
          chunkA.done &&
          !textA.includes(`
`)
            ? [textA, ""]
            : this.getNextLine(textA)),
        ([nextLineB, textB] =
          chunkB.done &&
          !textB.includes(`
`)
            ? [textB, ""]
            : this.getNextLine(textB)),
        (partialTextA += nextLineA),
        (partialTextB += nextLineB),
        this.postStreamChunksToPanel(preferencePanel, partialTextA, requestIdA, "A"),
        this.postStreamChunksToPanel(preferencePanel, partialTextB, requestIdB, "B"),
        !(textA.length === 0 || textB.length === 0));

      );
    }
    return (
      textA && ((partialTextA += textA), this.postStreamChunksToPanel(preferencePanel, partialTextA, requestIdA, "A")),
      textB && ((partialTextB += textB), this.postStreamChunksToPanel(preferencePanel, partialTextB, requestIdB, "B")),
      {
        responseA: partialTextA,
        responseB: partialTextB,
        workspaceFileChunksA: workspaceFileChunksA,
        workspaceFileChunksB: workspaceFileChunksB,
        preferencePanel: preferencePanel,
      }
    )
  }
  onExternalSourceSearch = async (message) => {
    if (
      !isMinVersionMet(
        this._featureFlagManager.currentFlags
          .vscodeExternalSourcesInChatMinVersion,
      )
    )
      return { type: "find-external-sources-response", data: { sources: [] } }
    let response = await this._apiServer.searchExternalSources(message.data.query, [])
    return { type: "find-external-sources-response", data: response }
  }
  getActiveWorkspacePath = () => {
    let editor = kt.window.activeTextEditor
    if (!editor) return
    let filePath = editor.document.uri.fsPath
    return this._workspaceManager.safeResolvePathName(filePath)?.rootPath
  }
  _resolvePathName(filePath) {
    let pathInfo = this._workspaceManager.safeResolvePathName(filePath)
    if (pathInfo !== undefined) return { repoRoot: pathInfo.rootPath, pathName: pathInfo.relPath }
  }
  _getDefaultTargetPath = () => {
    let editor = kt.window.activeTextEditor
    if (!editor) return
    let filePath = editor.document.uri.fsPath,
      pathInfo = this._workspaceManager.safeResolvePathName(filePath)
    return pathInfo ? rg(pathInfo) : undefined
  }
  resolveTargetPath = async (targetPath, searchScope = undefined, exactMatch = true) => {
    if (!targetPath) return
    let pathInfo
    if (af(targetPath)) pathInfo = this._workspaceManager.safeResolvePathName(targetPath)
    else {
      let workspace = this._workspaceManager.findBestWorkspaceRootMatch(targetPath)
      workspace && (pathInfo = { rootPath: workspace.qualifiedPathName.rootPath, relPath: targetPath })
    }
    if (pathInfo) {
      let fileStats = await this._fuzzyFsSearcher.statPath(pathInfo)
      if (fileStats) {
        let result = rg(pathInfo)
        return (result.fileType = fileStats.type), result
      }
    }
    let searchResult = this._fuzzyFsSearcher.findFiles({
      type: "find-file-request",
      data: {
        rootPath: "",
        relPath: targetPath,
        exactMatch: exactMatch,
        maxResults: 10,
        searchScope: searchScope,
      },
    })
    if (searchResult.data.length >= 0) return searchResult.data[0]
  }
  async *_smartPasteWithChatInstruction(requestData, requestId) {
    let { message, targetFilePath, targetFileContent } = requestData,
      selectedCodeDetails = requestData.selectedCodeDetails
    requestId = requestId ?? this._apiServer.createRequestId()
    let blobs = this._workspaceManager.getContext().blobs,
      chatHistory = message.data.chatHistory.map((entry) => ({
        request_message: entry.request_message,
        response_text: entry.response_text,
        request_id: entry.request_id,
      })),
      referenceRequestId = this._chatModel.getReferenceReqId()
    for (let index = chatHistory.length - 1; index >= 0; index--) {
      let historyEntry = chatHistory[index],
        cachedSelection = this._chatModel.selectionCache.get(historyEntry.request_id)
      if (cachedSelection) {
        ;(selectedCodeDetails = cachedSelection), (referenceRequestId = historyEntry.request_id)
        break
      }
    }
    try {
      let stream = await this._apiServer.smartPasteStream(
        requestId,
        "",
        blobs,
        chatHistory,
        selectedCodeDetails?.selectedCode,
        selectedCodeDetails?.prefix,
        selectedCodeDetails?.suffix,
        selectedCodeDetails?.path,
        undefined,
        selectedCodeDetails?.prefixBegin,
        selectedCodeDetails?.suffixEnd,
        selectedCodeDetails?.language,
        message.data.generatedCode,
        targetFilePath,
        targetFileContent,
        referenceRequestId,
      )
      for await (let chunk of stream) yield chunk
    } catch (error) {
      throw (
        (this._logger.error(
          `Error in _smartPasteWithChatInstruction: ${getErrorMessage(error)}`,
        ),
        error)
      )
    }
  }
  onClearMetadataFor = (message) => {
    let data = message.data,
      chatModel = this._chatModel
    data.requestIds?.forEach((requestId) => {
      chatModel.deleteChatStream(requestId), chatModel.selectionCache.remove(requestId)
    }),
      data.conversationIds?.forEach((conversationId) => {
        this._checkpointManager.clearConversationCheckpoints(conversationId)
      })
  }
  async onExecuteCommand(message) {
    let { iterationId, command, args } = message.data,
      process = (0, dwe.spawn)(command, args, {
        stdio: ["ignore", "pipe", "pipe"],
        shell: true,
        cwd: this.getActiveWorkspacePath(),
      }),
      output = "",
      returnCode = -1
    return (
      await new Promise((resolve, reject) => {
        process.stdout?.on("data", (data) => {
          ;(output += data.toString()),
            km.currentPanel?.handleCommandPartialOutput({
              type: "autofix-panel-execute-command-partial-output",
              data: { iterationId, output: output },
            })
        }),
          process.stderr?.on("data", (data) => {
            ;(output += data.toString()),
              km.currentPanel?.handleCommandPartialOutput({
                type: "autofix-panel-execute-command-partial-output",
                data: { iterationId, output },
              })
          }),
          process.on("close", (code) => {
            ;(returnCode = code ?? -1), resolve()
          }),
          process.on("error", reject)
      }),
      {
        type: "chat-autofix-execute-command-result",
        data: { output, returnCode },
      }
    )
  }
  async _getVCSChange() {
    return this._workspaceManager !== undefined
      ? await this._workspaceManager.getVCSChange()
      : { commits: [], workingDirectory: [] }
  }
  async onAutofixPlan(message) {
    let blobs = this._workspaceManager.getContext().blobs,
      vcsChanges = await this._getVCSChange(),
      planResponse = null
    try {
      planResponse = await this._apiServer.autofixPlan(
        message.data.command,
        vcsChanges,
        blobs,
        message.data.steeringHistory,
      )
    } catch {
      return {
        type: "chat-autofix-plan-response",
        data: {
          plan: {
            summary: "Error",
            replacements: [],
            originalReplacements: [],
          },
        },
      }
    }
    let replacements = planResponse.replacements,
      processedReplacements = await Promise.all(
        replacements.map(async (replacement) => await iEe(this._workspaceManager, replacement)),
      )
    return {
      type: "chat-autofix-plan-response",
      data: {
        plan: { summary: planResponse.summary, replacements: processedReplacements, originalReplacements: replacements },
      },
    }
  }
  onDidReceiveMessage = async (message) => {
    switch (message.type) {
      case "chat-create-file": {
        let relativePath = message.data.relPath
        if (relativePath) {
          let workspace = this._workspaceManager.findBestWorkspaceRootMatch(relativePath)
          if (!workspace || workspace.fileType !== "Directory") {
            kt.window.showWarningMessage(`Directory ${Ha(relativePath)} not found.`)
            break
          }
          let fullPath = getFullPath({ rootPath: workspace.qualifiedPathName.rootPath, relPath: relativePath }),
            fileUri = kt.Uri.file(fullPath)
          try {
            await kt.workspace.fs.stat(fileUri),
              kt.window.showErrorMessage(
                `Cannot create file at ${fileUri.fsPath}. File already exists.`,
              )
            break
          } catch {}
          try {
            await kt.workspace.fs.writeFile(fileUri, Buffer.from(message.data.code))
            let document = await kt.workspace.openTextDocument(fileUri)
            if (!document) {
              this._logger.error(
                `Could not open document at ${fileUri.fsPath} during file creation.`,
              )
              break
            }
            await kt.window.showTextDocument(document)
          } catch (error) {
            this._logger.error(`Could not create file at ${fileUri.fsPath}: ${error}`)
          }
        } else {
          try {
            let document = await kt.workspace.openTextDocument({
                content: message.data.code,
              }),
              documentUri = document.uri
            await kt.workspace.fs.writeFile(documentUri, Buffer.from(message.data.code)),
              await kt.window.showTextDocument(document)
          } catch (error) {
            this._logger.error(`Could not create untitled file: ${error}`)
          }
          break
        }
        break
      }
      case "chat-smart-paste": {
        let activeEditor = kt.window.activeTextEditor,
          selectedCodeDetails = null
        activeEditor && (selectedCodeDetails = PG(activeEditor, this._workspaceManager, w1, w1))
        let targetPath,
          resolvedTargetPath =
            (await this.resolveTargetPath(message.data.targetFile)) ??
            this._getDefaultTargetPath()
        if (!message.data.options?.dryRun)
          if (resolvedTargetPath) {
            if (
              message.data.options?.requireFileConfirmation &&
              !(
                await this.onOpenConfirmationModal({
                  type: "open-confirmation-modal",
                  data: {
                    title: "Apply Codeblock",
                    message: `Are you sure you want to apply the codeblock to ${resolvedTargetPath.pathName}?`,
                    confirmButtonText: "Apply",
                    cancelButtonText: "Cancel",
                  },
                })
              ).data.ok
            )
              return
          } else {
            kt.window.showWarningMessage(
              "Cannot apply codeblock. No valid target file found.",
            ),
              this._clientMetricsReporter.reportWebviewClientMetric({
                webviewName: "chat",
                client_metric: "chat-failed-smart-paste-resolve-file",
                value: 1,
              })
            return
          }
        if (!resolvedTargetPath) return
        targetPath = getFullPath({ rootPath: resolvedTargetPath.repoRoot, relPath: resolvedTargetPath.pathName })
        let fileContent = (await Io(targetPath)).getText(),
          qualifiedPath = QualifiedPathName.from({ rootPath: resolvedTargetPath.repoRoot, relPath: resolvedTargetPath.pathName }),
          applyTime
        !message.data.options?.dryRun &&
          !message.data.options?.instantApply &&
          this._createOrShowDiffView({
            smartPasteContext: { applyTime: applyTime },
            document: new VsCodeDiffDocument(qualifiedPath, fileContent, message.data.generatedCode),
          })
        let generator, requestId
        if (this._config.config.chat.smartPasteUsePrecomputation ?? true) {
          let cacheResult = await this._smartPasteCache.get(message.data.generatedCode, targetPath, fileContent, {
            message: message,
            selectedCodeDetails: selectedCodeDetails,
            targetFilePath: targetPath,
            targetFileContent: fileContent,
          })
          if (!cacheResult) {
            this._logger.error(
              "Could not get valid edit stream for smart paste.",
            )
            return
          }
          ;(generator = cacheResult.generator),
            (requestId = cacheResult.requestId),
            this._clientMetricsReporter.reportWebviewClientMetric({
              webviewName: "chat",
              client_metric: "chat-precompute-smart-paste",
              value: 1,
            })
        } else {
          if (message.data.options?.dryRun) return
          {
            let directResult = await this._smartPasteCache.getDirect({
              message: message,
              selectedCodeDetails: selectedCodeDetails,
              targetFilePath: targetPath,
              targetFileContent: fileContent,
            })
            if (!directResult) {
              this._logger.error(
                "Could not get valid edit stream for smart paste.",
              )
              return
            }
            ;(generator = directResult.generator),
              (requestId = directResult.requestId),
              this._clientMetricsReporter.reportWebviewClientMetric({
                webviewName: "chat",
                client_metric: "chat-smart-paste",
                value: 1,
              })
          }
        }
        if (!generator) {
          this._logger.error("Could not get valid edit stream for smart paste.")
          return
        }
        message.data.options?.dryRun ||
          (message.data.options?.instantApply
            ? await DiffViewPanel.instantApply(
                {
                  extensionUri: this._extensionUri,
                  workspaceManager: this._workspaceManager,
                  apiServer: this._apiServer,
                  keybindingWatcher: this._keybindingWatcher,
                  fuzzyFsSearcher: this._fuzzyFsSearcher,
                  fuzzySymbolSearcher: this._fuzzySymbolSearcher,
                  workTimer: this._workTimer,
                },
                { document: new VsCodeDiffDocument(qualifiedPath, fileContent, message.data.generatedCode) },
                generator,
              )
            : DiffViewPanel.startStream(hF(fileContent, generator), requestId, "smart-paste"))
        break
      }
      case "open-file": {
        let resolvedPath = await this.resolveTargetPath(message.data.pathName, undefined, false)
        if (!resolvedPath && message.data.allowOutOfWorkspace) {
          cg(message.data)
          return
        } else if (!resolvedPath) return
        let repoRoot = resolvedPath.repoRoot,
          pathName = resolvedPath.pathName
        cg({
          repoRoot: repoRoot,
          pathName: pathName,
          range: message.data.range,
          fullRange: message.data.fullRange,
          differentTab: message.data.differentTab,
          snippet: message.data.snippet,
        })
        break
      }
      case "open-memories-file": {
        let memoriesPath = this._toolsModel.memoriesAbsPath
        if (!memoriesPath) return
        cg({ repoRoot: "", pathName: memoriesPath })
        break
      }
      case "main-panel-perform-action": {
        this.performAction(message.data)
        break
      }
      case "used-slash-action": {
        this._onboardingSessionEventReporter.reportEvent("used-slash-action")
        break
      }
      case "used-chat": {
        this._onboardingSessionEventReporter.reportEvent("used-chat")
        break
      }
      case "chat-clear-metadata": {
        this.onClearMetadataFor(message)
        break
      }
      case "open-guidelines": {
        this._openGuidelines(message.data)
        break
      }
      case "update-user-guidelines": {
        ig.updateUserGuidelines(message.data)
        break
      }
      case "open-settings-page": {
        message.data
          ? kt.commands.executeCommand(
              "vscode-augment.showSettingsPanel",
              message.data,
            )
          : kt.commands.executeCommand("vscode-augment.showSettingsPanel")
        break
      }
      case "augment-link": {
        try {
          let url = message.data
          if (url) {
            let uri = kt.Uri.parse(url)
            kt.env.openExternal(uri)
          }
        } catch (error) {
          this._logger.error(`Failed to open URL: ${getErrorMessage(error)}`)
        }
        break
      }
      case "trigger-initial-orientation": {
        if (
          !this._featureFlagManager.currentFlags.memoriesParams
            ?.enable_initial_orientation
        )
          return
        await runAgentInitialOrientation( // =
          this._apiServer,
          this._workspaceManager,
          this._featureFlagManager,
          this._checkpointManager,
          nh.onboarding,
        )
        break
      }
      case "get-orientation-status": {
        notifyOrientationStateChanged()
        break
      }
      case "execute-command": {
        let command = message.data
        try {
          await kt.commands.executeCommand(command)
        } catch (error) {
          this._logger.error(`Failed to execute command ${command}: ${error}`)
        }
        break
      }
      case "report-error": {
        this._apiServer.reportError(
          message.data.originalRequestId,
          message.data.sanitizedMessage,
          message.data.stackTrace,
          message.data.diagnostics,
        )
        break
      }
    }
  }
  _openGuidelines = (folderPath) => {
    if (folderPath) {
      let guidelinesPath = hwe.default.join(folderPath, ".augment-guidelines"),
        fileUri = kt.Uri.file(guidelinesPath)
      kt.commands.executeCommand("vscode.open", fileUri)
      return
    } else {
      kt.commands.executeCommand(
        "workbench.action.openSettings",
        "augment.userGuidelines",
      )
      return
    }
  }
  _getBlobNames(paths) {
    let blobNames = new Array()
    for (let path of paths) {
      let blobName = this._workspaceManager.getBlobName(QualifiedPathName.from(path))
      blobName !== undefined && blobNames.push(blobName)
    }
    return blobNames
  }
  performAction(action) {
    switch (action) {
      case "disable-github-copilot": {
        Im.disableGitHubCopilot()
        break
      }
      case "disable-codeium": {
        Im.disableCodeium()
        break
      }
      case "move-extension-aside": {
        this._actionsModel.setSystemStateStatus(
          "hasMovedExtensionAside",
          "complete",
        )
        break
      }
      case "open-folder": {
        kt.commands.executeCommand("vscode.openFolder")
        break
      }
      case "close-folder": {
        kt.commands.executeCommand("vscode.closeFolder")
        break
      }
      case "grant-sync-permission": {
        this._syncingEnabledTracker.enableSyncing()
        break
      }
    }
  }
  handleDerivedStateChange(actions) {
    this.sendActionsToWebview(actions.map((action) => action.name))
  }
  async sendActionsToWebview(actions) {
    await this._webview?.postMessage({ type: "main-panel-actions", data: actions })
  }
  async sendAutofixUpdateRequestMessage() {
    await this._webview?.postMessage({
      type: "chat-autofix-state-update-request",
    })
  }
  async sendAutofixSuggestionsAppliedMessage(solutions) {
    await this._webview?.postMessage({
      type: "chat-autofix-suggestions-applied",
      data: { selectedSolutions: solutions },
    })
  }
  onChatExtensionMessage = async (command) => {
    switch (command) {
      case "runSlashFix": {
        await this._webview?.postMessage({
          type: "run-slash-command",
          data: "fix",
        })
        break
      }
      case "runSlashExplain": {
        await this._webview?.postMessage({
          type: "run-slash-command",
          data: "explain",
        })
        break
      }
      case "newThread": {
        await this._webview?.postMessage({ type: "new-thread" })
        break
      }
      case "runSlashTest": {
        await this._webview?.postMessage({
          type: "run-slash-command",
          data: "write-test",
        })
        break
      }
      case "runSlashDocument": {
        await this._webview?.postMessage({
          type: "run-slash-command",
          data: "document",
        })
        break
      }
      case "reset-agent-onboarding": {
        await this._webview?.postMessage({ type: "reset-agent-onboarding" })
        break
      }
    }
  }
  showAugmentPanel = async () => (
    await kt.commands.executeCommand(Separator.commandID), { type: "empty" }
  )
  callTool = async (message) => {
    let data = message.data,
      chatHistory = await this._chatModel.hydrateChatHistory(data.chatHistory),
      limitedChatHistory = this._chatModel.limitChatHistory(chatHistory),
      result = await this._toolsModel.callTool(
        data.chatRequestId,
        data.toolUseId,
        data.name,
        data.input,
        limitedChatHistory,
        data.conversationId,
      )
    return { type: "call-tool-response", data: result }
  }
  cancelToolRun = async (message) => (
    await this._toolsModel.cancelToolRun(message.data.requestId, message.data.toolUseId),
    { type: "cancel-tool-run-response" }
  )
  toolCheckSafe = async (message) => {
    let data = message.data,
      isSafe = await this._toolsModel.checkToolCallSafe(data.name, data.input)
    return { type: "check-safe-response", data: { isSafe: isSafe } }
  }
  checkToolExists = async (message) => {
    let exists = await this._toolsModel.checkToolExists(message.toolName)
    return { type: "checkToolExistsResponse", exists: exists }
  }
  _getChatRequestIdeState = async (message) => {
    let activeFolderRoot = kt.window.activeTextEditor
        ? this._workspaceManager.getFolderRoot(
            kt.window.activeTextEditor?.document.uri,
          )
        : undefined,
      recentlyChangedRoot = this._workspaceManager.getMostRecentlyChangedFolderRoot(),
      workspaceFolders = this._workspaceManager
        .listSourceFolders()
        .filter((folder) => folder.type === 0)
        .sort((folder) => (folder.folderRoot === activeFolderRoot ? -1 : folder.folderRoot === recentlyChangedRoot ? 0 : 1))
        .map((folder) => ({
          folder_root: folder.folderRoot,
          repository_root:
            this._workspaceManager.getRepoRootForFolderRoot(folder.folderRoot) ??
            folder.folderRoot,
        })),
      launchProcessTool = this._toolsModel.getTool(ToolType.launchProcess),
      terminalInfo
    return (
      launchProcessTool && launchProcessTool instanceof cv && (terminalInfo = launchProcessTool.processTools.getLongRunningTerminalInfo()),
      !terminalInfo &&
        workspaceFolders.length > 0 &&
        (terminalInfo = { terminal_id: 0, current_working_directory: workspaceFolders[0].folder_root }),
      Promise.resolve({
        type: "get-ide-state-node-response",
        data: {
          workspace_folders: workspaceFolders,
          workspace_folders_unchanged: false,
          current_terminal: terminalInfo,
        },
      })
    )
  }
  _createOrShowDiffView = (options) => {
    DiffViewPanel.createOrShow(
      {
        extensionUri: this._extensionUri,
        workspaceManager: this._workspaceManager,
        apiServer: this._apiServer,
        keybindingWatcher: this._keybindingWatcher,
        fuzzyFsSearcher: this._fuzzyFsSearcher,
        fuzzySymbolSearcher: this._fuzzySymbolSearcher,
        workTimer: this._workTimer,
      },
      options,
    )
  }
  _notifyAgentEditListHasUpdates = (0, yf.default)(
    () => {
      this._webview?.postMessage({
        type: "chat-agent-edit-list-has-updates",
        data: {},
      })
    },
    1e3,
    { leading: true, trailing: true },
  )
  _notifyMemoryHasUpdates = (0, yf.default)(
    () => {
      this._webview?.postMessage({ type: "chat-memory-has-updates" })
    },
    500,
    { leading: true, trailing: true },
  )
  setupMemoryUpdateListener() {
    if (
      !this._toolsModel ||
      typeof this._toolsModel.getSidecarToolHost != "function"
    )
      return
    let sidecarToolHost = this._toolsModel.getSidecarToolHost()
    if (!sidecarToolHost) return
    let memoryUpdateManager = sidecarToolHost.getMemoryUpdateManager()
    memoryUpdateManager &&
      (this._memoryUpdateManagerDisposable?.dispose(),
      (this._memoryUpdateManagerDisposable = memoryUpdateManager.onMemoryHasUpdates(() => {
        this._notifyMemoryHasUpdates()
      })),
      this.addDisposable(this._memoryUpdateManagerDisposable))
  }
  _saveImage = async (message) => {
    let { filename, data } = message.data,
      buffer = lEe(data)
    return (
      await this._assetManager.saveAsset(filename, buffer),
      { type: "chat-save-image-response", data: filename }
    )
  }
  _deleteImage = async (message) => {
    let filename = message.data
    return (
      await this._assetManager.deleteAsset(filename),
      { type: "chat-delete-image-response" }
    )
  }
  _loadImage = async (message) => {
    let filename = message.data,
      imageData = await this._assetManager.loadAsset(filename),
      base64Data = imageData ? cEe(imageData) : undefined
    return { type: "chat-load-image-response", data: base64Data }
  }
}
var H8 = q(require("vscode")),
  pwe = require("vscode")
var gwe = require("vscode")
var ShowSidebarChatCommand = class extends AugmentCommand {
  constructor(featureFlagManager, changeWebviewAppEvent) {
    super()
    this._featureFlagManager = featureFlagManager
    this._changeWebviewAppEvent = changeWebviewAppEvent
  }
  type = "public"
  static commandID = "_vscode-augment.showSidebarChat"
  run() {
    this._changeWebviewAppEvent.fire("chat"),
      gwe.commands.executeCommand(Separator.commandID)
  }
}
async function showAugmentPanel(featureName) {
  try {
    await H8.commands.executeCommand(Separator.commandID),
      await H8.commands.executeCommand(ShowSidebarChatCommand.commandID)
  } catch (error) {
    error instanceof Error &&
      pwe.window.showErrorMessage(
        `Sorry, Augment ${featureName} encountered an unexpected error: ${getErrorMessage(error)}`,
      )
  }
}
var BaseSlashCommand = class extends SyncingEnabledCommand {
    constructor(extension, configListener, chatExtensionEvent, title, displayName, requiresSync) {
      super(title, displayName, requiresSync)
      this._extension = extension
      this._configListener = configListener
      this._chatExtensionEvent = chatExtensionEvent
      ;(this._extension = extension),
        (this._configListener = configListener),
        (this._chatExtensionEvent = chatExtensionEvent)
    }
    type = "public"
    canRun() {
      return this._extension.ready
    }
    updateSelectionToCoverDiagnostics(diagnostics) {
      let editor = dg.window.activeTextEditor
      if (editor) {
        let selectionRange
        if (diagnostics && !diagnostics.every((diagnostic) => editor.selection.contains(diagnostic.range))) {
          let startLine = Math.min(...diagnostics.map((diag) => diag.range.start.line)),
            endLine = Math.max(...diagnostics.map((diag) => diag.range.end.line)),
            startPosition = new dg.Position(startLine, 0),
            endPosition = editor.document.lineAt(endLine).range.end
          selectionRange = new dg.Range(startPosition, endPosition)
        } else
          editor.selection.isEmpty &&
            (selectionRange = editor.document.lineAt(editor.selection.active.line).range)
        selectionRange && (editor.selection = new dg.Selection(selectionRange.start, selectionRange.end))
      }
    }
  },
  FixCommand = class extends BaseSlashCommand {
    static commandID = "vscode-augment.chat.slash.fix"
    constructor(extension, configListener, chatExtensionEvent, title) {
      super(extension, configListener, chatExtensionEvent, title, "Fix using Augment", false)
    }
    async run(uri, diagnostics) {
      await showAugmentPanel("Quick Fix"),
        diagnostics && this.updateSelectionToCoverDiagnostics(diagnostics),
        this._chatExtensionEvent.fire("runSlashFix")
    }
  },
  ExplainCommand = class extends BaseSlashCommand {
    static commandID = "vscode-augment.chat.slash.explain"
    constructor(extension, configListener, chatExtensionEvent, title) {
      super(extension, configListener, chatExtensionEvent, title, "Explain using Augment", false)
    }
    async run() {
      await showAugmentPanel("Explain"), this._chatExtensionEvent.fire("runSlashExplain")
    }
  },
  TestCommand = class extends BaseSlashCommand {
    static commandID = "vscode-augment.chat.slash.test"
    constructor(extension, configListener, chatExtensionEvent, title) {
      super(extension, configListener, chatExtensionEvent, title, "Write test using Augment", false)
    }
    async run() {
      await showAugmentPanel("Write a Test"), this._chatExtensionEvent.fire("runSlashTest")
    }
  },
  DocumentCommand = class extends BaseSlashCommand {
    static commandID = "vscode-augment.chat.slash.document"
    constructor(extension, configListener, chatExtensionEvent, title) {
      super(extension, configListener, chatExtensionEvent, title, "Document", true)
    }
    async run() {
      await showAugmentPanel("Document"), this._chatExtensionEvent.fire("runSlashDocument")
    }
  }
var B1 = class {
  provideCodeActions(t, r, n, i) {
    let s = n.diagnostics
    if (s.length === 0) return Promise.resolve(undefined)
    let o = new R1.CodeAction("Fix using Augment", R1.CodeActionKind.QuickFix)
    return (
      (o.command = {
        command: FixCommand.commandID,
        title: "Fix using Augment",
        arguments: [t.uri, s],
      }),
      Promise.resolve([o])
    )
  }
  resolveCodeAction(t, r) {
    return t
  }
}
var W8 = q(require("vscode"))
var ResetAgentOnboardingCommand = class extends AugmentCommand {
    constructor(chatExtensionEvent, globalState, workspaceStorage) {
      super("Reset Agent Onboarding", true)
      this._chatExtensionEvent = chatExtensionEvent
      this._globalState = globalState
      this._workspaceStorage = workspaceStorage
    }
    static commandID = "augment.resetAgentOnboarding"
    type = "debug"
    async run() {
      await showAugmentPanel("Reset Agent Onboarding"),
        this._chatExtensionEvent.fire("reset-agent-onboarding"),
        await this._globalState.update("memoriesFileOpenCount", 0),
        await this._workspaceStorage.update(ORIENTATION_RUN_COUNT_KEY, 0)
    }
  },
  RunAgentInitialOrientationCommand = class extends SyncingEnabledCommand {
    constructor(extension, apiServer, syncingEnabledTracker) {
      super(syncingEnabledTracker, "Run Agent Initial Orientation", true)
      this._extension = extension
      this._apiServer = apiServer
    }
    static commandID = "vscode-augment.runAgentInitialOrientation"
    type = "debug"
    async run() {
      if (!this._extension.workspaceManager) {
        W8.window.showErrorMessage("Workspace manager is not ready")
        return
      }
      if (!this._extension.agentCheckpointManager) {
        W8.window.showErrorMessage("Agent checkpoint manager is not ready")
        return
      }
      await runAgentInitialOrientation(
        this._apiServer,
        this._extension.workspaceManager,
        this._extension.featureFlagManager,
        this._extension.agentCheckpointManager,
        nh.command,
      )
    }
    canRun() {
      return super.canRun() && this._extension.ready
    }
  }
var AuthCommand = class AuthCommand extends AugmentCommand {
  constructor(authService, oauthFlow, commandId, title) {
    super(title)
    this._auth = authService
    this._oauthFlow = oauthFlow
    this._commandID = commandId
  }
  static signInCommandID = "vscode-augment.signIn"
  static signOutCommandID = "vscode-augment.signOut"
  type = "public"
  async run() {
    this.commandID === AuthCommand.signInCommandID
      ? await this._oauthFlow.startFlow()
      : await this._auth.removeSession()
  }
  canRun() {
    return this._auth.useOAuth
      ? this.commandID === AuthCommand.signOutCommandID
        ? this._auth.isLoggedIn === true
        : !this._auth.isLoggedIn
      : false
  }
}
var Awe = require("child_process"),
  Uv = q(require("fs")),
  Fm = require("path"),
  br = q(require("vscode"))
var G8 = class {
    documents = new Map()
    setDocumentContent(t, r) {
      this.documents.set(t.toString(), r)
    }
    provideTextDocumentContent(t) {
      return this.documents.get(t.toString())
    }
  },
  T1 = class e extends AugmentCommand {
    constructor(r, n) {
      super()
      this._extension = r
      this._apiServer = n
      this._outputChannel = br.window.createOutputChannel(
        "Autofix Command Output",
      )
    }
    static commandID = "vscode-augment.autofixCommand"
    type = "public"
    static testCommandHistory = []
    _outputChannel
    _chunkCount = 32
    _autofixLogger = z("AutofixCommand")
    async _locationToChunkContents(r, n) {
      let i = (0, Fm.join)(n, r.path),
        o = (await Uv.promises.readFile(i, { encoding: "utf8" })).split(`
`),
        a = 0,
        l = Math.max(r.range.start - a, 0),
        c = Math.min(r.range.stop + a, o.length)
      return {
        path: r.path,
        content: o.slice(l, c).join(`
`),
        start_line: l,
        end_line: c,
      }
    }
    _clearAndShowOutput(r) {
      this._outputChannel.clear(),
        this._outputChannel.appendLine(r),
        this._outputChannel.show()
    }
    async _openDiffForChanges(r, n) {
      let i = r.map(async (s) => {
        let o = "virtual",
          a = new G8(),
          l = br.workspace.registerTextDocumentContentProvider(o, a),
          c = br.Uri.parse(`${o}:/${s.path}.right`)
        a.setDocumentContent(c, s.targetContent),
          await br.commands.executeCommand(
            "vscode.diff",
            br.Uri.file((0, Fm.join)(n, s.path)),
            c,
            `Diff - ${s.path}`,
          ),
          await new Promise((u) => {
            let f = br.workspace.onDidCloseTextDocument((p) => {
              p.uri.toString() === c.toString() &&
                (f.dispose(), l.dispose(), u())
            })
          })
      })
      await Promise.all(i)
    }
    async _getTestCommand() {
      let r = br.window.createQuickPick()
      ;(r.placeholder = "Enter the test command to run (e.g. `pytest`)"),
        (r.ignoreFocusOut = true)
      let n = () => {
        let s = r.value ? [{ label: r.value, description: "New command" }] : [],
          o = e.testCommandHistory
            .filter((a) => a.toLowerCase() !== r.value.toLowerCase())
            .map((a) => ({ label: a, description: "Previous command" }))
        r.items = [...s, ...o]
      }
      r.onDidChangeValue(n), n(), r.show()
      let i = await new Promise((s) => {
        r.onDidAccept(() => {
          let o = r.selectedItems[0]?.label || r.value
          s(o || undefined), r.hide()
        }),
          r.onDidHide(() => s(undefined))
      })
      return (
        r.dispose(),
        i &&
          (e.testCommandHistory = [
            i,
            ...e.testCommandHistory.filter((s) => s !== i),
          ].slice(0, 10)),
        i
      )
    }
    _runCommand(r, n, i = false) {
      return (
        i && this._clearAndShowOutput("Running command: " + r),
        new Promise((s) => {
          let o = r.split(" "),
            a = o[0],
            l = o.slice(1),
            c = (0, Awe.spawn)(a, l, {
              cwd: n,
              stdio: ["ignore", "pipe", "pipe"],
              shell: true,
            }),
            u = ""
          c.stdout.on("data", (f) => {
            ;(u += f.toString()), i && this._outputChannel.append(f.toString())
          }),
            c.stderr.on("data", (f) => {
              ;(u += f.toString()),
                i && this._outputChannel.append(f.toString())
            }),
            c.on("close", (f) => {
              s({ output: u, success: f === 0 })
            }),
            c.on("error", (f) => {
              s({ output: f.message, success: false })
            })
        })
      )
    }
    async _askYesNo(r, n = "") {
      let i = { modal: true, detail: n },
        s = [{ title: "Yes" }, { title: "No", isCloseAffordance: true }]
      return (await br.window.showInformationMessage(r, i, ...s)) === s[0]
    }
    async _getEditLocations(r, n, i, s, o, a) {
      let l = await this._apiServer.nextEditLocation(
        a,
        r,
        "",
        n,
        [],
        i,
        [],
        [],
        o,
        false,
      )
      if (l.checkpointNotFound) throw new Error("Checkpoint not found")
      if (l.candidateLocations.length === 0)
        throw new Error("No candidate locations found")
      return Promise.all(
        l.candidateLocations.map(async (c) =>
          this._locationToChunkContents(c.item, s),
        ),
      )
    }
    async _diffToChunks(r) {
      return Promise.all(
        r.map((n) => {
          let i = n.afterContent.split(`
`)
          return {
            path: n.afterPath,
            content: n.afterContent,
            start_line: 0,
            end_line: i.length - 1,
          }
        }),
      )
    }
    async _applyChanges(r, n, i) {
      if (
        n &&
        (await this._askYesNo("Would you like to apply and test the changes?"))
      ) {
        for (let o of r) {
          let { path: a, targetContent: l } = o
          await Uv.promises.writeFile((0, Fm.join)(i, a), l)
        }
        if ((await this._runCommand(n, i, true)).success)
          br.window.showInformationMessage("The tests has passed.")
        else {
          let o = "Command failed. Keep changes anyway?"
          if (!(await this._askYesNo(o, "return code != 0")))
            for (let a of r) {
              let { path: l, sourceContent: c } = a
              await Uv.promises.writeFile((0, Fm.join)(i, l), c)
            }
        }
      }
    }
    _checkOutputReturn(r) {
      return r.success && r.output.length > 0
    }
    async _getGitDiffObject(r, n) {
      let i = `git diff ${r} --name-status -M`,
        o = (await this._runGitCommand(i, n)).split(`
`),
        a = []
      for (let l of o) {
        let [c, ...u] = l.split("	"),
          f = u[0],
          p = u[u.length - 1],
          g
        switch (c[0]) {
          case "M":
            if (((g = nr.modified), f !== p))
              throw new Error("Unexpected change type: modified with rename")
            break
          case "A":
            ;(g = nr.added), (f = "")
            break
          case "D":
            ;(g = nr.deleted), (p = "")
            break
          case "R":
            if (((g = nr.renamed), f === p))
              throw new Error("Unexpected change type: rename with no change")
            break
          default:
            continue
        }
        let m = "",
          y = ""
        if (g !== nr.added) {
          let v = `git show ${r}:${f}`,
            C = await this._runCommand(v, n)
          if (!C.success) throw new Error("Failed to execute git command")
          m = C.output
        }
        if (g !== nr.deleted) {
          let v = (0, Fm.join)(n, p)
          y = await Uv.promises.readFile(v, { encoding: "utf8" })
        }
        a.push({
          beforePath: f,
          afterPath: p,
          changeType: g,
          beforeContent: m,
          afterContent: y,
        })
      }
      return a
    }
    _diffToVCSChange(r) {
      let n = new HashCalculator(1e3)
      return {
        commits: [],
        workingDirectory: r.map((i) => {
          let s = n.calculateNoThrow(i.afterPath, i.afterContent) || "",
            o = n.calculateNoThrow(i.afterPath, i.afterContent) || ""
          return {
            beforePath: i.beforePath,
            afterPath: i.afterPath,
            changeType: i.changeType,
            headBlobName: s,
            indexedBlobName: o,
            currentBlobName: o,
          }
        }),
      }
    }
    async _uploadBlobs(r, n) {
      let i = []
      r.workingDirectory.forEach((s, o) => {
        s.currentBlobName &&
          i.push({
            pathName: s.afterPath || "",
            text: n[o].afterContent,
            blobName: s.currentBlobName,
            metadata: [],
          }),
          s.headBlobName &&
            i.push({
              pathName: s.beforePath || "",
              text: n[o].beforeContent,
              blobName: s.headBlobName,
              metadata: [],
            })
      })
      try {
        await Promise.all(i.map((s) => this._apiServer.batchUpload([s])))
      } catch {}
    }
    async _runGitCommand(r, n) {
      let i = await this._runCommand(r, n)
      if (!this._checkOutputReturn(i))
        throw new Error(`Failed to execute git command: ${r}
Output: ${i.output}`)
      return i.output.trimEnd()
    }
    async run() {
      if (!this._extension.workspaceManager)
        throw new Error("Workspace manager is not ready")
      let r = this._extension.workspaceManager.getContext()
      if (
        !br.workspace.workspaceFolders ||
        br.workspace.workspaceFolders.length === 0
      ) {
        br.window.showErrorMessage("No workspace folders")
        return
      }
      let n = br.workspace.workspaceFolders[0].uri.fsPath,
        i = await this._runGitCommand("git rev-parse --show-toplevel", n),
        s = await this._runGitCommand(
          "git rev-parse --abbrev-ref origin/HEAD",
          i,
        ),
        o = await this._runGitCommand("git rev-parse --abbrev-ref HEAD", i),
        a = (Q) => Q.slice(Q.lastIndexOf("/") + 1),
        l = "HEAD"
      a(o) !== a(s) &&
        (l = await this._runGitCommand(`git merge-base HEAD ${s}`, i))
      let c = `git diff -U10 ${l}`,
        u = await this._runCommand(c, i)
      if (!this._checkOutputReturn(u)) {
        br.window.showErrorMessage(`Failed to get git diff: ${u.output}`)
        return
      }
      let f
      try {
        f = await this._getGitDiffObject(l, i)
      } catch (Q) {
        br.window.showErrorMessage(
          `Failed to parse git diff: ${Q instanceof Error ? Q.message : String(Q)}`,
        )
        return
      }
      let p = this._diffToVCSChange(f)
      try {
        await this._uploadBlobs(p, f)
      } catch (Q) {
        br.window.showErrorMessage(
          `Failed to upload blobs: ${Q instanceof Error ? Q.message : String(Q)}`,
        )
        return
      }
      let g = await this._getTestCommand()
      if (!g) {
        br.window.showInformationMessage("No test command provided.")
        return
      }
      let m = await this._runCommand(g, i, true),
        y = "The tests has passed, would you like to continue anyway?"
      if (m.success && !(await this._askYesNo(y, "return code: 0"))) return
      if (m.output.length === 0) {
        br.window.showInformationMessage("No command output found.")
        return
      }
      let v = this._apiServer.createRequestId()
      this._autofixLogger.info(`Requesting edit locations with requestId=${v}`)
      let C = this._getEditLocations(
        m.output,
        p,
        r.blobs,
        i,
        this._chunkCount,
        v,
      )
      ;(v = this._apiServer.createRequestId()),
        this._autofixLogger.info(`Requesting check command with requestId=${v}`)
      let E = this._apiServer.checkCommand(g, m.output, v)
      ;(v = this._apiServer.createRequestId()),
        this._autofixLogger.info(
          `Requesting contain errors with requestId=${v}`,
        )
      let w = this._apiServer.containErrors(g, m.output, v)
      try {
        let Q = await E,
          se = "Command doesn't appear code-related. Continue anyway?"
        if (Q.result)
          br.window.showInformationMessage("\u2705 Command check passed.")
        else if (!(await this._askYesNo(se, Q.desc))) return
      } catch (Q) {
        br.window.showErrorMessage(
          `Failed to check command: ${Q instanceof Error ? Q.message : String(Q)}`,
        )
        return
      }
      try {
        let Q = await w,
          se = "Couldn't find errors in the output. Continue anyway?"
        if (Q.result)
          br.window.showInformationMessage(
            "\u2705 Contain errors check passed.",
          )
        else if (!(await this._askYesNo(se, Q.desc))) return
      } catch (Q) {
        br.window.showErrorMessage(
          `Failed to check for errors: ${Q instanceof Error ? Q.message : String(Q)}`,
        )
        return
      }
      let B
      try {
        B = await C
      } catch (Q) {
        br.window.showErrorMessage(
          `Failed to get edit locations: ${Q instanceof Error ? Q.message : String(Q)}`,
        )
        return
      }
      let T = f.filter((Q) => Q.afterPath !== ""),
        N = T.map((Q) => Q.afterPath),
        W = await this._diffToChunks(T),
        Z = B.filter((Q) => !N.includes(Q.path)).concat(W)
      br.window.showInformationMessage(
        `Found ${B.length} potential edit locations.`,
      ),
        br.window.showInformationMessage("Creating fix plan...")
      let te
      try {
        ;(v = this._apiServer.createRequestId()),
          this._autofixLogger.info(
            `Requesting create fix plan with requestId=${v}`,
          ),
          (te = await this._apiServer.createFixPlan(
            u.output,
            g,
            m.output,
            Z,
            v,
          ))
      } catch (Q) {
        br.window.showErrorMessage(
          `Failed to create fix plan: ${Q instanceof Error ? Q.message : String(Q)}`,
        )
        return
      }
      let Y = `Changes:
${te.changes.map((Q) => `- ${Q.path}`).join(`
`)}`,
        U = `${te.fix_desc}

${Y}`,
        ce = Promise.all(
          te.changes.map(async (Q) => {
            let se = (0, Fm.join)(i, Q.path),
              J = await Uv.promises.readFile(se, { encoding: "utf8" })
            return (
              (v = this._apiServer.createRequestId()),
              this._autofixLogger.info(
                `Requesting apply file fix with requestId=${v}`,
              ),
              this._apiServer.applyFileFix(Q, J, v)
            )
          }),
        )
      if (!(await this._askYesNo("Do you confirm the the following fix?", U)))
        return
      br.window.showInformationMessage("Generating patch...")
      let Ie
      try {
        Ie = await ce
      } catch (Q) {
        br.window.showErrorMessage(
          `Failed to generate patch: ${Q instanceof Error ? Q.message : String(Q)}`,
        )
        return
      }
      if (
        ((Ie = Ie.filter((Q) => Q.targetContent !== Q.sourceContent)),
        Ie.length === 0)
      ) {
        br.window.showWarningMessage("Sorry, no changes to apply.")
        return
      }
      br.window.showInformationMessage("Close all diff views to continue.")
      try {
        await this._openDiffForChanges(Ie, i)
      } catch (Q) {
        Q instanceof Error &&
          br.window.showErrorMessage(`Failed to open diff views: ${Q.message}`)
        return
      }
      try {
        await this._applyChanges(Ie, g, i)
      } catch (Q) {
        br.window.showErrorMessage(
          `Failed to apply changes: ${Q instanceof Error ? Q.message : String(Q)}`,
        )
        return
      }
    }
  }
var iQ = q(require("vscode"))
var Pi = q(require("vscode"))
var Qm = q(require("vscode"))
var Zx = ((n) => (
    (n.showDiffInHover = "showDiffInHover"),
    (n.highlightSuggestionsInTheEditor = "highlightSuggestionsInTheEditor"),
    (n.enableAutoApply = "enableAutoApply"),
    n
  ))(Zx || {}),
  NextEditConfigManager = class extends DisposableContainer {
    constructor(configListener, featureFlagManager, augmentGlobalState) {
      super()
      this.configListener = configListener
      this.featureFlagManager = featureFlagManager
      this.augmentGlobalState = augmentGlobalState
      augmentGlobalState.update("nextEditUxMigrationStatus", undefined)
    }
    get config() {
      return getNextEditConfig(this.configListener.config, this.featureFlagManager)
    }
    async toggleSetting(settingName) {
      let configuration = Qm.workspace.getConfiguration("augment"),
        configPath = "nextEdit." + Zx[settingName],
        inspectedConfig = configuration.inspect(configPath),
        targetScope = Qm.ConfigurationTarget.Global
      return (
        inspectedConfig?.workspaceValue !== undefined && (targetScope = Qm.ConfigurationTarget.Workspace),
        configuration.update(configPath, !this.configListener.config.nextEdit[settingName], targetScope)
      )
    }
    async setGlobalBooleanSetting(settingName, value) {
      let configuration = Qm.workspace.getConfiguration("augment"),
        configPath = "nextEdit." + Zx[settingName]
      return configuration.update(configPath, value, Qm.ConfigurationTarget.Global)
    }
  }
function getNextEditConfig(config, featureFlagManager) {
  return {
    enableAutoApply: config.nextEdit.enableAutoApply,
    showDiffInHover: config.nextEdit.showDiffInHover,
    enablePanel:
      config.nextEdit.enableBottomPanel ??
      isMinVersionMet(featureFlagManager.currentFlags.vscodeNextEditBottomPanelMinVersion) ??
      false,
  }
}
var an = class extends SyncingEnabledCommand {
    constructor(r, n, i, s, o = true, a = false) {
      super(i, s, o)
      this._extension = r
      this._configListener = n
      this._isFileRequired = a
    }
    type = "debug"
    static _generateHref(r, n, ...i) {
      return `command:${r}?${encodeURIComponent(JSON.stringify([n, ...i]))}`
    }
    canRun() {
      return (
        super.canRun() &&
        this._extension.ready &&
        isVersionSupported(
          this._configListener.config,
          this._extension.featureFlagManager.currentFlags
            .vscodeNextEditMinVersion,
        ) &&
        (this._isFileRequired ? Pi.window.activeTextEditor !== undefined : true)
      )
    }
    _getEventSource(r) {
      if (r.length === 0) return "command"
      for (let n in Fs) {
        if (!isNaN(Number(n))) continue
        let i = Fs[n]
        if (r[0] === i) return i
      }
      return r.length === 2 && r[0] instanceof Pi.Uri && "groupId" in r[1]
        ? "editor-action-click"
        : r.length === 1 && r[0] instanceof Pi.Uri
          ? "right-click"
          : r.length === 1 && r[0] === undefined
            ? "next-edit-panel-item-click"
            : "command"
    }
  },
  ForceNextEditCommand = class extends an {
    type = "public"
    static commandID = "vscode-augment.next-edit.force"
    constructor(t, r, n) {
      super(t, r, n, undefined, undefined, true)
    }
    canRun() {
      return super.canRun()
    }
    run(...t) {
      this._extension.forceNextEditSuggestion(this._getEventSource(t))
    }
  },
  UpdateNextEditCommand = class extends an {
    type = "public"
    static commandID = "vscode-augment.next-edit.update"
    constructor(t, r, n) {
      super(t, r, n, undefined, true, false)
    }
    run(...t) {
      this._extension.nextEditUpdate(this._getEventSource(t))
    }
  },
  UpdateNextEditLoadingCommand = class extends an {
    type = "private"
    static commandID = "_vscode-augment.next-edit.update.loading"
    constructor(t, r, n) {
      super(t, r, n, undefined, false)
    }
    run() {
      this._extension.noopClicked()
    }
  },
  UpdateNextEditDisabledNoChangesCommand = class extends an {
    type = "private"
    static commandID = "_vscode-augment.next-edit.update.disabled-no-changes"
    constructor(t, r, n) {
      super(t, r, n, undefined, false)
    }
    run() {
      this._extension.noopClicked()
    }
  },
  UpdateNextEditDisabledCachedCommand = class extends an {
    type = "private"
    static commandID = "_vscode-augment.next-edit.update.disabled-cached"
    constructor(t, r, n) {
      super(t, r, n, undefined, false)
    }
    run() {
      this._extension.noopClicked()
    }
  },
  AcceptNextEditCommand = class extends an {
    type = "public"
    static commandID = "vscode-augment.next-edit.background.accept"
    constructor(t, r, n) {
      super(t, r, n, undefined)
    }
    static generateHref(t, r) {
      return super._generateHref(this.commandID, t, r)
    }
    run(...t) {
      this._extension.editorNextEdit?.accept(
        this._getEventSource(t),
        undefined,
        typeof t[1] == "string" ? t[1] : undefined,
      )
    }
  },
  AcceptAllNextEditCommand = class extends an {
    type = "public"
    static commandID = "vscode-augment.next-edit.background.accept-all"
    constructor(t, r, n) {
      super(t, r, n, undefined, true)
    }
    run(...t) {
      this._extension.editorNextEdit?.acceptAllSuggestions(
        this._getEventSource(t),
      )
    }
  },
  AcceptNextEditCodeActionCommand = class extends an {
    type = "private"
    static commandID = "_vscode-augment.next-edit.background.accept-code-action"
    constructor(t, r, n) {
      super(t, r, n, undefined, false)
    }
    run(t) {
      this._extension.editorNextEdit?.acceptSuggestion(t, "code-action")
    }
  },
  RejectNextEditCommand = class extends an {
    type = "public"
    static commandID = "vscode-augment.next-edit.background.reject"
    constructor(t, r, n) {
      super(t, r, n, undefined)
    }
    static generateHref(t = "hover-click", r) {
      return super._generateHref(this.commandID, t, r)
    }
    run(...t) {
      this._extension.editorNextEdit?.reject(
        this._getEventSource(t),
        typeof t[1] == "string" ? t[1] : undefined,
      )
    }
  },
  RejectAllNextEditCommand = class extends an {
    type = "public"
    static commandID = "vscode-augment.next-edit.background.reject-all"
    constructor(t, r, n) {
      super(t, r, n, undefined, true)
    }
    run(...t) {
      this._extension.editorNextEdit?.rejectAllSuggestions(
        this._getEventSource(t),
      )
    }
  },
  DismissNextEditCommand = class extends an {
    type = "public"
    static commandID = "vscode-augment.next-edit.background.dismiss"
    constructor(t, r, n) {
      super(t, r, n, undefined)
    }
    run(...t) {
      this._extension.editorNextEdit?.dismissOrReject(this._getEventSource(t))
    }
  },
  NextEditNavigateCommand = class extends an {
    type = "public"
    static commandID = "vscode-augment.next-edit.background.next"
    constructor(t, r, n) {
      super(t, r, n, undefined)
    }
    run(...t) {
      this._extension.editorNextEdit?.gotoNextSmart(this._getEventSource(t))
    }
  },
  NextEditForwardCommand = class extends an {
    type = "public"
    static commandID = "vscode-augment.next-edit.background.next-forward"
    constructor(t, r, n) {
      super(t, r, n, undefined)
    }
    run(...t) {
      this._extension.editorNextEdit?.next(this._getEventSource(t))
    }
  },
  NextEditPreviousCommand = class extends an {
    type = "public"
    static commandID = "vscode-augment.next-edit.background.previous"
    constructor(t, r, n) {
      super(t, r, n, undefined)
    }
    run(...t) {
      this._extension.editorNextEdit?.previous(this._getEventSource(t))
    }
  },
  OpenNextEditCommand = class extends an {
    type = "private"
    static commandID = "_vscode-augment.next-edit.background.open"
    constructor(t, r, n) {
      super(t, r, n, undefined, false)
    }
    run(...t) {
      let r = t[0]
      this._extension.editorNextEdit?.openSuggestionAt(r.uri, r.lineNumber - 1)
    }
  },
  ToggleNextEditPanelSplitCommand = class extends an {
    type = "public"
    static commandID = "vscode-augment.next-edit.toggle-panel-horizontal-split"
    constructor(t, r, n) {
      super(t, r, n, undefined, false)
    }
    run(...t) {
      this._extension.nextEditTogglePanelHorizontalSplit(
        this._getEventSource(t),
      )
    }
  },
  LearnMoreNextEditCommand = class extends an {
    type = "public"
    static commandID = "vscode-augment.next-edit.learn-more"
    constructor(t, r, n) {
      super(t, r, n, undefined, true)
    }
    static generateHref(t = "hover-click", r) {
      return super._generateHref(this.commandID, t, r)
    }
    run(...t) {
      this._extension.nextEditLearnMore(this._getEventSource(t))
    }
  },
  NextForwardDisabledCommand = class extends an {
    type = "private"
    static commandID =
      "_vscode-augment.next-edit.background.next-forward.disabled"
    constructor(t, r, n) {
      super(t, r, n, undefined, false)
    }
    run() {
      this._extension.noopClicked()
    }
  },
  PreviousDisabledCommand = class extends an {
    type = "private"
    static commandID = "_vscode-augment.next-edit.background.previous.disabled"
    constructor(t, r, n) {
      super(t, r, n, undefined, false)
    }
    run() {
      this._extension.noopClicked()
    }
  },
  OpenNextEditPanelCommand = class extends an {
    constructor(r, n, i) {
      super(r, n, i, undefined, r.nextEditConfigManager.config.enablePanel)
      this.extension = r
    }
    type = "public"
    static commandID = "vscode-augment.next-edit.open-panel"
    get showInActionPanel() {
      return this.extension.nextEditConfigManager.config.enablePanel
    }
    static generateHref(r = "hover-click", n) {
      return "command:augment-next-edit.focus"
    }
    run(...r) {
      this._extension.openNextEditPanel(this._getEventSource(r))
    }
  },
  UndoAcceptSuggestionCommand = class extends an {
    type = "private"
    static commandID = "_vscode-augment.next-edit.undo-accept-suggestion"
    constructor(t, r, n) {
      super(t, r, n, undefined, false)
    }
    static generateHref(t = "hover-click", r) {
      return super._generateHref(this.commandID, t, r)
    }
    run(...t) {
      this._extension.editorNextEdit?.undoAcceptSuggestion(
        undefined,
        this._getEventSource(t),
      )
    }
  },
  ToggleHoverDiffCommand = class extends an {
    type = "private"
    static commandID = "_vscode-augment.next-edit.toggle-hover-diff"
    constructor(t, r, n) {
      super(t, r, n, undefined, false)
    }
    static generateHref(t = "hover-click", r) {
      return super._generateHref(this.commandID, t, r)
    }
    run(...t) {
      this._extension.editorNextEdit?.toggleHoverDiff(
        this._getEventSource(t),
        typeof t[1] == "string" ? t[1] : undefined,
      )
    }
  },
  ToggleBackgroundSuggestionsCommand = class e extends an {
    type = "public"
    static commandID = "vscode-augment.next-edit.toggle-bg"
    static backgroundSuggestionsConfigKey =
      "nextEdit.enableBackgroundSuggestions"
    defaultParams = { promptFirst: false, newValue: undefined }
    constructor(t, r, n) {
      super(
        t,
        r,
        n,
        () =>
          r.config.nextEdit.enableBackgroundSuggestions
            ? "Turn Background Suggestions Off"
            : "Turn Background Suggestions On",
        true,
      )
    }
    async run(t) {
      let r = { ...this.defaultParams, ...t },
        n = Pi.workspace.getConfiguration("augment"),
        i = n.inspect(e.backgroundSuggestionsConfigKey),
        s = Pi.ConfigurationTarget.Global
      i?.workspaceValue !== undefined && (s = Pi.ConfigurationTarget.Workspace)
      let o =
        r.newValue ??
        !this._configListener.config.nextEdit.enableBackgroundSuggestions
      if (r.promptFirst && o === false) {
        let a = await Pi.window.showErrorMessage(
          "Are you sure you want to disable Next Edit Suggestions?",
          {
            modal: true,
            detail:
              "You can re-enable them in Settings > Augment > Enable Background Suggestions.",
          },
          "Disable",
          "Go to Settings",
        )
        if (
          (a === "Go to Settings" &&
            Pi.commands.executeCommand(
              "workbench.action.openSettings",
              "@ext:augment.vscode-augment nextEdit.enableBackgroundSuggestions",
            ),
          a !== "Disable")
        )
          return
      }
      await n.update(e.backgroundSuggestionsConfigKey, o, s)
    }
  },
  ToggleHighlightsCommand = class extends an {
    type = "public"
    static commandID = "vscode-augment.next-edit.toggle-all-highlights"
    constructor(t, r, n) {
      super(t, r, n, () =>
        this._configListener.config.nextEdit.highlightSuggestionsInTheEditor
          ? "Turn Off All Line Highlights"
          : "Turn On All Line Highlights",
      )
    }
    canRun() {
      return super.canRun()
    }
    run() {
      this._extension.nextEditConfigManager.toggleSetting(
        "highlightSuggestionsInTheEditor",
      )
    }
  },
  EnableBackgroundSuggestionsCommand = class e extends an {
    type = "public"
    static commandID = "vscode-augment.next-edit.enable-bg"
    static backgroundSuggestionsConfigKey =
      "nextEdit.enableBackgroundSuggestions"
    constructor(t, r, n) {
      super(t, r, n, () => "Enable Background Suggestions", true)
    }
    canRun() {
      return (
        super.canRun() &&
        this._extension.ready &&
        !this._configListener.config.nextEdit.enableBackgroundSuggestions
      )
    }
    async run() {
      let t = Pi.workspace.getConfiguration("augment")
      if (t.get(e.backgroundSuggestionsConfigKey)) return
      let r = t.inspect(e.backgroundSuggestionsConfigKey),
        n = Pi.ConfigurationTarget.Global
      r?.workspaceValue !== undefined && (n = Pi.ConfigurationTarget.Workspace),
        await t.update(e.backgroundSuggestionsConfigKey, true, n)
    }
  },
  DisableBackgroundSuggestionsCommand = class e extends an {
    type = "public"
    static commandID = "vscode-augment.next-edit.disable-bg"
    static backgroundSuggestionsConfigKey =
      "nextEdit.enableBackgroundSuggestions"
    constructor(t, r, n) {
      super(t, r, n, () => "Disable Background Suggestions", true)
    }
    canRun() {
      return (
        super.canRun() &&
        this._extension.ready &&
        this._configListener.config.nextEdit.enableBackgroundSuggestions
      )
    }
    async run() {
      let t = Pi.workspace.getConfiguration("augment")
      if (!t.get(EnableBackgroundSuggestionsCommand.backgroundSuggestionsConfigKey)) return
      let r = t.inspect(e.backgroundSuggestionsConfigKey),
        n = Pi.ConfigurationTarget.Global
      r?.workspaceValue !== undefined && (n = Pi.ConfigurationTarget.Workspace),
        await t.update(e.backgroundSuggestionsConfigKey, false, n)
    }
  },
  ResetNextEditOnboardingCommand = class e extends an {
    constructor(r, n, i, s) {
      super(r, n, i, e.title)
      this._globalState = s
    }
    static title = "Reset Next Edit Onboarding"
    static commandID = "_vscode-augment.next-edit.reset-onboarding"
    type = "debug"
    canRun() {
      return this._configListener.config.enableDebugFeatures && super.canRun()
    }
    async run() {
      await this._globalState.update("nextEditSuggestionSeen", undefined),
        await this._globalState.update("nextEditSuggestionAccepted", undefined),
        await this._globalState.update("nextEditKeybindingUsageCount", undefined),
        await this._globalState.update("nextEditUxMigrationStatus", undefined)
    }
  },
  OpenNextEditSettingsCommand = class extends an {
    static commandID = "vscode-augment.next-edit.settings"
    type = "public"
    constructor(t, r, n) {
      super(t, r, n, () => "Enable Background Suggestions", false)
    }
    run() {
      Pi.commands.executeCommand(
        "workbench.action.openSettings",
        "@ext:augment.vscode-augment augment.nextEdit",
      )
    }
  }
var rQ = q(require("fs")),
  Qwe = q(e6()),
  Nwe = q(require("os")),
  Pwe = q(require("path")),
  Zl = q(require("vscode"))
var rw = class {
    _keyCodeToStr
    _strToKeyCode
    constructor() {
      ;(this._keyCodeToStr = []), (this._strToKeyCode = Object.create(null))
    }
    define(t, r) {
      ;(this._keyCodeToStr[t] = r), (this._strToKeyCode[r.toLowerCase()] = t)
    }
    keyCodeToStr(t) {
      return this._keyCodeToStr[t]
    }
    strToKeyCode(t) {
      return this._strToKeyCode[t.toLowerCase()] || 0
    }
  },
  j1 = new rw(),
  t6 = new rw(),
  r6 = new rw(),
  bCt = new Array(230),
  ECt = {},
  Bwe = [],
  Rwe = Object.create(null),
  Dwe = Object.create(null),
  Z1 = {
    lowerCaseToEnum: (e) => Dwe[e] || 0,
    toEnum: (e) => Rwe[e] || 0,
    toString: (e) => Bwe[e] || "None",
  },
  Twe = [],
  n6 = []
for (let e = 0; e <= 193; e++) Twe[e] = -1
for (let e = 0; e <= 132; e++) n6[e] = -1
;(function () {
  let e = "",
    t = [
      [1, 0, "None", 0, "unknown", 0, "VK_UNKNOWN", e, e],
      [1, 1, "Hyper", 0, e, 0, e, e, e],
      [1, 2, "Super", 0, e, 0, e, e, e],
      [1, 3, "Fn", 0, e, 0, e, e, e],
      [1, 4, "FnLock", 0, e, 0, e, e, e],
      [1, 5, "Suspend", 0, e, 0, e, e, e],
      [1, 6, "Resume", 0, e, 0, e, e, e],
      [1, 7, "Turbo", 0, e, 0, e, e, e],
      [1, 8, "Sleep", 0, e, 0, "VK_SLEEP", e, e],
      [1, 9, "WakeUp", 0, e, 0, e, e, e],
      [0, 10, "KeyA", 31, "A", 65, "VK_A", e, e],
      [0, 11, "KeyB", 32, "B", 66, "VK_B", e, e],
      [0, 12, "KeyC", 33, "C", 67, "VK_C", e, e],
      [0, 13, "KeyD", 34, "D", 68, "VK_D", e, e],
      [0, 14, "KeyE", 35, "E", 69, "VK_E", e, e],
      [0, 15, "KeyF", 36, "F", 70, "VK_F", e, e],
      [0, 16, "KeyG", 37, "G", 71, "VK_G", e, e],
      [0, 17, "KeyH", 38, "H", 72, "VK_H", e, e],
      [0, 18, "KeyI", 39, "I", 73, "VK_I", e, e],
      [0, 19, "KeyJ", 40, "J", 74, "VK_J", e, e],
      [0, 20, "KeyK", 41, "K", 75, "VK_K", e, e],
      [0, 21, "KeyL", 42, "L", 76, "VK_L", e, e],
      [0, 22, "KeyM", 43, "M", 77, "VK_M", e, e],
      [0, 23, "KeyN", 44, "N", 78, "VK_N", e, e],
      [0, 24, "KeyO", 45, "O", 79, "VK_O", e, e],
      [0, 25, "KeyP", 46, "P", 80, "VK_P", e, e],
      [0, 26, "KeyQ", 47, "Q", 81, "VK_Q", e, e],
      [0, 27, "KeyR", 48, "R", 82, "VK_R", e, e],
      [0, 28, "KeyS", 49, "S", 83, "VK_S", e, e],
      [0, 29, "KeyT", 50, "T", 84, "VK_T", e, e],
      [0, 30, "KeyU", 51, "U", 85, "VK_U", e, e],
      [0, 31, "KeyV", 52, "V", 86, "VK_V", e, e],
      [0, 32, "KeyW", 53, "W", 87, "VK_W", e, e],
      [0, 33, "KeyX", 54, "X", 88, "VK_X", e, e],
      [0, 34, "KeyY", 55, "Y", 89, "VK_Y", e, e],
      [0, 35, "KeyZ", 56, "Z", 90, "VK_Z", e, e],
      [0, 36, "Digit1", 22, "1", 49, "VK_1", e, e],
      [0, 37, "Digit2", 23, "2", 50, "VK_2", e, e],
      [0, 38, "Digit3", 24, "3", 51, "VK_3", e, e],
      [0, 39, "Digit4", 25, "4", 52, "VK_4", e, e],
      [0, 40, "Digit5", 26, "5", 53, "VK_5", e, e],
      [0, 41, "Digit6", 27, "6", 54, "VK_6", e, e],
      [0, 42, "Digit7", 28, "7", 55, "VK_7", e, e],
      [0, 43, "Digit8", 29, "8", 56, "VK_8", e, e],
      [0, 44, "Digit9", 30, "9", 57, "VK_9", e, e],
      [0, 45, "Digit0", 21, "0", 48, "VK_0", e, e],
      [1, 46, "Enter", 3, "Enter", 13, "VK_RETURN", e, e],
      [1, 47, "Escape", 9, "Escape", 27, "VK_ESCAPE", e, e],
      [1, 48, "Backspace", 1, "Backspace", 8, "VK_BACK", e, e],
      [1, 49, "Tab", 2, "Tab", 9, "VK_TAB", e, e],
      [1, 50, "Space", 10, "Space", 32, "VK_SPACE", e, e],
      [0, 51, "Minus", 88, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
      [0, 52, "Equal", 86, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
      [0, 53, "BracketLeft", 92, "[", 219, "VK_OEM_4", "[", "OEM_4"],
      [0, 54, "BracketRight", 94, "]", 221, "VK_OEM_6", "]", "OEM_6"],
      [0, 55, "Backslash", 93, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
      [0, 56, "IntlHash", 0, e, 0, e, e, e],
      [0, 57, "Semicolon", 85, ";", 186, "VK_OEM_1", ";", "OEM_1"],
      [0, 58, "Quote", 95, "'", 222, "VK_OEM_7", "'", "OEM_7"],
      [0, 59, "Backquote", 91, "`", 192, "VK_OEM_3", "`", "OEM_3"],
      [0, 60, "Comma", 87, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
      [0, 61, "Period", 89, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
      [0, 62, "Slash", 90, "/", 191, "VK_OEM_2", "/", "OEM_2"],
      [1, 63, "CapsLock", 8, "CapsLock", 20, "VK_CAPITAL", e, e],
      [1, 64, "F1", 59, "F1", 112, "VK_F1", e, e],
      [1, 65, "F2", 60, "F2", 113, "VK_F2", e, e],
      [1, 66, "F3", 61, "F3", 114, "VK_F3", e, e],
      [1, 67, "F4", 62, "F4", 115, "VK_F4", e, e],
      [1, 68, "F5", 63, "F5", 116, "VK_F5", e, e],
      [1, 69, "F6", 64, "F6", 117, "VK_F6", e, e],
      [1, 70, "F7", 65, "F7", 118, "VK_F7", e, e],
      [1, 71, "F8", 66, "F8", 119, "VK_F8", e, e],
      [1, 72, "F9", 67, "F9", 120, "VK_F9", e, e],
      [1, 73, "F10", 68, "F10", 121, "VK_F10", e, e],
      [1, 74, "F11", 69, "F11", 122, "VK_F11", e, e],
      [1, 75, "F12", 70, "F12", 123, "VK_F12", e, e],
      [1, 76, "PrintScreen", 0, e, 0, e, e, e],
      [1, 77, "ScrollLock", 84, "ScrollLock", 145, "VK_SCROLL", e, e],
      [1, 78, "Pause", 7, "PauseBreak", 19, "VK_PAUSE", e, e],
      [1, 79, "Insert", 19, "Insert", 45, "VK_INSERT", e, e],
      [1, 80, "Home", 14, "Home", 36, "VK_HOME", e, e],
      [1, 81, "PageUp", 11, "PageUp", 33, "VK_PRIOR", e, e],
      [1, 82, "Delete", 20, "Delete", 46, "VK_DELETE", e, e],
      [1, 83, "End", 13, "End", 35, "VK_END", e, e],
      [1, 84, "PageDown", 12, "PageDown", 34, "VK_NEXT", e, e],
      [1, 85, "ArrowRight", 17, "RightArrow", 39, "VK_RIGHT", "Right", e],
      [1, 86, "ArrowLeft", 15, "LeftArrow", 37, "VK_LEFT", "Left", e],
      [1, 87, "ArrowDown", 18, "DownArrow", 40, "VK_DOWN", "Down", e],
      [1, 88, "ArrowUp", 16, "UpArrow", 38, "VK_UP", "Up", e],
      [1, 89, "NumLock", 83, "NumLock", 144, "VK_NUMLOCK", e, e],
      [1, 90, "NumpadDivide", 113, "NumPad_Divide", 111, "VK_DIVIDE", e, e],
      [
        1,
        91,
        "NumpadMultiply",
        108,
        "NumPad_Multiply",
        106,
        "VK_MULTIPLY",
        e,
        e,
      ],
      [
        1,
        92,
        "NumpadSubtract",
        111,
        "NumPad_Subtract",
        109,
        "VK_SUBTRACT",
        e,
        e,
      ],
      [1, 93, "NumpadAdd", 109, "NumPad_Add", 107, "VK_ADD", e, e],
      [1, 94, "NumpadEnter", 3, e, 0, e, e, e],
      [1, 95, "Numpad1", 99, "NumPad1", 97, "VK_NUMPAD1", e, e],
      [1, 96, "Numpad2", 100, "NumPad2", 98, "VK_NUMPAD2", e, e],
      [1, 97, "Numpad3", 101, "NumPad3", 99, "VK_NUMPAD3", e, e],
      [1, 98, "Numpad4", 102, "NumPad4", 100, "VK_NUMPAD4", e, e],
      [1, 99, "Numpad5", 103, "NumPad5", 101, "VK_NUMPAD5", e, e],
      [1, 100, "Numpad6", 104, "NumPad6", 102, "VK_NUMPAD6", e, e],
      [1, 101, "Numpad7", 105, "NumPad7", 103, "VK_NUMPAD7", e, e],
      [1, 102, "Numpad8", 106, "NumPad8", 104, "VK_NUMPAD8", e, e],
      [1, 103, "Numpad9", 107, "NumPad9", 105, "VK_NUMPAD9", e, e],
      [1, 104, "Numpad0", 98, "NumPad0", 96, "VK_NUMPAD0", e, e],
      [1, 105, "NumpadDecimal", 112, "NumPad_Decimal", 110, "VK_DECIMAL", e, e],
      [0, 106, "IntlBackslash", 97, "OEM_102", 226, "VK_OEM_102", e, e],
      [1, 107, "ContextMenu", 58, "ContextMenu", 93, e, e, e],
      [1, 108, "Power", 0, e, 0, e, e, e],
      [1, 109, "NumpadEqual", 0, e, 0, e, e, e],
      [1, 110, "F13", 71, "F13", 124, "VK_F13", e, e],
      [1, 111, "F14", 72, "F14", 125, "VK_F14", e, e],
      [1, 112, "F15", 73, "F15", 126, "VK_F15", e, e],
      [1, 113, "F16", 74, "F16", 127, "VK_F16", e, e],
      [1, 114, "F17", 75, "F17", 128, "VK_F17", e, e],
      [1, 115, "F18", 76, "F18", 129, "VK_F18", e, e],
      [1, 116, "F19", 77, "F19", 130, "VK_F19", e, e],
      [1, 117, "F20", 78, "F20", 131, "VK_F20", e, e],
      [1, 118, "F21", 79, "F21", 132, "VK_F21", e, e],
      [1, 119, "F22", 80, "F22", 133, "VK_F22", e, e],
      [1, 120, "F23", 81, "F23", 134, "VK_F23", e, e],
      [1, 121, "F24", 82, "F24", 135, "VK_F24", e, e],
      [1, 122, "Open", 0, e, 0, e, e, e],
      [1, 123, "Help", 0, e, 0, e, e, e],
      [1, 124, "Select", 0, e, 0, e, e, e],
      [1, 125, "Again", 0, e, 0, e, e, e],
      [1, 126, "Undo", 0, e, 0, e, e, e],
      [1, 127, "Cut", 0, e, 0, e, e, e],
      [1, 128, "Copy", 0, e, 0, e, e, e],
      [1, 129, "Paste", 0, e, 0, e, e, e],
      [1, 130, "Find", 0, e, 0, e, e, e],
      [
        1,
        131,
        "AudioVolumeMute",
        117,
        "AudioVolumeMute",
        173,
        "VK_VOLUME_MUTE",
        e,
        e,
      ],
      [
        1,
        132,
        "AudioVolumeUp",
        118,
        "AudioVolumeUp",
        175,
        "VK_VOLUME_UP",
        e,
        e,
      ],
      [
        1,
        133,
        "AudioVolumeDown",
        119,
        "AudioVolumeDown",
        174,
        "VK_VOLUME_DOWN",
        e,
        e,
      ],
      [
        1,
        134,
        "NumpadComma",
        110,
        "NumPad_Separator",
        108,
        "VK_SEPARATOR",
        e,
        e,
      ],
      [0, 135, "IntlRo", 115, "ABNT_C1", 193, "VK_ABNT_C1", e, e],
      [1, 136, "KanaMode", 0, e, 0, e, e, e],
      [0, 137, "IntlYen", 0, e, 0, e, e, e],
      [1, 138, "Convert", 0, e, 0, e, e, e],
      [1, 139, "NonConvert", 0, e, 0, e, e, e],
      [1, 140, "Lang1", 0, e, 0, e, e, e],
      [1, 141, "Lang2", 0, e, 0, e, e, e],
      [1, 142, "Lang3", 0, e, 0, e, e, e],
      [1, 143, "Lang4", 0, e, 0, e, e, e],
      [1, 144, "Lang5", 0, e, 0, e, e, e],
      [1, 145, "Abort", 0, e, 0, e, e, e],
      [1, 146, "Props", 0, e, 0, e, e, e],
      [1, 147, "NumpadParenLeft", 0, e, 0, e, e, e],
      [1, 148, "NumpadParenRight", 0, e, 0, e, e, e],
      [1, 149, "NumpadBackspace", 0, e, 0, e, e, e],
      [1, 150, "NumpadMemoryStore", 0, e, 0, e, e, e],
      [1, 151, "NumpadMemoryRecall", 0, e, 0, e, e, e],
      [1, 152, "NumpadMemoryClear", 0, e, 0, e, e, e],
      [1, 153, "NumpadMemoryAdd", 0, e, 0, e, e, e],
      [1, 154, "NumpadMemorySubtract", 0, e, 0, e, e, e],
      [1, 155, "NumpadClear", 131, "Clear", 12, "VK_CLEAR", e, e],
      [1, 156, "NumpadClearEntry", 0, e, 0, e, e, e],
      [1, 0, e, 5, "Ctrl", 17, "VK_CONTROL", e, e],
      [1, 0, e, 4, "Shift", 16, "VK_SHIFT", e, e],
      [1, 0, e, 6, "Alt", 18, "VK_MENU", e, e],
      [1, 0, e, 57, "Meta", 91, "VK_COMMAND", e, e],
      [1, 157, "ControlLeft", 5, e, 0, "VK_LCONTROL", e, e],
      [1, 158, "ShiftLeft", 4, e, 0, "VK_LSHIFT", e, e],
      [1, 159, "AltLeft", 6, e, 0, "VK_LMENU", e, e],
      [1, 160, "MetaLeft", 57, e, 0, "VK_LWIN", e, e],
      [1, 161, "ControlRight", 5, e, 0, "VK_RCONTROL", e, e],
      [1, 162, "ShiftRight", 4, e, 0, "VK_RSHIFT", e, e],
      [1, 163, "AltRight", 6, e, 0, "VK_RMENU", e, e],
      [1, 164, "MetaRight", 57, e, 0, "VK_RWIN", e, e],
      [1, 165, "BrightnessUp", 0, e, 0, e, e, e],
      [1, 166, "BrightnessDown", 0, e, 0, e, e, e],
      [1, 167, "MediaPlay", 0, e, 0, e, e, e],
      [1, 168, "MediaRecord", 0, e, 0, e, e, e],
      [1, 169, "MediaFastForward", 0, e, 0, e, e, e],
      [1, 170, "MediaRewind", 0, e, 0, e, e, e],
      [
        1,
        171,
        "MediaTrackNext",
        124,
        "MediaTrackNext",
        176,
        "VK_MEDIA_NEXT_TRACK",
        e,
        e,
      ],
      [
        1,
        172,
        "MediaTrackPrevious",
        125,
        "MediaTrackPrevious",
        177,
        "VK_MEDIA_PREV_TRACK",
        e,
        e,
      ],
      [1, 173, "MediaStop", 126, "MediaStop", 178, "VK_MEDIA_STOP", e, e],
      [1, 174, "Eject", 0, e, 0, e, e, e],
      [
        1,
        175,
        "MediaPlayPause",
        127,
        "MediaPlayPause",
        179,
        "VK_MEDIA_PLAY_PAUSE",
        e,
        e,
      ],
      [
        1,
        176,
        "MediaSelect",
        128,
        "LaunchMediaPlayer",
        181,
        "VK_MEDIA_LAUNCH_MEDIA_SELECT",
        e,
        e,
      ],
      [
        1,
        177,
        "LaunchMail",
        129,
        "LaunchMail",
        180,
        "VK_MEDIA_LAUNCH_MAIL",
        e,
        e,
      ],
      [
        1,
        178,
        "LaunchApp2",
        130,
        "LaunchApp2",
        183,
        "VK_MEDIA_LAUNCH_APP2",
        e,
        e,
      ],
      [1, 179, "LaunchApp1", 0, e, 0, "VK_MEDIA_LAUNCH_APP1", e, e],
      [1, 180, "SelectTask", 0, e, 0, e, e, e],
      [1, 181, "LaunchScreenSaver", 0, e, 0, e, e, e],
      [
        1,
        182,
        "BrowserSearch",
        120,
        "BrowserSearch",
        170,
        "VK_BROWSER_SEARCH",
        e,
        e,
      ],
      [1, 183, "BrowserHome", 121, "BrowserHome", 172, "VK_BROWSER_HOME", e, e],
      [1, 184, "BrowserBack", 122, "BrowserBack", 166, "VK_BROWSER_BACK", e, e],
      [
        1,
        185,
        "BrowserForward",
        123,
        "BrowserForward",
        167,
        "VK_BROWSER_FORWARD",
        e,
        e,
      ],
      [1, 186, "BrowserStop", 0, e, 0, "VK_BROWSER_STOP", e, e],
      [1, 187, "BrowserRefresh", 0, e, 0, "VK_BROWSER_REFRESH", e, e],
      [1, 188, "BrowserFavorites", 0, e, 0, "VK_BROWSER_FAVORITES", e, e],
      [1, 189, "ZoomToggle", 0, e, 0, e, e, e],
      [1, 190, "MailReply", 0, e, 0, e, e, e],
      [1, 191, "MailForward", 0, e, 0, e, e, e],
      [1, 192, "MailSend", 0, e, 0, e, e, e],
      [1, 0, e, 114, "KeyInComposition", 229, e, e, e],
      [1, 0, e, 116, "ABNT_C2", 194, "VK_ABNT_C2", e, e],
      [1, 0, e, 96, "OEM_8", 223, "VK_OEM_8", e, e],
      [1, 0, e, 0, e, 0, "VK_KANA", e, e],
      [1, 0, e, 0, e, 0, "VK_HANGUL", e, e],
      [1, 0, e, 0, e, 0, "VK_JUNJA", e, e],
      [1, 0, e, 0, e, 0, "VK_FINAL", e, e],
      [1, 0, e, 0, e, 0, "VK_HANJA", e, e],
      [1, 0, e, 0, e, 0, "VK_KANJI", e, e],
      [1, 0, e, 0, e, 0, "VK_CONVERT", e, e],
      [1, 0, e, 0, e, 0, "VK_NONCONVERT", e, e],
      [1, 0, e, 0, e, 0, "VK_ACCEPT", e, e],
      [1, 0, e, 0, e, 0, "VK_MODECHANGE", e, e],
      [1, 0, e, 0, e, 0, "VK_SELECT", e, e],
      [1, 0, e, 0, e, 0, "VK_PRINT", e, e],
      [1, 0, e, 0, e, 0, "VK_EXECUTE", e, e],
      [1, 0, e, 0, e, 0, "VK_SNAPSHOT", e, e],
      [1, 0, e, 0, e, 0, "VK_HELP", e, e],
      [1, 0, e, 0, e, 0, "VK_APPS", e, e],
      [1, 0, e, 0, e, 0, "VK_PROCESSKEY", e, e],
      [1, 0, e, 0, e, 0, "VK_PACKET", e, e],
      [1, 0, e, 0, e, 0, "VK_DBE_SBCSCHAR", e, e],
      [1, 0, e, 0, e, 0, "VK_DBE_DBCSCHAR", e, e],
      [1, 0, e, 0, e, 0, "VK_ATTN", e, e],
      [1, 0, e, 0, e, 0, "VK_CRSEL", e, e],
      [1, 0, e, 0, e, 0, "VK_EXSEL", e, e],
      [1, 0, e, 0, e, 0, "VK_EREOF", e, e],
      [1, 0, e, 0, e, 0, "VK_PLAY", e, e],
      [1, 0, e, 0, e, 0, "VK_ZOOM", e, e],
      [1, 0, e, 0, e, 0, "VK_NONAME", e, e],
      [1, 0, e, 0, e, 0, "VK_PA1", e, e],
      [1, 0, e, 0, e, 0, "VK_OEM_CLEAR", e, e],
    ],
    r = [],
    n = []
  for (let i of t) {
    let [s, o, a, l, c, u, f, p, g] = i
    if (
      (n[o] ||
        ((n[o] = true),
        (Bwe[o] = a),
        (Rwe[a] = o),
        (Dwe[a.toLowerCase()] = o),
        s &&
          ((Twe[o] = l),
          l !== 0 &&
            l !== 3 &&
            l !== 5 &&
            l !== 4 &&
            l !== 6 &&
            l !== 57 &&
            (n6[l] = o))),
      !r[l])
    ) {
      if (((r[l] = true), !c))
        throw new Error(
          `String representation missing for key code ${l} around scan code ${a}`,
        )
      j1.define(l, c), t6.define(l, p || c), r6.define(l, g || p || c)
    }
    u && (bCt[u] = l), f && (ECt[f] = l)
  }
  n6[3] = 46
})()
var nw
;((o) => {
  function e(a) {
    return j1.keyCodeToStr(a)
  }
  o.toString = e
  function t(a) {
    return j1.strToKeyCode(a)
  }
  o.fromString = t
  function r(a) {
    return t6.keyCodeToStr(a)
  }
  o.toUserSettingsUS = r
  function n(a) {
    return r6.keyCodeToStr(a)
  }
  o.toUserSettingsGeneral = n
  function i(a) {
    return t6.strToKeyCode(a) || r6.strToKeyCode(a)
  }
  o.fromUserSettings = i
  function s(a) {
    if (a >= 98 && a <= 113) return null
    switch (a) {
      case 16:
        return "Up"
      case 18:
        return "Down"
      case 15:
        return "Left"
      case 17:
        return "Right"
    }
    return j1.keyCodeToStr(a)
  }
  o.toElectronAccelerator = s
})((nw ||= {}))
var i6 = class {
    unexpectedErrorHandler
    listeners
    constructor() {
      ;(this.listeners = []),
        (this.unexpectedErrorHandler = function (t) {
          setTimeout(() => {
            throw t.stack
              ? X1.isErrorNoTelemetry(t)
                ? new X1(
                    t.message +
                      `

` +
                      t.stack,
                  )
                : new Error(
                    t.message +
                      `

` +
                      t.stack,
                  )
              : t
          }, 0)
        })
    }
    addListener(t) {
      return (
        this.listeners.push(t),
        () => {
          this._removeListener(t)
        }
      )
    }
    emit(t) {
      this.listeners.forEach((r) => {
        r(t)
      })
    }
    _removeListener(t) {
      this.listeners.splice(this.listeners.indexOf(t), 1)
    }
    setUnexpectedErrorHandler(t) {
      this.unexpectedErrorHandler = t
    }
    getUnexpectedErrorHandler() {
      return this.unexpectedErrorHandler
    }
    onUnexpectedError(t) {
      this.unexpectedErrorHandler(t), this.emit(t)
    }
    onUnexpectedExternalError(t) {
      this.unexpectedErrorHandler(t)
    }
  },
  A8t = new i6()
function kwe(e) {
  return e ? new Error(`Illegal argument: ${e}`) : new Error("Illegal argument")
}
var X1 = class e extends Error {
  name
  constructor(t) {
    super(t), (this.name = "CodeExpectedError")
  }
  static fromError(t) {
    if (t instanceof e) return t
    let r = new e()
    return (r.message = t.message), (r.stack = t.stack), r
  }
  static isErrorNoTelemetry(t) {
    return t.name === "CodeExpectedError"
  }
}
var qv = class e {
    constructor(t, r, n, i, s) {
      this.ctrlKey = t
      this.shiftKey = r
      this.altKey = n
      this.metaKey = i
      this.keyCode = s
    }
    equals(t) {
      return (
        t instanceof e &&
        this.ctrlKey === t.ctrlKey &&
        this.shiftKey === t.shiftKey &&
        this.altKey === t.altKey &&
        this.metaKey === t.metaKey &&
        this.keyCode === t.keyCode
      )
    }
    getHashCode() {
      let t = this.ctrlKey ? "1" : "0",
        r = this.shiftKey ? "1" : "0",
        n = this.altKey ? "1" : "0",
        i = this.metaKey ? "1" : "0"
      return `K${t}${r}${n}${i}${this.keyCode}`
    }
    isModifierKey() {
      return (
        this.keyCode === 0 ||
        this.keyCode === 5 ||
        this.keyCode === 57 ||
        this.keyCode === 6 ||
        this.keyCode === 4
      )
    }
    toKeybinding() {
      return new Vm([this])
    }
    isDuplicateModifierCase() {
      return (
        (this.ctrlKey && this.keyCode === 5) ||
        (this.shiftKey && this.keyCode === 4) ||
        (this.altKey && this.keyCode === 6) ||
        (this.metaKey && this.keyCode === 57)
      )
    }
  },
  gg = class e {
    constructor(t, r, n, i, s) {
      this.ctrlKey = t
      this.shiftKey = r
      this.altKey = n
      this.metaKey = i
      this.scanCode = s
    }
    equals(t) {
      return (
        t instanceof e &&
        this.ctrlKey === t.ctrlKey &&
        this.shiftKey === t.shiftKey &&
        this.altKey === t.altKey &&
        this.metaKey === t.metaKey &&
        this.scanCode === t.scanCode
      )
    }
    getHashCode() {
      let t = this.ctrlKey ? "1" : "0",
        r = this.shiftKey ? "1" : "0",
        n = this.altKey ? "1" : "0",
        i = this.metaKey ? "1" : "0"
      return `S${t}${r}${n}${i}${this.scanCode}`
    }
    isDuplicateModifierCase() {
      return (
        (this.ctrlKey && (this.scanCode === 157 || this.scanCode === 161)) ||
        (this.shiftKey && (this.scanCode === 158 || this.scanCode === 162)) ||
        (this.altKey && (this.scanCode === 159 || this.scanCode === 163)) ||
        (this.metaKey && (this.scanCode === 160 || this.scanCode === 164))
      )
    }
  },
  Vm = class {
    chords
    constructor(t) {
      if (t.length === 0) throw kwe("chords")
      this.chords = t
    }
    getHashCode() {
      let t = ""
      for (let r = 0, n = this.chords.length; r < n; r++)
        r !== 0 && (t += ";"), (t += this.chords[r].getHashCode())
      return t
    }
    equals(t) {
      if (t === null || this.chords.length !== t.chords.length) return false
      for (let r = 0; r < this.chords.length; r++)
        if (!this.chords[r].equals(t.chords[r])) return false
      return true
    }
  }
var eQ = class {
  static _readModifiers(t) {
    t = t.toLowerCase().trim()
    let r = false,
      n = false,
      i = false,
      s = false,
      o
    do
      (o = false),
        /^ctrl(\+|\-)/.test(t) && ((r = true), (t = t.substr(5)), (o = true)),
        /^shift(\+|\-)/.test(t) && ((n = true), (t = t.substr(6)), (o = true)),
        /^alt(\+|\-)/.test(t) && ((i = true), (t = t.substr(4)), (o = true)),
        /^meta(\+|\-)/.test(t) && ((s = true), (t = t.substr(5)), (o = true)),
        /^win(\+|\-)/.test(t) && ((s = true), (t = t.substr(4)), (o = true)),
        /^cmd(\+|\-)/.test(t) && ((s = true), (t = t.substr(4)), (o = true))
    while (o)
    let a,
      l = t.indexOf(" ")
    return (
      l > 0
        ? ((a = t.substring(0, l)), (t = t.substring(l)))
        : ((a = t), (t = "")),
      { remains: t, ctrl: r, shift: n, alt: i, meta: s, key: a }
    )
  }
  static parseChord(t) {
    let r = this._readModifiers(t),
      n = r.key.match(/^\[([^\]]+)\]$/)
    if (n) {
      let s = n[1],
        o = Z1.lowerCaseToEnum(s)
      return [new gg(r.ctrl, r.shift, r.alt, r.meta, o), r.remains]
    }
    let i = nw.fromUserSettings(r.key)
    return [new qv(r.ctrl, r.shift, r.alt, r.meta, i), r.remains]
  }
  static parseKeybinding(t) {
    if (!t) return null
    let r = [],
      n
    for (; t.length > 0; ) ([n, t] = this.parseChord(t)), r.push(n)
    return r.length > 0 ? new Vm(r) : null
  }
}
var nQ = class {
    constructor(t, r) {
      this.platform = t
      this.keybindings = r
    }
  },
  jc = class e extends DisposableContainer {
    constructor(r) {
      super()
      this._globalState = r
      if (
        ((this.defaultKeybindings = this.getDefaultKeybindings()),
        !this.isRemote && !this.isWeb)
      ) {
        this.platform = Nwe.default.platform()
        let n = bCe()
        if (n) {
          let i = Pwe.default.join(n, e.keybindingFileName)
          ;(this.userKeybindings = this.getUserKeybindings(i)),
            (this.watcher = rQ.default.watch(n, (s, o) => {
              o === e.keybindingFileName &&
                (e._logger.info(`keybindings file changed: ${s} ${o}`),
                (this.userKeybindings = this.getUserKeybindings(i)))
            })),
            this.addDisposable({
              dispose: () => {
                this.watcher?.close()
              },
            })
        }
      } else {
        let n = this._globalState.get("userKeybindingInfo")
        ;(this.platform = n?.platform),
          (this.userKeybindings = n?.keybindings ?? {}),
          this.addDisposable(
            Zl.workspace.onDidSaveTextDocument((i) => {
              i.uri.scheme === "vscode-userdata" &&
                i.fileName.endsWith(e.keybindingFileName) &&
                ((this.platform = this.getPlatformFromFilename(i.fileName)),
                (this.userKeybindings = this.getUserKeybindingsFromJSON(
                  i.fileName,
                  i.getText(),
                )),
                this._globalState.update(
                  "userKeybindingInfo",
                  new nQ(this.platform, this.userKeybindings),
                ))
            }),
          ),
          setTimeout(() => {
            this.tryToFindPlatformAndUserKeybindings()
          }, e.remoteHeuristicDelayMs)
      }
    }
    static remoteHeuristicDelayMs = 1e3 * 5
    static _logger = z("KeybindingWatcher")
    static keybindingFileName = "keybindings.json"
    isRemote = Zl.env.remoteName !== undefined
    isWeb = Zl.env.uiKind === Zl.UIKind.Web
    platform
    watcher
    defaultKeybindings = {}
    userKeybindings = {}
    async tryToFindPlatformAndUserKeybindings() {
      if (this.isRemote && this.platform === undefined) {
        let n = (
            await Zl.workspace.openTextDocument(
              Zl.Uri.from({ scheme: "output", path: "exthost" }),
            )
          ).getText(),
          i = /Skipping acquiring lock for (.*)\./,
          s = n.match(i)
        if (s) {
          e._logger.debug("Loading user keybindings")
          let a = s[1].replace(/workspaceStorage.*/, e.keybindingFileName)
          this.platform = this.getPlatformFromFilename(a)
          let l = await Zl.workspace.openTextDocument(
            Zl.Uri.from({ scheme: "vscode-userdata", path: a }),
          )
          ;(this.userKeybindings = this.getUserKeybindingsFromJSON(
            l.fileName,
            l.getText(),
          )),
            this._globalState.update(
              "userKeybindingInfo",
              new nQ(this.platform, this.userKeybindings),
            )
        }
      }
    }
    getKeybindingForCommand(r, n = false) {
      let i = this.userKeybindings[r]
      if (!i) {
        if (this.userKeybindings["-" + r]) return
        let o = this.defaultKeybindings[r]
        o && (this.platform !== undefined || o.key === o.mac) && (i = o)
      }
      let s
      return i
        ? (this.platform === undefined
            ? (s = Array.from(new Set([i.key, i.mac]))
                .filter((o) => o !== undefined)
                .join("/"))
            : this.platform === "darwin" && i.mac
              ? (s = i.mac)
              : (s = i.key),
          n ? e.formatKeyboardShortcut(s, this.getSimplifiedPlatform()) : s)
        : null
    }
    static getStructuredKeybinding(r) {
      try {
        if (!r) return null
        let n = eQ.parseKeybinding(r)
        return n ? new s6(n.chords) : null
      } catch (n) {
        return this._logger.warn(`error parsing keybinding ${r}`, n), null
      }
    }
    static formatKeyboardShortcut(r, n) {
      try {
        let i = e.getStructuredKeybinding(r)
        return i ? i.toPrettyString(n) : ""
      } catch (i) {
        return (
          this._logger.warn(
            "error formatting keybinding, returning unformatted keybinding.",
            i,
          ),
          r || ""
        )
      }
    }
    getSimplifiedPlatform() {
      return this.platform === "darwin"
        ? "darwin"
        : this.platform === "win32"
          ? "win32"
          : "linux"
    }
    getDefaultKeybindings() {
      let r = getVSCodeAPI()
      if (r && r.contributes && r.contributes.keybindings) {
        let { keybindings: n } = r.contributes
        return Object.fromEntries(n.map((i) => [i.command, i]))
      }
      return {}
    }
    getUserKeybindings(r) {
      if (rQ.default.existsSync(r)) {
        let n = rQ.default.readFileSync(r, "utf8")
        return this.getUserKeybindingsFromJSON(r, n)
      }
      return {}
    }
    getUserKeybindingsFromJSON(r, n) {
      try {
        let i = Qwe.default.parse(n)
        return Object.fromEntries(i.map((s) => [s.command, s]))
      } catch (i) {
        return e._logger.debug(`Failed to parse '${r}': ${i.message}`), {}
      }
    }
    getPlatformFromFilename(r) {
      return r.startsWith("/Users/")
        ? "darwin"
        : r.match(/^\/?[a-zA-Z](?::|%3A)\/.*/)
          ? "win32"
          : "linux"
    }
  },
  tQ = {
    meta: { darwin: "\u2318", win32: "Win", linux: "Meta" },
    ctrl: { darwin: "\u2303", win32: "Ctrl", linux: "Ctrl" },
    alt: { darwin: "\u2325", win32: "Alt", linux: "Alt" },
    shift: "\u21E7",
  },
  Fwe = {
    Enter: "\u23CE",
    UpArrow: "\u2191",
    DownArrow: "\u2193",
    Backspace: "\u232B",
    Escape: "Esc",
  },
  s6 = class extends Vm {
    constructor(t) {
      super(t)
    }
    toPrettyString(t) {
      let r = []
      for (let n of this.chords) {
        let i = []
        n.ctrlKey && i.push(tQ.ctrl[t]),
          n.shiftKey && i.push(tQ.shift),
          n.altKey && i.push(tQ.alt[t]),
          n.metaKey && i.push(tQ.meta[t])
        let s
        n instanceof qv
          ? (s = nw.toString(n.keyCode))
          : (s = Z1.toString(n.scanCode)),
          s in Fwe && (s = Fwe[s]),
          (s = s.charAt(0).toUpperCase() + s.substring(1).toLowerCase()),
          i.push(s),
          i.join("").length <= 2 || t === "darwin"
            ? r.push(i.join(""))
            : r.push(i.join("+"))
      }
      return r.indexOf("Unknown") !== -1 ? "" : r.join(" ").trim()
    }
  }
function isVersionSupported(config, minVersion) {
  return config.nextEdit.enabled ?? isMinVersionMet(minVersion)
}
function iw(e, t) {
  return (
    e.nextEdit.enableBackgroundSuggestions &&
    e.nextEdit.backgroundEnabled &&
    isVersionSupported(e, t)
  )
}
function isDiffEditor() {
  let activeInput = iQ.window.tabGroups.activeTabGroup?.activeTab?.input
  return (
    activeInput instanceof iQ.TabInputTextDiff ||
    (activeInput != null &&
      Object.hasOwn(activeInput, "base") &&
      Object.hasOwn(activeInput, "input1") &&
      Object.hasOwn(activeInput, "input2"))
  )
}
var filterValidSuggestions = (e) => {
    let t = new Map()
    for (let r of e.filter(Boolean)) t.set(r.result.suggestionId, r)
    return Array.from(t.values())
  },
  somePredicatesMatch =
    (...e) =>
    (t) =>
      e.some((r) => r(t))
function isSuggestionAccepted(suggestion) {
  return suggestion?.state === "accepted"
}
function isFreshNonNoopSuggestion(suggestion) {
  return suggestion?.state === "fresh" && suggestion.changeType !== "noop"
}
function isFreshSuggestion(suggestion) {
  return suggestion?.state === "fresh"
}
function getKeybindingLabel(keybindingWatcher, commandId, formatForDisplay = false) {
  let keybinding = keybindingWatcher.getKeybindingForCommand(commandId, formatForDisplay)
  return (
    keybinding ||
    (commandId === UndoAcceptSuggestionCommand.commandID
      ? (keybindingWatcher.getSimplifiedPlatform() === "darwin"
          ? (keybinding = "Cmd+Z")
          : (keybinding = "Ctrl+Z"),
        formatForDisplay ? jc.formatKeyboardShortcut(keybinding, keybindingWatcher.getSimplifiedPlatform()) : keybinding)
      : commandId === "redo"
        ? (keybindingWatcher.getSimplifiedPlatform() === "darwin"
            ? (keybinding = "Cmd+Shift+Z")
            : (keybinding = "Ctrl+Y"),
          formatForDisplay ? jc.formatKeyboardShortcut(keybinding, keybindingWatcher.getSimplifiedPlatform()) : keybinding)
        : keybinding)
  )
}
var ClearRecentEditingHistoryCommand = class e extends AugmentCommand {
  constructor(r, n) {
    super(e.title)
    this._extension = r
    this._configListener = n
  }
  static title = "Clear Recent Editing History"
  static commandID = "vscode-augment.clear-recent-editing-history"
  type = "public"
  run() {
    this._extension.clearFileEdits()
  }
  canRun() {
    return (
      super.canRun() &&
      this._extension.ready &&
      isVersionSupported(
        this._configListener.config,
        this._extension.featureFlagManager.currentFlags
          .vscodeNextEditMinVersion,
      )
    )
  }
}
var aQ = require("vscode")
var _Ct = z("CopySessionIdPanelCommand"),
  CopySessionIdCommand = class extends AugmentCommand {
    constructor(apiServer) {
      super()
      this._apiServer = apiServer
    }
    static commandID = "vscode-augment.copySessionId"
    type = "public"
    async run() {
      try {
        let sessionId = this._apiServer.sessionId
        await aQ.env.clipboard.writeText(sessionId),
          await aQ.window.showInformationMessage(
            "Copied session ID to clipboard",
          )
      } catch (error) {
        _Ct.error(`Failed to copy session ID: ${error}`)
      }
    }
  }
var StartCpuProfileCommand = class e extends AugmentCommand {
    constructor(r) {
      super("Start Extension CPU Profile")
      this._flagManager = r
    }
    static commandID = "vscode-augment.cpu-profile.start"
    static isProfileRunning = false
    type = "debug"
    run() {
      !this._flagManager.currentFlags.vscodeEnableCpuProfile ||
        e.isProfileRunning ||
        (e.markAsRunning(), console.profile())
    }
    canRun() {
      return (
        this._flagManager.currentFlags.vscodeEnableCpuProfile &&
        !e.isProfileRunning
      )
    }
    static markAsRunning() {
      e.isProfileRunning = true
    }
    static markAsNotRunning() {
      e.isProfileRunning = false
    }
  },
  StopCpuProfileCommand = class extends AugmentCommand {
    constructor(r) {
      super("End Extension CPU Profile")
      this._flagManager = r
    }
    static commandID = "vscode-augment.cpu-profile.stop"
    type = "debug"
    run() {
      StartCpuProfileCommand.isProfileRunning && (console.profileEnd(), StartCpuProfileCommand.markAsNotRunning())
    }
    canRun() {
      return StartCpuProfileCommand.isProfileRunning
    }
  }
var DebugCommand = class extends AugmentCommand {
  constructor(configListener, title, showInActionPanel = true) {
    super(title, showInActionPanel)
    this._config = configListener
  }
  type = "debug"
  canRun() {
    return this._config.config.enableDebugFeatures
  }
}
var EnableWorkspaceSyncingCommand = class EnableWorkspaceSyncingCommand extends DebugCommand {
    constructor(syncingEnabledTracker, configListener, extension) {
      super(configListener, EnableWorkspaceSyncingCommand.title)
      this._syncingEnabledTracker = syncingEnabledTracker
      this._extension = extension
    }
    static title = "$(sync) Enable workspace syncing"
    static commandID = "vscode-augment.enable-workspace-syncing"
    run() {
      this._syncingEnabledTracker.syncingEnabledState !== "initializing" &&
        this._syncingEnabledTracker.enableSyncing()
    }
    canRun() {
      let state = this._syncingEnabledTracker.syncingEnabledState
      return (
        super.canRun() &&
        this._extension.ready &&
        (state === "disabled" || state === "partial")
      )
    }
  },
  DisableWorkspaceSyncingCommand = class DisableWorkspaceSyncingCommand extends DebugCommand {
    constructor(syncingStateTracker, configListener, extension) {
      super(configListener, DisableWorkspaceSyncingCommand.title)
      this._syncingStateTracker = syncingStateTracker
      this._extension = extension
    }
    static title = "$(circle-slash) Disable workspace syncing"
    static commandID = "vscode-augment.disable-workspace-syncing"
    run() {
      this._syncingStateTracker.syncingEnabledState !== "initializing" &&
        this._syncingStateTracker.disableSyncing()
    }
    canRun() {
      let state = this._syncingStateTracker.syncingEnabledState
      return (
        super.canRun() &&
        this._extension.ready &&
        (state === "enabled" || state === "partial")
      )
    }
  }
var fQ = require("vscode")
var ShowExtensionStatusCommand = class extends DebugCommand {
  constructor(extension, configListener) {
    super(configListener, "Show Extension Status")
    this._extension = extension
  }
  static commandID = "vscode-augment.extensionStatus"
  async run() {
    this._extension.updateStatusTrace()
    let document = await fQ.workspace.openTextDocument(AugmentExtension.displayStatusUri)
    await fQ.window.showTextDocument(document)
  }
}
var hQ = q(require("vscode"))
var GenerateCommitMessageCommand = class extends AugmentCommand {
  type = "public"
  static commandID = "vscode-augment.generateCommitMessage"
  _apiServer
  extension
  commitMessagePromptPreparer
  constructor(extension, apiServer) {
    super(),
      (this._apiServer = apiServer),
      (this.extension = extension),
      (this.commitMessagePromptPreparer = new Dv())
  }
  canRun() {
    return isMinVersionMet(
      this.extension.featureFlagManager.currentFlags
        .vscodeGenerateCommitMessageMinVersion,
    )
  }
  async run(params) {
    await this.generateCommitMessage(params)
  }
  async generateCommitMessage(params) {
    let gitExtension
    try {
      gitExtension = hQ.default.extensions.getExtension("vscode.git")?.exports
    } catch {
      hQ.default.window.showInformationMessage(
        "Cannot generate commit message: Failed to interact with git extension",
      )
      return
    }
    let repositories = gitExtension?.getAPI(1)?.repositories,
      repoUri = params.rootUri ?? "",
      repository = repositories?.find((repo) => repo.rootUri.toString() === repoUri.toString())
    if (!repository) {
      hQ.default.window.showInformationMessage(
        "Cannot generate commit message: no repo",
      )
      return
    }
    if (
      ((repository.inputBox.value = "Augment is generating..."),
      !this.extension.workspaceManager)
    ) {
      repository.inputBox.value = "Cannot generate commit message: no workspace"
      return
    }
    let promptData
    try {
      promptData = await this.commitMessagePromptPreparer.getCommitMessagePromptData(
        repository.rootUri.fsPath,
        {
          diffBudget: 9216,
          messageBudget: 3072,
          relevantMessageSubbudget: 1024,
          diffNoopLineLimit: 5e3,
          onlyUseStagedChanges: false,
          maxExampleCommitMessages: 3,
        },
      )
    } catch {
      repository.inputBox.value =
        "Cannot generate commit message: Failed to generate diff details"
      return
    }
    if (promptData.diff === "") {
      repository.inputBox.value = "Cannot generate commit message: no diff"
      return
    }
    let requestId = this._apiServer.createRequestId(),
      commitMessage = ""
    try {
      let messageStream = await this._apiServer.generateCommitMessageStream(requestId, promptData)
      for await (let chunk of messageStream) (commitMessage += chunk.text), (repository.inputBox.value = commitMessage)
    } catch {
      repository.inputBox.value = "Server error: failed to generate commit message."
    }
  }
}
var sd = require("vscode")
var ow = require("vscode"),
  completionEmitter = new ow.EventEmitter(),
  acceptEmitter = new ow.EventEmitter(),
  cancelEmitter = new ow.EventEmitter(),
  rejectEmitter = new ow.EventEmitter(),
  onCompletionAvailable = (handler) => completionEmitter.event(handler),
  onCompletionCancelled = (handler) => cancelEmitter.event(handler),
  onCompletionAccepted = (handler) => acceptEmitter.event(handler),
  fireCompletion = (data) => completionEmitter.fire(data),
  fireCancel = () => cancelEmitter.fire(),
  fireAccept = (data) => acceptEmitter.fire(data),
  onCompletionRejected = (handler) => rejectEmitter.event(handler),
  fireReject = (data) => rejectEmitter.fire(data)
var InsertCompletionCommand = class extends SyncingEnabledCommand {
  constructor(extension, syncingEnabledTracker) {
    super(syncingEnabledTracker)
    this._extension = extension
  }
  static commandID = "vscode-augment.insertCompletion"
  completionTimeoutMS = 1e4
  type = "public"
  async run() {
    let progressOptions = {
        location: sd.ProgressLocation.Notification,
        title: "Waiting for completion...",
        cancellable: true,
      },
      completionResult,
      progressTask = async (progress, token) => {
        completionResult = await this.requestCompletion(token)
      }
    if ((await sd.window.withProgress(progressOptions, progressTask), !completionResult)) {
      await sd.window.showWarningMessage("Failed to request a completion")
      return
    }
    switch (completionResult.resultType) {
      case "timeout":
        await sd.window.showWarningMessage("Failed to request a completion")
        break
      case "cancelled":
        await sd.window.showInformationMessage("Completion request cancelled")
        break
      default:
        completionResult.foundCompletion ||
          (await sd.window.showInformationMessage("No completions found"))
        break
    }
  }
  async requestCompletion(token) {
    let raceResult = Promise.race([
      (async () => {
        let completionEvent = await waitForEvent(onCompletionAvailable),
          found = false
        return (
          completionEvent?.completions && completionEvent.completions.length > 0 && (found = true),
          { foundCompletion: found, resultType: "completion" }
        )
      })(),
      (async () => (
        await waitForEvent(onCompletionCancelled), { foundCompletion: false, resultType: "cancelled" }
      ))(),
      (async () => (
        await waitForEvent(token.onCancellationRequested),
        { foundCompletion: false, resultType: "cancelled" }
      ))(),
      new Promise((resolve) => {
        setTimeout(() => {
          resolve({ foundCompletion: false, resultType: "timeout" })
        }, this.completionTimeoutMS)
      }),
    ])
    return (
      sd.commands.executeCommand("editor.action.inlineSuggest.trigger"), await raceResult
    )
  }
  canRun() {
    return super.canRun() && this._extension.ready
  }
}
var ha = q(require("vscode"))
var ShowWorkspaceContextCommand = class e extends DebugCommand {
  constructor(extension, configListener) {
    super(configListener, "Show Internal Context")
    this._extension = extension
  }
  static commandID = "vscode-augment.showWorkspaceContext"
  static textDocumentName = "Augment Workspace Context.txt"
  _documentUri = ha.Uri.file(e.textDocumentName).with({ scheme: "untitled" })
  async run() {
    let contextText = this._formatContext(),
      document = await ha.workspace.openTextDocument(this._documentUri)
    await ha.window.showTextDocument(document)
    let fullRange = new ha.Range(
        new ha.Position(0, 0),
        new ha.Position(document.lineCount, 0),
      ),
      workspaceEdit = new ha.WorkspaceEdit()
    workspaceEdit.replace(document.uri, fullRange, contextText), await ha.workspace.applyEdit(workspaceEdit)
  }
  _formatContext() {
    let workspaceManager = this._extension.workspaceManager
    if (workspaceManager === undefined) return "no workspace manager"
    let context = workspaceManager.getContextWithBlobNames(),
      headerText = `Augment workspace context
`,
      blobsText = this._formatBlobs(workspaceManager, context),
      chunksText = this._formatChunks(context.recentChunks)
    return (
      headerText +
      blobsText +
      `


` +
      chunksText
    )
  }
  _formatBlobs(workspaceManager, context) {
    let lines = new Array(),
      trackedBlobs = new Set()
    for (let [repoRoot, paths] of context.trackedPaths) for (let [path, blobName] of paths) trackedBlobs.add(blobName)
    let repoPathMap = new Map(),
      unknownBlobs = new Set()
    for (let blobName of context.blobNames) {
      let pathInfos = workspaceManager.getAllPathInfo(blobName)
      for (let [repoRoot, path, relativePath] of pathInfos) {
        let repoMap = repoPathMap.get(repoRoot)
        repoMap === undefined && ((repoMap = new Map()), repoPathMap.set(repoRoot, repoMap)), repoMap.set(relativePath, [blobName, pathInfos.length])
      }
      pathInfos.length === 0 && !trackedBlobs.has(blobName) && unknownBlobs.add(blobName)
    }
    let chunkCountMap = new Map()
    for (let chunk of context.recentChunks) {
      let repoRoot = chunk.repoRoot,
        pathName = chunk.pathName,
        repoMap = chunkCountMap.get(repoRoot)
      repoMap === undefined && ((repoMap = new Map()), chunkCountMap.set(repoRoot, repoMap)),
        repoMap.set(pathName, (repoMap.get(pathName) || 0) + 1)
    }
    for (let [repoRoot, pathMap] of repoPathMap) {
      let trackedPathsMap = context.trackedPaths.get(repoRoot) || new Map(),
        totalPaths = pathMap.size,
        openPaths = trackedPathsMap.size,
        recentChunksMap = chunkCountMap.get(repoRoot) || new Map()
      for (let path of recentChunksMap.keys())
        trackedPathsMap.has(path) || lines.push(`    ${repoRoot}: ${path} has recent chunks but is not open`)
      let headerLine = `Repo root ${repoRoot}: ${totalPaths} paths (${openPaths} open)`
      lines.push(""), lines.push(headerLine), lines.push("=".repeat(headerLine.length))
      let trackedPaths = Array.from(trackedPathsMap.keys())
      trackedPaths.sort()
      for (let path of trackedPaths) {
        let blobName = trackedPathsMap.get(path),
          chunkCount = recentChunksMap.get(path) || 0
        lines.push(`    ${blobName} -> ${path}: open, recent chunks: ${chunkCount}`)
      }
      trackedPaths.length > 0 && lines.push("")
      let allPaths = Array.from(pathMap.keys())
      allPaths.sort()
      for (let path of allPaths) {
        if (trackedPathsMap.has(path)) continue
        let [blobName, count] = pathMap.get(path),
          countSuffix = count === 1 ? "" : ` (x ${count})`
        lines.push(`    ${blobName} -> ${path}${countSuffix}`)
      }
    }
    if (unknownBlobs.size > 0) for (let blobName of unknownBlobs) lines.push(`unknown blob: ${blobName}`)
    return lines.join(`
`)
  }
  _formatChunks(chunks) {
    let lines = new Array(),
      headerText = "Recent chunks"
    if ((lines.push(headerText), lines.push("=".repeat(headerText.length)), chunks.length === 0))
      return (
        lines.push("    (no recent chunks)"),
        lines.join(`
`)
      )
    for (let index = 0; index < chunks.length; index++) {
      let chunk = chunks[index]
      lines.push(""),
        lines.push(`Chunk ${index + 1} of ${chunks.length}`),
        lines.push(`    seq:      ${chunk.seq}`),
        lines.push(`    uploaded: ${chunk.uploaded}`),
        lines.push(`    repoRoot: ${chunk.repoRoot}`),
        lines.push(`    pathName: ${chunk.pathName}`),
        lines.push(`    blobName: ${chunk.blobName}`),
        lines.push(`    start:    ${chunk.origStart}`),
        lines.push(`    length:   ${chunk.origLength}`),
        lines.push("======== chunk begin ========"),
        lines.push(chunk.text),
        lines.push("-------- chunk end ----------"),
        lines.push("")
    }
    return lines.join(`
`)
  }
}
var AQ = q(require("vscode"))
var ManageAccountCommand = class ManageAccountCommand extends AugmentCommand {
  constructor(extension, commandID) {
    super()
    this.extension = extension
    this._commandID = commandID
  }
  static commandIDCommunity = "vscode-augment.manageAccountCommunity"
  static commandIDProfessional = "vscode-augment.manageAccountProfessional"
  static commandIDEnterprise = "vscode-augment.manageAccountEnterprise"
  type = "public"
  run() {
    AQ.env.openExternal(AQ.Uri.parse("https://app.augmentcode.com/account"))
  }
  canRun() {
    let userTier = this.extension.userTier,
      commandTier =
        this._commandID === ManageAccountCommand.commandIDCommunity
          ? "community"
          : this._commandID === ManageAccountCommand.commandIDProfessional
            ? "professional"
            : "enterprise"
    return super.canRun() && userTier === commandTier
  }
}
var Ywe = q(require("vscode"))
var OpenSshConfigCommand = class extends DebugCommand {
  static commandID = "vscode-augment.openSshConfig"
  sshConfigManager
  constructor(configListener, r) {
    super(configListener, "Open Augment SSH Config"), (this.sshConfigManager = new Ev(r))
  }
  async run() {
    try {
      let fileSystem = this.sshConfigManager.fileSystem,
        configPath = await fileSystem.getAugmentSshConfigPath()
      await this.sshConfigManager.ensureAugmentConfigExists(),
        await fileSystem.openFile(configPath)
    } catch (error) {
      Ywe.window.showErrorMessage(`Error opening SSH config: ${String(error)}`)
    }
  }
}
var l6 = require("vscode")
var OpenSettingsCommand = class extends AugmentCommand {
    static commandID = "vscode-augment.settings"
    type = "public"
    run() {
      l6.commands.executeCommand(
        "workbench.action.openSettings",
        "@ext:augment.vscode-augment",
      )
    }
  },
  OpenKeyboardShortcutsCommand = class extends AugmentCommand {
    static commandID = "vscode-augment.keyboard-shortcuts"
    type = "public"
    run() {
      l6.commands.executeCommand(
        "workbench.action.openGlobalKeybindings",
        "@ext:augment.vscode-augment",
      )
    }
  }
var Kwe = require("vscode"),
  zwe = q(require("vscode"))
var ShowDocsCommand = class extends AugmentCommand {
  static commandID = "vscode-augment.showDocs"
  type = "public"
  async run() {
    await zwe.env.openExternal(Kwe.Uri.parse("https://docs.augmentcode.com"))
  }
}
var Qo = q(require("vscode"))
var EQ = class e extends PanelWebview {
  constructor(
    r,
    n,
    i,
    s,
    o,
    a,
    l,
    c,
    u = Qo.window.createWebviewPanel("history", "Augment History", s),
  ) {
    super("history.html", u.webview)
    this._extensionUri = r
    this._config = n
    this._apiServer = i
    this._recentCompletions = o
    this._recentInstructions = a
    this._recentNextEditResults = l
    this._workTimer = c
    this._panel = u
    ;(this._panel.iconPath = {
      light: Qo.Uri.joinPath(
        this._extensionUri,
        "media",
        "panel-icon-light.svg",
      ),
      dark: Qo.Uri.joinPath(this._extensionUri, "media", "panel-icon-dark.svg"),
    }),
      this._panel.onDidDispose(() => {
        this.dispose()
      }),
      this.addDisposables(
        this._panel,
        new Qo.Disposable(() => {
          e.currentPanel = undefined
        }),
      ),
      this.addDisposable(
        this._recentInstructions.onNewItems((f) => {
          !this._panel ||
            !this._panel.visible ||
            this._panel.webview.postMessage({ type: "instructions", data: [f] })
        }),
      ),
      this.addDisposable(
        this._recentNextEditResults.onNewItems((f) => {
          !this._panel ||
            !this._panel.visible ||
            this._panel.webview.postMessage({
              type: "next-edit-suggestions",
              data: f,
            })
        }),
      ),
      this.addDisposable(
        this._recentCompletions.onNewItems(async (f) => {
          await this.sendCompletions()
        }),
      ),
      this.addDisposable(
        this._config.onDidChange(async () => {
          await this.sendConfig()
        }),
      ),
      this._panel.webview.onDidReceiveMessage(async (f) => {
        await this._workTimer.runTimed(f.type, async () => {
          await this._handleMessage(f)
        })
      }),
      this.loadHTML(r)
  }
  static currentPanel
  async _postMessage(r) {
    !this._panel ||
      !this._panel.visible ||
      (await this._panel.webview.postMessage(r))
  }
  async sendCompletions() {
    await this._postMessage({
      type: "completions",
      data: this._getCompletions(),
    })
  }
  _getCompletions() {
    return this._recentCompletions.items.map((r) => ({
      occuredAt: r.occuredAt.toISOString(),
      requestId: r.requestId,
      repoRoot: r.repoRoot,
      pathName: r.pathName,
      prefix: r.prefix,
      completions: r.completions.map((n) => ({
        text: n.completionText,
        skippedSuffix: n.skippedSuffix,
        suffixReplacementText: n.suffixReplacementText,
      })),
      suffix: r.suffix,
    }))
  }
  async sendConfig() {
    await this._postMessage({
      type: "history-config",
      data: this._config.config,
    })
  }
  async _handleMessage(r) {
    if (!(!this._panel || !this._panel.visible))
      switch (r.type) {
        case "history-loaded":
          await this._postMessage({
            type: "history-initialize",
            data: {
              config: this._config.config,
              completionRequests: this._getCompletions(),
              instructions: this._recentInstructions.items.slice(),
              nextEdits: this._recentNextEditResults.items.slice(),
            },
          })
          break
        case "copy-request-id-to-clipboard":
          await Qo.env.clipboard.writeText(r.data),
            await Qo.window.showInformationMessage(
              "Copied request ID to clipboard",
            )
          break
        case "open-file": {
          cg(r.data, this._panel.viewColumn)
          break
        }
        case "completion-rating": {
          let n = true
          try {
            await this._apiServer.completionFeedback(r.data)
          } catch (i) {
            ;(n = false),
              Qo.window.showErrorMessage(
                `Failed to submit feedback: ${i.message}`,
              )
          } finally {
            this._panel.webview.postMessage({
              type: "completion-rating-done",
              data: { success: n, requestId: r.data.requestId },
            })
          }
          break
        }
        case "next-edit-rating": {
          let n = true
          try {
            await this._apiServer.nextEditFeedback(r.data)
          } catch (i) {
            ;(n = false),
              Qo.window.showErrorMessage(
                `Failed to submit feedback: ${i.message}`,
              )
          } finally {
            this._panel.webview.postMessage({
              type: "next-edit-rating-done",
              data: { success: n, requestId: r.data.requestId },
            })
          }
          break
        }
      }
  }
  static createOrShow(r, n, i, s, o, a, l) {
    if (e.currentPanel) {
      e.currentPanel._panel.reveal(Qo.ViewColumn.Beside)
      return
    }
    e.currentPanel = new e(r, n, i, Qo.ViewColumn.Beside, s, o, a, l)
  }
}
var ShowHistoryPanelCommand = class extends AugmentCommand {
  constructor(extensionUri, config, apiServer, recentCompletions, recentInstructions, recentNextEditResults, workTimer) {
    super()
    this._extensionUri = extensionUri
    this._config = config
    this._apiServer = apiServer
    this._recentCompletions = recentCompletions
    this._recentInstructions = recentInstructions
    this._recentNextEditResults = recentNextEditResults
    this._workTimer = workTimer
  }
  static commandID = "vscode-augment.showHistoryPanel"
  type = "public"
  run() {
    EQ.createOrShow(
      this._extensionUri,
      this._config,
      this._apiServer,
      this._recentCompletions,
      this._recentInstructions,
      this._recentNextEditResults,
      this._workTimer,
    )
  }
}
var Wv = q(require("vscode"))
var ShowAugmentCommandsCommand = class extends AugmentCommand {
  constructor(extension, context, commandManager) {
    super()
    this._extension = extension
    this._context = context
    this._commandManager = commandManager
  }
  static commandID = "vscode-augment.showAugmentCommands"
  type = "public"
  async run() {
    let packageCommands = this._context.extension.packageJSON?.contributes?.commands
    if (!packageCommands) return
    let commandTitles = Object.fromEntries(packageCommands.map(({ command, title }) => [command, title]))
    for (let command of this._commandManager.availableCommands) {
      let title = command.title || commandTitles[command.commandID]
      title && (commandTitles[command.commandID] = title)
    }
    let keybindings = {}
    if (this._extension.keybindingWatcher)
      for (let cmdId of Object.keys(commandTitles)) {
        let keybinding = this._extension.keybindingWatcher.getKeybindingForCommand(cmdId, true)
        keybinding && (keybindings[cmdId] = `${keybinding}`)
      }
    let actions = this.getActions(commandTitles, keybindings),
      selectedAction = await Wv.window.showQuickPick(actions, { title: "Augment Commands" })
    selectedAction && selectedAction.commandID && Wv.commands.executeCommand(selectedAction.commandID)
  }
  getActions(commandTitles, keybindings) {
    let items = []
    for (let { name, commands } of this._commandManager
      .availableCommandGroups) {
      let filteredCommands = commands.filter((cmd) => commandTitles[cmd.commandID])
      if (filteredCommands.length !== 0) {
        items.length > 0 &&
          items.push({ label: name, kind: Wv.QuickPickItemKind.Separator })
        for (let command of filteredCommands)
          command.showInActionPanel &&
            items.push({
              commandID: command.commandID,
              label: commandTitles[command.commandID],
              description: keybindings[command.commandID],
            })
      }
    }
    return Promise.resolve(items)
  }
}
var gs = q(require("vscode"))
var c6 = q(Yf()),
  wQ = q(require("vscode"))
var Gv = class e extends DisposableContainer {
  constructor(r, n, i, s = undefined) {
    super()
    this._workspaceManager = r
    this._webview = n
    this._featureFlagManager = i
    ;(this._asyncMsgHandler = createAsyncMessageHandler(this._webview, s)),
      this.addDisposable(
        this._featureFlagManager.subscribe(
          ["enableWorkspaceManagerUi"],
          this._registerAllHandlers.bind(this),
        ),
      ),
      this._registerAllHandlers()
  }
  _logger = z("WorkspaceUIModel")
  _asyncMsgHandler
  _registerAllHandlers() {
    this._featureFlagManager.currentFlags.enableWorkspaceManagerUi &&
      (this._setupWorkspaceListeners(),
      this.addDisposable(this._asyncMsgHandler),
      this.addDisposable(
        this._webview.onDidReceiveMessage(this.onDidReceiveMessage),
      ),
      this._asyncMsgHandler.registerHandler(
        "ws-context-get-source-folders-request",
        this.getSourceFoldersHandler,
      ),
      this._asyncMsgHandler.registerHandler(
        "ws-context-get-children-request",
        this.getChildrenHandler,
      ))
  }
  _setupWorkspaceListeners() {
    this.addDisposable(
      this._workspaceManager.onDidChangeSourceFolders(
        (0, c6.default)(
          () => {
            this._webview.postMessage({ // =
              type: "ws-context-source-folders-changed",
            })
          },
          500,
          { leading: true, trailing: true },
        ),
      ),
    ),
      this.addDisposable(
        this._workspaceManager.onDidChangeSourceFolderContents(
          (0, c6.default)(
            (r) => {
              this._webview.postMessage({ // =
                type: "ws-context-folder-contents-changed",
                data: r,
              })
            },
            500,
            { leading: true, trailing: true },
          ),
        ),
      )
  }
  getSourceFoldersHandler = () => {
    let r = this._workspaceManager
      .listSourceFolders()
      .sort((n, i) => n.name.localeCompare(i.name))
    return {
      type: "ws-context-get-source-folders-response",
      data: { workspaceFolders: r.map(e.makeWSContextSourceFolder) },
    }
  }
  getChildrenHandler = (r) => {
    let n = this._workspaceManager
      .listChildren(r.data.fileId.folderRoot, r.data.fileId.relPath)
      .sort((i, s) => i.name.localeCompare(s.name))
    return {
      type: "ws-context-get-children-response",
      data: { children: n.map(e.makeWSContextFileItem) },
    }
  }
  static getInclusionState(r) {
    return r.included
      ? r.type === "Directory" && r.containsExcludedItems
        ? "partial"
        : "included"
      : "excluded"
  }
  static makeWSContextFileItem = (r) => ({
    name: r.name,
    fileId: { folderRoot: r.folderRoot, relPath: r.relPath },
    type: r.type === "Directory" ? "folder" : "file",
    inclusionState: e.getInclusionState(r),
    reason: r.reason,
    trackedFileCount: r.type === "Directory" ? r.trackedFileCount : undefined,
  })
  static makeWSContextSourceFolder = (r) => ({
    name: r.name,
    fileId: { folderRoot: r.folderRoot, relPath: "" },
    inclusionState: r.containsExcludedItems ? "partial" : "included",
    isWorkspaceFolder: r.type === 0 || r.type === 2,
    isNestedFolder: r.type === 2 || r.type === 3,
    isPending: r.enumerationState === 0,
    trackedFileCount:
      r.type === 0 || r.type === 1 ? r.trackedFileCount : undefined,
  })
  onDidReceiveMessage = async (r) => {
    switch (
      (this._logger.debug(`Extension received message: ${r.type}`), r.type)
    ) {
      case "ws-context-add-more-source-folders": {
        let n = await wQ.window.showOpenDialog({
          canSelectFolders: true,
          canSelectFiles: false,
          canSelectMany: true,
          openLabel: "Add Source Folder",
        })
        if (n && n.length > 0) {
          let i = n
            .map((s) => {
              try {
                return this._workspaceManager.addExternalSourceFolder(s), null
              } catch (o) {
                return (
                  this._logger.error("Failed to add source folder:", o),
                  o instanceof Error
                    ? { path: s.fsPath, message: o.message }
                    : { path: s.fsPath, message: String(o) }
                )
              }
            })
            .filter((s) => s !== null)
          i.length > 0 &&
            wQ.window.showErrorMessage(
              `One or more source folders could not be added:
` +
                i.map((s) => `${s.path}: ${s.message}`).join(`
`),
            )
        }
        break
      }
      case "ws-context-remove-source-folder": {
        try {
          this._workspaceManager.removeExternalSourceFolder(r.data)
        } catch (n) {
          let i = n
          n instanceof Error && (i = n.message),
            this._logger.error("Failed to remove source folder:", i),
            wQ.window
              .showErrorMessage(`Failed to remove source folder ${r.data}:
 ${String(i)}`)
        }
        break
      }
      case "ws-context-user-requested-refresh": {
        this._workspaceManager.refreshSourceFolders()
        break
      }
    }
  }
}
var u6 = 1,
  rl = class extends Error {
    constructor(t) {
      super(t), (this.name = "ToolConfigError")
    }
  }
var aw = class extends rl {
  constructor(t) {
    super(`Failed to parse tool config: ${t}`),
      (this.name = "ToolConfigParseError")
  }
}
var SQ = class e extends PanelWebview {
  constructor(
    r,
    n,
    i,
    s,
    o,
    a,
    l = gs.window.createWebviewPanel(
      e.viewType,
      "Augment Settings",
      gs.ViewColumn.Active,
      { retainContextWhenHidden: true, enableScripts: true },
    ),
  ) {
    super("settings.html", l.webview)
    this._extensionUri = r
    this._extension = n
    this._apiServer = i
    this._config = s
    this._guidelinesWatcher = o
    this._navigateTo = a
    this._panel = l
    ;(this._store = this._extension.toolConfigStore),
      (this._featureFlagManager = this._extension.featureFlagManager),
      (this._panel.iconPath = {
        light: gs.Uri.joinPath(
          this._extensionUri,
          "media",
          "panel-icon-light.svg",
        ),
        dark: gs.Uri.joinPath(
          this._extensionUri,
          "media",
          "panel-icon-dark.svg",
        ),
      }),
      this._panel.onDidDispose(() => {
        this.dispose()
      }),
      this.addDisposables(
        this._panel,
        new gs.Disposable(() => {
          e.currentPanel = undefined
        }),
        onOrientationStateChanged((c) => {
          this._postMessage({ type: "orientation-status-update", data: c })
        }),
      ),
      this.addDisposable(
        this._panel.webview.onDidReceiveMessage(async (c) => {
          try {
            await this._extension.workTimer.runTimed(c.type, () =>
              this._handleMessage(c),
            )
          } catch (u) {
            this._handleError(u)
          }
        }),
      ),
      this._extension.workspaceManager &&
        ((this._workspaceUiModel = new Gv(
          this._extension.workspaceManager,
          this._panel.webview,
          this._extension.featureFlagManager,
          this._extension.workTimer,
        )),
        this.addDisposable(this._workspaceUiModel)),
      this.loadHTML(r)
  }
  static viewType = "augmentSettingsPanel"
  _log = z("SettingsWebviewPanel")
  static currentPanel
  _workspaceUiModel = null
  static mcpServersKey = "mcpServers"
  _store
  _featureFlagManager
  dispose = () => {
    this._panel.dispose(), (e.currentPanel = undefined), super.dispose()
  }
  navigateToSection(r) {
    this._postMessage({ type: "navigate-to-settings-section", data: r })
  }
  _handleError(r) {
    r instanceof rl
      ? gs.window.showErrorMessage(r.message)
      : gs.window.showErrorMessage(`Unexpected error: ${getErrorMessage(r)}`)
  }
  async _handleMessage(r) {
    switch (r.type) {
      case "settings-panel-loaded":
        this._handleSettingsPanelLoaded()
        break
      case "tool-config-loaded":
        await this._handleConfigLoaded()
        break
      case "tool-config-save":
        await this._handleConfigSave(r.data)
        break
      case "tool-config-get-definitions":
        await this._handleGetDefinitions(r)
        break
      case "tool-config-start-oauth":
        await this._handleStartOAuth(r.data)
        break
      case "tool-config-revoke-access":
        await this._handleRevokeAccess(r.data)
        break
      case "get-stored-mcp-servers":
        await this._handleGetStorageValue()
        break
      case "set-stored-mcp-servers":
        await this._handleSetStorageValue(r.data)
        break
      case "execute-initial-orientation":
        await this._handleExecuteInitialOrientation()
        break
      case "get-orientation-status":
        this._handleGetOrientationStatus()
        break
      case "update-user-guidelines":
        ig.updateUserGuidelines(r.data)
        break
      case "get-terminal-settings":
        await this._handleGetTerminalSettings()
        break
      case "update-terminal-settings":
        await this._handleUpdateTerminalSettings(r.data)
        break
    }
  }
  _handleSettingsPanelLoaded() {
    setTimeout(() => {
      this._navigateTo && this.navigateToSection(this._navigateTo)
    }, 500)
  }
  async _handleConfigLoaded() {
    try {
      let r = await this._store.get(),
        n = this._getEnableAgentMode(),
        i =
          !!this._featureFlagManager.currentFlags.memoriesParams
            .enable_initial_orientation,
        s = [],
        o = []
      n &&
        ((s =
          await (this._extension.toolsModel?.getToolStatusForSettingsPanel() ??
            Promise.resolve([]))),
        (o = r.tools.map((l) => ({
          config: JSON.stringify(l.config, null, 2),
          isConfigured: l.isConfigured,
          name: l.name,
        }))))
      let a = this._guidelinesWatcher.getGuidelinesStates()
      await this._postMessage({
        type: "tool-config-initialize",
        data: {
          toolConfigs: o,
          hostTools: s,
          enableDebugFeatures: this._config.config.enableDebugFeatures,
          settingsComponentSupported: {
            workspaceContext: true,
            mcpServerList: true,
            mcpServerImport: true,
            orientation: true,
            remoteTools: true,
            userGuidelines:
              this._featureFlagManager.currentFlags.enableGuidelines,
            terminal: true,
          },
          enableAgentMode: n,
          enableInitialOrientation: i,
          userTier: this._extension.userTier,
          guidelines: a,
        },
      }),
        await this._handleGetStorageValue()
    } catch (r) {
      this._handleError(r)
    }
  }
  async _handleConfigSave(r) {
    try {
      let n = await this._store.get(),
        i
      try {
        i = JSON.parse(r.toolConfig)
      } catch (a) {
        throw (
          (this._log.error(`Failed to parse tool config: ${getErrorMessage(a)}`),
          new aw(getErrorMessage(a)))
        )
      }
      let s = { config: i, isConfigured: r.isConfigured, name: r.toolName },
        o = n.tools.findIndex((a) => a.name === r.toolName)
      o >= 0 ? (n.tools[o] = s) : n.tools.push(s), await this._store.save(n)
    } catch (n) {
      throw (
        (this._log.error(`Error saving tool configuration: ${getErrorMessage(n)}`),
        new aw(getErrorMessage(n)))
      )
    }
  }
  async _handleGetDefinitions(r) {
    let n = !!r?.data?.useCache,
      i = []
    this._getEnableAgentMode() &&
      (i = await (this._extension.toolsModel?.getToolStatusForSettingsPanel(
        n,
      ) ?? Promise.resolve([]))),
      await this._postMessage({
        type: "tool-config-definitions-response",
        data: { hostTools: i },
      })
  }
  async _handleStartOAuth(r) {
    let n = false
    try {
      let i = r.authUrl,
        s = gs.Uri.parse(i)
      ;(n = await gs.env.openExternal(s)),
        n || this._log.warn(`Failed to open URL: ${i}`)
    } catch (i) {
      this._log.error(`Error opening URL: ${getErrorMessage(i)}`)
    } finally {
      await this._postMessage({
        type: "tool-config-start-oauth-response",
        data: { ok: n },
      })
    }
  }
  async _handleRevokeAccess(r) {
    try {
      let i = (
        await (this._extension.toolsModel?.getToolStatusForSettingsPanel() ??
          Promise.resolve([]))
      ).find(
        (s) =>
          s.identifier.hostName === r.toolId.hostName &&
          s.identifier.toolId === r.toolId.toolId,
      )
      if (i && i.identifier.hostName === ToolHostType.remoteToolHost) {
        let s = i.identifier.toolId
        this._log.info(
          `Revoking access for remote tool: ${i.definition.name} (${s})`,
        )
        let o
        try {
          o = await this._apiServer.revokeToolAccess(s)
        } catch (a) {
          this._log.error(`API error revoking access: ${getErrorMessage(a)}`),
            gs.window.showErrorMessage(`Error revoking access: ${getErrorMessage(a)}`)
          return
        }
        switch (o.status) {
          case 3:
            this._log.info(
              `Successfully revoked access for ${i.definition.name} (${s}).`,
            ),
              await this._handleGetDefinitions()
            break
          case 4:
            this._log.info(
              `Tool ${i.definition.name} (${s}) has no access to revoke.`,
            ),
              await this._handleGetDefinitions()
            break
          case 1:
            this._log.warn(
              `Revoking access is not implemented for ${i.definition.name} (${s}).`,
            ),
              gs.window.showWarningMessage(
                `Revoking access is not implemented for ${i.definition.name} (${s}).`,
              )
            break
          case 2:
            throw new rl(`Tool not found: ${i.definition.name} (${s}).`)
          case 5:
            throw new rl(
              `Failed to revoke access for ${i.definition.name} (${s}).`,
            )
          default:
            throw new rl(
              `Unknown status (${o.status}) when revoking access for ${i.definition.name} (${s}).`,
            )
        }
      } else
        throw new rl(`Tool not found: ${r.toolId.hostName} ${r.toolId.toolId}`)
    } catch (n) {
      this._log.error(`Error revoking access: ${getErrorMessage(n)}`), this._handleError(n)
    }
  }
  async _handleGetStorageValue() {
    try {
      let r = await this._store.getMCPServers()
      await this._postMessage({
        type: "get-stored-mcp-servers-response",
        data: r,
      })
    } catch (r) {
      this._log.error(`Error getting storage value: ${getErrorMessage(r)}`),
        this._handleError(r)
    }
  }
  async _handleSetStorageValue(r) {
    try {
      await this._store.saveMCPServers(r)
    } catch (n) {
      this._log.error(`Error setting storage value: ${getErrorMessage(n)}`),
        this._handleError(n)
    }
  }
  async _postMessage(r) {
    try {
      return await this._panel.webview.postMessage(r), true
    } catch (n) {
      return this._log.error(`Failed to post message to webview: ${getErrorMessage(n)}`), false
    }
  }
  async _handleExecuteInitialOrientation() {
    try {
      await gs.commands.executeCommand(RunAgentInitialOrientationCommand.commandID)
    } catch (r) {
      this._log.error(`Failed to execute initial orientation: ${getErrorMessage(r)}`),
        this._handleError(r)
    }
  }
  _getEnableAgentMode() {
    return isMinVersionMet(
      this._featureFlagManager.currentFlags.vscodeAgentModeMinVersion ?? "",
    )
  }
  _handleGetOrientationStatus() {
    try {
      notifyOrientationStateChanged()
    } catch (r) {
      this._log.error(`Failed to get orientation status: ${getErrorMessage(r)}`),
        this._handleError(r)
    }
  }
  async _handleGetTerminalSettings() {
    try {
      let r = await this._store.getTerminalSettings()
      await this._postMessage({ type: "terminal-settings-response", data: r })
    } catch (r) {
      this._log.error(`Failed to get terminal settings: ${getErrorMessage(r)}`),
        this._handleError(r)
    }
  }
  async _handleUpdateTerminalSettings(r) {
    try {
      r.selectedShell &&
        (await this._store.updateSelectedShell(r.selectedShell)),
        r.startupScript !== undefined &&
          (await this._store.updateStartupScript(r.startupScript))
      let n = await this._store.getTerminalSettings()
      await this._postMessage({ type: "terminal-settings-response", data: n })
    } catch (n) {
      this._log.error(`Failed to update terminal settings: ${getErrorMessage(n)}`),
        this._handleError(n)
    }
  }
  static createOrShow(r, n, i, s, o, a) {
    return e.currentPanel
      ? (e.currentPanel._panel.reveal(), e.currentPanel)
      : ((e.currentPanel = new e(r, n, i, s, o, a)), e.currentPanel)
  }
}
var ShowSettingsPanelCommand = class extends AugmentCommand {
  constructor(extensionUri, extension, apiServer, config, guidelinesWatcher) {
    super("Show Settings Panel", true)
    this._extensionUri = extensionUri
    this._extension = extension
    this._apiServer = apiServer
    this._config = config
    this._guidelinesWatcher = guidelinesWatcher
  }
  static commandID = "vscode-augment.showSettingsPanel"
  type = "public"
  run(section) {
    let panel = SQ.createOrShow(
      this._extensionUri,
      this._extension,
      this._apiServer,
      this._config,
      this._guidelinesWatcher,
      section,
    )
    section && panel.navigateToSection(section)
  }
}
var StartNewChatCommand = class extends AugmentCommand {
  constructor(chatExtensionEvent) {
    super()
    this._chatExtensionEvent = chatExtensionEvent
  }
  static commandID = "vscode-augment.startNewChat"
  type = "public"
  async run() {
    await showAugmentPanel("Start chat command"), this._chatExtensionEvent.fire("newThread")
  }
}
var Jwe = q(require("vscode"))
var StatusBarClickCommand = class extends AugmentCommand {
  static commandID = "_vscode-augment.statusbarClick"
  type = "private"
  constructor() {
    super(undefined, false)
  }
  async run() {
    await Jwe.commands.executeCommand("augment-chat.focus")
  }
}
var lw = require("vscode")
var ToggleAutomaticCompletionCommand = class ToggleAutomaticCompletionCommand extends SyncingEnabledCommand {
  constructor(configListener, syncingEnabledTracker) {
    super(syncingEnabledTracker, () =>
      this._configListener.config.completions.enableAutomaticCompletions
        ? "Turn Automatic Completions Off"
        : "Turn Automatic Completions On",
    )
    this._configListener = configListener
  }
  static commandID = "vscode-augment.toggleAutomaticCompletionSetting"
  static autoCompletionsConfigKey = "completions.enableAutomaticCompletions"
  type = "public"
  run() {
    let config = lw.workspace.getConfiguration("augment"),
      inspection = config.inspect(ToggleAutomaticCompletionCommand.autoCompletionsConfigKey),
      target = lw.ConfigurationTarget.Global
    inspection?.workspaceValue !== undefined && (target = lw.ConfigurationTarget.Workspace),
      config.update(
        ToggleAutomaticCompletionCommand.autoCompletionsConfigKey,
        !this._configListener.config.completions.enableAutomaticCompletions,
        target,
      )
  }
  canRun() {
    return super.canRun()
  }
}
function registerCommands(e, t, r, n, i, s, o, a, l, changeWebviewAppEventEmitter, u, f, p, g) {
  let commandRegistry = new CommandRegistry(r)
  return (
    commandRegistry.registerGroup("", [
      new AuthCommand(n, i, AuthCommand.signInCommandID, "$(sign-in) Sign In"),
      new Separator(),
      new EnableWorkspaceSyncingCommand(f, r, t),
    ]),
    commandRegistry.registerGroup("Completions", [new InsertCompletionCommand(t, f), new ToggleAutomaticCompletionCommand(r, f)]),
    commandRegistry.registerGroup("Code Instruction", [
      new InstructionCommand(t, e.extensionUri, s, t.guidelinesWatcher, f),
    ]),
    commandRegistry.registerGroup("Chat", [
      new FixCommand(t, r, u, f),
      new ExplainCommand(t, r, u, f),
      new StartNewChatCommand(u),
      new TestCommand(t, r, u, f),
      new DocumentCommand(t, r, u, f),
      new ResetAgentOnboardingCommand(u, p, g),
      new RunAgentInitialOrientationCommand(t, s, f),
      new ShowSettingsPanelCommand(e.extensionUri, t, s, r, t.guidelinesWatcher),
    ]),
    commandRegistry.registerGroup("Next Edit Suggestions", [
      new AcceptNextEditCommand(t, r, f),
      new RejectNextEditCommand(t, r, f),
      new AcceptAllNextEditCommand(t, r, f),
      new RejectAllNextEditCommand(t, r, f),
      new DismissNextEditCommand(t, r, f),
      new NextEditPreviousCommand(t, r, f),
      new NextEditForwardCommand(t, r, f),
      new NextEditNavigateCommand(t, r, f),
      new ForceNextEditCommand(t, r, f),
      new ToggleNextEditPanelSplitCommand(t, r, f),
      new UpdateNextEditCommand(t, r, f),
      new LearnMoreNextEditCommand(t, r, f),
      new EnableBackgroundSuggestionsCommand(t, r, f),
      new DisableBackgroundSuggestionsCommand(t, r, f),
      new ToggleHighlightsCommand(t, r, f),
      new ResetNextEditOnboardingCommand(t, r, f, p),
      new ClearRecentEditingHistoryCommand(t, r),
      new UpdateNextEditLoadingCommand(t, r, f),
      new UpdateNextEditDisabledNoChangesCommand(t, r, f),
      new UpdateNextEditDisabledCachedCommand(t, r, f),
      new AcceptNextEditCodeActionCommand(t, r, f),
      new OpenNextEditCommand(t, r, f),
      new OpenNextEditPanelCommand(t, r, f),
      new PreviousDisabledCommand(t, r, f),
      new NextForwardDisabledCommand(t, r, f),
      new UndoAcceptSuggestionCommand(t, r, f),
      new ToggleHoverDiffCommand(t, r, f),
    ]),
    commandRegistry.registerGroup("Debug", [
      new ShowExtensionStatusCommand(t, r),
      new ShowWorkspaceContextCommand(t, r),
      new StartCpuProfileCommand(t.featureFlagManager),
      new StopCpuProfileCommand(t.featureFlagManager),
      new OpenSshConfigCommand(r, p),
    ]),
    commandRegistry.registerGroup("", [
      new OpenSettingsCommand(),
      new OpenKeyboardShortcutsCommand(),
      new DisableWorkspaceSyncingCommand(f, r, t),
      new ShowDocsCommand(),
      new ShowHistoryPanelCommand(e.extensionUri, r, s, o, a, l, t.workTimer),
      new CopySessionIdCommand(s),
      new ManageAccountCommand(t, ManageAccountCommand.commandIDCommunity),
      new ManageAccountCommand(t, ManageAccountCommand.commandIDProfessional),
      new ManageAccountCommand(t, ManageAccountCommand.commandIDEnterprise),
      new AuthCommand(n, i, AuthCommand.signOutCommandID, "$(sign-out) Sign Out"),
      new OpenNextEditSettingsCommand(t, r, f),
    ]),
    r.config.autofix.enabled &&
      r.config.autofix.autofixUrl &&
      commandRegistry.register([new T1(t, s)]),
    commandRegistry.register([
      new ShowAugmentCommandsCommand(t, e, commandRegistry),
      new ToggleBackgroundSuggestionsCommand(t, r, f),
      new ShowSidebarChatCommand(t.featureFlagManager, changeWebviewAppEventEmitter),
      new GenerateCommitMessageCommand(t, s),
      new OpenDiffViewCommand(t, e.extensionUri, s),
      new AcceptAllChunksCommand(),
      new AcceptFocusedChunkCommand(),
      new RejectFocusedChunkCommand(),
      new FocusPreviousChunkCommand(),
      new FocusNextChunkCommand(),
      new CloseDiffViewCommand(),
      new StatusBarClickCommand(),
    ]),
    commandRegistry
  )
}
var DQ = class e {
  constructor(t, r, n, i, s = e.chunkSize) {
    this._apiServer = t
    ;(this._completionTimeoutMs = r),
      (this._completionParams = { prefixSize: n, suffixSize: i, chunkSize: s })
  }
  static chunkSize = 1024
  _completionTimeoutMs
  _completionParams
  createRequestId() {
    return this._apiServer.createRequestId()
  }
  get completionParams() {
    return this._completionParams
  }
  async complete(t, r, n, i, s, o, a, l, c, u, f, p, g) {
    let m = await this._apiServer.complete(
      t,
      r,
      n,
      i,
      s,
      o,
      a,
      l,
      c,
      u,
      f,
      p,
      g,
    )
    return (
      m.completionTimeoutMs !== undefined &&
        (this._completionTimeoutMs = m.completionTimeoutMs),
      m.suggestedPrefixCharCount !== undefined &&
        (this._completionParams.prefixSize = m.suggestedPrefixCharCount),
      m.suggestedSuffixCharCount !== undefined &&
        (this._completionParams.suffixSize = m.suggestedSuffixCharCount),
      m.suggestedPrefixCharCount !== undefined &&
        (this._completionParams.chunkSize = e.chunkSize),
      m
    )
  }
}
var eSe = q(_s()),
  eu = q(require("vscode"))
var Sf = class {
  constructor(t, r, n, i) {
    this.completionText = t
    this.suffixReplacementText = r
    this.skippedSuffix = n
    this.range = i
  }
  toString() {
    return `text: ${this.completionText}
    suffixReplacementText: ${this.suffixReplacementText}
    skippedSuffix: ${this.skippedSuffix}
    start: ${this.range.startOffset}
    end: ${this.range.endOffset}`
  }
}
function TQ(e, t, r) {
  let n = "",
    i = t.completionText,
    s = e.document,
    o = s.offsetAt(r) - t.range.startOffset
  return (
    o < 0 ? (n = e.prefix.slice(o)) : (i = i.slice(o)),
    new Sf(n + i, t.suffixReplacementText, t.skippedSuffix, {
      startOffset: s.offsetAt(r),
      endOffset: t.range.endOffset,
    })
  )
}
function Zwe(e, t) {
  return `context:
    text: ${t.selectedCompletionInfo?.text}
    range: ${Yv(e, t.selectedCompletionInfo?.range)}
    triggerKind: ${t.triggerKind}`
}
function Xwe(e) {
  return `context:
    text: ${e.triggerCharacter}
    triggerKind: ${e.triggerKind}`
}
function pg(e, t) {
  return `ln: ${t.line} ch: ${t.character} offset: ${e.offsetAt(t)}`
}
function Yv(e, t) {
  return t === undefined
    ? "<undefined>"
    : `start: ${pg(e, t.start)} -> end: ${pg(e, t.end)}`
}
function kQ(e, t) {
  return t ? `${e}'${t}'` : ""
}
var Kv = class {
  constructor(t) {
    this._config = t
    this._documentation.isTrusted = true
  }
  _logger = z("CompletionItemsProvider")
  _documentation = new eu.MarkdownString(`This is a suggestion from Augment.

You can let us know about good or bad suggestions via [the History Panel](command:vscode-augment.showHistoryPanel).`)
  static triggerCharacters = [".", ":"]
  static languageSelector = [
    "python",
    "typescript",
    "javascript",
    "java",
    "go",
    "rust",
    "c",
    "cpp",
    "php",
    "csharp",
    "ruby",
    "bash",
    "html",
    "css",
    "scss",
    "less",
    "sass",
    "json",
    "yaml",
    "markdown",
    "xml",
    "sql",
    "swift",
    "kotlin",
    "objective-c",
    "perl",
    "scala",
    "lua",
    "groovy",
    "powershell",
    "*",
  ]
  async provideCompletionItems(t, r, n, i) {
    if (
      (this._logger.debug(
        `Pop-Up Request - ${t.uri.toString()} ${pg(t, r)}${kQ(" ", i.triggerCharacter)}`,
      ),
      this._logger.verbose(Xwe(i)),
      i.triggerKind === eu.CompletionTriggerKind.TriggerCharacter)
    )
      return (
        this._logger.debug(
          "Returning no completions because trigger kind was a trigger character",
        ),
        []
      )
    if (!this._config.config.completions.enableAutomaticCompletions)
      return this._logger.debug("Automatic completions are disabled"), []
    let s, o
    try {
      return await Promise.race([
        this._getCompletions(t, r, n),
        new Promise((a) => {
          let c = (0, eSe.debounce)(
            () => {
              this._logger.warn("Failed to find completions in time"), a([])
            },
            this._config.config.completions.timeoutMs,
            { maxWait: this._config.config.completions.maxWaitMs },
          )
          ;(o = onCompletionCancelled(() => {
            c()
          })),
            (s = c),
            c()
        }),
      ])
    } finally {
      o?.dispose(), s?.cancel()
    }
  }
  _getCompletionSuffix(t, r) {
    let n = r.substring(t.length, t.length + 50)
    if (n.length === 0) return ""
    let i = n.match(/^[^{}\[\]\(\)"`'<>]+/)
    return i ? (i[0] === n ? n : i[0] + "\u2026") : "\u2026"
  }
  async _getCompletions(t, r, n) {
    let i = await waitForEvent(onCompletionAvailable)
    if (!this._config.config.completions.enableQuickSuggestions)
      return (
        this._logger.debug("Enable IntelliSense suggestion is disabled"), []
      )
    if (!i) return this._logger.debug("No completion request"), []
    if (t !== i.document)
      return (
        this._logger.debug(
          `Completion request document does not match the current document.     current document: ${t.uri.toString()}     completion request document: ${i.document.uri.toString()}`,
        ),
        []
      )
    let s = []
    for (let o of i.completions) {
      this._logger.verbose(`AugmentCompletion: ${o.toString()}`)
      let a = t.getWordRangeAtPosition(r)?.start ?? r,
        l = TQ(i, o, a),
        c = t.offsetAt(r)
      if (c < l.range.startOffset || c > l.range.endOffset) {
        this._logger.debug(
          `Inline provider event does not satisfy this requests position.     completion item: ${pg(t, r)}    inline provider event: ${l.range.startOffset} => ${l.range.endOffset}}`,
        )
        continue
      }
      let u = t.offsetAt(r) - t.offsetAt(a),
        f = (l.completionText + l.suffixReplacementText).slice(u),
        p = f.split(/[^a-zA-Z0-9_]/).shift() ?? "",
        g = new eu.Range(a, r),
        y = t.getText(g) + p + this._getCompletionSuffix(p, f),
        v = new eu.CompletionItem(y)
      v.insertText = l.completionText + l.suffixReplacementText
      let C = new eu.Range(
        t.positionAt(l.range.startOffset),
        t.positionAt(t.offsetAt(r) + l.skippedSuffix.length),
      )
      ;(v.range = { inserting: C, replacing: C }),
        (v.preselect = false),
        (v.kind = eu.CompletionItemKind.Snippet),
        (v.detail = "Augment"),
        (v.documentation = this._documentation),
        (v.keepWhitespace = true),
        this._logger.debug(`insert: ${v.insertText}
label: ${y}
position: ${pg(t, r)}
inserting: ${Yv(t, v.range.inserting)}
replacing: ${Yv(t, v.range.replacing)})}`),
        s.push(v)
    }
    return n.isCancellationRequested
      ? (this._logger.debug("Completion cancelled"), [])
      : s
  }
}
var d6 = q(require("vscode"))
var cw = class extends Error {
  constructor(r) {
    super(`Configured model "${r}" is not available`)
    this.modelName = r
  }
}
var MQ = class extends Error {
    constructor() {
      super("No models available")
    }
  },
  mg = class extends Error {
    constructor(t = "Skipping inline completion.") {
      super(t)
    }
  }
function wCt(e, t) {
  return (r) => {
    let n = performance.now() - e
    return t(Math.round(n)), r
  }
}
function tSe(e, t) {
  return (...r) => {
    let n = performance.now(),
      i = wCt(n, t),
      s = e(...r)
    return s instanceof Promise ? s.then(i) : i(s)
  }
}
var CompletionsModel = class {
  constructor(t, r, n) {
    this._extension = t
    this._configListener = r
    this._metricsReporter = n
    this.generateCompletion = tSe(this.generateCompletion.bind(this), (i) => {
      this._metricsReporter.report({
        client_metric: "generate_completion_latency",
        value: i,
      })
    })
  }
  _logger = z("CompletionsModel")
  _completionSerial = 0
  async generateCompletion(t, r, n) {
    let i = this._extension.workspaceManager
    if (i === undefined) return
    let s = i.completionServer,
      o = s.createRequestId(),
      a = i.safeResolvePathName(t.uri)
    if (a === undefined) return
    let [l, c] = [a.rootPath, a.relPath],
      u = t.offsetAt(r),
      [f, p, g, m, y] = this._extractPrefixAndSuffix(t, u)
    u += y
    let v = { prefixBegin: g, cursorPosition: u, suffixEnd: m },
      E = (await this._requestCompletion(i, s, o, t, f, p, v, a, n))
        .completionItems
    if (E.length === 0)
      return {
        completions: [],
        document: t,
        requestId: o,
        repoRoot: l,
        pathName: c,
        prefix: f,
        suffix: p,
        occuredAt: new Date(),
        isReused: false,
      }
    E.length > 1 &&
      this._logger.warn(
        "Multiple completions not supported, ignoring all but the first",
      )
    let w = [],
      T = E[0]
    return (
      T.skippedSuffix.includes(`
`) &&
        (this._logger.debug("Skipped suffix spans multiple lines, dropping it"),
        (T.skippedSuffix = ""),
        (T.suffixReplacementText = "")),
      w.push(
        new Sf(T.text, T.suffixReplacementText, T.skippedSuffix, {
          startOffset: t.offsetAt(r),
          endOffset: t.offsetAt(r),
        }),
      ),
      this._logger.debug(`Returning ${w.length} completion(s)`),
      {
        occuredAt: new Date(),
        completions: w,
        document: t,
        requestId: o,
        repoRoot: l,
        pathName: c,
        prefix: f,
        suffix: p,
        isReused: false,
      }
    )
  }
  async _requestCompletion(t, r, n, i, s, o, a, l, c) {
    let u = i.languageId
    if (
      this._configListener.config.completions.disableCompletionsByLanguage.has(
        u,
      )
    )
      throw new mg(`Language ${u} is disabled.`)
    let p = this._completionSerial++
    this._logger.debug(
      `Requesting new completion - #${p} submitted; requestId: ${n}`,
    )
    let g = t.translateRange(l, a.prefixBegin, a.suffixEnd),
      m =
        g === undefined
          ? a
          : {
              prefixBegin: g.beginOffset,
              cursorPosition: a.cursorPosition,
              suffixEnd: g.endOffset,
            },
      y = t.getContext(),
      v = y.blobs,
      C = this._getRecentChanges(y),
      w = t.getEnableCompletionFileEditEvents() ? t.getFileEditEvents() : undefined
    try {
      let B = await r.complete(
        n,
        s,
        o,
        l.relPath,
        g?.blobName,
        m,
        u,
        v,
        C,
        w,
        undefined,
        undefined,
        c,
      )
      return (
        B.unknownBlobNames.length > 0 &&
          t.handleUnknownBlobs(y, B.unknownBlobNames),
        B.checkpointNotFound && t.handleUnknownCheckpoint(n, v.checkpointId),
        SCt(B.completionItems, o, this._logger),
        this._extension.updateModelInfo(B),
        (B.completionItems = B.completionItems.filter(
          (T) => (T.text + T.suffixReplacementText).length > 0,
        )),
        B
      )
    } catch (B) {
      if (ApiError.isAPIErrorWithStatus(B, RequestStatus.cancelled))
        throw (
          (this._logger.debug(
            `Completion #${p} cancelled in back end; requestId ${n}`,
          ),
          new mg("Cancelled in back end"))
        )
      if (ApiError.isRetriableAPIError(B))
        throw (
          (this._logger.debug(
            `Completion #${p} retriable error on back end; requestId ${n}`,
          ),
          new mg("Retriable error on back end"))
        )
      let T = getErrorMessage(B)
      throw (
        (this._logger.warn(`Completion #${p} failed: ${T}; requestId ${n}`), B)
      )
    }
  }
  _extractPrefixAndSuffix(t, r) {
    let n = this._extension.modelInfo,
      i = n.suggestedPrefixCharCount,
      s = n.suggestedSuffixCharCount,
      [o, a] = fbe(t)
    o !== undefined && (r += a)
    let l = Math.max(0, r - i),
      c = r + s
    if (o !== undefined) {
      let E = o.slice(l, r),
        w = o.slice(r, c)
      return [E, w, l, r + w.length, a]
    }
    let u = t.positionAt(l),
      f = t.positionAt(r),
      p = t.positionAt(r),
      g = t.positionAt(c),
      m = new d6.Range(u, f),
      y = new d6.Range(p, g),
      v = t.getText(m),
      C = t.getText(y)
    return [v, C, l, r + C.length, 0]
  }
  _getRecentChanges(t) {
    let r = t.recentChunks,
      n = t.lastChatResponse
    if (n !== undefined) {
      let i = {
          seq: n.seq,
          uploaded: false,
          repoRoot: "",
          pathName: "",
          blobName: "",
          text: n.text,
          origStart: 0,
          origLength: 0,
          expectedBlobName: "",
        },
        s = r.findIndex((o) => o.seq < i.seq)
      s < 0 && (s = r.length),
        (r = r.slice(0, s).concat([i]).concat(r.slice(s)))
    }
    return convertToChangeRecords(r)
  }
}
function SCt(e, t, r) {
  for (let n of e)
    t.startsWith(n.skippedSuffix) ||
      (r.warn(
        `Skipped suffix does not match the actual suffix. Skipped suffix: ${n.skippedSuffix}. First ${n.skippedSuffix.length} characters of suffix: ${t.substring(0, n.skippedSuffix.length)}`,
      ),
      (n.suffixReplacementText = ""),
      (n.skippedSuffix = ""))
}
var Ag = q(require("vscode"))
var $m = class {
  constructor(t) {
    this._statusBar = t
  }
  _state
  setState(t) {
    return (
      this.dispose(), (this._state = this._statusBar.setState(t)), this._state
    )
  }
  dispose() {
    this._state?.dispose()
  }
}
var uw = require("vscode")
var QQ = ((i) => (
    (i[(i.high = 0)] = "high"),
    (i[(i.medium = 1)] = "medium"),
    (i[(i.low = 2)] = "low"),
    (i[(i.neutral = 3)] = "neutral"),
    i
  ))(QQ || {}),
  f6 = Object.values(QQ)
    .filter((e) => typeof e == "number")
    .sort()
var zv = {
    background: new uw.ThemeColor("statusBarItem.warningBackground"),
    foreground: new uw.ThemeColor("statusBarItem.warningForeground"),
  },
  h6 = {
    background: new uw.ThemeColor("statusBarItem.errorBackground"),
    foreground: new uw.ThemeColor("statusBarItem.errorForeground"),
  },
  rSe = { priority: 3, tooltip: "Augment", icon: "$(augment-icon-simple)" },
  nSe = { priority: 3, tooltip: "Open Augment", icon: "$(augment-icon-smile)" },
  iSe = {
    priority: 0,
    tooltip: "Sign in to start using Augment",
    icon: "$(augment-icon-simple)",
    colors: zv,
  },
  sSe = {
    priority: 2,
    tooltip: "Augment is indexing your codebase",
    icon: "$(sync)",
  },
  oSe = {
    priority: 0,
    tooltip: "No API token",
    icon: "$(augment-icon-simple)",
    colors: zv,
  },
  aSe = {
    priority: 0,
    tooltip: "No completion URL",
    icon: "$(augment-icon-simple)",
    colors: zv,
  },
  lSe = {
    priority: 2,
    tooltip: "Initializing Augment",
    icon: "$(loading~spin)",
  },
  cSe = {
    priority: 0,
    tooltip: "Authentication failed, please sign in again",
    icon: "$(augment-icon-simple)",
    colors: zv,
  },
  uSe = {
    priority: 0,
    tooltip:
      "Authentication failed, please check your API token and completion URL",
    icon: "$(augment-icon-simple)",
    colors: zv,
  },
  dSe = {
    priority: 0,
    tooltip:
      "The completion URL setting is invalid. Please enter a valid value",
    icon: "$(augment-icon-simple)",
    colors: zv,
  },
  fSe = {
    priority: 2,
    tooltip: "Automatic completions are off",
    icon: "$(augment-icon-closed-eyes)",
  },
  hSe = {
    priority: 1,
    tooltip: "Enhancements are off",
    icon: "$(augment-icon-simple)",
  },
  g6 = {
    priority: 0,
    tooltip: "Cannot connect to Augment",
    icon: "$(augment-icon-simple)",
    colors: h6,
  },
  gSe = {
    priority: 0,
    tooltip: "Failed to generate completion",
    icon: "$(augment-icon-simple)",
    colors: h6,
  },
  pSe = {
    priority: 1,
    tooltip: "Generating completion",
    icon: "$(augment-icon-dots)",
  },
  mSe = {
    priority: 2,
    tooltip: "No completions generated",
    icon: "$(augment-icon-zero)",
  },
  ASe = {
    priority: 0,
    tooltip: "Failed to generate suggestions",
    icon: "$(augment-icon-simple)",
    colors: h6,
  },
  ySe = {
    priority: 1,
    tooltip: "Generating suggestions",
    icon: "$(augment-icon-dots)",
  },
  vSe = {
    priority: 2,
    tooltip: "No suggestions generated",
    icon: "$(augment-icon-zero)",
  },
  CSe = {
    priority: 0,
    tooltip: "Workspace indexing is disabled",
    icon: "$(circle-slash)",
  }
var NQ = class {
  rpcStart
  rpcEnd
  constructor() {}
}
var PQ = class extends NQ {
  requestStart
  emitTime
  constructor(t = Date.now(), r, n, i) {
    super(),
      (this.requestStart = t),
      (this.rpcStart = r),
      (this.rpcEnd = n),
      (this.emitTime = i)
  }
  isComplete() {
    return [this.rpcStart, this.rpcEnd, this.emitTime].every(
      (r) => r !== undefined,
    )
  }
}
var fw = q(require("vscode"))
var LQ = class extends DisposableContainer {
  constructor(r) {
    super()
    this._metricsReporter = r
    this.addDisposables(
      fw.workspace.onDidChangeTextDocument((n) => {
        this._onTextDocumentChange(n)
      }),
      fw.window.onDidChangeActiveTextEditor(() => {
        this._rejectPendingCompletion()
      }),
      fw.window.onDidChangeWindowState(() => {
        this._rejectPendingCompletion()
      }),
      onCompletionAvailable((n) => {
        n && this._onNewCompletion(n)
      }),
    )
  }
  _logger = z("PendingCompletion")
  _pendingCompletion
  getPendingCompletion(r, n) {
    if (!this._pendingCompletion) {
      this._logger.verbose("No previous completion to use")
      return
    }
    if (this._pendingCompletion.document !== r) {
      this._logger.debug(
        `Not reusing previous completion as documents differ ${this._pendingCompletion.document.uri.toString()} vs ${r.uri.toString()}`,
      ),
        this._rejectPendingCompletion()
      return
    }
    let i = this._pendingCompletion.completion,
      s = r.offsetAt(n),
      o = i.range.endOffset + this._pendingCompletion.added
    if (s < i.range.startOffset) {
      this._logger
        .debug(`Not reusing previous completion as position is before completion: ${s} vs
                ${i.range.startOffset}`),
        this._rejectPendingCompletion()
      return
    }
    if (s > o) {
      this._logger
        .debug(`Not reusing previous completion as position is after completion: ${s} vs
                ${o}`),
        this._rejectPendingCompletion()
      return
    }
    let a = i.skippedSuffix,
      l = i.completionText,
      c = i.suffixReplacementText
    this._pendingCompletion.deleted > 0 &&
      (a = a.slice(this._pendingCompletion.deleted)),
      a === "" && ((l = l + c), (c = ""))
    let u = new Sf(l, c, a, { startOffset: i.range.startOffset, endOffset: o })
    return (
      this._logger.verbose(`Reusing pending completion: ${u.completionText}`),
      { ...this._pendingCompletion, completions: [u], isReused: true }
    )
  }
  _onNewCompletion(r) {
    let { completions: n, requestId: i } = r
    if (this._pendingCompletion?.requestId === i) return
    if (!n.length) {
      this._logger.verbose(`No completions in ${i}`),
        this._rejectPendingCompletion()
      return
    }
    if (n.length !== 1) {
      this._logger.warn(
        `Unable to handle multiple completions, received ${n.length}`,
      ),
        this._rejectPendingCompletion()
      return
    }
    let s = this._findLastMatches(n[0])
    if (!s) {
      this._logger
        .verbose(`Skipped suffix is not a subsequence of the suffix replacement text:
                ${n[0].skippedSuffix} !<= ${n[0].suffixReplacementText}`),
        this._rejectPendingCompletion()
      return
    }
    this._logger.verbose(
      `Registering pending completion: ${n[0].completionText}`,
    ),
      (this._pendingCompletion = {
        ...r,
        completion: this._stripCommonSkippedSuffix(n[0]),
        added: 0,
        deleted: 0,
        suffixMatches: s,
        emitTime: Date.now(),
      })
  }
  _findLastMatches(r) {
    let n = r.skippedSuffix,
      i = r.suffixReplacementText,
      s = [],
      o = n.length - 1,
      a = i.length - 1
    for (; o >= 0 && a >= 0; ) n[o] === i[a] && (s.push(a), o--), a--
    if (!(o >= 0)) return s.reverse()
  }
  _stripCommonSkippedSuffix(r) {
    let n = r.skippedSuffix,
      i = r.suffixReplacementText,
      s = 0
    for (
      ;
      s < n.length &&
      s < i.length &&
      n[n.length - 1 - s] === i[i.length - 1 - s];

    )
      s++
    return s === 0
      ? r
      : new Sf(r.completionText, i.slice(0, -s), n.slice(0, -s), r.range)
  }
  _onTextDocumentChange(r) {
    if (
      !this._pendingCompletion ||
      this._pendingCompletion.document !== r.document ||
      r.contentChanges.length === 0
    )
      return
    if (r.contentChanges.length > 1) {
      this._logger.verbose(
        `Unexpected number of content changes: ${r.contentChanges.length}`,
      ),
        this._rejectPendingCompletion()
      return
    }
    let n = this._normalizeChange(r.contentChanges[0])
    if (!n) {
      this._logger.verbose(
        `Unexpected content change: ${JSON.stringify(r.contentChanges[0])}`,
      ),
        this._rejectPendingCompletion()
      return
    }
    let i = this._pendingCompletion.added,
      s = this._pendingCompletion.deleted,
      o = this._pendingCompletion.completion,
      a = n.rangeOffset + n.rangeLength,
      l = o.range.startOffset + i,
      c = a - l,
      u = l - n.rangeOffset
    if (c < 0 || u < 0) {
      this._logger
        .verbose(`Change would delete or unadd negative characters: ${a} - ${l} < 0
                    or ${l} - ${n.rangeOffset} < 0`),
        this._rejectPendingCompletion()
      return
    }
    ;(s += c), (i -= u)
    let f = o.completionText + o.suffixReplacementText,
      p = n.text.length,
      g = f.slice(i, i + p)
    if (n.text.slice(0, g.length) !== g) {
      this._logger.verbose(`Pending completion mismatch: ${n.text} vs ${g}`),
        this._rejectPendingCompletion()
      return
    }
    if (((i += p), s < this._pendingCompletion.suffixMatches.length)) {
      let m = this._pendingCompletion.suffixMatches[s]
      if (i > o.completionText.length + m) {
        this._logger
          .verbose(`Remaining skipped suffix is not a subsequence of the remaining suffix replacement text:
                    ${o.skippedSuffix.slice(s)} !<= ${f.slice(i)}`),
          this._rejectPendingCompletion()
        return
      }
    }
    ;(this._pendingCompletion.added = i),
      (this._pendingCompletion.deleted = s),
      this._pendingCompletion.added >= f.length &&
      this._pendingCompletion.deleted >= o.skippedSuffix.length
        ? this._acceptPendingInlineCompletion()
        : (this._pendingCompletion.added >= f.length ||
            this._pendingCompletion.deleted > o.skippedSuffix.length) &&
          this._rejectPendingCompletion()
  }
  _normalizeChange(r) {
    if (!this._pendingCompletion) return
    let n = this._pendingCompletion.completion,
      i = this._pendingCompletion.added,
      s = this._pendingCompletion.deleted
    if (r.rangeOffset < n.range.startOffset) {
      let a = n.range.startOffset - r.rangeOffset
      return a > r.rangeLength
        ? undefined
        : {
            rangeLength: r.rangeLength - a,
            rangeOffset: r.rangeOffset + a,
            text: r.text.slice(a),
          }
    }
    let o = n.range.startOffset + i
    if (r.rangeOffset > o) {
      let a = r.rangeOffset - o
      return s + a > n.skippedSuffix.length
        ? undefined
        : {
            rangeLength: r.rangeLength + a,
            rangeOffset: r.rangeOffset - a,
            text: n.skippedSuffix.slice(s, s + a) + r.text,
          }
    }
    return {
      rangeLength: r.rangeLength,
      rangeOffset: r.rangeOffset,
      text: r.text,
    }
  }
  _rejectPendingCompletion() {
    this._pendingCompletion &&
      (fireAccept({
        requestId: this._pendingCompletion.requestId,
        acceptedIdx: -1,
        document: this._pendingCompletion.document,
      }),
      fireReject(false),
      this._logger.debug(
        `Rejecting completion: ${this._pendingCompletion.requestId}`,
      ),
      this._metricsReporter.reportResolution(
        this._pendingCompletion.requestId,
        this._pendingCompletion.emitTime,
        Date.now(),
        undefined,
      ),
      (this._pendingCompletion = undefined))
  }
  _acceptPendingInlineCompletion() {
    this._pendingCompletion &&
      (fireAccept({
        requestId: this._pendingCompletion.requestId,
        acceptedIdx: 0,
        document: this._pendingCompletion.document,
      }),
      fireReject(false),
      this._logger.debug(
        `Accepting completion: ${this._pendingCompletion.requestId}`,
      ),
      this._metricsReporter.reportResolution(
        this._pendingCompletion.requestId,
        this._pendingCompletion.emitTime,
        Date.now(),
        0,
      ),
      (this._pendingCompletion = undefined))
  }
}
var Ym = q(require("vscode"))
var UQ = class extends DisposableContainer {
  _logger = z("SuppressDeletedCompletions")
  _inProgressDeletion = undefined
  _prevCompletions = undefined
  constructor() {
    super(),
      this.addDisposables(
        Ym.workspace.onDidChangeTextDocument((t) => {
          this._onTextDocumentChange(t)
        }),
        Ym.window.onDidChangeActiveTextEditor((t) => {
          this._resetDeletions(t)
        }),
      )
  }
  _onTextDocumentChange(t) {
    if (
      (t.document.uri.scheme !== "file" && !isNotebookCell(t.document.uri)) ||
      t.contentChanges.length === 0
    )
      return
    if (
      this._inProgressDeletion === undefined ||
      t.contentChanges.length !== 1 ||
      t.contentChanges[0].text.length > 0 ||
      t.document !== this._inProgressDeletion.document
    ) {
      ;(this._inProgressDeletion = {
        document: t.document,
        preDeletionDocumentText: t.document.getText(),
        prevDeletionRange: undefined,
        prevDeletionText: undefined,
        curDocumentText: t.document.getText(),
      }),
        (this._prevCompletions = [])
      return
    }
    ;(this._inProgressDeletion.prevDeletionRange === undefined ||
      !this._areAdjacentDeletions(
        t.contentChanges[0].range,
        this._inProgressDeletion.prevDeletionRange,
      )) &&
      (this._inProgressDeletion.preDeletionDocumentText =
        this._inProgressDeletion.curDocumentText)
    let r = this._inProgressDeletion.curDocumentText.substring(
      t.contentChanges[0].rangeOffset,
      t.contentChanges[0].rangeOffset + t.contentChanges[0].rangeLength,
    )
    ;(this._inProgressDeletion.prevDeletionRange = t.contentChanges[0].range),
      (this._inProgressDeletion.prevDeletionText = r),
      (this._inProgressDeletion.curDocumentText = t.document.getText())
  }
  _areAdjacentDeletions(t, r) {
    return t.end.isEqual(r.start) || t.start.isEqual(r.start)
  }
  _resetDeletions(t) {
    if (((this._prevCompletions = []), t === undefined)) {
      this._inProgressDeletion = undefined
      return
    }
    this._inProgressDeletion = {
      document: t.document,
      preDeletionDocumentText: t.document.getText(),
      prevDeletionRange: undefined,
      prevDeletionText: undefined,
      curDocumentText: t.document.getText(),
    }
  }
  processRequest(t) {
    if (!t || !this._inProgressDeletion) return t
    let r = t.completions
    return (
      this._inProgressDeletion.document === t.document &&
        (r = t.completions.filter((n) =>
          this._checkIfCompletionWasDeleted(t, n)
            ? (this._logger.debug("Suppressing previously deleted completion"),
              false)
            : this._checkIfForwardDeletion(t, n)
              ? (this._logger.debug(
                  "Suppressing completion due to forward deletion",
                ),
                false)
              : true,
        )),
      this._inProgressDeletion.document === t.document &&
        (this._prevCompletions = [...t.completions]),
      (t.completions = r),
      t
    )
  }
  _checkIfCompletionWasDeleted(t, r) {
    let n = t.document,
      i = n.getText(
        new Ym.Range(n.positionAt(0), n.positionAt(r.range.startOffset)),
      ),
      s = n.getText(
        new Ym.Range(
          n.positionAt(r.range.endOffset + r.skippedSuffix.length),
          n.positionAt(n.getText().length),
        ),
      ),
      o = i + r.completionText + s
    return this._inProgressDeletion.preDeletionDocumentText === o
  }
  _checkIfForwardDeletion(t, r) {
    if (this._inProgressDeletion.prevDeletionRange)
      return this._prevCompletions?.some((i) => {
        let s = this._inProgressDeletion?.document?.positionAt(
            i.range.endOffset,
          ),
          o = t.document.positionAt(r.range.endOffset)
        if (!s || !s.isEqual(o)) return false
        let a = (i.completionText + i.suffixReplacementText).substring(
            i.range.endOffset - i.range.startOffset,
          ),
          l = r.completionText + r.suffixReplacementText,
          c = [a]
        if (
          (this._inProgressDeletion?.prevDeletionText &&
            c.push(a + this._inProgressDeletion?.prevDeletionText),
          !c.some((f) => f === l))
        )
          return false
        let u = this._inProgressDeletion?.document.positionAt(i.range.endOffset)
        return (
          u &&
          this._inProgressDeletion?.prevDeletionRange?.start &&
          u.isEqual(this._inProgressDeletion.prevDeletionRange.start)
        )
      })
  }
}
var ICt = 2e3,
  OQ = class extends DisposableContainer {
    constructor(r, n, i, s, o) {
      super()
      this._completionsModel = r
      this._config = s
      this._timelineReporter = o
      ;(this._pendingCompletions = new LQ(n)),
        (this._stateController = new $m(i)),
        this.addDisposable(this._pendingCompletions),
        this.addDisposable(this._deletedCompletions),
        this.addDisposable(
          Ag.window.onDidChangeTextEditorSelection((a) => {
            a.textEditor.document.uri.scheme === "file" && fireReject(false)
          }),
        )
    }
    _logger = z("InlineCompletionProvider")
    _pendingCompletions
    _deletedCompletions = new UQ()
    _stateController
    async provideInlineCompletionItems(r, n, i, s) {
      let o = new PQ()
      if (
        !this._config.config.completions.enableAutomaticCompletions &&
        i.triggerKind === Ag.InlineCompletionTriggerKind.Automatic
      )
        return fireReject(false), []
      this._stateController.dispose(),
        this._logger.debug(
          `Inline Request - ${r.uri.toString()} ${pg(r, n)}${kQ(" ", i.selectedCompletionInfo?.text)}`,
        ),
        this._logger.verbose(Zwe(r, i))
      let a = await this._getCompletions(r, n, i, o),
        l = this._deletedCompletions.processRequest(a)
      if (s.isCancellationRequested)
        return this._logger.debug("Completion cancelled"), fireCancel(), fireReject(false), []
      if ((fireCompletion(l), !l))
        return this._logger.debug("Returning no completions"), fireReject(false), []
      ;(o.emitTime = Date.now()),
        l.isReused ||
          this._timelineReporter.reportCompletionTimeline(l.requestId, o)
      let c = l.completions.map((u) => {
        this._logger.verbose(`AugmentCompletion: ${u.toString()}`)
        let f = new Ag.InlineCompletionItem(
          u.completionText + u.suffixReplacementText,
          new Ag.Range(
            r.positionAt(u.range.startOffset),
            r.positionAt(u.range.endOffset + u.skippedSuffix.length),
          ),
        )
        return (
          this._logger.verbose(
            `InlineCompletionItem: ${JSON.stringify(f.insertText)} ${Yv(r, f.range)}`,
          ),
          f
        )
      })
      return c.length > 0 && fireReject(true), c
    }
    async _getCompletions(r, n, i, s) {
      let o = this._pendingCompletions.getPendingCompletion(r, n)
      if (o && o.completions.length > 0) {
        let l = this._processCompletionForMode(o, i)
        return (
          this._logger.debug(`Returning ${l.length} completions`),
          { ...o, completions: l }
        )
      }
      if (i.selectedCompletionInfo?.text) {
        this._logger.debug(
          "Returning no completions because the provider request includes selected text that does not match an Augment suggestion",
        )
        return
      }
      let a = this._stateController.setState(pSe)
      try {
        let l = await this._completionsModel.generateCompletion(r, n, s)
        if (l && l.completions.length === 0) {
          let c = this._stateController.setState(mSe)
          setTimeout(() => {
            c.dispose()
          }, ICt)
        }
        return l
      } catch (l) {
        l instanceof mg || this._stateController.setState(gSe)
      } finally {
        a.dispose()
      }
    }
    _processCompletionForMode(r, n) {
      if (!n.selectedCompletionInfo || !n.selectedCompletionInfo.text)
        return r.completions
      let i = n.selectedCompletionInfo.range.start
      return r.completions.map((o) => TQ(r, o, i))
    }
  }
var bSe = q(require("vscode"))
var yg = class extends DisposableContainer {
  constructor(r = 100, n = () => true) {
    super()
    this._itemVerifier = n
    ;(this._ringBuffer = new CircularBuffer(r)),
      this.addDisposable(this._newItemEventEmitter)
  }
  _ringBuffer
  _newItemEventEmitter = new bSe.EventEmitter()
  get onNewItems() {
    return this._newItemEventEmitter.event
  }
  get items() {
    return this._ringBuffer.slice()
  }
  get mostRecentItem() {
    return this._ringBuffer.at(-1)
  }
  addItem(r) {
    this._itemVerifier(r) &&
      (this._ringBuffer.addItem(r), this._newItemEventEmitter.fire(r))
  }
}
var qQ = class extends yg {
  constructor() {
    super(100, (t) => t.completions.length > 0 && !t.isReused)
  }
}
var HQ = q(require("vscode"))
var ESe = q(require("crypto"))
function createSHA256Hash(data) {
  let hasher = ESe.createHash("sha256")
  return hasher.update(data), hasher.digest("hex")
}
var Range = class e {
    constructor(t, r) {
      this.start = t
      this.stop = r
    }
    equals(t) {
      return this.start === t.start && this.stop === t.stop
    }
    get length() {
      return this.stop - this.start
    }
    toString() {
      return `[${this.start}, ${this.stop})`
    }
    compareTo(t) {
      return this.start - t.start
    }
    contains(t) {
      return (
        typeof t == "number" && (t = new e(t, t + 1)),
        this.start <= t.start && this.stop >= t.stop && this.stop > t.start
      )
    }
    intersects(t) {
      return (
        typeof t == "number" && (t = new e(t, t + 1)),
        this.start < t.stop && this.stop > t.start
      )
    }
    touches(t) {
      return (
        typeof t == "number" && (t = new e(t, t + 1)),
        this.start === t.stop || this.stop === t.start
      )
    }
    intersection(t) {
      if (this.intersects(t))
        return new e(Math.max(this.start, t.start), Math.min(this.stop, t.stop))
    }
    distanceTo(t) {
      return (
        typeof t == "number" && (t = new e(t, t + 1)),
        -Math.min(
          0,
          Math.min(this.stop, t.stop) - Math.max(this.start, t.start),
        )
      )
    }
    offset(t, r, n = -1 / 0, i = 1 / 0) {
      let s = Math.min(i, Math.max(n, this.start + t)),
        o = Math.max(n, Math.min(i, this.stop + r))
      if (s > o) {
        let a = Math.ceil((this.start + this.stop) / 2),
          l = Math.max(n, Math.min(i, a))
        return new e(l, l)
      }
      return new e(s, o)
    }
    static anyOverlaps(t) {
      if (t.length <= 1) return false
      t.sort((n, i) =>
        n.start === i.start ? n.stop - i.stop : n.start - i.start,
      )
      let r = t[0].stop
      for (let n = 1; n < t.length; n++) {
        if (t[n].start < r) return true
        r = t[n].stop
      }
      return false
    }
    static mergeTouching(t) {
      if (t.length <= 1) return [...t]
      let r = [...t].sort((i, s) => i.start - s.start),
        n = [r[0]]
      for (let i = 1; i < r.length; i++) {
        let s = n[n.length - 1],
          o = r[i]
        s.stop >= o.start ? (s.stop = Math.max(s.stop, o.stop)) : n.push(o)
      }
      return n
    }
  },
  CharRange = class extends Range {},
  LineRange = class extends Range {}
function BCt(e, t) {
  let r = t.text === undefined ? "" : t.text,
    n
  return (
    t.rangeOffset !== undefined && t.rangeLength !== undefined
      ? (n = { start: t.rangeOffset, end: t.rangeOffset + t.rangeLength })
      : (n = {
          start: e.offsetAt(t.range.start),
          end: e.offsetAt(t.range.end),
        }),
    { text: r, range: n }
  )
}
var p6 = class {
    constructor(t, r, n) {
      this._uploadBatchFunction = t
      this._batchSize = r
      this._maxUploadDelayMs = n
    }
    _queue = []
    _queueNonEmptyTimer
    add(t) {
      if (
        (this._queue.push(t),
        this._queue.length === 1 &&
          (clearTimeout(this._queueNonEmptyTimer),
          (this._queueNonEmptyTimer = setTimeout(() => {
            this._uploadBatch()
          }, this._maxUploadDelayMs))),
        this._queue.length >= this._batchSize)
      ) {
        let r = this._queue
        this._queue = []
        let n = { user_events: r }
        this._uploadBatchFunction(n)
      }
    }
    _uploadBatch() {
      let t = this._queue
      this._queue = []
      let r = t.length,
        n = { user_events: t }
      r !== 0 && this._uploadBatchFunction(n),
        clearTimeout(this._queueNonEmptyTimer)
    }
    dispose() {
      this.stop()
    }
    stop() {
      clearTimeout(this._queueNonEmptyTimer)
    }
  },
  m6 = class {
    constructor(t) {
      this._apiServer = t
      this._logger = z("UploadHandler")
    }
    _logger
    _lastErrorTime
    _uploadInterruptPeriodMs = 15e3
    async uploadUserEvents(t) {
      try {
        if (
          this._lastErrorTime
            ? Date.now() - this._lastErrorTime < this._uploadInterruptPeriodMs
            : false
        )
          return
        await this._apiServer.uploadUserEvents(t)
      } catch (r) {
        throw (
          (this._logger.info("Error uploading tracked events", r),
          (this._lastErrorTime = Date.now()),
          r)
        )
      }
    }
  },
  VQ = class e extends DisposableContainer {
    constructor(
      r,
      n,
      i,
      s,
      o,
      a = e.defaultUploadBatchSize,
      l = e.defaultMaxUploadDelayMs,
    ) {
      super()
      this._pathResolver = n
      this._recentInstructions = i
      this._recentCompletions = s
      this._recentNextEditSuggestions = o
      ;(this._uploadHandler = new m6(r)),
        (this._uploadQueue = new p6(
          (c) =>
            void this._uploadHandler.uploadUserEvents.bind(this._uploadHandler)(
              c,
            ),
          a,
          l,
        )),
        this._createSubscriptions(),
        this.addDisposable(this._uploadQueue)
    }
    static defaultUploadBatchSize = 128
    static defaultMaxUploadDelayMs = 5e3
    _uploadQueue
    _uploadHandler
    _createSubscriptions() {
      this.addDisposable(
        HQ.workspace.onDidChangeTextDocument(
          this._processChangeTextDocument.bind(this),
        ),
      ),
        this.addDisposable(
          this._recentInstructions.onNewItems(
            this._processInstruction.bind(this),
          ),
        ),
        this.addDisposable(
          this._recentCompletions.onNewItems(
            this._processCompletion.bind(this),
          ),
        ),
        this.addDisposable(
          this._recentNextEditSuggestions.onNewItems(
            this._processNextEdit.bind(this),
          ),
        )
    }
    _processChangeTextDocument(r) {
      let n = r.document.uri.fsPath,
        i = new Date().toISOString(),
        s = this._pathResolver.resolvePathName(n)
      if (s === undefined || r.contentChanges.length === 0) return
      let o = []
      for (let y of r.contentChanges) o.push(BCt(r.document, y))
      let a = 500,
        l = r.document.getText().length,
        c = o
          .map((y) => new CharRange(y.range.start, y.range.end))
          .map((y) => y.offset(-a, a, 0, l)),
        u = Range.mergeTouching(c),
        f = u.map((y) =>
          r.document.getText(
            new HQ.Range(
              r.document.positionAt(y.start),
              r.document.positionAt(y.stop),
            ),
          ),
        ),
        p = createSHA256Hash(new TextEncoder().encode(f.join(""))),
        g = {
          reason: r.reason,
          content_changes: o,
          after_changes_hash: p,
          source_folder_root: s.rootPath,
          hash_char_ranges: u.map((y) => ({ start: y.start, end: y.stop })),
          after_doc_length: l,
        },
        m = { time: i, file_path: s.relPath, text_edit: g }
      this._uploadQueue.add(m)
    }
    _processInstruction(r) {
      let n = { request_id: r.requestId },
        i = {
          time: r.requestedAt.toISOString(),
          file_path: r.pathName,
          edit_request_id_issued: n,
        }
      this._uploadQueue.add(i)
    }
    _processNextEdit(r) {
      let n = { request_id: r.requestId },
        i = {
          time: r.requestTime.toISOString(),
          file_path: r.qualifiedPathName?.relPath ?? "",
          next_edit_request_id_issued: n,
        }
      this._uploadQueue.add(i)
    }
    _processCompletion(r) {
      let n = {
        time: r.occuredAt.toISOString(),
        file_path: r.pathName ?? "",
        completion_request_id_issued: { request_id: r.requestId },
      }
      this._uploadQueue.add(n)
    }
  }
var Zv = q(require("vscode"))
var A6 = class {
    constructor(t, r, n) {
      this.uri = t
      this.diagnostic = r
      this.time = n
    }
  },
  y6 = class {
    constructor(t, r, n, i) {
      this.uri = t
      this.diagnostic = r
      this.charStart = n
      this.charEnd = i
    }
  }
function RCt(e, t) {
  return (
    e.message === t.message &&
    e.severity === t.severity &&
    e.range.isEqual(t.range)
  )
}
var WQ = class e extends DisposableContainer {
  static _maxDiagnosticsPerFile = 10
  _diagnostics = new Map()
  _logger = z("DiagnosticsManager")
  constructor() {
    super(),
      this.addDisposable(
        Zv.languages.onDidChangeDiagnostics((t) => {
          let r = new Date()
          for (let n of t.uris) {
            if (isNotebookCell(n)) continue
            let i = this._diagnostics.get(n.path),
              s = Zv.languages
                .getDiagnostics(n)
                .slice(0, e._maxDiagnosticsPerFile),
              o = []
            for (let a of s) {
              if (
                a.severity !== Zv.DiagnosticSeverity.Error &&
                a.severity !== Zv.DiagnosticSeverity.Warning
              )
                continue
              let l = i?.find((c) => RCt(c.diagnostic, a))
              l === undefined ? o.push(new A6(n, a, r)) : o.push(l)
            }
            this._diagnostics.set(n.path, o)
          }
        }),
      )
  }
  async getMostRecentDiagnostics(t, r, n = undefined) {
    let s = Array.from(this._diagnostics.entries())
        .flatMap(([c, u]) => (n !== undefined && !c.startsWith(n) ? [] : u))
        .sort((c, u) => {
          let f = u.time.getTime() - c.time.getTime()
          return f !== 0 ? f : c.diagnostic.severity - u.diagnostic.severity
        }),
      o = new Map(),
      a = [],
      l = new Map()
    for (let c of s) {
      if (
        c.diagnostic.range.start.line < 0 ||
        c.diagnostic.range.start.line > c.diagnostic.range.end.line
      ) {
        this._logger.debug(
          `Ignoring invalid diagnostic ${c.diagnostic.message} in ${c.uri.path} at ${c.diagnostic.range.start.line}:${c.diagnostic.range.end.line}`,
        )
        continue
      }
      let u = o.get(c.uri.path) ?? 0
      if (u < r) {
        if (!l.has(c.uri.path))
          try {
            l.set(c.uri.path, await Io(c.uri))
          } catch {
            this._logger.debug(`Failed to open document ${c.uri.fsPath}.`)
            continue
          }
        let f = l.get(c.uri.path)
        if (!f) continue
        if (c.diagnostic.range.end.line >= f.lineCount) {
          this._logger.debug(
            `Ignoring stale diagnostic ${c.diagnostic.message} in ${c.uri.path} at ${c.diagnostic.range.start.line}:${c.diagnostic.range.end.line}`,
          )
          continue
        }
        let p = f.offsetAt(c.diagnostic.range.start),
          g = f.offsetAt(c.diagnostic.range.end)
        if (
          (a.push(new y6(c.uri, c.diagnostic, p, g)),
          o.set(c.uri.path, u + 1),
          a.length >= t)
        )
          break
      }
    }
    return a
  }
}
var v6 = q(RA()),
  ps = q(require("vscode"))
var DCt = 5,
  GQ = class extends DisposableContainer {
    constructor(r, n) {
      super()
      this._keybindingWatcher = r
      this._inlineCompletionProvider = n
      this.createDecorationTypes(),
        this.addDisposables(...this.setupEmptyFileHint())
      let i = ps.window.activeTextEditor
      i && i.document.getText() === "" && this.debouncedDecorations(i),
        this._logger.info("HotKeyHints initialized")
    }
    _logger = z("HotKeyHints")
    activeCompletion = false
    emptyFileHotKeyHintDecorationType
    debouncedDecorations = (0, v6.default)(
      (r) => {
        ;(r.document.uri.scheme === "file" ||
          r.document.uri.scheme === "untitled") &&
        r.document.getText() === "" &&
        !this.activeCompletion
          ? r.setDecorations(this.emptyFileHotKeyHintDecorationType, [
              r.selection,
            ])
          : this.hideHints(r)
      },
      DCt,
      { leading: false, trailing: true },
    )
    createDecorationTypes() {
      let r = this._keybindingWatcher.getKeybindingForCommand(Separator.commandID),
        n = ""
      r
        ? (n = `${r} to open Augment.`)
        : (n = "Click the robot icon in the side bar to open Augment."),
        (this.emptyFileHotKeyHintDecorationType =
          ps.window.createTextEditorDecorationType({
            after: {
              contentText: n,
              color: "rgba(150, 150, 150, 0.9)",
              margin: "0 0 0 0.5rem",
            },
          }))
    }
    setupEmptyFileHint() {
      let r = []
      return (
        r.push({
          dispose: () => {
            this.debouncedDecorations.cancel()
          },
        }),
        this._inlineCompletionProvider &&
          (r.push(
            onCompletionAvailable((n) => {
              let i = ps.window.activeTextEditor
              !i ||
                !n ||
                n.completions.length === 0 ||
                (this.debouncedDecorations.cancel(),
                this.hideHints(i),
                (this.activeCompletion = true))
            }),
          ),
          r.push(
            onCompletionCancelled(() => {
              this.activeCompletion = false
              let n = ps.window.activeTextEditor
              !n || n.document.getText() !== "" || this.debouncedDecorations(n)
            }),
          )),
        ps.workspace.onDidCloseTextDocument(() => {
          this.activeCompletion = false
        }),
        r.push(
          ps.window.onDidChangeActiveTextEditor((n) => {
            !n ||
              n.document.getText() !== "" ||
              ((this.activeCompletion = false), this.debouncedDecorations(n))
          }),
        ),
        r.push(
          ps.workspace.onDidChangeTextDocument((n) => {
            if (
              (n.contentChanges.length > 0 && (this.activeCompletion = false),
              n.document.uri.scheme !== "file" &&
                n.document.uri.scheme !== "untitled")
            )
              return
            let i = ps.window.activeTextEditor
            if (
              !(!i || i.document.uri.toString() !== n.document.uri.toString())
            ) {
              if (i.document.getText() !== "") {
                this.hideHints(i)
                return
              }
              this.activeCompletion || this.debouncedDecorations(i)
            }
          }),
        ),
        r
      )
    }
    hideHints(r) {
      r.setDecorations(this.emptyFileHotKeyHintDecorationType, [])
    }
  },
  $Q = class extends DisposableContainer {
    constructor(r, n) {
      super()
      this._keybindingWatcher = r
      this._inlineCompletionProvider = n
      this.createDecorationTypes(),
        this.addDisposables(...this.setupEmptyLineHint())
    }
    _logger = z("EmptyLineHints")
    activeCompletion = false
    decorationType
    debouncedDecorations = (0, v6.default)(
      (r) => {
        let n = r.selection.active,
          s = r.document.lineAt(n.line).text,
          o = s.lastIndexOf(" ") !== -1 ? s.lastIndexOf(" ") : s.length - 1,
          a = new ps.Range(n.line, o + 1, n.line, o + 1)
        ;/\S/.test(s) === false && (s.trim() === "" || n.character === s.length)
          ? r.setDecorations(this.decorationType, [a])
          : this.hideHints(r)
      },
      16,
      { leading: false, trailing: true },
    )
    createDecorationTypes() {
      let r = "",
        n = this._keybindingWatcher.getKeybindingForCommand(
          "augment-chat.focus",
          true,
        )
      n && (r = `${n} to open Augment`),
        (this.decorationType = ps.window.createTextEditorDecorationType({
          after: {
            contentText: r,
            color: "rgba(150, 150, 150, 0.5)",
            margin: "0 0 0 1.2rem",
          },
        }))
    }
    setupEmptyLineHint() {
      let r = []
      return (
        r.push({
          dispose: () => {
            this.debouncedDecorations.cancel()
          },
        }),
        this._inlineCompletionProvider &&
          (r.push(
            onCompletionAvailable((n) => {
              let i = ps.window.activeTextEditor
              !i ||
                !n ||
                n.completions.length === 0 ||
                (this.debouncedDecorations.cancel(),
                this.hideHints(i),
                (this.activeCompletion = true))
            }),
          ),
          r.push(
            onCompletionCancelled(() => {
              this.activeCompletion = false
              let n = ps.window.activeTextEditor
              n && this.debouncedDecorations(n)
            }),
          )),
        r.push(
          ps.window.onDidChangeTextEditorSelection((n) => {
            this.debouncedDecorations(n.textEditor)
          }),
        ),
        r.push(
          ps.workspace.onDidChangeTextDocument((n) => {
            let i = ps.window.activeTextEditor
            !i ||
              i.document.uri.toString() !== n.document.uri.toString() ||
              this.activeCompletion ||
              this.debouncedDecorations(i)
          }),
        ),
        r
      )
    }
    hideHints(r) {
      r.setDecorations(this.decorationType, [])
    }
  }
var wSe = q(require("vscode"))
var _Se = new Map([
    ["authenticated", { name: "authenticated", status: "initializing" }],
    ["syncingPermitted", { name: "syncingPermitted", status: "complete" }],
    [
      "disabledGithubCopilot",
      { name: "disabledGithubCopilot", status: "initializing" },
    ],
    [
      "hasMovedExtensionAside",
      { name: "hasMovedExtensionAside", status: "incomplete" },
    ],
    [
      "workspacePopulated",
      { name: "workspacePopulated", status: "initializing" },
    ],
    [
      "workspaceSelected",
      { name: "workspaceSelected", status: "initializing" },
    ],
    ["disabledCodeium", { name: "disabledCodeium", status: "initializing" }],
    ["uploadingHomeDir", { name: "uploadingHomeDir", status: "initializing" }],
    [
      "workspaceTooLarge",
      { name: "workspaceTooLarge", status: "initializing" },
    ],
  ]),
  xSe = new Map([
    [
      "UserShouldSignIn",
      {
        name: "UserShouldSignIn",
        renderOrder: 0,
        desiredConditions: [{ name: "authenticated", status: "incomplete" }],
      },
    ],
    [
      "SyncingPermissionNeeded",
      {
        name: "SyncingPermissionNeeded",
        renderOrder: 1,
        desiredConditions: [
          { name: "syncingPermitted", status: "initializing" },
        ],
      },
    ],
    [
      "uploadingHomeDir",
      {
        name: "uploadingHomeDir",
        renderOrder: 2,
        desiredConditions: [{ name: "uploadingHomeDir", status: "complete" }],
      },
    ],
    [
      "workspaceTooLarge",
      {
        name: "workspaceTooLarge",
        renderOrder: 2,
        desiredConditions: [{ name: "workspaceTooLarge", status: "complete" }],
      },
    ],
    [
      "ShouldDisableCopilot",
      {
        name: "ShouldDisableCopilot",
        renderOrder: 3,
        desiredConditions: [
          { name: "authenticated", status: "complete" },
          { name: "disabledGithubCopilot", status: "incomplete" },
        ],
      },
    ],
    [
      "ShouldDisableCodeium",
      {
        name: "ShouldDisableCodeium",
        renderOrder: 3,
        desiredConditions: [
          { name: "authenticated", status: "complete" },
          { name: "disabledCodeium", status: "incomplete" },
        ],
      },
    ],
    [
      "WorkspaceNotSelected",
      {
        name: "WorkspaceNotSelected",
        renderOrder: 5,
        desiredConditions: [
          { name: "authenticated", status: "complete" },
          { name: "syncingPermitted", status: "complete" },
          { name: "workspaceSelected", status: "incomplete" },
        ],
      },
    ],
    [
      "WorkspacePopulated",
      {
        name: "WorkspacePopulated",
        renderOrder: 5,
        desiredConditions: [
          { name: "authenticated", status: "complete" },
          { name: "syncingPermitted", status: "complete" },
          { name: "workspaceSelected", status: "complete" },
          { name: "workspacePopulated", status: "complete" },
        ],
      },
    ],
    [
      "WorkspaceNotPopulated",
      {
        name: "WorkspaceNotPopulated",
        renderOrder: 5,
        desiredConditions: [
          { name: "authenticated", status: "complete" },
          { name: "syncingPermitted", status: "complete" },
          { name: "workspaceSelected", status: "complete" },
          { name: "workspacePopulated", status: "incomplete" },
        ],
      },
    ],
    [
      "AllActionsComplete",
      {
        name: "AllActionsComplete",
        renderOrder: 6,
        desiredConditions: [
          { name: "authenticated", status: "complete" },
          { name: "syncingPermitted", status: "complete" },
          { name: "disabledGithubCopilot", status: "complete" },
          { name: "disabledCodeium", status: "complete" },
          { name: "workspacePopulated", status: "complete" },
          { name: "workspaceSelected", status: "complete" },
        ],
      },
    ],
  ]),
  ActionsStateModel = class extends DisposableContainer {
    _systemStates
    _derivedStates
    _onDerivedStatesSatisfied = new wSe.EventEmitter()
    _systemToDerivedStateMap = new Map()
    _globalState
    _satisfiedDerivedStates = new Set()
    constructor(globalState, defaultSystemStates = _Se, defaultDerivedStates = xSe) {
      super(),
        this.addDisposable(this._onDerivedStatesSatisfied),
        (this._systemStates = new Map(defaultSystemStates)),
        (this._derivedStates = new Map(defaultDerivedStates)),
        (this._globalState = globalState),
        this.loadSystemStates(),
        this._derivedStates.forEach(
          this.updateSystemToDerivedStateMap.bind(this),
        ),
        this._derivedStates.forEach((derivedState) => {
          this._isStateSatisfied(derivedState) && this._satisfiedDerivedStates.add(derivedState.name)
        }),
        this._emitSatisfiedStates()
    }
    get satisfiedStates() {
      return Array.from(this._satisfiedDerivedStates)
        .map((stateName) => this._derivedStates.get(stateName))
        .sort((stateA, stateB) => stateA.renderOrder - stateB.renderOrder)
    }
    saveSystemStates() {
      let serializedStates = JSON.stringify(Array.from(this._systemStates.entries()))
      this._globalState.update("actionSystemStates", serializedStates)
    }
    loadSystemStates() {
      let serializedStates = this._globalState.get("actionSystemStates") || "[]"
      new Map(JSON.parse(serializedStates)).forEach((state) => {
        this._systemStates.set(state.name, state)
      })
    }
    get onDerivedStatesSatisfied() {
      return this._onDerivedStatesSatisfied.event
    }
    updateSystemToDerivedStateMap(derivedState) {
      derivedState.desiredConditions.forEach((condition) => {
        this._systemToDerivedStateMap.has(condition.name) ||
          this._systemToDerivedStateMap.set(condition.name, new Set()),
          this._systemToDerivedStateMap.get(condition.name).add(derivedState.name)
      })
    }
    setSystemStateStatus(stateName, status) {
      let state = { name: stateName, status: status }
      this._systemStates.set(state.name, state), this.saveSystemStates()
      let affectedDerivedStates = this._systemToDerivedStateMap.get(state.name) || new Set(),
        statesChanged = false
      affectedDerivedStates.forEach((derivedStateName) => {
        let derivedState = this._derivedStates.get(derivedStateName)
        if (derivedState) {
          let wasSatisfied = this._satisfiedDerivedStates.has(derivedStateName),
            isSatisfied = this._isStateSatisfied(derivedState)
          wasSatisfied !== isSatisfied &&
            ((statesChanged = true),
            isSatisfied
              ? this._satisfiedDerivedStates.add(derivedStateName)
              : this._satisfiedDerivedStates.delete(derivedStateName))
        }
      }),
        statesChanged && this._emitSatisfiedStates(),
        this.saveSystemStates()
    }
    restartActionsState() {
      ;(this._systemStates = new Map(_Se)),
        (this._derivedStates = new Map(xSe)),
        (this._systemToDerivedStateMap = new Map()),
        (this._satisfiedDerivedStates = new Set()),
        this._derivedStates.forEach(
          this.updateSystemToDerivedStateMap.bind(this),
        ),
        this._derivedStates.forEach((derivedState) => {
          this._isStateSatisfied(derivedState) && this._satisfiedDerivedStates.add(derivedState.name)
        }),
        this._emitSatisfiedStates(),
        this.saveSystemStates()
    }
    getSystemState(stateName) {
      return this._systemStates.get(stateName)
    }
    addDerivedState(derivedState) {
      this._derivedStates.set(derivedState.name, derivedState),
        this.updateSystemToDerivedStateMap(derivedState),
        this._isStateSatisfied(derivedState) &&
          (this._satisfiedDerivedStates.add(derivedState.name),
          this._emitSatisfiedStates()),
        this.saveSystemStates()
    }
    isDerivedStateSatisfied(stateName) {
      let derivedState = this._derivedStates.get(stateName)
      return derivedState ? this._isStateSatisfied(derivedState) : false
    }
    isSystemStateComplete(stateName) {
      return this._systemStates.get(stateName)?.status === "complete"
    }
    _emitSatisfiedStates() {
      this._onDerivedStatesSatisfied.fire(this.satisfiedStates) // =
    }
    broadcastDerivedStates() {
      this._emitSatisfiedStates()
    }
    _isStateSatisfied(derivedState) {
      for (let condition of derivedState.desiredConditions) {
        let systemState = this._systemStates.get(condition.name)
        if (!systemState || systemState.status !== condition.status) return false
      }
      return true
    }
  }
var SSe = q(Yf()),
  hw = q(require("vscode"))
  var AwaitingSyncingPermissionApp = class extends DisposableContainer {
    constructor(actionsModel, apiServer, config, syncingEnabledTracker, changeWebviewAppEvent, featureFlagManager, userTier) {
      super()
      this._actionsModel = actionsModel
      this._apiServer = apiServer
      this._config = config
      this._syncingEnabledTracker = syncingEnabledTracker
      this._changeWebviewAppEvent = changeWebviewAppEvent
      this._featureFlagManager = featureFlagManager
      this._userTier = userTier
      this.addDisposables(
        this._actionsModel.onDerivedStatesSatisfied(
          this.handleDerivedStateChange.bind(this),
        ),
        this._syncingEnabledTracker.onDidChangeSyncingEnabled(
          this.sendSyncEnabledStatus.bind(this),
        ),
        this._actionsModel.onDerivedStatesSatisfied((states) => {
          for (let state of states) // =
            (state.name === "WorkspacePopulated" ||
              state.name === "WorkspaceNotPopulated") &&
              ((this._workspaceChecked = true),
              this._waitingOnWorkspace &&
                ((this._waitingOnWorkspace = false), this.changeToChatApp()))
        }),
      )
    }
    _logger = z("AwaitingSyncingPermissionApp")
    _webview
    _asyncMsgHandler
    _workspaceChecked = false
    _waitingOnWorkspace = false
    appType() {
      return "awaiting-syncing-permission"
    }
    title() {
      return "Syncing Permission Needed"
    }
    register(webview) {
      this._logger.info("Registering AwaitingSyncingPermissionApp"),
        (this._webview = webview),
        this.addDisposable(
          webview.onDidReceiveMessage((message) => this.onMessageFromWebview(message)),
        )
    }
    sendSyncEnabledStatus = (0, SSe.default)(
      () => {
        this._webview?.postMessage({ // =
          type: "sync-enabled-state",
          data: this._syncingEnabledTracker.syncingEnabledState,
        })
      },
      250,
      { leading: true, trailing: true },
    )
    async handleDerivedStateChange(states) {
      let relevantStates = new Set([
          "SyncingPermissionNeeded",
          "uploadingHomeDir",
          "workspaceTooLarge",
          "WorkspaceNotSelected",
        ]),
        matchingStates = states.map((state) => state.name).filter((name) => relevantStates.has(name))
      if (matchingStates.length === 0) {
        this._workspaceChecked
          ? this.changeToChatApp()
          : (this._waitingOnWorkspace = true)
        return
      }
      await this.sendActionsToWebview(matchingStates)
    }
    changeToChatApp() {
      this._changeWebviewAppEvent.fire("chat") // =
    }
    async sendActionsToWebview(actions) {
      await this._webview?.postMessage({ type: "main-panel-actions", data: actions })
    }
    onMessageFromWebview(message) {
      switch (message.type) {
        case "main-panel-perform-action":
          this.performAction(message.data)
          break
        case "awaiting-syncing-permission-loaded": {
          this.handleDerivedStateChange(this._actionsModel.satisfiedStates),
            this.sendSyncEnabledStatus(),
            this._webview?.postMessage({
              type: "awaiting-syncing-permission-initialize",
              data: {
                workspaceName: hw.workspace.name,
                enableDebugFeatures: this._config.config.enableDebugFeatures,
                maxTrackableFileCount:
                  this._featureFlagManager.currentFlags.maxTrackableFileCount,
                userTier: this._userTier,
              },
            })
          break
        }
      }
    }
    performAction(action) {
      switch (action) {
        case "grant-sync-permission": {
          this._logger.info("User granted syncing permission"),
            this._syncingEnabledTracker.enableSyncing()
          break
        }
        case "open-folder": {
          hw.commands.executeCommand("vscode.openFolder")
          break
        }
        case "close-folder": {
          hw.commands.executeCommand("workbench.action.closeFolder")
          break
        }
      }
    }
    async *onUserSendMessage(message) {
      let requestId = this._apiServer.createRequestId(),
        responseChunks = oEe
      for (let chunk of responseChunks)
        yield {
          type: "chat-model-reply",
          data: { text: chunk, requestId: requestId, workspaceFileChunks: [], streaming: true },
        },
          await new Promise((o) => setTimeout(o, 8))
      yield {
        type: "chat-model-reply",
        data: { text: "", requestId: requestId, workspaceFileChunks: [], streaming: false },
      }
    }
  }
var If = q(require("vscode"))
var zQ = class extends DisposableContainer {
  constructor(r) {
    super()
    this._onboardingSessionEventReporter = r
  }
  _webview
  appType() {
    return "folder-selection"
  }
  title() {
    return "Select Folder"
  }
  register(r) {
    ;(this._webview = r),
      this.addDisposables(
        this._webview.onDidReceiveMessage(this.onDidReceiveMessage),
      )
  }
  onDidReceiveMessage = (r) => {
    switch (r.type) {
      case "main-panel-perform-action":
        this.performAction(r.data)
        break
      case "main-panel-create-project":
        this.createProject(r.data.name)
        break
    }
  }
  performAction(r) {
    switch (r) {
      case "open-folder": {
        this._onboardingSessionEventReporter.reportEvent("opened-folder"),
          If.commands.executeCommand("vscode.openFolder")
        break
      }
      case "close-folder": {
        If.commands.executeCommand("workbench.action.closeFolder")
        break
      }
      case "clone-repository": {
        this._onboardingSessionEventReporter.reportEvent("cloned-repo"),
          If.commands.executeCommand("git.clone")
        break
      }
    }
  }
  async createProject(r) {
    let n = "augment-projects",
      i = ECe()
    if (!i) return
    let s = If.Uri.file(i),
      o = If.Uri.joinPath(s, n),
      a = If.Uri.joinPath(o, r)
    ;(await Vl(a.fsPath)) || (await Hl(a.fsPath)),
      this._onboardingSessionEventReporter.reportEvent("created-new-project"),
      await this._onboardingSessionEventReporter.uploadNow(),
      If.commands.executeCommand("vscode.openFolder", a)
  }
}
var JQ = class extends DisposableContainer {
  constructor(r, n, i, s) {
    super()
    this._apiServer = r
    this._config = n
    this._oauthFlow = i
    this._actionsModel = s
  }
  _logger = z("SignInApp")
  _webview
  _signInFlow
  appType() {
    return "sign-in"
  }
  title() {
    return ""
  }
  register(r) {
    ;(this._webview = r),
      this.addDisposable(
        r.onDidReceiveMessage((i) => this.onMessageFromWebview(i)),
      ),
      this.addDisposable(
        this._actionsModel.onDerivedStatesSatisfied(
          this.handleDerivedStateChange.bind(this),
        ),
      )
    let n = createAsyncMessageHandler(r)
    this.addDisposable(n),
      n.registerStreamHandler("chat-user-message", (i) =>
        this.onUserSendMessage(i),
      ),
      n.registerHandler(
        "chat-loaded",
        (i) => (
          this._actionsModel.isDerivedStateSatisfied("UserShouldSignIn") &&
            this.sendSignInActions(),
          Promise.resolve({
            type: "chat-initialize",
            data: {
              enableDebugFeatures: this._config.config.enableDebugFeatures,
              fullFeatured: false,
            },
          })
        ),
      )
  }
  onMessageFromWebview(r) {
    switch (r.type) {
      case "main-panel-perform-action":
        this.performAction(r.data)
        break
      case "augment-link": {
        switch (r.data) {
          case q4:
            this.performAction("sign-in")
            break
          default:
            this._logger.warn(`Unknown augment link: ${r.data}`)
            break
        }
        break
      }
      case "sign-in-loaded": {
        let n = { type: "sign-in-loaded-response", data: { client: "vscode" } }
        this._webview?.postMessage(n)
        break
      }
    }
  }
  performAction(r) {
    switch (r) {
      case "cancel-sign-in":
        this._oauthFlow.doProgrammaticCancellation(), this.sendSignInActions()
        break
      case "sign-in": {
        this.sendInProgressActions()
        let n = this._oauthFlow.startFlow(false)
        ;(this._signInFlow = n),
          n.catch((i) => {
            this._signInFlow === n && this.sendSignInActions()
          })
        break
      }
    }
  }
  async sendSignInActions() {
    await this.sendActionsToWebview(["UserShouldSignIn"])
  }
  async sendInProgressActions() {
    await this.sendActionsToWebview(["SignInInProgress"])
  }
  handleDerivedStateChange(r) {
    for (let n of r) n.name === "UserShouldSignIn" && this.sendSignInActions()
  }
  async sendActionsToWebview(r) {
    await this._webview?.postMessage({ type: "main-panel-actions", data: r })
  }
  async *onUserSendMessage(r) {
    let n = this._apiServer.createRequestId(),
      i = sEe
    for (let s of i)
      yield {
        type: "chat-model-reply",
        data: { text: s, requestId: n, workspaceFileChunks: [], streaming: true },
      },
        await new Promise((o) => setTimeout(o, 8))
    yield {
      type: "chat-model-reply",
      data: { text: "", requestId: n, workspaceFileChunks: [], streaming: false },
    }
  }
}
var jQ = class extends DisposableContainer {
  constructor(r, n, i) {
    super()
    this._workspaceManager = r
    this._featureFlagManager = n
    this._workTimer = i
  }
  _workspaceUiModel = null
  appType() {
    return "workspace-context"
  }
  title() {
    return "Workspace Context"
  }
  register(r) {
    this._workspaceUiModel?.dispose(),
      this._featureFlagManager.currentFlags.enableWorkspaceManagerUi &&
        ((this._workspaceUiModel = new Gv(
          this._workspaceManager,
          r,
          this._featureFlagManager,
          this._workTimer,
        )),
        this.addDisposable(this._workspaceUiModel))
  }
}
var ClientMetricsReporter = class e extends MetricsReporter {
  constructor(r) {
    super(
      "ClientMetricsReporter",
      e.defaultMaxRecords,
      e.defaultUploadMsec,
      e.defaultBatchSize,
    )
    this._apiServer = r
  }
  static defaultMaxRecords = 1e4
  static defaultBatchSize = 500
  static defaultUploadMsec = 1e4
  reportWebviewClientMetric = (r) => {
    this.report({
      client_metric: `webview__${r.webviewName}__${r.client_metric}`,
      value: r.value,
    })
  }
  performUpload(r) {
    return this._apiServer.clientMetrics(r)
  }
}
var XQ = class {
  constructor(t) {
    this._apiServer = t
  }
  uploadEnabled = false
  _logger = z("CodeEditReporter")
  enableUpload() {
    this.uploadEnabled = true
  }
  disableUpload() {
    this.uploadEnabled = false
  }
  dispose() {
    this.disableUpload()
  }
  async reportResolution(t, r, n, i, s) {
    let [o, a] = Vn(r),
      [l, c] = Vn(n),
      u = {
        request_id: t,
        emit_time_sec: o,
        emit_time_nsec: a,
        resolve_time_sec: l,
        resolve_time_nsec: c,
        is_accepted: i,
        annotated_text: s,
      }
    await retryOperation(async () => {
      if (this.uploadEnabled)
        try {
          return await this._apiServer.logCodeEditResolution(u)
        } catch (f) {
          throw (this._logger.error(`Error reporting edit resolution: ${f}`), f)
        }
    }, this._logger)
  }
}
var eN = class e extends MetricsReporter {
  constructor(r, n, i, s, o) {
    super(
      "CompletionAcceptanceReporter",
      i ?? e.defaultMaxRecords,
      s ?? e.defaultUploadMsec,
      o ?? e.defaultBatchSize,
    )
    this._apiServer = r
    this._onboardingSessionEventReporter = n
  }
  static defaultMaxRecords = 1e4
  static defaultBatchSize = 1e3
  static defaultUploadMsec = 1e4
  reportResolution(r, n, i, s) {
    let [o, a] = Vn(n),
      [l, c] = Vn(i)
    this.report({
      request_id: r,
      emit_time_sec: o,
      emit_time_nsec: a,
      resolve_time_sec: l,
      resolve_time_nsec: c,
      accepted_idx: s ?? -1,
    }),
      s !== undefined &&
        this._onboardingSessionEventReporter.reportEvent("accepted-completion")
  }
  performUpload(r) {
    return this._apiServer.resolveCompletions(r)
  }
}
var tN = class e extends MetricsReporter {
  constructor(r, n, i, s) {
    super(
      "TimelineEventReporter",
      n ?? e.defaultMaxRecords,
      i ?? e.defaultUploadMsec,
      s ?? e.defaultBatchSize,
    )
    this._apiServer = r
  }
  static defaultMaxRecords = 1e4
  static defaultBatchSize = 1e3
  static defaultUploadMsec = 1e4
  reportCompletionTimeline(r, n) {
    if (!n.emitTime || !n.rpcStart || !n.rpcEnd) return
    let [i, s] = Vn(n.requestStart),
      [o, a] = Vn(n.emitTime),
      [l, c] = Vn(n.rpcStart),
      [u, f] = Vn(n.rpcEnd)
    this.report({
      request_id: r,
      initial_request_time_sec: i,
      initial_request_time_nsec: s,
      api_start_time_sec: l,
      api_start_time_nsec: c,
      api_end_time_sec: u,
      api_end_time_nsec: f,
      emit_time_sec: o,
      emit_time_nsec: a,
    })
  }
  performUpload(r) {
    return this._apiServer.reportClientCompletionTimelines(r)
  }
}
var vg = q(require("vscode"))
function flattenObject(obj, prefix = "", result = {}) {
  for (let key in obj)
    if (Object.hasOwn(obj, key)) {
      let path = prefix ? `${prefix}.${key}` : key
      typeof obj[key] == "object" && obj[key] !== null
        ? flattenObject(obj[key], path, result)
        : (result[path] = String(obj[key]))
    }
  return result
}
var ExtensionSessionEventReporter = class ExtensionSessionEventReporter extends MetricsReporter {
  constructor(apiServer, maxRecords, uploadInterval, batchSize) {
    super(
      "ExtensionSessionEventReporter",
      maxRecords ?? ExtensionSessionEventReporter.defaultMaxRecords,
      uploadInterval ?? ExtensionSessionEventReporter.defaultUploadMsec,
      batchSize ?? ExtensionSessionEventReporter.defaultBatchSize,
    )
    this._apiServer = apiServer
  }
  static defaultMaxRecords = 1e4
  static defaultBatchSize = 1e3
  static defaultUploadMsec = 1e4
  reportEvent(eventName, additionalData) {
    this.report({
      time_iso: new Date().toISOString(),
      event_name: eventName,
      additional_data: additionalData,
    })
  }
  performUpload(events) {
    return this._apiServer.logExtensionSessionEvent(events)
  }
  reportSourceFolders(folderData) {
    if (!folderData.workspaceStorageUri) return
    let projectId = createSHA256Hash(new TextEncoder().encode(folderData.workspaceStorageUri))
    delete folderData.workspaceStorageUri
    let formattedData = flattenObject({ projectId: projectId, ...folderData })
    this.report({
      time_iso: new Date().toISOString(),
      event_name: "source-folder-snapshot",
      additional_data: Object.entries(formattedData).map(([key, value]) => ({
        key: key,
        value: value,
      })),
    })
  }
  reportConfiguration(eventName, configData, featureFlags) {
    let formattedData = flattenObject({
      otherConfig: {
        theme: vg.workspace.getConfiguration().get("workbench.colorTheme"),
        fontSize: vg.workspace.getConfiguration().get("editor.fontSize"),
        isDark: [
          vg.ColorThemeKind.Dark,
          vg.ColorThemeKind.HighContrast,
        ].includes(vg.window.activeColorTheme.kind),
      },
      config: configData,
      featureFlags: featureFlags,
    })
    for (let key in formattedData)
      key.toLowerCase().includes("token") && formattedData[key] && (formattedData[key] = "<redacted>")
    this.report({
      time_iso: new Date().toISOString(),
      event_name: "configuration-snapshot",
      additional_data: Object.entries(formattedData).map(([key, value]) => ({
        key: key,
        value: value,
      })),
    })
  }
}
var iN = class e extends MetricsReporter {
  constructor(r, n, i, s) {
    super(
      "NextEditResolutionReporter",
      n ?? e.defaultMaxRecords,
      i ?? e.defaultUploadMsec,
      s ?? e.defaultBatchSize,
    )
    this._apiServer = r
  }
  static defaultMaxRecords = 1e4
  static defaultBatchSize = 1e3
  static defaultUploadMsec = 1e4
  reportResolution(r, n, i, s) {
    let [o, a] = Vn(n),
      [l, c] = Vn(i)
    this.report({
      request_id: r,
      emit_time_sec: o,
      emit_time_nsec: a,
      resolve_time_sec: l,
      resolve_time_nsec: c,
      is_accepted: s,
    })
  }
  performUpload(r) {
    return this._apiServer.resolveNextEdits(r)
  }
}
var sN = class e extends MetricsReporter {
  constructor(r, n, i, s) {
    super(
      "NextEditSessionEventReporter",
      n ?? e.defaultMaxRecords,
      i ?? e.defaultUploadMsec,
      s ?? e.defaultBatchSize,
    )
    this._apiServer = r
  }
  static defaultMaxRecords = 1e4
  static defaultBatchSize = 1e3
  static defaultUploadMsec = 1e4
  reportEvent(r, n, i, s, o) {
    let [a, l] = Vn(i)
    this.report({
      related_request_id: r,
      related_suggestion_id: n,
      event_time_sec: a,
      event_time_nsec: l,
      event_name: s,
      event_source: o,
    })
  }
  reportEventFromSuggestion(r, n, i) {
    this.reportEvent(r?.requestId, r?.result.suggestionId, Date.now(), n, i)
  }
  reportEventWithoutIds(r, n) {
    this.reportEvent(undefined, undefined, Date.now(), r, n)
  }
  performUpload(r) {
    return this._apiServer.logNextEditSessionEvent(r)
  }
}
var oN = class e extends MetricsReporter {
  constructor(r, n, i, s) {
    super(
      "OnboardingSessionEventReporter",
      n ?? e.defaultMaxRecords,
      i ?? e.defaultUploadMsec,
      s ?? e.defaultBatchSize,
    )
    this._apiServer = r
  }
  static defaultMaxRecords = 1e4
  static defaultBatchSize = 1e3
  static defaultUploadMsec = 1e4
  reportEvent(r) {
    let [n, i] = Vn(Date.now())
    this.report({ event_time_sec: n, event_time_nsec: i, event_name: r })
  }
  performUpload(r) {
    return this._apiServer.logOnboardingSessionEvent(r)
  }
}
var aN = class extends DisposableContainer {
  constructor(r, n, i) {
    super()
    this._reporter = r
    this._workTimer = n
    this._options = i
    ;(this._options.periodMs = Math.max(this._options.periodMs, 10)),
      (this._options.infoThresholdMs = Math.max(
        this._options.infoThresholdMs,
        10,
      )),
      (this._options.debugThresholdMs = Math.min(
        Math.max(this._options.debugThresholdMs, 10),
        this._options.infoThresholdMs,
      )),
      this._schedule(),
      this.addDisposable({ dispose: () => clearTimeout(this._nextCheck) })
  }
  _logger = z("StallDetector")
  _targetWakeup = 0
  _nextCheck
  _schedule() {
    ;(this._targetWakeup = Date.now() + this._options.periodMs),
      (this._nextCheck = setTimeout(
        () => this._checkStall(),
        this._options.periodMs,
      ))
  }
  _checkStall() {
    let n = Date.now() - this._targetWakeup
    if (n > this._options.debugThresholdMs) {
      let s = `Event loop delay: Timer(${this._options.periodMs} msec) ran ${n} msec late.`,
        o = n > this._options.infoThresholdMs ? "info" : "debug"
      this._logger.log(o, s),
        this._reporter.report({ client_metric: "event_loop_delay", value: n })
    }
    let i = this._workTimer.popSlowEvents()
    i.length > 0 && this._logger.info(`Recent work: ${JSON.stringify(i)}`),
      this._schedule()
  }
}
var lN = class e {
  thresholdMs
  slowEvents
  static maxSlowEvents = 1e3
  constructor(t = 1e3) {
    ;(this.thresholdMs = t), (this.slowEvents = [])
  }
  async runTimed(t, r) {
    let n = process.hrtime.bigint(),
      i
    try {
      return (i = await r()), i
    } finally {
      this.recordIfSlow(t, n)
    }
  }
  recordIfSlow(t, r) {
    let n = process.hrtime.bigint() - r,
      i = Number(n) / 1e6
    i >= this.thresholdMs &&
      (this.slowEvents.push({ name: t, durationMs: i, timestamp: new Date() }),
      this.slowEvents.length > e.maxSlowEvents &&
        this.slowEvents.splice(0, e.maxSlowEvents / 2))
  }
  popSlowEvents() {
    let t = this.slowEvents
    return (this.slowEvents = []), t
  }
  clear() {
    this.slowEvents = []
  }
}
var nl = q(require("vscode"))
var C6 = q(require("vscode"))
var kCt = z("RangesVSCode")
function createRange(lineRange, document) {
  return document && document.lineCount < lineRange.stop
    ? (kCt.warn(
        `LineRange[${lineRange.start}, ${lineRange.stop}) is out of bounds for document ${document.uri.path}.`,
      ),
      new C6.Range(lineRange.start, 0, document.lineCount, 0))
    : new C6.Range(lineRange.start, 0, lineRange.stop, 0)
}
function rangeToLineRange(range) {
  return new LineRange(range.start.line, range.end.line + (range.end.character > 0 ? 1 : 0))
}
function formatRangeToString(range) {
  return `[${formatPositionToString(range.start)},${formatPositionToString(range.end)})`
}
function formatPositionToString(position) {
  return `${position.line}:${position.character}`
}
function b6(e) {
  return [...e.visibleRanges].sort((t, r) => t.start.line - r.start.line)
}
function getPathFromUri(uri) {
  return Zy(uri.fsPath)
}
function getUriPath(uri) {
  return uri.fsPath
}
function getPathIfSupported(uri) {
  if (uri.scheme === "file" || uri.scheme === "untitled" || isNotebookCell(uri)) return getPathFromUri(uri)
}
function getPathIfFile(uri) {
  if (uri.scheme === "file") return getPathFromUri(uri)
}
var fN = q(require("vscode"))
var TutorialAction = class {
    constructor(title, action) {
      this.title = title
      this.action = action
      ;(this.title = title), (this.action = action)
    }
  },
  NextEditTutorialManager = class extends DisposableContainer {
    constructor(configListener, suggestionManager, keybindingWatcher, globalState, nextEditSessionEventReporter, nextEditConfigManager, completionVisibilityWatcher) {
      super()
      this._configListener = configListener
      this._suggestionManager = suggestionManager
      this._keybindingWatcher = keybindingWatcher
      this._globalState = globalState
      this._nextEditSessionEventReporter = nextEditSessionEventReporter
      this._nextEditConfigManager = nextEditConfigManager
      this._completionVisibilityWatcher = completionVisibilityWatcher
      this._addInitialTutorial(), this._addSecondTutorial()
    }
    _addInitialTutorial() {
      let enableAutoApply = this._nextEditConfigManager.config.enableAutoApply,
        previewKeybinding = getKeybindingLabel(this._keybindingWatcher, NextEditNavigateCommand.commandID, true),
        dismissKeybinding = getKeybindingLabel(this._keybindingWatcher, DismissNextEditCommand.commandID, true)
      this._addTutorial(
        "nextEditSuggestionSeen",
        (suggestions) => suggestions.newSuggestions,
        isFreshNonNoopSuggestion,
        "You have a Next Edit suggestion available. Next Edit helps you complete your train of thought by suggesting changes that continue your recent work.",
        [
          new TutorialAction(
            enableAutoApply ? `Preview & Apply (${previewKeybinding})` : `Preview (${previewKeybinding})`,
            createCommandExecutor(NextEditNavigateCommand.commandID),
          ),
          new TutorialAction(`Dismiss All (${dismissKeybinding})`, createCommandExecutor(DismissNextEditCommand.commandID)),
        ],
        "tutorial-initial-shown",
      )
    }
    _addSecondTutorial() {
      let undoKeybinding = getKeybindingLabel(this._keybindingWatcher, UndoAcceptSuggestionCommand.commandID, true),
        redoKeybinding = getKeybindingLabel(this._keybindingWatcher, "redo", true),
        viewPanelKeybinding = getKeybindingLabel(this._keybindingWatcher, OpenNextEditPanelCommand.commandID, true),
        actions = [new TutorialAction("Learn More", createCommandExecutor(LearnMoreNextEditCommand.commandID))].concat(
          this._nextEditConfigManager.config.enablePanel
            ? [new TutorialAction(`View All in Panel (${viewPanelKeybinding})`, createCommandExecutor(OpenNextEditPanelCommand.commandID))]
            : [],
        )
      this._addTutorial(
        "nextEditSuggestionAccepted",
        (suggestions) => suggestions.accepted,
        undefined,
        `You just applied a Next Edit suggestion! Use Undo (${undoKeybinding}) and Redo (${redoKeybinding}) to go back and forth between the original and suggested code.`,
        actions,
        "tutorial-after-accept-shown",
      )
    }
    _addTutorial(storageKey, suggestionsSelector, suggestionFilter, message, actions, eventName) {
      this._globalState.get(storageKey) !== true &&
        this.addDisposable(
          this._suggestionManager.onSuggestionsChanged(async (changedSuggestions) => {
            if (
              !this._shouldShowTutorial(storageKey, suggestionsSelector(changedSuggestions), suggestionFilter) ||
              this._completionVisibilityWatcher.maybeInlineCompletionVisible
            )
              return
            this._globalState.update(storageKey, true),
              this._nextEditSessionEventReporter.reportEventWithoutIds(
                eventName,
                "unknown",
              )
            let selectedAction = await fN.window.showInformationMessage(message, ...actions)
            selectedAction?.action(),
              this._nextEditSessionEventReporter.reportEventWithoutIds(
                selectedAction ? "tutorial-nonempty-response" : "tutorial-empty-response",
                "unknown",
              )
          }),
        )
    }
    _shouldShowTutorial(storageKey, suggestions, suggestionFilter = undefined) {
      return (
        suggestionFilter && (suggestions = suggestions.filter(suggestionFilter)),
        !(suggestions.length === 0 || this._globalState.get(storageKey) === true)
      )
    }
  }
function createCommandExecutor(commandId) {
  return () => void fN.commands.executeCommand(commandId, "tutorial")
}
var BackgroundNextEdit = class BackgroundNextEdit extends DisposableContainer {
  constructor(workspaceManager, nextEditSessionEventReporter, context, configListener, suggestionManager, requestManager, webviewManager, nextEditConfigManager, completionVisibilityWatcher) {
    super()
    this.workspaceManager = workspaceManager
    this._nextEditSessionEventReporter = nextEditSessionEventReporter
    this._configListener = configListener
    this._suggestionManager = suggestionManager
    this._requestManager = requestManager
    this._nextEditConfigManager = nextEditConfigManager
    this._completionVisibilityWatcher = completionVisibilityWatcher
    this.addDisposable(
      new nl.Disposable(() => {
        this._requestManager?.clearCompletedRequests(),
          this._suggestionManager?.clear(false, "BACKGROUND"),
          this._noopReportTimer &&
            (clearTimeout(this._noopReportTimer),
            (this._noopReportTimer = null)),
          this._cancelDelayedFileRequest()
      }),
    ),
      this._scheduleNoopReport(),
      this.addDisposable(
        nl.workspace.onDidChangeTextDocument(this._handleTextDocumentChanged),
      ),
      this.addDisposable(
        nl.window.onDidChangeTextEditorSelection(
          this._handleTextEditorSelectionChanged,
        ),
      ),
      this.addDisposable(
        new nl.Disposable(
          this._requestManager.lastFinishedRequest.listen((request) => {
            if (!request || request.apiResult !== RequestStatus.ok || request.mode !== "BACKGROUND") return
            let activeEditor = nl.window.activeTextEditor,
              currentPath = activeEditor && this.workspaceManager.safeResolvePathName(activeEditor.document.uri)
            if (request.suggestions.length === 0) {
              this._logRequestCaching(
                `Request (scope=${request.scope}) returned no suggestions.`,
              )
              return
            }
            if (request.scope === "CURSOR") {
              let freshSuggestions = request.suggestions.filter(isFreshNonNoopSuggestion)
              freshSuggestions.length === 0
                ? (this._logRequestCaching(
                    "CURSOR request returned no results, falling back to FILE request immediately",
                  ),
                  this._requestManager.enqueueRequest(currentPath, "BACKGROUND", "FILE"))
                : (this._logRequestCaching(
                    `CURSOR request returned ${freshSuggestions.length} suggestions, scheduling delayed FILE request in ${BackgroundNextEdit._fileRequestDelayMs}ms`,
                  ),
                  (this._delayedFileRequestTimer = setTimeout(() => {
                    this._logRequestCaching("Enqueuing delayed FILE request"),
                      this._requestManager.enqueueRequest(
                        currentPath,
                        "BACKGROUND",
                        "FILE",
                      ),
                      (this._delayedFileRequestTimer = null)
                  }, BackgroundNextEdit._fileRequestDelayMs)))
            } else
              request.scope === "FILE" &&
                request.suggestions.filter(isFreshNonNoopSuggestion).length === 0 &&
                this._configListener.config.nextEdit
                  .enableGlobalBackgroundSuggestions &&
                (this._logRequestCaching(
                  "FILE request returned no results, falling back to WORKSPACE request",
                ),
                this._requestManager.enqueueRequest(
                  currentPath,
                  "BACKGROUND",
                  "WORKSPACE",
                ))
          }),
        ),
      ),
      this.addDisposable(
        this._suggestionManager.onSuggestionsChanged((changedSuggestions) => {
          // fetch('http://localhost:3000', {
          //   method: 'POST',
          //   body: JSON.stringify({
          //     callMethod: 'BackgroundNextEdit:_suggestionManager.onSuggestionsChanged',
          //     prev: 'triggered by add new suggestions'
          //   })
          // });
          for (let suggestion of changedSuggestions.accepted.filter(
            (item) => item.result.truncationChar !== undefined,
          ))
            this._requestManager.enqueueRequest(
              suggestion.qualifiedPathName,
              "BACKGROUND",
              "CURSOR",
              suggestion.lineRange,
            )
          let requestGroups = changedSuggestions.accepted
            .map((suggestion) => suggestion.requestId)
            .map((requestId) =>
              changedSuggestions.newSuggestions.filter((item) => isFreshNonNoopSuggestion(item) && item.requestId === requestId),
            )
          for (let group of requestGroups)
            if (!group.some((item) => item.result.truncationChar === undefined))
              for (let suggestion of group)
                this._requestManager.enqueueRequest(
                  suggestion.qualifiedPathName,
                  "BACKGROUND",
                  "CURSOR",
                  suggestion.lineRange,
                )
        }),
      ),
      this.addDisposable(
        new NextEditTutorialManager(
          this._configListener,
          this._suggestionManager,
          context,
          webviewManager,
          nextEditSessionEventReporter,
          this._nextEditConfigManager,
          this._completionVisibilityWatcher,
        ),
      )
    let activeEditor = nl.window.activeTextEditor
    if (!activeEditor) return
    let currentPath = this.workspaceManager.safeResolvePathName(activeEditor.document.uri)
    currentPath && this._requestManager.enqueueRequest(currentPath, "BACKGROUND", "CURSOR")
  }
  _logger = z("BackgroundNextEdits")
  _noopSources = new Set()
  _noopReportTimer = null
  _noopReportDelayMs = 6e4 * 5
  _debugRequestCaching = true
  _delayedFileRequestTimer = null
  static _fileRequestDelayMs = 4e3
  _logRequestCaching(message) {
    if (this._debugRequestCaching) {
      let logMessage = typeof message == "string" ? message : message()
      this._logger.debug(logMessage)
    }
  }
  _cancelDelayedFileRequest() {
    this._delayedFileRequestTimer &&
      (this._logRequestCaching("Cancelling delayed FILE request"),
      clearTimeout(this._delayedFileRequestTimer),
      (this._delayedFileRequestTimer = null))
  }
  get _isDebugging() {
    return (
      nl.debug.activeDebugSession !== undefined &&
      !this._configListener.config.nextEdit.allowDuringDebugging
    )
  }
  _scheduleNoopReport() {
    this._noopReportTimer &&
      (clearTimeout(this._noopReportTimer), (this._noopReportTimer = null)),
      (this._noopReportTimer = setTimeout(() => {
        this._reportNoopSources(), this._scheduleNoopReport()
      }, this._noopReportDelayMs))
  }
  _reportNoopSources() {
    if (this._noopSources.size !== 0) {
      for (let source of this._noopSources.values())
        this._nextEditSessionEventReporter.reportEventWithoutIds(
          "background-noop",
          source,
        )
      this._noopSources.clear()
    }
  }
  _handleTextDocumentChanged = (event) => {
    if (event.contentChanges.length === 0) {
      this._noopSources.add("no-content-changes")
      return
    }
    if (this._isDebugging) {
      this._noopSources.add("debug-session")
      return
    }
    if (isNotebook(event.document)) {
      this._noopSources.add("notebook-document")
      return
    }
    if (!getPathIfFile(event.document.uri)) {
      this._noopSources.add("unsupported-uri")
      return
    }
    let currentPath = this.workspaceManager.safeResolvePathName(event.document.uri)
    if (!currentPath) {
      this._noopSources.add("missing-path-name")
      return
    }
    let activeEditor = nl.window.activeTextEditor
    if (!activeEditor || event.document !== activeEditor.document) {
      this._noopSources.add("not-active-editor")
      return
    }
    if (
      (this._logger.debug(`Received TextDocumentChangeEvent for ${currentPath.relPath}`),
      this._cancelDelayedFileRequest(),
      this._logRequestCaching(
        "Canceled delayed FILE request due to document change.",
      ),
      this._suggestionManager
        .getActiveSuggestions()
        .filter(
          (suggestion) =>
            suggestion.qualifiedPathName.equals(currentPath) &&
            isFreshNonNoopSuggestion(suggestion) &&
            suggestion.result.truncationChar === undefined,
        ).length > 0)
    ) {
      this._noopSources.add("fresh-suggestions"),
        this._logRequestCaching("Continuing with remaining fresh suggestions.")
      return
    }
    this._requestManager.enqueueRequest(currentPath, "BACKGROUND", "CURSOR")
  }
  _handleTextEditorSelectionChanged = (event) => {
    let activeEditor = nl.window.activeTextEditor
    if (
      !activeEditor ||
      event.textEditor.document !== activeEditor.document ||
      isDiffEditor() ||
      this._isDebugging ||
      isNotebookCell(activeEditor.document.uri)
    )
      return
    let currentPath = this.workspaceManager.safeResolvePathName(event.textEditor.document.uri)
    if (!currentPath) return
    let freshSuggestions = this._suggestionManager
      .getActiveSuggestions()
      .filter(
        (suggestion) =>
          suggestion.qualifiedPathName.equals(currentPath) &&
          isFreshSuggestion(suggestion) &&
          suggestion.result.truncationChar === undefined,
      )
      .sort((a, b) => {
        let rangeA =
            a.state === "accepted" ? a.afterLineRange(activeEditor.document) : a.lineRange,
          rangeB =
            b.state === "accepted" ? b.afterLineRange(activeEditor.document) : b.lineRange
        return rangeA.start - rangeB.start
      })
    this._logRequestCaching(
      () =>
        `Found ${freshSuggestions.length} fresh suggestions in current file: ${freshSuggestions
          .map((suggestion) => {
            let range =
                suggestion.state === "accepted"
                  ? suggestion.afterLineRange(activeEditor.document)
                  : suggestion.lineRange,
              type = suggestion.changeType === "noop" ? "no-op" : "change"
            return `[${range.toString()}, ${type}]`
          })
          .join(", ")}`,
    )
    let selectionRange = rangeToLineRange(activeEditor.selection)
    this._logRequestCaching(`Cursor moved to line range: ${selectionRange.toString()}`)
    let intersectingSuggestions = freshSuggestions.filter((suggestion) => {
      let range =
        suggestion.state === "accepted" ? suggestion.afterLineRange(activeEditor.document) : suggestion.lineRange
      return range.intersects(selectionRange) || range.touches(selectionRange)
    })
    if (!(intersectingSuggestions.length > 0))
      this._logRequestCaching(
        "Cursor not in any fresh suggestion region, sending new CURSOR request",
      ),
        this._cancelDelayedFileRequest(),
        this._logRequestCaching(
          "Canceled delayed FILE request due to cursor movement.",
        ),
        this._requestManager.enqueueRequest(currentPath, "BACKGROUND", "CURSOR")
    else {
      for (let suggestion of intersectingSuggestions) {
        let range =
            suggestion.state === "accepted" ? suggestion.afterLineRange(activeEditor.document) : suggestion.lineRange,
          type = suggestion.changeType === "noop" ? "no-op" : "change"
        this._logRequestCaching(
          `Cursor is in fresh suggestion at lines ${range.toString()}, suggestion ID: ${suggestion.requestId}, state: ${Ul[suggestion.state]}, type: ${type}`,
        )
      }
      this._logRequestCaching(
        "Not sending new request as cursor is in fresh suggestion regions",
      )
    }
  }
}
var Observable = class Observable {
  constructor(initialValue, equalityFunction = (newValue, oldValue) => newValue === oldValue, initialListeners = []) {
    this._value = initialValue
    this._equalityFn = equalityFunction
    this._listeners = initialListeners
  }
  static watch(computeFunction, ...observables) {
    let computeValue = () => computeFunction(...observables.map((observable) => observable.value)),
      derivedObservable = new Observable(computeValue()),
      subscriptions = observables.map((observable) =>
        observable.listen(() => {
          derivedObservable.value = computeValue()
        }),
      ),
      originalDispose = derivedObservable.dispose
    return (
      (derivedObservable.dispose = () => {
        originalDispose(), subscriptions.forEach((unsubscribe) => unsubscribe())
      }),
      derivedObservable
    )
  }
  dispose = () => {
    this._listeners = []
  }
  listen(callback, invokeImmediately = false) {
    return (
      invokeImmediately && callback(this._value, this._value),
      this._listeners.push(callback),
      () => {
        this._listeners = this._listeners.filter((listener) => listener !== callback)
      }
    )
  }
  get value() {
    return this._value
  }
  set value(newValue) {
    if (this._equalityFn(newValue, this._value)) return
    let oldValue = this._value
    this._value = newValue
    for (let listener of this._listeners) listener(newValue, oldValue)
  }
  waitUntil(predicate, timeoutMs) {
    return new Promise((resolve, reject) => {
      let unsubscribe,
        timeoutId =
          timeoutMs !== undefined &&
          setTimeout(() => {
            unsubscribe?.(), reject(new Error("Timeout exceeded."))
          }, timeoutMs)
      unsubscribe = this.listen((value) => {
        predicate(value) && (timeoutId && clearTimeout(timeoutId), unsubscribe?.(), resolve(value))
      }, true)
    })
  }
}
var gN = class extends DisposableContainer {
  _maybeInlineCompletionVisible = new Observable(false)
  constructor() {
    super(),
      this.addDisposable(
        onCompletionRejected((t) => {
          this._maybeInlineCompletionVisible.value = t
        }),
      )
  }
  get maybeInlineCompletionVisible() {
    return this._maybeInlineCompletionVisible.value
  }
  listen(t) {
    return this._maybeInlineCompletionVisible.listen(t)
  }
}
var ZSe = q(_s()),
  Se = q(require("vscode"))
var ad = q(require("vscode"))
var HintedSuggestionState = class {
    constructor(suggestion, isNext) {
      this.suggestion = suggestion
      this.isNext = isNext
    }
    toString() {
      return "hinted-suggestion"
    }
  },
  NoSuggestionsState = class {
    constructor() {}
    get suggestion() {}
    toString() {
      return "no-suggestions"
    }
  },
  HintingState = class {
    constructor(suggestion, isNext) {
      this.suggestion = suggestion
      this.isNext = isNext
    }
    toString() {
      return "hinting"
    }
    get hintedSuggestion() {
      return new HintedSuggestionState(this.suggestion, this.isNext)
    }
  },
  BeforePreviewState = class {
    constructor(suggestion) {
      this.suggestion = suggestion
    }
    toString() {
      return "before-preview"
    }
  },
  AfterPreviewState = class {
    constructor(suggestion) {
      this.suggestion = suggestion
    }
    toString() {
      return "after-preview"
    }
  },
  AnimatingState = class {
    constructor(suggestion, selection, timeout) {
      this.suggestion = suggestion
      this.selection = selection
      this.timeout = timeout
    }
    toString() {
      return "animating"
    }
  }
function DSe(e, t) {
  return e instanceof NoSuggestionsState && t instanceof NoSuggestionsState
    ? true
    : e instanceof HintingState && t instanceof HintingState
      ? e.suggestion.equals(t.suggestion) && e.isNext === t.isNext
      : (e instanceof BeforePreviewState && t instanceof BeforePreviewState) ||
          (e instanceof AfterPreviewState && t instanceof AfterPreviewState)
        ? e.suggestion.equals(t.suggestion)
        : e instanceof AnimatingState && t instanceof AnimatingState
          ? e.suggestion.equals(t.suggestion) &&
            e.selection.isEqual(t.selection) &&
            e.timeout === t.timeout
          : false
}
var CodeLensProvider = class {
  constructor(t, r) {
    this._state = t
    this._keybindingWatcher = r
  }
  _onDidChangeCodeLenses = new ad.EventEmitter()
  onDidChangeCodeLenses = this._onDidChangeCodeLenses.event
  get _activeSuggestion() {
    return this._state.value instanceof BeforePreviewState ||
      this._state.value instanceof AfterPreviewState ||
      this._state.value instanceof AnimatingState
      ? this._state.value.suggestion
      : undefined
  }
  refresh() {
    this._onDidChangeCodeLenses.fire()
  }
  _buildCodeLens(t, r, n) {
    return new ad.CodeLens(n, {
      title: t,
      command: r,
      tooltip: this._getKeybindingForCommand(r, true) ?? undefined,
      arguments: ["code-lens"],
    })
  }
  _getKeybindingForCommand(t, r = false) {
    return getKeybindingLabel(this._keybindingWatcher, t, r)?.replace("Escape", "esc")
  }
  provideCodeLenses(t, r) {
    let n = this._activeSuggestion
    if (!n) return []
    if (!n.qualifiedPathName.equals(t.uri)) return []
    let i = [],
      s = new ad.Range(
        new ad.Position(n.lineRange.start, 0),
        new ad.Position(n.lineRange.start, 0),
      )
    return (
      i.push(
        new ad.CodeLens(s, {
          title: `Augment Next Edit: ${n.result.changeDescription}`,
          command: "",
        }),
      ),
      this._state.value instanceof AfterPreviewState || this._state.value instanceof AnimatingState
        ? i.push(this._buildCodeLens("Undo", UndoAcceptSuggestionCommand.commandID, s))
        : i.push(this._buildCodeLens("Apply", AcceptNextEditCommand.commandID, s)),
      i.push(this._buildCodeLens("Reject", RejectNextEditCommand.commandID, s)),
      i
    )
  }
}
var eC = require("vscode")
var TSe = new eC.EventEmitter(),
  Km = TSe.event,
  gw = class extends DisposableContainer {
    constructor(r, n, i) {
      super()
      this._reportId = n
      this._vcsDetails = i
      this._logger = z(`HeadChangeWatcher[${r}]`)
    }
    _logger
    listening = false
    handleChange = () => {
      this._logger.debug("handling HEAD change"),
        TSe.fire({ repoId: this._reportId })
    }
    listenForChanges() {
      if (this.listening) return
      if (this._vcsDetails.toolName !== "git")
        throw new Error("only git is supported for now")
      let r = eC.workspace.createFileSystemWatcher(
        new eC.RelativePattern(this._vcsDetails.root, ".git/logs/HEAD"),
      )
      this.addDisposables(
        r,
        r.onDidCreate(this.handleChange),
        r.onDidChange(this.handleChange),
        r.onDidDelete(this.handleChange),
      ),
        (this.listening = true),
        this._logger.debug("Listening for HEAD changes.")
    }
  }
var tC = require("vscode")
var mN = new tC.EventEmitter(),
  yN = mN.event,
  AN = class extends DisposableContainer {
    constructor(r, n, i) {
      super()
      this._repoRoot = r
      this._folderName = n
      this._repoId = i
      this._logger = z(`StashWatcher[${this._folderName}]`)
    }
    _logger
    listening = false
    listenForChanges() {
      if (this.listening) return
      let r = tC.Uri.joinPath(this._repoRoot, ".git", "refs", "stash"),
        n = tC.workspace.createFileSystemWatcher(r.fsPath)
      this.addDisposables(
        n,
        n.onDidCreate(() => {
          this._logger.debug("Stash created"), mN.fire({ repoId: this._repoId })
        }),
        n.onDidChange(() => {
          this._logger.debug("Stash changed"), mN.fire({ repoId: this._repoId })
        }),
        n.onDidDelete(() => {
          this._logger.debug("Stash deleted"), mN.fire({ repoId: this._repoId })
        }),
      ),
        (this.listening = true),
        this._logger.debug("Listening for stash changes.")
    }
  }
var qSe = q(require("assert")),
  We = q(require("vscode"))
var vN = q(require("vscode")),
  MSe = "var(--vscode-editorGhostText-foreground)"
function x6() {
  return vN.window.createTextEditorDecorationType({
    after: { contentText: " ", margin: "0 0 0 3em" },
  })
}
function w6(e) {
  let t = { after: { color: MSe, margin: "0 0.25em 0 0" } }
  return (e || [1, 2, 3, 4, 5]).map((n, i) =>
    vN.window.createTextEditorDecorationType({ ...t, ...(e ? e[i] : {}) }),
  )
}
function CN(e) {
  return vN.window.createTextEditorDecorationType({
    after: { color: MSe, margin: "0 0 0 0.5em", contentText: e },
  })
}
function FSe() {
  return [x6(), w6(), CN()]
}
var FCt = q(require("vscode"))
function bN(e) {
  return e
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;")
}
var QCt = new Map([
  [31, "a"],
  [32, "b"],
  [33, "c"],
  [34, "d"],
  [35, "e"],
  [36, "f"],
  [37, "g"],
  [38, "h"],
  [39, "i"],
  [40, "j"],
  [41, "k"],
  [42, "l"],
  [43, "m"],
  [44, "n"],
  [45, "o"],
  [46, "p"],
  [47, "q"],
  [48, "r"],
  [49, "s"],
  [50, "t"],
  [51, "u"],
  [52, "v"],
  [53, "w"],
  [54, "x"],
  [55, "y"],
  [56, "z"],
  [4, "shift"],
  [20, "delete"],
  [3, "return"],
  [2, "tab"],
  [9, "escape"],
  [85, "semicolon"],
  [1, "backspace"],
  [5, { linux: "ctrl", win32: "ctrl", darwin: "control" }],
  [6, { linux: "alt", win32: "alt", darwin: "option" }],
  [57, { linux: "meta", win32: "win", darwin: "command" }],
])
function QSe(e, t) {
  let r = QCt.get(e)
  return r == null || (typeof r == "object" && ((r = r[t]), r == null))
    ? null
    : r
}
function NCt(e, t) {
  let r = QSe(e, t)
  return r == null ? null : `$(augment-kb-${r})`
}
function NSe(e, t) {
  let r = QSe(e, t)
  if (r == null) return null
  let i =
    getVSCodeAPI()?.contributes.icons[`augment-kb-${r}`].default.fontCharacter?.replace(
      "\\",
      "",
    ) ?? null
  return i == null ? null : String.fromCharCode(parseInt(i, 16))
}
function PSe(e, t) {
  return e == null || e.chords.length < 1
    ? null
    : e.chords.find((n) => n instanceof gg)
      ? e.toPrettyString(t)
      : e.chords
          .map((n) => {
            let i = [],
              s = (o) => {
                i.push(NCt(o, t))
              }
            return (
              n.ctrlKey && s(5),
              n.shiftKey && s(4),
              n.altKey && s(6),
              n.metaKey && s(57),
              n.keyCode && s(n.keyCode),
              i.some((o) => o == null)
                ? bN(e.toPrettyString(t))
                : i.join("&nbsp;")
            )
          })
          .join("&nbsp;&nbsp;")
}
function pw(e, t, r) {
  let n = jc.getStructuredKeybinding(t.getKeybindingForCommand(e))
  if (!n || n.chords.length < 1) return []
  if (n.chords.length > 1 || n.chords[0] instanceof gg)
    return [
      {
        after: {
          contentText: n
            ? `[${n.toPrettyString(t.getSimplifiedPlatform())}]`
            : "",
        },
      },
    ]
  {
    let i = n.chords[0],
      s = [],
      o = (l) => {
        s.push(NSe(l, t.getSimplifiedPlatform()))
      }
    if (
      (i.ctrlKey && o(5),
      i.shiftKey && o(4),
      i.altKey && o(6),
      i.metaKey && o(57),
      i.keyCode && o(i.keyCode),
      s.some((l) => l == null))
    )
      return [
        {
          after: {
            contentText: n
              ? `[${n.toPrettyString(t.getSimplifiedPlatform())}]`
              : "",
          },
        },
      ]
    let a = {
      fontFamily: '"Augment.vscode-augment/augment-kb-icon-font.woff"',
      verticalAlign: "bottom",
    }
    return s.map((l) => ({
      light: { after: { ...a, contentText: l } },
      dark: { after: { ...a, contentText: l } },
    }))
  }
}
var rC = q(require("vscode"))
function Cg(e) {
  let t = new rC.Position(e, 0)
  return new rC.Range(t, t)
}
function bg(e, t) {
  let r = e.document.lineAt(t).range.end
  return new rC.Range(r, r)
}
var USe = q(require("assert")),
  EN = q(require("vscode"))
var LSe = z("DecorationManager"),
  _N = class extends DisposableContainer {
    previousDecorationsPerEditor = new Map()
    addExtraDecorationsForActiveEditor(t, r, n, i) {
      return t
    }
    getDecorationsForNextSuggestion
    decorate(t, r) {
      let n = new Map()
      for (let i of EN.window.visibleTextEditors) {
        if (!i.viewColumn) continue
        let s = n.get(i) ?? n.set(i, this.createEmptyDecorations()).get(i),
          o = t.filter((a) => a.qualifiedPathName.equals(i.document.uri))
        for (let a of o) this.addDecorationsForItem(s, i, a, r)
        i === EN.window.activeTextEditor &&
          this.addExtraDecorationsForActiveEditor(s, i, t, r)
      }
      for (let [i, s] of n)
        for (let [o, a] of s) {
          if (o === undefined) {
            LSe.warn("Got an undefined decoration type.")
            continue
          }
          ;(0, USe.default)(a.every((l) => l instanceof a[0].constructor)),
            i.setDecorations(o, a)
        }
      for (let [i, s] of this.previousDecorationsPerEditor) {
        if (!EN.window.visibleTextEditors.includes(i)) {
          this.previousDecorationsPerEditor.delete(i)
          continue
        }
        if (!n.has(i))
          for (let [o, a] of s) {
            if (o === undefined) {
              LSe.warn("Got an undefined decoration type.")
              continue
            }
            i.setDecorations(o, [])
          }
      }
      this.previousDecorationsPerEditor = n
    }
  }
var EditSuggestion = class EditSuggestion {
  constructor(requestId, mode, scope, result, qualifiedPathName, lineRange, uriScheme = "file", occurredAt = new Date(), state = "fresh") {
    this.requestId = requestId
    this.mode = mode
    this.scope = scope
    this.result = result
    this.qualifiedPathName = qualifiedPathName
    this.lineRange = lineRange
    this.uriScheme = uriScheme
    this.occurredAt = occurredAt
    this.state = state
    ;(this.changeType = EditSuggestion.determineChangeType(
      this.result.existingCode,
      this.result.suggestedCode,
    )),
      this.changeType === "modification" &&
        this.makeOneLineDiffSpans()
          .filter((diffSpan) => diffSpan.type !== "noop")
          .every((diffSpan) => diffSpan.type === "insertion" && diffSpan.updated.isWholeLine) &&
        (this.changeType = "insertion"),
      this.changeType === "insertion" && this.lineRange.start > 0
        ? (this.highlightRange = new LineRange(
            this.lineRange.start - 1,
            this.lineRange.stop -
              (this.lineRange.stop > this.lineRange.start &&
              this.result.existingCode.indexOf(`
`) === -1
                ? 1
                : 0),
          ))
        : this.changeType === "insertion" &&
            this.lineRange.start === 0 &&
            this.lineRange.stop === 0
          ? (this.highlightRange = new LineRange(0, 1))
          : (this.highlightRange = this.lineRange)
  }
  changeType
  highlightRange
  previewCursorRange(document) {
    let boxRange = this.previewBoxRange(document)
    return new LineRange(Math.max(0, boxRange.start - 1), boxRange.stop)
  }
  previewBoxRange(document) {
    let isAccepted = this.state === "accepted",
      range = isAccepted ? this.afterLineRange(document) : this.highlightRange
    return (
      isAccepted &&
        (this.changeType === "deletion" && range.start > 0
          ? (range = new LineRange(
              range.start - 1,
              range.stop -
                (range.stop > range.start &&
                this.result.suggestedCode.indexOf(`
`) === -1
                  ? 1
                  : 0),
            ))
          : this.changeType === "deletion" &&
            range.start === 0 &&
            range.stop === 0 &&
            (range = new LineRange(0, 1))),
      range
    )
  }
  get previewTargetCursorLine() {
    return Math.max(0, this.lineRange.start - 1)
  }
  toString() {
    return `EditSuggestion(${this.qualifiedPathName.relPath}:${this.lineRange.toString()})`
  }
  equals(other) {
    return this.result.suggestionId === other?.result.suggestionId
  }
  compareTo(other) {
    return this.qualifiedPathName.equals(other.qualifiedPathName)
      ? this.lineRange.compareTo(other.lineRange)
      : this.qualifiedPathName.relPath.localeCompare(
          other.qualifiedPathName.relPath,
        )
  }
  makeOneLineDiffSpans() {
    return EditSuggestion.makeOneLineDiffSpans(
      this.result.diffSpans,
      this.result.existingCode,
      this.result.suggestedCode,
      this.lineRange,
    )
  }
  static determineChangeType(existingCode, suggestedCode) {
    return existingCode === suggestedCode
      ? "noop"
      : existingCode === ""
        ? "insertion"
        : suggestedCode === ""
          ? "deletion"
          : "modification"
  }
  static makeOneLineDiffSpans(diffSpans, existingCode, suggestedCode, lineRange) {
    if (!diffSpans) return []
    let sortedDiffSpans = diffSpans.sort((a, b) => a.original.start - b.original.start),
      oneLineDiffSpans = [],
      originalLine = lineRange.start,
      updatedLine = lineRange.start,
      isOriginalWholeLine = true,
      isUpdatedWholeLine = true
    for (let diffSpan of sortedDiffSpans) {
      let originalText = existingCode.slice(diffSpan.original.start, diffSpan.original.stop),
        updatedText = suggestedCode.slice(diffSpan.updated.start, diffSpan.updated.stop),
        changeType = EditSuggestion.determineChangeType(originalText, updatedText),
        originalLines = originalText.split(`
`),
        updatedLines = updatedText.split(`
`),
        maxLines = Math.max(originalLines.length, updatedLines.length),
        originalCharPos = diffSpan.original.start,
        updatedCharPos = diffSpan.updated.start
      for (let lineIndex = 0; lineIndex < maxLines; lineIndex++) {
        let originalLineText = originalLines.length > lineIndex ? originalLines[lineIndex] : "",
          updatedLineText = updatedLines.length > lineIndex ? updatedLines[lineIndex] : ""
        if (
          (lineIndex < originalLines.length - 1 &&
            (originalLineText += `
`),
          lineIndex < updatedLines.length - 1 &&
            (updatedLineText += `
`),
          originalLineText === "" && updatedLineText === "")
        )
          continue
        let spanType = changeType
        oneLineDiffSpans.push({
          original: {
            text: originalLineText,
            charRange: new CharRange(originalCharPos, originalCharPos + originalLineText.length),
            line: originalLine,
            isWholeLine:
              isOriginalWholeLine &&
              originalLineText.endsWith(`
`),
          },
          updated: {
            text: updatedLineText,
            charRange: new CharRange(updatedCharPos, updatedCharPos + updatedLineText.length),
            line: updatedLine,
            isWholeLine:
              isUpdatedWholeLine &&
              updatedLineText.endsWith(`
`),
          },
          type: spanType,
        }),
          (originalCharPos += originalLineText.length),
          (updatedCharPos += updatedLineText.length),
          originalLineText.endsWith(`
`)
            ? (originalLine++, (isOriginalWholeLine = true))
            : (isOriginalWholeLine = false),
          updatedLineText.endsWith(`
`)
            ? (updatedLine++, (isUpdatedWholeLine = true))
            : (isUpdatedWholeLine = false)
      }
    }
    return oneLineDiffSpans.filter((span) => span.original.text !== "" || span.updated.text !== "")
  }
  afterLineRange(document) {
    return this.state !== "accepted"
      ? this.lineRange
      : document
        ? this.result.charStart + getTextLength(this.result.suggestedCode) >
          getTextLength(document.getText())
          ? this.lineRange
          : new LineRange(
              document.positionAt(this.result.charStart).line,
              document.positionAt(
                this.result.charStart + getTextLength(this.result.suggestedCode),
              ).line,
            )
        : new LineRange(
            this.lineRange.start,
            this.lineRange.stop +
              this.result.suggestedCode.split(`
`).length -
              this.result.existingCode.split(`
`).length,
          )
  }
  intersects(other) {
    return (
      this.qualifiedPathName.equals(other.qualifiedPathName) &&
      (this.lineRange.equals(other.lineRange) ||
        this.lineRange.intersects(other.lineRange))
    )
  }
  with(updates) {
    return new EditSuggestion(
      updates.requestId ?? this.requestId,
      updates.mode ?? this.mode,
      updates.scope ?? this.scope,
      updates.result ?? this.result,
      updates.qualifiedPathName ?? this.qualifiedPathName,
      updates.lineRange ?? this.lineRange,
      updates.uriScheme ?? this.uriScheme,
      updates.occurredAt ?? this.occurredAt,
      updates.state ?? this.state,
    )
  }
  static from(data) {
    return new EditSuggestion(
      data.requestId,
      data.mode,
      data.scope,
      data.result,
      QualifiedPathName.from(data.qualifiedPathName),
      new LineRange(data.lineRange.start, data.lineRange.stop),
      data.uriScheme,
      data.occurredAt,
      data.state,
    )
  }
}
var ru = q(require("vscode"))
var OSe = { border: 0, background: 1, line: 2 },
  xN = class extends DisposableContainer {
    constructor(r) {
      super()
      this._styles = r
      ;(this._decorationTypes.insertion = this._createDecorations(
        this._styles.insertion,
      )),
        (this._decorationTypes.deletion = this._createDecorations(
          this._styles.deletion,
        )),
        this.addDisposables(
          ...Object.values(this._decorationTypes.insertion).flat(),
          ...Object.values(this._decorationTypes.deletion).flat(),
        )
    }
    _decorationTypes = {
      insertion: { upper: [], lower: [] },
      deletion: { upper: [], lower: [] },
    }
    _createDecorations(r) {
      return {
        upper: this._createHalfDecoration(r, false),
        lower: this._createHalfDecoration(r, true),
      }
    }
    _createHalfDecoration(r, n) {
      let i = (s) => (n ? `${s} 0 0 0` : `0 0 ${s} 0`)
      return [
        ru.window.createTextEditorDecorationType({
          borderWidth: i(r.borderWidth),
          light: { borderColor: r.lightBorderColor },
          dark: { borderColor: r.darkBorderColor },
          borderStyle: "solid",
          isWholeLine: true,
        }),
        ru.window.createTextEditorDecorationType({
          borderWidth: i("0.2em"),
          light: { borderColor: r.lightBackgroundColor },
          dark: { borderColor: r.darkBackgroundColor },
          borderStyle: "solid",
          isWholeLine: true,
        }),
        ru.window.createTextEditorDecorationType({
          borderWidth: i("0.1em"),
          borderColor: r.lineColor,
          borderStyle: "solid",
          isWholeLine: true,
          overviewRulerColor: n ? r.overviewRulerColor : undefined,
          overviewRulerLane: n ? ru.OverviewRulerLane.Right : undefined,
        }),
      ]
    }
    addEmptyDecorations(r) {
      for (let n of ["insertion", "deletion"])
        for (let i of ["upper", "lower"])
          for (let s of this._decorationTypes[n][i]) r.set(s, [])
    }
    addDecorations(r, n, i) {
      if (n > 0)
        for (let s of this._decorationTypes[r].upper)
          i.get(s)?.push(new ru.Range(n - 1, 0, n - 1, 0))
      for (let s of this._decorationTypes[r].lower)
        i.get(s)?.push(new ru.Range(n, 0, n, 0))
    }
    addSimpleInsertionDecoration(r, n) {
      r > 0 &&
        n
          .get(this._decorationTypes.insertion.upper[OSe.line])
          ?.push(new ru.Range(r - 1, 0, r - 1, 0)),
        n
          .get(this._decorationTypes.insertion.lower[OSe.line])
          ?.push(new ru.Range(r, 0, r, 0))
    }
  }
var DecorationManager = class e extends _N {
  constructor(r, n, i, s, o, a, l) {
    super()
    this._context = r
    this._workspaceManager = n
    this._keybindingWatcher = i
    this._configListener = s
    this._nextEditSessionEventReporter = o
    this._completionVisible = a
    this._showAllLineHighlights = l
    let c = {
        active: {
          insertion: {
            light: "nextedit-addition-selected-light.svg",
            dark: "nextedit-addition-selected-dark.svg",
          },
          insertionInBetween: {
            light: "nextedit-addition-inbetween-selected-light.svg",
            dark: "nextedit-addition-inbetween-selected-dark.svg",
          },
          deletion: {
            light: "nextedit-deletion-selected-light.svg",
            dark: "nextedit-deletion-selected-dark.svg",
          },
          modification: {
            light: "nextedit-change-selected-light.svg",
            dark: "nextedit-change-selected-dark.svg",
          },
        },
        inactive: {
          insertion: {
            light: "nextedit-addition-light.svg",
            dark: "nextedit-addition-dark.svg",
          },
          insertionInBetween: {
            light: "nextedit-addition-inbetween-light.svg",
            dark: "nextedit-addition-inbetween-dark.svg",
          },
          deletion: {
            light: "nextedit-deletion-light.svg",
            dark: "nextedit-deletion-dark.svg",
          },
          modification: {
            light: "nextedit-change-light.svg",
            dark: "nextedit-change-dark.svg",
          },
        },
        applied: {
          light: "nextedit-applied-light.svg",
          dark: "nextedit-applied-dark.svg",
        },
        appliedInBetween: {
          light: "nextedit-applied-inbetween-light.svg",
          dark: "nextedit-applied-inbetween-dark.svg",
        },
        grayline: {
          light: "bg-next-edit-gray-line.svg",
          dark: "bg-next-edit-gray-line.svg",
        },
        grayhook: {
          light: "bg-next-edit-gray-hook.svg",
          dark: "bg-next-edit-gray-hook.svg",
        },
      },
      u = new Map([
        [
          "insertion",
          {
            inline:
              "rgb(from var(--vscode-diffEditor-insertedTextBackground) r g b / calc(alpha * 1.8))",
            focusLine:
              "rgb(from var(--vscode-diffEditor-insertedTextBackground) r g b / calc(alpha * 1.3))",
            lineBackground: new We.ThemeColor(
              "diffEditor.insertedLineBackground",
            ),
            lineOverview: new We.ThemeColor(
              "editorOverviewRuler.addedForeground",
            ),
          },
        ],
        [
          "deletion",
          {
            inline:
              "rgb(from var(--vscode-diffEditor-removedTextBackground) r g b / calc(alpha * 2))",
            focusLine: "var(--vscode-diffEditor-removedLineBackground)",
            lineBackground:
              "rgb(from var(--vscode-diffEditor-removedLineBackground) r g b / calc(alpha * 0.5))",
            lineOverview: new We.ThemeColor(
              "editorOverviewRuler.deletedForeground",
            ),
          },
        ],
        [
          "modification",
          {
            inline:
              "rgb(from var(--vscode-editorOverviewRuler-modifiedForeground) r g b / calc(alpha * 0.5))",
            focusLine:
              "rgb(from var(--vscode-editorOverviewRuler-modifiedForeground) r g b / calc(alpha * 0.35))",
            lineBackground:
              "rgb(from var(--vscode-editorOverviewRuler-modifiedForeground) r g b / calc(alpha * 0.2))",
            lineOverview: new We.ThemeColor(
              "editorOverviewRuler.modifiedForeground",
            ),
          },
        ],
      ]),
      f = new Map([
        [
          "insertion",
          {
            dark: { backgroundColor: "#27E14966", color: "#BCF0C9" },
            light: { backgroundColor: "#82CC0266", color: "#4B543E" },
          },
        ],
        [
          "deletion",
          {
            dark: { backgroundColor: "#FF272766", color: "#F4A2A6" },
            light: { backgroundColor: "#FF272766", color: "#412C2D" },
          },
        ],
        [
          "modification",
          {
            dark: { backgroundColor: "#FFE30966", color: "#F4EEB6" },
            light: { backgroundColor: "#EDBD0099", color: "#433C1E" },
          },
        ],
      ]),
      p = {
        light: {
          after: {
            color:
              "color-mix(in srgb, rgb(0, 0, 0) 50%, var(--vscode-editor-background))",
            backgroundColor:
              "color-mix(in srgb, rgb(0,0,0) 15%, var(--vscode-editor-background))",
          },
        },
        dark: {
          after: {
            color:
              "color-mix(in srgb, rgb(255, 255, 255) 90%, var(--vscode-editor-background))",
            backgroundColor:
              "color-mix(in srgb, rgb(255, 255, 255) 25%, var(--vscode-editor-background))",
          },
        },
      },
      g = (C, E, w, B = "75%") => {
        let T = c[C][E][w]
        return {
          gutterIconPath: We.Uri.joinPath(
            r.extensionUri,
            "media",
            "next-edit",
            T,
          ),
          gutterIconSize: B,
        }
      },
      m = (C, E, w = "75%") => {
        let B = c[C][E]
        return {
          gutterIconPath: We.Uri.joinPath(
            r.extensionUri,
            "media",
            "next-edit",
            B,
          ),
          gutterIconSize: w,
        }
      }
    ;(this._gutterDecorations = {
      active: {
        insertion: We.window.createTextEditorDecorationType({
          light: g("active", "insertion", "light"),
          dark: g("active", "insertion", "dark"),
          overviewRulerColor: u.get("insertion")?.lineOverview,
          overviewRulerLane: We.OverviewRulerLane.Right,
        }),
        insertionInBetween: We.window.createTextEditorDecorationType({
          light: g("active", "insertionInBetween", "light"),
          dark: g("active", "insertionInBetween", "dark"),
          overviewRulerColor: u.get("insertion")?.lineOverview,
          overviewRulerLane: We.OverviewRulerLane.Right,
        }),
        deletion: We.window.createTextEditorDecorationType({
          light: g("active", "deletion", "light"),
          dark: g("active", "deletion", "dark"),
          overviewRulerColor: u.get("deletion")?.lineOverview,
          overviewRulerLane: We.OverviewRulerLane.Right,
        }),
        modification: We.window.createTextEditorDecorationType({
          light: g("active", "modification", "light"),
          dark: g("active", "modification", "dark"),
          overviewRulerColor: u.get("modification")?.lineOverview,
          overviewRulerLane: We.OverviewRulerLane.Right,
        }),
      },
      inactive: {
        insertion: We.window.createTextEditorDecorationType({
          light: g("inactive", "insertion", "light"),
          dark: g("inactive", "insertion", "dark"),
          overviewRulerColor: u.get("insertion")?.lineOverview,
          overviewRulerLane: We.OverviewRulerLane.Right,
        }),
        insertionInBetween: We.window.createTextEditorDecorationType({
          light: g("inactive", "insertionInBetween", "light"),
          dark: g("inactive", "insertionInBetween", "dark"),
          overviewRulerColor: u.get("insertion")?.lineOverview,
          overviewRulerLane: We.OverviewRulerLane.Right,
        }),
        deletion: We.window.createTextEditorDecorationType({
          light: g("inactive", "deletion", "light"),
          dark: g("inactive", "deletion", "dark"),
          overviewRulerColor: u.get("deletion")?.lineOverview,
          overviewRulerLane: We.OverviewRulerLane.Right,
        }),
        modification: We.window.createTextEditorDecorationType({
          light: g("inactive", "modification", "light"),
          dark: g("inactive", "modification", "dark"),
          overviewRulerColor: u.get("modification")?.lineOverview,
          overviewRulerLane: We.OverviewRulerLane.Right,
        }),
      },
      applied: We.window.createTextEditorDecorationType({
        light: m("applied", "light"),
        dark: m("applied", "dark"),
      }),
      appliedInBetween: We.window.createTextEditorDecorationType({
        light: m("appliedInBetween", "light"),
        dark: m("appliedInBetween", "dark"),
      }),
      grayline: We.window.createTextEditorDecorationType({
        light: m("grayline", "light", "cover"),
        dark: m("grayline", "dark", "cover"),
      }),
      grayhook: We.window.createTextEditorDecorationType({
        light: m("grayhook", "light", "cover"),
        dark: m("grayhook", "dark", "cover"),
      }),
    }),
      this.addDisposables(
        ...Object.values(this._gutterDecorations.active),
        ...Object.values(this._gutterDecorations.inactive),
        this._gutterDecorations.applied,
        this._gutterDecorations.appliedInBetween,
        this._gutterDecorations.grayline,
        this._gutterDecorations.grayhook,
      ),
      (this._focusLineDecorations = new Map()),
      (this._focusWholeLineDecorations = new Map()),
      (this._wholeLineDecorations = new Map()),
      (this._lineDecorations = new Map()),
      (this._zeroWidthChangeDecorationsRight = new Map()),
      (this._zeroWidthChangeDecorationsLeft = new Map()),
      (this._zeroWidthChangeDecorationsStartLine = new Map()),
      (this._zeroWidthChangeDecorationsEndLine = new Map())
    for (let [C, E] of u) {
      this._focusLineDecorations.set(
        C,
        We.window.createTextEditorDecorationType({
          backgroundColor: E.focusLine,
          isWholeLine: false,
          overviewRulerColor: E.lineOverview,
          overviewRulerLane: We.OverviewRulerLane.Right,
        }),
      ),
        this._focusWholeLineDecorations.set(
          C,
          We.window.createTextEditorDecorationType({
            backgroundColor: E.focusLine,
            isWholeLine: true,
            overviewRulerColor: E.lineOverview,
            overviewRulerLane: We.OverviewRulerLane.Right,
          }),
        ),
        this._lineDecorations.set(
          C,
          We.window.createTextEditorDecorationType({
            backgroundColor: E.lineBackground,
            isWholeLine: false,
            overviewRulerColor: E.lineOverview,
            overviewRulerLane: We.OverviewRulerLane.Right,
          }),
        ),
        this._wholeLineDecorations.set(
          C,
          We.window.createTextEditorDecorationType({
            backgroundColor: E.lineBackground,
            isWholeLine: true,
            overviewRulerColor: E.lineOverview,
            overviewRulerLane: We.OverviewRulerLane.Right,
          }),
        )
      let w = { borderStyle: "solid", borderColor: E.inline }
      this._zeroWidthChangeDecorationsRight.set(
        C,
        We.window.createTextEditorDecorationType({
          borderWidth: "0 0.2em 0 0",
          ...w,
        }),
      ),
        this._zeroWidthChangeDecorationsLeft.set(
          C,
          We.window.createTextEditorDecorationType({
            borderWidth: "0 0 0 0.2em",
            ...w,
          }),
        ),
        this._zeroWidthChangeDecorationsStartLine.set(
          C,
          We.window.createTextEditorDecorationType({
            borderWidth: "0 0 0 0.4em",
            ...w,
          }),
        ),
        this._zeroWidthChangeDecorationsEndLine.set(
          C,
          We.window.createTextEditorDecorationType({
            borderWidth: "0 0.4em 0 0",
            ...w,
          }),
        )
    }
    this.addDisposables(
      ...this._focusLineDecorations.values(),
      ...this._focusWholeLineDecorations.values(),
      ...this._lineDecorations.values(),
      ...this._wholeLineDecorations.values(),
      ...this._zeroWidthChangeDecorationsRight.values(),
      ...this._zeroWidthChangeDecorationsLeft.values(),
      ...this._zeroWidthChangeDecorationsStartLine.values(),
      ...this._zeroWidthChangeDecorationsEndLine.values(),
    ),
      (this._inlineDecorations = new Map())
    for (let [C, E] of f)
      this._inlineDecorations.set(
        C,
        We.window.createTextEditorDecorationType({
          ...E,
          borderRadius: "0.2em",
        }),
      )
    this.addDisposables(...this._inlineDecorations.values()),
      (this._bottomLineDecorationType =
        We.window.createTextEditorDecorationType({
          after: { backgroundColor: "var(--vscode-editor-background)" },
        })),
      this.addDisposables(this._bottomLineDecorationType),
      (this._bottomBoxDecorationType = We.window.createTextEditorDecorationType(
        {
          light: { after: { backgroundColor: p.light.after.backgroundColor } },
          dark: { after: { backgroundColor: p.dark.after.backgroundColor } },
        },
      )),
      this.addDisposables(this._bottomBoxDecorationType),
      (this._bottomBoxLogoDecorationType =
        We.window.createTextEditorDecorationType({
          light: { after: { color: p.light.after.color } },
          dark: {
            after: {
              color: `color-mix(in srgb, ${p.dark.after.color} 50%, ${p.dark.after.backgroundColor})`,
            },
          },
        })),
      this.addDisposables(this._bottomBoxLogoDecorationType),
      ([
        this._rightSpacerDecorationType,
        this._rightKeybindingDecorationTypes,
        this._rightDecorationType,
      ] = FSe()),
      this.addDisposables(
        this._rightSpacerDecorationType,
        ...this._rightKeybindingDecorationTypes,
        this._rightDecorationType,
      ),
      (this._bottomTextDecorationType =
        We.window.createTextEditorDecorationType({
          dark: {
            after: {
              color: p.dark.after.color,
              backgroundColor: p.dark.after.backgroundColor,
            },
          },
          light: {
            after: {
              color: p.light.after.color,
              backgroundColor: p.light.after.backgroundColor,
            },
          },
        })),
      this.addDisposables(this._bottomTextDecorationType)
    let y = {
        light: {
          borderColor: "#87BFFF80",
          backgroundColor: "#87BFFF33",
          overviewRulerColor: "#87BFFF",
        },
        dark: {
          borderColor: "#9ECBFF80",
          backgroundColor: "#9ECBFF1A",
          overviewRulerColor: "#9ECBFF",
        },
        borderStyle: "solid",
        isWholeLine: true,
        borderWidth: "0.1em",
        borderRadius: "0.4em",
        overviewRulerLane: We.OverviewRulerLane.Right,
      },
      v = {
        light: {
          borderColor: "#87BFFF",
          backgroundColor: "#87BFFF33",
          overviewRulerColor: "#87BFFF",
        },
        dark: {
          borderColor: "#9ECBFF",
          backgroundColor: "#9ECBFF1A",
          overviewRulerColor: "#9ECBFF",
        },
        borderStyle: "solid",
        isWholeLine: true,
        borderWidth: "0.2em",
        borderRadius: "0.4em",
        overviewRulerLane: We.OverviewRulerLane.Right,
      }
    ;(this._zeroHeightDiffLineBuilder = new xN({
      insertion: {
        lineColor:
          "rgb(from var(--vscode-diffEditor-insertedLineBackground) r g b / 1)",
        lightBorderColor: y.light.borderColor,
        darkBorderColor: y.dark.borderColor,
        lightBackgroundColor:
          "color-mix(in srgb, #87BFFF 33%, var(--vscode-editor-background))",
        darkBackgroundColor:
          "color-mix(in srgb, #9ECBFF 10%, var(--vscode-editor-background))",
        borderWidth: "0.3em",
        overviewRulerColor: u.get("insertion")?.lineOverview,
      },
      deletion: {
        lineColor:
          "rgb(from var(--vscode-diffEditor-removedLineBackground) r g b / calc(alpha * 1.3))",
        lightBorderColor: v.light.borderColor,
        darkBorderColor: v.dark.borderColor,
        lightBackgroundColor:
          "color-mix(in srgb, #87BFFF 33%, var(--vscode-editor-background))",
        darkBackgroundColor:
          "color-mix(in srgb, #9ECBFF 10%, var(--vscode-editor-background))",
        borderWidth: "0.4em",
        overviewRulerColor: u.get("deletion")?.lineOverview,
      },
    })),
      this.addDisposables(this._zeroHeightDiffLineBuilder),
      (this._activeChangeDecoration1Line = new Map()),
      (this._activeChangeDecorationTop = new Map()),
      (this._activeChangeDecorationMiddle = new Map()),
      (this._activeChangeDecorationBottom = new Map())
    for (let { baseType: C, mode: E } of [
      { baseType: y, mode: 0 },
      { baseType: v, mode: 1 },
    ])
      this._activeChangeDecoration1Line.set(
        E,
        We.window.createTextEditorDecorationType({ ...C }),
      ),
        this._activeChangeDecorationTop.set(
          E,
          We.window.createTextEditorDecorationType({
            ...C,
            borderWidth: [
              C.borderWidth,
              C.borderWidth,
              "0",
              C.borderWidth,
            ].join(" "),
            borderRadius: [C.borderRadius, C.borderRadius, "0", "0"].join(" "),
          }),
        ),
        this._activeChangeDecorationMiddle.set(
          E,
          We.window.createTextEditorDecorationType({
            ...C,
            borderRadius: undefined,
            borderWidth: ["0", C.borderWidth, "0", C.borderWidth].join(" "),
          }),
        ),
        this._activeChangeDecorationBottom.set(
          E,
          We.window.createTextEditorDecorationType({
            ...C,
            borderWidth: [
              "0",
              C.borderWidth,
              C.borderWidth,
              C.borderWidth,
            ].join(" "),
            borderRadius: ["0", "0", C.borderRadius, C.borderRadius].join(" "),
          }),
        )
    this.addDisposables(
      ...this._activeChangeDecoration1Line.values(),
      ...this._activeChangeDecorationTop.values(),
      ...this._activeChangeDecorationMiddle.values(),
      ...this._activeChangeDecorationBottom.values(),
    )
  }
  _gutterDecorations
  _lineDecorations
  _wholeLineDecorations
  _focusLineDecorations
  _focusWholeLineDecorations
  _inlineDecorations
  _rightDecorationType
  _bottomBoxLogoDecorationType
  _rightKeybindingDecorationTypes
  _rightSpacerDecorationType
  _bottomLineDecorationType
  _bottomBoxDecorationType
  _bottomTextDecorationType
  _zeroWidthChangeDecorationsRight
  _zeroWidthChangeDecorationsLeft
  _zeroWidthChangeDecorationsStartLine
  _zeroWidthChangeDecorationsEndLine
  _activeChangeDecoration1Line
  _activeChangeDecorationTop
  _activeChangeDecorationMiddle
  _activeChangeDecorationBottom
  _zeroHeightDiffLineBuilder
  shouldDrawBottomDecorations = new Observable(true)
  babyGlobalHintRange
  bottomBoxRange
  cursorHintRange
  _filesWithGutterIconActions = new Set()
  _linesWithGutterIconActions = []
  _logger = z("BackgroundDecorationManager")
  static suppressGhostTextLineThreshold = 3
  static _maxGrayTextChars = 40
  static _maxBottomTextPathChars = 40
  static _maxBottomTextChars = 80
  createEmptyDecorations() {
    let r = new Map()
    r.set(this._rightSpacerDecorationType, []),
      r.set(this._rightDecorationType, []),
      this._rightKeybindingDecorationTypes.forEach((i) => {
        r.set(i, [])
      }),
      r.set(this._bottomLineDecorationType, []),
      r.set(this._bottomBoxDecorationType, []),
      r.set(this._bottomBoxLogoDecorationType, []),
      r.set(this._bottomTextDecorationType, []),
      this._zeroHeightDiffLineBuilder.addEmptyDecorations(r),
      this._activeChangeDecoration1Line.forEach((i) => {
        r.set(i, [])
      }),
      this._activeChangeDecorationTop.forEach((i) => {
        r.set(i, [])
      }),
      this._activeChangeDecorationMiddle.forEach((i) => {
        r.set(i, [])
      }),
      this._activeChangeDecorationBottom.forEach((i) => {
        r.set(i, [])
      }),
      Object.values(this._gutterDecorations.active).forEach((i) => {
        r.set(i, [])
      }),
      Object.values(this._gutterDecorations.inactive).forEach((i) => {
        r.set(i, [])
      }),
      r.set(this._gutterDecorations.applied, []),
      r.set(this._gutterDecorations.appliedInBetween, []),
      r.set(this._gutterDecorations.grayline, []),
      r.set(this._gutterDecorations.grayhook, [])
    let n = ["insertion", "deletion", "modification"]
    for (let i of n)
      r.set(this._lineDecorations.get(i), []),
        r.set(this._focusLineDecorations.get(i), []),
        r.set(this._wholeLineDecorations.get(i), []),
        r.set(this._focusWholeLineDecorations.get(i), []),
        r.set(this._inlineDecorations.get(i), []),
        r.set(this._zeroWidthChangeDecorationsRight.get(i), []),
        r.set(this._zeroWidthChangeDecorationsLeft.get(i), []),
        r.set(this._zeroWidthChangeDecorationsStartLine.get(i), []),
        r.set(this._zeroWidthChangeDecorationsEndLine.get(i), [])
    return r
  }
  decorate(r, n) {
    this._filesWithGutterIconActions.clear(),
      (this._linesWithGutterIconActions = []),
      super.decorate(r, n),
      We.commands.executeCommand(
        "setContext",
        "vscode-augment.nextEdit.linesWithGutterIconActions",
        this._linesWithGutterIconActions,
      ),
      We.commands.executeCommand(
        "setContext",
        "vscode-augment.nextEdit.filesWithGutterIconActions",
        Array.from(this._filesWithGutterIconActions),
      )
  }
  addDecorationsForItem(r, n, i, s) {
    if (!i.qualifiedPathName.equals(n.document.uri) || i.changeType === "noop")
      return r
    let o = i.equals(s.activeSuggestion),
      a = o || i.equals(s.hintSuggestion?.suggestion),
      l = i.state === "accepted",
      c = i.makeOneLineDiffSpans(),
      u = l ? i.afterLineRange(n.document) : i.lineRange,
      f
    u.start === 0 ||
    (i.changeType !== "insertion" &&
      !(c[0] && c[0].type === "insertion" && c[0].updated.isWholeLine))
      ? (f = u)
      : n.document.lineAt(u.start - 1).text.length > 0
        ? (f = new LineRange(u.start - 1, u.stop))
        : (f = new LineRange(u.start - 1, u.stop - 1))
    let p = (Y) => {
        l ||
          (this._filesWithGutterIconActions.add(i.qualifiedPathName.absPath),
          this._linesWithGutterIconActions.push(Y + 1))
      },
      g =
        i.changeType === "insertion" && i.lineRange.length === 0
          ? "insertionInBetween"
          : i.changeType,
      m =
        s.activeSuggestion !== undefined &&
        s.activeSuggestion.state !== "accepted",
      y
    l && u.length === 0
      ? (y = this._gutterDecorations.appliedInBetween)
      : l
        ? (y = this._gutterDecorations.applied)
        : o || (!m && a)
          ? (y = this._gutterDecorations.active[g])
          : (y = this._gutterDecorations.inactive[g])
    let v = i.previewBoxRange(n.document)
    r.get(y)?.push(Cg(v.start)), p(v.start)
    for (let Y = v.start + 1; Y < v.stop - 1; Y++)
      r.get(this._gutterDecorations.grayline)?.push(Cg(Y)), p(Y)
    if (
      (v.stop - v.start > 1 &&
        (r.get(this._gutterDecorations.grayhook)?.push(Cg(v.stop - 1)),
        p(v.stop - 1)),
      (s.isAnimating && s.activeSuggestion && !o) ||
        (a && this._completionVisible()))
    )
      return r
    let C = o,
      E = this._showAllLineHighlights() && !C && !l,
      w = createRange(f)
    if (E && !o)
      if (i.changeType === "insertion")
        this._zeroHeightDiffLineBuilder.addSimpleInsertionDecoration(
          w.start.line + 1,
          r,
        )
      else {
        let Y =
            f.length === 0 ||
            i.result.existingCode ===
              `
`,
          U = [
            [this._lineDecorations, this._wholeLineDecorations],
            [this._focusLineDecorations, this._focusWholeLineDecorations],
          ][+a][+Y],
          ce = w
        Y && (ce = w.with(undefined, w.end.translate(-1, 0))),
          r.get(U.get(i.changeType))?.push(ce)
      }
    else if (C) {
      if (
        (i.changeType === "insertion" && !l) ||
        (i.changeType === "deletion" && l)
      )
        this._zeroHeightDiffLineBuilder.addDecorations(
          i.changeType,
          w.start.line + (i.changeType === "insertion" ? 1 : 0),
          r,
        )
      else if (i.changeType === (l ? "deletion" : "insertion")) {
        let U =
          f.length === 0
            ? this._focusWholeLineDecorations
            : this._focusLineDecorations
        r.get(U.get(i.changeType))?.push(w)
      }
      for (let [U, ce] of PCt(n.document, i, !l))
        if (U === "noop")
          E && r.get(this._focusLineDecorations.get(i.changeType))?.push(ce)
        else if (
          U === "deletion" &&
          ce.start.character === 0 &&
          ce.end.character === 0
        ) {
          r.get(this._focusLineDecorations.get(U))?.push(ce)
          continue
        } else
          ce.start.isEqual(ce.end)
            ? this._addZeroWidthDecoration(n.document, r, ce, U)
            : r.get(this._inlineDecorations.get(U)).push(ce)
      let Y = l ? 1 : 0
      this._addPreviewBox(r, n, i, Y)
    }
    let B = i.result.changeDescription,
      T = n.selection,
      N = n.visibleRanges.some((Y) => Y.contains(createRange(f))),
      W = this._configListener.config.nextEdit.useCursorDecorations,
      Z = T.active.line - f.start,
      te = !W || Math.abs(Z) <= e.suppressGhostTextLineThreshold
    return (
      a &&
        N &&
        !l &&
        !o &&
        (te && this.addKeybindingDecor(f.start, r, n, NextEditNavigateCommand.commandID),
        this.addGrayText(`${B}`, f.start, r, n),
        this._nextEditSessionEventReporter.reportEventFromSuggestion(
          i,
          "suggestion-hint-shown",
          "background",
        )),
      N &&
        !l &&
        this._nextEditSessionEventReporter.reportEventFromSuggestion(
          i,
          "suggestion-visibly-shown",
          "background",
        ),
      r
    )
  }
  _addZeroWidthDecoration(r, n, i, s) {
    if (i.start.character === 0) {
      n.get(this._zeroWidthChangeDecorationsStartLine.get(s)).push(
        new We.Range(i.start, i.start.translate(0, 1)),
      )
      return
    } else if (i.start.character === r.lineAt(i.start.line).text.length) {
      n.get(this._zeroWidthChangeDecorationsEndLine.get(s)).push(
        new We.Range(i.start.translate(0, -1), i.start),
      )
      return
    } else
      n
        .get(this._zeroWidthChangeDecorationsLeft.get(s))
        .push(new We.Range(i.start, i.start.translate(0, 1))),
        n
          .get(this._zeroWidthChangeDecorationsRight.get(s))
          .push(new We.Range(i.start.translate(0, -1), i.start))
  }
  addKeybindingDecor(r, n, i, s = NextEditNavigateCommand.commandID) {
    pw(s, this._keybindingWatcher, this._context).map((o, a) => {
      n.get(this._rightKeybindingDecorationTypes[a])?.push({
        range: bg(i, r),
        renderOptions: o,
      })
    })
  }
  addGrayText(r, n, i, s) {
    i.get(this._rightSpacerDecorationType).push({ range: bg(s, n) })
    let o = yc(r, e._maxGrayTextChars)
    i.get(this._rightDecorationType).push({
      range: bg(s, n),
      renderOptions: { after: { contentText: o } },
    })
  }
  addExtraDecorationsForActiveEditor(r, n, i, s) {
    ;(0, qSe.default)(n === We.window.activeTextEditor)
    let o = this._workspaceManager.safeResolvePathName(n.document.uri)
    if (!o) return r
    ;(this.babyGlobalHintRange = undefined),
      (this.bottomBoxRange = undefined),
      (this.cursorHintRange = undefined)
    let a = s.hintSuggestion?.suggestion
    if (this._completionVisible() || !a || n.visibleRanges.length === 0)
      return r
    let l = this._configListener.config.nextEdit.useCursorDecorations
    if (a.qualifiedPathName.equals(n.document.uri)) {
      let c = a.result.changeDescription,
        u = n.selection,
        f
      if (
        (a.changeType !== "insertion" || a.lineRange.start === 0
          ? (f = a.lineRange)
          : n.document.lineAt(a.lineRange.start - 1).text.length > 0
            ? (f = new LineRange(a.lineRange.start - 1, a.lineRange.stop))
            : (f = new LineRange(a.lineRange.start - 1, a.lineRange.stop - 1)),
        l)
      ) {
        let p = u.intersection(createRange(f)),
          g = u.start.line - f.start,
          m =
            Math.abs(g) > e.suppressGhostTextLineThreshold ||
            !n.visibleRanges.some((v) => v.contains(createRange(f))),
          y = ""
        !p && m && (y = `${g > 0 ? "\u2191" : "\u2193"}${Math.abs(g)} lines: `),
          (y || p) &&
            (this.addKeybindingDecor(u.start.line, r, n, NextEditNavigateCommand.commandID),
            this.addGrayText(`${y}${c}`, u.start.line, r, n),
            (this.cursorHintRange = bg(n, u.start.line)),
            this._nextEditSessionEventReporter.reportEventFromSuggestion(
              a,
              "suggestion-offset-text-shown",
              "background",
            ))
      } else {
        if (n.visibleRanges.some((g) => g.contains(createRange(a.highlightRange))))
          return r
        let p = f.start < b6(n)[0].start.line ? "\u2191" : "\u2193"
        this.addBottomDecoration(r, n, `${p} ${c}`),
          this._nextEditSessionEventReporter.reportEventFromSuggestion(
            a,
            "suggestion-bottom-text-shown",
            "background",
          )
      }
    } else if (
      this._configListener.config.nextEdit.enableGlobalBackgroundSuggestions
    ) {
      if (l) {
        this.addKeybindingDecor(n.selection.active.line, r, n)
        let c = "in file: "
        this.addGrayText(
          `${c}${yc(a.qualifiedPathName.relPath, e._maxGrayTextChars - getTextLength(c), true)}`,
          n.selection.active.line,
          r,
          n,
        ),
          (this.babyGlobalHintRange = bg(n, n.selection.active.line))
      } else {
        let c = "\u21AA ",
          u = ql(o.relPath, a.qualifiedPathName.relPath),
          f = yc(
            u.length < a.qualifiedPathName.relPath.length
              ? u
              : a.qualifiedPathName.relPath,
            e._maxBottomTextPathChars,
            true,
          ),
          p = a.result.changeDescription,
          g = yc(`${c}${f}: ${p}`, e._maxBottomTextChars, false)
        this.addBottomDecoration(r, n, g)
      }
      this._nextEditSessionEventReporter.reportEventFromSuggestion(
        a,
        "suggestion-global-bottom-text-shown",
        "background",
      )
    }
    return r
  }
  addBottomDecoration(r, n, i) {
    if (n.visibleRanges.length === 0 || !this.shouldDrawBottomDecorations.value)
      return
    let s = b6(n),
      o = s[s.length - 1],
      a = o.end.line >= n.document.lineCount - 1,
      l = n.selection,
      c = a ? l.active.line > o.end.line - 2 : l.active.line > o.end.line - 3
    if (s.some((C) => C.intersection(l)) && c) return
    let u = yc(i, e._maxBottomTextChars),
      f = (C) => {
        if (C < 0 || C >= n.document.lineCount) return
        let E = n.document.lineAt(C).text.length
        r.get(this._bottomLineDecorationType).push({
          range: new We.Range(C, E, C, E),
          renderOptions: {
            after: {
              margin: `0 ${-E}ch 0 ${-E}ch`,
              contentText: `${"\xA0".repeat(E)}`,
              padding: "0 0 0.3lh 0",
            },
          },
        })
      }
    a
      ? f(o.end.line)
      : (f(o.end.line - 1), f(o.end.line), f(o.end.line + 1), f(o.end.line + 2))
    let p = a ? n.document.lineCount - 1 : o.end.line - 1,
      g = n.document.lineAt(p).text.length,
      m = new We.Range(p, g, p, g)
    ;(this.babyGlobalHintRange = new We.Range(p, 0, p, g)),
      (this.bottomBoxRange = this.babyGlobalHintRange)
    let y = 20
    r.get(this._bottomBoxDecorationType).push({
      range: m,
      renderOptions: {
        after: {
          margin: `0 -${y + 1}ch 0 0`,
          contentText: `${"\xA0".repeat(y)}`,
          padding: "0.2em 1ch 0.15em 1ch",
          borderRadius: "0.3em",
        },
      },
    })
    let v = {
      contentText: "\uE901",
      fontFamily: '"Augment.vscode-augment/augment-icon-font.woff"',
      verticalAlign: "top",
      margin: "0 1ch 0 0",
    }
    r
      .get(this._bottomBoxLogoDecorationType)
      .push({
        renderOptions: { light: { after: v }, dark: { after: v } },
        range: m,
      }),
      this.addKeybindingDecor(p, r, n),
      r
        .get(this._bottomTextDecorationType)
        .push({
          range: m,
          renderOptions: {
            after: {
              margin: "0 0 0 1ch",
              contentText: u,
              padding: "0.2em 1ch 0.15em 0",
              borderRadius: "0 0.3em 0.3em 0",
            },
          },
        })
  }
  _addPreviewBox(r, n, i, s) {
    let o = s === 1
    if (
      (i.changeType === "insertion" && !o) ||
      (i.changeType === "deletion" && o)
    )
      return
    let a = i.previewBoxRange(n.document)
    a.stop - a.start <= 1
      ? r.get(this._activeChangeDecoration1Line.get(s))?.push(Cg(a.start))
      : r.get(this._activeChangeDecorationTop.get(s))?.push(Cg(a.start))
    for (let l = a.start + 1; l < a.stop - 1; l++)
      r.get(this._activeChangeDecorationMiddle.get(s))?.push(Cg(l))
    a.stop - a.start > 1 &&
      r.get(this._activeChangeDecorationBottom.get(s))?.push(Cg(a.stop - 1))
  }
}
function PCt(e, t, r) {
  let n = t.result.existingCode,
    i = t.result.suggestedCode,
    s = []
  for (let o of t.result.diffSpans) {
    let a = n.slice(o.original.start, o.original.stop),
      l = i.slice(o.updated.start, o.updated.stop),
      c = EditSuggestion.determineChangeType(a, l),
      u = r ? o.original : o.updated,
      f = t.result.charStart + u.start,
      p = t.result.charStart + u.stop
    c === (r ? "insertion" : "deletion") &&
      e.positionAt(f).character === 0 &&
      l.endsWith(`
`) &&
      (f = t.result.charStart + u.start - 1),
      s.push([c, new We.Range(e.positionAt(f), e.positionAt(p))])
  }
  return s
}
var IN = q(require("vscode"))
var CodeActionProvider = class {
  constructor(t, r, n) {
    this._suggestionManager = t
    this._configListener = r
    this._nextEditSessionEventReporter = n
  }
  provideCodeActions(t, r, n, i) {
    if (!this._configListener.config.enableDebugFeatures) return
    let s = new LineRange(r.start.line, r.end.line),
      o = this._suggestionManager
        .getActiveSuggestions()
        .find(
          (c) =>
            c.changeType !== "noop" && c.previewCursorRange(t).intersects(s),
        )
    if (!o) return
    let a = o.result.changeDescription || "Augment: Accept suggestion",
      l = new IN.CodeAction(a, IN.CodeActionKind.QuickFix)
    return (
      (l.command = { command: AcceptNextEditCodeActionCommand.commandID, title: a, arguments: [o] }),
      this._nextEditSessionEventReporter.reportEventFromSuggestion(
        o,
        "code-action-shown",
        "code-action",
      ),
      [l]
    )
  }
  resolveCodeAction(t, r) {
    return t
  }
}
var ti = q(require("vscode"))
var GSe = q(require("os"))
var PJt = z("markdown-html-utils")
function VSe() {
  return eo("1.92.0")
}
function LCt(e) {
  return e.replace(/\$\(([\w-]+)\)/gi, "&dollar;($1)")
}
function nC(e) {
  return LCt(bN(e))
}
var mw = class e {
  _spaces
  _tabs
  constructor({ spaces: t, tabs: r }) {
    ;(this._spaces = t), (this._tabs = r)
  }
  static computeCommonLeadingWhitespace(t) {
    if (t.length === 0) return new e({ spaces: 0, tabs: 0 })
    let n = t
        .filter((o) => o.trim().length > 0)
        .map((o) => {
          let a = o.match(/^([ \t]*)/)
          return a ? a[1] : ""
        }),
      i = n.map((o) => o.length - o.replace(/ /g, "").length),
      s = n.map((o) => o.length - o.replace(/\t/g, "").length)
    return new e({
      spaces: i.reduce((o, a) => Math.min(o, a), i[0]),
      tabs: s.reduce((o, a) => Math.min(o, a), s[0]),
    })
  }
  trimLeadingIncremental(t) {
    let r = this._spaces,
      n = this._tabs,
      i = 0
    for (; i < t.length && (r > 0 || n > 0); ) {
      let s = t[i++]
      if (s === " " && r > 0) r--
      else if (s === "	" && n > 0) n--
      else return
    }
    return { trimmed: t.slice(i), remaining: new e({ spaces: r, tabs: n }) }
  }
  trimLeadingFull(t, r) {
    let n = this.trimLeadingIncremental(t)
    return n
      ? !n.remaining.isEmpty() && t.length > 0
        ? (r?.debug("Untrimmed whitespace"), t)
        : n.trimmed
      : (r?.debug(`No common leading whitespace for line: ${t}`), t)
  }
  isEmpty() {
    return this._spaces === 0 && this._tabs === 0
  }
  total() {
    return this._spaces + this._tabs
  }
}
function $Se(e, t, r, n, i, s, o) {
  let a = OCt(e.makeOneLineDiffSpans()),
    l =
      a.filter((N) => N.type === "updated").length -
      a.filter((N) => N.type === "original").length,
    c = (e.lineRange.stop + 2 + l).toString().length + 1,
    u
  if (s) {
    let N =
        t?.split(`
`) ?? [],
      W =
        r?.split(`
`) ?? [],
      Z = [...N, ...a.map((te) => te.spans.map((Y) => Y.text).join("")), ...W]
    ;(u = mw.computeCommonLeadingWhitespace(Z)),
      (t = N.map((te) => u.trimLeadingFull(te, o)).join(`
`)),
      (r = W.map((te) => u.trimLeadingFull(te, o)).join(`
`))
  } else u = mw.computeCommonLeadingWhitespace([])
  let f = n,
    { rendered: p, longestLineLength: g } = VCt(
      a,
      f,
      i,
      e.result.truncationChar,
      u,
      o,
    )
  t && (t = yc(t, g)), r && (r = yc(r, g))
  let m = iC(e.lineRange.start, c),
    y = t
      ? `<span style="color:${i.lineNumberColor};">${m}${m}<span class="codicon codicon-blank"></span> ${nC(WSe(Aw(t), g + 1))}</span>
`
      : "",
    v = iC(e.lineRange.stop + 1, c),
    C = iC(e.lineRange.stop + 1 + l, c),
    E = "",
    w = ""
  GSe.default.platform() === "win32" && ((E = "<strong>"), (w = "</strong>"))
  let B =
      "background-color:var(--vscode-editor-background);" +
      (UCt() ? "border-radius:5px;" : ""),
    T = r
      ? `
<span style="color:${i.lineNumberColor};">${v}${C}<span class="codicon codicon-blank"></span> ${nC(WSe(Aw(r), g + 1))}</span>`
      : ""
  return {
    result: `
${E}<pre><span style="${B}">${y}${p}${T}</span></pre>${w}
`,
    longestLineLength: g + c,
  }
}
function UCt() {
  return VSe() && !eo("1.97.0")
}
function OCt(e) {
  let t = [],
    r = []
  if (e.length === 0) return []
  let n = {
      type: "noop",
      spans: [],
      originalLineNumber: -1,
      updatedLineNumber: -1,
    },
    i = {
      type: "noop",
      spans: [],
      originalLineNumber: -1,
      updatedLineNumber: -1,
    },
    s = () => {
      n.spans.some((a) => a.text.length > 0) && t.push(n)
    },
    o = () => {
      i.spans.some((a) => a.text.length > 0) && r.push(i)
    }
  for (let a of e)
    (a.original.text !== "" || !a.updated.isWholeLine) &&
      (n.spans.push({
        type: a.type,
        text: a.original.text,
        charRange: a.original.charRange,
      }),
      (n.originalLineNumber = a.original.line),
      a.type !== "noop"
        ? (n.type = "original")
        : (n.updatedLineNumber = a.updated.line)),
      (a.updated.text !== "" || !a.original.isWholeLine) &&
        (i.spans.push({
          type: a.type,
          text: a.updated.text,
          charRange: a.updated.charRange,
        }),
        (i.updatedLineNumber = a.updated.line),
        a.type !== "noop"
          ? (i.type = "updated")
          : ((i.originalLineNumber = a.original.line),
            i.type !== "noop"
              ? (n.type = "original")
              : n.type !== "noop" && (i.type = "updated"))),
      a.original.text.endsWith(`
`) &&
        (s(),
        (n = {
          type: "noop",
          spans: [],
          originalLineNumber: -1,
          updatedLineNumber: -1,
        })),
      a.updated.text.endsWith(`
`) &&
        (o(),
        (i = {
          type: "noop",
          spans: [],
          originalLineNumber: -1,
          updatedLineNumber: -1,
        }))
  return s(), o(), qCt(t, r)
}
function qCt(e, t) {
  let r = [],
    n = 0,
    i = 0,
    s = 0
  for (; i < e.length || s < t.length; ) {
    if (n++ > 1e4) throw new Error("infinite loop in groupLines")
    for (; i < e.length && e[i].type !== "noop"; ) r.push(e[i]), i++
    for (; s < t.length && t[s].type !== "noop"; ) r.push(t[s]), s++
    for (
      ;
      i < e.length &&
      s < t.length &&
      e[i].type === "noop" &&
      t[s].type === "noop";

    )
      r.push(e[i]), i++, s++
  }
  return r
}
function VCt(e, t, r, n, i, s) {
  if (e.length === 0) return { rendered: "", longestLineLength: 0 }
  let { linePadAmounts: o, longestLineLength: a } = HCt(e, t, i),
    c =
      (
        e
          .map((f) => f.updatedLineNumber)
          .concat(e.map((f) => f.originalLineNumber))
          .reduce((f, p) => Math.max(f, p), 0) + 2
      ).toString().length + 1,
    u = []
  for (let f = 0; f < e.length; f++) {
    let p = e[f],
      g,
      m
    p.type === "noop"
      ? ((g = p.spans.map((E) => E.text).join("")),
        (g = i.trimLeadingFull(g)),
        (m = "#00000000"))
      : p.type === "original"
        ? ((g = HSe(p.spans, true, r, i, s)), (m = r.originalLineColor))
        : ((g = HSe(p.spans, false, r, i, s)), (m = r.updatedLineColor)),
      (g = Aw(g))
    let y = (p.type !== "updated" ? p.originalLineNumber + 1 : "").toString(),
      v = (p.type !== "original" ? p.updatedLineNumber + 1 : "").toString(),
      C =
        p.type === "noop"
          ? '<span class="codicon codicon-blank"></span>'
          : p.type === "original"
            ? '<span class="codicon codicon-diff-remove"></span>'
            : '<span class="codicon codicon-diff-insert"></span>'
    u.push(
      `<span style="color:${r.lineNumberColor};background-color:${m};">${iC(y, c)}${iC(v, c)}</span><span style="background-color:${m};">${C} </span>${g}<span style="background-color:${m};">${" ".repeat(o[f])}</span>`,
    )
  }
  return (
    n !== undefined &&
      u.push(
        `<span style="color:${r.lineNumberColor};">${iC(" ", 2 * c + 1)}...(MORE CHANGES)...</span>`,
      ),
    {
      rendered: u.join(`
`),
      longestLineLength: a,
    }
  )
}
function HCt(e, t, r) {
  let n = e.map((s) => Aw(s.spans.map((o) => o.text).join(""))),
    i = Math.max(
      t,
      n.map((s) => s.length).reduce((s, o) => Math.max(s, o), 0) - r.total(),
    )
  return {
    linePadAmounts: n.map((s) => i - Math.max(0, s.length - r.total()) + 1),
    longestLineLength: i,
  }
}
function HSe(e, t, r, n, i) {
  let s = []
  if (e.length === 0 || e.every((o) => o.text === "")) return ""
  for (let o of e) {
    let a
    o.type === "noop"
      ? t
        ? (a = `background-color:${r.originalLineColor};`)
        : (a = `background-color:${r.updatedLineColor};`)
      : t
        ? (a = `background-color:${r.originalTextColor};`)
        : (a = `background-color:${r.updatedTextColor};`)
    let l = o.text,
      c = n.trimLeadingIncremental(o.text)
    c
      ? ((l = c.trimmed), (n = c.remaining))
      : i?.debug(`No common leading whitespace for span: ${o.text}`)
    let u = nC(l),
      f = u.endsWith(`
`)
    ;(u = Aw(u)),
      s.push(
        `<span style="${a}">${u}</span>${
          f
            ? `
`
            : ""
        }`,
      )
  }
  return n.isEmpty() || i?.debug("Untrimmed whitespace"), s.join("")
}
function iC(e, t) {
  let r = e.toString()
  return t - getTextLength(r) >= 0 ? " ".repeat(t - r.length) + r : r
}
function WSe(e, t) {
  let r = e.toString()
  return t - getTextLength(r) >= 0 ? r + " ".repeat(t - r.length) : r
}
function Aw(e) {
  return e.endsWith(`
`)
    ? e.slice(0, -1)
    : e
}
var KSe = q(require("vscode"))
function S6(e, t, r, n, i) {
  let s = "$(augment-icon-simple)&#x2009;&#x1D5D;",
    o = t.length > 0 ? YSe(t[0]) : ""
  for (let c = 1; c < t.length; c++) {
    let u = t[c].noLeftMargin ? "&nbsp;&nbsp;" : "&nbsp;&nbsp;&nbsp;&nbsp;"
    o += `${u}${YSe(t[c])}`
  }
  let a = r ? `<br/>${r}` : "",
    l = new KSe.MarkdownString(`${s}&nbsp;&nbsp;&nbsp;&nbsp;${o}<br/>${e}${a}`)
  return (l.isTrusted = true), (l.supportHtml = true), (l.supportThemeIcons = true), l
}
function YSe(e) {
  return `<a href="${e.href}" title="${e.tooltip}">${e.text}${e.keybindingIcons ? `&nbsp;${e.keybindingIcons}` : ""}</a>`
}
var WCt = 38,
  HoverProvider = class e extends DisposableContainer {
    constructor(r, n, i, s, o, a, l, c, u) {
      super()
      this._keybindingWatcher = r
      this._nextEditSessionEventReporter = n
      this._suggestionManager = i
      this._state = s
      this._configListener = o
      this._hasCompletionShowing = a
      this._showKeybindingsOnButtons = l
      this._keybindingStatus = c
      this._nextEditConfigManager = u
      this.addDisposable(
        ti.window.onDidChangeTextEditorVisibleRanges((f) => {
          this._handleVisibleRangesChanged(f)
        }),
      ),
        this._register(undefined),
        this.addDisposable(
          ti.window.onDidChangeActiveTextEditor((f) => this._register(f)),
        ),
        this.addDisposable(
          this._suggestionManager.onSuggestionsChanged((f) => {
            this._register(ti.window.activeTextEditor)
          }),
        ),
        this.addDisposable(
          new ti.Disposable(() => {
            this._provider?.dispose(), (this._provider = undefined)
          }),
        )
    }
    _logger = z("BackgroundNextEditsHoverProvider")
    static inlineDiffColors = {
      originalLineColor: "var(--vscode-diffEditor-removedLineBackground)",
      originalTextColor: "#FF000066",
      updatedLineColor: "var(--vscode-diffEditor-insertedLineBackground)",
      updatedTextColor: "#9CCC2C66",
      lineNumberColor: "var(--vscode-editorGhostText-foreground)",
    }
    _provider
    _waitingToShowHover = false
    get _showDiffInDifflessHover() {
      return this._nextEditConfigManager.config.showDiffInHover
    }
    _handleVisibleRangesChanged(r) {
      let n = r.textEditor.document,
        i = this._state.value.suggestion
      i &&
        (this._state.value instanceof BeforePreviewState ||
          this._state.value instanceof AfterPreviewState ||
          this._state.value instanceof AnimatingState) &&
        i.qualifiedPathName.equals(n.uri) &&
        r.visibleRanges.some((s) => s.contains(createRange(i.highlightRange))) &&
        this.showHover()
    }
    _register(r) {
      this._waitingToShowHover ||
        (this._provider?.dispose(),
        (this._provider = undefined),
        r &&
          (this._provider = ti.languages.registerHoverProvider(
            { pattern: r.document.uri.fsPath },
            this,
          )))
    }
    provideHover(r, n, i) {
      if (this._hoverDisabled()) return
      let s, o
      try {
        if (r.uri.scheme === "output" || this._hasCompletionShowing()) return
        ;(this._waitingToShowHover = false),
          (o = this._suggestionManager
            .getActiveSuggestions()
            .filter(
              (c) =>
                c.state === "fresh" &&
                c.changeType !== "noop" &&
                c.qualifiedPathName.equals(r.uri),
            )
            .find((c) => this.hoverContactCondition(c, n, r)))
        let l = this._provideDifflessHover(r, n, o)
        return (
          l &&
            this._nextEditSessionEventReporter.reportEventFromSuggestion(
              o,
              "hover-shown",
              "unknown",
            ),
          l && new ti.Hover(l)
        )
      } catch (a) {
        return (
          a instanceof Error &&
            (this._logger.error(
              `Error in hover provider: ${a.message}, requestId: ${s}`,
            ),
            a.stack && this._logger.error(a.stack),
            this._nextEditSessionEventReporter.reportEventFromSuggestion(
              o,
              "error-hover-error",
              "unknown",
            )),
          new ti.Hover(`Error rendering hover. requestId: ${s}`)
        )
      }
    }
    _keybindingWillWork(r, n) {
      return r === OpenNextEditPanelCommand
        ? this._nextEditConfigManager.config.enablePanel
        : n && !n.equals(this._state.value.suggestion)
          ? false
          : this._keybindingStatus.get(r)
    }
    _provideDifflessHover(r, n, i) {
      let s,
        o = []
      i =
        this._state.value instanceof NoSuggestionsState || this._state.value instanceof HintingState
          ? i
          : undefined
      let a = ["hover-click", i?.result.suggestionId ?? undefined],
        l = (y, v) => {
          if (this._keybindingWillWork(y, i)) {
            let C = this.getPrettyKeybinding(y.commandID)
            return `${v}${C ? "&nbsp;" + C : ""}`
          }
          return v
        },
        c = (y, v, C) => {
          let E = y.commandID
          return {
            href: y.generateHref(...a),
            text: v,
            tooltip: l(y, C),
            keybindingIcons:
              this._showKeybindingsOnButtons() && this._keybindingWillWork(y, i)
                ? this.getPrettyKeybindingIcons(E)
                : null,
          }
        },
        u = c(RejectNextEditCommand, "Reject", "Reject Suggestion"),
        f = c(OpenNextEditPanelCommand, "$(layout-panel)", "Open Suggestions Panel")
      f.keybindingIcons = null
      let p = c(
        ToggleHoverDiffCommand,
        "$(diff-single)",
        this._showDiffInDifflessHover ? "Hide Diff" : "Show Diff",
      )
      p.noLeftMargin = true
      let g = {
          href: `command:workbench.action.openSettings?${encodeURIComponent(JSON.stringify(["@ext:augment.vscode-augment augment.nextEdit"]))}`,
          text: "$(gear)",
          tooltip: "Open Settings",
          noLeftMargin: true,
        },
        m = c(LearnMoreNextEditCommand, "Learn More", "Learn More")
      if (
        ((((this._state.value instanceof BeforePreviewState ||
          this._state.value instanceof AfterPreviewState) &&
          this._state.value.suggestion
            ?.previewCursorRange(r)
            .contains(n.line)) ||
          i) &&
          ((s = i || this._state.value.suggestion),
          (o = [
            c(AcceptNextEditCommand, "Apply", "Apply Suggestion"),
            u,
            ...(this._showKeybindingsOnButtons() ? [m] : []),
            ...(this._nextEditConfigManager.config.enablePanel ? [f] : []),
            p,
            g,
          ])),
        this._state.value instanceof AfterPreviewState)
      ) {
        let y = this._state.value.suggestion.previewCursorRange(r)
        ;(y.contains(n.line) ||
          (this._state.value.suggestion?.changeType === "deletion" &&
            y?.touches(n.line))) &&
          ((s = this._state.value.suggestion),
          (o = [
            c(UndoAcceptSuggestionCommand, "Undo", "Undo Suggestion"),
            u,
            ...(this._showKeybindingsOnButtons() ? [m] : []),
            ...(this._nextEditConfigManager.config.enablePanel ? [f] : []),
            p,
            g,
          ]))
      }
      if (s) {
        let y = nC(s.result.changeDescription)
        if (this._showDiffInDifflessHover) {
          let { result: v, longestLineLength: C } = this.getHoverDiff(r, s, WCt)
          return S6(y, o, v, [], C)
        } else return S6(y, o)
      }
    }
    hoverContactCondition(r, n, i) {
      return r.previewCursorRange(i).contains(n.line)
    }
    getPrettyKeybinding(...r) {
      return this.getKeybindingsForCommands(r, true)
    }
    getPrettyKeybindingIcons(...r) {
      let n = jc.getStructuredKeybinding(this.getKeybindingsForCommands(r))
      return PSe(n, this._keybindingWatcher.getSimplifiedPlatform())
    }
    getKeybindingsForCommands(r, n = false) {
      let i = r.map((s) => getKeybindingLabel(this._keybindingWatcher, s, n))
      return i.includes(null) ? "" : i.join(" ")
    }
    getHoverDiff(r, n, i) {
      let s = n.state === "accepted" ? n.afterLineRange(r) : n.lineRange,
        o = s.start > 0 ? new ti.Range(s.start - 1, 0, s.start, 0) : undefined,
        a =
          s.stop < r.lineCount - 1
            ? new ti.Range(s.stop, 0, s.stop + 1, 0)
            : undefined,
        l = $Se(
          n,
          o && r.getText(o),
          a && r.getText(a),
          i,
          e.inlineDiffColors,
          true,
          this._logger,
        )
      return (
        n.result.truncationChar !== undefined &&
          this._nextEditSessionEventReporter.reportEventFromSuggestion(
            n,
            "suggestion-truncated-in-hover",
            "unknown",
          ),
        l
      )
    }
    _hoverDisabled() {
      return this._configListener.config.nextEdit.noDiffModeUseCodeLens
    }
    showHover() {
      this._hoverDisabled() ||
        (this._register(ti.window.activeTextEditor),
        (this._waitingToShowHover = true),
        ti.commands.executeCommand("editor.action.showHover", {
          focus: "noAutoFocus",
        }))
    }
    hideHover(r = "unknown") {
      this._hoverDisabled() ||
        r === "keybinding" ||
        (eo("1.97.0-insider") || eo("1.97.0")
          ? ti.commands.executeCommand("editor.action.hideHover")
          : (ti.commands.executeCommand("editorScroll", {
              to: "down",
              by: "line",
              value: 0,
            }),
            ti.commands.executeCommand("editorScroll", {
              to: "up",
              by: "line",
              value: 0,
            })))
    }
    async hideHoverAsync(r = "unknown") {
      this._hoverDisabled() ||
        r === "keybinding" ||
        (eo("1.97.0-insider") || eo("1.97.0")
          ? await ti.commands.executeCommand("editor.action.hideHover")
          : (await ti.commands.executeCommand("editorScroll", {
              to: "down",
              by: "line",
              value: 0,
            }),
            await ti.commands.executeCommand("editorScroll", {
              to: "up",
              by: "line",
              value: 0,
            })))
    }
  }
var zSe = q(require("vscode"))
var GCt = new Map([
    [NextEditNavigateCommand, "vscode-augment.nextEdit.canNextSmart"],
    [NextEditForwardCommand, "vscode-augment.nextEdit.canNext"],
    [NextEditPreviousCommand, "vscode-augment.nextEdit.canPrevious"],
    [AcceptNextEditCommand, "vscode-augment.nextEdit.canAccept"],
    [RejectNextEditCommand, "vscode-augment.nextEdit.canReject"],
    [DismissNextEditCommand, "vscode-augment.nextEdit.canDismiss"],
    [AcceptNextEditCodeActionCommand, "vscode-augment.nextEdit.canAcceptCodeAction"],
    [AcceptAllNextEditCommand, "vscode-augment.nextEdit.canAcceptAll"],
    [RejectAllNextEditCommand, "vscode-augment.nextEdit.canRejectAll"],
    [UndoAcceptSuggestionCommand, "vscode-augment.nextEdit.canUndoAcceptSuggestion"],
  ]),
  RN = class extends DisposableContainer {
    constructor(r) {
      super()
      this._state = r
      this.addDisposable(
        new zSe.Disposable(
          this._state.listen((n) => {
            // fetch('http://localhost:3000', {
            //   method: 'POST',
            //   body: JSON.stringify({
            //     callMethod: 'nextEditStream',
            //     prev: 'triggered by set hintState'
            //   })
            // });
            let i = !(n instanceof NoSuggestionsState)
            this._set(NextEditNavigateCommand, i),
              this._set(NextEditForwardCommand, i),
              this._set(NextEditPreviousCommand, i),
              this._set(
                AcceptNextEditCommand,
                n instanceof BeforePreviewState || n instanceof AnimatingState || n instanceof AfterPreviewState,
              ),
              this._set(
                RejectNextEditCommand,
                n instanceof BeforePreviewState || n instanceof AnimatingState || n instanceof AfterPreviewState,
              ),
              this._set(UndoAcceptSuggestionCommand, n instanceof AfterPreviewState),
              this._set(DismissNextEditCommand, i),
              this._set(AcceptNextEditCodeActionCommand, n instanceof AfterPreviewState),
              this._set(AcceptAllNextEditCommand, i),
              this._set(RejectAllNextEditCommand, i)
          }, true),
        ),
      )
    }
    _status = new Map()
    get(r) {
      return this._status.get(r) ?? false
    }
    _set(r, n) {
      this._status.set(r, n)
      let i = GCt.get(r)
      i && setVSCodeContext(i, n)
    }
  }
var EditorNextEdit = class EditorNextEdit extends DisposableContainer {
  constructor(editor, workspaceManager, sessionEventReporter, documentManager, configListener, suggestionManager, requestManager, globalState, configManager, completionVisibilityWatcher, onCursorWithinSuggestion = (suggestion) => {}) {
    super()
    this.workspaceManager = workspaceManager
    this._nextEditSessionEventReporter = sessionEventReporter
    this._configListener = configListener
    this._suggestionManager = suggestionManager
    this._requestManager = requestManager
    this._globalState = globalState
    this._nextEditConfigManager = configManager
    this._completionVisibilityWatcher = completionVisibilityWatcher
    this._onCursorWithinSuggestion = onCursorWithinSuggestion
    ;(this._state = new Observable(new NoSuggestionsState(), DSe)),
      (this._decorationManager = new DecorationManager(
        editor,
        workspaceManager,
        documentManager,
        configListener,
        sessionEventReporter,
        this.isInlineCompletionVisible,
        this.isShowAllHighlightsEnabled,
      )),
      this.addDisposable(this._decorationManager),
      (this._codeActionProvider = new CodeActionProvider(
        this._suggestionManager,
        this._configListener,
        sessionEventReporter,
      )),
      (this._keybindingStatus = this.addDisposable(new RN(this._state))),
      (this._hoverProvider = new HoverProvider(
        documentManager,
        sessionEventReporter,
        this._suggestionManager,
        this._state,
        this._configListener,
        this.isInlineCompletionVisible,
        () =>
          (this._globalState.get("nextEditKeybindingUsageCount") ?? 0) <
          EditorNextEdit.maxKeybindingUsageCount,
        this._keybindingStatus,
        this._nextEditConfigManager,
      )),
      this.addDisposable(this._hoverProvider),
      (this._codeLensProvider = new CodeLensProvider(this._state, documentManager)),
      this.addDisposable(
        new Se.Disposable(() => {
          ;(this._state.value = new NoSuggestionsState()),
            this._state.dispose(),
            this._decorationManager.decorate([], {}),
            this._hoverProvider.hideHover("command")
        }),
      ),
      this.addDisposable(
        Se.languages.registerCodeActionsProvider("*", this._codeActionProvider),
      ),
      this.addDisposable(
        Se.workspace.onDidChangeTextDocument(this._handleTextDocumentChanged),
      ),
      this.addDisposable(
        Se.window.onDidChangeActiveTextEditor(this._handleEditorChange),
      ),
      this.addDisposable(
        Se.window.onDidChangeTextEditorSelection(
          this._handleTextEditorSelectionChanged,
        ),
      ),
      this.addDisposable(
        new Se.Disposable(
          this._requestManager.lastResponse.listen((response) => {
            response && this._suggestionManager.add([EditSuggestion.from(response)], response.mode === "FORCED")
          }),
        ),
      ),
      this.addDisposable(
        this._suggestionManager.onSuggestionsChanged((event) => {
          this._handleSuggestionsChanged(event)
        }),
      ),
      this.addDisposable(
        Se.window.onDidChangeTextEditorVisibleRanges((event) => {
          this.workspaceManager.safeResolvePathName(
            event.textEditor.document.uri,
          ) &&
            event.textEditor === Se.window.activeTextEditor &&
            !isDiffEditor() &&
            (!this._lastVisibleRanges ||
              this._lastVisibleRanges.uri.fsPath !==
                event.textEditor.document.uri.fsPath ||
              this._lastVisibleRanges.visibleRanges.length !==
                event.visibleRanges.length ||
              this._lastVisibleRanges.visibleRanges.some(
                (range, index) => !range.equals(rangeToLineRange(event.visibleRanges[index])),
              )) &&
            (this._drawDecorations(),
            this._configListener.config.nextEdit.useCursorDecorations ||
              ((this._decorationManager.shouldDrawBottomDecorations.value = false),
              this._debouncedSetBottomDecorations()),
            (this._lastVisibleRanges = {
              uri: event.textEditor.document.uri,
              visibleRanges: event.visibleRanges.map((range) => rangeToLineRange(range)),
            }))
        }),
      ),
      this.addDisposable(
        new Se.Disposable(
          this._suggestionManager.suggestionWasJustAccepted.listen((accepted) => {
            accepted &&
              (this._debouncedSetBottomDecorations.flush(),
              this._drawDecorations())
          }),
        ),
      ),
      this._configListener.addDisposable(
        this._configListener.onDidChange((change) => {
          !!change.newConfig.nextEdit.highlightSuggestionsInTheEditor !=
            !!change.previousConfig.nextEdit.highlightSuggestionsInTheEditor &&
            this._drawDecorations()
        }),
      ),
      this.addDisposable(
        this.workspaceManager.onDidChangeSourceFolderContents((rootPath) => {
          let fileExistsCache = new Map(), // =
            suggestionsToRemove = this._suggestionManager.getAllSuggestions().filter((suggestion) => {
              if (suggestion.qualifiedPathName.rootPath !== rootPath) return false
              let relPath = suggestion.qualifiedPathName.relPath
              return (
                fileExistsCache.get(relPath) ||
                  fileExistsCache.set(relPath, this.workspaceManager.hasFile(suggestion.qualifiedPathName)),
                !fileExistsCache.get(relPath)
              )
            })
          this._suggestionManager.remove(suggestionsToRemove)
        }),
      ),
      this.addDisposable(
        new Se.Disposable(
          this._completionVisibilityWatcher.listen(() => {
            this._drawDecorations()
          }),
        ),
      ),
      this._configListener.config.nextEdit.noDiffModeUseCodeLens &&
        (this.addDisposable(
          Se.languages.registerCodeLensProvider("*", this._codeLensProvider),
        ),
        this.addDisposable(
          new Se.Disposable(
            this._state.listen(() => {
              this._codeLensProvider.refresh()
            }),
          ),
        )),
      this.addDisposable(
        new Se.Disposable(
          this._state.listen(() => {
            // fetch('http://localhost:3000', {
            //   method: 'POST',
            //   body: JSON.stringify({
            //     callMethod: 'EditorNextEdit._state.listen',
            //     prev: 'triggered by hintState'
            //   })
            // });
            this._drawDecorations()
          }),
        ),
      ),
      this.addDisposable(
        new Se.Disposable(
          this._state.listen((state) => {
            let eventName
            state instanceof NoSuggestionsState
              ? (eventName = "state-transitioned-to-no-suggestions")
              : state instanceof HintingState
                ? (eventName = "state-transitioned-to-hinting")
                : state instanceof BeforePreviewState
                  ? (eventName = "state-transitioned-to-before-preview")
                  : state instanceof AfterPreviewState
                    ? (eventName = "state-transitioned-to-after-preview")
                    : state instanceof AnimatingState &&
                      (eventName = "state-transitioned-to-animating"),
              eventName !== undefined &&
                this._nextEditSessionEventReporter.reportEventFromSuggestion(
                  state.suggestion,
                  eventName,
                  "unknown",
                )
          }),
        ),
      ),
      this.addDisposable(
        Se.debug.onDidStartDebugSession(() => {
          this._suggestionManager.clear(false),
            this._decorationManager.decorate([], {})
        }),
      ),
      this.addDisposable(
        Se.debug.onDidTerminateDebugSession(() => {
          this._handleEditorChange(Se.window.activeTextEditor)
        }),
      ),
      this.addDisposable(
        Km(() => {
          this._suggestionManager.clear(false),
            this._decorationManager.decorate([], {})
        }),
      ),
      this.addDisposable(
        yN(() => {
          this._suggestionManager.clear(false),
            this._decorationManager.decorate([], {})
        }),
      )
  }
  static _waitForAcceptTimeoutMs = 1e3
  static _applySuggestionDelayMs = {
    fromHover: 50,
    atCursor: 250,
    onScreen: 500,
    offScreen: 750,
    largeBonus: 250,
  }
  static _largeChangeLineCountThreshold = 3
  static _postScrollRenderDelayMs = 250
  static maxKeybindingUsageCount = 30
  _logger = z("EditorNextEdits")
  _decorationManager
  _codeActionProvider
  _keybindingStatus
  _hoverProvider
  _codeLensProvider
  _state
  _lastVisibleRanges
  _ignoreSelectionChangeEvents = false
  _debouncedSetBottomDecorations = (0, ZSe.debounce)(() => {
    ;(this._decorationManager.shouldDrawBottomDecorations.value = true),
      this._drawDecorations()
  }, EditorNextEdit._postScrollRenderDelayMs)
  static get _smoothScrollDelayMs() {
    return (Se.workspace.getConfiguration("editor").smoothScrolling ?? false)
      ? 150
      : 0
  }
  dismiss(source, hideHover = false, clearJustAccepted = true) {
    this._state.value instanceof BeforePreviewState || this._state.value instanceof AnimatingState
      ? ((this._state.value = new HintingState(this._state.value.suggestion, true)),
        clearJustAccepted && this._suggestionManager.clearJustAcceptedSuggestions(),
        this._nextEditSessionEventReporter.reportEventWithoutIds(
          "preview-decoration-dismissed",
          source ?? "command",
        ))
      : this._state.value instanceof AfterPreviewState &&
        ((this._state.value = this._getHintedState()),
        clearJustAccepted && this._suggestionManager.clearJustAcceptedSuggestions(),
        this._nextEditSessionEventReporter.reportEventWithoutIds(
          "reverse-decoration-dismissed",
          source ?? "command",
        )),
      hideHover && this._hoverProvider.hideHover()
  }
  async dismissOrReject(source) {
    let editor = Se.window.activeTextEditor
    this._state.value instanceof AfterPreviewState
      ? (await this._undoSuggestions(this._state.value.suggestion),
        this.dismiss(source, true))
      : this._state.value instanceof BeforePreviewState || this._state.value instanceof AnimatingState
        ? this.dismiss(source)
        : editor &&
            this._state.value instanceof HintingState &&
            this._hoverProvider.hoverContactCondition(
              this._state.value.suggestion,
              editor.selection.active,
              editor.document,
            )
          ? this.reject(source, this._state.value.suggestion.result.suggestionId)
          : this.reject(source)
  }
  isInlineCompletionVisible = () =>
    this._completionVisibilityWatcher.maybeInlineCompletionVisible
  isShowAllHighlightsEnabled = () =>
    this._configListener.config.nextEdit.highlightSuggestionsInTheEditor
  nextAvailableSuggestion = (preferVisible = true, preferCursor = false) =>
    jSe(
      this._suggestionManager.getActiveSuggestions().filter(isFreshNonNoopSuggestion),
      this._state.value instanceof BeforePreviewState ||
        this._state.value instanceof AfterPreviewState ||
        this._state.value instanceof AnimatingState
        ? this._state.value.suggestion
        : undefined,
      !preferVisible,
      preferCursor,
      this._configListener.config.nextEdit.enableGlobalBackgroundSuggestions,
    )
  _handleSuggestionsChanged = async (event) => {
    fetch('http://localhost:3000', {
      method: 'POST',
      body: JSON.stringify({
        callMethod: 'EditorNextEdit:_handleSuggestionsChanged',
        event,
      })
    });
    this._updateSuggestions(event.newSuggestions, true)
    let editor = Se.window.activeTextEditor,
      undoneAtCursor =
        editor &&
        event.undone.find(
          (suggestion) =>
            suggestion.lineRange.contains(editor.selection.active.line) ||
          suggestion.lineRange.touches(editor.selection.active.line),
        )
    if (undoneAtCursor && this._state.value instanceof AfterPreviewState) {
      await this._suggestionManager.suggestionWasJustUndone.waitUntil(
        (undone) => undone === true,
        EditorNextEdit._waitForAcceptTimeoutMs,
      )
      let selection = this._getSuggestionSelection(undoneAtCursor)
      selection.isEqual(editor.selection) ||
        ((this._ignoreSelectionChangeEvents = true), (editor.selection = selection)),
        (this._state.value = new BeforePreviewState(undoneAtCursor)),
        this._nextEditSessionEventReporter.reportEventFromSuggestion(
          this._state.value.suggestion,
          "undid-accepted-suggestion",
          "document-changed",
        ),
        this._hoverProvider.showHover()
    }
    if (
      editor &&
      event.accepted.length > 0 &&
      (this._state.value instanceof BeforePreviewState || this._state.value instanceof AnimatingState)
    ) {
      await this._suggestionManager.suggestionWasJustAccepted.waitUntil(
        (accepted) => accepted === true,
        EditorNextEdit._waitForAcceptTimeoutMs,
      )
      let acceptedSuggestion = event.accepted[event.accepted.length - 1],
        selection = this._getSuggestionSelection(acceptedSuggestion)
      selection.isEqual(editor.selection) ||
        ((this._ignoreSelectionChangeEvents = true), (editor.selection = selection)),
        (this._state.value = new AfterPreviewState(acceptedSuggestion)),
        this._hoverProvider.showHover()
    } else event.accepted.length > 0 && (this._ignoreSelectionChangeEvents = true)
  }
  _updateSuggestions(suggestions, shouldUpdateState) {
    if (isDiffEditor()) return
    let activeSuggestions = suggestions.filter(isFreshNonNoopSuggestion)
    if (
      (this._configListener.config.nextEdit.enableGlobalBackgroundSuggestions
        ? activeSuggestions
        : activeSuggestions.filter((suggestion) =>
            suggestion.qualifiedPathName.equals(
              Se.window.activeTextEditor?.document.uri,
            ),
          )
      ).length === 0 &&
      this._state.value instanceof HintingState
    ) {
      ;(this._state.value = new NoSuggestionsState()), this._onCursorWithinSuggestion(undefined)
      return
    }
    shouldUpdateState &&
      (this._state.value instanceof NoSuggestionsState || this._state.value instanceof HintingState) &&
      (this._state.value = this._getHintedState()),
      this._drawDecorations()
  }
  get _isDebugging() {
    return (
      Se.debug.activeDebugSession !== undefined &&
      !this._configListener.config.nextEdit.allowDuringDebugging
    )
  }
  _drawDecorations() {
    if (this._isDebugging) {
      this._decorationManager.decorate([], {})
      return
    }
    let activeSuggestions = this._suggestionManager.getActiveSuggestions().filter(isFreshNonNoopSuggestion),
      acceptedSuggestions = this._suggestionManager.getJustAcceptedSuggestions(),
      hintingState =
        this._state.value instanceof HintingState
          ? this._state.value
          : this._getHintedState()
    fetch('http://localhost:3000', {
      method: 'POST',
      body: JSON.stringify({
        callMethod: 'EditorNextEdit:_drawDecorations',
        activeSuggestions,
        acceptedSuggestions,
      })
    });
    this._decorationManager.decorate(activeSuggestions.concat(acceptedSuggestions), {
      hintSuggestion: hintingState instanceof HintingState ? hintingState.hintedSuggestion : undefined,
      activeSuggestion:
        this._state.value instanceof BeforePreviewState ||
        this._state.value instanceof AfterPreviewState ||
        this._state.value instanceof AnimatingState
          ? this._state.value.suggestion
          : undefined,
      isAnimating: this._state.value instanceof AnimatingState,
    })
  }
  _handleTextDocumentChanged = (event) => {
    if (event.contentChanges.length === 0) return
    let pathName = this.workspaceManager.safeResolvePathName(event.document.uri)
    if (this._isDebugging || isNotebookCell(event.document.uri) || !pathName) return
    let editor = Se.window.activeTextEditor
    !editor ||
      event.document !== editor.document ||
      (this._clearAnimatedApply(),
      (this._state.value instanceof AfterPreviewState || this._state.value instanceof AnimatingState) &&
        ((this._state.value = new NoSuggestionsState()),
        this._nextEditSessionEventReporter.reportEventWithoutIds(
          "reverse-decoration-dismissed",
          "document-changed",
        )))
  }
  _handleTextEditorSelectionChanged = (event) => {
    let editor = Se.window.activeTextEditor
    if (
      !editor ||
      event.textEditor.document !== editor.document ||
      isDiffEditor() ||
      this._isDebugging ||
      isNotebookCell(editor.document.uri) ||
      !this.workspaceManager.safeResolvePathName(event.textEditor.document.uri)
    )
      return
    this._clearAnimatedApply(editor.selection)
    let isIgnoredSelectionChange =
      !(
        event.kind === Se.TextEditorSelectionChangeKind.Keyboard ||
        event.kind === Se.TextEditorSelectionChangeKind.Mouse
      ) && this._ignoreSelectionChangeEvents
    ;(this._ignoreSelectionChangeEvents = false),
      (this._state.value instanceof BeforePreviewState ||
        this._state.value instanceof AnimatingState ||
        this._state.value instanceof AfterPreviewState) &&
      !isIgnoredSelectionChange
        ? this.dismiss("editor-selection-changed")
        : isIgnoredSelectionChange || this._suggestionManager.clearJustAcceptedSuggestions(),
      (this._state.value instanceof NoSuggestionsState ||
        this._state.value instanceof HintingState ||
        (this._state.value instanceof AnimatingState &&
          !this._getSuggestionSelection(this._state.value.suggestion).isEqual(
            editor.selection,
          ))) &&
        (this._state.value = this._getHintedState()),
      this._drawDecorations()
    let currentSuggestion = this._state.value.suggestion
    if (
      currentSuggestion &&
      editor.selection.isEmpty &&
      this._hoverProvider.hoverContactCondition(
        currentSuggestion,
        editor.selection.active,
        editor.document,
      )
    ) {
      let selectionSource = "unknown"
      event.kind === Se.TextEditorSelectionChangeKind.Keyboard
        ? (selectionSource = "keyboard")
        : event.kind === Se.TextEditorSelectionChangeKind.Mouse
          ? (selectionSource = "click")
          : event.kind === Se.TextEditorSelectionChangeKind.Command &&
            (selectionSource = "command"),
        this._nextEditSessionEventReporter.reportEventFromSuggestion(
          currentSuggestion,
          "cursor-inside-suggestion",
          selectionSource,
        ),
        this._onCursorWithinSuggestion(currentSuggestion)
    } else this._onCursorWithinSuggestion(undefined)
  }
  _handleEditorChange = (editor) => {
    this.dismiss("active-editor-changed"),
      editor &&
        this._updateSuggestions(
          this._suggestionManager.getActiveSuggestions(),
          false,
        )
  }
  async accept(eventSource, shouldHideHover = true, suggestionId, preserveFocus) {
    let suggestion
    if (suggestionId) {
      if (((suggestion = this._suggestionManager.findSuggestionById(suggestionId)), suggestion))
        return (
          this._hoverProvider.hideHover(),
          await this.open(suggestion, {
            shouldAutoApply: true,
            animationDelayMs: EditorNextEdit._applySuggestionDelayMs.fromHover,
            preserveFocus: preserveFocus,
            eventSource: eventSource,
          }),
          true
        )
    } else
      (this._state.value instanceof BeforePreviewState ||
        this._state.value instanceof AnimatingState ||
        this._state.value instanceof AfterPreviewState) &&
        (suggestion = this._state.value.suggestion)
    return this.acceptSuggestion(suggestion, eventSource, shouldHideHover, preserveFocus)
  }
  async acceptSuggestion(suggestion, eventSource, shouldHideHover = true, preserveFocus = false) {
    if (!suggestion)
      return (
        Se.window.showInformationMessage("No Next Edit to accept."),
        this._nextEditSessionEventReporter.reportEventWithoutIds(
          "error-no-suggestion-to-accept",
          eventSource ?? "command",
        ),
        false
      )
    if (
      this._state.value instanceof AfterPreviewState &&
      this._state.value.suggestion?.equals(suggestion)
    )
      return this.dismiss(eventSource), false
    if (
      (shouldHideHover && this._hoverProvider.hideHover(eventSource ?? "command"),
      await this.gotoSuggestion(suggestion, undefined, preserveFocus),
      Se.window.activeTextEditor &&
        !suggestion.qualifiedPathName.equals(Se.window.activeTextEditor.document.uri))
    )
      return (
        this._logger.debug(
          `Current suggestion ${suggestion.qualifiedPathName.relPath} does not match active document ${Se.window.activeTextEditor?.document.uri.toString()}`,
        ),
        this._nextEditSessionEventReporter.reportEventFromSuggestion(
          suggestion,
          "error-accept-suggestion-wrong-document",
          eventSource ?? "command",
        ),
        false
      )
    this._nextEditSessionEventReporter.reportEventFromSuggestion(
      suggestion,
      "accept",
      eventSource ?? "command",
    ),
      this._state.value instanceof BeforePreviewState || (this._state.value = new BeforePreviewState(suggestion)),
      JSe(),
      this._suggestionManager.accept([suggestion])
    try {
      await this._suggestionManager.suggestionWasJustAccepted.waitUntil(
        (accepted) => accepted === true,
        EditorNextEdit._waitForAcceptTimeoutMs,
      )
    } catch {
      return (
        this._logger.debug("Error waiting for suggestion to be accepted."), false
      )
    }
    return this.incrementKeybindingUsageCount(eventSource), true
  }
  _acceptSuggestions(suggestions, eventSource) {
    if (suggestions.length === 0) {
      Se.window.showInformationMessage("No Next Edits to accept.")
      return
    }
    ;(this._state.value = new NoSuggestionsState()),
      JSe(),
      this._hoverProvider.hideHover("command")
    for (let suggestion of suggestions)
      this._nextEditSessionEventReporter.reportEventFromSuggestion(
        suggestion,
        "accept",
        eventSource ?? "command",
      )
    this._suggestionManager.accept(suggestions)
  }
  acceptAllSuggestionsInFile(uri, eventSource) {
    let filePath = getFullPath(uri),
      suggestionsInFile = this._suggestionManager
        .getActiveSuggestions()
        .filter(isFreshNonNoopSuggestion)
        .filter((o) => filePath === o.qualifiedPathName.absPath)
    this._acceptSuggestions(suggestionsInFile, eventSource),
      this._nextEditSessionEventReporter.reportEventWithoutIds(
        "accept-all-in-file",
        eventSource ?? "command",
      )
  }
  acceptAllSuggestions(eventSource) {
    let allSuggestions = this._suggestionManager.getActiveSuggestions().filter(isFreshNonNoopSuggestion)
    this._acceptSuggestions(allSuggestions, eventSource),
      this._nextEditSessionEventReporter.reportEventWithoutIds(
        "accept-all",
        eventSource ?? "command",
      )
  }
  reject(eventSource, suggestionId) {
    let suggestion
    return (
      suggestionId
        ? (suggestion = this._suggestionManager.findSuggestionById(suggestionId))
        : (this._state.value instanceof BeforePreviewState ||
            this._state.value instanceof AfterPreviewState ||
            this._state.value instanceof AnimatingState) &&
          (suggestion = this._state.value.suggestion),
      this.rejectSuggestion(suggestion, eventSource)
    )
  }
  rejectSuggestion(suggestion, eventSource) {
    this._hoverProvider.hideHover(eventSource ?? "command"),
      suggestion &&
        Se.window.activeTextEditor &&
        !suggestion.qualifiedPathName.equals(Se.window.activeTextEditor.document.uri) &&
        this._logger.debug(
          `Current suggestion ${suggestion.qualifiedPathName.relPath} does not match active document ${Se.window.activeTextEditor?.document.uri.toString()}`,
        )
    let previousState = this._state.value
    this._state.value instanceof AnimatingState
      ? (this._clearAnimatedApply(), (this._state.value = new NoSuggestionsState()))
      : (this._state.value = new NoSuggestionsState())
    let suggestionsToReject,
      eventName,
      wasAccepted = false
    suggestion
      ? ((suggestionsToReject = [suggestion]),
        this._suggestionManager.reject(suggestionsToReject),
        (eventName = "reject"),
        (wasAccepted = suggestion.state === "accepted"))
      : ((suggestionsToReject = this._suggestionManager.getActiveSuggestions().filter(isFreshNonNoopSuggestion)),
        this._suggestionManager.reject(suggestionsToReject),
        (eventName = "reject-all")),
      this._drawDecorations(),
      this._requestManager?.clearCompletedRequests("FORCED")
    for (let rejectedSuggestion of suggestionsToReject)
      this._nextEditSessionEventReporter.reportEventFromSuggestion(
        rejectedSuggestion,
        eventName,
        eventSource ?? "command",
      )
    previousState instanceof AfterPreviewState
      ? this._undoSuggestions(previousState.suggestion)
      : suggestion && wasAccepted && this._undoSuggestions(suggestion)
  }
  _rejectSuggestions(suggestions, eventSource) {
    if (
      (this._nextEditSessionEventReporter.reportEventWithoutIds(
        "reject-all",
        eventSource ?? "command",
      ),
      this._suggestionManager.reject(suggestions),
      suggestions.length === 0)
    ) {
      Se.window.showInformationMessage("No Next Edits to reject.")
      return
    }
    ;(this._state.value = new NoSuggestionsState()),
      this._hoverProvider.hideHover("command"),
      this._suggestionManager.reject(suggestions),
      this._requestManager?.clearCompletedRequests("FORCED")
    for (let suggestion of suggestions)
      this._nextEditSessionEventReporter.reportEventFromSuggestion(
        suggestion,
        "reject",
        eventSource ?? "command",
      )
  }
  rejectAllSuggestionsInFile(uri, eventSource) {
    let filePath = getFullPath(uri),
      acceptedSuggestionsInFile = this._suggestionManager
        .getJustAcceptedSuggestions()
        .filter((a) => filePath === a.qualifiedPathName.absPath),
      allSuggestionsInFile = this._suggestionManager
        .getActiveSuggestions()
        .filter(isFreshNonNoopSuggestion)
        .filter((a) => filePath === a.qualifiedPathName.absPath)
        .concat(acceptedSuggestionsInFile)
    this._rejectSuggestions(allSuggestionsInFile, eventSource),
      this._undoSuggestions(acceptedSuggestionsInFile),
      this._nextEditSessionEventReporter.reportEventWithoutIds(
        "reject-all-in-file",
        eventSource ?? "command",
      )
  }
  rejectAllSuggestions(eventSource) {
    let acceptedSuggestions = this._suggestionManager.getJustAcceptedSuggestions(),
      allSuggestions = this._suggestionManager.getActiveSuggestions().filter(isFreshNonNoopSuggestion).concat(acceptedSuggestions)
    this._rejectSuggestions(allSuggestions, eventSource),
      this._undoSuggestions(acceptedSuggestions),
      this._nextEditSessionEventReporter.reportEventWithoutIds(
        "reject-all",
        eventSource ?? "command",
      )
  }
  _undoSuggestions(suggestions) {
    Array.isArray(suggestions) || (suggestions = [suggestions])
    let workspaceEdit = new Se.WorkspaceEdit()
    for (let suggestion of suggestions)
      workspaceEdit.replace(
        Se.Uri.from({ scheme: suggestion.uriScheme, path: suggestion.qualifiedPathName.absPath }),
        new Se.Range(
          new Se.Position(suggestion.afterLineRange().start, 0),
          new Se.Position(suggestion.afterLineRange().stop, 0),
        ),
        suggestion.result.existingCode,
      )
    return Se.workspace.applyEdit(workspaceEdit)
  }
  gotoNextSmart(eventSource) {
    this.incrementKeybindingUsageCount(eventSource)
    let hintedSuggestion = this._getHintedState().suggestion
    if (this._state.value instanceof NoSuggestionsState) {
      Se.window.showInformationMessage("No more suggestions right now."),
        this._hoverProvider.hideHover(eventSource ?? "command")
      return
    } else {
      if (this._state.value instanceof AfterPreviewState && !hintedSuggestion) return this.dismiss(eventSource)
      if (this._state.value instanceof AnimatingState)
        return this._clearAnimatedApply(), this.accept()
      if (hintedSuggestion)
        return (
          this._nextEditSessionEventReporter.reportEventFromSuggestion(
            this._state.value instanceof BeforePreviewState || this._state.value instanceof AfterPreviewState
              ? this._state.value.suggestion
              : undefined,
            "goto-hinting-triggered-from",
            eventSource ?? "command",
          ),
          this._nextEditSessionEventReporter.reportEventFromSuggestion(
            hintedSuggestion,
            "goto-hinting-triggered-to",
            eventSource ?? "command",
          ),
          this.open(hintedSuggestion, { eventSource: eventSource })
        )
      this._logger.debug("Could not goto hinting.")
    }
  }
  next(eventSource) {
    return this._nextOrPrevious(true, eventSource)
  }
  previous(eventSource) {
    return this._nextOrPrevious(false, eventSource)
  }
  _nextOrPrevious(isNext, eventSource, showMessage = true) {
    let activeSuggestions = this._suggestionManager.getActiveSuggestions().filter(isFreshNonNoopSuggestion),
      nextSuggestion = jSe(
        activeSuggestions,
        this._state.value instanceof BeforePreviewState ||
          this._state.value instanceof AfterPreviewState ||
          this._state.value instanceof AnimatingState
          ? this._state.value.suggestion
          : undefined,
        !isNext,
        false,
        this._configListener.config.nextEdit.enableGlobalBackgroundSuggestions,
      )
    if (
      (this._nextEditSessionEventReporter.reportEventFromSuggestion(
        this._state.value instanceof BeforePreviewState || this._state.value instanceof AfterPreviewState
          ? this._state.value.suggestion
          : undefined,
        isNext ? "next-triggered-from" : "previous-triggered-from",
        eventSource ?? "command",
      ),
      this._nextEditSessionEventReporter.reportEventFromSuggestion(
        nextSuggestion,
        isNext ? "next-triggered-to" : "previous-triggered-to",
        eventSource ?? "command",
      ),
      !nextSuggestion)
    ) {
      showMessage && Se.window.showInformationMessage("No more suggestions right now."),
        this._hoverProvider.hideHover(eventSource ?? "command")
      return
    }
    return (
      (this._decorationManager.shouldDrawBottomDecorations.value = false),
      this._debouncedSetBottomDecorations(),
      this._state.value instanceof AnimatingState
        ? (this._logger.debug(
            "Finishing animation instead of opening suggestion.",
          ),
          this._clearAnimatedApply(),
          this.accept())
        : (this.incrementKeybindingUsageCount(eventSource),
          this.open(nextSuggestion, { eventSource: eventSource }))
    )
  }
  undoAcceptSuggestion(suggestion, eventSource) {
    ;(suggestion ??=
      this._state.value instanceof AfterPreviewState ? this._state.value.suggestion : undefined),
      suggestion && suggestion.state === "accepted"
        ? this._undoSuggestions(suggestion)
        : Se.commands.executeCommand("undo"),
      this._hoverProvider.hideHover(eventSource ?? "command"),
      this._nextEditSessionEventReporter.reportEventWithoutIds(
        "undo-accept",
        eventSource ?? "command",
      )
  }
  undoAllSuggestionsInFile(uri, eventSource) {
    let filePath = getFullPath(uri),
      acceptedSuggestionsInFile = this._suggestionManager
        .getActiveSuggestions()
        .filter(isSuggestionAccepted)
        .filter((o) => filePath === o.qualifiedPathName.absPath)
    if (acceptedSuggestionsInFile.length === 0) {
      Se.window.showInformationMessage("No Next Edits to undo.")
      return
    }
    this._nextEditSessionEventReporter.reportEventWithoutIds(
      "undo-all-in-file",
      eventSource ?? "command",
    ),
      this._undoSuggestions(acceptedSuggestionsInFile),
      this._hoverProvider.hideHover(eventSource ?? "command")
  }
  async toggleHoverDiff(eventSource, suggestionId) {
    if (
      (await this._nextEditConfigManager.toggleSetting("showDiffInHover"), suggestionId)
    ) {
      let suggestion = this._suggestionManager.findSuggestionById(suggestionId),
        activeEditor = Se.window.activeTextEditor
      if (suggestion && activeEditor) {
        this._hoverProvider.hideHover(eventSource ?? "command")
        let currentSelection = activeEditor.selection,
          suggestionSelection = this._getSuggestionSelection(suggestion)
        ;(!this._hoverProvider.hoverContactCondition(
          suggestion,
          activeEditor.selection.active,
          activeEditor.document,
        ) ||
          !activeEditor.selection.isEqual(suggestionSelection)) &&
          ((this._ignoreSelectionChangeEvents = true), (activeEditor.selection = suggestionSelection)),
          this._hoverProvider.showHover(),
          (activeEditor.selection = currentSelection)
      }
    } else
      this._hoverProvider.hideHover(eventSource ?? "command"),
        this._hoverProvider.showHover()
  }
  _clearAnimatedApply(selection) {
    this._state.value instanceof AnimatingState &&
      (!selection || !selection.isEqual(this._state.value.selection)) &&
      clearTimeout(this._state.value.timeout)
  }
  async gotoSuggestion(suggestion, animationDelayMs = undefined, preserveFocus = false) {
    this._completionVisibilityWatcher.maybeInlineCompletionVisible &&
      (this._logger.debug(
        "Clearing inline completion before opening next edit suggestion.",
      ),
      await Se.commands.executeCommand("editor.action.inlineSuggest.hide"))
    let isGlobalSuggestion = false
    if (suggestion.qualifiedPathName.equals(Se.window.activeTextEditor?.document.uri))
      preserveFocus ||
        (await Se.commands.executeCommand(
          "workbench.action.focusActiveEditorGroup",
        ))
    else {
      ;(isGlobalSuggestion = true),
        this._nextEditSessionEventReporter.reportEventFromSuggestion(
          suggestion,
          "suggestion-global-offset-text-triggered",
          "command",
        )
      let visibleEditor = Se.window.visibleTextEditors.find((editor) =>
        suggestion.qualifiedPathName.equals(editor.document.uri),
      )
      if (visibleEditor)
        await Se.window.showTextDocument(visibleEditor.document, {
          selection: this._getSuggestionSelection(suggestion),
          preserveFocus: preserveFocus,
        })
      else {
        if (!fileExists(suggestion.qualifiedPathName.absPath)) {
          Se.window.showInformationMessage(
            `Suggestion for ${suggestion.qualifiedPathName.relPath} is no longer relevant.`,
          ),
            this._suggestionManager.remove(
              this._suggestionManager
                .getActiveSuggestions()
                .filter((suggestion) => suggestion.qualifiedPathName.equals(suggestion.qualifiedPathName)),
            )
          return
        }
        await Se.window.showTextDocument(
          Se.Uri.file(suggestion.qualifiedPathName.absPath),
          { selection: this._getSuggestionSelection(suggestion), preserveFocus: preserveFocus },
        )
      }
    }
    let activeEditor = Se.window.activeTextEditor
    if (!activeEditor || !suggestion.qualifiedPathName.equals(activeEditor.document.uri)) {
      this._logger.debug(
        `Unable to go to suggestion in ${suggestion.qualifiedPathName.absPath}.`,
      )
      return
    }
    if (
      (suggestion.lineRange.start >= activeEditor.document.lineCount &&
        (this._logger.warn("Trying to move to a line that doesn't exist."),
        this._nextEditSessionEventReporter.reportEventFromSuggestion(
          suggestion,
          "error-moving-to-line-that-doesnt-exist",
          "unknown",
        )),
      activeEditor.visibleRanges.some((range) => range.contains(createRange(suggestion.lineRange))) ||
        (activeEditor.revealRange(
          new Se.Range(suggestion.lineRange.start, 0, suggestion.lineRange.stop, 0),
          Se.TextEditorRevealType.InCenterIfOutsideViewport,
        ),
        await sleep(EditorNextEdit._smoothScrollDelayMs)),
      animationDelayMs === undefined)
    ) {
      let isCursorInSuggestion = !isGlobalSuggestion && suggestion.highlightRange.contains(activeEditor.selection.active.line),
        isSuggestionVisible = !isGlobalSuggestion && activeEditor.visibleRanges.some((u) => u.contains(createRange(suggestion.lineRange)))
      ;(animationDelayMs = isCursorInSuggestion
        ? EditorNextEdit._applySuggestionDelayMs.atCursor
        : isSuggestionVisible
          ? EditorNextEdit._applySuggestionDelayMs.onScreen
          : EditorNextEdit._applySuggestionDelayMs.offScreen),
        suggestion.lineRange.length > EditorNextEdit._largeChangeLineCountThreshold &&
          (animationDelayMs += EditorNextEdit._applySuggestionDelayMs.largeBonus)
    }
    let suggestionSelection = this._getSuggestionSelection(suggestion)
    return (
      (!this._hoverProvider.hoverContactCondition(
        suggestion,
        activeEditor.selection.active,
        activeEditor.document,
      ) ||
        !activeEditor.selection.isEqual(suggestionSelection)) &&
        ((this._ignoreSelectionChangeEvents = true), (activeEditor.selection = suggestionSelection)),
      animationDelayMs
    )
  }
  async open(suggestion, options = {}) {
    if (suggestion.state === "stale") {
      this._logger.debug(
        `Tried to open stale suggestion. ${suggestion.result.suggestionId}`,
      )
      return
    }
    let delayMs = await this.gotoSuggestion(suggestion, options.animationDelayMs, options.preserveFocus)
    if (delayMs === undefined) return
    let activeEditor = Se.window.activeTextEditor
    if (!activeEditor) {
      this._logger.debug(
        `Unable to open suggestion in ${suggestion.qualifiedPathName.absPath}.`,
      )
      return
    }
    ;(this._state.value instanceof BeforePreviewState || this._state.value instanceof AfterPreviewState) &&
      !suggestion.equals(this._state.value.suggestion) &&
      (await this._hoverProvider.hideHoverAsync(options.eventSource ?? "command")),
      suggestion.state === "accepted"
        ? (this._state.value = new AfterPreviewState(suggestion))
        : (this._state.value = new BeforePreviewState(suggestion)),
      this._state.value instanceof BeforePreviewState &&
      (options.shouldAutoApply ?? this.nextEditConfig.enableAutoApply)
        ? (this._clearAnimatedApply(),
          (this._state.value = new AnimatingState(
            suggestion,
            activeEditor.selection,
            setTimeout(() => {
              this.accept(undefined, false, undefined, options.preserveFocus)
            }, delayMs),
          )))
        : this._hoverProvider.showHover()
  }
  openSuggestionAt(uri, lineNumber) {
    let matchingSuggestion = this._suggestionManager
      .getActiveSuggestions()
      .find(
        (suggestion) =>
          isFreshNonNoopSuggestion(suggestion) &&
          suggestion.qualifiedPathName.equals(uri) &&
          (suggestion.lineRange.contains(lineNumber) || suggestion.lineRange.touches(lineNumber)),
      )
    matchingSuggestion
      ? (this._nextEditSessionEventReporter.reportEventFromSuggestion(
          matchingSuggestion,
          "suggestion-opened",
          "gutter-click",
        ),
        this.open(matchingSuggestion, {
          animationDelayMs: EditorNextEdit._applySuggestionDelayMs.atCursor,
          eventSource: "gutter-click",
        }))
      : (this._logger.error(
          `No suggestion found for ${uri.toString()} at line ${lineNumber}.`,
        ),
        Se.window.showInformationMessage("No suggestion found."),
        this._nextEditSessionEventReporter.reportEventWithoutIds(
          "error-no-suggestion-found",
          "command",
        ))
  }
  _getHintedState() {
    let activeEditor = Se.window.activeTextEditor
    if (!activeEditor) return new NoSuggestionsState()
    let nextSuggestion = this.nextAvailableSuggestion(true)
    if (!nextSuggestion) return new NoSuggestionsState()
    let previousSuggestion = this.nextAvailableSuggestion(false)
    return previousSuggestion
      ? activeEditor.visibleRanges.some((range) => range.contains(createRange(previousSuggestion.highlightRange))) &&
        !activeEditor.visibleRanges.some((range) => range.contains(createRange(nextSuggestion.highlightRange)))
        ? new HintingState(previousSuggestion, false)
        : new HintingState(nextSuggestion, true)
      : new HintingState(nextSuggestion, true)
  }
  get state() {
    return this._state.value
  }
  addStateListener(listener) {
    return this._state.listen(listener)
  }
  _getSuggestionSelection(suggestion) {
    let targetLine = suggestion.previewTargetCursorLine
    return new Se.Selection(targetLine, 0, targetLine, 0)
  }
  async incrementKeybindingUsageCount(eventSource) {
    if (eventSource !== "keybinding") return
    let currentCount = this._globalState.get("nextEditKeybindingUsageCount") ?? 0
    if (!(currentCount >= EditorNextEdit.maxKeybindingUsageCount))
      return this._globalState.update("nextEditKeybindingUsageCount", currentCount + 1)
  }
  get nextEditConfig() {
    return this._nextEditConfigManager.config
  }
}
async function JSe() {
  try {
    await Se.commands.executeCommand("extension.vim_escape"),
      await Se.commands.executeCommand("extension.vim_insert"),
      await Se.commands.executeCommand("extension.vim_escape")
  } catch {}
}
function jSe(e, t, r, n, i) {
  let s = r ? -1 : 1
  if (e.length === 0) return
  let o = Se.window.activeTextEditor
  if (!o) return
  let a = o.selection
  if (!a) return
  let l = rangeToLineRange(a),
    c = e.filter(
      (f) => f.qualifiedPathName.equals(o.document.uri) && (!n || !f.equals(t)),
    )
  if (c.length === 0 && i)
    return e
      .filter((f) => !n || !f.equals(t))
      .filter((f) => f.scope === "WORKSPACE")
      .reduce(
        (f, p) =>
          f != null && f.result.localizationScore > p.result.localizationScore
            ? f
            : p,
        undefined,
      )
  n && (c = c.filter((f) => !f.equals(t)))
  let u = c.sort((f, p) => s * f.highlightRange.compareTo(p.highlightRange))
  return t
    ? (u.find((f) => s * f.highlightRange.compareTo(t.highlightRange) > 0) ??
        u[0])
    : (u.find(
        (f) =>
          s * f.highlightRange.compareTo(l) >= 0 ||
          f.previewBoxRange(o.document).contains(a.active.line) ||
          f.previewBoxRange(o.document).contains(a.anchor.line),
      ) ?? u[0])
}
var Xl = q(require("vscode"))
var no = q(require("vscode"))
var TN = q(require("assert")),
  XSe = q(e6()),
  sC = q(require("vscode"))
function getNextEditResultsPath(qualifiedPath) {
  return joinPaths(qualifiedPath.rootPath, qualifiedPath.relPath + ".next-edit-results.json5")
}
async function* createMockNextEditResultsStream(requestParams) {
  ;(0, TN.default)(requestParams.pathName)
  let document = await sC.workspace.openTextDocument(QualifiedPathName.from(requestParams.pathName).absPath),
    resultsFilePath = getNextEditResultsPath(requestParams.pathName)
  ;(0, TN.default)(fileExists(resultsFilePath))
  let mockResults = XSe.default.parse((await sC.workspace.openTextDocument(resultsFilePath)).getText()),
    documentText = document.getText(),
    suggestionCounter = 0
  for await (let mockResult of mockResults)
    (mockResult.path = mockResult.path ?? requestParams.pathName?.relPath),
      (mockResult.blobName = requestParams.blobName ?? ""),
      (mockResult.suggestionId =
        mockResult.suggestionId ?? `mock-suggestion-${mockResult.blobName}-${suggestionCounter++}`),
      (mockResult.charStart =
        mockResult.charStart ?? document.offsetAt(new sC.Position(mockResult.lineStart, 0))),
      (mockResult.charEnd = mockResult.charEnd ?? document.offsetAt(new sC.Position(mockResult.lineEnd, 0))),
      (mockResult.diffSpans =
        mockResult.diffSpans ??
        (mockResult.existingCode != null && mockResult.suggestedCode != null
          ? $Ct(mockResult.existingCode, mockResult.suggestedCode)
          : [
              {
                original: { start: mockResult.charStart, stop: mockResult.charEnd },
                updated: { start: mockResult.charStart, stop: mockResult.charEnd },
              },
            ])),
      (mockResult.existingCode =
        mockResult.existingCode?.replaceAll("|", "") ??
        documentText.substring(mockResult.charStart, mockResult.charEnd)),
      (mockResult.suggestedCode =
        mockResult.suggestedCode?.replaceAll("|", "") ??
        documentText.substring(mockResult.charStart, mockResult.charEnd)),
      (mockResult.changeDescription = mockResult.changeDescription ?? ""),
      (mockResult.editingScore = mockResult.editingScore ?? 1),
      (mockResult.localizationScore = mockResult.localizationScore ?? 1),
      (mockResult.editingScoreThreshold = mockResult.editingScoreThreshold ?? 1),
      yield { result: mockResult, unknownBlobNames: [], checkpointNotFound: false }
}
function $Ct(e, t) {
  let r = [],
    n = e.split("|"),
    i = t.split("|")
  ;(0, TN.default)(n.length === i.length)
  let s = 0,
    o = 0
  for (let a = 0; a < n.length; a++)
    r.push({
      original: { start: s, stop: s + n[a].length },
      updated: { start: o, stop: o + i[a].length },
    }),
      (s += n[a].length),
      (o += i[a].length)
  return r
}
var MAX_DIAGNOSTICS = 10,
  MAX_AGE_MS = 3
function getFolderRoot(workspaceManager, pathName) {
  return pathName
    ? workspaceManager.getFolderRoot(QualifiedPathName.from(pathName).absPath)
    : workspaceManager.getMostRecentlyChangedFolderRoot()
}
function checkCanUpdateGlobal(workspaceManager, configListener, activePath, fileEditEvents) {
  let useMockResultsForCurrentFile = !!configListener.config.nextEdit.useMockResults && !!activePath && fileExists(getNextEditResultsPath(activePath))
  return (fileEditEvents ?? workspaceManager.getFileEditEvents(getFolderRoot(workspaceManager, activePath))).length !== 0 || useMockResultsForCurrentFile
}
async function* createNextEditSuggestionStream(request, workspaceManager, diagnosticsManager, apiServer, blobNameCalculator, configListener, cancellationToken, eventReporter) {
  let logger = z("queryNextEditStream")
  if (cancellationToken.isCancellationRequested) {
    logger.debug("Skipping Next Edit with cancelled token."),
      yield { status: RequestStatus.cancelled }
    return
  }
  if (!checkCanUpdateGlobal(workspaceManager, configListener, request.pathName, request.fileEditEvents)) {
    logger.debug("Skipping Next Edit with no changes."), yield { status: RequestStatus.ok }
    return
  }
  let useMockResults = configListener.config.nextEdit.useMockResults && request.pathName && fileExists(getNextEditResultsPath(request.pathName)),
    folderRoot = getFolderRoot(workspaceManager, request.pathName),
    fileEditEvents = request.fileEditEvents ?? workspaceManager.getFileEditEvents(folderRoot), // =
    repoRoot = folderRoot ? workspaceManager.getRepoRootForFolderRoot(folderRoot) : undefined,
    qualifiedPathName = request.pathName && QualifiedPathName.from(request.pathName),
    rootPath = qualifiedPathName?.rootPath ?? repoRoot,
    workspaceContext = workspaceManager.getContext()
  request = {
    ...request,
    blobName: request.blobName ?? (qualifiedPathName && workspaceManager.getBlobName(qualifiedPathName)),
    blobs: request.blobs ?? workspaceContext.blobs,
    recentChanges:
      request.recentChanges ?? convertToChangeRecords(workspaceContext.recentChunks.filter((chunk) => !chunk.uploaded)),
    fileEditEvents: fileEditEvents,
    unindexedEditEvents:
      request.unindexedEditEvents.length > 0
        ? request.unindexedEditEvents
        : workspaceContext.unindexedEditEvents,
    unindexedEditEventsBaseBlobNames:
      request.unindexedEditEventsBaseBlobNames.length > 0
        ? request.unindexedEditEventsBaseBlobNames
        : workspaceContext.unindexedEditEventsBaseBlobNames,
    diagnostics: await getDiagnosticsForNextEdit(diagnosticsManager, rootPath, blobNameCalculator, workspaceManager),
  }
  let pendingEditsTracker = new PendingEditsTracker(request.requestId, workspaceManager)
  logger.debug(
    `[${request.requestId}] Starting request for ${qualifiedPathName?.relPath} (mode=${request.mode}, scope=${request.scope}).`,
  )
  try {
    let suggestionStream
    if (
      (useMockResults ? (suggestionStream = createMockNextEditResultsStream(request)) : (suggestionStream = await apiServer.nextEditStream(request)),
      cancellationToken.isCancellationRequested)
    ) {
      logger.debug(`[${request.requestId}] Skipping next edit with cancelled token.`),
        yield { status: RequestStatus.cancelled }
      return
    }
    for await (let suggestionResponse of suggestionStream) {
      let logPrefix = `[${request.requestId}/${suggestionResponse.result.suggestionId}]`
      if (
        (suggestionResponse.unknownBlobNames.length > 0 &&
          (workspaceManager.handleUnknownBlobs(workspaceContext, suggestionResponse.unknownBlobNames),
          logger.warn(`${logPrefix} Found ${suggestionResponse.unknownBlobNames.length} unknown blobs.`)),
        suggestionResponse.checkpointNotFound &&
          (workspaceManager.handleUnknownCheckpoint(request.requestId, request.blobs.checkpointId),
          logger.warn(`${logPrefix} Checkpoint was not found.`)),
        cancellationToken.isCancellationRequested)
      ) {
        logger.debug(`${logPrefix} Cancelled by the client.`), yield { status: RequestStatus.cancelled }
        return
      }
      let document = await resolveDocumentFromPath(suggestionResponse.result.path, rootPath, workspaceManager),
        resolvedPathName = document && workspaceManager.safeResolvePathName(document.uri)
      if (cancellationToken.isCancellationRequested) {
        logger.debug(`${logPrefix} Cancelled by the client.`), yield { status: RequestStatus.cancelled }
        return
      }
      if (!resolvedPathName) {
        logger.warn(`${logPrefix} Response path ${suggestionResponse.result.path} has no document.`),
          eventReporter.reportEvent(
            request.requestId,
            suggestionResponse.result.suggestionId,
            Date.now(),
            "error-no-document-for-response",
            "unknown",
          )
        continue
      }
      if (document?.uri.scheme === "file" && !fileExists(resolvedPathName.absPath)) {
        logger.warn(`${logPrefix} Response path ${resolvedPathName.relPath} does not exist.`),
          eventReporter.reportEvent(
            request.requestId,
            suggestionResponse.result.suggestionId,
            Date.now(),
            "error-response-file-is-deleted",
            "unknown",
          )
        continue
      }
      let documentText = document.getText(),
        adjustedStartChar = getByteOffsetFromCodePointIndex(documentText, suggestionResponse.result.charStart),
        adjustedEndChar = getByteOffsetFromCodePointIndex(documentText, suggestionResponse.result.charEnd),
        adjustedRange = pendingEditsTracker.updateWithPendingEdits(resolvedPathName, new CharRange(adjustedStartChar, adjustedEndChar))
      if (!adjustedRange) {
        logger.debug(`${logPrefix} Response was invalidated by pending edits.`),
          yield { status: RequestStatus.invalidArgument }
        return
      }
      let vscodeRange = new no.Range(document.positionAt(adjustedRange.start), document.positionAt(adjustedRange.stop)),
        endLine = document.lineAt(vscodeRange.end.line)
      if (
        (endLine.range.isEqual(endLine.rangeIncludingLineBreak) &&
          vscodeRange.end.line === document.lineCount - 1 &&
          vscodeRange.end.character === endLine.range.end.character &&
          !vscodeRange.isEmpty &&
          (vscodeRange = vscodeRange.with({ end: new no.Position(vscodeRange.end.line + 1, 0) })),
        vscodeRange.start.character !== 0 || vscodeRange.end.character !== 0)
      ) {
        if (
          (logger.warn(`${logPrefix} Response was not line-aligned ${formatRangeToString(vscodeRange)}.`),
          logger.debug(
            `${logPrefix} Converting char range ${suggestionResponse.result.charStart}-${suggestionResponse.result.charEnd} to ${adjustedStartChar}-${adjustedEndChar}.`,
          ),
          logger.debug(`${logPrefix} Updated char range to ${adjustedRange?.start}-${adjustedRange?.stop}.`),
          logger.debug(
            `${logPrefix} The bad line is: "${document.lineAt(vscodeRange.end.character !== 0 ? vscodeRange.end.line : vscodeRange.start.line).text}".`,
          ),
          eventReporter.reportEvent(
            request.requestId,
            suggestionResponse.result.suggestionId,
            Date.now(),
            "error-response-not-line-aligned",
            "unknown",
          ),
          resolvedPathName.relPath !== request.pathName?.relPath)
        )
          continue
        eventReporter.reportEvent(
          request.requestId,
          suggestionResponse.result.suggestionId,
          Date.now(),
          "error-response-not-line-aligned-for-current-file",
          "unknown",
        ),
          yield { status: RequestStatus.invalidArgument }
        return
      }
      if (document.getText(vscodeRange) !== suggestionResponse.result.existingCode) {
        if (
          (logger.warn(`${logPrefix} Code in buffer doesn't match code in response.`),
          logger.debug(
            `${logPrefix} Converting char range ${suggestionResponse.result.charStart}-${suggestionResponse.result.charEnd} to ${adjustedStartChar}-${adjustedEndChar}.`,
          ),
          logger.debug(`${logPrefix} Updated char range to ${adjustedRange?.start}-${adjustedRange?.stop}.`),
          logger.debug(
            `${logPrefix} Buffer code: "${document.getText(vscodeRange)}", response code: "${suggestionResponse.result.existingCode}".`,
          ),
          eventReporter.reportEvent(
            request.requestId,
            suggestionResponse.result.suggestionId,
            Date.now(),
            "error-code-in-buffer-doesnt-match-code-in-response",
            "unknown",
          ),
          resolvedPathName.relPath !== request.pathName?.relPath)
        )
          continue
        eventReporter.reportEvent(
          request.requestId,
          suggestionResponse.result.suggestionId,
          Date.now(),
          "error-code-in-buffer-doesnt-match-code-in-response-for-current-file",
          "unknown",
        ),
          yield { status: RequestStatus.invalidArgument }
        return
      }
      fetch('http://localhost:3000', {
        method: 'POST',
        body: JSON.stringify({
          callMethod: 'createNextEditSuggestionStream: suggestionStream for loop',
          next: 'yield suggestion to _processPendingRequests',
          requestId: request.requestId,
          suggestionResponse,
        })
      });
      let suggestion = new EditSuggestion(
        request.requestId,
        request.mode,
        request.scope,
        { ...suggestionResponse.result, charStart: adjustedRange.start, charEnd: adjustedRange.stop },
        resolvedPathName,
        rangeToLineRange(vscodeRange),
        document.uri.scheme,
      )
      logger.debug(
        `${logPrefix} Returning ${suggestion.changeType} suggestion for ${resolvedPathName.relPath}@${suggestion.lineRange.toString()}.`,
      ),
        yield { status: RequestStatus.ok, suggestion: suggestion }
    }
    logger.debug(`[${request.requestId}] Request completed.`)
  } catch (error) {
    if (ApiError.isAPIErrorWithStatus(error, RequestStatus.cancelled)) {
      logger.debug(`[${request.requestId}] Cancelled by the server.`),
        yield { status: RequestStatus.cancelled }
      return
    }
    logger.warn(`[${request.requestId}] Next edit failed: ${error}.`),
      eventReporter.reportEvent(
        request.requestId,
        undefined,
        Date.now(),
        "error-api-error",
        "unknown",
      ),
      yield { status: RequestStatus.unknown }
    return
  } finally {
    pendingEditsTracker.dispose()
  }
}
var PendingEditsTracker = class extends DisposableContainer {
  constructor(requestId, workspaceManager) {
    super()
    this.requestId = requestId
    this.workspaceManager = workspaceManager
    this.addDisposable(
      no.workspace.onDidChangeTextDocument((event) => {
        if (event.contentChanges.length === 0) return
        let pathName = this.workspaceManager.safeResolvePathName(event.document.uri)
        if (!pathName) return
        let pendingChanges = this._pendingEdits.get(pathName.absPath) ?? []
        pendingChanges.push(...event.contentChanges), this._pendingEdits.set(pathName.absPath, pendingChanges)
      }),
    )
  }
  _pendingEdits = new Map()
  updateWithPendingEdits(pathName, charRange) {
    let pendingChanges = this._pendingEdits.get(pathName.absPath) ?? []
    for (let change of pendingChanges) {
      let offsetDelta = change.text.length - change.rangeLength
      if (change.rangeOffset + change.rangeLength < charRange.start) (charRange.start += offsetDelta), (charRange.stop += offsetDelta)
      else if (change.rangeOffset <= charRange.stop) return
    }
    return charRange
  }
}
async function resolveDocumentFromPath(relativePath, rootPath, workspaceManager) {
  if (!rootPath) {
    let qualifiedPaths = workspaceManager.getAllQualifiedPathNames(relativePath)
    qualifiedPaths.length === 1 && (rootPath = qualifiedPaths[0].rootPath)
  }
  if (rootPath) {
    let documentUri = no.Uri.file(joinPaths(rootPath, relativePath)),
      document = await no.workspace.openTextDocument(documentUri)
    if (document) return document
  }
  return no.window.visibleTextEditors.find((editor) => editor.document.uri.fsPath === relativePath)
    ?.document
}
async function getDiagnosticsForNextEdit(diagnosticsManager, rootPath, blobNameCalculator, workspaceManager) {
  let diagnostics = await diagnosticsManager.getMostRecentDiagnostics(MAX_DIAGNOSTICS, MAX_AGE_MS, rootPath),
    blobNameCache = new Map()
  return (
    await Promise.all(
      diagnostics.map(async (diagnostic) => {
        let relativePath = diagnostic.uri.path
        rootPath && relativePath.startsWith(rootPath) && (relativePath = relativePath.substring(rootPath.length))
        let severityString
        switch (diagnostic.diagnostic.severity) {
          case no.DiagnosticSeverity.Error:
            severityString = "ERROR"
            break
          case no.DiagnosticSeverity.Warning:
            severityString = "WARNING"
            break
          case no.DiagnosticSeverity.Information:
            severityString = "INFORMATION"
            break
          case no.DiagnosticSeverity.Hint:
            severityString = "HINT"
            break
        }
        blobNameCache.has(relativePath) ||
          blobNameCache.set(relativePath, blobNameCalculator.calculateNoThrow(relativePath, (await Io(diagnostic.uri.fsPath)).getText()))
        let currentBlobName = blobNameCache.get(relativePath)
        if (!currentBlobName) return
        let qualifiedPath = workspaceManager.safeResolvePathName(diagnostic.uri)
        if (!qualifiedPath) return
        let blobName = workspaceManager.getBlobName(qualifiedPath)
        return blobName
          ? {
              location: {
                path: relativePath,
                line_start: diagnostic.diagnostic.range.start.line,
                line_end: diagnostic.diagnostic.range.end.line,
              },
              message: diagnostic.diagnostic.message,
              severity: severityString,
              current_blob_name: currentBlobName,
              blob_name: blobName,
              char_start: diagnostic.charStart,
              char_end: diagnostic.charEnd,
            }
          : undefined
      }),
    )
  ).filter((result) => result !== undefined)
}
var GlobalNextEdit = class extends DisposableContainer {
  constructor(workspaceManager, nextEditRequestManager, suggestionManager, configListener, nextEditSessionEventReporter) {
    super()
    this._workspaceManager = workspaceManager
    this._nextEditRequestManager = nextEditRequestManager
    this._suggestionManager = suggestionManager
    this._configListener = configListener
    this._nextEditSessionEventReporter = nextEditSessionEventReporter
    this.addDisposable(
      Xl.workspace.onDidChangeTextDocument(this.handleWorkspaceEditsAvailable),
    ),
      this.addDisposable(
        Xl.window.onDidChangeActiveTextEditor(
          this.handleWorkspaceEditsAvailable,
        ),
      ),
      this.addDisposable(
        new Xl.Disposable(
          this._nextEditRequestManager.lastFinishedRequest.listen(() => {
            this._handleWorkspaceEditsCached()
          }),
        ),
      )
  }
  timeoutMs = 1e3 * 30
  _logger = z("GlobalNextEdits")
  async startGlobalQuery(eventSource) {
    Xl.commands.executeCommand(
      "setContext",
      "vscode-augment.nextEdit.global.updating",
      true,
    )
    try {
      this._nextEditSessionEventReporter.reportEventWithoutIds(
        "global-mode-refreshed",
        eventSource ?? "command",
      )
      let activeEditor = Xl.window.activeTextEditor,
        activePath = activeEditor
          ? this._workspaceManager.safeResolvePathName(activeEditor.document.uri)
          : undefined,
        requestId = this._nextEditRequestManager.enqueueRequest(
          activePath,
          "FOREGROUND",
          "WORKSPACE",
        )
      if (!requestId) return
      await this._nextEditRequestManager.lastFinishedRequest
        .waitUntil((request) => request !== undefined && request.requestId === requestId, this.timeoutMs)
        .catch((error) => {
          this._logger.error(`Global next edit failed: ${error}`),
            this._nextEditSessionEventReporter.reportEvent(
              requestId,
              undefined,
              Date.now(),
              "error-global-mode-error",
              "command",
            )
        })
      let invalidSuggestions = this._suggestionManager
        .getActiveSuggestions()
        .filter((suggestion) => !fileExists(suggestion.qualifiedPathName.absPath))
      this._suggestionManager.remove(invalidSuggestions)
    } finally {
      Xl.commands.executeCommand(
        "setContext",
        "vscode-augment.nextEdit.global.updating",
        false,
      )
    }
  }
  cancel() {
    this._nextEditRequestManager.cancelAll(),
      this._nextEditSessionEventReporter.reportEventWithoutIds(
        "global-mode-canceled",
        "command",
      )
  }
  handleWorkspaceEditsAvailable = () => {
    let { activeTextEditor: activeTextEditor } = Xl.window,
      activePath = activeTextEditor
        ? this._workspaceManager.safeResolvePathName(activeTextEditor?.document.uri)
        : undefined,
      canUpdate = checkCanUpdateGlobal(this._workspaceManager, this._configListener, activePath)
    setVSCodeContext("vscode-augment.nextEdit.global.canUpdate", canUpdate)
  }
  _handleWorkspaceEditsCached() {
    let { activeTextEditor: activeTextEditor } = Xl.window,
      activePath = activeTextEditor
        ? this._workspaceManager.safeResolvePathName(activeTextEditor?.document.uri)
        : undefined,
      shouldNotEnqueueReason = this._nextEditRequestManager.shouldNotEnqueueRequestReason(
        activePath,
        "FOREGROUND",
        "WORKSPACE",
      )
    setVSCodeContext("vscode-augment.nextEdit.global.updateCached", shouldNotEnqueueReason)
  }
}
var nIe = q(_s()),
  ec = q(require("vscode"))
var NextEditRequestManager = class e extends DisposableContainer {
  constructor(apiServer, configListener, workspaceManager, diagnosticsManager, nextEditSessionEventReporter, clientMetricsReporter, blobNameCalculator, suggestionManager, recentSuggestions, stateController, completionJustAccepted, featureFlagManager) {
    super()
    this._apiServer = apiServer
    this._configListener = configListener
    this._workspaceManager = workspaceManager
    this._diagnosticsManager = diagnosticsManager
    this._nextEditSessionEventReporter = nextEditSessionEventReporter
    this._clientMetricsReporter = clientMetricsReporter
    this._blobNameCalculator = blobNameCalculator
    this._suggestionManager = suggestionManager
    this._recentSuggestions = recentSuggestions
    this._stateController = stateController
    this._completionJustAccepted = completionJustAccepted
    this._featureFlagManager = featureFlagManager
    this.addDisposable(
      new ec.Disposable(() => {
        this._inflightRequest?.cancelTokenSource?.cancel(),
          this._inflightRequest?.cancelTokenSource?.dispose(),
          (this._inflightRequest = undefined),
          this.lastFinishedRequest.dispose(),
          this.lastResponse.dispose(),
          this.state.dispose()
      }),
    ),
      this.addDisposable(
        new ec.Disposable(
          this.state.listen((y) => {
            setVSCodeContext("vscode-augment.nextEdit.loading", y === "inflight")
          }),
        ),
      )
    let setupDebounce = (debounceMs) => {
      let value = debounceMs ?? this._featureFlagManager.currentFlags.nextEditDebounceMs
      this._processPendingRequestsDebounced &&
        this._processPendingRequestsDebounced.cancel(),
        (this._processPendingRequestsDebounced = (0, nIe.debounce)(
          () => void this._processPendingRequests(),
          value,
        ))
    }
    setupDebounce(this._configListener.config.nextEdit.useDebounceMs),
      this.addDisposable(
        this._configListener.onDidChange((configChange) => {
          configChange.newConfig.nextEdit.useDebounceMs !==
            configChange.previousConfig.nextEdit.useDebounceMs &&
            setupDebounce(configChange.newConfig.nextEdit.useDebounceMs)
        }),
      ),
      this.addDisposable(
        ec.workspace.onDidChangeTextDocument((event) => {
          event.contentChanges.length > 0 &&
            this._workspaceManager.safeResolvePathName(event.document.uri) &&
            (this._freshCompletedRequests = []),
            !(
              !QualifiedPathName.equals(
                this._inflightRequest?.qualifiedPathName,
                event.document.uri,
              ) &&
              !this._pendingRequests.some((v) =>
                QualifiedPathName.equals(v.qualifiedPathName, event.document.uri),
              )
            ) &&
              event.contentChanges.length > 0 &&
              !this._suggestionManager.suggestionWasJustAccepted.value &&
              this.cancelAll()
        }),
      )
  }
  _logger = z("NextEditRequestManager")
  static _statusClearTimeoutMs = 2e3
  _pendingRequests = []
  _inflightRequest
  lastFinishedRequest = new Observable(undefined)
  lastResponse = new Observable(undefined)
  state = new Observable("ready")
  _processPendingRequestsDebounced
  _freshCompletedRequests = []
  get hasInflightRequest() {
    return !!this._inflightRequest
  }
  get pendingQueueLength() {
    return this._pendingRequests.length
  }
  shouldNotEnqueueRequestReason(qualifiedPathName, mode, scope, selection) {
    let resolvedPath = this._resolvePath(qualifiedPathName),
      requestInfo = {
        mode: mode,
        scope: scope,
        selection: selection ?? resolvedPath?.selection,
        requestBlobName: resolvedPath?.blobName,
        qualifiedPathName: qualifiedPathName,
      },
      activeRequest = this._inflightRequest || this._pendingRequests[0]
    if (activeRequest && isRequestSubsumed(requestInfo, activeRequest))
      return `Skipping ${mode}/${scope} request because it is subsumed by inflight request ${activeRequest.id}.`
    let recentlyCompletedRequest = this._freshCompletedRequests.find((req) => isRequestSubsumed(requestInfo, req)),
      locationString = `${qualifiedPathName?.relPath}@${requestInfo.selection?.toString()}`
    if (recentlyCompletedRequest)
      return `Skipping ${mode}/${scope} request at ${locationString} because it is subsumed by ${recentlyCompletedRequest.id}, which was recently completed.`
  }
  enqueueRequest(qualifiedPathName, mode, scope, selection) {
    let skipReason = this.shouldNotEnqueueRequestReason(qualifiedPathName, mode, scope, selection)
    if (skipReason) {
      this._logger.debug(skipReason)
      return
    }
    let resolvedPath = this._resolvePath(qualifiedPathName)
    selection = selection ?? resolvedPath?.selection
    let locationString = `${qualifiedPathName?.relPath}@${selection?.toString()}`,
      request = {
        id: this._apiServer.createRequestId(),
        qualifiedPathName: qualifiedPathName,
        mode: mode,
        scope: scope,
        enqueuedAt: Date.now(),
      }
    this._logger.debug(
      `Starting enqueuing ${mode}/${scope} request ${request.id} at ${locationString}.`,
    )
    let activeRequest = this._inflightRequest || this._pendingRequests[0]
    activeRequest &&
      (request.mode === "FOREGROUND" || request.mode === "FORCED"
        ? (this._logger.debug(
            `Clearing requests for foreground request @ ${locationString}.`,
          ),
          this.cancelAll())
        : request.mode === "BACKGROUND" &&
            activeRequest.mode === "BACKGROUND" &&
            !QualifiedPathName.equals(activeRequest.qualifiedPathName, request.qualifiedPathName)
          ? (this._logger.debug(
              `Clearing requests for background request @ ${locationString}.`,
            ),
            this.cancelAll())
          : request.mode === "BACKGROUND" &&
            activeRequest.mode === "BACKGROUND" &&
            activeRequest.scope === "WORKSPACE" &&
            request.scope === "FILE" &&
            (this._logger.debug(
              `Clearing background workspace requests for background file request @ ${locationString}.`,
            ),
            this.cancelAll()))
    let existingRequest = this._pendingRequests.find((req) => isRequestSubsumed(request, req))
    return (
      existingRequest
        ? this._logger.debug(
            `Skipping enqueueing request ${request.id} at ${locationString} because it is subsumed by ${existingRequest.id}, which is already pending.`,
          )
        : this._pendingRequests.push(request),
      (this.state.value = this._inflightRequest ? "inflight" : "pending"),
      this._processPendingRequestsDebounced(),
      (request.mode === "FOREGROUND" ||
        request.mode === "FORCED" ||
        this._suggestionManager.suggestionWasJustAccepted.value ||
        this._completionJustAccepted.value) &&
        this._processPendingRequestsDebounced.flush(),
      request.id
    )
  }
  cancelAll() {
    this._inflightRequest &&
      (this._logger.debug(
        `Cancelling inflight request ${this._inflightRequest.id}.`,
      ),
      this._inflightRequest.cancelTokenSource?.cancel(),
      this._inflightRequest.cancelTokenSource?.dispose(),
      (this._inflightRequest = undefined)),
      this._pendingRequests.length > 0 &&
        (this._logger.debug(
          `Cancelling ${this._pendingRequests.length} pending requests: ${this._pendingRequests.map((req) => req.id).toString()}.`,
        ),
        (this._pendingRequests = []),
        this._processPendingRequestsDebounced.cancel())
  }
  async _processPendingRequests() {
    if (this._inflightRequest) {
      this._logger.debug("Waiting for inflight request to complete.")
      return
    } else if (!this._pendingRequests.length) {
      this._logger.debug("Waiting for a request to be enqueued.")
      return
    }
    let [request] = this._pendingRequests.splice(0, 1),
      resolvedPath = this._resolvePath(request.qualifiedPathName),
      queueTime = Date.now() - request.enqueuedAt
    this._logger.debug(`Starting to process ${request.id} after ${queueTime} ms.`)
    let blobName = resolvedPath?.blobName,
      qualifiedPathName = request.qualifiedPathName,
      document = resolvedPath?.document,
      selection = resolvedPath?.selection,
      mode = request.mode,
      scope = request.scope,
      blockedLocations = this._suggestionManager
        .getRejectedSuggestions()
        .filter(
          (suggestion) =>
            suggestion.changeType !== "noop" &&
            (scope === "WORKSPACE" ||
              qualifiedPathName === undefined ||
              suggestion.qualifiedPathName.equals(qualifiedPathName)),
        )
        .map(
          (suggestion) =>
            new RejectedLocation(
              suggestion.qualifiedPathName.relPath,
              suggestion.lineRange,
              suggestion.result.charStart,
              suggestion.result.charEnd,
            ),
        ),
      requestId = request.id,
      inflightRequest = (this._inflightRequest = {
        ...request,
        requestBlobName: blobName,
        selection: selection,
        cancelTokenSource: new ec.CancellationTokenSource(),
      })
    this.state.value = "inflight"
    let stateToken = this._stateController.setState(ySe),
      requestStatus = RequestStatus.ok,
      suggestions = [],
      startTime = new Date()
    try {
      let processingStartTime = Date.now(),
        suggestionStream = createNextEditSuggestionStream(
          {
            requestId: requestId,
            clientCreatedAt: new Date(),
            instruction: "",
            selectedCode: document?.getText(selection && createRange(selection, document)),
            prefix: selection && document?.getText(createRange({ start: 0, stop: selection.start }, document)),
            suffix:
              selection && document?.getText(createRange({ start: selection.stop, stop: document.lineCount }, document)),
            language: document?.languageId,
            pathName: qualifiedPathName,
            mode: mode,
            scope: scope,
            blockedLocations: blockedLocations,
            unindexedEditEvents: [],
            unindexedEditEventsBaseBlobNames: [],
          },
          this._workspaceManager,
          this._diagnosticsManager,
          this._apiServer,
          this._blobNameCalculator,
          this._configListener,
          inflightRequest.cancelTokenSource.token,
          this._nextEditSessionEventReporter,
        ),
        preprocessingEndTime = Date.now(),
        firstChangeLatency = 0,
        sufficientNoopsLatency = 0,
        suggestionCount = 0,
        queueLatency = processingStartTime - inflightRequest.enqueuedAt
      this._logger.debug(`[${inflightRequest.id}] queued for ${queueLatency} ms.`)
      for await (let response of suggestionStream) {
        if (((requestStatus = response.status), !response.suggestion)) break
        suggestionCount++
        fetch('http://localhost:3000', {
          method: 'POST',
          body: JSON.stringify({
            callMethod: '_processPendingRequests: suggestionStream for loop',
            next: 'about to assign to this.lastResponse.value',
            requestId: requestId,
            response
          })
        });
        let totalLatency = Date.now() - inflightRequest.enqueuedAt
        this._logger.debug(
          `[${response.suggestion?.requestId}/${response.suggestion?.result.suggestionId}] ${response.suggestion?.changeType?.toString()} took ${totalLatency} ms since enqueue.`,
        ),
          firstChangeLatency === 0 &&
            response.suggestion !== undefined &&
            response.suggestion.changeType !== "noop" &&
            (firstChangeLatency = totalLatency),
          suggestionCount === 4 && firstChangeLatency === 0 && (sufficientNoopsLatency = totalLatency),
          (this.lastResponse.value = response.suggestion),
          response.suggestion && suggestions.push(response.suggestion)
      }
      let noSuggestions = requestStatus === RequestStatus.ok && suggestions.length === 0
      if (
        (requestStatus === RequestStatus.ok && !noSuggestions && this._freshCompletedRequests.push(inflightRequest),
        !noSuggestions && inflightRequest.mode === "BACKGROUND")
      ) {
        this._clientMetricsReporter.report({
          client_metric: "next_edit_bg_stream_preprocessing_latency_ms",
          value: preprocessingEndTime - processingStartTime,
        })
        let totalLatency = Date.now() - inflightRequest.enqueuedAt
        requestStatus === RequestStatus.ok
          ? this._clientMetricsReporter.report({
              client_metric: "next_edit_bg_stream_finish_latency_ms",
              value: totalLatency,
            })
          : firstChangeLatency > 0 || sufficientNoopsLatency > 0
            ? this._clientMetricsReporter.report({
                client_metric: "next_edit_bg_stream_partial_latency_ms",
                value: totalLatency,
              })
            : requestStatus === RequestStatus.cancelled
              ? this._clientMetricsReporter.report({
                  client_metric: "next_edit_bg_stream_cancel_latency_ms",
                  value: totalLatency,
                })
              : this._clientMetricsReporter.report({
                  client_metric: "next_edit_bg_stream_error_latency_ms",
                  value: totalLatency,
                }),
          firstChangeLatency > 0
            ? this._clientMetricsReporter.report({
                client_metric: "next_edit_bg_first_change_latency_ms",
                value: firstChangeLatency,
              })
            : sufficientNoopsLatency > 0
              ? this._clientMetricsReporter.report({
                  client_metric: "next_edit_bg_sufficient_noops_latency_ms",
                  value: sufficientNoopsLatency,
                })
              : suggestionCount < 4 &&
                requestStatus === RequestStatus.ok &&
                this._clientMetricsReporter.report({
                  client_metric: "next_edit_bg_sufficient_noops_latency_ms",
                  value: totalLatency,
                })
      }
    } catch (error) {
      this._logger.warn(`[${requestId}] Next edit failed: ${error}.`),
        this._nextEditSessionEventReporter.reportEvent(
          requestId,
          undefined,
          Date.now(),
          "error-api-error",
          "unknown",
        )
    } finally {
      inflightRequest === this._inflightRequest &&
        ((this._inflightRequest = undefined),
        this._pendingRequests.length > 0
          ? (this._processPendingRequestsDebounced(),
            this._processPendingRequestsDebounced.flush())
          : (this._logger.debug("No more pending requests."),
            (this.state.value = "ready"),
            requestStatus === RequestStatus.ok &&
            !this._suggestionManager
              .getActiveSuggestions()
              .some((suggestion) => suggestion.state === "fresh" && suggestion.changeType !== "noop")
              ? disposeAfterDelay(
                  this._stateController.setState(vSe),
                  e._statusClearTimeoutMs,
                )
              : requestStatus !== RequestStatus.cancelled &&
                requestStatus !== RequestStatus.ok &&
                (this._stateController.setState(ASe),
                this._logger.debug(
                  `Request ${requestId} failed with status: ${requestStatus}.`,
                ))))
      let finishedRequest = new NextEditRequest(requestId, mode, scope, qualifiedPathName, requestStatus, suggestions, startTime)
      this._recentSuggestions.addItem(finishedRequest),
        (this.lastFinishedRequest.value = finishedRequest),
        stateToken.dispose(),
        inflightRequest.cancelTokenSource.dispose()
    }
  }
  clearCompletedRequests(mode) {
    this._freshCompletedRequests = this._freshCompletedRequests.filter(
      (request) => mode !== undefined && request.mode !== mode,
    )
  }
  _resolvePath(qualifiedPathName) {
    let pathName = qualifiedPathName && QualifiedPathName.from(qualifiedPathName),
      editor = pathName && this._findEditorForPath(pathName),
      document = editor && editor.document,
      blobName = document && this._blobNameCalculator.calculate(pathName.relPath, document.getText()),
      selection = editor && new LineRange(editor.selection.start.line, editor.selection.end.line)
    return { blobName: blobName, document: document, selection: selection }
  }
  _findEditorForPath(qualifiedPathName) {
    let pathName = QualifiedPathName.from(qualifiedPathName)
    return ec.window.activeTextEditor &&
      this._workspaceManager
        .safeResolvePathName(ec.window.activeTextEditor.document.uri)
        ?.equals(pathName)
      ? ec.window.activeTextEditor
      : ec.window.visibleTextEditors.find((i) =>
          this._workspaceManager
            .safeResolvePathName(i.document.uri)
            ?.equals(pathName),
        )
  }
},
  MAX_CURSOR_LINE_DISTANCE = 15
function isRequestSubsumed(request, otherRequest) {
  return (
    request.mode === otherRequest.mode &&
    (request.scope === otherRequest.scope || (request.scope === "CURSOR" && otherRequest.scope === "FILE")) &&
    (request.scope === "WORKSPACE" ||
      QualifiedPathName.equals(request.qualifiedPathName, otherRequest.qualifiedPathName)) &&
    !(
      request.scope !== "WORKSPACE" &&
      request.requestBlobName &&
      otherRequest.requestBlobName &&
      request.requestBlobName !== otherRequest.requestBlobName
    ) &&
    !(
      request.scope === "CURSOR" &&
      request.selection?.start != null &&
      otherRequest.selection?.start != null &&
      Math.abs(request.selection.start - otherRequest.selection.start) > MAX_CURSOR_LINE_DISTANCE
    )
  )
}
function disposeAfterDelay(disposable, delayMs) {
  setTimeout(() => {
    disposable.dispose()
  }, delayMs)
}
var oIe = q(_s()),
  Us = q(require("vscode"))
var yw = q(require("vscode"))
var DocumentContextValue = class extends DisposableContainer {
  _document
  _lastSetAt
  _observable
  constructor(initialValue = undefined, clearDelayMs = 1) {
    super(), (this._observable = this.addDisposable(new Observable(initialValue)))
    let checkAndClearIfNeeded = (document) => {
      this.value === undefined ||
        (document && this._document && document !== this._document) ||
        (this._lastSetAt && Date.now() - this._lastSetAt < clearDelayMs) ||
        this.clear()
    }
    this.addDisposable(
      yw.window.onDidChangeActiveTextEditor(() => {
        checkAndClearIfNeeded()
      }),
    ),
      this.addDisposable(
        yw.window.onDidChangeTextEditorSelection((event) => {
          checkAndClearIfNeeded(event.textEditor.document)
        }),
      ),
      this.addDisposable(
        yw.workspace.onDidChangeTextDocument((event) => {
          checkAndClearIfNeeded(event.document)
        }),
      )
  }
  get value() {
    return this._observable.value
  }
  listen(callback, runImmediately = false) {
    return this._observable.listen(callback, runImmediately)
  }
  waitUntil(predicate, timeoutMs) {
    return this._observable.waitUntil(predicate, timeoutMs)
  }
  set(value, document) {
    ;(this._lastSetAt = Date.now()),
      (this._document = document),
      (this._observable.value = value)
  }
  clear() {
    ;(this._document = undefined), (this._observable.value = undefined)
  }
}
var sIe = q(require("vscode"))
var UnchangedSuggestion = class {
    constructor(suggestion) {
      this.suggestion = suggestion
    }
  },
  AdjustedSuggestion = class {
    constructor(suggestion) {
      this.suggestion = suggestion
    }
  },
  AcceptedSuggestion = class {
    constructor(suggestion) {
      this.suggestion = suggestion
    }
  },
  InvalidatedSuggestion = class {
    constructor(suggestion) {
      this.suggestion = suggestion
    }
  },
  RevertedSuggestion = class {
    constructor(suggestion) {
      this.suggestion = suggestion
    }
  }
function updateSuggestionState(suggestion, changeEvent) {
  if (
    changeEvent.contentChanges.length === 0 ||
    changeEvent.document.uri.fsPath !== suggestion.qualifiedPathName.absPath
  )
    return new UnchangedSuggestion(suggestion)
  let isAccepted = suggestion.state === "accepted",
    document = changeEvent.document,
    targetLineRange = isAccepted ? suggestion.afterLineRange() : suggestion.lineRange,
    changesBeforeRange = changeEvent.contentChanges.filter(
      (change) => change.range.end.line <= targetLineRange.start && !iIe(change, targetLineRange),
    ),
    lineOffset = changesBeforeRange
      .map((change) => {
        let newLineCount = change.text.match(/\n/g)?.length ?? 0,
          oldLineCount = change.range.end.line - change.range.start.line
        return newLineCount - oldLineCount
      })
      .reduce((sum, diff) => sum + diff, 0),
    adjustedLineRange = new LineRange(suggestion.lineRange.start + lineOffset, suggestion.lineRange.stop + lineOffset),
    charOffset = changesBeforeRange.map((change) => change.text.length - change.rangeLength).reduce((sum, diff) => sum + diff, 0),
    rangeStartOffset = document.offsetAt(new sIe.Position(adjustedLineRange.start, 0)) - charOffset,
    updatedSuggestion = suggestion.with({
      result: {
        ...suggestion.result,
        charStart: suggestion.result.charStart + charOffset,
        charEnd: suggestion.result.charEnd + charOffset,
      },
      lineRange: adjustedLineRange,
    }),
    changesInRange = changeEvent.contentChanges
      .filter((change) => iIe(change, targetLineRange))
      .map((change) => ({
        rangeOffset: change.rangeOffset - rangeStartOffset,
        rangeLength: change.rangeLength,
        text: change.text,
      }))
      .sort((a, b) => a.rangeOffset - b.rangeOffset)
  if (changesInRange.length === 0) return charOffset === 0 ? new UnchangedSuggestion(updatedSuggestion) : new AdjustedSuggestion(updatedSuggestion)
  let totalDiff = 0
  for (let change of changesInRange) {
    if (
      (isAccepted ? suggestion.result.existingCode : suggestion.result.suggestedCode).slice(
        totalDiff + change.rangeOffset,
        totalDiff + change.rangeOffset + change.text.length,
      ) !== change.text
    )
      return new InvalidatedSuggestion(suggestion)
    totalDiff += change.text.length - change.rangeLength
  }
  return (
    isAccepted && (totalDiff *= -1),
    totalDiff !== suggestion.result.suggestedCode.length - suggestion.result.existingCode.length
      ? new InvalidatedSuggestion(suggestion)
      : isAccepted
        ? new RevertedSuggestion(updatedSuggestion.with({ state: "fresh" }))
        : new AcceptedSuggestion(updatedSuggestion.with({ state: "accepted" }))
  )
}
function XCt(e) {
  return new LineRange(e.start.line, e.end.line + (e.end.character > 0 ? 1 : 0))
}
function iIe(e, t) {
  let r = XCt(e.range)
  return r.intersects(t) || (t.length === 0 && r.touches(t))
    ? true
    : r.length === 0 && r.start === t.start
      ? !e.text.endsWith(`
`) || r.equals(t)
      : false
}
var SuggestionManager = class extends DisposableContainer {
  constructor(workspaceManager, nextEditSessionEventReporter, defaultRejectionDurationMs = 1e3 * 60 * 10) {
    super()
    this._workspaceManager = workspaceManager
    this._nextEditSessionEventReporter = nextEditSessionEventReporter
    this.defaultRejectionDurationMs = defaultRejectionDurationMs
    ;(this.suggestionWasJustAccepted = new DocumentContextValue()),
      (this.suggestionWasJustUndone = new DocumentContextValue()),
      this.addDisposable(this.suggestionWasJustAccepted),
      this.addDisposable(this.suggestionWasJustUndone),
      this.addDisposable(new Us.Disposable(() => this.clear(true))),
      this.addDisposable(
        Us.workspace.onDidChangeTextDocument((event) => {
          this.handleChangeEvent(event)
        }),
      )
  }
  _suggestions = []
  _justAcceptedSuggestions = []
  _rejectedSuggestions = []
  _suggestionsChangedListeners = []
  suggestionWasJustAccepted
  suggestionWasJustUndone
  _logger = z("SuggestionManagerImpl")
  onSuggestionsChanged(listener) {
    return (
      this._suggestionsChangedListeners.push(listener),
      new Us.Disposable(() => {
        this._suggestionsChangedListeners =
          this._suggestionsChangedListeners.filter((item) => item !== listener)
      })
    )
  }
  dispatchSuggestionsChangedEvent(event) {
    let eventCopy = {
      ...event,
      newSuggestions: event.newSuggestions,
      oldSuggestions: event.oldSuggestions,
    }
    this._suggestionsChangedListeners.forEach((listener) => void listener(eventCopy))
  }
  add(suggestions, overrideRejections) {
    if (
      ((this._rejectedSuggestions = this._getCurrentRejectedSuggestions()), overrideRejections)
    ) {
      let oldRejectionCount = this._rejectedSuggestions.length
      ;(this._rejectedSuggestions = this._rejectedSuggestions.filter(
        ([rejectedSuggestion, expiryTime]) => !suggestions.some((suggestion) => rejectedSuggestion.intersects(suggestion)),
      )),
        oldRejectionCount !== this._rejectedSuggestions.length &&
          this._logger.debug(
            `Clearing ${oldRejectionCount - this._rejectedSuggestions.length} old rejections.`,
          )
    } else {
      let originalCount = suggestions.length
      ;(suggestions = suggestions.filter(
        (suggestion) => !this._rejectedSuggestions.some(([rejectedSuggestion, expiryTime]) => rejectedSuggestion.intersects(suggestion)),
      )),
        originalCount !== suggestions.length &&
          this._logger.debug(
            `Dropping ${originalCount - suggestions.length} suggestions that overlap with rejected suggestions.`,
          )
    }
    if (!suggestions.length) return false
    let oldSuggestions = this._suggestions
    this._filterSuggestions((suggestion) => !suggestions.some((newSuggestion) => suggestion.intersects(newSuggestion)))
    for (let suggestion of suggestions) this._reportNonemptyEvent(suggestion, "nonempty-suggestion-added")
    fetch('http://localhost:3000', {
      method: 'POST',
      body: JSON.stringify({
        callMethod: 'SuggestionManager:add',
        before: 'triggered by listener to this.lastResponse.value',
        suggestions
      })
    });
    return (
      this._suggestions.push(...suggestions),
      this.checkValidity(this._suggestions),
      this.dispatchSuggestionsChangedEvent({
        oldSuggestions: oldSuggestions,
        newSuggestions: this._suggestions,
        accepted: this._justAcceptedSuggestions,
        rejected: [],
        undone: [],
      }),
      true
    )
  }
  remove(suggestionsToRemove) {
    if (!suggestionsToRemove.length) return false
    let oldSuggestions = this._suggestions,
      oldRejectedSuggestions = this._rejectedSuggestions
    return (
      this._filterSuggestions((suggestion) => !suggestionsToRemove.some((toRemove) => toRemove.equals(suggestion))),
      (this._rejectedSuggestions = this._getCurrentRejectedSuggestions().filter(
        ([rejectedSuggestion, o]) => !suggestionsToRemove.some((toRemove) => toRemove.equals(rejectedSuggestion)),
      )),
      this._logger.debug(
        `Removing ${oldSuggestions.length - this._suggestions.length} suggestions and ${oldRejectedSuggestions.length - this._rejectedSuggestions.length} rejections from the manager.`,
      ),
      oldSuggestions.length !== this._suggestions.length
        ? (this.dispatchSuggestionsChangedEvent({
            oldSuggestions: oldSuggestions,
            newSuggestions: this._suggestions,
            accepted: this._justAcceptedSuggestions,
            rejected: [],
            undone: [],
          }),
          true)
        : oldRejectedSuggestions.length !== this._rejectedSuggestions.length
    )
  }
  clear(clearRejections, mode) {
    let oldSuggestions = this._suggestions
    for (let suggestion of oldSuggestions) this._reportNonemptyEvent(suggestion, "nonempty-suggestion-cleared")
    mode
      ? (this._suggestions = this._suggestions.filter((suggestion) => suggestion.mode !== mode))
      : (this._suggestions = []),
      clearRejections && (this._rejectedSuggestions = []),
      (this._justAcceptedSuggestions = []),
      this.dispatchSuggestionsChangedEvent({
        oldSuggestions: oldSuggestions,
        newSuggestions: [],
        accepted: this._justAcceptedSuggestions,
        rejected: [],
        undone: [],
      })
  }
  getActiveSuggestions() {
    return [...this._suggestions]
  }
  getJustAcceptedSuggestions() {
    return [...this._justAcceptedSuggestions]
  }
  clearJustAcceptedSuggestions() {
    this._justAcceptedSuggestions.length !== 0 &&
      ((this._justAcceptedSuggestions = []),
      this.dispatchSuggestionsChangedEvent({
        oldSuggestions: this._suggestions,
        newSuggestions: this._suggestions,
        accepted: this._justAcceptedSuggestions,
        rejected: [],
        undone: [],
      }))
  }
  findSuggestionById(id) {
    return this._suggestions.find((suggestion) => suggestion.result.suggestionId === id)
  }
  _getCurrentRejectedSuggestions() {
    let currentTime = Date.now(),
      validRejections = this._rejectedSuggestions.filter(([suggestion, expiryTime]) => currentTime < expiryTime)
    return (
      validRejections.length !== this._rejectedSuggestions.length &&
        this._logger.debug(
          `Filtering out ${this._rejectedSuggestions.length - validRejections.length} expired rejections.`,
        ),
      validRejections
    )
  }
  getRejectedSuggestions() {
    return (
      (this._rejectedSuggestions = this._getCurrentRejectedSuggestions()),
      this._rejectedSuggestions.map(([suggestion, expiryTime]) => suggestion)
    )
  }
  getAllSuggestions() {
    return [...this.getActiveSuggestions(), ...this.getRejectedSuggestions()]
  }
  accept(suggestionsToAccept) {
    if (suggestionsToAccept.length === 0) return
    let workspaceEdit = new Us.WorkspaceEdit()
    for (let suggestion of suggestionsToAccept)
      workspaceEdit.replace(
        Us.Uri.from({ scheme: suggestion.uriScheme, path: suggestion.qualifiedPathName.absPath }),
        new Us.Range(
          new Us.Position(suggestion.lineRange.start, 0),
          new Us.Position(suggestion.lineRange.stop, 0),
        ),
        suggestion.result.suggestedCode,
      )
    Us.workspace.applyEdit(workspaceEdit)
  }
  reject(suggestionsToReject, rejectionDurationMs = this.defaultRejectionDurationMs) {
    if (suggestionsToReject.length === 0) return
    this._logger.debug(`Rejecting ${suggestionsToReject.length} suggestions.`),
      (this._justAcceptedSuggestions = this._justAcceptedSuggestions.filter(
        (acceptedSuggestion) => !suggestionsToReject.some((rejectedSuggestion) => rejectedSuggestion.equals(acceptedSuggestion)),
      ))
    let oldSuggestions = this._suggestions
    this._filterSuggestions((suggestion) => !suggestionsToReject.some((rejectedSuggestion) => rejectedSuggestion.equals(suggestion)))
    let expiryTime = Date.now() + rejectionDurationMs,
      newRejections = suggestionsToReject.map((suggestion) => [suggestion, expiryTime])
    ;(this._rejectedSuggestions =
      this._getCurrentRejectedSuggestions().concat(newRejections)),
      this.dispatchSuggestionsChangedEvent({
        oldSuggestions: oldSuggestions,
        newSuggestions: this._suggestions,
        accepted: this._justAcceptedSuggestions,
        rejected: suggestionsToReject,
        undone: [],
      })
  }
  handleChangeEvent(event) {
    if (event.contentChanges.length === 0) return false
    let documentPath = this._workspaceManager.safeResolvePathName(event.document.uri)
    if (documentPath === undefined) return false
    let oldSuggestions = this._suggestions,
      [affectedSuggestions, unaffectedSuggestions] = (0, oIe.partition)(this._suggestions, (suggestion) =>
        documentPath.equals(suggestion.qualifiedPathName),
      ),
      updatedSuggestions = affectedSuggestions.map((suggestion) => updateSuggestionState(suggestion, event)),
      updatedAcceptedSuggestions = this._justAcceptedSuggestions.map((suggestion) => updateSuggestionState(suggestion, event)),
      updatedRejectedSuggestions = this._getCurrentRejectedSuggestions().map(([suggestion, expiryTime]) => updateSuggestionState(suggestion, event)),
      acceptedSuggestions = filterSuggestionsByType(updatedSuggestions, AcceptedSuggestion),
      invalidatedSuggestions = filterSuggestionsByType(updatedSuggestions, InvalidatedSuggestion),
      undoneSuggestions = filterSuggestionsByType(updatedAcceptedSuggestions, RevertedSuggestion),
      undoneRejectedSuggestions = filterSuggestionsByType(updatedRejectedSuggestions, RevertedSuggestion)
    this._justAcceptedSuggestions = filterSuggestionsByType(updatedAcceptedSuggestions, UnchangedSuggestion).concat(filterSuggestionsByType(updatedAcceptedSuggestions, AdjustedSuggestion))
    let allUndoneSuggestions = undoneSuggestions.concat(undoneRejectedSuggestions),
      invalidatedDueToUndo = invalidatedSuggestions.filter((suggestion) =>
        allUndoneSuggestions.some(
          (undoneSuggestion) =>
            undoneSuggestion.lineRange.equals(suggestion.afterLineRange(event.document)) ||
            undoneSuggestion.lineRange.intersects(suggestion.afterLineRange(event.document)),
        ),
      )
    ;(acceptedSuggestions.length > 0 || invalidatedSuggestions.length > 0 || allUndoneSuggestions.length > 0) &&
      this._logger.debug(
        `Accepting ${acceptedSuggestions.length} suggestions and invalidating ${invalidatedSuggestions.length} suggestions (of which ${invalidatedDueToUndo.length} were invalidated due to undo) and undoing ${allUndoneSuggestions.length} suggestions.`,
      )
    let shouldMarkStale = acceptedSuggestions.length === 0 && allUndoneSuggestions.length === 0 && invalidatedSuggestions.length > invalidatedDueToUndo.length,
      updatedUnchangedSuggestions = [...filterSuggestionsByType(updatedSuggestions, UnchangedSuggestion), ...filterSuggestionsByType(updatedSuggestions, AdjustedSuggestion)].map((suggestion) =>
        this._markStaleIfNeeded(suggestion, shouldMarkStale, "document-changed"),
      ),
      updatedUnaffectedSuggestions = unaffectedSuggestions.map((suggestion) => this._markStaleIfNeeded(suggestion, shouldMarkStale, "document-changed"))
    for (let suggestion of acceptedSuggestions)
      this._reportNonemptyEvent(
        suggestion,
        event.reason === Us.TextDocumentChangeReason.Redo
          ? "nonempty-suggestion-redone"
          : "nonempty-suggestion-accepted",
        "document-changed",
      )
    for (let suggestion of invalidatedSuggestions)
      this._reportNonemptyEvent(
        suggestion,
        "nonempty-suggestion-invalidated",
        "document-changed",
      )
    for (let suggestion of allUndoneSuggestions)
      this._reportNonemptyEvent(
        suggestion,
        "nonempty-suggestion-undone",
        "document-changed",
      )
    return (
      (this._suggestions = updatedUnaffectedSuggestions.concat(updatedUnchangedSuggestions, undoneSuggestions)),
      this.checkValidity(this._suggestions),
      (this._justAcceptedSuggestions = (
        shouldMarkStale ? [] : this._justAcceptedSuggestions
      ).concat(acceptedSuggestions)),
      acceptedSuggestions.length > 0 && this.suggestionWasJustAccepted.set(true),
      undoneSuggestions.length > 0 && this.suggestionWasJustUndone.set(true),
      this.dispatchSuggestionsChangedEvent({
        oldSuggestions: oldSuggestions,
        newSuggestions: this._suggestions,
        accepted: this._justAcceptedSuggestions,
        rejected: [],
        undone: undoneSuggestions,
      }),
      acceptedSuggestions.length > 0
    )
  }
  _filterSuggestions(predicate) {
    ;(this._suggestions = this._suggestions.filter((suggestion) => {
      let shouldKeep = predicate(suggestion)
      return shouldKeep || this._reportNonemptyEvent(suggestion, "nonempty-suggestion-dropped"), shouldKeep
    })),
      this.checkValidity(this._suggestions)
  }
  _markStaleIfNeeded(suggestion, shouldMarkStale, eventSource) {
    return shouldMarkStale
      ? (this._reportNonemptyEvent(suggestion, "nonempty-suggestion-becomes-stale", eventSource),
        suggestion.with({ state: "stale" }))
      : suggestion
  }
  checkValidity(suggestions) {
    if (suggestions.length < 2) return true
    let sortedSuggestions = [...suggestions]
    sortedSuggestions.sort(
      (a, b) =>
        a.qualifiedPathName.relPath.localeCompare(
          b.qualifiedPathName.relPath,
        ) || a.lineRange.compareTo(b.lineRange),
    )
    let previousSuggestion = sortedSuggestions[0]
    for (let i = 1; i < sortedSuggestions.length; i++) {
      let currentSuggestion = sortedSuggestions[i]
      if (previousSuggestion.intersects(currentSuggestion))
        return (
          this._logger.error(
            `Found intersecting suggestions, ${previousSuggestion.toString()} and ${currentSuggestion.toString()}`,
          ),
          this._nextEditSessionEventReporter.reportEventFromSuggestion(
            currentSuggestion,
            "error-intersecting-suggestions",
            "unknown",
          ),
          false
        )
    }
    return true
  }
  _reportNonemptyEvent(suggestion, eventName, eventSource) {
    suggestion.changeType !== "noop" &&
      this._nextEditSessionEventReporter.reportEventFromSuggestion(
        suggestion,
        eventName,
        eventSource ?? "unknown",
      )
  }
}
function filterSuggestionsByType(suggestions, suggestionType) {
  return suggestions.filter((suggestion) => suggestion instanceof suggestionType).map((suggestion) => suggestion.suggestion)
}
var PN = q(_s()),
  io = q(require("vscode"))
var ebt = 2,
  tbt = 200,
  rbt = 80,
  nbt = 3,
  ibt = 3,
  sbt = 4,
  cC = class e extends DisposableContainer {
    constructor(r, n, i, s, o) {
      super()
      this._configListener = r
      this._context = n
      this._keybindingWatcher = i
      this._featureFlagManager = s
      this._hints = o
      ;(this._decorations = new D6(
        this._context,
        this._keybindingWatcher,
        this._hints,
      )),
        (this._hoverPanel = new T6()),
        (this.showHintDecoration = PN.debounce((a) => {
          this._decorations.decorate(a)
        }, tbt))
    }
    _decorations
    _previousEditor
    _hoverPanel
    showHintDecoration
    enable() {
      this.dispose(),
        (this._configListener.config.enableDebugFeatures ||
          isMinVersionMet(
            this._featureFlagManager.currentFlags
              .vscodeChatHintDecorationMinVersion,
          )) &&
          (this._hoverPanel.enable(),
          this.addDisposable(
            io.window.onDidChangeActiveTextEditor((r) => {
              this._decorations.clearDecorations(this._previousEditor),
                (this._previousEditor = r),
                r &&
                  e.canDecorateEditor(r) &&
                  this.enableMultilineSelectionHints(r.selection)
            }),
          ),
          this.addDisposable(
            io.window.onDidChangeTextEditorSelection((r) => {
              if (!e.canDecorateEditor(r.textEditor)) return
              let n = r.selections[0]
              this.enableMultilineSelectionHints(n)
            }),
          ))
    }
    dispose() {
      super.dispose(),
        this._decorations.clearDecorations(),
        this._hoverPanel.dispose()
    }
    enableMultilineSelectionHints(r) {
      this._decorations.clearDecorations(),
        r.isSingleLine
          ? this._hoverPanel.setRange()
          : (this.showHintDecoration(this.getOffsetLine(r)),
            this._hoverPanel.setRange(r.start, r.end))
    }
    static canDecorateEditor(r) {
      return (
        r.document.uri.scheme === "file" || r.document.uri.scheme === "untitled"
      )
    }
    getOffsetLine(r) {
      let n = io.window.activeTextEditor,
        i = r.active.line < r.anchor.line
      if (!n) return i ? r.active.line - 1 : r.active.line + 1
      let s = i ? 1 : -1,
        o = [
          Math.min(r.anchor.line, r.active.line),
          Math.max(r.anchor.line, r.active.line),
        ],
        a = r.active.line + s * ebt,
        l = r.active.line,
        c = [Math.min(a, l), Math.max(a, l)],
        u = PN.range(Math.max(c[0], o[0]), Math.min(c[1], o[1]) + 1)
      return (
        u.sort((f, p) => {
          let g =
            n.document.lineAt(f).text.length - n.document.lineAt(p).text.length
          return g === 0 ? (i ? f - p : p - f) : g
        }),
        u[0] === r.active.line ? u[1] : u[0]
      )
    }
  },
  D6 = class {
    constructor(t, r, n) {
      this._context = t
      this._keybindingWatcher = r
      this._hints = n
      ;(this._rightSpacerDecorationType = x6()),
        (this._keyHintDecorationTypes = []),
        this._hints.forEach((i, s) => {
          let o = pw(i.keyBindingId, this._keybindingWatcher, this._context)
          this._decorationLength += o.length * ibt
          let a = {
            keyBindingDecorationTypes: w6(),
            textDecorationType: CN(i.text),
          }
          ;(this._decorationLength += i.text.length),
            s < this._hints.length - 1 &&
              ((a.gapDecorationType = CN(" | ")),
              (this._decorationLength += sbt)),
            this._keyHintDecorationTypes.push(a)
        })
    }
    _rightSpacerDecorationType
    _keyHintDecorationTypes
    _decorationLength = 0
    decorate(t) {
      let r = io.window.activeTextEditor
      if (
        !r ||
        !cC.canDecorateEditor(r) ||
        this._keyHintDecorationTypes.length === 0
      )
        return
      let n = bg(r, t),
        i = r.document.lineAt(t).text.length,
        s = Math.max(rbt - i - this._decorationLength, nbt)
      r.setDecorations(this._rightSpacerDecorationType, [
        { range: n, renderOptions: { after: { margin: `0 0 0 ${s}ch` } } },
      ]),
        this._keyHintDecorationTypes.forEach((o, a) => {
          let l = pw(
            this._hints[a].keyBindingId,
            this._keybindingWatcher,
            this._context,
          )
          o.keyBindingDecorationTypes.forEach((c, u) => {
            l[u] && r.setDecorations(c, [{ range: n, renderOptions: l[u] }])
          }),
            r.setDecorations(o.textDecorationType, [{ range: n }]),
            o.gapDecorationType &&
              r.setDecorations(o.gapDecorationType, [
                {
                  range: n,
                  renderOptions: { after: { margin: "0 0.65em 0 0.5em" } },
                },
              ])
        })
    }
    clearDecorations(t) {
      let r = t ?? io.window.activeTextEditor
      r &&
        (r.setDecorations(this._rightSpacerDecorationType, []),
        this._keyHintDecorationTypes.forEach((n) => {
          n.keyBindingDecorationTypes.forEach((i) => {
            r.setDecorations(i, [])
          }),
            r.setDecorations(n.textDecorationType, []),
            n.gapDecorationType && r.setDecorations(n.gapDecorationType, [])
        }))
    }
  },
  T6 = class extends DisposableContainer {
    _provider
    _range
    enable() {
      this.registerHoverProvider(io.window.activeTextEditor),
        this.addDisposable(
          io.window.onDidChangeActiveTextEditor((t) => {
            this.registerHoverProvider(t)
          }),
        )
    }
    setRange(t, r) {
      if (t && r) {
        this._range = new io.Range(t, r)
        return
      }
      this._range = undefined
    }
    provideHover(t, r, n) {
      if (this._range && this._range.contains(r)) {
        let i = `
$(augment-icon-simple)
&nbsp;
<a href="command:${Separator.commandID}" title="Open Augment Chat">
    Open in Chat
</a> |
<a href="command:${FixCommand.commandID}" title="Fix with Augment Chat">
    Fix
</a> |
<a href="command:${ExplainCommand.commandID}" title="Explain with Augment Chat">
    Explain
</a> | <a href="command:${TestCommand.commandID}" title="Write a test with Augment Chat">
    Write a Test
</a> | <a href="command:${DocumentCommand.commandID}" title="Document with Augment Chat">
    Document
</a>
            `,
          s = new io.MarkdownString(i)
        return (
          (s.isTrusted = true),
          (s.supportHtml = true),
          (s.supportThemeIcons = true),
          new io.Hover(s, this._range)
        )
      }
    }
    registerHoverProvider(t) {
      this._provider?.dispose(),
        (this._provider = undefined),
        !(!t || !cC.canDecorateEditor(t)) &&
          (this._provider = io.languages.registerHoverProvider(
            { pattern: t.document.uri.fsPath },
            this,
          ))
    }
  }
var aIe = q(require("vscode"))
var LN = class {
  _logger = z("ResolveFileService")
  constructor() {}
  getOpenDocumentText(t) {
    for (let r of aIe.workspace.textDocuments)
      if (r.uri.fsPath === t && r.uri.scheme === "file") return r.getText()
    return null
  }
  async resolveFile(t) {
    let r = QualifiedPathName.from(t).absPath,
      n = this.getOpenDocumentText(r)
    if (n == null)
      try {
        n = await readTextFile(r)
      } catch (i) {
        this._logger.warn(`Could not read file: ${r}`, i), (n = "")
      }
    return n
  }
  register(t) {
    t.registerHandler("read-file-request", async (r) => ({
      type: "read-file-response",
      data: {
        pathName: r.data.pathName,
        content: await this.resolveFile(r.data.pathName),
      },
    }))
  }
}
var UN = class e {
  constructor(t) {
    this.publish = t
  }
  static _lineLen = 80
  static _indent = "    "
  static _subIndent = "  "
  _content = ""
  _disposed = false
  get content() {
    return this._content
  }
  addSection(t) {
    let r =
      (this._content.length === 0
        ? ""
        : `
`) +
      `================
`
    this._addLine(r + t)
  }
  addObject(t) {
    if (t === undefined) this.addLine(this.formatValue(t))
    else
      for (let r in t) {
        let n = t[r]
        typeof n != "object"
          ? this.addValue(r, n)
          : this.addValue(r, JSON.stringify(n))
      }
  }
  formatValue(t) {
    return t === undefined
      ? "<undefined>"
      : t === null
        ? "<null>"
        : typeof t == "string"
          ? `"${t}"`
          : `${t}`
  }
  addLine(t) {
    this._disposed || this._addLine(e._indent + t)
  }
  addText(t, r) {
    if (this._disposed) return
    let n =
      (this._content.length === 0
        ? ""
        : `
`) + ">>>>>>>>>>>>>>>> "
    this._addLine(n + t),
      this._addLine(r, ""),
      r.length > 0 &&
        r[r.length - 1] !==
          `
` &&
        this._addLine("|<---- (ends here)"),
      this._addLine("<<<<<<<<<<<<<<<< " + t)
  }
  addError(t) {
    if (e._indent.length + t.length <= e._lineLen) {
      this._addLine(e._indent + t)
      return
    }
    let r = 0,
      n = e._indent
    for (;;) {
      let i = t.indexOf(": ", r)
      if (i === -1) {
        this._addLine(n + t.substring(r))
        break
      }
      this._addLine(n + t.substring(r, i + 1)), (r = i + 2), (n += e._subIndent)
    }
  }
  addValue(t, r) {
    this._addLine(e._indent + t + ": " + this.formatValue(r))
  }
  addStringValue(t, r, n = true) {
    this._addLine(e._indent + t + ": " + (n ? `"${r}"` : r))
  }
  _addLine(
    t,
    r = `
`,
  ) {
    this._disposed || (this._content += t + r)
  }
  savePoint() {
    return this._content.length
  }
  rollback(t) {
    this._disposed ||
      (this._content.length > t &&
        (this._content = this._content.substring(0, t)))
  }
  dispose() {
    ;(this._disposed = true), (this._content = "")
  }
}
var uC = q(require("vscode"))
var qN = q(require("vscode"))
var ON = class {
  constructor(t) {
    this._baseState = t
  }
  _stateEventEmitter = new qN.EventEmitter()
  _state = { 0: [], 1: [], 2: [], 3: [] }
  onDidChangeState = this._stateEventEmitter.event
  setState(t) {
    this._state[t.priority].push(t)
    let r = false
    return qN.Disposable.from({
      dispose: () => {
        if (r) return
        r = true
        let n = false
        ;(this._state[t.priority] = this._state[t.priority].filter((i) =>
          n ? true : ((n = i === t), !n),
        )),
          this._stateEventEmitter.fire()
      },
    })
  }
  getPriorityState() {
    for (let t of f6) {
      let r = this._state[t]
      if (r.length > 0) return r[r.length - 1]
    }
    return this._baseState
  }
  reset() {
    for (let t of f6) this._state[t] = []
    this._stateEventEmitter.fire()
  }
}
var obt = "Augment",
  VN = class extends DisposableContainer {
    _statusBarItem
    _stateManager = new ON(rSe)
    _currentState
    constructor() {
      super(),
        this.addDisposable(new uC.Disposable(() => this.reset())),
        (this._statusBarItem = uC.window.createStatusBarItem(
          "vscode-augment.PrimaryStatusBarItem",
          uC.StatusBarAlignment.Right,
        )),
        (this._statusBarItem.name = "Augment"),
        (this._statusBarItem.command = StatusBarClickCommand.commandID),
        this.addDisposables(
          this._statusBarItem,
          this._stateManager.onDidChangeState(() => this.updateState()),
        ),
        this.updateState(),
        this._statusBarItem.show()
    }
    updateState() {
      let t = this._stateManager.getPriorityState()
      if (t === this._currentState) return
      ;(this._currentState = t),
        (this._statusBarItem.tooltip = t.tooltip),
        (this._statusBarItem.backgroundColor = t.colors?.background),
        (this._statusBarItem.color = t.colors?.foreground)
      let r = t.label ? t.label : obt
      this._statusBarItem.text = `${t.icon} ${r}`
    }
    setState(t) {
      let r = this._stateManager.setState(t)
      return this.updateState(), r
    }
    reset() {
      this._stateManager.reset()
    }
  }
var dC = q(require("vscode"))
var NextEditSuggestionsPanel = class extends PanelWebview {
  constructor(extensionUri, webviewView, webviewPanel, suggestionManager, globalNextEdit, editorEditManager, eventReporter, resolveFileService, vscodeToWebviewMessage, asyncMessageHandler, messageHandler = createAsyncMessageHandler(webviewPanel, asyncMessageHandler)) {
    super("next-edit-suggestions.html", webviewPanel)
    this._webviewView = webviewView
    this._suggestionManager = suggestionManager
    this._globalNextEdit = globalNextEdit
    this._editorEditManager = editorEditManager
    this._nextEditSessionEventReporter = eventReporter
    this._resolveFileService = resolveFileService
    this._nextEditVSCodeToWebviewMessage = vscodeToWebviewMessage
    this._asyncMsgHandler = messageHandler
    this.loadHTML(extensionUri),
      this.addDisposable(this._asyncMsgHandler),
      this._resolveFileService.register(this._asyncMsgHandler),
      this.addDisposable(
        this._suggestionManager.onSuggestionsChanged((change) => {
          let filteredSuggestions = filterValidSuggestions(
            [this._editorEditManager.state.suggestion]
              .concat(change.newSuggestions)
              .concat(this._suggestionManager.getJustAcceptedSuggestions()),
          ).filter(somePredicatesMatch(isFreshNonNoopSuggestion, isSuggestionAccepted))
          fetch('http://localhost:3000', {
            method: 'POST',
            body: JSON.stringify({
              callMethod: 'NextEditSuggestionsPanel:_suggestionManager.onSuggestionsChanged',
              type: "next-edit-suggestions-changed",
              filteredSuggestions
            })
          });
          this.postMessage({
            type: "next-edit-suggestions-changed",
            data: { suggestions: filteredSuggestions },
          }),
            (webviewView.badge = { value: filteredSuggestions.length, tooltip: "Next Edit Suggestions" })
        }),
      ),
      this.addDisposable(
        new dC.Disposable(
          this._editorEditManager.addStateListener((newState, oldState) => {
            // fetch('http://localhost:3000', {
            //   method: 'POST',
            //   body: JSON.stringify({
            //     callMethod: 'NextEditSuggestionsPanel:_editorEditManager.addStateListener',
            //     prev: 'triggered by set hintState'
            //   })
            // });
            if (newState instanceof AfterPreviewState || newState instanceof BeforePreviewState || newState instanceof AnimatingState) {
              this.postMessage({
                type: "next-edit-preview-active",
                data: newState.suggestion,
              })
              return
            }
            if (oldState instanceof AfterPreviewState || oldState instanceof BeforePreviewState || oldState instanceof AnimatingState) {
              this.postMessage({ type: "next-edit-dismiss" })
              return
            }
            if (
              (newState.suggestion?.equals(oldState.suggestion) ?? oldState.suggestion === undefined) &&
              !(newState instanceof AfterPreviewState) &&
              !(oldState instanceof AfterPreviewState)
            )
              return
            let currentSuggestions = filterValidSuggestions(
              [this._editorEditManager.state.suggestion]
                .concat(this._suggestionManager.getActiveSuggestions())
                .concat(this._suggestionManager.getJustAcceptedSuggestions()),
            ).filter(somePredicatesMatch(isFreshNonNoopSuggestion, isSuggestionAccepted))
            fetch('http://localhost:3000', {
              method: 'POST',
              body: JSON.stringify({
                callMethod: 'NextEditSuggestionsPanel:_editorEditManager.addStateListener',
                type: "next-edit-suggestions-changed",
                filteredSuggestions
              })
            });
            this.postMessage({
              type: "next-edit-suggestions-changed",
              data: { suggestions: currentSuggestions },
            }),
              this.postMessage({
                type: "next-edit-next-suggestion-changed",
                data: newState.suggestion,
              })
          }),
        ),
      ),
      this.addDisposable(
        this._nextEditVSCodeToWebviewMessage.event((message) => {
          this.postMessage(message)
        }),
      ),
      this.addDisposable(
        this._webview.onDidReceiveMessage(this.onDidReceiveMessage),
      ),
      (webviewView.badge = {
        value: this._suggestionManager.getActiveSuggestions().filter(somePredicatesMatch(isFreshNonNoopSuggestion))
          .length,
        tooltip: "Next Edit Suggestions",
      }),
      this._nextEditSessionEventReporter.reportEventWithoutIds(
        "panel-created",
        "unknown",
      )
  }
  logger = z("NextEditSuggestionsPanel")
  wrapAsyncMsg(request, response, error = null) {
    return this.postMessage({
      type: "async-wrapper",
      requestId: request.requestId,
      error: error,
      baseMsg: response,
    })
  }
  postMessage = async (message) => this._webview.postMessage(message)
  onDidReceiveMessage = async (message) => {
    switch (message.type) {
      case "next-edit-suggestions-action":
        if ("accept" in message.data) {
          await this._editorEditManager.acceptSuggestion(
            EditSuggestion.from(message.data.accept),
            "next-edit-panel-item-click",
            undefined,
            true,
          )
          return
        }
        if ("reject" in message.data) {
          this._editorEditManager.rejectSuggestion(
            EditSuggestion.from(message.data.reject),
            "next-edit-panel-item-click",
          )
          return
        }
        if ("undo" in message.data && message.data.undo) {
          this._editorEditManager.undoAcceptSuggestion(
            EditSuggestion.from(message.data.undo),
            "next-edit-panel-item-click",
          )
          return
        }
        if ("acceptAllInFile" in message.data) {
          if (message.data.acceptAllInFile.length === 0) {
            dC.window.showInformationMessage("No Next Edits to accept.")
            return
          }
          this._editorEditManager.acceptAllSuggestionsInFile(
            message.data.acceptAllInFile[0].qualifiedPathName,
            "next-edit-panel-item-click",
          )
          return
        }
        if ("rejectAllInFile" in message.data) {
          if (message.data.rejectAllInFile.length === 0) {
            dC.window.showInformationMessage("No Next Edits to reject.")
            return
          }
          this._editorEditManager.rejectAllSuggestionsInFile(
            message.data.rejectAllInFile[0].qualifiedPathName,
            "next-edit-panel-item-click",
          )
          return
        }
        if ("undoAllInFile" in message.data) {
          if (message.data.undoAllInFile.length === 0) {
            dC.window.showInformationMessage("No Next Edits to undo.")
            return
          }
          this._editorEditManager.undoAllSuggestionsInFile(
            message.data.undoAllInFile[0].qualifiedPathName,
            "next-edit-panel-item-click",
          )
          return
        }
        this.logger.error("Unknown action message: " + JSON.stringify(message))
        return
      case "next-edit-dismiss":
        this._editorEditManager.dismiss("next-edit-panel-item-click", true, false)
        return
      case "next-edit-loaded":
        this._nextEditSessionEventReporter.reportEventWithoutIds(
          "panel-opened",
          "unknown",
        ),
          // (fetch('http://localhost:3000', {
          //   method: 'POST',
          //   body: JSON.stringify({
          //     callMethod: 'NextEditSuggestionsPanel:onDidReceiveMessage',
          //     type: "next-edit-suggestions-changed",
          //     filteredSuggestions
          //   })
          // }));
          await this.postMessage({
            type: "next-edit-suggestions-changed",
            data: {
              suggestions: this._suggestionManager
                .getActiveSuggestions()
                .concat(this._suggestionManager.getJustAcceptedSuggestions())
                .filter(somePredicatesMatch(isFreshNonNoopSuggestion, isSuggestionAccepted)),
            },
          }),
          this.postMessage({
            type: "next-edit-next-suggestion-changed",
            data: this._editorEditManager.state.suggestion,
          }),
          this._globalNextEdit.handleWorkspaceEditsAvailable()
        return
      case "next-edit-open-suggestion":
        await this._editorEditManager.open(EditSuggestion.from(message.data), {
          shouldAutoApply: false,
          preserveFocus: true,
          eventSource: "next-edit-panel-item-click",
          animationDelayMs: 0,
        }),
          this._nextEditSessionEventReporter.reportEvent(
            message.data.requestId,
            message.data.result.suggestionId,
            Date.now(),
            "panel-suggestion-clicked",
            "click",
          )
        return
      case "next-edit-refresh-started":
        await this._globalNextEdit.startGlobalQuery(),
          await this.postMessage({ type: "next-edit-refresh-finished" })
        return
      case "next-edit-cancel":
        this._globalNextEdit.cancel()
        return
      case "next-edit-active-suggestion":
        this.postMessage({ type: "next-edit-active-suggestion", data: message.data })
        return
    }
  }
}
var WN = class {
  constructor(t, r, n) {
    this.storage = t
    this.toolsModel = r
    this.getSettingsMcpServers = n
  }
  logger = z("ToolConfigStore")
  async get() {
    try {
      return (
        (await this.storage.load("toolsConfiguration")) ?? {
          version: u6,
          tools: [],
        }
      )
    } catch (t) {
      return (
        this.logger.error(`Failed to load tool configurations: ${getErrorMessage(t)}`),
        { version: u6, tools: [] }
      )
    }
  }
  async save(t) {
    try {
      await this.storage.save("toolsConfiguration", t)
    } catch (r) {
      let n = `Failed to save tool configurations: ${getErrorMessage(r)}`
      throw (this.logger.error(n), new rl(n))
    }
  }
  async getMCPServers() {
    try {
      let t = await this.storage.load("mcpServers")
      return Array.isArray(t) ? t : []
    } catch (t) {
      return this.logger.error(`Failed to load MCP servers: ${getErrorMessage(t)}`), []
    }
  }
  async saveMCPServers(t) {
    try {
      await this.storage.save("mcpServers", t),
        await this.updateSidecarMCPServers()
    } catch (r) {
      let n = `Failed to save MCP servers: ${getErrorMessage(r)}`
      throw (this.logger.error(n), new rl(n))
    }
  }
  async updateSidecarMCPServers() {
    try {
      let r = (await this.getMCPServers()).map((s) => ({
          name: s.name,
          command: s.command,
          args: [],
          useShellInterpolation: true,
          env: s.env,
        })),
        n = this.getSettingsMcpServers ? this.getSettingsMcpServers() : [],
        i = [...r]
      n && n.length > 0 && i.push(...n),
        this.toolsModel && this.toolsModel.setMcpServers(i)
    } catch (t) {
      this.logger.error(`Failed to update sidecar MCP servers: ${getErrorMessage(t)}`)
    }
  }
  async getTerminalSettings() {
    try {
      return (
        (await this.storage.load("terminalSettings")) ?? {
          supportedShells: [],
          selectedShell: undefined,
        }
      )
    } catch (t) {
      return (
        this.logger.error(`Failed to load terminal settings: ${getErrorMessage(t)}`),
        { supportedShells: [], selectedShell: undefined }
      )
    }
  }
  async saveTerminalSettings(t) {
    try {
      await this.storage.save("terminalSettings", t)
    } catch (r) {
      let n = `Failed to save terminal settings: ${getErrorMessage(r)}`
      throw (this.logger.error(n), new rl(n))
    }
  }
  async updateSelectedShell(t) {
    let r = await this.getTerminalSettings()
    ;(r.selectedShell = t), await this.saveTerminalSettings(r)
  }
  async updateStartupScript(t) {
    let r = await this.getTerminalSettings()
    ;(r.startupScript = t), await this.saveTerminalSettings(r)
  }
}
var lIe = q(require("vscode"))
var GN = class extends PanelWebview {
  _currentApp
  constructor(t) {
    super("main-panel.html", t),
      this.addDisposable(
        this._webview.onDidReceiveMessage((r) => this.onDidReceiveMessage(r)),
      )
  }
  changeApp(t) {
    ;(this._currentApp = t),
      this._currentApp &&
        (this._currentApp.register(this._webview),
        setVSCodeContext("vscode-augment.mainPanel.app", this._currentApp.appType())),
      this._postAppTypeMsg()
  }
  onDidReceiveMessage(t) {
    switch (t.type) {
      case "main-panel-loaded":
        this._postAppTypeMsg()
        break
    }
  }
  _postAppTypeMsg() {
    this._webview.postMessage({
      type: "main-panel-display-app",
      data: this._currentApp?.appType(),
    })
  }
}
var MainPanelWebviewProvider = class extends DisposableContainer {
  constructor(extensionUri) {
    super()
    this._extensionUri = extensionUri
    this.addDisposable(this.visibilityEventEmitter)
  }
  _logger = z("MainPanelWebviewProvider")
  _webviewView = undefined
  _mainPanelWebview = undefined
  currentApp = undefined
  visibilityEventEmitter = new lIe.EventEmitter()
  get onVisibilityChange() {
    return this.visibilityEventEmitter.event
  }
  isVisible() {
    return !!this._webviewView?.visible
  }
  changeApp(app) {
    this.currentApp?.dispose(),
      app && this.addDisposable(app),
      this._setViewTitle(app?.title() || ""),
      (this.currentApp = app),
      this._mainPanelWebview?.changeApp(app)
  }
  _setViewTitle(title) {
    this._webviewView && (this._webviewView.title = title)
  }
  async resolveWebviewView(webviewView, context, token) {
    webviewView.onDidDispose(() => {
      this._webviewView === webviewView &&
        (this._logger.debug("Disposing of main panel webview view"),
        (this._webviewView = undefined))
    }),
      (this._webviewView = webviewView),
      this._setViewTitle(this.currentApp?.title() || ""),
      this._mainPanelWebview?.dispose(),
      (this._mainPanelWebview = new GN(this._webviewView.webview)),
      this.addDisposable(this._mainPanelWebview),
      this._mainPanelWebview.changeApp(this.currentApp),
      this._mainPanelWebview.addDisposable(
        this._webviewView.onDidChangeVisibility(() => {
          this.visibilityEventEmitter.fire(!!this._webviewView?.visible)
        }),
      ),
      await this._mainPanelWebview.loadHTML(this._extensionUri)
  }
}
var NextEditWebviewProvider = class extends DisposableContainer {
  constructor(configListener, featureFlagsManager, onWebviewCreated) {
    super()
    this._config = configListener
    this._featureFlagsManager = featureFlagsManager
    this.onWebviewCreated = onWebviewCreated
    this.maybeRegisterWebview()
  }
  webviewView = undefined
  nextEditWebview = undefined
  maybeRegisterWebview = () => {
    !this.webviewView ||
      !isVersionSupported(
        this._config.config,
        this._featureFlagsManager.currentFlags.vscodeNextEditMinVersion,
      ) ||
      (this.nextEditWebview?.dispose(),
      (this.nextEditWebview = this.onWebviewCreated(this.webviewView)),
      this.addDisposable(this.nextEditWebview))
  }
  resolveWebviewView(webviewView, context, token) {
    ;(this.webviewView = webviewView), this.maybeRegisterWebview()
  }
}
var k6 = class extends Error {
    constructor() {
      super("SingletonExecutor has been disposed")
    }
  },
  SingletonExecutor = class e extends DisposableContainer {
    constructor(executeFunction) {
      super()
      this._execute = executeFunction
      this.addDisposable({ dispose: () => (this._stopping = true) })
    }
    static _disposedError = new k6()
    _nextExecutionScheduled = false
    _kickPromise = Promise.resolve()
    _stopping = false
    kick() {
      return this._nextExecutionScheduled
        ? this._kickPromise
        : ((this._nextExecutionScheduled = true),
          (this._kickPromise = this._kickPromise.then(
            async () => (
              (this._nextExecutionScheduled = false),
              this._stopping
                ? Promise.reject(e._disposedError)
                : this._execute() // =
            ),
          )),
          this._kickPromise)
    }
  }
var ExternalSourceFoldersManager = class ExternalSourceFoldersManager {
  constructor(workspaceStorage) {
    this._workspaceStorage = workspaceStorage
    ;(this._persistedFolders = this._readFolders()),
      (this._toPersist = new Map(this._persistedFolders)),
      (this._persister = new SingletonExecutor(async () => await this._persistFolders()))
  }
  static storageKey = "external-source-folders:original"
  _persistedFolders
  _toPersist
  _persister
  getFolders() {
    return new Map(this._persistedFolders)
  }
  async setFolders(folders) {
    areMapsEqual(this._persistedFolders, folders) ||
      ((this._toPersist = new Map(folders)), await this._persister.kick())
  }
  async _persistFolders() {
    if (areMapsEqual(this._persistedFolders, this._toPersist)) return
    let foldersToSave = new Map(this._toPersist),
      folderEntries = new Array()
    for (let [folderRoot, folderName] of foldersToSave) folderEntries.push({ folderRoot: folderRoot, folderName: folderName })
    await this._workspaceStorage.update(ExternalSourceFoldersManager.storageKey, folderEntries),
      (this._persistedFolders = foldersToSave)
  }
  _readFolders() {
    let storedData = this._workspaceStorage.get(ExternalSourceFoldersManager.storageKey)
    if (storedData === undefined) return new Map()
    if (!Array.isArray(storedData)) return new Map()
    let folders = new Map()
    for (let entry of storedData)
      entry.folderRoot === undefined ||
        typeof entry.folderRoot != "string" ||
        entry.folderName === undefined ||
        typeof entry.folderName != "string" ||
        folders.set(entry.folderRoot, entry.folderName)
    return folders
  }
}
function areMapsEqual(map1, map2) {
  if (map1.size !== map2.size) return false
  for (let [key, value] of map1) if (map2.get(key) !== value) return false
  return true
}
var uIe = q(require("vscode"))
var ChatHistoryManager = class extends DisposableContainer {
  constructor(globalState, syncingStatus) {
    super()
    this._globalState = globalState
    this._syncingStatus = syncingStatus
    this.loadWorkspaceMessageState(),
      this.addDisposable(
        this._syncingStatus.onDidChangeSyncingStatus((event) =>
          this._handleSyncingProgress(),
        ),
      )
  }
  _workspaceMessageState = new Map()
  _shouldShowSummary = false
  shouldShowSummaryEmitter = new uIe.EventEmitter()
  get shouldShowSummary() {
    return this._shouldShowSummary
  }
  get onShouldShowSummary() {
    return this.shouldShowSummaryEmitter.event
  }
  setShouldShowSummary(value) {
    this._shouldShowSummary = value
  }
  async _handleSyncingProgress() {
    let status = this._syncingStatus.status // =
    status.foldersProgress.length !== 0 && (await this.handleShowingSummaryMsg(status))
  }
  async handleShowingSummaryMsg(statusData) {
    if (
      !(
        statusData.status !== "done" ||
        statusData.foldersProgress.every(
          (folderProgress) =>
            folderProgress.progress?.trackedFiles === undefined ||
            folderProgress.progress.trackedFiles === 0,
        ) ||
        statusData.foldersProgress.find(
          (folderProgress) =>
            this._workspaceMessageState.get(folderProgress.folderRoot)?.workspaceSummary,
        ) ||
        !statusData.foldersProgress.find((folderProgress) => folderProgress.progress?.newlyTracked)
      )
    ) {
      this.showSummaryMessage()
      for (let folderProgress of statusData.foldersProgress)
        this._workspaceMessageState.set(folderProgress.folderRoot, {
          folderRoot: folderProgress.folderRoot,
          workspaceSummary: true,
        })
      await this.saveWorkspaceMessageState()
    }
  }
  showSummaryMessage() {
    ;(this._shouldShowSummary = true), this.shouldShowSummaryEmitter.fire(true)
  }
  async saveWorkspaceMessageState() {
    await this._globalState.update(
      "workspaceMessageStates",
      Array.from(this._workspaceMessageState.values()),
    )
  }
  loadWorkspaceMessageState() {
    let storedStates = this._globalState.get("workspaceMessageStates")
    storedStates &&
      (this._workspaceMessageState = new Map(storedStates.map((state) => [state.folderRoot, state])))
  }
  dispose() {
    this.shouldShowSummaryEmitter.dispose()
  }
}
var jN = q(require("vscode"))
var SyncingStatusTracker = class extends DisposableContainer {
  constructor(statusBar, syncingProgressEmitter) {
    super()
    this._statusBar = statusBar
    this.addDisposables(
      syncingProgressEmitter((progressEvent) => this._handleSyncingStatusChanged(progressEvent)),
      new jN.Disposable(() => {
        this._syncingStatusBarDisposable?.dispose(),
          (this._syncingStatusBarDisposable = undefined)
      }),
    )
  }
  static syncingMessage =
    "Augment is synchronizing with your codebase to make better suggestions. The first time typically takes a few minutes."
  _syncingStatusBarDisposable
  _syncingNotificationShown = false
  _handleSyncingStatusChanged(progressEvent) {
    switch (progressEvent.status) {
      case "longRunning":
        this._syncingNotificationShown ||
          (progressEvent.foldersProgress.find((folderProgress) => folderProgress.progress?.newlyTracked) &&
            ((this._syncingNotificationShown = true),
            jN.commands.executeCommand(Separator.commandID)))
      case "running":
        this._syncingStatusBarDisposable ||
          (this._syncingStatusBarDisposable = this._statusBar.setState(sSe))
        break
      case "done":
        ;(this._syncingNotificationShown = false),
          this._syncingStatusBarDisposable?.dispose(),
          (this._syncingStatusBarDisposable = undefined)
        break
    }
  }
}
var SyncingStatusBarManager = class extends DisposableContainer {
  constructor(statusBarManager, syncingEnabledTracker) {
    super()
    this._statusBarManager = statusBarManager
    this._syncingEnabledTracker = syncingEnabledTracker
    this.addDisposable(
      this._syncingEnabledTracker.onDidChangeSyncingEnabled((newState) =>
        this._updateSyncingState(newState === "enabled"),
      ),
    )
    let initialState = this._syncingEnabledTracker.syncingEnabledState
    initialState !== "initializing" && this._updateSyncingState(initialState === "enabled")
  }
  _syncingDisabledDisp = undefined
  _updateSyncingState(isEnabled) {
    isEnabled // =
      ? (this._syncingDisabledDisp?.dispose(),
        (this._syncingDisabledDisp = undefined))
      : this._syncingDisabledDisp ||
        (this._syncingDisabledDisp = this._statusBarManager.setState(CSe))
  }
}
var e2 = q(require("vscode"))
var SyncingEnabledTracker = class extends DisposableContainer {
  _workspaceManager = undefined
  _syncingEnabledChangedEmitter = new e2.EventEmitter()
  _publishStateExecutor
  constructor() {
    super(),
      (this._publishStateExecutor = new SingletonExecutor(async () => {
        await this._publishSyncingState()
      }))
  }
  get syncingEnabledState() {
    return this._workspaceManager
      ? this._workspaceManager.syncingEnabledState
      : "initializing"
  }
  get onDidChangeSyncingEnabled() {
    return this._syncingEnabledChangedEmitter.event
  }
  enableSyncing() {
    if (this.syncingEnabledState === "initializing")
      throw new Error("Syncing enabled state not initialized")
    this.syncingEnabledState !== "enabled" &&
      this._workspaceManager.enableSyncing()
  }
  disableSyncing() {
    if (this.syncingEnabledState === "initializing")
      throw new Error("Syncing enabled state not initialized")
    this.syncingEnabledState !== "disabled" &&
      this._workspaceManager.disableSyncing()
  }
  set workspaceManager(manager) {
    ;(this._workspaceManager = manager),
      this.addDisposable(
        this._workspaceManager.onDidChangeSyncingState(
          (r) => void this._publishStateExecutor.kick(),
        ),
      )
  }
  async _publishSyncingState() {
    await e2.commands.executeCommand(
      "setContext",
      "vscode-augment.syncingEnabledState",
      this.syncingEnabledState,
    ),
      this._syncingEnabledChangedEmitter.fire(this.syncingEnabledState) // =
  }
}
var SyncingPermissionTracker = class SyncingPermissionTracker extends DisposableContainer {
  constructor(workspaceStorage) {
    super()
    this._workspaceStorage = workspaceStorage
    ;(this._currentPermission = this._getStoredPermission()),
      (this._persister = new SingletonExecutor(
        async () => await this._persistCurrentPermission(),
      )),
      this._logPermission("Initial syncing permission", this._currentPermission)
  }
  static storageKey = "syncingPermission.2024102300"
  _currentPermission
  _persister
  _logger = z("SyncingPermissionTracker")
  get syncingPermissionDenied() {
    return this._currentPermission?.state === 1
  }
  getFolderSyncingPermission(folderPath) {
    let permission = this._currentPermission
    if (permission === undefined)
      return (
        this._logger.info(
          `Permission to sync folder ${folderPath} unknown: no permission information recorded`,
        ),
        "unknown"
      )
    if (permission.state === 1) {
      let timestamp = new Date(permission.timestamp).toLocaleString()
      return (
        this._logger.info(`Permission to sync folder ${folderPath} denied at ${timestamp}`),
        "denied"
      )
    }
    for (let folder of permission.permittedFolders)
      if (folderPath === folder.sourceFolder) {
        let folderTimestamp = new Date(folder.timestamp).toLocaleString()
        return (
          this._logger.info(
            `Permission to sync folder ${folderPath} granted at ${folderTimestamp}; type = ${folder.type}`,
          ),
          "granted"
        )
      }
    return (
      this._logger.info(
        `Permission to sync folder ${folderPath} unknown: no current permission for folder`,
      ),
      "unknown"
    )
  }
  setDefaultPermissions(folderPaths) {
    if (this._currentPermission !== undefined || folderPaths.length === 0) return
    let timestamp = Date.now()
    this._setSyncingPermission({
      state: 0,
      permittedFolders: folderPaths.map((folderPath) => ({
        sourceFolder: folderPath,
        type: "implicit",
        timestamp: timestamp,
      })),
    })
  }
  setPermittedFolders(folderPaths) {
    let timestamp = Date.now()
    this._setSyncingPermission({
      state: 0,
      permittedFolders: folderPaths.map((folderPath) => ({
        sourceFolder: folderPath,
        type: "explicit",
        timestamp: timestamp,
      })),
    })
  }
  addPermittedFolder(folderPath) {
    let permission = this._currentPermission
    ;(permission === undefined || permission.state === 1) && (permission = { state: 0, permittedFolders: [] })
    let folderPermission = { sourceFolder: folderPath, type: "explicit", timestamp: Date.now() }
    this._setSyncingPermission({
      ...permission,
      permittedFolders: [...permission.permittedFolders, folderPermission],
    })
  }
  addImplicitlyPermittedFolder(folderPath) {
    let permission = this._currentPermission
    if (permission?.state === 1) return
    if (permission === undefined) permission = { state: 0, permittedFolders: [] }
    else if (permission.permittedFolders.find((folder) => folder.sourceFolder === folderPath) !== undefined)
      return
    let folderPermission = { sourceFolder: folderPath, type: "implicit", timestamp: Date.now() }
    this._setSyncingPermission({
      ...permission,
      permittedFolders: [...permission.permittedFolders, folderPermission],
    })
  }
  dropPermission(folderPaths) {
    if (
      folderPaths.length === 0 ||
      this._currentPermission === undefined ||
      this._currentPermission.state === 1
    )
      return
    let remainingFolders = this._currentPermission.permittedFolders.filter(
      (folder) => !folderPaths.includes(folder.sourceFolder),
    )
    this._setSyncingPermission({
      ...this._currentPermission,
      permittedFolders: remainingFolders,
    })
  }
  dropStaleFolders(validFolderPaths) {
    if (
      this._currentPermission === undefined ||
      this._currentPermission.state === 1
    )
      return
    let validFolders = this._currentPermission.permittedFolders.filter((folder) =>
      validFolderPaths.includes(folder.sourceFolder),
    )
    this._setSyncingPermission({
      ...this._currentPermission,
      permittedFolders: validFolders,
    })
  }
  denyPermission() {
    this._setSyncingPermission({ state: 1, timestamp: Date.now() })
  }
  _getStoredPermission() {
    return this._workspaceStorage.get(SyncingPermissionTracker.storageKey)
  }
  _setSyncingPermission(permission) {
    ;(this._currentPermission = permission),
      this._logPermission("Updating syncing permission", permission),
      this._persister.kick()
  }
  async persistCurrentPermission() {
    await this._persister.kick()
  }
  async _persistCurrentPermission() {
    await this._workspaceStorage.update(SyncingPermissionTracker.storageKey, this._currentPermission) // =
  }
  _logPermission(message, permission) {
    if (permission === undefined) {
      this._logger.info(`${message}: undefined`)
      return
    }
    if (permission.state === 1) {
      let timestamp = new Date(permission.timestamp).toLocaleString()
      this._logger.info(`${message}: syncing permission denied for workspace at ${timestamp}`)
      return
    }
    let foldersInfo =
      permission.permittedFolders.length === 0
        ? "none"
        : permission.permittedFolders
            .map((folder) => {
              let folderTimestamp = new Date(folder.timestamp).toLocaleString()
              return `
    ${folder.sourceFolder} (${folder.type}) at ${folderTimestamp}`
            })
            .join("")
    this._logger.info(
      `${message}: syncing permission granted for workspace. Folders:${foldersInfo}`,
    )
  }
}
var dIe = q(require("vscode"))
var SyncingStatusReporter = class extends DisposableContainer {
  constructor(featureFlagManager, workspaceManager) {
    super()
    this._featureFlagManager = featureFlagManager
    this._workspaceManager = workspaceManager
    this.addDisposable(
      this._workspaceManager.onDidChangeSourceFolders(() =>
        this._handleSourceFoldersChanged(), // =
      ),
    ),
      this.addDisposable(
        this._workspaceManager.onDidChangeSyncingProgress((progress) =>
          this._handleSyncingProgressChanged(progress), // =
        ),
      ),
      this._handleSourceFoldersChanged()
  }
  _newFolders = new Set()
  _folderBacklogSize = new Map()
  _folderTrackedFilesSize = new Map()
  _syncingStatusEmitter = new dIe.EventEmitter()
  _status = { status: "done", foldersProgress: [] }
  get status() {
    return this._status
  }
  get onDidChangeSyncingStatus() {
    return this._syncingStatusEmitter.event
  }
  _handleSourceFoldersChanged() {
    this._newFolders.clear(), // =
      this._folderBacklogSize.clear(),
      this._folderTrackedFilesSize.clear(),
      this._workspaceManager
        .getSyncingProgress()
        .forEach((folderProgress) => this._updateFolderState(folderProgress)),
      this._reportSyncingStatus()
  }
  _handleSyncingProgressChanged(folderProgress) {
    this._updateFolderState(folderProgress), this._reportSyncingStatus()
  }
  _updateFolderState(folderProgress) {
    folderProgress.progress !== undefined && // =
      (folderProgress.progress.newlyTracked
        ? this._newFolders.add(folderProgress.folderRoot)
        : this._newFolders.delete(folderProgress.folderRoot),
      this._folderBacklogSize.set(folderProgress.folderRoot, folderProgress.progress.backlogSize),
      this._folderTrackedFilesSize.set(folderProgress.folderRoot, folderProgress.progress.trackedFiles))
  }
  _reportSyncingStatus() {
    let isLongRunning = false, // =
      totalBacklogSize = 0,
      totalTrackedFiles = 0,
      flags = this._featureFlagManager.currentFlags
    this._folderBacklogSize.forEach((backlogSize, folderPath) => {
      backlogSize >= flags.bigSyncThreshold && (isLongRunning = true), (totalBacklogSize += backlogSize)
    }),
      this._folderTrackedFilesSize.forEach((trackedFiles, folderPath) => {
        totalTrackedFiles += trackedFiles
      })
    let newStatus = "done"
    isLongRunning
      ? (newStatus = "longRunning")
      : (totalBacklogSize > flags.smallSyncThreshold || totalBacklogSize / totalTrackedFiles >= 0.1) && (newStatus = "running")
    let previousStatus = this._status.status
    ;(this._status = {
      status: newStatus,
      foldersProgress: this._workspaceManager.getSyncingProgress(),
      prevStatus: previousStatus,
    }),
      this._syncingStatusEmitter.fire(this._status) // =
  }
}
var nc = q(_s()),
  St = q(require("vscode"))
var M6 = class {
  async read(t) {
    try {
      return await AM(t)
    } catch {
      return
    }
  }
  stat(t) {
    try {
      return getFileStats(t)
    } catch {
      return
    }
  }
}
function fIe() {
  return new M6()
}
var lbt = "file-edit-events.json",
  n2 = class {
    save(t) {
      return Promise.resolve()
    }
    load() {
      return Promise.resolve([])
    }
    clear() {}
  },
  i2 = class {
    _logger = z("FileEditEventsStore")
    _version = "1"
    _storeFile
    constructor(t) {
      this._logger.debug(`Using [${t.directory}] to store events`),
        (this._storeFile = joinPaths(t.directory, lbt))
    }
    save(t) {
      this._logger.debug(`Saving ${t.length} events to ${this._storeFile}`),
        sye(
          this._storeFile,
          JSON.stringify({ version: this._version, events: t }),
        )
    }
    async load() {
      this._logger.debug(`Loading events from ${this._storeFile}`)
      try {
        if (!fileExists(this._storeFile))
          return (
            this._logger.debug(
              `File ${this._storeFile} does not exist. Not loading events.`,
            ),
            []
          )
        let t = await readTextFile(this._storeFile),
          r = JSON.parse(t)
        return r.version !== this._version
          ? (this._logger.debug(
              `Version mismatch: ${r.version} !== ${this._version}. Not loading events from ${this._storeFile}`,
            ),
            [])
          : (this._logger.debug(
              `Loaded ${r.events.length} events from ${this._storeFile}`,
            ),
            r.events)
      } catch (t) {
        return (
          this._logger.debug(
            `Failed to load events from ${this._storeFile}`,
            t,
          ),
          []
        )
      }
    }
    clear() {
      this.save([])
    }
  }
function hIe(e, t) {
  let r = Math.min(e.length, t.length),
    n = 1024,
    i = 0
  for (; i < r; ) {
    let s = e.slice(i, i + n),
      o = t.slice(i, i + n)
    if (s !== o) break
    if (s.length === 0)
      throw new Error(`unexpected empty block: s1=${e}, s2=${t}`)
    i += s.length
  }
  for (; i < r && e[i] === t[i]; ) i++
  return i
}
function gIe(e, t) {
  let r = Math.min(e.length, t.length),
    n = 1024,
    i = 0
  for (; i < r; ) {
    let a = e.slice(Math.max(0, e.length - i - n), e.length - i),
      l = t.slice(Math.max(0, t.length - i - n), t.length - i)
    if (a !== l) break
    if (a.length === 0)
      throw new Error(`unexpected empty block: s1=${e}, s2=${t}`)
    i += a.length
  }
  let s = e.length - 1,
    o = t.length - 1
  for (; i < r && e[s - i] === t[o - i]; ) i++
  return i
}
var tc = class e {
  beforeStart
  afterStart
  beforeText
  afterText
  constructor(t) {
    ;(this.beforeStart = t.beforeStart),
      (this.afterStart = t.afterStart),
      (this.beforeText = t.beforeText),
      (this.afterText = t.afterText)
  }
  static from(t) {
    return new e({
      beforeStart: t.beforeStart ?? 0,
      afterStart: t.afterStart ?? 0,
      beforeText: t.beforeText ?? "",
      afterText: t.afterText ?? "",
    })
  }
  get beforeEnd() {
    return this.beforeStart + this.beforeText.length
  }
  get afterEnd() {
    return this.afterStart + this.afterText.length
  }
  get beforeCRange() {
    return new CharRange(this.beforeStart, this.beforeEnd)
  }
  get afterCRange() {
    return new CharRange(this.afterStart, this.afterEnd)
  }
  toString() {
    return `SingleEdit{before=${this.beforeStart}:${this.beforeEnd}, after=${this.afterStart}:${this.afterEnd}, beforeText=${JSON.stringify(this.beforeText)}, afterText=${JSON.stringify(this.afterText)}}`
  }
  mergeNext(t) {
    if (
      t.afterText === "" &&
      t.beforeStart >= this.afterStart &&
      t.beforeEnd <= this.afterEnd
    ) {
      let r =
        this.afterText.slice(0, t.beforeStart - this.afterStart) +
        this.afterText.slice(t.beforeEnd - this.afterStart)
      return new e({
        beforeStart: this.beforeStart,
        afterStart: this.afterStart,
        beforeText: this.beforeText,
        afterText: r,
      })
    } else {
      if (this.afterEnd === t.beforeStart)
        return new e({
          beforeStart: this.beforeStart,
          afterStart: this.afterStart,
          beforeText: this.beforeText + t.beforeText,
          afterText: this.afterText + t.afterText,
        })
      if (t.beforeEnd === this.afterStart)
        return new e({
          beforeStart: t.beforeStart,
          afterStart: t.afterStart,
          beforeText: t.beforeText + this.beforeText,
          afterText: t.afterText + this.afterText,
        })
    }
  }
  normalize() {
    let t = this.beforeStart,
      r = this.afterStart,
      n = this.beforeText,
      i = this.afterText,
      s = hIe(n, i)
    s > 0 && ((t += s), (r += s), (n = n.slice(s)), (i = i.slice(s)))
    let o = gIe(n, i)
    return (
      o > 0 && ((n = n.slice(0, -o)), (i = i.slice(0, -o))),
      new e({ beforeStart: t, afterStart: r, beforeText: n, afterText: i })
    )
  }
}
var _g = class e {
  path
  beforeBlobName
  afterBlobName
  edits
  constructor(t) {
    ;(this.path = t.path),
      (this.beforeBlobName = t.beforeBlobName),
      (this.afterBlobName = t.afterBlobName),
      (this.edits = t.edits)
  }
  static from(t) {
    return new e({
      path: t.path ?? "",
      beforeBlobName: t.beforeBlobName ?? "",
      afterBlobName: t.afterBlobName ?? "",
      edits: t.edits?.map((n) => tc.from(n)) ?? [],
    })
  }
  changedChars() {
    return this.edits.reduce(
      (t, r) => t + r.beforeText.length + r.afterText.length,
      0,
    )
  }
  isRepeatedChange() {
    if (this.edits.length <= 1) return true
    let t = this.edits[0]
    return this.edits.every(
      (r) => r.beforeText === t.beforeText && r.afterText === t.afterText,
    )
  }
  mergeNext(t) {
    if (
      this.edits.length !== t.edits.length ||
      this.path !== t.path ||
      !t.isRepeatedChange()
    )
      return
    let r = [],
      n = 0,
      i = 0
    for (let s = 0; s < this.edits.length; s++) {
      let o = this.edits[s],
        a = o.mergeNext(t.edits[s])
      if (a === undefined) return
      r.push(
        new tc({
          beforeStart: a.beforeStart + n,
          afterStart: a.afterStart + i,
          beforeText: a.beforeText,
          afterText: a.afterText,
        }),
      ),
        (n += a.beforeText.length - o.beforeText.length),
        (i += a.afterText.length - o.afterText.length)
    }
    if (r.length >= 2) {
      let s = r.map((a) => a.beforeCRange)
      if (CharRange.anyOverlaps(s)) return
      let o = r.map((a) => a.afterCRange)
      if (CharRange.anyOverlaps(o)) return
    }
    return new e({
      path: this.path,
      beforeBlobName: this.beforeBlobName,
      afterBlobName: t.afterBlobName,
      edits: r,
    }).normalize()
  }
  normalize() {
    let t = this.edits
      .map((r) => r.normalize())
      .filter((r) => r.beforeText !== r.afterText)
      .sort((r, n) => r.beforeStart - n.beforeStart)
    return new e({
      path: this.path,
      beforeBlobName: this.beforeBlobName,
      afterBlobName: this.afterBlobName,
      edits: t,
    })
  }
  hasChange() {
    return this.edits.some((t) => t.beforeText !== t.afterText)
  }
}
var mIe = q(F6())
var EventCircularBuffer = class {
  _events = new mIe.default()
  _queueSizeChars = 0
  constructor() {}
  add(event) {
    return this._events.push(event), this._updateState(event, "ADDED")
  }
  _updateState(event, action) {
    return event === undefined
      ? 0
      : (action === "ADDED"
          ? (this._queueSizeChars += event.changedChars() ?? 0)
          : (this._queueSizeChars -= event.changedChars() ?? 0),
        event.changedChars() ?? 0)
  }
  removeOld() {
    let event = this._events.shift()
    return this._updateState(event, "REMOVED"), event
  }
  removeNew() {
    let event = this._events.pop()
    return this._updateState(event, "REMOVED"), event
  }
  newest() {
    if (this._events.length !== 0) return this.at(this._events.length - 1)
  }
  asArray() {
    return this._events.toArray()
  }
  get numEvents() {
    return this._events.length
  }
  get sizeChars() {
    return this._queueSizeChars
  }
  at(index) {
    return this._events.get(index)
  }
  removeAt(index) {
    let event = this._events.get(index)
    this._updateState(event, "REMOVED"), this._events.removeOne(index)
  }
  clear() {
    this._events.clear(), (this._queueSizeChars = 0)
  }
}
var EventQueue = class {
  constructor(maxSizeChars, queue = new EventCircularBuffer()) {
    this.maxQueueSizeChars = maxSizeChars
    this._queue = queue
  }
  addEvent(event, blobName) {
    let newestEvent = this._queue.newest(),
      isSameBlobName = newestEvent?.afterBlobName === blobName,
      charsDelta = 0,
      mergedEvent = isSameBlobName ? undefined : newestEvent?.mergeNext(event)
    if (mergedEvent !== undefined) {
      let removedEvent = this._queue.removeNew()
      ;(charsDelta -= removedEvent?.changedChars() ?? 0), mergedEvent.hasChange() && (charsDelta += this._queue.add(mergedEvent))
    } else charsDelta += this._queue.add(event)
    for (; this._queue.sizeChars > this.maxQueueSizeChars; )
      this._queue.removeOld()
    return charsDelta
  }
  removeEventsForFile(filePath) {
    for (let index = this._queue.numEvents - 1; index >= 0; index--) {
      let event = this._queue.at(index)
      event !== undefined && event.path === filePath && this._queue.removeAt(index)
    }
  }
  removeEventsPriorToBlob(blobName) {
    let filePath = null
    for (let index = this._queue.numEvents - 1; index >= 0; index--) {
      let event = this._queue.at(index)
      if (!filePath && event?.afterBlobName === blobName) {
        this._queue.removeAt(index), (filePath = event.path)
        continue
      }
      filePath && event?.path === filePath && this._queue.removeAt(index)
    }
  }
  updatePath(oldPath, newPath) {
    for (let index = 0; index < this._queue.numEvents; index++) {
      let event = this._queue.at(index)
      event !== undefined && event.path === oldPath && (event.path = newPath)
    }
  }
  getEvents() {
    return this._queue.asArray()
  }
  clear() {
    this._queue.clear()
  }
}
var Q6 = ["file".toString(), "untitled".toString()]
var FileEditWatcher = class extends DisposableContainer {
  constructor(folderName, blobNameCalculator, maxBlobSizeBytes, store, maxEventCharsToReturn = 5e3) {
    super()
    this._folderName = folderName
    this._blobNameCalculator = blobNameCalculator
    this._maxBlobSizeBytes = maxBlobSizeBytes
    this._store = store
    this.maxEventCharsToReturn = maxEventCharsToReturn
    ;(this._logger = z(`FileEditEventsWatcher[${this._folderName}]`)),
      (this._eventsQueue = new EventQueue(this.maxEventCharsToReturn * 2))
  }
  _eventsQueue
  _lastKnownText = new Map()
  _lastEventTimestamp = 0
  _logger
  _swapLastKnownText(filePath, newText) {
    if (!this._lastKnownText.has(filePath)) throw new Error(`no known text for [${filePath}]`)
    let oldText = this._lastKnownText.get(filePath)
    return this._lastKnownText.set(filePath, newText), oldText
  }
  _vscodeEventToFileEditEvent(filePath, event) {
    let newText = event.document.getText(),
      oldText = this._swapLastKnownText(filePath, newText),
      edits = event.contentChanges.map(
        (change) =>
          new tc({
            beforeStart: change.rangeOffset,
            afterStart: change.rangeOffset,
            beforeText: oldText.substring(
              change.rangeOffset,
              change.rangeOffset + change.rangeLength,
            ),
            afterText: change.text,
          }),
      )
    if (edits.length > 1) {
      edits.sort((editA, editB) => editA.beforeStart - editB.beforeStart)
      let offset = 0
      edits = edits.map((edit) => {
        let newAfterStart = edit.afterStart + offset
        return (
          (offset += edit.afterText.length - edit.beforeText.length),
          new tc({
            beforeStart: edit.beforeStart,
            afterStart: newAfterStart,
            beforeText: edit.beforeText,
            afterText: edit.afterText,
          })
        )
      })
    }
    return new _g({
      path: filePath,
      edits: edits,
      beforeBlobName: this._blobNameCalculator.calculateNoThrow(filePath, oldText),
      afterBlobName: this._blobNameCalculator.calculateNoThrow(filePath, newText),
    }).normalize()
  }
  handleChangedDocument(docEvent) {
    let filePath = docEvent.relPath,
      vscodeEvent = docEvent.event
    if (!Q6.includes(vscodeEvent.document.uri.scheme)) return
    if (vscodeEvent.document.getText().length > this._maxBlobSizeBytes) {
      this._logger.debug(`Ignoring event for ${filePath} because it is too large`)
      return
    }
    if (!this._lastKnownText.has(filePath)) {
      this._logger.debug(
        vscodeEvent.contentChanges.length > 0
          ? `Last known text is not for the same file. Missing last known text for [${filePath}].  This is ok if we have recently cleared.`
          : `Updating last known text for ${filePath} - based on empty event`,
      ),
        this._lastKnownText.set(filePath, vscodeEvent.document.getText())
      return
    }
    if (vscodeEvent.contentChanges.length === 0) {
      this._logger.verbose(`Ignoring event for ${filePath} - no content changes`)
      return
    }
    let fileEditEvent = this._vscodeEventToFileEditEvent(filePath, vscodeEvent)
    fileEditEvent.hasChange() &&
      (this._eventsQueue.addEvent(fileEditEvent), (this._lastEventTimestamp = Date.now()))
  }
  get lastEventTimestamp() {
    return this._lastEventTimestamp
  }
  handleOpenedDocument(docEvent) {
    if (Q6.includes(docEvent.document.uri.scheme)) {
      if (docEvent.document.getText().length > this._maxBlobSizeBytes) {
        this._logger.debug(
          `Ignoring event for ${docEvent.relPath} because it is too large`,
        )
        return
      }
      this._logger.debug(
        `Adding last known text for ${docEvent.relPath}. size before = ${this._lastKnownText.size}`,
      ),
        this._lastKnownText.set(docEvent.relPath, docEvent.document.getText())
    }
  }
  handleClosedDocument(docEvent) {
    this._logger.debug(
      `Removing last known text for ${docEvent.relPath}. size before = ${this._lastKnownText.size}`,
    ),
      this._lastKnownText.delete(docEvent.relPath)
  }
  getEvents() {
    let events = [],
      totalChars = 0,
      allEvents = this._eventsQueue.getEvents()
    for (let index = allEvents.length - 1; index >= 0; index--) {
      let event = allEvents[index]
      if (totalChars + event.changedChars() > this.maxEventCharsToReturn) break
      events.push(event), (totalChars += event.changedChars())
    }
    return events.reverse(), events
  }
  handleFileDeleted(fileEvent) {
    this._logger.debug(`Deleting events for ${fileEvent.relPath}`),
      this._lastKnownText.delete(fileEvent.relPath),
      this._eventsQueue.removeEventsForFile(fileEvent.relPath)
  }
  _handleFileWillRename(oldPath, newPath) {
    this._logger.debug(`Renaming events for file [${oldPath}] to [${newPath}]`),
      this._lastKnownText.has(oldPath) &&
        (this._lastKnownText.set(newPath, this._lastKnownText.get(oldPath)),
        this._lastKnownText.delete(oldPath)),
      this._eventsQueue.updatePath(oldPath, newPath)
  }
  handleFileWillRename(renameEvent) {
    if (
      (this._logger.debug(
        `Renaming events for file/folder [${renameEvent.oldRelPath}] to [${renameEvent.newRelPath}]`,
      ),
      renameEvent.type === "File")
    )
      this._handleFileWillRename(renameEvent.oldRelPath, renameEvent.newRelPath)
    else if (renameEvent.type === "Directory") {
      for (let path of this._lastKnownText.keys())
        if (Qs(renameEvent.oldRelPath, path)) {
          let newPath = renameEvent.newRelPath + path.slice(renameEvent.oldRelPath.length)
          this._handleFileWillRename(path, newPath)
        }
    }
  }
  clear(options) {
    this._eventsQueue.clear(),
      options.clearLastKnown && this._lastKnownText.clear(),
      (this._lastEventTimestamp = 0),
      this._store.clear()
  }
  async loadEvents() {
    ;(await this._store.load()).forEach((eventData) =>
      this._eventsQueue.addEvent(_g.from(eventData)),
    )
  }
  dispose() {
    super.dispose(),
      this._store.save(this._eventsQueue.getEvents()),
      this._logger.debug("Disposing FileEditEventsWatcher")
  }
}
var FileEditManager = class extends DisposableContainer {
  constructor(blobNameCalculator, maxBlobSizeBytes, onFolderTextDocumentChanged, onFolderTextDocumentOpened, onFolderTextDocumentClosed, onFolderFileDeleted, onFolderFileWillRename, debugFeaturesEnabled, maxEventCharsToReturn = 5e3) {
    super()
    this._blobNameCalculator = blobNameCalculator
    this._maxBlobSizeBytes = maxBlobSizeBytes
    this._onFolderTextDocumentChanged = onFolderTextDocumentChanged
    this._onFolderTextDocumentOpened = onFolderTextDocumentOpened
    this._onFolderTextDocumentClosed = onFolderTextDocumentClosed
    this._onFolderFileDeleted = onFolderFileDeleted
    this._onFolderFileWillRename = onFolderFileWillRename
    this._debugFeaturesEnabled = debugFeaturesEnabled
    this._maxEventCharsToReturn = maxEventCharsToReturn
  }
  _watcher = new Map()
  _logger = z("FileEditManager")
  listenToEvents() {
    this._logger.debug("Listening to events"),
      this.addDisposable(
        this._onFolderTextDocumentChanged((event) =>
          this._handleTextDocumentChanged(event),
        ),
      ),
      this.addDisposable(
        this._onFolderTextDocumentOpened((event) =>
          this._handleTextDocumentOpened(event),
        ),
      ),
      this.addDisposable(
        this._onFolderTextDocumentClosed((event) =>
          this._handleTextDocumentClosed(event),
        ),
      ),
      this.addDisposable(
        this._onFolderFileDeleted((event) => this._handleFileDeleted(event)),
      ),
      this.addDisposable(
        this._onFolderFileWillRename((event) => this._handleFileWillRename(event)),
      ),
      this.addDisposable(
        yN((repoEvent) => {
          this._logger.debug(`Stash changed for repo ${repoEvent.repoId}`),
            this._watcher.get(repoEvent.repoId)?.clear({ clearLastKnown: true })
        }),
      ),
      this.addDisposable(
        Km((repoEvent) => {
          this._logger.debug(`Head changed for repo ${repoEvent.repoId}`),
            this._watcher.get(repoEvent.repoId)?.clear({ clearLastKnown: true })
        }),
      )
  }
  _handleTextDocumentChanged(event) {
    let watcher = this._watcher.get(event.folderId)
    watcher && watcher.handleChangedDocument(event)
  }
  _handleTextDocumentOpened(event) {
    let watcher = this._watcher.get(event.folderId)
    watcher && watcher.handleOpenedDocument(event)
  }
  _handleTextDocumentClosed(event) {
    let watcher = this._watcher.get(event.folderId)
    watcher && watcher.handleClosedDocument(event)
  }
  _handleFileDeleted(event) {
    let watcher = this._watcher.get(event.folderId)
    watcher && watcher.handleFileDeleted(event)
  }
  _handleFileWillRename(event) {
    let watcher = this._watcher.get(event.folderId)
    watcher && watcher.handleFileWillRename(event)
  }
  findFolderIdWithMostRecentChanges() {
    let mostRecentWatcher,
      mostRecentTimestamp = -1,
      mostRecentFolderId = -1
    for (let [folderId, watcher] of this._watcher)
      watcher.lastEventTimestamp > mostRecentTimestamp && ((mostRecentWatcher = watcher), (mostRecentTimestamp = watcher.lastEventTimestamp), (mostRecentFolderId = folderId))
    return mostRecentWatcher === undefined ? -1 : mostRecentFolderId
  }
  findEventsForFolder(folderId) {
    let watcher = this._watcher.get(folderId)
    return watcher === undefined ? [] : watcher.getEvents()
  }
  addInitialDocument(document) {
    this._handleTextDocumentOpened(document)
  }
  startTracking(folderId, folderName, storeConfig) {
    this._logger.debug(`Tracking folder ${folderId} with store at ${storeConfig.directory}`)
    let fileEditWatcher = new FileEditWatcher(
      folderName,
      this._blobNameCalculator,
      this._maxBlobSizeBytes,
      this._debugFeaturesEnabled ? new i2(storeConfig) : new n2(),
      this._maxEventCharsToReturn,
    )
    return this._watcher.set(folderId, fileEditWatcher), fileEditWatcher.loadEvents(), fileEditWatcher
  }
  clearAll(options) {
    this._watcher.forEach((watcher) => watcher.clear(options))
  }
  dispose() {
    super.dispose(),
      this._logger.debug("Disposing FileEditManager"),
      this._watcher.forEach((watcher) => watcher.dispose())
  }
}
var xw = q(require("vscode")),
  G6 = q(SIe())
var _w = class {
    accepted = true
  },
  xg = class {
    accepted = false
  }
var wg = class extends _w {
    explicit = false
    format() {
      return "Tracked"
    }
  },
  q6 = class extends _w {
    constructor(r) {
      super()
      this.ignoreSourceName = r
    }
    explicit = true
    format() {
      return `Tracked (${this.ignoreSourceName})`
    }
  },
  V6 = class extends xg {
    constructor(r) {
      super()
      this.ignoreSourceName = r
    }
    explicit = true
    format() {
      return `Not tracked (${this.ignoreSourceName})`
    }
  },
  o2 = class {
    constructor(t, r, n, i) {
      this.dirName = t
      this.ignoreSource = r
      this.rules = n
      this.next = i
    }
  },
  H6 = class e {
    constructor(t, r, n) {
      this._rootUri = t
      this._ignoreSource = r
      this._top = n
    }
    static async buildNew(t, r, n) {
      let i = new Array()
      if (lf(n, r) !== "") {
        let o = r
        for (;;) {
          o = getWorkspaceFolder(o)
          let a = lf(n, o),
            l = await t.getRules(o)
          if ((l && i.push([a, t, l]), a === "")) break
        }
      }
      let s
      for (let o = i.length - 1; o >= 0; o--) {
        let [a, l, c] = i[o]
        s = new o2(a, l, c, s)
      }
      return new e(n, t, s)
    }
    async buildAtop(t, r) {
      let n = await this._ignoreSource.getRules(t, r)
      if (n === undefined) return this
      let i = lf(this._rootUri, t),
        s = new o2(i, this._ignoreSource, n, this._top)
      return new e(this._rootUri, this._ignoreSource, s)
    }
    getPathInfo(t) {
      for (let r = this._top; r !== undefined; r = r.next) {
        if (!Qs(r.dirName, t))
          throw new Error(
            `candidatePath "${t}" is not below ignore file's parent "${r.dirName}"`,
          )
        let n = t.slice(r.dirName.length),
          i = r.rules.test(n)
        if (i.ignored)
          return new V6(
            r.ignoreSource.getName(xw.Uri.joinPath(this._rootUri, r.dirName)),
          )
        if (i.unignored)
          return new q6(
            r.ignoreSource.getName(xw.Uri.joinPath(this._rootUri, r.dirName)),
          )
      }
      return new wg()
    }
  },
  W6 = class e {
    constructor(t, r) {
      this._ignoreSources = t
      this._ignoreStacks = r
    }
    static async buildNew(t, r, n) {
      let i = new Array()
      for (let s of t) {
        let o = await H6.buildNew(s, r, n)
        i.push(o)
      }
      return new e(t, i)
    }
    async buildAtop(t, r) {
      let n = new Array(),
        i = 0
      for (let s = 0; s < this._ignoreStacks.length; s++) {
        let o = this._ignoreStacks[s],
          a = await o.buildAtop(t, r)
        a !== o && i++, n.push(a)
      }
      return i === 0 ? this : new e(this._ignoreSources, n)
    }
    getPathInfo(t) {
      for (let r = this._ignoreStacks.length - 1; r >= 0; r--) {
        let i = this._ignoreStacks[r].getPathInfo(t)
        if (i.explicit) return i
      }
      return new wg()
    }
  }
async function Sbt(e, t) {
  let r = xw.Uri.joinPath(e, t)
  try {
    let n = await readTextFile(r.fsPath),
      i = (0, G6.default)({ ignorecase: false })
    return i.add(n), i
  } catch {}
}
var fC = class {
    constructor(t = []) {
      this._ignoreSources = t
    }
    async build(t, r) {
      return await W6.buildNew(this._ignoreSources, t, r)
    }
  },
  ww = class {
    constructor(t) {
      this.filename = t
    }
    getName(t) {
      return getUriPath(xw.Uri.joinPath(t, this.filename))
    }
    async getRules(t, r) {
      if (
        !(
          r !== undefined &&
          !(r.find(([i, s]) => s === "File" && this.filename === i) !== undefined)
        )
      )
        return Sbt(t, this.filename)
    }
  },
  a2 = class {
    constructor(t) {
      this._sourceFolderRootPath = t
    }
    getName() {
      return "default Augment rules"
    }
    getRules(t) {
      return new Promise((r) => {
        if (getPathFromUri(t) !== this._sourceFolderRootPath) r(undefined)
        else {
          let n = (0, G6.default)({ ignorecase: false })
          n.add([
            ".git",
            "*.pem",
            "*.key",
            "*.pfx",
            "*.p12",
            "*.jks",
            "*.keystore",
            "*.pkcs12",
            "*.crt",
            "*.cer",
            "id_rsa",
            "id_ed25519",
            "id_ecdsa",
            "id_dsa",
            ".augment-guidelines",
            ".env",
          ]),
            r(n)
        }
      })
    }
  }
var l2 = class {
    constructor(t) {
      this.name = t
    }
    start = Date.now()
    increments = []
    charge(t) {
      this.increments.push({ name: t, end: Date.now() })
    }
    *[Symbol.iterator]() {
      let t = this.start
      for (let { name: r, end: n } of this.increments) yield [r, n - t], (t = n)
      yield ["total", t - this.start]
    }
    format() {
      return (
        (this.name
          ? `${this.name}:
`
          : "") +
        Array.from(this).map(([r, n]) => `  - ${r}: ${n} ms`).join(`
`)
      )
    }
  },
  c2 = class {
    _value = 0
    _add(t = 1) {
      this._value += t
    }
    _invalidate() {
      this._value = Number.NaN
    }
    get value() {
      return this._value
    }
  },
  $6 = class extends c2 {
    increment(t = 1) {
      this._add(t)
    }
  },
  Y6 = class extends c2 {
    _start = undefined
    start() {
      this._start = Date.now()
    }
    stop() {
      this._start === undefined
        ? this._invalidate()
        : this._add(Date.now() - this._start)
    }
  },
  hC = class {
    constructor(t) {
      this.name = t
    }
    counters = new Map()
    timings = new Map()
    counterMetric(t) {
      let r = this.counters.get(t)
      return r === undefined && ((r = new $6()), this.counters.set(t, r)), r
    }
    timingMetric(t) {
      let r = this.timings.get(t)
      return r === undefined && ((r = new Y6()), this.timings.set(t, r)), r
    }
    format() {
      let t = this.name ? `${this.name}:` : "",
        r = Array.from(this.counters.entries()).map(
          ([s, o]) => `  - ${s}: ${o.value}`,
        ).join(`
`),
        n = "  - timing stats:",
        i = Array.from(this.timings.entries()).map(
          ([s, o]) => `    - ${s}: ${o.value} ms`,
        ).join(`
`)
      return (
        t +
        `
` +
        r +
        `
` +
        n +
        `
` +
        i
      )
    }
  }
var IIe = q(require("os"))
function BIe(e) {
  let t = IIe.default.homedir()
  return Xy(e, t)
}
var Sw = q(require("path")),
  j6 = q(require("vscode"))
async function buildIgnoreStack(rootUri, workspaceUri, ignoreBuilder, fileExtensions) {
  let rootIgnoreStack = await ignoreBuilder.build(rootUri, workspaceUri),
    ignoreStackMap = new Map()
  ignoreStackMap.set("", rootIgnoreStack), ignoreStackMap.set(".", rootIgnoreStack)
  let yieldInterval = 200,
    lastYieldTime = Date.now(),
    dirStack = []
  dirStack.push([rootUri, rootIgnoreStack])
  let currentDir
  for (; (currentDir = dirStack.pop()) !== undefined; ) {
    Date.now() - lastYieldTime >= yieldInterval &&
      (await new Promise((resolve) => setTimeout(resolve, 0)), (lastYieldTime = Date.now()))
    let [dirUri, parentIgnoreStack] = currentDir,
      relativePath = lf(workspaceUri, dirUri),
      dirEntries = hm(dirUri.fsPath),
      dirIgnoreStack = await parentIgnoreStack.buildAtop(dirUri, dirEntries)
    dirIgnoreStack !== parentIgnoreStack && ignoreStackMap.set(relativePath, dirIgnoreStack)
    for (let [entryName, entryType] of dirEntries) {
      if (
        (Date.now() - lastYieldTime >= yieldInterval &&
          (await new Promise((resolve) => setTimeout(resolve, 0)), (lastYieldTime = Date.now())),
        entryName === "." || entryName === ".." || entryType !== "Directory")
      )
        continue
      let entryUri = j6.Uri.joinPath(dirUri, entryName),
        entryPath = joinPaths(relativePath, entryName, true)
      dirIgnoreStack.getPathInfo(entryPath).accepted && dirStack.push([entryUri, dirIgnoreStack])
    }
  }
  return new PathFilter(ignoreStackMap, fileExtensions)
}
var gC = class {
    constructor(t, r, n, i) {
      this._name = t
      this._startUri = r
      this._rootUri = n
      this._pathFilter = i
      if (!Sw.isAbsolute(r.fsPath))
        throw new Error(
          `PathIterator[${this._name}]: startUri ${this._name} must contain an absolute pathname`,
        )
      if (!Sw.isAbsolute(n.fsPath))
        throw new Error(
          `PathIterator[${this._name}]: rootUri ${n.toString()} must contain an absolute pathname`,
        )
      if (!Qs(getPathFromUri(n), getPathFromUri(r)))
        throw new Error(
          `PathIterator[${this._name}]: startUri ${getPathFromUri(this._startUri)} must be inside rootUri ${getPathFromUri(this._rootUri)}`,
        )
      this._logger.verbose(
        `Created PathIterator for startUri ${this._startUri.fsPath}, rootUri ${this._rootUri.fsPath}`,
      )
    }
    stats = new hC("Path metrics")
    _logger = z("PathIterator")
    _dirsEmitted = this.stats.counterMetric("directories emitted")
    _filesEmitted = this.stats.counterMetric("files emitted")
    _otherEmitted = this.stats.counterMetric("other paths emitted")
    _totalEmitted = this.stats.counterMetric("total paths emitted")
    _readDirMs = this.stats.timingMetric("readDir")
    _filterMs = this.stats.timingMetric("filter")
    _yieldMs = this.stats.timingMetric("yield")
    _totalMs = this.stats.timingMetric("total")
    async *[Symbol.asyncIterator]() {
      this._totalMs.start()
      let t = 200,
        r = Date.now(),
        n = new Array()
      n.push(this._startUri)
      let i
      for (; (i = n.pop()) !== undefined; ) {
        Date.now() - r >= t &&
          (await new Promise((c) => setTimeout(c, 0)), (r = Date.now()))
        let o = lf(this._rootUri, i),
          a = this._pathFilter.makeLocalPathFilter(o)
        this._readDirMs.start()
        let l = hm(i.fsPath)
        this._readDirMs.stop()
        for (let [c, u] of l) {
          if (
            (Date.now() - r >= t &&
              (await new Promise((v) => setTimeout(v, 0)), (r = Date.now())),
            c === "." || c === "..")
          )
            continue
          this._filterMs.start()
          let p = j6.Uri.joinPath(i, c),
            g = joinPaths(o, c, u === "Directory"),
            m = a.getPathInfo(g, u)
          this._filterMs.stop()
          let y = g
          u === "File"
            ? this._filesEmitted.increment()
            : u === "Directory"
              ? ((y = Zy(g)), this._dirsEmitted.increment())
              : this._otherEmitted.increment(),
            this._totalEmitted.increment(),
            this._yieldMs.start(),
            yield [p, y, u, m],
            this._yieldMs.stop(),
            u === "Directory" && m.accepted && n.push(p)
        }
      }
      this._totalMs.stop()
    }
  },
  K6 = class extends xg {
    constructor(r) {
      super()
      this.extension = r
    }
    format() {
      return `Unsupported file extension (${this.extension})`
    }
  },
  BasePathFilter = class {
    _fileExtensions
    constructor(t) {
      if (t) {
        this._fileExtensions = new Set()
        for (let r of t) this._fileExtensions.add(r.toLowerCase())
      } else this._fileExtensions = undefined
    }
    acceptsPath(t, r = "File") {
      return this.getPathInfo(t, r).accepted
    }
    getPathInfo(t, r = "File") {
      if (r === "File") {
        let i = Sw.extname(t)
        if (
          this._fileExtensions !== undefined &&
          !this._fileExtensions.has(i.toLowerCase())
        )
          return new K6(i)
      } else r === "Directory" && !t.endsWith("/") && (t += "/")
      let n = this._getIgnoreStack(Ha(t))
      return n === undefined ? new wg() : n.getPathInfo(t)
    }
  },
  PathFilter = class extends BasePathFilter {
    constructor(r, n) {
      super(n)
      this._ignorePathMap = r
    }
    makeLocalPathFilter(r) {
      let n = this._getIgnoreStack(r)
      return new J6(n, this._fileExtensions)
    }
    _getIgnoreStack(r) {
      if (af(r)) throw new Error(`Absolute path ${r} passed to PathFilter`)
      let n = r
      for (let i = 0; i < 1e4; i++) {
        let s = this._ignorePathMap.get(n)
        if (s) return s
        if (Ha(n) === n) return
        n = Ha(n)
      }
      throw new Error(`Too-deep or malformed directory name ${r}`)
    }
  },
  J6 = class extends BasePathFilter {
    constructor(r, n) {
      super(n)
      this._ignoreStack = r
    }
    _getIgnoreStack(r) {
      return this._ignoreStack
    }
  }
var Ibt = q(require("vscode"))
function createDisposablePromise(registerCallback) {
  let disposable
  return new Promise((resolve) => {
    disposable = registerCallback((result) => {
      disposable.dispose(), resolve(result)
    })
  })
}
var f2 = class e {
  static defaultStartSeq = 1e4
  _next
  constructor(t = e.defaultStartSeq) {
    this._next = t
  }
  next() {
    return this._next++
  }
}
var Xm = {}
lL(Xm, {
  BlobNameRetrieverImpl: () => Z6,
  FileChangeWatcherImpl: () => X6,
  FileUploaderImpl: () => e9,
  FileUtilsImpl: () => t9,
  HeadChangeWatcher: () => gw,
  onDidChange: () => Km,
})
var RIe = q(require("vscode"))
var Z6 = class {
  constructor(t, r, n) {
    this._rootPath = t
    this._workspaceManager = r
    this._blobNameCalculator = n
  }
  async getBufferBlobName(t) {
    let r = RIe.Uri.file(joinPaths(this._rootPath, t)),
      i = (await Io(r)).getText()
    return this._blobNameCalculator.calculate(t, i)
  }
  getIndexedBlobName(t) {
    return this._workspaceManager.getBlobName(new QualifiedPathName(this._rootPath, t))
  }
}
var h2 = require("vscode")
var X6 = class {
  constructor(t, r) {
    this._rootPath = t
    this.onDidChangeFile = r
  }
  async _getOpenTabs() {
    let t = []
    for (let r of h2.window.tabGroups.all)
      for (let n of r.tabs) {
        let i = n.input
        if (!eM(i, "uri")) continue
        let s = i.uri
        if (!(await nye(s.fsPath))) continue
        let a = null
        try {
          a = await h2.workspace.openTextDocument(s)
        } catch {
          continue
        }
        let l = a.isDirty
        t.push({ label: n.label, uri: s, isDirty: l })
      }
    return t
  }
  async getPathsWithBufferChanges() {
    let r = (await this._getOpenTabs()).filter(
        (i) => i.isDirty && Qs(this._rootPath.fsPath, i.uri.fsPath),
      ),
      n = []
    for (let i of r) {
      let s = Zh(this._rootPath.fsPath, i.uri.fsPath)
      s !== undefined && n.push(s)
    }
    return n
  }
}
var DIe = require("vscode")
var e9 = class extends DisposableContainer {
  constructor(r, n) {
    super()
    this._blobNameCalculator = r
    this._apiServer = n
    ;(this._uploadQueue = new ProcessQueue(async (i) => {
      i !== undefined && (await this._processUpload(i))
    })),
      this.addDisposable(this._uploadQueue)
  }
  _emitter = new DIe.EventEmitter()
  _uploadQueue
  _logger = z("FileUploaderImpl")
  get onDidChange() {
    return this._emitter.event
  }
  upload(r, n) {
    let i = this._blobNameCalculator.calculate(r, n)
    if (i === undefined)
      throw new Error(`blobNameCalculator returned undefined for ${r}`)
    return (
      this._uploadQueue.insert({ path: r, content: n, blobName: i }),
      this._uploadQueue.kick(),
      Promise.resolve(i)
    )
  }
  async _processUpload(r) {
    try {
      this._logger.debug(
        `Upload started: path [${r.path}] with blob name [${r.blobName}]`,
      ),
        await this._apiServer.batchUpload([
          {
            pathName: r.path,
            text: r.content,
            blobName: r.blobName,
            metadata: [],
          },
        ]),
        this._logger.debug(
          `Upload complete: path [${r.path}] with blob name [${r.blobName}]`,
        )
    } catch (n) {
      this._logger.debug(
        `Failed upload for [${r.path}]. Caused by: ${n.stack}.`,
      )
    }
  }
}
var t9 = class {
  constructor(t) {
    this._pathFilter = t
  }
  isUploadable(t) {
    return this._pathFilter.acceptsPath(t)
  }
}
var r9 = q(require("vscode"))
var TIe = ((i) => (
    (i.added = "A"), (i.deleted = "D"), (i.modified = "M"), (i.renamed = "R"), i
  ))(TIe || {}),
  Bbt = Object.freeze({
    A: nr.added,
    D: nr.deleted,
    M: nr.modified,
    R: nr.renamed,
  }),
  Rbt = new RegExp("^R\\d{3}$"),
  Dbt = `
`,
  Tbt = "	"
function kbt(e, t) {
  for (let r in e) if (e[r] === t) return e[r]
}
function Mbt(e) {
  let r = Rbt.test(e) ? "R" : kbt(TIe, e)
  if (!r) throw new Error(`Unknown diff change type [${e}]`)
  return r
}
function Fbt(e) {
  return Bbt[Mbt(e)]
}
function Qbt(e, t, r) {
  return {
    [nr.added]: undefined,
    [nr.deleted]: e,
    [nr.modified]: e,
    [nr.renamed]: e,
  }[r]
}
function Nbt(e, t, r) {
  return {
    [nr.added]: e,
    [nr.deleted]: undefined,
    [nr.modified]: e,
    [nr.renamed]: t,
  }[r]
}
function g2(e) {
  let t = [],
    r = e.split(Dbt)
  for (let n of r) {
    if (!n || n.trim().length === 0) continue
    let [i, s, o] = n.split(Tbt),
      a = Fbt(i),
      l = { beforePath: Qbt(s, o, a), afterPath: Nbt(s, o, a), changeType: a }
    t.push(l)
  }
  return t
}
var p2 = class {
  constructor(t) {
    this._git = t
  }
  async getWorkingDirectoryChanges() {
    let t = `
`,
      r = [],
      n = new Set(),
      i = await this._git.diff({ hash1: "HEAD", nameStatus: true })
    if (i) {
      r = g2(i)
      for (let o of r.slice(0, 50)) o.afterPath !== undefined && n.add(o.afterPath)
    }
    let s = await this._git.lsFiles({ others: true, excludeStandard: true })
    if (s) {
      let o = s
        .split(t)
        .filter((a) => a.trim().length > 0 && !n.has(a))
        .map((a) => ({
          afterPath: a,
          beforePath: undefined,
          changeType: nr.added,
        }))
      r = r.concat(o)
    }
    return r
  }
  async _getDefaultBranch() {
    let t = "refs/remotes/origin",
      r = await this._git.symbolicRef({ name: `${t}/HEAD` })
    if (r) return r.trim().replace(t + "/", "")
  }
  async _getCommitHashes() {
    let t = "%H",
      r = `
`,
      n = await this._getDefaultBranch()
    return (
      (
        await this._git.log({
          commit1: n,
          commit2: "HEAD",
          noMerges: true,
          format: t,
          not: n,
        })
      )?.split(r) ?? []
    )
  }
  async getCommitChanges() {
    let t = `
`,
      r = {},
      n = await this._getCommitHashes()
    for (let i of n) {
      let s = await this._git.show({ object: i, nameStatus: true, oneLine: true }),
        o = s?.slice(s.indexOf(t) + 1)
      if (o == null)
        throw new Error(`Could not get commit changes for commit ${i}`)
      let a = g2(o)
      r[i] = a
    }
    return r
  }
  async getFileWorkingDirectoryChange(t) {
    let r = await this._git.diff({ hash1: "HEAD", nameStatus: true, relPath: t })
    if (r) {
      let i = g2(r)
      if (i.length > 0) return i[0]
    }
    if (
      (
        await this._git.lsFiles({ others: true, excludeStandard: true, relPath: t })
      )?.trim() === t
    )
      return { afterPath: t, beforePath: undefined, changeType: nr.added }
  }
  async getFileContentForCommit(t, r) {
    let n = await this._git.show({ object: `${r}:${t}` })
    if (n === undefined) throw new Error(`Could not find file ${t} in commit ${r}`)
    return n
  }
  async getFileContentBeforeCommit(t, r) {
    return this.getFileContentForCommit(t, `${r}^`)
  }
}
var kIe = q(_s())
var m2 = class extends DisposableContainer {
  constructor(r, n, i, s, o, a, l) {
    super()
    this._workspaceName = r
    this._vcs = n
    this._fileUtils = i
    this._fileUploader = s
    this._fileChangeWatcher = o
    this._blobNameRetriever = a
    this._configListener = l
    ;(this._logger = z(`VCSRepoWatcher[${r}]`)),
      (this._changes = { commits: [], workingDirectory: [] }),
      this.addDisposable(s.onDidChange((c) => this.handleFileUploaded(c))),
      this.addDisposable(o.onDidChangeFile((c) => this.handleFileChange(c)))
  }
  _changes
  _workingDirectoryTrackedPaths = new Set()
  _trackedBlobs = new Map()
  _logger
  async _uploadFile(r) {
    let n = await r.readContent(),
      i = await this._fileUploader.upload(r.path, n)
    return this._trackedBlobs.set(i, r), i
  }
  _clear() {
    ;(this._changes = { commits: [], workingDirectory: [] }),
      this._workingDirectoryTrackedPaths.clear(),
      this._trackedBlobs.clear()
  }
  async handleHeadChange() {
    this._logger.debug("Handling head changes"), this._clear()
    try {
      let i = await this.collectCommitChanges()
      this._changes.commits = i
    } catch (i) {
      this._logger.error("Error collecting commit changes", i)
    }
    let r = await this.collectWorkingDirectoryChanges(),
      n = await this.collectBufferChanges()
    this._changes.workingDirectory = r.concat(n)
  }
  handleFileUploaded(r) {
    throw new Error("Method not implemented.")
  }
  async handleFileChange(r) {
    if (
      (this._logger.debug(`Handling file change [${r.relPath}]`),
      r.origin === "buffer" &&
        this._workingDirectoryTrackedPaths.has(r.relPath))
    )
      return
    r.origin === "disk" &&
      (this._changes.workingDirectory = this._changes.workingDirectory.filter(
        (s) => s.afterPath !== r.relPath,
      )),
      this._workingDirectoryTrackedPaths.add(r.relPath)
    let n
    if (r.origin === "disk")
      n = await this._vcs.getFileWorkingDirectoryChange(r.relPath)
    else if (r.origin === "buffer")
      n = {
        afterPath: r.relPath,
        beforePath: r.relPath,
        changeType: nr.modified,
      }
    else {
      this._logger.debug(`Unknown file change origin ${JSON.stringify(r)}`)
      return
    }
    if (!n) {
      this._changes.workingDirectory = this._changes.workingDirectory.filter(
        (s) => {
          let o = s.changeType === nr.renamed && s.afterPath === r.relPath,
            a = s.changeType === nr.deleted && s.beforePath === r.relPath,
            l = s.changeType === nr.added && s.afterPath === r.relPath
          return !o && !a && !l
        },
      )
      return
    }
    let i = { changeType: n.changeType }
    n.beforePath && (i.beforePath = n.beforePath),
      n.afterPath && (i.afterPath = n.afterPath),
      [nr.deleted, nr.modified, nr.renamed].includes(n.changeType) &&
        (i.headBlobName = await this._uploadFile({
          path: n.afterPath,
          readContent: () =>
            this._vcs.getFileContentForCommit(n.beforePath, "HEAD"),
        })),
      nr.renamed.includes(n.changeType) &&
        (this._changes.workingDirectory = this._changes.workingDirectory.filter(
          (s) => s.afterPath !== n.beforePath,
        )),
      this._changes.workingDirectory.push(i)
  }
  async collectCommitChanges() {
    let r = []
    this._logger.debug("Collecting disk changes")
    let n = await this._vcs.getCommitChanges()
    for (let i in n) {
      let s = { hash: i, files: [] }
      for (let o of n[i]) {
        let a = { changeType: o.changeType }
        if (o.afterPath !== undefined) {
          if (!this._fileUtils.isUploadable(o.afterPath)) continue
          ;(a.afterPath = o.afterPath),
            (a.afterBlobName = await this._uploadFile({
              path: o.afterPath,
              readContent: () =>
                this._vcs.getFileContentForCommit(o.afterPath, i),
            }))
        }
        if (o.beforePath !== undefined) {
          if (!this._fileUtils.isUploadable(o.beforePath)) continue
          ;(a.beforePath = o.beforePath),
            (a.beforeBlobName = await this._uploadFile({
              path: o.beforePath,
              readContent: () =>
                this._vcs.getFileContentBeforeCommit(o.beforePath, i),
            }))
        }
        s.files.push(a)
      }
      r.push(s)
    }
    return r
  }
  async collectWorkingDirectoryChanges() {
    let r = [],
      n = await this._vcs.getWorkingDirectoryChanges()
    for (let i of n) {
      ;[nr.added, nr.modified].includes(i.changeType) &&
        this._workingDirectoryTrackedPaths.add(i.afterPath)
      let s = { changeType: i.changeType }
      if (i.afterPath !== undefined) {
        if (!this._fileUtils.isUploadable(i.afterPath)) continue
        s.afterPath = i.afterPath
      }
      if (i.beforePath !== undefined) {
        if (!this._fileUtils.isUploadable(i.beforePath)) continue
        ;(s.beforePath = i.beforePath),
          (s.headBlobName = await this._uploadFile({
            path: i.beforePath,
            readContent: () =>
              this._vcs.getFileContentForCommit(i.beforePath, "HEAD"),
          }))
      }
      r.push(s)
    }
    return r
  }
  async collectBufferChanges() {
    let r = [],
      n = await this._fileChangeWatcher.getPathsWithBufferChanges()
    for (let i of n) {
      if (
        !this._fileUtils.isUploadable(i) ||
        this._workingDirectoryTrackedPaths.has(i)
      )
        continue
      this._workingDirectoryTrackedPaths.add(i)
      let s = { changeType: nr.modified, afterPath: i, beforePath: i }
      ;(s.headBlobName = await this._uploadFile({
        path: i,
        readContent: () => this._vcs.getFileContentForCommit(i, "HEAD"),
      })),
        r.push(s)
    }
    return r
  }
  async getChanges() {
    let r = (0, kIe.cloneDeep)(this._changes),
      n = []
    for (let i of r.workingDirectory.slice(-50)) {
      if (!i.afterPath) {
        n.push(i)
        continue
      }
      ;(i.indexedBlobName = this._blobNameRetriever.getIndexedBlobName(
        i.afterPath,
      )),
        i.indexedBlobName !== undefined &&
          ((i.currentBlobName = await this._blobNameRetriever.getBufferBlobName(
            i.afterPath,
          )),
          n.push(i))
    }
    return (r.workingDirectory = n), r
  }
  handleUnknownBlobs(r) {
    for (let n of r) {
      let i = this._trackedBlobs.get(n)
      i !== undefined && this._uploadFile(i)
    }
  }
}
var A2 = class {
  constructor(t, r) {
    this._fileUploader = t
    this.configListener = r
  }
  _repoWatchers = new Map()
  _disposables = new Map()
  _logger = z("VCSWatcher")
  _headChangeListener
  _createFacade(t) {
    if (t.toolName === "git") return new p2(new gM(t.root))
    throw new Error("only git is supported for now")
  }
  startTracking(t, r, n, i, s, o) {
    if (
      (this._logger.debug(`startTracking folderId ${r}`),
      this._repoWatchers.has(r))
    )
      return (
        this._logger.debug(`folderId ${r} is already being tracked`),
        new r9.Disposable(() => {})
      )
    let a = new m2(
      t,
      this._createFacade(n),
      o,
      this._fileUploader,
      i,
      s,
      this.configListener,
    )
    return (
      this._repoWatchers.set(r, a),
      this._disposables.set(r, [a]),
      a.handleHeadChange(),
      new r9.Disposable(() => this._stopTracking(r))
    )
  }
  _stopTracking(t) {
    this._logger.debug(`stopTracking folderId ${t}`)
    let r = this._disposables.get(t)
    if (r) {
      for (let n of r) n.dispose()
      this._disposables.delete(t)
    }
    this._repoWatchers.delete(t)
  }
  dispose() {
    this._logger.debug("Disposing VCSWatcher")
    for (let t of this._repoWatchers.keys()) this._stopTracking(t)
    this._repoWatchers.clear(), this._disposables.clear()
  }
  getWatchedFolderIds() {
    return Array.from(this._repoWatchers.keys())
  }
  async getChanges() {
    let t = { commits: [], workingDirectory: [] }
    for (let r of this._repoWatchers.values()) {
      let n = await r.getChanges()
      ;(t.commits = t.commits.concat(n.commits)),
        (t.workingDirectory = t.workingDirectory.concat(n.workingDirectory))
    }
    return t
  }
  handleUnknownBlobs(t) {
    for (let r of this._repoWatchers.values()) r.handleUnknownBlobs(t)
  }
  listenForEvents() {
    this._logger.debug("Registering for events"),
      this._headChangeListener !== undefined && this._headChangeListener.dispose(),
      (this._headChangeListener = Km((t) => {
        this._logger.debug(`Head changed for repo ${t.repoId}`),
          this._repoWatchers
            .get(t.repoId)
            ?.handleHeadChange()
            .catch((r) => {
              r instanceof Error
                ? this._logger.error(
                    `Error handling head change: ${r.message ?? ""} ${r.stack}`,
                  )
                : this._logger.error(`Error handling head change: ${r}`)
            })
      }))
  }
}
var n9 = q(_s())
var OpenFileManagerProxy = class {
  constructor(configListener, openFileManagerV1, openFileManagerV2) {
    this._configListener = configListener
    this._openFileManagerV1 = openFileManagerV1
    this._openFileManagerV2 = openFileManagerV2
  }
  _logger = z("OpenFileManagerProxy")
  get isV2Enabled() {
    return this._configListener.config.openFileManager.v2Enabled
  }
  startTrackingFolder(folder, folderId) {
    return this.isV2Enabled // =
      ? [
          this._openFileManagerV2.startTrackingFolder(folder, folderId),
          this._openFileManagerV1.openSourceFolder(folderId),
        ]
      : [this._openFileManagerV1.openSourceFolder(folderId)]
  }
  addOpenedDocument(document, content) {
    this._openFileManagerV1.startTracking(document.folderId, document.relPath, document.document),
      this.isV2Enabled && this._openFileManagerV2.addOpenedDocument(document, content)
  }
  getBlobName(folderId, relPath) {
    if (this.isV2Enabled) {
      let v2Result = this._openFileManagerV2.getBlobName(folderId, relPath),
        v1Result = this._openFileManagerV1.getBlobName(folderId, relPath)
      return (
        ((v2Result === undefined && v1Result !== undefined) || (v2Result !== undefined && v1Result === undefined)) &&
          this._logger
            .debug(`[WARN] getBlobName returned different results between v1 and v2 [${folderId}:${relPath}]
[${JSON.stringify(v2Result)}]
[${JSON.stringify(v1Result)}]`),
        v1Result
      )
    } else return this._openFileManagerV1.getBlobName(folderId, relPath)
  }
  handleMissingBlob(folderId, relPath, blobType) {
    if (this.isV2Enabled) {
      let v2Result = this._openFileManagerV2.handleMissingBlob(folderId, relPath, blobType)
      return this._openFileManagerV1.notifyMissingBlob(folderId, relPath, blobType) || v2Result
    } else return this._openFileManagerV1.notifyMissingBlob(folderId, relPath, blobType)
  }
  loseFocus() {
    this._openFileManagerV1.loseFocus()
  }
  stopTracking(folderId, relPath) {
    this._openFileManagerV1.stopTracking(folderId, relPath),
      this.isV2Enabled && this._openFileManagerV2.stopTracking(folderId, relPath)
  }
  handleClosedDocument(document) {
    let isNotebookDoc = isNotebook(document.document)
    this._openFileManagerV1.stopTracking(document.folderId, document.relPath, isNotebookDoc ? 1 : 0),
      this.isV2Enabled && this._openFileManagerV2.handleClosedDocument(document)
  }
  handleChangedDocument(documentChange) {
    Object.prototype.hasOwnProperty.call(documentChange.event, "notebook")
      ? this._openFileManagerV1.applyNotebookChange(
          documentChange.folderId,
          documentChange.relPath,
          documentChange.event,
        )
      : this._openFileManagerV1.applyTextDocumentChange(
          documentChange.folderId,
          documentChange.relPath,
          documentChange.event,
        ),
      this.isV2Enabled && this._openFileManagerV2.handleChangedDocument(documentChange)
  }
  isTracked(folderId, relPath) {
    if (this.isV2Enabled) {
      let v2Result = this._openFileManagerV2.isTracked(folderId, relPath),
        v1Result = this._openFileManagerV1.isTracked(folderId, relPath)
      return (
        v2Result !== v1Result &&
          this._logger
            .debug(`[WARN] isTracked returned different results between v1 and v2 [${folderId}:${relPath}]
[${JSON.stringify(v2Result)}]
[${JSON.stringify(v1Result)}]`),
        v1Result
      )
    } else return this._openFileManagerV1.isTracked(folderId, relPath)
  }
  getTrackedPaths(folderId) {
    if (this.isV2Enabled) {
      let v2Paths = this._openFileManagerV2.getTrackedPaths(folderId),
        v1Paths = this._openFileManagerV1.getTrackedPaths(folderId),
        newPathsNotInOld = (0, n9.difference)(v2Paths, v1Paths)
      newPathsNotInOld.length > 0 &&
        this._logger.debug(`[WARN] getTrackedPaths in new but not in old [${folderId}]
[${JSON.stringify(newPathsNotInOld)}]`)
      let oldPathsNotInNew = (0, n9.difference)(v1Paths, v2Paths)
      return (
        oldPathsNotInNew.length > 0 &&
          this._logger
            .debug(`[WARN] getTrackedPaths in old but not in new [${folderId}]
[${JSON.stringify(oldPathsNotInNew)}]`),
        v1Paths
      )
    } else return this._openFileManagerV1.getTrackedPaths(folderId)
  }
  getRecencySummary(folderId) {
    return this._openFileManagerV1.getRecencySummary(folderId)
  }
  getAllEditEvents() {
    return this.isV2Enabled
      ? this._openFileManagerV2.getAllEditEvents()
      : new Map()
  }
  getAllPathToIndexedBlob() {
    return this.isV2Enabled
      ? this._openFileManagerV2.getAllPathToIndexedBlob()
      : new Map()
  }
  translateRange(folderId, relPath, beginOffset, endOffset) {
    if (this.isV2Enabled) {
      let v2Result = this._openFileManagerV2.translateRange(folderId, relPath, beginOffset, endOffset),
        v1Result = this._openFileManagerV1.translateRange({
          folderId: folderId,
          relPath: relPath,
          beginOffset: beginOffset,
          endOffset: endOffset,
        })
      return (
        (v2Result?.blobName !== v1Result?.blobName ||
          v2Result?.beginOffset !== v1Result?.beginOffset ||
          v2Result?.endOffset !== v1Result?.endOffset) &&
          this._logger
            .debug(`[WARN] translateRange returned different results between v1 and v2 [${folderId}:${relPath}]
[${JSON.stringify(v2Result)}]
[${JSON.stringify(v1Result)}]`),
        v1Result
      )
    } else
      return this._openFileManagerV1.translateRange({
        folderId: folderId,
        relPath: relPath,
        beginOffset: beginOffset,
        endOffset: endOffset,
      })
  }
}
var i9 = q(_s()),
  v2 = class {
    store
    primaryKey
    constructor(t) {
      ;(this.store = {}), (this.primaryKey = t)
    }
    add(t) {
      let r = t[this.primaryKey]
      if (this.get(r))
        throw new Error(`Record with primary key ${r} already exists.`)
      this.store[r] = Object.assign({}, t)
    }
    update(t, r) {
      this.store[t] = { ...this.store[t], ...r }
    }
    delete(t) {
      let r = this.store[t]
      return delete this.store[t], r
    }
    deleteBy(t) {
      let r = this.search(t)
      for (let n of r) this.delete(n[this.primaryKey])
    }
    get(t) {
      return this.store[t]
    }
    search(t, { limit: r } = {}) {
      let n = 0,
        i = []
      for (let s of Object.values(this.store))
        if (
          i9.default.every(t, (o, a) => i9.default.isEqual(s[a], o)) &&
          (i.push(s), n++, r && n >= r)
        )
          break
      return i
    }
    getAll() {
      return Object.values(this.store)
    }
    clear() {
      this.store = {}
    }
  }
var C2 = class {
  _logger = z("BlobStatusStore")
  _store = new v2("blobName")
  _embargoedPaths = new Set()
  getIndexedBlobName(t) {
    if (this._embargoedPaths.has(t)) {
      this._logger.debug(`Path [${t}] is embargoed`)
      return
    }
    let r = this._store.search({ pathName: t, status: "indexed" })
    if (r.length === 0) {
      this._logger.debug(`No indexed blob found for ${t}`)
      return
    }
    return r.length > 1
      ? (this._logger.warn(`Multiple indexed blobs found for ${t}`),
        r.sort((n, i) => (n.indexedAt ?? 0) - (i.indexedAt ?? 0)),
        r[r.length - 1].blobName)
      : r[0].blobName
  }
  isTrackingBlob(t) {
    return this._store.get(t) !== undefined
  }
  removePath(t) {
    this._store.deleteBy({ pathName: t }), this._embargoedPaths.delete(t)
  }
  isTrackingPath(t) {
    return (
      this._embargoedPaths.has(t) ||
      this._store.search({ pathName: t }, { limit: 1 }).length > 0
    )
  }
  clear() {
    this._store.clear(), this._embargoedPaths.clear()
  }
  getTrackedPaths() {
    return [
      ...new Set(
        ...this._store.getAll().map((t) => t.pathName),
        ...this._embargoedPaths,
      ),
    ]
  }
  addIndexedBlob(t, r) {
    this.addUploadedBlob(t, r), this.updateBlobIndexed(t)
  }
  addUploadedBlob(t, r) {
    this._store.add({
      blobName: t,
      pathName: r,
      status: "uploaded",
      uploadRequestedAt: Date.now(),
    })
  }
  getLastBlobNameForPath(t) {
    return this._store
      .search({ pathName: t })
      .reduce((n, i) =>
        n === undefined
          ? i
          : (n.uploadRequestedAt ?? 0) > (i.uploadRequestedAt ?? 0)
            ? n
            : i,
      )?.blobName
  }
  updateBlobIndexed(t) {
    let r = Date.now(),
      n = this._store.get(t)
    if (!n) {
      this._logger.debug(`[ERROR] Failed to find record for ${t}`)
      return
    }
    if (n.status === "indexed") {
      this._logger.debug(`[WARN] Blob ${t} is already indexed`)
      return
    }
    let i = this._store.search({ pathName: n.pathName, status: "indexed" })
    if (i.length === 0) {
      ;(n.status = "indexed"), (n.indexedAt = r)
      return
    }
    if (
      (i.reduce((o, a) =>
        (o.uploadRequestedAt ?? 0) > (a.uploadRequestedAt ?? 0) ? o : a,
      ).uploadRequestedAt ?? 0) > (n.uploadRequestedAt ?? 0)
    ) {
      this._logger.info(
        `Blob ${t} is indexed but there is a newer blob to upload for ${n.pathName}`,
      ),
        this._store.delete(t)
      return
    }
    for (let o of i) this._store.delete(o.blobName)
    ;(n.status = "indexed"), (n.indexedAt = r)
  }
  embargoPath(t) {
    if (this._embargoedPaths.has(t)) {
      this._logger.debug(`Path [${t}] is already embargoed`)
      return
    }
    this._logger.debug(`Embargoing path [${t}]`),
      this._store.deleteBy({ pathName: t }),
      this._embargoedPaths.add(t)
  }
  isEmbargoed(t) {
    return this._embargoedPaths.has(t)
  }
  updateBlobName(t, r) {
    let n = this._store.get(t)
    if (!n) {
      this._logger.debug(`[ERROR] Failed to find record for ${t}`)
      return
    }
    this._store.delete(t), (n.blobName = r), this._store.add(n)
  }
  getAllPathToIndexedBlob() {
    return this._store
      .search({ status: "indexed" })
      .reduce((t, r) => (t.set(r.pathName, r.blobName), t), new Map())
  }
}
var Bw = require("vscode")
var b2 = require("vscode"),
  s9 = new b2.EventEmitter(),
  o9 = s9.event,
  a9 = new b2.EventEmitter(),
  l9 = a9.event,
  c9 = new b2.EventEmitter(),
  u9 = c9.event
var MIe = q(F6())
var E2 = class {
  _queue = new MIe.default()
  config
  constructor(t = {}) {
    this.config = {
      sizeLimit: t.sizeLimit ?? 1e6,
      queueSizeManagement: t.queueSizeManagement ?? "REMOVE_OLDEST",
    }
  }
  enqueue(t) {
    if (this._queue.length >= this.config.sizeLimit) {
      if (this.config.queueSizeManagement === "REJECT_NEW_ITEMS") return false
      this.config.queueSizeManagement === "REMOVE_OLDEST" && this._queue.shift()
    }
    return this._queue.push(t), true
  }
  dequeue() {
    return this._queue.shift()
  }
  isEmpty() {
    return this._queue.isEmpty()
  }
  clear() {
    this._queue.clear()
  }
  peek() {
    return this.peek()
  }
  getItems() {
    return Object.freeze(this._queue.toArray())
  }
  size() {
    return this._queue.length
  }
}
var FIe = z("SimpleQueueProcessor"),
  Iw = class {
    queue
    _inProgress = false
    _disposed = false
    constructor(t = new E2()) {
      this.queue = t
    }
    enqueue(t) {
      return this.queue.enqueue(t)
    }
    dequeue() {
      return this.queue.dequeue()
    }
    isEmpty() {
      return this.queue.isEmpty()
    }
    clear() {
      this.queue.clear()
    }
    peek() {
      return this.queue.peek()
    }
    getItems() {
      return this.queue.getItems()
    }
    size() {
      return this.queue.size()
    }
    dispose() {
      this._disposed = true
    }
    retry(t, r) {
      setTimeout(() => {
        for (let n of t) this.enqueue(n)
        this.startProcess()
      }, r)
    }
    startProcess() {
      this._inProgress ||
        ((this._inProgress = true),
        Promise.resolve()
          .then(async () => {
            for (; !this.isEmpty() && !this.isDisposed(); ) {
              let t = this.peek()
              if ((await this.internalProcess(), t === this.peek())) break
            }
          })
          .catch((t) => {
            t instanceof Error
              ? FIe.info(
                  `Unhandled error while processing task: ${t.message} ${t.stack}`,
                )
              : FIe.info(`Unhandled error while processing task: ${t}`)
          })
          .finally(() => {
            this._inProgress = false
          }))
    }
    isDisposed() {
      return this._disposed
    }
  }
function Ubt(e, t) {
  let r = new Set(t.unknownBlobNames.concat(t.nonindexedBlobNames)),
    n = []
  for (let i of e) r.has(i) || n.push(i)
  return n
}
var d9 = class extends Iw {
    constructor(r, n) {
      super()
      this._apiServer = r
      this._config = n
    }
    _onFoundIndexedBlobNamesEmitter = new Bw.EventEmitter()
    _onFoundUnknownBlobNamesEmitter = new Bw.EventEmitter()
    _pollingStartTime = new Map()
    _logger = z("FileUploader#BlobStatusExecutor")
    dispose() {
      super.dispose(),
        this._pollingStartTime.clear(),
        this._onFoundIndexedBlobNamesEmitter.dispose(),
        this._onFoundUnknownBlobNamesEmitter.dispose()
    }
    get onFoundIndexedBlobNames() {
      return this._onFoundIndexedBlobNamesEmitter.event
    }
    get onFoundUnknownBlobNames() {
      return this._onFoundUnknownBlobNamesEmitter.event
    }
    retryBlobNames(r) {
      let [s, o] = r.reduce(
        (a, l) => {
          let c = this._pollingStartTime.get(l)
          return c === undefined
            ? (this._logger.debug(
                `[WARN] retryBlobNames: missing start time for ${l}`,
              ),
              a[1].push(l),
              a)
            : (Date.now() - c < this._config.oldBlobNameThresholdMs
                ? a[1].push(l)
                : a[0].push(l),
              a)
        },
        [[], []],
      )
      s.length > 0 && this.retry(s, this._config.newBlobNameRetryMs),
        o.length > 0 && this.retry(o, this._config.oldBlobNameRetryMs)
    }
    async internalProcess() {
      let r = new Set(),
        n = 0
      for (; n < this._config.maxBatchCount; ) {
        let o = this.dequeue()
        if (o === undefined) break
        r.add(o),
          this._pollingStartTime.has(o) ||
            this._pollingStartTime.set(o, Date.now()),
          n++
      }
      this._logger.verbose(`FindMissingProcess started: for [${r.size}] items`)
      let i
      try {
        i = await retryOperation(() => this._apiServer.findMissing([...r]), this._logger)
      } catch {
        this._logger.debug(
          `[ERROR] FindMissingProcess failed: for [${r.size}] items`,
        ),
          this.retryBlobNames([...r])
        return
      }
      if (i.unknownBlobNames.length > 0) {
        this._logger.debug(
          `FindMissingProcess found unknown: for [${i.unknownBlobNames.length}] items`,
        )
        for (let o of i.unknownBlobNames) this._pollingStartTime.delete(o)
        this._onFoundUnknownBlobNamesEmitter.fire(i.unknownBlobNames)
      }
      i.nonindexedBlobNames.length > 0 &&
        (this._logger.debug(
          `FindMissingProcess found nonindexed: for [${i.nonindexedBlobNames.length}] items`,
        ),
        this.retryBlobNames(i.nonindexedBlobNames))
      let s = Ubt(r, i)
      for (let o of s) this._pollingStartTime.delete(o)
      s.length > 0 &&
        (this._logger.verbose(
          `FindMissingProcess found not missing: for [${s.length}] items`,
        ),
        this._onFoundIndexedBlobNamesEmitter.fire(s))
    }
  },
  f9 = class extends Iw {
    constructor(r, n) {
      super()
      this._apiServer = r
      this._config = n
    }
    _onUploadedEmitter = new Bw.EventEmitter()
    _onFailedEmitter = new Bw.EventEmitter()
    _logger = z("FileUploader#UploadExecutor")
    dispose() {
      super.dispose(),
        this._onUploadedEmitter.dispose(),
        this._onFailedEmitter.dispose()
    }
    get onDidUpload() {
      return this._onUploadedEmitter.event
    }
    get onFailed() {
      return this._onFailedEmitter.event
    }
    async _processUpload(r) {
      let n = Date.now(),
        i
      this._logger.verbose(`Upload started [${n}]: for [${r.length}] items`),
        (i = await retryOperation(() => this._apiServer.batchUpload(r), this._logger)),
        this._logger.debug(
          `Upload complete [${n}]: for [${i.blobNames.length} / ${r.length}] items`,
        )
      let s = new Map()
      if (i !== undefined)
        for (let a = 0; a < i.blobNames.length; a++) {
          let l = r[a].blobName,
            c = i.blobNames[a]
          s.set(l, c),
            l !== c &&
              this._logger.debug(
                `[WARN]Upload blob name mismatch: ${l} -> ${c}`,
              )
        }
      let o = r.length - (i?.blobNames.length ?? 0)
      return { expectedToActualBlobNameMap: s, failedCount: o }
    }
    processResult(r, n) {
      let { expectedToActualBlobNameMap: i, failedCount: s } = r
      s > 0 &&
        (this._logger.debug(`[WARN] Scheduling for retry [${s}] items`),
        this.retry(n.slice(n.length - s), this._config.retryMs)),
        i.size > 0 && this._onUploadedEmitter.fire(i)
    }
    async internalProcess() {
      let r = 0,
        n = [],
        i = [],
        s = 0
      for (; !this.isDisposed() && s < this._config.maxBatchCount; ) {
        let o = this.peek()
        if (o === undefined) break
        let a = await o.readContent()
        if (a.length > this._config.maxUploadSize) {
          this._logger.debug(
            `[WARN] UploadExecutor: skipping upload for ${o.path} because it is too large`,
          ),
            this.dequeue()
          continue
        }
        if (r + a.length > this._config.maxUploadSize) break
        ;(r += a.length),
          n.push({
            pathName: o.path,
            text: a,
            blobName: o.blobName,
            metadata: [],
          }),
          i.push(o),
          this.dequeue(),
          s++
      }
      if (n.length === 0) {
        this._logger.debug("UploadExecutor: no items to upload")
        return
      }
      try {
        let o = await this._processUpload(n)
        this.processResult(o, i)
      } catch (o) {
        this._logger.debug(
          `[ERROR] UploadExecutor failed: for [${n.length}] items. Caused by: ${o.message} ${o.stack}`,
        ),
          await this.processIndividualUploads(i, n)
      }
    }
    async processIndividualUploads(r, n) {
      for (let i = 0; i < r.length; i++) {
        let s = r[i],
          o = n[i]
        try {
          let a = await this._processUpload([o])
          this.processResult(a, [s])
        } catch {
          this._logger.debug(
            `[ERROR] UploadExecutor failed: for [${s.blobName}]`,
          ),
            this._onFailedEmitter.fire(s)
        }
      }
    }
  },
  Obt = {
    uploadConfig: { maxUploadSize: 1e7, maxBatchCount: 128, retryMs: 6e4 },
    blobStatusConfig: {
      maxBatchCount: 1e3,
      oldBlobNameThresholdMs: 6e4,
      oldBlobNameRetryMs: 6e4,
      newBlobNameRetryMs: 3e3,
    },
  },
  _2 = class extends DisposableContainer {
    constructor(r, n, i = Obt) {
      super()
      this._blobNameCalculator = r
      this._apiServer = n
      this._config = i
      ;(this._uploadExecutor = new f9(n, i.uploadConfig)),
        (this._blobStatusExecutor = new d9(n, i.blobStatusConfig)),
        this.addDisposables(
          {
            dispose: () => {
              this._handledItems.clear()
            },
          },
          this._uploadExecutor,
          this._blobStatusExecutor,
          this._uploadExecutor.onDidUpload((s) => {
            a9.fire({ expectedToActualBlobNameMap: s })
            for (let [o, a] of s)
              this._handledItems.has(o) &&
                (o !== a &&
                  (this._handledItems.set(a, this._handledItems.get(o)),
                  this._handledItems.delete(o)),
                this._blobStatusExecutor.enqueue(a))
            this._blobStatusExecutor.startProcess()
          }),
          this._uploadExecutor.onFailed((s) => {
            this._logger.debug(`[ERROR] Upload failed: ${s.path}`),
              this._handledItems.delete(s.blobName),
              s9.fire({ blobName: s.blobName })
          }),
          this._blobStatusExecutor.onFoundIndexedBlobNames((s) => {
            for (let o of s) this._handledItems.delete(o)
            c9.fire({ blobNames: s })
          }),
          this._blobStatusExecutor.onFoundUnknownBlobNames((s) => {
            for (let o of s) {
              let a = this._handledItems.get(o)
              a && this._uploadExecutor.enqueue(a)
            }
            this._uploadExecutor.startProcess()
          }),
        )
    }
    _logger = z("BlobUploaderImpl")
    _uploadExecutor
    _blobStatusExecutor
    _handledItems = new Map()
    enqueueUpload(r, n) {
      let i = this._blobNameCalculator.calculate(r.path, n)
      if (i === undefined) {
        this._logger.debug(
          `blobNameCalculator returned undefined for ${r.path}`,
        )
        return
      }
      let s = { ...r, blobName: i }
      return (
        this._handledItems.set(i, s),
        this._logger.debug(
          `upload: ${r.path}. total: ${this._handledItems.size}`,
        ),
        this._blobStatusExecutor.enqueue(i),
        i
      )
    }
    startUpload() {
      this._blobStatusExecutor.startProcess()
    }
  }
var h9 = class {
    constructor(t) {
      this._blobNameCalculator = t
    }
    _logger = z("OpenDocumentSnapshotCache")
    _lastKnownText = new Map()
    handleDocumentOpened(t) {
      isNotebook(t.document) || this._lastKnownText.set(t.relPath, t.document.getText())
    }
    handleDocumentClosed(t) {
      this._lastKnownText.delete(t.relPath)
    }
    handleFileRename(t) {
      for (let r of this._lastKnownText.keys())
        if (Qs(t.oldRelPath, r)) {
          let n = t.newRelPath + r.slice(t.oldRelPath.length)
          this._lastKnownText.set(n, this._lastKnownText.get(r)),
            this._lastKnownText.delete(r)
        }
    }
    handleFileDeletion(t) {
      this._lastKnownText.delete(t.relPath)
    }
    _swapLastKnownText(t, r) {
      if (!this._lastKnownText.has(t)) {
        this._logger.verbose(
          `[WARN] no known last text for path [${t}]. initializing.`,
        ),
          this._lastKnownText.set(t, r)
        return
      }
      let n = this._lastKnownText.get(t)
      return this._lastKnownText.set(t, r), n
    }
    handleDocumentChange(t) {
      if (Object.prototype.hasOwnProperty.call(t.event, "notebook")) return
      t = t
      let r = t.event.document.getText(),
        n = this._swapLastKnownText(t.relPath, r)
      if (!n || t.event.contentChanges.length === 0) return
      let i = t.event.contentChanges.map(
        (s) =>
          new tc({
            beforeStart: s.rangeOffset,
            afterStart: s.rangeOffset,
            beforeText: n.substring(
              s.rangeOffset,
              s.rangeOffset + s.rangeLength,
            ),
            afterText: s.text,
          }),
      )
      if (i.length > 1) {
        i.sort((o, a) => o.beforeStart - a.beforeStart)
        let s = 0
        i = i.map((o) => {
          let a = o.afterStart + s
          return (
            (s += o.afterText.length - o.beforeText.length),
            new tc({
              beforeStart: o.beforeStart,
              afterStart: a,
              beforeText: o.beforeText,
              afterText: o.afterText,
            })
          )
        })
      }
      return new _g({
        path: t.relPath,
        edits: i,
        beforeBlobName: this._blobNameCalculator.calculateNoThrow(t.relPath, n),
        afterBlobName: this._blobNameCalculator.calculateNoThrow(t.relPath, r),
      }).normalize()
    }
    getLastKnownText(t) {
      return this._lastKnownText.get(t)
    }
  },
  x2 = class {
    constructor(t) {
      this._blobNameCalculator = t
      ;(this._openDocumentSnapshotCache = new h9(this._blobNameCalculator)),
        (this._fileEditsStore = new EventQueue(1e6))
    }
    _openDocumentSnapshotCache
    _fileEditsStore
    handleDocumentOpened(t) {
      this._openDocumentSnapshotCache.handleDocumentOpened(t)
    }
    handleDocumentClosed(t) {
      this._openDocumentSnapshotCache.handleDocumentClosed(t)
    }
    handleFileWillRename(t) {
      this._openDocumentSnapshotCache.handleFileRename(t)
    }
    handleFileDeletion(t) {
      this._openDocumentSnapshotCache.handleFileDeletion(t)
    }
    handleDocumentChange(t, r) {
      let n = this._openDocumentSnapshotCache.handleDocumentChange(t)
      return n === undefined ? 0 : this._fileEditsStore.addEvent(n, r)
    }
    getEvents() {
      return this._fileEditsStore.getEvents()
    }
    removeEventsPriorToBlob(t) {
      this._fileEditsStore.removeEventsPriorToBlob(t)
    }
    getLastKnownText(t) {
      return this._openDocumentSnapshotCache.getLastKnownText(t)
    }
  }
var g9 = class {
  constructor(t, r, n, i, s) {
    this.blobStatusStore = t
    this.fileEditProcessor = r
    this.fileChangeSizeCounter = n
    this.workspaceName = i
    this.folderId = s
  }
  dispose() {
    this.blobStatusStore.clear()
  }
}
var p9 = class {
  _size = 0
  _relPath = ""
  get size() {
    return this._size
  }
  add(t, r) {
    return (
      this._relPath !== r
        ? ((this._size = t), (this._relPath = r))
        : (this._size += t),
      this._size
    )
  }
  clear() {
    ;(this._size = 0), (this._relPath = "")
  }
}
function QIe(e) {
  return isNotebook(e)
    ? e.getCells().map((t) => t.document.getText()).join(`
`)
    : e.getText()
}
var qbt = 1e3
function Vbt(e) {
  return Object.prototype.hasOwnProperty.call(e.event, "notebook")
    ? e.event.notebook
    : e.event.document
}
var w2 = class extends DisposableContainer {
  constructor(r, n) {
    super()
    this._blobUploader = r
    this._blobNameCalculator = n
    this.addDisposables(
      u9((i) => this.handleBlobIndexed(i)),
      l9((i) => this.handleBlobUploaded(i)),
      o9((i) => this.handleBlobUploadFailed(i)),
    )
  }
  _folderResources = new Map()
  _logger = z("OpenFileManagerV2")
  _uploadingBlobToFolder = new Map()
  startTrackingFolder(r, n) {
    let i = new x2(this._blobNameCalculator),
      s = new g9(new C2(), i, new p9(), r, n)
    return this._folderResources.set(n, s), this.addDisposable(s), s
  }
  handleBlobIndexed(r) {
    for (let n of r.blobNames) {
      this._logger.verbose(`Blob ${n} indexed`)
      let i = this._uploadingBlobToFolder.get(n)
      if (i === undefined) {
        this._logger.debug(
          `[WARN] Blob ${n} was indexed but not tracked. Ignoring.`,
        )
        return
      }
      this._uploadingBlobToFolder.delete(n),
        this._folderResources.get(i)?.blobStatusStore.updateBlobIndexed(n),
        this._folderResources
          .get(i)
          ?.fileEditProcessor.removeEventsPriorToBlob(n)
    }
  }
  handleBlobUploadFailed(r) {
    let n = r.blobName
    this._uploadingBlobToFolder.has(n) &&
      (this._logger.debug(`Blob ${n} failed to upload`),
      this._uploadingBlobToFolder.delete(n))
  }
  handleBlobUploaded(r) {
    this._logger.verbose(
      `Handling ${r.expectedToActualBlobNameMap.size} uploaded blobs`,
    )
    for (let [n, i] of r.expectedToActualBlobNameMap) {
      if (n === i) continue
      let s = this._uploadingBlobToFolder.get(n)
      if (s === undefined) {
        this._logger.debug(`Blob ${n} was uploaded but not tracked. Ignoring.`)
        continue
      }
      this._logger.debug(
        `[WARN] Blob name mismatch. Expected ${n} but got ${i}.`,
      ),
        this._uploadingBlobToFolder.set(i, s),
        this._uploadingBlobToFolder.delete(n)
      let o = this._folderResources.get(s)
      if (o === undefined) {
        this._logger.debug(
          `[WARN] Blob ${n} was uploaded but folder ${s} is not tracked. Ignoring.`,
        )
        continue
      }
      o.blobStatusStore.updateBlobName(n, i)
    }
  }
  _upload(r, n, i, s) {
    let o = this._folderResources.get(r)?.workspaceName
    this._logger.info(`[${o}] Uploading [${i}] because [${s}]`)
    let a = this._blobUploader.enqueueUpload(
      { path: i, readContent: async () => n },
      n,
    )
    a &&
      (this._uploadingBlobToFolder.set(a, r),
      this._folderResources.get(r)?.blobStatusStore.addUploadedBlob(a, i))
  }
  stopTracking(r, n) {
    this._logger.info(
      `[${this._folderResources.get(r)?.workspaceName}] Stopping tracking [${n}]`,
    ),
      this._folderResources.get(r)?.blobStatusStore.removePath(n)
  }
  addOpenedDocument(r, n) {
    let i = this._folderResources.get(r.folderId)
    if (i === undefined)
      throw new Error(`Source folder [${r.folderId}] is not open`)
    let s = i.workspaceName
    isNotebook(r.document) &&
      this._logger.info(`TODO [${s}] Ignoring notebook document ${r.relPath}`)
    let o = QIe(r.document),
      a = this._blobNameCalculator.calculate(r.relPath, o)
    if (!a) {
      i.blobStatusStore.embargoPath(r.relPath),
        this._logger.debug(
          `[WARN] Failed to calculate blob name for ${r.relPath}`,
        )
      return
    }
    a !== n
      ? (this._upload(r.folderId, o, r.relPath, "new file"),
        this._logger.debug(
          `[INFO] Blob name mismatch. Expected ${n} but got ${a}.`,
        ))
      : i.blobStatusStore.addIndexedBlob(n, r.relPath)
  }
  getBlobName(r, n) {
    return this._folderResources.get(r)?.blobStatusStore?.getIndexedBlobName(n)
  }
  handleMissingBlob(r, n, i) {
    let s = this._folderResources.get(r)
    if (s === undefined) return false
    let o = s.blobStatusStore.isTrackingBlob(i),
      a = s.workspaceName
    if (!o) return false
    this._logger.info(`[${a}] Re-uploading ${i} for ${n} in ${r}`)
    let l = s.fileEditProcessor.getLastKnownText(n)
    return l === undefined ? false : (this._upload(r, l, n, "missing blob"), true)
  }
  handleClosedDocument(r) {
    let n = this._folderResources.get(r.folderId)?.workspaceName
    this._logger.info(`[${n}] Handling closed document ${r.relPath}`),
      this.stopTracking(r.folderId, r.relPath)
  }
  handleChangedDocument(r) {
    let n = this._folderResources.get(r.folderId)
    if (n === undefined) {
      this._logger.debug(
        `Ignoring change event for ${r.relPath} because folder is not tracked`,
      )
      return
    }
    if (n.blobStatusStore.isEmbargoed(r.relPath)) return
    let i = n.workspaceName
    if (Object.prototype.hasOwnProperty.call(r.event, "notebook")) {
      this._logger.debug(`[${i}] Ignoring notebook document ${r.relPath}`)
      return
    }
    let s = n.fileEditProcessor
    if (s === undefined) {
      this._logger.debug(
        `[${i}] Ignoring change event for ${r.relPath} because folder is not tracked`,
      )
      return
    }
    let o = n.blobStatusStore.getLastBlobNameForPath(r.relPath),
      a = s.handleDocumentChange(r, o)
    ;(n.fileChangeSizeCounter.add(a, r.relPath) ?? 0) > qbt &&
      (this._upload(r.folderId, QIe(Vbt(r)), r.relPath, "large change"),
      n.fileChangeSizeCounter.clear())
  }
  isTracked(r, n) {
    return this._folderResources.get(r)?.blobStatusStore.isTrackingPath(n) ?? false
  }
  getTrackedPaths(r) {
    return this._folderResources.get(r)?.blobStatusStore.getTrackedPaths() ?? []
  }
  translateRange(r, n, i, s) {
    let o = this.getBlobName(r, n)
    if (o === undefined) return
    let a = { blobName: o, beginOffset: i, endOffset: s },
      l = (u, f) => {
        if (u.afterStart > f.endOffset) return f
        if (u.afterEnd < f.beginOffset) {
          let p = u.afterText.length - u.beforeText.length
          return {
            blobName: f.blobName,
            beginOffset: f.beginOffset - p,
            endOffset: f.endOffset - p,
          }
        }
        return {
          blobName: f.blobName,
          beginOffset: Math.min(u.afterStart, f.beginOffset),
          endOffset: Math.max(u.afterEnd, f.endOffset),
        }
      },
      c =
        this._folderResources
          .get(r)
          ?.fileEditProcessor.getEvents()
          .filter((u) => u.path === n) ?? []
    for (let u of c) for (let f of u.edits) a = l(f, a)
    return a
  }
  getAllEditEvents() {
    let r = new Map()
    return Array.from(this._folderResources.keys()).reduce((n, i) => {
      let s = Number(i)
      return (
        n.set(
          s,
          this._folderResources.get(s)?.fileEditProcessor.getEvents() ?? [],
        ),
        n
      )
    }, r)
  }
  getAllPathToIndexedBlob() {
    let r = new Map()
    return Array.from(this._folderResources.keys()).reduce((n, i) => {
      let s = Number(i)
      return (
        n.set(
          s,
          this._folderResources
            .get(s)
            ?.blobStatusStore.getAllPathToIndexedBlob() ?? new Map(),
        ),
        n
      )
    }, r)
  }
}
var NIe = q(require("vscode"))
var m9 = require("vscode")
var Rw = class extends Error {
    constructor(r, n) {
      let i = r instanceof Error ? r.message : `${r}`
      super(`WorkQueueItemFailed: ${i}, retry = ${n}`)
      this.toThrow = r
      this.retry = n
    }
  },
  A9 = class {
    throwError(t, r) {
      throw new Rw(t, r)
    }
  },
  y9 = class {
    progressReporter
    completedItems = 0
    totalItems
    constructor(t, r) {
      ;(this.progressReporter = t),
        (this.totalItems = r),
        this.update(0, this.totalItems)
    }
    update(t, r) {
      ;(this.completedItems += t),
        (this.totalItems = this.completedItems + r),
        this.progressReporter.update(this.completedItems, this.totalItems)
    }
    cancel() {
      this.progressReporter.cancel()
    }
  },
  v9 = class {
    constructor(t, r) {
      this.item = t
      this.process = r
    }
    itemCount() {
      return 1
    }
    start(t) {
      return this.process(this.item, t)
    }
  },
  C9 = class {
    constructor(t, r) {
      this.items = t
      this.process = r
    }
    itemCount() {
      return this.items.size
    }
    start(t) {
      return this.process(this.items, t)
    }
  },
  S2 = class {
    queue = new Set()
    get size() {
      return this.queue.size
    }
    add(t) {
      this.queue.add(t)
    }
    delete(t) {
      this.queue.delete(t)
    }
  },
  b9 = class extends S2 {
    constructor(r) {
      super()
      this.process = r
    }
    dequeue() {
      let r = this.queue.values().next()
      if (r.done) throw new Error("Cannot dequeue from empty queue")
      let n = r.value
      return this.queue.delete(n), new v9(n, this.process)
    }
  },
  E9 = class extends S2 {
    constructor(r, n) {
      super()
      this.process = r
      this._maxBatchSize = n
    }
    dequeue() {
      let r
      if (
        this._maxBatchSize === undefined ||
        this.queue.size <= this._maxBatchSize
      )
        (r = this.queue), (this.queue = new Set())
      else {
        r = new Set()
        let n = this.queue.values()
        for (let i = 0; i < this._maxBatchSize; i++) {
          let s = n.next()
          if (s.done) break
          let o = s.value
          this.queue.delete(o), r.add(o)
        }
      }
      return new C9(r, this.process)
    }
  },
  I2 = class e {
    constructor(t, r, n, i) {
      this.name = t
      this.shutdownError = n
      if ("processOne" in r) this.queue = new b9(r.processOne)
      else if ("processBatch" in r)
        this.queue = new E9(r.processBatch, r.maxBatchSize)
      else throw new Error("Invalid processor type")
      ;(this.backoffParams = i || e.defaultBackoffParams),
        (this.logger = z(`WorkQueue[${t}]`)),
        (this.errorHandler = new A9())
    }
    static queueStatusChanged = "QueueStatusChanged"
    static itemFailed = "ItemFailed"
    static defaultBackoffParams = { initialMS: 100, mult: 2, maxMS: 3e4 }
    eventEmitters = {
      [e.queueStatusChanged]: new m9.EventEmitter(),
      [e.itemFailed]: new m9.EventEmitter(),
    }
    queue
    countReporters = new Set()
    progressReporters = new Set()
    errorHandler
    backoffParams
    itemsInProgress = 0
    stopping = false
    logger
    stop() {
      ;(this.stopping = true), this.update(), this.notifyStatusChanged()
    }
    add(t) {
      this.stopping || (this.queue.add(t), this.update(), this.kick())
    }
    delete(t) {
      this.stopping || (this.queue.delete(t), this.update())
    }
    size() {
      return this.queue.size + this.itemsInProgress
    }
    reportQueueSize(t) {
      let r = this.size()
      t.update(r), this.countReporters.add(t)
    }
    awaitEmpty(t, r = true) {
      if (this.stopping) return Promise.resolve()
      let n = this.size()
      return n === 0
        ? Promise.resolve()
        : (t && this.progressReporters.add(new y9(t, n)),
          new Promise((i, s) => {
            let o = []
            function a() {
              for (let l of o) l.dispose()
            }
            o.push(
              this.eventEmitters[e.queueStatusChanged].event(() => {
                a(), this.stopping ? s(this.shutdownError) : i()
              }),
            ),
              r &&
                o.push(
                  this.eventEmitters[e.itemFailed].event((l) => {
                    a(), s(l)
                  }),
                )
          }))
    }
    update(t = 0) {
      if (this.stopping) {
        for (let r of this.countReporters) r.cancel()
        for (let r of this.progressReporters) r.cancel()
      } else {
        this.itemsInProgress -= t
        let r = this.size()
        for (let n of this.countReporters) n.update(r)
        for (let n of this.progressReporters) n.update(t, r)
      }
    }
    notifyStatusChanged() {
      this.eventEmitters[e.queueStatusChanged].fire(null),
        this.progressReporters.clear()
    }
    notifyItemFailed(t) {
      let r = t instanceof Rw ? t.toThrow : t
      this.eventEmitters[e.itemFailed].fire(r)
    }
    delay(t) {
      return new Promise((r) => setTimeout(r, t))
    }
    async kick() {
      if (!this.itemsInProgress) {
        for (; !this.stopping && this.queue.size !== 0; ) {
          let t = this.queue.dequeue()
          this.itemsInProgress = t.itemCount()
          let r = 0,
            n = 0
          do {
            try {
              await t.start(this.errorHandler),
                n && this.logger.debug(`item succeeded; retries = ${n}`)
              break
            } catch (i) {
              if ((this.notifyItemFailed(i), !(i instanceof Rw && i.retry))) {
                this.logger.debug(`item failed, not retrying; retries = ${n}`)
                break
              }
            }
            this.logger.debug(
              `item failed, retrying in ${r} ms; retries = ${n}`,
            ),
              await this.delay(r),
              this.logger.debug("retrying"),
              r === 0
                ? (r = this.backoffParams.initialMS)
                : (r = Math.min(
                    r * this.backoffParams.mult,
                    this.backoffParams.maxMS,
                  )),
              n++
          } while (!this.stopping)
          this.stopping || this.update(this.itemsInProgress)
        }
        this.notifyStatusChanged()
      }
    }
  }
function pC(e, t) {
  let r = new Set(t)
  return e.filter((n) => !r.has(n))
}
var BlobsCheckpointManager = class BlobsCheckpointManager extends DisposableContainer {
  static defaultCheckpointThreshold = 1e3
  _checkpointId
  _checkpointBlobNames = new Map()
  _toAdd = new Map()
  _toRemove = new Set()
  _apiServer
  _logger
  _checkpointQueue
  _checkpointThreshold
  _maxCheckpointBatchSize = 10000
  _featureFlagManager
  _onContextChange = new NIe.EventEmitter()
  onContextChange = this._onContextChange.event
  get _flags() {
    return this._featureFlagManager.currentFlags
  }
  constructor(apiServer, featureFlagManager, onDidChangeBlobName, threshold) {
    super(),
      (this._logger = z("BlobsCheckpointManager")),
      (this._checkpointId = undefined),
      (this._apiServer = apiServer),
      (this._featureFlagManager = featureFlagManager),
      (this._checkpointThreshold = threshold ?? BlobsCheckpointManager.defaultCheckpointThreshold),
      this.addDisposable(
        onDidChangeBlobName((blobChangeEvent) => {
          this.updateBlob(blobChangeEvent.absPath, blobChangeEvent.prevBlobName, blobChangeEvent.newBlobName)
        }),
      ),
      (this._checkpointQueue = new I2("checkpoint", {
        processOne: async (task, context) => await this._checkpoint(task, context),
      })),
      this._logger.info(
        `BlobsCheckpointManager created. checkpointThreshold: ${this._checkpointThreshold}`,
      )
  }
  refBlob(blobName) {
    let refCount = this._checkpointBlobNames.get(blobName)
    refCount !== undefined
      ? (this._checkpointBlobNames.set(blobName, refCount + 1),
        refCount === 0 && this._toRemove.delete(blobName))
      : this._toAdd.set(blobName, (this._toAdd.get(blobName) ?? 0) + 1)
  }
  derefBlob(blobName) {
    !this.derefFromCheckpoint(blobName) &&
      !this.derefFromAdded(blobName) &&
      this._logger.error(
        `derefBlob: blob ${blobName} not found in checkpoint or toAdd`,
      )
  }
  derefFromCheckpoint(blobName) {
    let refCount = this._checkpointBlobNames.get(blobName)
    return refCount === undefined || refCount <= 0
      ? (refCount !== undefined &&
          this._logger.error(
            `derefFromCheckpoint: blob ${blobName} has reference count ${refCount}. In toRemove? ${this._toRemove.has(blobName)}`,
          ),
        false)
      : (this._checkpointBlobNames.set(blobName, refCount - 1),
        refCount === 1 && this._toRemove.add(blobName),
        true)
  }
  derefFromAdded(blobName) {
    let refCount = this._toAdd.get(blobName)
    return refCount === undefined
      ? false
      : refCount <= 1
        ? (this._toAdd.delete(blobName), refCount === 1)
        : (this._toAdd.set(blobName, refCount - 1), true)
  }
  getCheckpointedBlobNames() {
    return Array.from(this._checkpointBlobNames.keys())
  }
  getContext() {
    return {
      checkpointId: this._checkpointId,
      addedBlobs: Array.from(this._toAdd.keys()),
      deletedBlobs: Array.from(this._toRemove),
    }
  }
  getContextAdjusted(additionalBlobs, removedBlobs) {
    let adjustedAddedBlobs = new Set(this._toAdd.keys()),
      adjustedRemovedBlobs = new Set(this._toRemove)
    for (let blobName of additionalBlobs) this._checkpointBlobNames.has(blobName) || adjustedAddedBlobs.add(blobName), adjustedRemovedBlobs.delete(blobName)
    for (let blobName of removedBlobs) this._checkpointBlobNames.has(blobName) && adjustedRemovedBlobs.add(blobName), adjustedAddedBlobs.delete(blobName)
    return {
      checkpointId: this._checkpointId,
      addedBlobs: Array.from(adjustedAddedBlobs),
      deletedBlobs: Array.from(adjustedRemovedBlobs),
    }
  }
  blobsPayload(requestedBlobs) {
    let checkpointedBlobs = this.getCheckpointedBlobNames(),
      addedBlobs = pC(requestedBlobs, checkpointedBlobs),
      deletedBlobs = pC(checkpointedBlobs, requestedBlobs)
    return { checkpointId: this._checkpointId, addedBlobs: addedBlobs, deletedBlobs: deletedBlobs }
  }
  expandBlobs(blobsContext) {
    if (blobsContext.checkpointId === undefined) return blobsContext.addedBlobs
    if (blobsContext.checkpointId !== this._checkpointId)
      throw new Error(
        `expandBlobs: checkpointId mismatch: ${blobsContext.checkpointId} != ${this._checkpointId}`,
      )
    let allBlobs = this.getCheckpointedBlobNames()
    if ((allBlobs.push(...blobsContext.addedBlobs), blobsContext.deletedBlobs.length > 0)) {
      let deletedBlobsSet = new Set(blobsContext.deletedBlobs)
      return allBlobs.filter((blob) => !deletedBlobsSet.has(blob))
    }
    return allBlobs
  }
  validateMatching(leftContext, rightContext, verbose = false) {
    if (leftContext.checkpointId !== rightContext.checkpointId)
      return (
        this._logger.error(
          `checkpointId mismatch: ${leftContext.checkpointId} vs ${rightContext.checkpointId}`,
        ),
        false
      )
    let isValid = true,
      leftOnlyAdded = pC(leftContext.addedBlobs, rightContext.addedBlobs),
      rightOnlyAdded = pC(rightContext.addedBlobs, leftContext.addedBlobs)
    return (
      (leftOnlyAdded.length > 0 || rightOnlyAdded.length > 0) &&
        ((isValid = false),
        this._logger.error(`addedBlobs mismatch: -${leftOnlyAdded.length}/+${rightOnlyAdded.length}`),
        verbose &&
          (this._logger.error(`left-added: ${leftOnlyAdded.slice(0, 5).join(",")}`),
          this._logger.error(`right-added: ${rightOnlyAdded.slice(0, 5).join(",")}`))),
      (leftOnlyAdded = pC(leftContext.deletedBlobs, rightContext.deletedBlobs)),
      (rightOnlyAdded = pC(rightContext.deletedBlobs, leftContext.deletedBlobs)),
      (leftOnlyAdded.length > 0 || rightOnlyAdded.length > 0) &&
        ((isValid = false),
        this._logger.error(`deletedBlobs mismatch: -${leftOnlyAdded.length}/+${rightOnlyAdded.length}`),
        verbose &&
          (this._logger.error(`left-deleted: ${leftOnlyAdded.slice(0, 5).join(",")}`),
          this._logger.error(`right-deleted: ${rightOnlyAdded.slice(0, 5).join(",")}`))),
      isValid
    )
  }
  updateBlob(filePath, prevBlobName, newBlobName) {
    this._logger.verbose(`notifyBlobChange ${filePath}: ${prevBlobName} to ${newBlobName}`), // =
      newBlobName && newBlobName !== prevBlobName && this.refBlob(newBlobName),
      prevBlobName && newBlobName !== prevBlobName && this.derefBlob(prevBlobName),
      this._toAdd.size + this._toRemove.size >= this._checkpointThreshold &&
        this._checkpointQueue.size() === 0 &&
        this._queueCheckpoint()
  }
  resetCheckpoint() {
    for (let [blobName, refCount] of this._checkpointBlobNames)
      refCount > 0
        ? this._toAdd.set(blobName, refCount)
        : this._toRemove.delete(blobName) ||
          this._logger.warn(
            `blob with 0 references was not found in toRemove: ${blobName}`,
          )
    for (let blobName of this._toRemove)
      this._logger.warn(`blob in toRemove was not found in checkpoint: ${blobName}`)
    this._toRemove.clear(),
      (this._checkpointId = undefined),
      this._checkpointBlobNames.clear(),
      this._onContextChange.fire(this.getContext())
  }
  async awaitEmptyQueue() {
    await this._checkpointQueue.awaitEmpty(undefined, false)
  }
  async _checkpoint(checkpointTask, queueContext) {
    let { checkpointId, addedBlobs, deletedBlobs } = checkpointTask
    this._logger.debug(`Begin checkpoint of working set into ${checkpointId}`),
      this._logger.debug(
        `add ${addedBlobs.length} blobs, remove ${deletedBlobs.length} blobs into ${checkpointId}`,
      )
    let response = { newCheckpointId: "" }
    try {
      response = await this._apiServer.checkpointBlobs(checkpointTask)
    } catch (error) {
      let errorMessage = error instanceof Error ? error.message : `${error}`,
        currentCheckpoint = this._checkpointId ? this._checkpointId : "{initial}"
      ApiError.isAPIErrorWithStatus(error, RequestStatus.invalidArgument) ||
      ApiError.isAPIErrorWithStatus(error, RequestStatus.unimplemented)
        ? (this._logger.warn(
            `checkpoint-blobs from ${currentCheckpoint} failed with invalid argument: ${errorMessage}. Recreating checkpoint.`,
          ),
          this.resetCheckpoint(),
          this._queueCheckpoint(),
          queueContext.throwError(error, false))
        : (this._logger.error(`checkpoint-blobs failed with error: ${errorMessage}.`),
          queueContext.throwError(error, false))
    }
    if (checkpointId !== this._checkpointId)
      this._logger.warn(
        `original checkpointId ${checkpointId} does not match current checkpointId ${this._checkpointId}. Abandoning new checkpoint.`,
      )
    else {
      this._logger.debug(`checkpointId ${checkpointId} advanced to ${response.newCheckpointId}`),
        (this._checkpointId = response.newCheckpointId)
      for (let blobName of addedBlobs) {
        let refCount = this._toAdd.get(blobName)
        refCount === undefined
          ? (this._checkpointBlobNames.set(blobName, 0), this._toRemove.add(blobName))
          : (this._checkpointBlobNames.set(blobName, refCount), this._toAdd.delete(blobName))
      }
      for (let blobName of deletedBlobs) {
        let refCount = this._checkpointBlobNames.get(blobName)
        refCount === undefined
          ? this._logger.warn(
              `In _checkpoint: deleted blob ${blobName} not found in checkpoint`,
            )
          : refCount > 0 && this._toAdd.set(blobName, refCount),
          this._checkpointBlobNames.delete(blobName),
          this._toRemove.delete(blobName)
      }
      this._onContextChange.fire(this.getContext())
    }
    this._toAdd.size + this._toRemove.size >= this._checkpointThreshold &&
      (this._logger.debug(
        `starting a new round of checkpointing due to size ${this._toAdd.size} + ${this._toRemove.size}`,
      ),
      this._queueCheckpoint())
  }
  _queueCheckpoint() {
    this._logger.debug("queue checkpoint")
    let blobsToAdd = Array.from(this._toAdd.keys()).slice(
        0,
        this._maxCheckpointBatchSize,
      ),
      blobsToRemove = Array.from(this._toRemove).slice(0, this._maxCheckpointBatchSize),
      checkpointTask = { checkpointId: this._checkpointId, addedBlobs: blobsToAdd, deletedBlobs: blobsToRemove }
    this._logger.debug(
      `queue checkpoint: version: ${checkpointTask.checkpointId}, add: ${checkpointTask.addedBlobs.length} blobs, rm: ${checkpointTask.deletedBlobs.length} blob`,
    ),
      this._checkpointQueue.add(checkpointTask)
  }
}
var Dw = q(require("vscode"))
function Sg(e, t, r, n) {
  let i = 0
  for (let s of r)
    if ((e.log(t, `  ${s}`), i++, n !== undefined && i >= n)) {
      e.log(t, "  ...")
      break
    }
}
var SizeConstrainedCollection = class {
    constructor(maxItems, maxByteSizeLimit) {
      this.maxItems = maxItems
      this.maxByteSize = maxByteSizeLimit
    }
    items = new Map()
    byteSize = 0
    addItem(key, item) {
      let existingItems = this.items.get(key)
      if (existingItems === undefined) {
        if (
          this.items.size >= this.maxItems ||
          this.byteSize + item.byteSize >= this.maxByteSize
        )
          return false
        this.items.set(key, [item]), (this.byteSize += item.byteSize)
      } else existingItems.push(item)
      return true
    }
  },
  LimitedCollection = class {
    constructor(maxCount) {
      this.maxItemCount = maxCount
    }
    items = new Map()
    get full() {
      return this.items.size >= this.maxItemCount
    }
    addItem(key, value) {
      if (this.items.has(key)) return false
      this.items.set(key, value)
    }
  },
  DiskFileManager = class DiskFileManager extends DisposableContainer {
    constructor(workspaceName, apiServer, pathHandler, pathMap, probeBatchSize) {
      super()
      this.workspaceName = workspaceName
      this._apiServer = apiServer
      this._pathHandler = pathHandler
      this._pathMap = pathMap
      ;(this._logger = z(`DiskFileManager[${workspaceName}]`)),
        probeBatchSize === undefined
          ? (this._probeBatchSize = DiskFileManager.maxProbeBatchSize)
          : (probeBatchSize < DiskFileManager.minProbeBatchSize
              ? this._logger.verbose(
                  `Rejecting requested probe batch size of ${probeBatchSize} (min = ${DiskFileManager.minProbeBatchSize})`,
                )
              : probeBatchSize > DiskFileManager.maxProbeBatchSize &&
                this._logger.verbose(
                  `Rejecting requested probe batch size of ${probeBatchSize} (max = ${DiskFileManager.maxProbeBatchSize})`,
                ),
            (this._probeBatchSize = Math.max(
              Math.min(probeBatchSize, DiskFileManager.maxProbeBatchSize),
              DiskFileManager.minProbeBatchSize,
            ))),
        (this._toCalculate = new KeyedTaskQueue(this._calculate.bind(this))),
        this.addDisposable(this._toCalculate),
        (this._toProbe = new KeyedTaskQueue(this._probe.bind(this))),
        this.addDisposable(this._toProbe),
        (this._probeBatch = this._newProbeBatch()),
        (this._toUpload = new KeyedTaskQueue(this._upload.bind(this))),
        this.addDisposable(this._toUpload),
        (this._uploadBatch = this._newUploadBatch()),
        (this._probeRetryWaiters = new KeyedTaskQueue(this._enqueueForProbe.bind(this))),
        this.addDisposable(this._probeRetryWaiters),
        (this._probeRetryKicker = new Oc(
          this._probeRetryWaiters,
          DiskFileManager.probeRetryPeriodMs,
        )),
        this.addDisposable(this._probeRetryKicker),
        (this._probeRetryBackoffWaiters = new KeyedTaskQueue(
          this._enqueueForProbe.bind(this),
        )),
        (this._probeRetryBackoffKicker = new Oc(
          this._probeRetryBackoffWaiters,
          DiskFileManager.probeRetryBackoffPeriodMs,
        )),
        this.addDisposable(this._probeRetryBackoffKicker)
    }
    static minProbeBatchSize = 1
    static maxProbeBatchSize = 1e3
    static maxUploadBatchBlobCount = 128
    static maxUploadBatchByteSize = 1e6
    static probeRetryPeriodMs = 3 * 1e3
    static probeBackoffAfterMs = 60 * 1e3
    static probeRetryBackoffPeriodMs = 60 * 1e3
    _notAPlainFile = "Not a file"
    _fileNotAccessible = "File not readable"
    _fileNotText = "Binary file"
    _fileUploadFailure = "Upload failed"
    _onDidChangeInProgressItemCountEmitter = new Dw.EventEmitter()
    onDidChangeInProgressItemCount =
      this._onDidChangeInProgressItemCountEmitter.event
    _onQuiescedEmitter = new Dw.EventEmitter()
    _onQuiesced = this._onQuiescedEmitter.event
    _textDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true })
    _toCalculate
    _toProbe
    _probeBatch
    _probeBatchSize
    _probeRetryWaiters
    _probeRetryKicker
    _probeRetryBackoffWaiters
    _probeRetryBackoffKicker
    _toUpload
    _uploadBatch
    _itemsInFlight = new Map()
    _seq = 1e3
    metrics = new hC("File metrics")
    _logger
    _stopping = false
    _pathsAccepted = this.metrics.counterMetric("paths accepted")
    _pathsNotAccessible = this.metrics.counterMetric("paths not accessible")
    _nonFiles = this.metrics.counterMetric("not plain files")
    _largeFiles = this.metrics.counterMetric("large files")
    _blobNameCalculationFails = this.metrics.counterMetric(
      "blob name calculation fails",
    )
    _encodingErrors = this.metrics.counterMetric("encoding errors")
    _mtimeCacheHits = this.metrics.counterMetric("mtime cache hits")
    _mtimeCacheMisses = this.metrics.counterMetric("mtime cache misses")
    _probeBatches = this.metrics.counterMetric("probe batches")
    _blobNamesProbed = this.metrics.counterMetric("blob names probed")
    _filesRead = this.metrics.counterMetric("files read")
    _blobsUploaded = this.metrics.counterMetric("blobs uploaded")
    _ingestPathMs = this.metrics.timingMetric("ingestPath")
    _probeMs = this.metrics.timingMetric("probe")
    _statMs = this.metrics.timingMetric("stat")
    _readMs = this.metrics.timingMetric("read")
    _uploadMs = this.metrics.timingMetric("upload")
    stop() {
      this.dispose()
    }
    dispose() {
      ;(this._stopping = true), super.dispose()
    }
    get probeBatchSize() {
      return this._probeBatchSize
    }
    get itemsInFlight() {
      return this._itemsInFlight.size
    }
    ingestPath(folderId, relativePath) {
      this._ingestPathMs.start(),
        !this._stopping &&
          ((relativePath = Y0e(relativePath)),
          this._enqueueForCalculate(folderId, relativePath),
          this._ingestPathMs.stop())
    }
    async awaitQuiesced() {
      if (!(this._stopping || this._itemsInFlight.size === 0))
        return createDisposablePromise(this._onQuiesced)
    }
    _nextSeq() {
      return this._seq++
    }
    _makeAbsPath(folderId, relativePath) {
      let repoRoot = this._pathMap.getRepoRoot(folderId)
      if (repoRoot !== undefined) return joinPaths(repoRoot, relativePath)
    }
    _fileTooLargeString(fileSize) {
      return `File too large (${fileSize} > ${this._pathHandler.maxBlobSize})`
    }
    _getMtime(absolutePath, folderId, relativePath, seqId) {
      this._statMs.start()
      let pathInfo = this._pathHandler.classifyPath(absolutePath)
      switch ((this._statMs.stop(), pathInfo.type)) {
        case "inaccessible":
          this._pathsNotAccessible.increment(),
            this._pathMapInvalidate(folderId, relativePath, seqId, this._fileNotAccessible)
          return
        case "not a file":
          this._nonFiles.increment(),
            this._pathMapInvalidate(folderId, relativePath, seqId, this._notAPlainFile)
          return
        case "large file":
          this._largeFiles.increment(),
            this._pathMapInvalidate(folderId, relativePath, seqId, this._fileTooLargeString(pathInfo.size))
          return
        case "accepted":
          return pathInfo.mtime
      }
    }
    async _readAndValidate(absolutePath, folderId, relativePath, seqId) {
      this._readMs.start()
      let fileResult = await this._pathHandler.readText(absolutePath)
      switch ((this._readMs.stop(), this._filesRead.increment(), fileResult.type)) {
        case "inaccessible":
          this._pathsNotAccessible.increment(),
            this._pathMapInvalidate(folderId, relativePath, seqId, this._fileNotAccessible)
          return
        case "large file":
          this._largeFiles.increment(),
            this._pathMapInvalidate(folderId, relativePath, seqId, this._fileTooLargeString(fileResult.size))
          return
        case "binary":
          this._pathMapInvalidate(folderId, relativePath, seqId, this._fileNotText)
          return
        case "text":
          return fileResult.contents
      }
    }
    _calculateBlobName(relativePath, fileContents, folderId, seqId) {
      try {
        return this._pathHandler.calculateBlobName(relativePath, fileContents)
      } catch (error) {
        if (error instanceof ContentSizeExceededError) {
          this._largeFiles.increment()
          let errorMessage = this._fileTooLargeString(fileContents.length)
          this._pathMapInvalidate(folderId, relativePath, seqId, errorMessage)
        } else
          this._blobNameCalculationFails.increment(),
            this._pathMapInvalidate(folderId, relativePath, seqId, getErrorMessage(error))
        return
      }
    }
    async _calculate(item) {
      if (item === undefined) return
      let [seqId, [folderId, relativePath]] = item
      if (!this._pathMapVerify(folderId, relativePath, seqId)) return
      let absolutePath = this._makeAbsPath(folderId, relativePath)
      if (absolutePath === undefined) {
        this._inflightItemRemove(seqId)
        return
      }
      let mtime = this._getMtime(absolutePath, folderId, relativePath, seqId)
      if (mtime === undefined) return
      let blobName,
        cacheInfo = this._pathMap.getBlobInfo(folderId, relativePath, mtime)
      if (cacheInfo !== undefined) {
        this._mtimeCacheHits.increment()
        let [cachedBlobName, cacheStatus] = cacheInfo
        if (cacheStatus > 0) {
          this._pathMapUpdate(folderId, relativePath, seqId, cachedBlobName, mtime)
          return
        }
        blobName = cachedBlobName
      } else {
        let fileContents = await this._readAndValidate(absolutePath, folderId, relativePath, seqId)
        if (
          fileContents === undefined ||
          (this._mtimeCacheMisses.increment(),
          (blobName = this._calculateBlobName(relativePath, fileContents, folderId, seqId)),
          blobName === undefined)
        )
          return
      }
      this._pathsAccepted.increment()
      let probeItem = {
        folderId: folderId,
        relPath: relativePath,
        blobName: blobName,
        mtime: mtime,
        startTime: Date.now(),
      }
      this._enqueueForProbeRetry(seqId, probeItem)
    }
    _newProbeBatch() {
      return new LimitedCollection(this._probeBatchSize)
    }
    _grabProbeBatch() {
      if (this._probeBatch.items.size === 0) return
      let currentBatch = this._probeBatch
      return (this._probeBatch = this._newProbeBatch()), currentBatch
    }
    async _probe(item) {
      if (item !== undefined) {
        let [seqId, probeItem] = item
        if (
          !this._pathMapVerify(probeItem.folderId, probeItem.relPath, seqId) ||
          (this._probeBatch.addItem(seqId, probeItem), !this._probeBatch.full)
        )
          return
      }
      let batch = this._grabProbeBatch()
      if (batch === undefined) return
      let blobSet = new Set()
      for (let [seqId, probeItem] of batch.items) blobSet.add(probeItem.blobName)
      this._probeBatches.increment(),
        this._blobNamesProbed.increment(batch.items.size),
        this._logger.verbose(`probe ${blobSet.size} blobs`),
        this._probeMs.start()
      let result
      try {
        result = await retryOperation(
          async () => this._apiServer.findMissing([...blobSet]),
          this._logger,
        )
      } catch {}
      if ((this._probeMs.stop(), result !== undefined)) {
        this._logger.verbose(
          `find-missing reported ${result.unknownBlobNames.length} unknown blob names and ${result.nonindexedBlobNames.length} nonindexed blob names.`,
        ),
          result.unknownBlobNames.length > 0 &&
            (this._logger.verbose("unknown blob names:"),
            Sg(this._logger, "verbose", result.unknownBlobNames, 5)),
          result.nonindexedBlobNames.length > 0 &&
            (this._logger.verbose("nonindexed blob names:"),
            Sg(this._logger, "verbose", result.nonindexedBlobNames, 5))
        let unknownBlobs = new Set(result.unknownBlobNames),
          nonindexedBlobs = new Set(result.nonindexedBlobNames),
          uploadBatch = this._beginUploadBatch()
        for (let [seqId, itemInfo] of batch.items)
          this._pathMapVerify(itemInfo.folderId, itemInfo.relPath, seqId) &&
            (unknownBlobs.has(itemInfo.blobName)
              ? this._enqueueForUpload(seqId, itemInfo.folderId, itemInfo.relPath, false)
              : nonindexedBlobs.has(itemInfo.blobName)
                ? this._enqueueForProbeRetry(seqId, itemInfo)
                : this._pathMapUpdate(
                    itemInfo.folderId,
                    itemInfo.relPath,
                    seqId,
                    itemInfo.blobName,
                    itemInfo.mtime,
                  ))
        uploadBatch.dispose()
      } else for (let [seqId, itemInfo] of batch.items) this._enqueueForProbeRetry(seqId, itemInfo)
    }
    _newUploadBatch() {
      return new SizeConstrainedCollection(DiskFileManager.maxUploadBatchBlobCount, DiskFileManager.maxUploadBatchByteSize)
    }
    _grabUploadBatch() {
      if (this._uploadBatch.items.size === 0) return
      let currentBatch = this._uploadBatch
      return (this._uploadBatch = this._newUploadBatch()), currentBatch
    }
    async _upload(item) {
      let newItem
      if (item !== undefined) {
        let [absolutePath, { seq, folderId, relPath }] = item
        if (!this._pathMapVerify(folderId, relPath, seq)) return
        let mtime = this._getMtime(absolutePath, folderId, relPath, seq)
        if (mtime === undefined) return
        let fileContents = await this._readAndValidate(absolutePath, folderId, relPath, seq)
        if (fileContents === undefined) return
        let blobName = this._calculateBlobName(relPath, fileContents, folderId, seq)
        if (blobName === undefined) return
        let textContent
        try {
          textContent = this._textDecoder.decode(fileContents)
        } catch (error) {
          this._pathMapInvalidate(folderId, relPath, seq, getErrorMessage(error)),
            this._encodingErrors.increment()
          return
        }
        let uploadItem = {
          seq: seq,
          folderId: folderId,
          pathName: relPath,
          text: textContent,
          blobName: blobName,
          mtime: mtime,
          byteSize: fileContents.length,
          metadata: [],
        }
        if (this._uploadBatch.addItem(blobName, uploadItem)) return
        newItem = uploadItem
      }
      let batch = this._grabUploadBatch()
      if (batch === undefined) return
      newItem !== undefined && this._uploadBatch.addItem(newItem.blobName, newItem),
        this._logger.verbose(`upload ${batch.items.size} blobs`)
      let uploadItems = new Array()
      for (let [blobName, items] of batch.items) uploadItems.push(items[0])
      this._uploadMs.start()
      let uploadResults = await this._uploadBlobBatch(uploadItems)
      this._uploadMs.stop(), this._blobsUploaded.increment(uploadResults.size)
      for (let [blobName, items] of batch.items) {
        let resultBlobName = uploadResults.get(blobName)
        if (resultBlobName === undefined)
          for (let item of items)
            this._pathMapInvalidate(
              item.folderId,
              item.pathName,
              item.seq,
              this._fileUploadFailure,
            )
        else
          for (let item of items) {
            let probeItem = {
              folderId: item.folderId,
              relPath: item.pathName,
              blobName: resultBlobName,
              mtime: item.mtime,
              startTime: Date.now(),
            }
            this._enqueueForProbeRetry(item.seq, probeItem)
          }
      }
    }
    async _uploadBlobBatch(items) {
      this._logger.verbose(`upload begin: ${items.length} blobs`)
      for (let item of items)
        this._logger.verbose(
          `    - ${item.folderId}:${item.pathName}; expected blob name ${item.blobName}`,
        )
      let result
      try {
        result = await retryOperation(
          async () => await this._apiServer.batchUpload(items),
          this._logger,
        )
      } catch (error) {
        this._logger.error(`batch upload failed: ${getErrorMessage(error)}`)
      }
      let blobNameMap = new Map()
      if (result !== undefined)
        for (let index = 0; index < result.blobNames.length; index++)
          blobNameMap.set(items[index].blobName, result.blobNames[index])
      return (
        await this._uploadBlobsSequentially(items, result?.blobNames.length ?? 0, blobNameMap), blobNameMap
      )
    }
    async _uploadBlobsSequentially(items, processedCount, blobNameMap) {
      for (let index = processedCount; index < items.length; index++) {
        let item = items[index]
        try {
          this._logger.verbose(
            `sequential upload of ${item.pathName} -> ${item.blobName}`,
          )
          let result = await retryOperation(
            async () =>
              this._apiServer.memorize(item.pathName, item.text, item.blobName, []),
            this._logger,
          )
          blobNameMap.set(item.blobName, result.blobName)
        } catch {}
      }
    }
    _inflightItemAdd(seqId, folderId, relativePath) {
      this._itemsInFlight.set(seqId, [folderId, relativePath])
    }
    _inflightItemRemove(seqId) {
      this._itemsInFlight.delete(seqId),
        this._onDidChangeInProgressItemCountEmitter.fire(
          this._itemsInFlight.size,
        ),
        this._itemsInFlight.size === 0 &&
          (this._logger.verbose("inflight items signaling empty"),
          this._onQuiescedEmitter.fire())
    }
    _pathMapVerify(folderId, relativePath, seqId) {
      if (!this._pathMap.shouldTrack(folderId, relativePath))
        return this._inflightItemRemove(seqId), false
      let contentSeq = this._pathMap.getContentSeq(folderId, relativePath)
      return contentSeq !== undefined && contentSeq >= seqId ? (this._inflightItemRemove(seqId), false) : true
    }
    _pathMapUpdate(folderId, relativePath, seqId, blobName, mtime) {
      this._inflightItemRemove(seqId), this._pathMap.update(folderId, relativePath, seqId, blobName, mtime)
    }
    _pathMapInvalidate(folderId, relativePath, seqId, reason) {
      this._logger.verbose(`path map invalidate: ${folderId}:${relativePath} (${reason})`),
        this._pathMap.markUntrackable(folderId, relativePath, seqId, reason),
        this._inflightItemRemove(seqId),
        this._pathMap.markUntrackable(folderId, relativePath, seqId, reason)
    }
    _enqueueForCalculate(folderId, relativePath) {
      let seqId = this._nextSeq()
      this._inflightItemAdd(seqId, folderId, relativePath),
        this._toCalculate.insert(seqId, [folderId, relativePath])
          ? this._toCalculate.kick()
          : this._inflightItemRemove(seqId)
    }
    _enqueueForProbe(item) {
      if (item === undefined) this._toProbe.kick()
      else {
        let [seqId, probeItem] = item
        this._logger.verbose(
          `probe enqueue ${probeItem.blobName} -> ${seqId}, ${probeItem.folderId}:${probeItem.relPath}`,
        ),
          this._toProbe.insert(seqId, probeItem)
      }
      return Promise.resolve()
    }
    _beginUploadBatch() {
      return new Dw.Disposable(() => this._toUpload.kick())
    }
    _enqueueForUpload(seqId, folderId, relativePath, kickNow = true) {
      this._logger.verbose(`upload enqueue ${folderId}:${relativePath} -> ${seqId}`)
      let absolutePath = this._makeAbsPath(folderId, relativePath)
      if (absolutePath === undefined) {
        this._inflightItemRemove(seqId)
        return
      }
      let existingItem = this._toUpload.get(absolutePath)
      if (existingItem !== undefined) {
        let existingSeq = existingItem.seq
        if (existingSeq > seqId) this._inflightItemRemove(existingSeq)
        else if (existingSeq < seqId) {
          this._inflightItemRemove(seqId)
          return
        }
      }
      this._toUpload.insert(absolutePath, { seq: seqId, folderId: folderId, relPath: relativePath }, true),
        kickNow && this._toUpload.kick()
    }
    _enqueueForProbeRetry(seqId, probeItem) {
      Date.now() - probeItem.startTime < DiskFileManager.probeBackoffAfterMs
        ? (this._logger.verbose(
            `probe-retry enqueue ${probeItem.blobName} -> ${seqId}, ${probeItem.folderId}:${probeItem.relPath}`,
          ),
          this._probeRetryWaiters.insert(seqId, probeItem))
        : (this._logger.verbose(
            `probe-retry enqueue backoff ${probeItem.blobName} -> ${seqId}, ${probeItem.folderId}:${probeItem.relPath}`,
          ),
          this._probeRetryBackoffWaiters.insert(seqId, probeItem))
    }
  }
var MTimeCache = class {
    static cacheFileName = "mtime-cache.json"
    static tmpFileName = "mtime-cache.json.tmp"
  },
  MTimeCacheData = class {
    constructor(version = DEFAULT_NAMING_VERSION) {
      this.namingVersion = version
    }
    entries = new Array()
  }
function Wbt(e) {
  if (
    !(e.mtime === undefined || typeof e.mtime != "number" || !e.mtime) &&
    !(e.name === undefined || typeof e.name != "string" || !e.name)
  )
    return { mtime: e.mtime, name: e.name }
}
function Gbt(e) {
  return joinPaths(e, MTimeCache.cacheFileName)
}
function T2(e) {
  let t = Gbt(e)
  return fileExists(t)
}
async function LIe(e, t) {
  let r = joinPaths(e, MTimeCache.cacheFileName),
    n = joinPaths(t, MTimeCache.cacheFileName)
  await Hl(t), await IG(r, n)
}
async function UIe(e, t) {
  let r = new Map(),
    n = z(`MtimeCache[${e}]`),
    i = joinPaths(t, MTimeCache.cacheFileName)
  n.info(`reading blob name cache from ${i}`)
  try {
    let s = 0,
      o = await readTextFile(i),
      a = JSON.parse(o)
    if (a.namingVersion === undefined || a.namingVersion !== DEFAULT_NAMING_VERSION)
      n.info(`blob naming version ${a.namingVersion} !== ${DEFAULT_NAMING_VERSION}`)
    else if (Array.isArray(a.entries))
      for (let [l, c] of a.entries) {
        let u = Wbt(c)
        u !== undefined && (r.set(l, { mtime: u.mtime, name: u.name }), s++)
      }
    n.info(`read ${s} entries from ${i}`)
  } catch (s) {
    let o = getErrorMessage(s)
    s instanceof Error && "code" in s && s.code === "ENOENT"
      ? n.info(
          `no blob name cache found at ${i} (probably new source folder); error = ${o}`,
        )
      : n.error(`failed to read blob name cache ${i}: ${o}`)
  }
  return r
}
var MTimeCacheWriter = class extends MTimeCache {
  constructor(cacheName, cacheDirPath) {
    super()
    this._name = cacheName
    this._cacheDirName = cacheDirPath
    ;(this._cacheFileName = joinPaths(this._cacheDirName, MTimeCache.cacheFileName)),
      (this._tmpFileName = joinPaths(this._cacheDirName, MTimeCache.tmpFileName))
  }
  _cacheFileName
  _tmpFileName
  _logger = z("MTimeCacheWriter")
  get cacheFileName() {
    return this._cacheFileName
  }
  async write(entries) {
    this._logger.debug(`persisting to ${this._cacheFileName}`)
    let cacheData = new MTimeCacheData()
    for (let [path, modTime, blobName] of entries) cacheData.entries.push([path, { mtime: modTime, name: blobName }])
    await Hl(this._cacheDirName),
      await oa(this._tmpFileName, JSON.stringify(cacheData, undefined, 4)),
      await IG(this._tmpFileName, this._cacheFileName),
      this._logger.debug(
        `persisted ${cacheData.entries.length} entries at naming version ${DEFAULT_NAMING_VERSION} to ${this._cacheFileName}`,
      )
  }
}
var qIe = q(_s()),
  kw = q(require("vscode"))
var OIe = require("console")
var Modification = class {
    constructor(sequence, startPosition, modifiedLength, originalLength) {
      this.seq = sequence
      this.start = startPosition
      this.length = modifiedLength
      this.origLength = originalLength
    }
    get end() {
      return this.start + this.length
    }
    get localShift() {
      return this.origLength - this.length
    }
  },
  Chunk = class Chunk {
    constructor(sequence, startPosition, modifiedLength, originalStart, originalLength) {
      this.seq = sequence
      this.start = startPosition
      this.length = modifiedLength
      this.origStart = originalStart
      this.origLength = originalLength
    }
    static fromMod(modification, offset) {
      return new Chunk(modification.seq, modification.start, modification.length, modification.start + offset, modification.origLength)
    }
    get end() {
      return this.start + this.length
    }
    get origEnd() {
      return this.origStart + this.origLength
    }
    setStart(newStart) {
      let delta = this.start - newStart
      ;(this.start -= delta),
        (this.length += delta),
        (this.origStart -= delta),
        (this.origLength += delta)
    }
    setEnd(newEnd) {
      let delta = newEnd - this.end
      ;(this.length += delta), (this.origLength += delta)
    }
  },
  ChangeTracker = class ChangeTracker {
    static _logger = z("ChangeTracker")
    _modifications = []
    _seq = 0
    get seq() {
      return this._seq
    }
    get empty() {
      return this._modifications.length === 0
    }
    get length() {
      return this._modifications.length
    }
    translate(position, length) {
      let endPosition = position + Math.max(length, 0),
        index = 0,
        offset = 0
      for (; index < this._modifications.length && this._modifications[index].end < position; )
        (offset += this._modifications[index].localShift), index++
      let translatedStart =
        (index === this._modifications.length || position < this._modifications[index].start
          ? position
          : this._modifications[index].start) + offset
      for (; index < this._modifications.length && this._modifications[index].end < endPosition; )
        (offset += this._modifications[index].localShift), index++
      let translatedEnd =
        (index === this._modifications.length || endPosition < this._modifications[index].start
          ? endPosition
          : this._modifications[index].start + this._modifications[index].origLength) +
        offset
      return [translatedStart, translatedEnd - translatedStart]
    }
    apply(sequenceNumber, startPosition, originalLength, newLength) {
      let index = 0,
        modification,
        modificationLength,
        modificationOrigLength,
        currentPosition = startPosition,
        processedLength = 0,
        startIndex
      for (; index < this._modifications.length && this._modifications[index].end < startPosition; )
        index++
      if (
        ((startIndex = index),
        index < this._modifications.length && this._modifications[index].start <= startPosition)
      ) {
        ;(modification = this._modifications[index]), (modificationLength = modification.length), (modificationOrigLength = modification.origLength)
        let positionOffset = currentPosition - modification.start
        ;(0, OIe.assert)(positionOffset <= modification.length)
        let overlapLength = Math.min(modification.length - positionOffset, originalLength - processedLength)
        ;(modificationLength -= overlapLength), (processedLength += overlapLength), (currentPosition = modification.end), ++index
      } else (modification = new Modification(sequenceNumber, startPosition, 0, 0)), (modificationLength = 0), (modificationOrigLength = 0)
      for (; index < this._modifications.length && processedLength < originalLength; index++) {
        let currentMod = this._modifications[index],
          gapLength = currentMod.start - currentPosition,
          gapToProcess = Math.min(gapLength, originalLength - processedLength)
        if (((modificationOrigLength += gapToProcess), (processedLength += gapToProcess), currentPosition + gapToProcess < currentMod.start)) break
        let modOverlap = Math.min(currentMod.length, originalLength - processedLength)
        ;(modificationLength += currentMod.length - modOverlap), (processedLength += modOverlap), (modificationOrigLength += currentMod.origLength), (currentPosition = currentMod.end)
      }
      for (
        modification.length = modificationLength + newLength,
          modification.origLength = modificationOrigLength + (originalLength - processedLength),
          modification.seq = sequenceNumber,
          this._modifications.splice(startIndex, index - startIndex, modification),
          index = startIndex + 1;
        index < this._modifications.length;
        index++
      )
        this._modifications[index].start += newLength - originalLength
      this._seq = sequenceNumber
    }
    merge(otherTracker) {
      for (let mod of otherTracker._modifications)
        this.apply(mod.seq, mod.start, mod.origLength, mod.length)
    }
    advance() {
      for (let mod of this._modifications) mod.origLength = mod.length
    }
    getEdits() {
      let edits = [],
        offset = 0
      for (let mod of this._modifications)
        edits.push(new Chunk(mod.seq, mod.start, mod.length, mod.start + offset, mod.origLength)),
          (offset += mod.localShift)
      return edits
    }
    countChunks(chunkSize) {
      if (this._modifications.length === 0) return 0
      let documentLength = this._modifications.at(-1).end
      return this.getChunks(chunkSize, documentLength).length
    }
    getChunks(chunkSize, documentLength) {
      if (this._modifications.length === 0) return []
      let chunks = new Array(),
        currentChunk,
        offset = 0
      for (let mod of this._modifications) {
        let edit = Chunk.fromMod(mod, offset)
        if (
          ((offset += mod.localShift),
          currentChunk !== undefined &&
            (edit.start - currentChunk.start >= chunkSize ||
              (edit.end - currentChunk.start > chunkSize && edit.length <= chunkSize)) &&
            (chunks.push(currentChunk), (currentChunk = undefined)),
          currentChunk === undefined)
        )
          currentChunk = new Chunk(edit.seq, edit.start, 0, edit.origStart, 0)
        else {
          let gap = edit.start - currentChunk.end
          ;(currentChunk.length += gap), (currentChunk.origLength += gap)
        }
        let editLength = edit.length,
          lengthToAdd = Math.min(editLength, chunkSize - currentChunk.length)
        ;(currentChunk.length += lengthToAdd),
          (currentChunk.origLength += edit.origLength),
          (currentChunk.seq = Math.max(currentChunk.seq, edit.seq))
        for (let index = lengthToAdd; index < editLength; index += lengthToAdd) {
          chunks.push(currentChunk)
          let newChunkStart = edit.start + index
          ;(currentChunk = new Chunk(edit.seq, newChunkStart, 0, edit.origEnd, 0)),
            (lengthToAdd = Math.min(editLength - index, chunkSize)),
            (currentChunk.length += lengthToAdd)
        }
      }
      return (
        currentChunk !== undefined && chunks.push(currentChunk), this._widen(chunks, chunkSize, documentLength), this._validateChunks(chunks)
      )
    }
    _widen(chunks, chunkSize, documentLength) {
      let lastEnd = 0
      for (let index = 0; index < chunks.length; index++) {
        let chunk = chunks[index],
          nextStart = index + 1 === chunks.length ? documentLength : chunks[index + 1].start,
          remainingSpace = chunkSize - chunk.length,
          newStart,
          newEnd,
          idealStart = Math.floor(chunk.start - remainingSpace / 2)
        idealStart <= lastEnd
          ? ((newStart = lastEnd), (newEnd = Math.min(newStart + chunkSize, nextStart)))
          : ((newEnd = Math.min(idealStart + chunkSize, nextStart)), (newStart = Math.max(newEnd - chunkSize, lastEnd))),
          chunk.setStart(newStart),
          chunk.setEnd(newEnd),
          (lastEnd = newEnd)
      }
    }
    _validateChunks(chunks) {
      let validChunks = new Array()
      for (let chunk of chunks)
        chunk.origStart > chunk.origEnd
          ? ChangeTracker._logger.error("invalid chunk: ", JSON.stringify(chunk))
          : validChunks.push(chunk)
      return validChunks
    }
  }
var VIe = 6,
  HIe = 6,
  Tw = VIe * HIe,
  $bt = 1e3,
  Ybt = 2e3,
  Kbt = 60 * 1e3,
  zbt = 200,
  Jbt = 30 * 1e3,
  jbt = 30 * 1e3,
  Zbt = 60 * 1e3,
  TrackedDocument = class {
    constructor(folderId, pathName, documentKey, sequenceNumber) {
      this.folderId = folderId
      this.pathName = pathName
      this.key = documentKey
      this.appliedSeq = sequenceNumber
      ;(this.recentChangesets = new CircularBuffer(HIe)),
        this.addChangeset(sequenceNumber),
        (this.changesSinceUpload = new ChangeTracker())
    }
    uploadedBlobName
    uploadedSeq
    recentChangesets
    changesSinceUpload
    uploadRequested = false
    inProgressUpload
    _embargoed = false
    invalidateUploadState() {
      ;(this.uploadedBlobName = undefined), (this.uploadedSeq = undefined)
    }
    _clear() {
      ;(this.uploadedBlobName = undefined),
        (this.uploadedSeq = undefined),
        this.recentChangesets.clear(),
        (this.changesSinceUpload = undefined),
        (this.uploadRequested = false),
        (this.inProgressUpload = undefined)
    }
    embargo() {
      this._clear(), (this._embargoed = true)
    }
    get embargoed() {
      return this._embargoed
    }
    get uploadInProgress() {
      return this.inProgressUpload !== undefined
    }
    getBlobName() {
      return this.recentChanges(false)?.blobName
    }
    longestHistory(includeUnverified) {
      if (this.uploadedSeq === undefined) return
      let oldestChangeset = this.recentChangesets.at(0)
      if (oldestChangeset !== undefined) {
        if (includeUnverified)
          return {
            changeTracker: oldestChangeset.changeTracker,
            blobName: this.uploadedBlobName,
          }
        if (
          this.uploadedBlobName !== undefined &&
          !(oldestChangeset.initialSeq > this.uploadedSeq)
        )
          return {
            changeTracker: oldestChangeset.changeTracker,
            blobName: this.uploadedBlobName,
          }
      }
    }
    recentChanges(includeUnverified) {
      return this.inProgressUpload !== undefined
        ? this.inProgressUpload.savedChangeset
        : this.longestHistory(includeUnverified)
    }
    applyAll(sequenceNumber, text, startOffset, endOffset) {
      for (let changeset of this.recentChangesets) changeset.changeTracker.apply(sequenceNumber, text, startOffset, endOffset)
      this.appliedSeq = sequenceNumber
    }
    advanceAll() {
      for (let changeset of this.recentChangesets) changeset.changeTracker.advance()
    }
    addChangeset(sequenceNumber) {
      this.recentChangesets.addItem({ initialSeq: sequenceNumber, changeTracker: new ChangeTracker() })
    }
    purgeChangesets(sequenceNumber) {
      let purgedCount = 0
      for (
        ;
        !this.recentChangesets.empty &&
        !((this.recentChangesets.at(1)?.initialSeq ?? this.appliedSeq) >= sequenceNumber);

      )
        this.recentChangesets.shiftLeft(1), purgedCount++
      return purgedCount
    }
  },
  TextDocumentTracker = class extends TrackedDocument {
    constructor(folderId, pathName, documentKey, textDocument, sequenceNumber) {
      super(folderId, pathName, documentKey, sequenceNumber)
      this.document = textDocument
    }
    get documentType() {
      return 0
    }
    getText() {
      return this.document.getText()
    }
  },
  NotebookDocumentTracker = class extends TrackedDocument {
    constructor(folderId, pathName, documentKey, notebookDocument, sequenceNumber) {
      super(folderId, pathName, documentKey, sequenceNumber)
      this.document = notebookDocument
    }
    get documentType() {
      return 1
    }
    getText() {
      return k4(this.document)
    }
  }
function Xbt(e) {
  return e.getCells !== undefined
}
function eEt(e) {
  return Xbt(e) ? e : hbe(e)
}
var OpenFileManager = class OpenFileManager extends DisposableContainer {
  constructor(apiServer, completionServer, configListener, blobNameCalculator, pathMap, sequenceGenerator) {
    super()
    this._apiServer = apiServer
    this._completionServer = completionServer
    this._configListener = configListener
    this._blobNameCalculator = blobNameCalculator
    this._pathMap = pathMap
    this._sequenceGenerator = sequenceGenerator
    ;(this._logger = z("OpenFileManager")),
      (this._uploadQueue = new ProcessQueue(this._upload.bind(this))),
      this.addDisposable(this._uploadQueue),
      (this._verifyWaiters = new ProcessQueue(this._enqueueForVerify.bind(this))),
      this.addDisposable(this._verifyWaiters),
      (this._verifyWaitersKicker = new Oc(this._verifyWaiters, Ybt)),
      this.addDisposable(this._verifyWaitersKicker),
      (this._longWaiters = new ProcessQueue(this._enqueueForVerify.bind(this))),
      this.addDisposable(this._longWaiters),
      (this._longWaitersKicker = new Oc(this._longWaiters, Kbt)),
      this.addDisposable(this._longWaitersKicker),
      (this._verifyQueue = new ProcessQueue(this._verify.bind(this))),
      this.addDisposable(this._verifyQueue)
  }
  _trackedFolders = new Map()
  _uploadQueue
  _verifyWaiters
  _longWaiters
  _verifyWaitersKicker
  _longWaitersKicker
  _verifyQueue
  _verifyBatch = new Map()
  _prevUpdatedDocument
  _logger
  openSourceFolder(folderId) {
    if (this._trackedFolders.has(folderId))
      throw new Error(`Source folder ${folderId} is already open`)
    return (
      this._trackedFolders.set(folderId, new Map()), // =
      this._logger.info(`Opened source folder ${folderId}`),
      new kw.Disposable(() => {
        this._closeSourceFolder(folderId)
      })
    )
  }
  _closeSourceFolder(folderId) {
    this._trackedFolders.delete(folderId),
      this._logger.info(`Closed source folder ${folderId}`)
  }
  startTracking(folderId, pathName, documentType) {
    this._trackDocument(folderId, pathName, documentType)
  }
  stopTracking(folderId, pathName, documentType) {
    let folderMap = this._getFolder(folderId)
    if (folderMap === undefined) return
    let document = folderMap.get(pathName)
    document !== undefined &&
      ((documentType !== undefined && document.documentType !== documentType) ||
        (folderMap.delete(pathName),
        this._prevUpdatedDocument === document && (this._prevUpdatedDocument = undefined),
        this._logger.verbose(`stop tracking ${folderId}:${pathName}`)))
  }
  isTracked(folderId, pathName) {
    return this._getDocument(folderId, pathName) !== undefined
  }
  getTrackedPaths(folderId) {
    let folderMap = this._getFolder(folderId)
    return folderMap === undefined ? new Array() : Array.from(folderMap.keys())
  }
  loseFocus() {
    this._setFocus(undefined)
  }
  get _chunkSize() {
    return this._completionServer.completionParams.chunkSize
  }
  _getFolder(folderId) {
    return this._trackedFolders.get(folderId)
  }
  _getDocument(folderId, pathName, documentKey) {
    let folderMap = typeof folderId == "number" ? this._getFolder(folderId) : folderId
    if (folderMap === undefined) return
    let document = folderMap.get(pathName)
    if (document !== undefined && !(documentKey !== undefined && document.key !== documentKey)) return document
  }
  getBlobName(folderId, pathName) {
    return this._getDocument(folderId, pathName)?.getBlobName()
  }
  translateRange(rangeInfo) {
    let document = this._getDocument(rangeInfo.folderId, rangeInfo.relPath)
    if (document === undefined || document.uploadedBlobName === undefined) return
    let changes = document.changesSinceUpload
    if (changes === undefined) return
    let translatedRange = changes.translate(rangeInfo.beginOffset, rangeInfo.endOffset - rangeInfo.beginOffset)
    return {
      blobName: document.uploadedBlobName,
      beginOffset: translatedRange[0],
      endOffset: translatedRange[0] + translatedRange[1],
    }
  }
  notifyMissingBlob(folderId, pathName, blobName) {
    let document = this._getDocument(folderId, pathName)
    return document === undefined || document.uploadedBlobName !== blobName
      ? false
      : (document.invalidateUploadState(),
        this._tryEnqueueUpload(folderId, pathName, "blob name reported missing", document),
        true)
  }
  getRecencySummary(chunkSize) {
    let folderBlobMap = new Map(), // =
      recentChunks = new Array()
    for (let [folderId, folderMap] of this._trackedFolders) {
      let pathBlobMap = new Map()
      folderBlobMap.set(folderId, pathBlobMap)
      for (let [pathName, document] of folderMap) {
        if (document.embargoed || document.uploadedSeq === undefined) continue
        let recentChanges = document.recentChanges(false)
        if (recentChanges === undefined || recentChanges.blobName === undefined) continue
        pathBlobMap.set(pathName, recentChanges.blobName)
        let fileContent = document.getText(),
          chunks = recentChanges.changeTracker.getChunks(chunkSize, fileContent.length)
        if (chunks.length === 0) continue
        let expectedBlobName = this._blobNameCalculator.calculateNoThrow(pathName, fileContent)
        for (let chunk of chunks)
          recentChunks.push({
            seq: chunk.seq,
            uploaded: chunk.seq <= document.uploadedSeq,
            folderId: folderId,
            pathName: pathName,
            blobName: recentChanges.blobName,
            text: fileContent.slice(chunk.start, chunk.end),
            origStart: chunk.origStart,
            origLength: chunk.origLength,
            expectedBlobName: expectedBlobName,
          })
      }
    }
    return recentChunks.sort(OpenFileManager._compareChunks), { folderMap: folderBlobMap, recentChunks: recentChunks }
  }
  getRecentChunkInfo(chunkSize, includeUploaded = false) {
    let chunks = new Array()
    for (let [folderId, folderMap] of this._trackedFolders)
      for (let [pathName, document] of folderMap) {
        if (document.embargoed || document.uploadedSeq === undefined) continue
        let recentChanges = document.recentChanges(includeUploaded)
        if (recentChanges === undefined) continue
        let fileChunks = recentChanges.changeTracker.getChunks(chunkSize, document.getText().length)
        if (fileChunks.length !== 0)
          for (let chunk of fileChunks)
            chunks.push({
              seq: chunk.seq,
              uploaded: chunk.seq <= document.uploadedSeq,
              folderId: folderId,
              pathName: pathName,
              blobName: recentChanges.blobName,
            })
      }
    return chunks.sort(OpenFileManager._compareChunks), chunks
  }
  static _compareChunks(chunkA, chunkB) {
    return chunkA.uploaded === chunkB.uploaded ? chunkB.seq - chunkA.seq : chunkA.uploaded ? 1 : -1
  }
  applyTextDocumentChange(folderId, pathName, changeEvent) {
    let document = this._getDocument(folderId, pathName)
    if (document === undefined) {
      this._trackDocument(folderId, pathName, changeEvent.document)
      return
    }
    if (!this._prepareForUpdate(document) || changeEvent.contentChanges.length === 0) return
    let changedRanges = changeEvent.contentChanges.map((change) => [
      change.rangeOffset,
      change.rangeLength,
      change.text.length,
    ])
    this._applyChangedRanges(folderId, pathName, document, changedRanges)
  }
  applyNotebookChange(folderId, pathName, changeEvent) {
    let document = this._getDocument(folderId, pathName)
    if (document === undefined) {
      this._trackDocument(folderId, pathName, changeEvent.notebook)
      return
    }
    if (!this._prepareForUpdate(document) || changeEvent.contentChanges.length === 0) return
    let originalCells = changeEvent.notebook.getCells().slice(),
      changedRanges = new Array()
    changeEvent.contentChanges
      .slice()
      .reverse()
      .forEach((change) => {
        originalCells.splice(change.range.start, change.addedCells.length),
          originalCells.splice(change.range.start, 0, ...change.removedCells)
        let isMarkupBefore = originalCells
            .slice(0, change.range.start)
            .every((cell) => cell.kind === kw.NotebookCellKind.Markup),
          isMarkupAfter = originalCells
            .slice(change.range.end)
            .every((cell) => cell.kind === kw.NotebookCellKind.Markup),
          offset = uv(originalCells.slice(0, change.range.start)).length
        offset > 0 && !isMarkupBefore && !isMarkupAfter && (offset += Ix.length)
        let separatorLength = !isMarkupBefore || !isMarkupAfter ? Ix.length : 0,
          addedLength = uv(change.addedCells).length
        addedLength > 0 && (addedLength += separatorLength)
        let removedLength = uv(change.removedCells).length
        removedLength > 0 && (removedLength += separatorLength), (addedLength > 0 || removedLength > 0) && changedRanges.push([offset, removedLength, addedLength])
      }),
      changedRanges.reverse(),
      this._applyChangedRanges(folderId, pathName, document, changedRanges)
  }
  _setFocus(document) {
    this._prevUpdatedDocument !== undefined &&
      document !== this._prevUpdatedDocument &&
      (this._tryEnqueueUpload(
        this._prevUpdatedDocument.folderId,
        this._prevUpdatedDocument.pathName,
        "document lost focus",
      ),
      this._purgeUnneededChangesets()),
      (this._prevUpdatedDocument = document)
  }
  _trackDocument(folderId, pathName, documentObj) {
    let folderMap = this._getFolder(folderId)
    if (folderMap === undefined) throw new Error(`Source folder ${folderId} is not open`)
    let document = this._getDocument(folderMap, pathName)
    if ((this._setFocus(document), document !== undefined)) return
    let initialSeq = this._sequenceGenerator.next(),
      notebookCells = eEt(documentObj)
    if (notebookCells === undefined) {
      let textDocument = documentObj
      document = new TextDocumentTracker(folderId, pathName, initialSeq, textDocument, initialSeq)
    } else document = new NotebookDocumentTracker(folderId, pathName, initialSeq, notebookCells, initialSeq)
    folderMap.set(pathName, document)
    let fileContent = document.getText(),
      blobName = this._blobNameCalculator.calculate(pathName, fileContent)
    if (blobName === undefined) {
      this._embargo(folderId, pathName, document, "blob name calculation failed")
      return
    }
    this._pathMap.getAnyPathName(blobName) === undefined
      ? this._tryEnqueueUpload(folderId, pathName, "new document has no blob name", document)
      : ((document.uploadedBlobName = blobName), (document.uploadedSeq = document.appliedSeq)),
      this._logger.verbose(`start tracking ${folderId}:${pathName}`)
  }
  _prepareForUpdate(document) {
    return this._setFocus(document), !document.embargoed
  }
  _applyChangedRanges(folderId, pathName, document, changedRanges) {
    let newSeq = this._sequenceGenerator.next()
    document.recentChangesets.empty &&
      (document.addChangeset(newSeq),
      this._logger.verbose(
        `apply: new changeset for ${folderId}:${pathName}; total = ${document.recentChangesets.length}`,
      ))
    let uploadInfo = document.inProgressUpload
    for (let range of changedRanges) {
      let [offset, removedLength, addedLength] = range
      uploadInfo !== undefined &&
        (uploadInfo.savedChangeset !== undefined &&
          uploadInfo.savedChangeset.changeTracker.apply(newSeq, offset, removedLength, addedLength),
        uploadInfo.changesSinceUpload.apply(newSeq, offset, removedLength, addedLength)),
        document.applyAll(newSeq, offset, removedLength, addedLength),
        document.changesSinceUpload?.apply(newSeq, offset, removedLength, addedLength)
    }
    if (((document.appliedSeq = newSeq), uploadInfo !== undefined)) {
      let shouldCancel = uploadInfo.changesSinceUpload.length >= zbt
      shouldCancel || (shouldCancel = uploadInfo.changesSinceUpload.countChunks(this._chunkSize) >= Tw),
        shouldCancel && this._cancelInProgressUpload(folderId, pathName, document)
    }
    if (document.changesSinceUpload !== undefined) {
      let chunkCount = document.changesSinceUpload.countChunks(this._chunkSize)
      chunkCount > 1 && this._tryEnqueueUpload(folderId, pathName, "multiple non-uploaded chunks", document),
        chunkCount >= Tw &&
          (this._logger.verbose(
            `apply: no longer tracking non-uploaded changes for ${folderId}:${pathName}`,
          ),
          (document.changesSinceUpload = undefined))
    }
    let currentChunks = document.recentChangesets.at(-1).changeTracker.countChunks(this._chunkSize)
    currentChunks >= VIe &&
      (document.addChangeset(newSeq),
      this._logger.verbose(
        `apply: new changeset for ${folderId}:${pathName}; chunks = ${currentChunks}; total = ${document.recentChangesets.length}`,
      ))
  }
  _cancelInProgressUpload(folderId, pathName, document) {
    this._logger.verbose(`cancel in-progress upload: ${folderId}:${pathName}`),
      (document.inProgressUpload = undefined),
      (document.key = this._sequenceGenerator.next())
  }
  _validateInProgressUpload(folderId, pathName, documentKey) {
    let document = this._getDocument(folderId, pathName, documentKey)
    if (!(document === undefined || document.inProgressUpload === undefined))
      return [document, document.inProgressUpload]
  }
  _tryEnqueueUpload(folderId, pathName, reason, documentObj) {
    let document = documentObj ?? this._getDocument(folderId, pathName) // =
    document !== undefined &&
      (document.uploadRequested ||
        (document.appliedSeq !== document.uploadedSeq &&
          document.appliedSeq !== document.inProgressUpload?.uploadSeq &&
          (this._logger.verbose(`upload request: ${folderId}:${pathName}; reason = ${reason}`),
          (document.uploadRequested = true),
          document.uploadInProgress
            ? this._logger.verbose(
                `upload request delayed: upload for ${folderId}:${pathName} already in progress`,
              )
            : this._enqueueUpload(folderId, pathName, document.key))))
  }
  _retryUpload(folderId, pathName) {
    this._logger.verbose(`retry upload; ${folderId}:${pathName}`)
    let document = this._getDocument(folderId, pathName)
    if (document === undefined) {
      this._logger.verbose(
        `retry upload: document is no longer tracked; ${folderId}:${pathName}`,
      )
      return
    }
    if (document.inProgressUpload !== undefined) {
      this._logger.verbose(
        `retry upload: upload already in progress; ${folderId}:${pathName}`,
      )
      return
    }
    ;(document.uploadRequested = true), this._enqueueUpload(folderId, pathName, document.key)
  }
  _enqueueUpload(folderId, pathName, documentKey) {
    this._uploadQueue.insert([folderId, pathName, documentKey]) &&
      (this._logger.verbose(`enqueue upload: ${folderId}:${pathName}`),
      this._uploadQueue.kick()) // =
  }
  async _upload(uploadInfo) {
    if (uploadInfo === undefined) return // =
    let [folderId, pathName, documentKey] = uploadInfo,
      document = this._getDocument(folderId, pathName, documentKey)
    if (document === undefined) {
      this._logger.verbose(
        `upload: upload cancelled or no longer tracking document ${folderId}:${pathName}`,
      )
      return
    }
    document.uploadRequested = false
    let fileContent = document.getText(),
      blobName = this._blobNameCalculator.calculate(pathName, fileContent)
    if (blobName === undefined) {
      this._embargo(folderId, pathName, document, "failed to compute blob name")
      return
    }
    let longestHistory = document.longestHistory(false),
      savedChangeset =
        longestHistory === undefined || longestHistory.blobName === undefined
          ? undefined
          : {
              changeTracker: (0, qIe.cloneDeep)(longestHistory.changeTracker),
              blobName: longestHistory.blobName,
            }
    ;(document.inProgressUpload = {
      uploadSeq: document.appliedSeq,
      blobName: blobName,
      savedChangeset: savedChangeset,
      changesSinceUpload: new ChangeTracker(),
    }),
      document.advanceAll(),
      (document.uploadedBlobName = undefined)
    let result
    try {
      this._logger.verbose(`upload: begin; ${folderId}:${pathName}, ${blobName}`)
      let startTime = Date.now()
      result = await retryOperation(async () => {
        if (!(Date.now() - startTime > Jbt) && this._validateInProgressUpload(folderId, pathName, documentKey)) // =
          return this._apiServer.memorize(pathName, fileContent, blobName, [])
      }, this._logger)
    } catch (error) {
      return (
        this._logger.verbose(`upload: failed; ${folderId}:${pathName}, ${blobName}; ${getErrorMessage(error)};`),
        this._embargo(folderId, pathName, document, `upload encountered permanent error: ${getErrorMessage(error)}`)
      )
    }
    if (!this._validateInProgressUpload(folderId, pathName, documentKey))
      return (
        this._logger.verbose(`upload: upload cancelled; pathName = ${folderId}:${pathName}`),
        this._retryUpload(folderId, pathName)
      )
    if (result === undefined)
      return (
        this._logger.verbose(
          `upload: upload timed out, cancelling; pathName = ${folderId}:${pathName}`,
        ),
        this._cancelInProgressUpload(folderId, pathName, document),
        this._retryUpload(folderId, pathName)
      )
    let resultBlobName = result.blobName
    resultBlobName === blobName
      ? this._logger.verbose(`upload: completed; ${folderId}:${pathName}, ${resultBlobName}`)
      : this._logger.error(
          `upload: completed with mismatched blobName; pathName, received, expected = ${folderId}:${pathName}, ${resultBlobName}, ${blobName}`,
        ),
      (document.inProgressUpload.blobName = resultBlobName),
      this._enqueueVerifyWaiter(
        { folderId: folderId, pathName: pathName, key: documentKey, startTime: Date.now() },
        resultBlobName,
      )
  }
  _requeueVerifyWaiter(waiterInfo, blobName) {
    let folderId = waiterInfo.folderId,
      pathName = waiterInfo.pathName
    if (!this._validateInProgressUpload(folderId, pathName, waiterInfo.key))
      return (
        this._logger.verbose(
          `requeue verify-wait: upload cancelled; ${folderId}:${pathName}, ${blobName}`,
        ),
        this._retryUpload(folderId, pathName)
      )
    Date.now() - waiterInfo.startTime > Zbt
      ? (this._logger.verbose(
          `verify-wait: enqueue long; pathName = ${folderId}:${pathName}`,
        ),
        this._longWaiters.insert(waiterInfo))
      : this._enqueueVerifyWaiter(waiterInfo, blobName)
  }
  _enqueueVerifyWaiter(waiterInfo, blobName) {
    this._logger.verbose(
      `verify-wait: enqueue; ${waiterInfo.folderId}:${waiterInfo.pathName}, ${blobName}`,
    ),
      this._verifyWaiters.insert(waiterInfo)
  }
  _enqueueForVerify(waiterInfo) {
    return waiterInfo === undefined
      ? (this._verifyQueue.kick(), Promise.resolve())
      : (this._verifyQueue.insert(waiterInfo), Promise.resolve())
  }
  _grabVerifyBatch() {
    if (this._verifyBatch.size === 0) return
    let batch = this._verifyBatch
    return (this._verifyBatch = new Map()), batch
  }
  async _verify(waiterInfo) {
    if (waiterInfo !== undefined) {
      let document = this._getDocument(waiterInfo.folderId, waiterInfo.pathName, waiterInfo.key)
      if (document === undefined || document.inProgressUpload === undefined) return
      let waitersForBlob = this._verifyBatch.get(document.inProgressUpload.blobName)
      if (
        (waitersForBlob === undefined &&
          ((waitersForBlob = new Array()),
          this._verifyBatch.set(document.inProgressUpload.blobName, waitersForBlob)),
        waitersForBlob.push(waiterInfo),
        this._verifyBatch.size < $bt)
      )
        return
    }
    let batchToVerify = this._grabVerifyBatch()
    if (batchToVerify === undefined) return
    let blobNames = [...batchToVerify.keys()]
    this._logger.verbose(`verify batch: blob count = ${blobNames.length}`)
    let findMissingResult
    try {
      let startTime = Date.now()
      findMissingResult = await retryOperation(async () => {
        if (!(Date.now() - startTime > jbt)) return this._apiServer.findMissing(blobNames)
      }, this._logger)
    } catch {}
    if (findMissingResult === undefined) {
      this._logger.verbose("verify: timeout exceeded")
      for (let blobName of blobNames) {
        let waitersForBlob = batchToVerify.get(blobName)
        for (let waiter of waitersForBlob) this._requeueVerifyWaiter(waiter, blobName)
      }
    } else {
      this._logVerifyResult(findMissingResult)
      let unknownBlobs = new Set(findMissingResult.unknownBlobNames),
        nonindexedBlobs = new Set(findMissingResult.nonindexedBlobNames)
      for (let [blobName, waiters] of batchToVerify)
        if (unknownBlobs.has(blobName))
          for (let waiter of waiters) this.notifyMissingBlob(waiter.folderId, waiter.pathName, blobName)
        else if (nonindexedBlobs.has(blobName)) for (let waiter of waiters) this._requeueVerifyWaiter(waiter, blobName)
        else for (let waiter of waiters) this._commit(waiter, blobName)
    }
  }
  _commit(waiterInfo, blobName) {
    let folderId = waiterInfo.folderId,
      pathName = waiterInfo.pathName,
      uploadInfo = this._validateInProgressUpload(folderId, pathName, waiterInfo.key)
    if (uploadInfo === undefined) {
      this._logger.verbose(`commit: upload cancelled for ${folderId}:${pathName}`)
      return
    }
    let [document, inProgressUpload] = uploadInfo
    ;(document.inProgressUpload = undefined),
      this._logger.verbose(
        `commit: ${folderId}:${pathName}, ${blobName}; uploadSeq = ${inProgressUpload.uploadSeq}`,
      ),
      (document.uploadedBlobName = blobName),
      (document.uploadedSeq = inProgressUpload.uploadSeq),
      (document.changesSinceUpload = inProgressUpload.changesSinceUpload),
      document.uploadRequested && this._retryUpload(waiterInfo.folderId, waiterInfo.pathName)
  }
  _purgeUnneededChangesets() {
    let recentChunks = this.getRecentChunkInfo(this._chunkSize, true)
    if (recentChunks.length < Tw) return
    let oldestNeededSeq = recentChunks[Tw - 1].seq,
      documentsToCheck = new Set()
    for (let index = Tw; index < recentChunks.length; index++) {
      let document = this._getDocument(recentChunks[index].folderId, recentChunks[index].pathName)
      document !== undefined && documentsToCheck.add(document)
    }
    for (let document of documentsToCheck) {
      if (document === undefined) continue
      let purgedCount = document.purgeChangesets(oldestNeededSeq)
      purgedCount > 0 &&
        this._logger.verbose(
          `purge: removed ${purgedCount} changesets from ${document.folderId}:${document.pathName}`,
        )
    }
  }
  _embargo(folderId, pathName, document, reason) {
    this._logger.info(`embargoing: ${folderId}:${pathName} reason = ${reason}`), document.embargo()
  }
  _logVerifyResult(result) {
    let logLevel = result.unknownBlobNames.length > 0 ? "error" : "verbose"
    this._logger.log(
      logLevel,
      `find-missing reported ${result.unknownBlobNames.length} unknown blob names and ${result.nonindexedBlobNames.length} nonindexed blob names.`,
    ),
      result.unknownBlobNames.length > 0 &&
        (this._logger.log(logLevel, "unknown blob names:"),
        Sg(this._logger, logLevel, result.unknownBlobNames, 5)),
      result.nonindexedBlobNames.length > 0 &&
        (this._logger.log(logLevel, "nonindexed blob names:"),
        Sg(this._logger, logLevel, result.nonindexedBlobNames, 5))
  }
}
var WIe = require("buffer")
var F2 = class {
  constructor(t, r) {
    this._fileReader = r
    this._blobNameCalculator = new HashCalculator(t)
  }
  _blobNameCalculator
  get maxBlobSize() {
    return this._blobNameCalculator.maxBlobSize
  }
  classifyPath(t) {
    let r = this._fileReader.stat(t)
    return r
      ? r.type !== "File"
        ? { type: "not a file", mtime: r.mtime }
        : r.size > this._blobNameCalculator.maxBlobSize
          ? { type: "large file", mtime: r.mtime, size: r.size }
          : { type: "accepted", size: r.size, mtime: r.mtime }
      : { type: "inaccessible" }
  }
  async readText(t) {
    let r
    try {
      if (((r = await this._fileReader.read(t)), r === undefined))
        return { type: "inaccessible" }
    } catch {
      return { type: "inaccessible" }
    }
    return (0, WIe.isUtf8)(r)
      ? r.length > this._blobNameCalculator.maxBlobSize
        ? { type: "large file", size: r.length }
        : JSON.stringify(r.toString()).length >
            this._blobNameCalculator.maxBlobSize
          ? { type: "large file", size: r.length }
          : { type: "text", contents: r }
      : { type: "binary" }
  }
  calculateBlobName(t, r) {
    return this._blobNameCalculator.calculateOrThrow(t, r)
  }
}
var Q2 = q(require("vscode"))
var WorkspacePathMap = class {
    _nextFolderId = 100
    _sourceFolders = new Map()
    _blobNameChangedEmitter = new Q2.EventEmitter()
    _nextEntryTS = 1e3
    _logger = z("PathMap")
    constructor() {}
    dispose() {
      for (let [folderId, folderManager] of this._sourceFolders) folderManager.dispose()
    }
    get nextEntryTS() {
      return this._nextEntryTS
    }
    get onDidChangeBlobName() {
      return this._blobNameChangedEmitter.event
    }
    onDidChangePathStatus(folderId) {
      return this._sourceFolders.get(folderId)?.onDidChangePathStatus
    }
    openSourceFolder(folderPath, repoRoot) {
      for (let [existingId, existingFolder] of this._sourceFolders) {
        if (Xy(existingFolder.folderRoot, folderPath))
          throw new Error(`Source folder ${folderPath} is already open`)
        if (Qs(folderPath, existingFolder.folderRoot))
          throw new Error(`Source folder ${folderPath} contains ${existingFolder.folderRoot}`)
        if (Qs(existingFolder.folderRoot, folderPath))
          throw new Error(`Source folder ${existingFolder.folderRoot} contains ${folderPath}`)
      }
      let folderId = this._nextFolderId++,
        folderManager = new SourceFolderManager(folderPath, repoRoot)
      this._sourceFolders.set(folderId, folderManager)
      let blobNameChangeSubscription = folderManager.onDidChangeBlobName(this._handleBlobNameChangeEvent.bind(this))
      return (
        folderManager.addDisposable(blobNameChangeSubscription),
        this._logger.info(`Opened source folder ${folderPath} with id ${folderId}`),
        folderId
      )
    }
    closeSourceFolder(folderId) {
      let folderManager = this._sourceFolders.get(folderId)
      if (folderManager === undefined) return
      folderManager.clear()
      let folderPath = folderManager.folderRoot
      this._sourceFolders.delete(folderId),
        folderManager.dispose(),
        this._logger.info(`Closed source folder ${folderPath} with id ${folderId}`)
    }
    _handleBlobNameChangeEvent(event) {
      this._blobNameChangedEmitter.fire(event)
    }
    getRepoRoot(folderId) {
      return this._sourceFolders.get(folderId)?.repoRoot
    }
    hasFile(folderId, relativePath) {
      return this._sourceFolders.get(folderId)?.hasFile(relativePath) ?? false
    }
    getBlobName(folderId, relativePath) {
      return this._sourceFolders.get(folderId)?.getBlobName(relativePath)
    }
    getBlobInfo(folderId, relativePath, modificationTime) {
      return this._sourceFolders.get(folderId)?.getBlobInfo(relativePath, modificationTime)
    }
    getAnyPathName(blobName) {
      for (let folderManager of this._sourceFolders.values()) {
        let relativePath = folderManager.getPathName(blobName)
        if (relativePath !== undefined) return this._makeQualifiedPathName(folderManager, relativePath)
      }
    }
    getAllPathNames(blobName) {
      let pathNames = new Array()
      for (let folderManager of this._sourceFolders.values()) {
        let relativePath = folderManager.getPathName(blobName)
        relativePath !== undefined && pathNames.push(new QualifiedPathName(folderManager.repoRoot, relativePath))
      }
      return pathNames
    }
    getUniquePathCount(blobName) {
      let count = 0
      for (let folderManager of this._sourceFolders.values())
        folderManager.getPathName(blobName) !== undefined && count++
      return count
    }
    getAllQualifiedPathNames(blobName) {
      return this.getAllQualifiedPathInfos(blobName).map((info) => info.qualifiedPathName)
    }
    getAllQualifiedPathInfos(blobName) {
      let pathInfos = new Array()
      for (let folderManager of this._sourceFolders.values()) {
        let pathInfo = folderManager.getPathInfo(blobName)
        if (pathInfo !== undefined) {
          let [fileType, acceptanceInfo] = pathInfo
          pathInfos.push({
            qualifiedPathName: new QualifiedPathName(folderManager.repoRoot, blobName),
            fileType: fileType,
            isAccepted: acceptanceInfo.accepted,
          })
        }
      }
      return pathInfos
    }
    getAllPathInfo(blobName) {
      let pathInfos = new Array()
      for (let folderManager of this._sourceFolders.values()) {
        let relativePath = folderManager.getPathName(blobName)
        relativePath !== undefined && pathInfos.push([folderManager.folderRoot, folderManager.repoRoot, relativePath])
      }
      return pathInfos
    }
    getPathInfo(folderId, relativePath) {
      return this._sourceFolders.get(folderId)?.getPathInfo(relativePath)
    }
    reportMissing(blobName) {
      for (let folderManager of this._sourceFolders.values()) {
        let relativePath = folderManager.reportMissing(blobName)
        if (relativePath !== undefined) return this._makeQualifiedPathName(folderManager, relativePath)
      }
    }
    insert(folderId, relativePath, fileType, acceptanceInfo) {
      let timestamp = this._nextEntryTS++
      this._sourceFolders.get(folderId)?.insert(relativePath, timestamp, fileType, acceptanceInfo)
    }
    remove(folderId, relativePath) {
      this._sourceFolders.get(folderId)?.remove(relativePath)
    }
    shouldTrack(folderId, relativePath) {
      return this._sourceFolders.get(folderId)?.shouldTrack(relativePath) ?? false
    }
    getContentSeq(folderId, relativePath) {
      return this._sourceFolders.get(folderId)?.getContentSeq(relativePath)
    }
    update(folderId, relativePath, contentSequence, blobName, modificationTime) {
      this._sourceFolders.get(folderId)?.update(relativePath, contentSequence, blobName, modificationTime)
    }
    markUntrackable(folderId, relativePath, contentSequence, reason) {
      this._sourceFolders.get(folderId)?.markUntrackable(relativePath, contentSequence, reason)
    }
    purge(folderId, oldestTimestamp) {
      this._sourceFolders.get(folderId)?.purge(oldestTimestamp)
    }
    *pathsWithBlobNames() {
      for (let [folderId, folderManager] of this._sourceFolders)
        for (let [relativePath, blobName, fileInfo] of folderManager.pathsWithBlobNames())
          yield [folderId, folderManager.repoRoot, relativePath, blobName, fileInfo]
    }
    *pathsInFolder(folderId) {
      let folderManager = this._sourceFolders.get(folderId)
      folderManager !== undefined && (yield* folderManager.allPaths())
    }
    enablePersist(folderId, enabled, threshold) {
      this._sourceFolders.get(folderId)?.enablePersist(enabled, threshold)
    }
    _makeQualifiedPathName(folderManager, relativePath) {
      return new QualifiedPathName(folderManager.repoRoot, relativePath)
    }
    trackedFileCount(folderId) {
      return this._sourceFolders.get(folderId)?.trackedFileCount ?? 0
    }
    getFolderIds() {
      return Array.from(this._sourceFolders.keys())
    }
  },
  SourceFolderManager = class extends DisposableContainer {
    constructor(folderPath, repoRootPath) {
      super()
      this.folderRoot = folderPath
      this.repoRoot = repoRootPath
    }
    static defaultPersistThreshold = 100
    _allPathNames = new Map()
    _trackableFilePaths = new Set()
    _blobNameToPathName = new Map()
    _persistState = undefined
    _pathStatusChangedEmitter = new Q2.EventEmitter()
    _blobNameChangedEmitter = new Q2.EventEmitter()
    get onDidChangePathStatus() {
      return this._pathStatusChangedEmitter.event
    }
    get onDidChangeBlobName() {
      return this._blobNameChangedEmitter.event
    }
    get trackedFileCount() {
      return this._trackableFilePaths.size
    }
    shouldTrack(relativePath) {
      let pathEntry = this._allPathNames.get(relativePath)
      return pathEntry === undefined
        ? false
        : pathEntry.fileType === "File" && pathEntry.pathAcceptance.accepted
    }
    getContentSeq(relativePath) {
      return this._allPathNames.get(relativePath)?.fileInfo?.contentSeq
    }
    insert(relativePath, timestamp, fileType, acceptanceInfo) {
      let pathEntry = this._allPathNames.get(relativePath),
        statusChanged =
          pathEntry === undefined ||
          pathEntry.fileType !== fileType ||
          pathEntry.pathAcceptance.format() !== acceptanceInfo.format()
      if (pathEntry === undefined)
        (pathEntry = { entryTS: timestamp, fileType: fileType, pathAcceptance: acceptanceInfo }),
          this._allPathNames.set(relativePath, pathEntry)
      else {
        let oldFileInfo = pathEntry.fileInfo
        ;(pathEntry.entryTS = timestamp),
          (pathEntry.fileType = fileType),
          (pathEntry.pathAcceptance = acceptanceInfo),
          acceptanceInfo.accepted ||
            ((pathEntry.fileInfo = undefined),
            oldFileInfo?.trackable &&
              (this._blobNameToPathName.delete(oldFileInfo.blobName),
              this._publishBlobNameChange(relativePath, oldFileInfo.blobName, undefined),
              this._markDirty()))
      }
      pathEntry.fileType === "File" &&
      pathEntry.pathAcceptance.accepted &&
      pathEntry.fileInfo?.trackable !== false
        ? this._trackableFilePaths.add(relativePath)
        : this._trackableFilePaths.delete(relativePath),
        statusChanged && this._pathStatusChangedEmitter.fire({ relPath: relativePath })
    }
    remove(relativePath) {
      let pathEntry = this._allPathNames.get(relativePath)
      if (pathEntry !== undefined) {
        if (
          (this._allPathNames.delete(relativePath),
          this._trackableFilePaths.delete(relativePath),
          pathEntry.fileInfo !== undefined && pathEntry.fileInfo.trackable)
        ) {
          let blobName = pathEntry.fileInfo.blobName
          this._blobNameToPathName.delete(blobName),
            this._publishBlobNameChange(relativePath, blobName, undefined),
            this._markDirty()
        }
        this._pathStatusChangedEmitter.fire({ relPath: relativePath })
      }
    }
    clear() {
      for (let [relativePath, pathEntry] of this._allPathNames)
        pathEntry.fileInfo !== undefined &&
          pathEntry.fileInfo.trackable &&
          this._publishBlobNameChange(relativePath, pathEntry.fileInfo.blobName, undefined)
      this._allPathNames.clear(),
        this._trackableFilePaths.clear(),
        this._blobNameToPathName.clear(),
        this._markDirty()
    }
    update(relativePath, contentSequence, blobName, modificationTime) {
      let pathEntry = this._allPathNames.get(relativePath)
      if (
        pathEntry === undefined ||
        pathEntry.fileType !== "File" ||
        !pathEntry.pathAcceptance.accepted ||
        (pathEntry.fileInfo !== undefined && pathEntry.fileInfo.contentSeq > contentSequence)
      )
        return
      let wasTrackable = pathEntry.fileInfo === undefined ? true : pathEntry.fileInfo.trackable,
        oldBlobName
      pathEntry.fileInfo?.trackable && (oldBlobName = pathEntry.fileInfo.blobName),
        (pathEntry.fileInfo = { trackable: true, contentSeq: contentSequence, blobName: blobName, mtime: modificationTime }),
        this._trackableFilePaths.add(relativePath),
        blobName !== oldBlobName &&
          (oldBlobName !== undefined && this._blobNameToPathName.delete(oldBlobName),
          this._blobNameToPathName.set(blobName, relativePath),
          this._publishBlobNameChange(relativePath, oldBlobName, blobName),
          this._markDirty()),
        (!wasTrackable || oldBlobName === undefined) &&
          this._pathStatusChangedEmitter.fire({ relPath: relativePath })
    }
    markUntrackable(relativePath, contentSequence, reason) {
      let pathEntry = this._allPathNames.get(relativePath)
      if (
        pathEntry === undefined ||
        pathEntry.fileType !== "File" ||
        !pathEntry.pathAcceptance.accepted ||
        (pathEntry.fileInfo !== undefined && pathEntry.fileInfo.contentSeq > contentSequence)
      )
        return
      let oldFileInfo = pathEntry.fileInfo
      ;(pathEntry.fileInfo = { trackable: false, contentSeq: contentSequence, reason: reason }),
        this._trackableFilePaths.delete(relativePath)
      let statusChanged = false
      if (oldFileInfo === undefined) statusChanged = true
      else if (oldFileInfo.trackable === true) {
        statusChanged = true
        let oldBlobName = oldFileInfo.blobName
        this._blobNameToPathName.delete(oldBlobName),
          this._publishBlobNameChange(relativePath, oldBlobName, undefined),
          this._markDirty()
      } else statusChanged = reason !== oldFileInfo.reason
      statusChanged && this._pathStatusChangedEmitter.fire({ relPath: relativePath })
    }
    _makeAbsPath(relativePath) {
      return joinPaths(this.repoRoot, relativePath)
    }
    _publishBlobNameChange(relativePath, oldBlobName, newBlobName) {
      oldBlobName !== newBlobName &&
        this._blobNameChangedEmitter.fire({
          absPath: this._makeAbsPath(relativePath),
          prevBlobName: oldBlobName,
          newBlobName: newBlobName,
        })
    }
    purge(oldestTimestamp) {
      let pathsToRemove = new Array()
      for (let [relativePath, pathEntry] of this._allPathNames) pathEntry.entryTS < oldestTimestamp && pathsToRemove.push(relativePath)
      for (let relativePath of pathsToRemove) this.remove(relativePath)
    }
    hasFile(relativePath) {
      return this._trackableFilePaths.has(relativePath)
    }
    getBlobName(relativePath) {
      let pathEntry = this._allPathNames.get(relativePath)
      if (pathEntry?.fileInfo?.trackable) return pathEntry.fileInfo?.blobName
    }
    getBlobInfo(relativePath, modificationTime) {
      let pathEntry = this._allPathNames.get(relativePath)
      if (pathEntry?.fileInfo?.trackable && pathEntry.fileInfo.mtime === modificationTime)
        return [pathEntry.fileInfo.blobName, pathEntry.fileInfo.contentSeq]
    }
    getPathName(blobName) {
      return this._blobNameToPathName.get(blobName)
    }
    getPathInfo(relativePath) {
      let pathEntry = this._allPathNames.get(relativePath)
      if (pathEntry !== undefined) return [pathEntry.fileType, pathEntry.pathAcceptance]
    }
    reportMissing(blobName) {
      let relativePath = this._blobNameToPathName.get(blobName)
      if (relativePath === undefined) return
      let pathEntry = this._allPathNames.get(relativePath)
      if (pathEntry?.fileInfo?.trackable) return (pathEntry.fileInfo.contentSeq = 0), relativePath
    }
    *pathsWithBlobNames() {
      for (let [relativePath, pathEntry] of this._allPathNames) {
        let fileInfo = pathEntry.fileInfo
        fileInfo?.trackable && (yield [relativePath, fileInfo.mtime, fileInfo.blobName, fileInfo.contentSeq])
      }
    }
    *allPaths() {
      for (let [relativePath, pathEntry] of this._allPathNames) {
        let isAccepted = pathEntry.pathAcceptance.accepted,
          isTrackable = false,
          acceptanceReason = pathEntry.pathAcceptance.format()
        isAccepted &&
          (pathEntry.fileType === "Other"
            ? ((isAccepted = false), (acceptanceReason = "Not a file"))
            : pathEntry.fileInfo !== undefined &&
              (pathEntry.fileInfo?.trackable === true
                ? (isTrackable = true)
                : ((isAccepted = false), (acceptanceReason = pathEntry.fileInfo.reason)))),
          yield [relativePath, pathEntry.fileType, isAccepted, isTrackable, acceptanceReason]
      }
    }
    _markDirty() {
      this._persistState !== undefined && this._persistState.dirtyCount++
    }
    enablePersist(cacheWriter, intervalMs) {
      if (this._persistState) return
      ;(this._persistState = {
        dirtyCount: this._trackableFilePaths.size,
        lastPersistDirtyCount: 0,
        mtimeCacheWriter: cacheWriter,
        persisting: false,
      }),
        this._maybePersist()
      let intervalId = setInterval(() => void this._maybePersist(), intervalMs)
      this.addDisposable({ dispose: () => clearInterval(intervalId) })
    }
    async _maybePersist() {
      if (!(this._persistState === undefined || this._persistState.persisting)) {
        this._persistState.persisting = true
        try {
          this._persistState.dirtyCount >
            this._persistState.lastPersistDirtyCount &&
            (await this._persist(this._persistState))
        } finally {
          this._persistState.persisting = false
        }
      }
    }
    async _persist(persistState) {
      let trackablePathsGenerator = function* (entries) {
          for (let [relativePath, pathEntry] of entries) {
            let fileInfo = pathEntry.fileInfo
            fileInfo?.trackable && (yield [relativePath, fileInfo.mtime, fileInfo.blobName])
          }
        },
        currentDirtyCount = persistState.dirtyCount
      await persistState.mtimeCacheWriter.write(trackablePathsGenerator(this._allPathNames.entries())),
        (persistState.lastPersistDirtyCount = currentDirtyCount)
    }
  }
var rc = q(require("vscode"))
var D9 = class extends xg {
    constructor(r) {
      super()
      this.reason = r
    }
    format() {
      return this.reason
    }
  },
  P2 = class extends DisposableContainer {
    constructor(r, n, i, s, o) {
      super()
      this.folderName = r
      this.folderRoot = n
      this.repoRoot = i
      this._pathFilter = s
      this._workspaceFolder = o
      this._logger = z(`PathNotifier[${n}]`)
    }
    _pathFoundEmitter = new rc.EventEmitter()
    _pathCreatedEmitter = new rc.EventEmitter()
    _pathChangedEmitter = new rc.EventEmitter()
    _pathDeletedEmitter = new rc.EventEmitter()
    _logger
    _filesystemWatcherCreated = false
    _stopping = false
    _deletedPaths = undefined
    get onDidFindPath() {
      return this._pathFoundEmitter.event
    }
    get onDidCreatePath() {
      return this._pathCreatedEmitter.event
    }
    get onDidChangePath() {
      return this._pathChangedEmitter.event
    }
    get onDidDeletePath() {
      return this._pathDeletedEmitter.event
    }
    dispose() {
      ;(this._stopping = true), super.dispose()
    }
    async enumeratePaths() {
      if (this._stopping) return
      ;(this._deletedPaths = new Set()),
        this._workspaceFolder !== undefined &&
          !this._filesystemWatcherCreated &&
          (this._createFilesystemWatcher(this._workspaceFolder),
          (this._filesystemWatcherCreated = true))
      let r = new gC(
        this.folderName,
        rc.Uri.file(this.folderRoot),
        rc.Uri.file(this.repoRoot),
        this._pathFilter,
      )
      for await (let [i, s, o, a] of r) {
        if (this._stopping) return
        this._pathFoundEmitter.fire({ relPath: s, fileType: o, acceptance: a })
      }
      if (this._stopping) return
      let n = this._deletedPaths
      this._deletedPaths = undefined
      for (let i of n) this._pathDeletedEmitter.fire(i)
      return r.stats
    }
    _handlePathChanged(r, n) {
      let i = this._getRelPath(r)
      if (i === undefined) return
      let s, o
      try {
        ;(s = getFileStats(getPathFromUri(r)).type), (o = this._pathFilter.getPathInfo(i, s))
      } catch (l) {
        ;(s = "Other"), (o = new D9(getErrorMessage(l)))
      }
      let a = n ? "created" : "changed"
      this._logger.verbose(`${s} ${a}: ${i}, acceptance = ${o.format()}`),
        this._deletedPaths?.delete(i),
        n
          ? this._pathCreatedEmitter.fire({
              relPath: i,
              fileType: s,
              acceptance: o,
            })
          : this._pathChangedEmitter.fire({
              relPath: i,
              fileType: s,
              acceptance: o,
            })
    }
    _handlePathDeleted(r) {
      let n = this._getRelPath(r)
      n !== undefined &&
        (this._logger.verbose(`Path deleted: ${n}`),
        this._deletedPaths !== undefined
          ? this._deletedPaths?.add(n)
          : this._pathDeletedEmitter.fire(n))
    }
    _getRelPath(r) {
      if (this._stopping) return
      let n = getPathIfSupported(r)
      if (n !== undefined) return Zh(this.repoRoot, n)
    }
    _createFilesystemWatcher(r) {
      let n = rc.workspace.createFileSystemWatcher(
        new rc.RelativePattern(r, "**/*"),
      )
      this.addDisposables(
        n,
        n.onDidCreate((i) => this._handlePathChanged(i, true)),
        n.onDidChange((i) => this._handlePathChanged(i, false)),
        n.onDidDelete((i) => this._handlePathDeleted(i)),
      )
    }
  }
var Mw = q(require("vscode"))
async function GIe(e, t, r, n) {
  let i = getPathFromUri(e),
    s = getPathFromUri(t),
    o = new Array()
  o.push(i)
  let a = new Array(),
    l = 200,
    c = Date.now(),
    u
  for (; (u = o.pop()) !== undefined && (n === undefined || a.length < n); ) {
    Date.now() - c >= l &&
      (await new Promise((y) => setTimeout(y, 0)), (c = Date.now()))
    let p = lf(s, u),
      g = r.makeLocalPathFilter(p),
      m = hm(u)
    for (let [y, v] of m) {
      if (
        (Date.now() - c >= l &&
          (await new Promise((w) => setTimeout(w, 0)), (c = Date.now())),
        y === "." || y === "..")
      )
        continue
      let E = joinPaths(p, y, v === "Directory")
      g.acceptsPath(E, v) &&
        (v === "File" ? a.push(E) : v === "Directory" && o.push(joinPaths(u, y)))
    }
  }
  return Promise.resolve(a)
}
var L2 = class e {
  constructor(t, r, n, i) {
    this._apiServer = t
    this._pathHandler = r
    this._fileExtensions = n
    this._maxTrackedFiles = i
  }
  static verifyBatchSize = 1e3
  async describe(t, r, n) {
    let i = await this._getAllPathNames(t, r, n)
    if (i.length > this._maxTrackedFiles) return { trackable: false }
    let s = i.length,
      o = await this._chooseBlobNameSample(r, i)
    if (o.length === 0)
      return { trackable: true, trackableFiles: 0, uploadedFraction: 1 }
    let a = await this._apiServer.findMissing(o),
      l = o.length,
      c = Math.min(a.unknownBlobNames.length, l)
    return { trackable: true, trackableFiles: s, uploadedFraction: (l - c) / l }
  }
  async _getAllPathNames(t, r, n) {
    let i = await buildIgnoreStack(
      Mw.Uri.file(t),
      Mw.Uri.file(r),
      new fC(n),
      this._fileExtensions,
    )
    return await GIe(
      Mw.Uri.file(t),
      Mw.Uri.file(r),
      i,
      this._maxTrackedFiles + 1,
    )
  }
  async _chooseBlobNameSample(t, r) {
    let n = new Array()
    for (; n.length < e.verifyBatchSize && r.length > 0; ) {
      let i = Math.floor(Math.random() * r.length),
        s = r[i]
      ;(r[i] = r[r.length - 1]), r.pop()
      let o = joinPaths(t, s),
        a = await this._pathHandler.readText(o)
      if (a.type !== "text") continue
      let l = this._pathHandler.calculateBlobName(s, a.contents)
      n.push(l)
    }
    return n
  }
}
var $Ie = q(require("vscode"))
var U2 = class {
  maxSize
  items
  constructor(t) {
    ;(this.maxSize = t), (this.items = [])
  }
  add(t) {
    let r = this.items.indexOf(t)
    r !== -1
      ? this.items.splice(r, 1)
      : this.items.length >= this.maxSize && this.items.shift(),
      this.items.push(t)
  }
  clear() {
    this.items = []
  }
  size() {
    return this.items.length
  }
  toArray() {
    return this.items.slice()
  }
}
var O2 = class extends DisposableContainer {
  constructor(r) {
    super()
    this._workspaceManager = r
    this.addDisposable(
      $Ie.window.onDidChangeActiveTextEditor(
        this._notifyActiveEditorChanged.bind(this),
      ),
    )
  }
  _tabSwitchHistory = new U2(20)
  _logger = z("TabWatcher")
  _notifyActiveEditorChanged(r) {
    if (r === undefined) return
    let n = r.document.uri
    this._workspaceManager.resolvePathName(n.fsPath) !== undefined &&
      this._tabSwitchHistory.add(n.fsPath)
  }
  getTabSwitchEvents() {
    let r = []
    for (let n of this._tabSwitchHistory.toArray()) {
      let i = this._workspaceManager.resolvePathName(n)
      if (i === undefined) continue
      let s = this._workspaceManager.getBlobName(i)
      s !== undefined && r.push({ relPathName: i.relPath, blobName: s })
    }
    return r
  }
}
var q2 = class e extends DisposableContainer {
  constructor(r, n) {
    super()
    this._apiServer = r
    this._workspaceManager = n
    ;(this._logger = z("UnknownBlobHandler")),
      (this._toProbe = new KeyedTaskQueue(this._probe.bind(this))),
      this.addDisposable(this._toProbe),
      (this._probeWaiters = new KeyedTaskQueue(this._enqueueForProbe.bind(this))),
      this.addDisposable(this._probeWaiters),
      (this._probeWaitersKicker = new Oc(
        this._probeWaiters,
        e.probeRetryWaitMs,
      )),
      this.addDisposable(this._probeWaitersKicker),
      (this._longWaiters = new KeyedTaskQueue(this._enqueueForProbe.bind(this))),
      this.addDisposable(this._longWaiters),
      (this._longWaitersKicker = new Oc(this._longWaiters, e.longRetryWaitMs)),
      this.addDisposable(this._longWaitersKicker)
  }
  static probeBatchSize = 1e3
  static probeRetryWaitMs = 5 * 1e3
  static probePatienceMs = 2 * 60 * 1e3
  static longRetryWaitMs = 60 * 1e3
  _toProbe
  _currentBatch = new Map()
  _probeWaiters
  _probeWaitersKicker
  _longWaiters
  _longWaitersKicker
  _logger
  enqueue(r) {
    for (let [n, i] of r)
      this._logger.verbose(`enqueue: ${i.rootPath}:${i.relPath}`),
        this._toProbe.insert(n, { qualifiedPath: i, startTime: Date.now() })
    this._toProbe.kick()
  }
  _grabCurrentBatch() {
    if (this._currentBatch.size === 0) return
    let r = this._currentBatch
    return (this._currentBatch = new Map()), r
  }
  async _probe(r) {
    if (r !== undefined) {
      let [o, a] = r
      if (
        this._workspaceManager.getBlobName(a.qualifiedPath) !== o ||
        (this._currentBatch.set(o, a),
        this._currentBatch.size < e.probeBatchSize)
      )
        return
    }
    let n = this._grabCurrentBatch()
    if (n === undefined) return
    let i = [...n.keys()],
      s
    try {
      s = await retryOperation(async () => this._apiServer.findMissing(i), this._logger)
    } catch {}
    if (s === undefined) for (let [o, a] of n) this._addRetryWaiter(o, a)
    else {
      this._logger.verbose(
        `find-missing reported ${s.nonindexedBlobNames.length} nonindexed blob names`,
      ),
        s.nonindexedBlobNames.length > 0 &&
          Sg(this._logger, "verbose", s.nonindexedBlobNames, 5)
      let o = new Set(s.unknownBlobNames),
        a = new Set(s.nonindexedBlobNames)
      for (let [l, c] of n)
        o.has(l)
          ? this._workspaceManager.notifyBlobMissing(c.qualifiedPath, l)
          : a.has(l) && this._addRetryWaiter(l, c)
    }
  }
  _enqueueForProbe(r) {
    if (r === undefined) this._toProbe.kick()
    else {
      let [n, i] = r
      this._logger.verbose(
        `probe enqueue: ${i.qualifiedPath.rootPath}:${i.qualifiedPath.relPath}: ${n}`,
      ),
        this._toProbe.insert(n, i)
    }
    return Promise.resolve()
  }
  _addRetryWaiter(r, n) {
    Date.now() - n.startTime < e.probePatienceMs
      ? (this._logger.verbose(
          `retry enqueue: ${n.qualifiedPath.rootPath}:${n.qualifiedPath.relPath}: ${r}`,
        ),
        this._probeWaiters.insert(r, n))
      : (this._logger.verbose(
          `long retry enqueue: ${n.qualifiedPath.rootPath}:${n.qualifiedPath.relPath}: ${r}`,
        ),
        this._longWaiters.insert(r, n))
  }
}
var IndexingContext = class IndexingContext {
  constructor(blobsData, recentChunks, trackedPaths, unindexedEditEvents = [], unindexedEditEventsBaseBlobNames = [], lastChatResponse, blobNames) {
    this.blobs = blobsData
    this.recentChunks = recentChunks
    this.trackedPaths = trackedPaths
    this.unindexedEditEvents = unindexedEditEvents
    this.unindexedEditEventsBaseBlobNames = unindexedEditEventsBaseBlobNames
    this.lastChatResponse = lastChatResponse
    this.blobNames = blobNames
  }
  static empty() {
    return new IndexingContext(
      { checkpointId: undefined, addedBlobs: [], deletedBlobs: [] },
      new Array(),
      new Map(),
      [],
      [],
      undefined,
      [],
    )
  }
}
function T9(e) {
  return Zy(getPathFromUri(e))
}
function Fw(e) {
  if (e.scheme === "file") return T9(e)
}
var SourceFolder = class extends DisposableContainer {
    constructor(folderName, folderRoot, repoRoot, workspaceFolder, vcsDetails, folderId, diskFileManager, cacheDirPath, disposables, eventEmitter, logger) {
      super(disposables, eventEmitter)
      this.folderName = folderName
      this.folderRoot = folderRoot
      this.repoRoot = repoRoot
      this.workspaceFolder = workspaceFolder
      this.vcsDetails = vcsDetails
      this.folderId = folderId
      this.diskFileManager = diskFileManager
      this.cacheDirPath = cacheDirPath
      this.logger = logger
      ;(this._operationQueue = new ProcessQueue(
        async (operation) => await this._runSerializedOperation(operation),
      )),
        this.addDisposables(this._operationQueue, {
          dispose: () => this._disposeTracker(),
        })
    }
    _operationQueue
    _tracker
    _newlyTracked = false
    _initialEnumerationComplete = false
    _initialSyncComplete = false
    _stopped = false
    dispose() {
      ;(this._stopped = true), super.dispose()
    }
    get stopped() {
      return this._stopped
    }
    get type() {
      return this.workspaceFolder === undefined ? 1 : 0
    }
    _disposeTracker() {
      this._tracker?.dispose(), (this._tracker = undefined)
    }
    setTracker(tracker) {
      if (this.stopped) throw new Error("Source folder has been disposed") // =
      this._disposeTracker(), (this._tracker = tracker)
    }
    get tracker() {
      return this._tracker // =
    }
    get initialEnumerationComplete() {
      return this._initialEnumerationComplete
    }
    setInitialEnumerationComplete() {
      this._initialEnumerationComplete = true
    }
    get initialSyncComplete() {
      return this._initialSyncComplete
    }
    setInitialSyncComplete() {
      this._initialSyncComplete = true
    }
    relativePathName(path) {
      if (Qs(this.folderRoot, path)) return ql(this.repoRoot, path)
    }
    acceptsPath(path) {
      return this._tracker === undefined
        ? false
        : this._tracker.pathFilter.acceptsPath(path)
    }
    async enqueueSerializedOperation(operation) {
      this._operationQueue.insert(operation), await this._operationQueue.kick()
    }
    async _runSerializedOperation(operation) {
      operation !== undefined &&
        (!this._initialEnumerationComplete || this._stopped || (await operation()))
    }
  },
  M9 = class extends DisposableContainer {
    constructor(r, n, i) {
      super(i)
      this.pathFilter = r
      this.pathNotifier = n
    }
  }
var nonTrackableFolderStatuses = new Set(["home directory", "too large"]),
  nestedFolderStatuses = new Set(["nested"])
function isNonTrackableFolderStatus(e) {
  return nonTrackableFolderStatuses.has(e)
}
function isNestedFolderStatus(e) {
  return nestedFolderStatuses.has(e)
}
function getFolderStatus(folderInfo) {
  return folderInfo.containingFolderRoot !== undefined
    ? "nested"
    : folderInfo.isHomeDir
      ? "home directory"
      : folderInfo.folderQualification !== undefined && !folderInfo.folderQualification.trackable
        ? "too large"
        : folderInfo.syncingPermission === "denied"
          ? "permission denied"
          : folderInfo.syncingPermission === "granted"
            ? "trackable"
            : folderInfo.folderQualification === undefined
              ? "qualifying"
              : "permission needed"
}
var WorkspaceManager = class WorkspaceManager extends DisposableContainer {
  constructor(actionsModel, externalSourceFolderRecorder, syncingPermissionTracker, storageUriProvider, apiServer, configListener, featureFlagManager, clientMetricsReporter, completionServer, blobNameCalculator, maxUploadSizeBytes, syncingEnabledTracker, onboardingSessionEventReporter, languageExtensions = new Array(), options) {
    super()
    this._actionsModel = actionsModel
    this._externalSourceFolderRecorder = externalSourceFolderRecorder
    this._syncingPermissionTracker = syncingPermissionTracker
    this._storageUriProvider = storageUriProvider
    this._apiServer = apiServer
    this._configListener = configListener
    this._featureFlagManager = featureFlagManager
    this._clientMetricsReporter = clientMetricsReporter
    this._completionServer = completionServer
    this._blobNameCalculator = blobNameCalculator
    this._maxUploadSizeBytes = maxUploadSizeBytes
    this._syncingEnabledTracker = syncingEnabledTracker
    this._onboardingSessionEventReporter = onboardingSessionEventReporter
    ;(this._enableFileLimitsForSyncingPermission =
      this._featureFlagManager.currentFlags.enableFileLimitsForSyncingPermission),
      (this._maxTrackableFiles =
        this._featureFlagManager.currentFlags.maxTrackableFileCount),
      (this._maxTrackableFilesWithoutPermission = Math.min(
        this._featureFlagManager.currentFlags
          .maxTrackableFileCountWithoutPermission,
        this._maxTrackableFiles,
      ))
    let minUploadedPercentage = Math.min(
      this._featureFlagManager.currentFlags
        .minUploadedPercentageWithoutPermission,
      100,
    )
    if (
      ((this._verifyFolderIsSourceRepo =
        this._featureFlagManager.currentFlags.verifyFolderIsSourceRepo),
      (this._minUploadedFractionWithoutPermission = minUploadedPercentage * 0.01),
      (this._refuseToSyncHomeDirectories =
        this._featureFlagManager.currentFlags.refuseToSyncHomeDirectories),
      (this._useCheckpointManagerContext =
        options?.useCheckpointManagerContext ??
        isMinVersionMet(
          this._featureFlagManager.currentFlags
            .useCheckpointManagerContextMinVersion,
        )),
      (this._validateCheckpointManagerContext =
        this._featureFlagManager.currentFlags.validateCheckpointManagerContext),
      (this._folderEnumeratedEmitter = this.addDisposable(
        new St.EventEmitter(),
      )),
      (this._folderSyncedEmitter = this.addDisposable(new St.EventEmitter())),
      (this._syncingProgressEmitter = this.addDisposable(
        new St.EventEmitter(),
      )),
      (this._syncingStateEmitter = this.addDisposable(new St.EventEmitter())),
      (this._sourceFoldersChangedEmitter = this.addDisposable(
        new St.EventEmitter(),
      )),
      (this._sourceFolderContentsChangedEmitter = this.addDisposable(
        new St.EventEmitter(),
      )),
      (this._sourceFolderContentsChangedEmitter = this.addDisposable(
        new St.EventEmitter(),
      )),
      (this._fileChangedEmitter = this.addDisposable(new St.EventEmitter())),
      (this._textDocumentOpenedEmitter = this.addDisposable(
        new St.EventEmitter(),
      )),
      (this._textDocumentClosedEmitter = this.addDisposable(
        new St.EventEmitter(),
      )),
      (this._textDocumentChangedEmitter = this.addDisposable(
        new St.EventEmitter(),
      )),
      (this._fileDeletedEmitter = this.addDisposable(new St.EventEmitter())),
      (this._fileWillRenameEmitter = this.addDisposable(new St.EventEmitter())),
      (this._fileDidMoveEmitter = this.addDisposable(new St.EventEmitter())),
      this._featureFlagManager.currentFlags.bypassLanguageFilter)
    )
      this._fileExtensions = undefined
    else {
      let extensionSet = new Set()
      for (let language of languageExtensions) for (let extension of language.extensions) extensionSet.add(extension)
      this._fileExtensions = extensionSet
    }
    ;(this._pathHandler = new F2(this._maxUploadSizeBytes, fIe())),
      (this._pathMap = this.addDisposable(new WorkspacePathMap()))
    let openFileManagerV2
    if (this._configListener.config.openFileManager.v2Enabled) {
      let fileUploader = new _2(this._blobNameCalculator, this._apiServer)
      this.addDisposable(fileUploader), (openFileManagerV2 = new w2(fileUploader, this._blobNameCalculator))
    }
    let openFileManagerV1 = new OpenFileManager(
      this._apiServer,
      this._completionServer,
      this._configListener,
      this._blobNameCalculator,
      this._pathMap,
      this._sequenceGenerator,
    )
    this.addDisposable(openFileManagerV1),
      (this._openFileManager = new OpenFileManagerProxy(this._configListener, openFileManagerV1, openFileManagerV2))
    let checkpointThreshold = options?.blobsCheckpointThreshold
    ;(this._blobsCheckpointManager = this.addDisposable(
      new BlobsCheckpointManager(
        this._apiServer,
        this._featureFlagManager,
        this._pathMap.onDidChangeBlobName,
        checkpointThreshold,
      ),
    )),
      (this._unknownBlobHandler = this.addDisposable(
        new q2(this._apiServer, this),
      )),
      (this._sourceFolderReconciler = this.addDisposable(
        new SingletonExecutor(() => this._reconcileSourceFolders()),
      )),
      (this._sourceFolderDescriber = new L2(
        this._apiServer,
        this._pathHandler,
        this._fileExtensions,
        this._maxTrackableFiles,
      )),
      this.addDisposable(
        St.workspace.onDidChangeWorkspaceFolders(
          this._handleWorkspaceFolderChangeEvent.bind(this),
        ),
      ),
      this.addDisposable(
        St.workspace.onDidChangeTextDocument(
          this._notifyTextDocumentChanged.bind(this),
        ),
      ),
      this.addDisposable(
        St.workspace.onDidOpenTextDocument(
          this._notifyTextDocumentOpened.bind(this),
        ),
      ),
      this.addDisposable(
        St.workspace.onDidCloseTextDocument(
          this._notifyTextDocumentClosed.bind(this),
        ),
      ),
      this.addDisposable(
        St.workspace.onDidChangeNotebookDocument(
          this._notifyNotebookDocumentChanged.bind(this),
        ),
      ),
      this.addDisposable(
        St.window.onDidChangeActiveTextEditor(
          this._notifyActiveEditorChanged.bind(this),
        ),
      ),
      this.addDisposable(
        St.workspace.onDidCloseTextDocument((T) => {
          this._notifyDocumentClosed(T)
        }),
      ),
      this.addDisposable(
        St.workspace.onDidCloseNotebookDocument((T) => {
          this._notifyDocumentClosed(T)
        }),
      ),
      this.addDisposable(
        St.workspace.onWillRenameFiles((T) => {
          this._notifyWillRenameFile(T)
        }),
      ),
      this.addDisposable(
        St.workspace.onDidRenameFiles((T) => {
          this._notifyDidRenameFile(T)
        }),
      ),
      this.addDisposable(
        this._configListener.onDidChange(this._notifyConfigChange.bind(this)),
      ),
      this._notifyConfigChange(),
      this.addDisposable(new St.Disposable(() => this._disposeSourceFolders())),
      this.addDisposable(new St.Disposable(() => this._disposeTabWatcher())),
      this._actionsModel.setSystemStateStatus("syncingPermitted", "complete"),
      this._actionsModel.setSystemStateStatus(
        "workspaceTooLarge",
        "initializing",
      ),
      this._actionsModel.setSystemStateStatus(
        "uploadingHomeDir",
        "initializing",
      ),
      this._registerInitialSourceFolders(),
      this._awaitInitialSourceFolders()
  }
  static augmentRootName = ".augmentroot"
  static ignoreSources(folderRoot) {
    return [new ww(".gitignore"), new a2(folderRoot), new ww(".augmentignore")]
  }
  static pathMapPersistFrequencyMs = 6e4
  static defaultPathAccept = new wg()
  static _textEncoder = new TextEncoder()
  _initialSourceFolders = new Set()
  _registeredSourceFolders = new Map()
  _trackedSourceFolders = new Map()
  _fileExtensions
  _pathMap
  _sequenceGenerator = new f2()
  _pathHandler
  _openFileManager
  _blobsCheckpointManager
  _unknownBlobHandler
  _sourceFolderDescriber
  _logger = z("WorkspaceManager")
  _tabWatcher
  _vcsWatcher
  _fileEditManager
  _folderEnumeratedEmitter
  _folderSyncedEmitter
  _syncingProgressEmitter
  _syncingPermissionInitialized = false
  _sourceFolderReconciler
  _syncingStateEmitter
  _sourceFoldersChangedEmitter
  _sourceFolderContentsChangedEmitter
  _fileChangedEmitter
  _textDocumentOpenedEmitter
  _textDocumentClosedEmitter
  _textDocumentChangedEmitter
  _fileDeletedEmitter
  _fileWillRenameEmitter
  _fileDidMoveEmitter
  _lastChatResponse = undefined
  _enableFileLimitsForSyncingPermission
  _maxTrackableFiles
  _maxTrackableFilesWithoutPermission
  _verifyFolderIsSourceRepo
  _minUploadedFractionWithoutPermission
  _refuseToSyncHomeDirectories
  _useCheckpointManagerContext
  _validateCheckpointManagerContext
  _stopping = false
  dispose() {
    ;(this._stopping = true), super.dispose()
  }
  get enableFileLimitsForSyncingPermission() {
    return this._enableFileLimitsForSyncingPermission
  }
  get maxTrackableFiles() {
    return this._maxTrackableFiles
  }
  get maxTrackableFilesWithoutPermission() {
    return this._maxTrackableFilesWithoutPermission
  }
  get verifyFolderIsSourceRepo() {
    return this._verifyFolderIsSourceRepo
  }
  get minUploadedFractionWithoutPermission() {
    return this._minUploadedFractionWithoutPermission
  }
  get refuseToSyncHomeDirectories() {
    return this._refuseToSyncHomeDirectories
  }
  get fileDeletedEmitter() {
    return this._fileDeletedEmitter.event
  }
  get fileWillRenameEmitter() {
    return this._fileWillRenameEmitter.event
  }
  get initialFoldersEnumerated() {
    return Array.from(this._initialSourceFolders).every((folderRoot) => {
      let folderInfo = this._registeredSourceFolders.get(folderRoot)
      if (folderInfo === undefined) return true
      let folderStatus = getFolderStatus(folderInfo)
      return isNonTrackableFolderStatus(folderStatus) || isNestedFolderStatus(folderStatus) || folderStatus === "permission denied"
        ? true
        : this._trackedSourceFolders.get(folderRoot)?.sourceFolder
            ?.initialEnumerationComplete
    })
  }
  async awaitInitialFoldersEnumerated() {
    for (; !this.initialFoldersEnumerated; )
      await createDisposablePromise(this._folderEnumeratedEmitter.event)
  }
  get onDidEnumerateFolder() {
    return this._folderEnumeratedEmitter.event
  }
  get initialFoldersSynced() {
    return Array.from(this._initialSourceFolders).every((folderRoot) => {
      let folderInfo = this._registeredSourceFolders.get(folderRoot)
      if (folderInfo === undefined) return true
      let folderStatus = getFolderStatus(folderInfo)
      return isNonTrackableFolderStatus(folderStatus) || isNestedFolderStatus(folderStatus) || folderStatus === "permission denied"
        ? true
        : this._trackedSourceFolders.get(folderRoot)?.sourceFolder?.initialSyncComplete
    })
  }
  async awaitInitialFoldersSynced() {
    for (; !this.initialFoldersSynced; )
      await createDisposablePromise(this._folderSyncedEmitter.event)
  }
  get onDidChangeSyncingProgress() {
    return this._syncingProgressEmitter.event
  }
  get syncingEnabledState() {
    if (!this._syncingPermissionInitialized) return "initializing"
    if (this._syncingPermissionTracker.syncingPermissionDenied)
      return "disabled"
    let permissionNeededCount = 0
    for (let [folderRoot, folderInfo] of this._registeredSourceFolders) {
      let folderStatus = getFolderStatus(folderInfo)
      if (isNonTrackableFolderStatus(folderStatus) || folderStatus === "permission denied") return "disabled"
      folderStatus === "permission needed" && permissionNeededCount++
    }
    return permissionNeededCount > 0 ? "partial" : "enabled"
  }
  get onDidChangeSyncingState() {
    return this._syncingStateEmitter.event
  }
  get onDidChangeSourceFolders() {
    return this._sourceFoldersChangedEmitter.event
  }
  get onDidChangeSourceFolderContents() {
    return this._sourceFolderContentsChangedEmitter.event
  }
  get onDidChangeFile() {
    return this._fileChangedEmitter.event
  }
  get onFileDeleted() {
    return this._fileDeletedEmitter.event
  }
  get onFileDidMove() {
    return this._fileDidMoveEmitter.event
  }
  get completionServer() {
    return this._completionServer
  }
  _disposeSourceFolders() {
    this._registeredSourceFolders.forEach((folderInfo) => {
      folderInfo.cancel?.cancel(), folderInfo.cancel?.dispose(), (folderInfo.cancel = undefined)
    }),
      this._trackedSourceFolders.forEach((trackedFolder) => trackedFolder.sourceFolder?.dispose()),
      this._trackedSourceFolders.clear(),
      this._vcsWatcher?.dispose(),
      this._fileEditManager?.dispose()
  }
  _disposeTabWatcher() {
    this._tabWatcher?.dispose(), (this._tabWatcher = undefined)
  }
  _disposeVCSWatcher() {
    this._vcsWatcher?.dispose(), (this._vcsWatcher = undefined)
  }
  _disposeEditFileManager() {
    this._fileEditManager?.dispose(), (this._fileEditManager = undefined)
  }
  _notifyConfigChange() {
    this._stopping ||
      (this._configListener.config.recencySignalManager.collectTabSwitchEvents
        ? this._tabWatcher === undefined && (this._tabWatcher = new O2(this))
        : this._disposeTabWatcher(),
      this._configListener.config.vcs.watcherEnabled
        ? this._vcsWatcher === undefined &&
          (this._vcsWatcher = new A2(
            new Xm.FileUploaderImpl(this._blobNameCalculator, this._apiServer),
            this._configListener,
          ))
        : this._disposeVCSWatcher(),
      isVersionSupported(
        this._configListener.config,
        this._featureFlagManager.currentFlags.vscodeNextEditMinVersion,
      ) || this.getEnableCompletionFileEditEvents()
        ? this._fileEditManager === undefined &&
          ((this._fileEditManager = new FileEditManager(
            this._blobNameCalculator,
            this._maxUploadSizeBytes,
            this._textDocumentChangedEmitter.event,
            this._textDocumentOpenedEmitter.event,
            this._textDocumentClosedEmitter.event,
            this._fileDeletedEmitter.event,
            this._fileWillRenameEmitter.event,
            this._configListener.config.enableDebugFeatures,
          )),
          this._fileEditManager.listenToEvents(),
          this._trackedSourceFolders.forEach((trackedFolder) => {
            trackedFolder.sourceFolder !== undefined &&
              this._fileEditManager?.startTracking(
                trackedFolder.sourceFolder.folderId,
                trackedFolder.sourceFolder.folderName,
                {
                  directory: this._computeCacheDirPath(
                    trackedFolder.sourceFolder.folderRoot,
                  ),
                },
              )
          }))
        : this._disposeEditFileManager())
  }
  getSyncingProgress() {
    let progressItems = new Array()
    return (
      this._trackedSourceFolders.forEach((trackedFolder, folderRoot) => {
        progressItems.push(this._getSyncingProgress(folderRoot, trackedFolder.sourceFolder))
      }),
      progressItems
    )
  }
  _reportSyncingProgress(sourceFolder) {
    this._syncingProgressEmitter.fire(this._getSyncingProgress(sourceFolder.folderRoot, sourceFolder)) // =
  }
  _getSyncingProgress(folderRoot, sourceFolder) {
    let progress = sourceFolder?.initialEnumerationComplete
      ? {
          newlyTracked: sourceFolder._newlyTracked,
          trackedFiles: this._pathMap.trackedFileCount(sourceFolder.folderId),
          backlogSize: sourceFolder.diskFileManager.itemsInFlight,
        }
      : undefined
    return { folderRoot: folderRoot, progress: progress }
  }
  _isHomeDir(folderPath) {
    return this._featureFlagManager.currentFlags.refuseToSyncHomeDirectories
      ? BIe(folderPath)
      : false
  }
  _registerInitialSourceFolders() {
    let externalFolders = new Array()
    St.workspace.workspaceFolders?.forEach((workspaceFolder) => {
      let folderPath = Fw(workspaceFolder.uri)
      folderPath !== undefined && this._mtimeCacheExists(folderPath) && externalFolders.push(folderPath)
    }),
      this._syncingPermissionTracker.setDefaultPermissions(externalFolders),
      this._externalSourceFolderRecorder.getFolders().forEach((folderName, folderPath) => {
        if (this._isHomeDir(folderPath)) {
          this._logger.info(
            `Rejecting external source folder ${folderPath}: home directory`,
          )
          return
        }
        this._logger.info(`Adding external source folder ${folderPath}`),
          this._initialSourceFolders.add(folderPath),
          this._registeredSourceFolders.set(folderPath, {
            folderName: folderName,
            isHomeDir: false,
            folderType: 1,
            syncingPermission: this._syncingPermissionTracker
              .syncingPermissionDenied
              ? "denied"
              : "granted",
          })
      })
    let permittedFolders = new Array()
    St.workspace.workspaceFolders?.forEach((workspaceFolder) => {
      let folderName = workspaceFolder.name,
        folderPath = Fw(workspaceFolder.uri)
      if (folderPath === undefined) return
      let syncingPermission = this._syncingPermissionTracker.getFolderSyncingPermission(folderPath)
      this._logger.info(
        `Adding workspace folder ${folderName}; folderRoot = ${folderPath}; syncingPermission = ${syncingPermission}`,
      ),
        this._initialSourceFolders.add(folderPath),
        this._registeredSourceFolders.set(folderPath, {
          folderName: folderName,
          isHomeDir: this._isHomeDir(folderPath),
          folderType: 0,
          syncingPermission: syncingPermission,
          workspaceFolder: workspaceFolder,
        }),
        syncingPermission === "granted" && permittedFolders.push(folderPath)
    }),
      this._syncingPermissionTracker.dropStaleFolders(permittedFolders),
      this._setSyncingPermissionInitialized()
  }
  _mtimeCacheExists(folderPath) {
    let cacheDirPath = this._computeCacheDirPath(folderPath)
    return T2(cacheDirPath)
  }
  _setSyncingPermissionInitialized() {
    ;(this._syncingPermissionInitialized = true),
      (this._syncingEnabledTracker.workspaceManager = this)
  }
  async _awaitInitialSourceFolders() {
    let startTime = Date.now()
    this._kickSourceFolderReconciler(),
      await this.awaitInitialFoldersSynced(),
      this._reportWorkspaceStartup(Date.now() - startTime),
      this._folderSyncedEmitter.fire()
  }
  _handleWorkspaceFolderChangeEvent(event) {
    for (let workspaceFolder of event.added) {
      let folderName = workspaceFolder.name,
        folderPath = Fw(workspaceFolder.uri)
      if (folderPath === undefined) continue
      let syncingPermission = this._syncingPermissionTracker.getFolderSyncingPermission(folderPath)
      this._logger.info(
        `Adding workspace folder ${folderName}; folderRoot = ${folderPath}; syncingPermission = ${syncingPermission}`,
      ),
        this._registeredSourceFolders.set(folderPath, {
          folderName: folderName,
          isHomeDir: this._isHomeDir(folderPath),
          folderType: 0,
          syncingPermission: syncingPermission,
          workspaceFolder: workspaceFolder,
        })
    }
    let removedFolders = new Array()
    for (let workspaceFolder of event.removed) {
      let folderPath = Fw(workspaceFolder.uri)
      if (folderPath === undefined) continue
      this._logger.info(`Removing workspace folder ${folderPath}`)
      let folderInfo = this._registeredSourceFolders.get(folderPath)
      folderInfo !== undefined &&
        (folderInfo.cancel?.cancel(),
        folderInfo.cancel?.dispose(),
        (folderInfo.cancel = undefined),
        this._registeredSourceFolders.delete(folderPath),
        removedFolders.push(folderPath))
    }
    this._syncingPermissionTracker.dropPermission(removedFolders),
      this._kickSourceFolderReconciler()
  }
  addExternalSourceFolder(uri) {
    let folderPath = Fw(uri)
    if (folderPath === undefined) throw new OF()
    if (this._registeredSourceFolders.has(folderPath)) throw new HF()
    try {
      if (getFileStats(folderPath).type !== "Directory") throw new VF()
    } catch (error) {
      throw new qF(getErrorMessage(error))
    }
    if (this._isHomeDir(folderPath)) throw new WF()
    this._logger.info(`Adding external source folder ${getUriPath(uri)}`),
      this._registeredSourceFolders.set(folderPath, {
        folderName: K0e(folderPath),
        isHomeDir: false,
        folderType: 1,
        syncingPermission: this._syncingPermissionTracker
          .syncingPermissionDenied
          ? "denied"
          : "granted",
      }),
      this._kickSourceFolderReconciler()
  }
  removeExternalSourceFolder(folderPath) {
    let folderInfo = this._registeredSourceFolders.get(folderPath)
    if (folderInfo !== undefined) {
      if (folderInfo.folderType !== 1) throw new GF()
      this._logger.info(`Removing external source folder ${folderPath}`),
        this._registeredSourceFolders.delete(folderPath),
        this._kickSourceFolderReconciler()
    }
  }
  enableSyncing() {
    this._logger.info("Enabling syncing for all trackable source folders")
    let permittedFolders = new Array()
    this._registeredSourceFolders.forEach((folderInfo, folderPath) => { //=
      let folderStatus = getFolderStatus(folderInfo)
      isNonTrackableFolderStatus(folderStatus) ||
        folderStatus === "qualifying" ||
        ((folderInfo.syncingPermission = "granted"), permittedFolders.push(folderPath))
    }),
      this._syncingPermissionTracker.setPermittedFolders(permittedFolders), // =
      this._kickSourceFolderReconciler() // =
  }
  disableSyncing() {
    this._logger.info("Disabling syncing for all trackable source folders"),
      this._registeredSourceFolders.forEach((folderInfo) => {
        let folderStatus = getFolderStatus(folderInfo)
        isNonTrackableFolderStatus(folderStatus) || (folderInfo.syncingPermission = "denied")
      }),
      this._syncingPermissionTracker.denyPermission(),
      this._kickSourceFolderReconciler()
  }
  requalifyLargeFolders() {
    this._registeredSourceFolders.forEach((folderInfo) => {
      folderInfo.folderQualification = undefined
    }),
      this._kickSourceFolderReconciler()
  }
  async _kickSourceFolderReconciler() {
    await this._updateStoredExternalSourceFolders() // =
    let nestedFolders = new Set() // =
    for (let [folderPath, folderInfo] of this._registeredSourceFolders)
      if (getFolderStatus(folderInfo) === "trackable") {
        for (let [otherPath, otherInfo] of this._registeredSourceFolders)
          if (getFolderStatus(otherInfo) === "trackable" && folderPath !== otherPath && Qs(otherPath, folderPath)) {
            nestedFolders.add(folderPath)
            break
          }
      }
    for (let [folderPath, folderInfo] of this._registeredSourceFolders) {
      if (!nestedFolders.has(folderPath)) {
        folderInfo.containingFolderRoot = undefined
        continue
      }
      for (let otherPath of this._registeredSourceFolders.keys())
        if (!(folderPath === otherPath || nestedFolders.has(otherPath)) && Qs(otherPath, folderPath)) {
          folderInfo.containingFolderRoot !== otherPath &&
            this._logger.info(
              `Source folder ${folderPath} will not be tracked. Containing folder: ${otherPath}`,
            ),
            (folderInfo.containingFolderRoot = otherPath)
          break
        }
    }
    this._updateActionsModelState() // =
    for (let [folderPath, folderInfo] of this._registeredSourceFolders)
      getFolderStatus(folderInfo) === "qualifying" &&
        folderInfo.cancel === undefined &&
        this._qualifySourceFolder(folderPath, folderInfo)
    this._syncingStateEmitter.fire(this.syncingEnabledState),
      this._sourceFoldersChangedEmitter.fire(),
      this._sourceFolderReconciler.kick() // =
  }
  async _updateStoredExternalSourceFolders() {
    let externalFolders = new Map()
    for (let [folderPath, folderInfo] of this._registeredSourceFolders)
      folderInfo.folderType === 1 && externalFolders.set(folderPath, folderInfo.folderName)
    await this._externalSourceFolderRecorder.setFolders(externalFolders) // =
  }
  _updateActionsModelState() {
    if (this._syncingPermissionTracker.syncingPermissionDenied) { // =
      this._actionsModel.setSystemStateStatus("syncingPermitted", "incomplete")
      return
    }
    let permissionNeeded = false,
      homeDirFound = false,
      tooLargeFound = false
    for (let [folderPath, folderInfo] of this._registeredSourceFolders) {
      let folderStatus = getFolderStatus(folderInfo)
      if (folderStatus === "permission needed") {
        permissionNeeded = true
        break
      } else if (folderStatus === "home directory") {
        homeDirFound = true
        break
      } else if (folderStatus === "too large") {
        tooLargeFound = true
        break
      }
    }
    let syncingStatus = permissionNeeded ? "initializing" : "complete"
    this._actionsModel.setSystemStateStatus("syncingPermitted", syncingStatus)
    let homeDirStatus = homeDirFound ? "complete" : "initializing"
    this._actionsModel.setSystemStateStatus("uploadingHomeDir", homeDirStatus)
    let workspaceSizeStatus = tooLargeFound ? "complete" : "initializing"
    this._actionsModel.setSystemStateStatus("workspaceTooLarge", workspaceSizeStatus)
  }
  async _qualifySourceFolder(folderPath, folderInfo) {
    let [repoRoot, isRepo] = await this._findRepoRoot(folderPath),
      qualification,
      qualificationType
    if (this._enableFileLimitsForSyncingPermission) {
      ;(qualificationType = "full"),
        this._logger.info(`Beginning ${qualificationType} qualification of source folder ${folderPath}`)
      let cancellationSource = new St.CancellationTokenSource()
      if (
        ((folderInfo.cancel = cancellationSource),
        (qualification = await this._sourceFolderDescriber.describe(
          folderPath,
          repoRoot,
          WorkspaceManager.ignoreSources(folderPath),
        )),
        cancellationSource.token.isCancellationRequested)
      ) {
        this._logger.info(`Cancelled qualification of source folder ${folderPath}`)
        return
      }
      ;(folderInfo.cancel = undefined), cancellationSource.dispose()
    } else
      (qualificationType = "phony"),
        this._logger.info(
          `Beginning ${qualificationType} qualification of source folder ${folderPath} per feature flag`,
        ),
        (qualification = { trackable: true, trackableFiles: 0, uploadedFraction: 1 })
    let folderQualification = { ...qualification, repoRoot: repoRoot, isRepo: isRepo }
    ;(folderInfo.folderQualification = folderQualification),
      this._syncingPermissionTracker.syncingPermissionDenied
        ? this._logger.info(
            `Finished ${qualificationType} qualification of source folder ${folderPath}: syncing disabled for workspace`,
          )
        : folderQualification.trackable
          ? (this._logger.info(
              `Finished ${qualificationType} qualification of source folder ${folderPath}: trackable files: ${folderQualification.trackableFiles}, uploaded fraction: ${folderQualification.uploadedFraction}, is repo: ${folderQualification.isRepo}`,
            ),
            folderQualification.trackableFiles > this._maxTrackableFilesWithoutPermission
              ? this._logger.info(
                  `Requesting syncing permission because source folder has more than ${this._maxTrackableFilesWithoutPermission} files`,
                )
              : this._verifyFolderIsSourceRepo && !folderQualification.isRepo
                ? this._logger.info(
                    "Requesting syncing permission because source folder does not appear to be a source repo",
                  )
                : folderQualification.uploadedFraction <
                    this._minUploadedFractionWithoutPermission
                  ? this._logger.info(
                      `Requesting syncing permission because source folder has less than ${this._minUploadedFractionWithoutPermission * 100}% of files uploaded`,
                    )
                  : ((folderInfo.syncingPermission = "granted"),
                    this._syncingPermissionTracker.addImplicitlyPermittedFolder(
                      folderPath,
                    )))
          : this._logger.info(
              `Finished ${qualificationType} qualification of source folder ${folderPath}: folder not trackable; too large`,
            ),
      this._kickSourceFolderReconciler()
  }
  async _reconcileSourceFolders() {
    await this._syncingPermissionTracker.persistCurrentPermission() // =
    let syncingDisabled = this.syncingEnabledState === "disabled", // =
      foldersToStop = new Map()
    for (let [folderPath, trackedFolder] of this._trackedSourceFolders) {
      let folderInfo = this._registeredSourceFolders.get(folderPath), // =
        stopReason
      if (folderInfo === undefined) stopReason = "source folder has been removed"
      else if (syncingDisabled) stopReason = "syncing is disabled"
      else if (folderInfo.containingFolderRoot !== undefined)
        stopReason = `source folder is nested inside folder ${folderInfo.containingFolderRoot}`
      else if (folderInfo.isHomeDir) stopReason = "source folder is a home directory"
      else if (folderInfo.folderQualification?.trackable === false)
        stopReason = "source folder is too large"
      else {
        let folderStatus = getFolderStatus(folderInfo)
        folderStatus === "permission denied"
          ? (stopReason = "syncing permission denied for this source folder")
          : folderStatus === "permission needed"
            ? (stopReason = "syncing permission not yet granted for this source folder")
            : folderStatus === "qualifying" && (stopReason = "source folder is being qualified")
      }
      stopReason !== undefined && foldersToStop.set(folderPath, [trackedFolder, stopReason])
    }
    let foldersToStart = new Map()
    for (let [folderPath, folderInfo] of this._registeredSourceFolders) {
      if (getFolderStatus(folderInfo) !== "trackable") continue
      let trackedFolder = this._trackedSourceFolders.get(folderPath)
      trackedFolder === undefined &&
        ((trackedFolder = {
          folderName: folderInfo.folderName,
          folderSpec: (0, nc.cloneDeep)(folderInfo),
          cancel: new St.CancellationTokenSource(),
          sourceFolder: undefined,
          logger: z(`WorkspaceManager[${folderInfo.folderName}]`),
        }),
        foldersToStart.set(folderPath, trackedFolder))
    }
    for (let [folderPath, [trackedFolder, stopReason]] of foldersToStop)
      trackedFolder.logger.info(`Stop tracking: ${stopReason}`),
        this._trackedSourceFolders.delete(folderPath),
        this._stopTracking(trackedFolder) // =
    for (let [folderPath, trackedFolder] of foldersToStart)
      trackedFolder.logger.info("Start tracking"),
        this._trackedSourceFolders.set(folderPath, trackedFolder),
        this._startTracking(folderPath, trackedFolder) // =
    return Promise.resolve()
  }
  async _startTracking(folderPath, trackedFolder) {
    let startupMetrics = new l2("Startup metrics"), // =
      cancellationSource = trackedFolder.cancel,
      sourceFolder = await this._createSourceFolder(folderPath, trackedFolder, cancellationSource.token)
    if (cancellationSource.token.isCancellationRequested) {
      trackedFolder.logger.info("Cancelled in-progress creation of source folder"),
        sourceFolder?.dispose()
      return
    }
    if (
      (startupMetrics.charge("create SourceFolder"),
      cancellationSource.dispose(),
      sourceFolder === undefined || this._stopping)
    ) {
      trackedFolder.logger.info("Stopped tracking source folder")
      return
    }
    trackedFolder.sourceFolder = sourceFolder
    let folderName = trackedFolder.folderName,
      folderId = sourceFolder.folderId,
      mtimeCache = await UIe(folderName, sourceFolder.cacheDirPath)
    if ((startupMetrics.charge("read MtimeCache"), sourceFolder.stopped)) {
      trackedFolder.logger.info("Stopped tracking source folder")
      return
    }
    for (let [filePath, fileInfo] of mtimeCache)
      this._pathMap.insert(folderId, filePath, "File", WorkspaceManager.defaultPathAccept),
        this._pathMap.update(folderId, filePath, 0, fileInfo.name, fileInfo.mtime)
    startupMetrics.charge("pre-populate PathMap")
    let disposables = new DisposableCollection()
    try {
      ;(sourceFolder._newlyTracked = mtimeCache.size === 0),
        disposables.add({ dispose: () => (sourceFolder._newlyTracked = false) })
      let enumerationResult = await this._refreshSourceFolder(sourceFolder, startupMetrics)
      if (enumerationResult === undefined || sourceFolder.stopped) return
      startupMetrics.charge("enumerate"),
        sourceFolder.setInitialEnumerationComplete(),
        this._folderEnumeratedEmitter.fire()
      let pathStatusChangeEvent = this._pathMap.onDidChangePathStatus(folderId)
      if (pathStatusChangeEvent === undefined) return
      sourceFolder.addDisposable(
        pathStatusChangeEvent((m) => {
          this._sourceFolderContentsChangedEmitter.fire(folderPath)
        }),
        true,
      ),
        sourceFolder.addDisposable(
          pathStatusChangeEvent((m) => {
            this._reportSyncingProgress(sourceFolder)
          }),
        ),
        sourceFolder.addDisposable(
          sourceFolder.diskFileManager.onDidChangeInProgressItemCount(() =>
            this._reportSyncingProgress(sourceFolder),
          ),
        ),
        this._reportSyncingProgress(sourceFolder),
        this._sourceFoldersChangedEmitter.fire(),
        await sourceFolder.diskFileManager.awaitQuiesced(),
        sourceFolder.setInitialSyncComplete(),
        this._folderSyncedEmitter.fire(),
        startupMetrics?.charge("await DiskFileManager quiesced")
      let mtimeCachePersister = new MTimeCacheWriter(folderName, sourceFolder.cacheDirPath)
      this._pathMap.enablePersist(folderId, mtimeCachePersister, WorkspaceManager.pathMapPersistFrequencyMs),
        startupMetrics.charge("enable persist"),
        this._reportSourceFolderStartup(trackedFolder.logger, sourceFolder, startupMetrics, enumerationResult),
        this._onboardingSessionEventReporter.reportEvent("finished-syncing")
    } finally {
      disposables.dispose(), this._reportSyncingProgress(sourceFolder)
    }
  }
  async _createSourceFolder(folderPath, trackedFolder, cancellationToken) {
    let folderName = trackedFolder.folderName, // =
      disposables = new DisposableCollection(),
      childDisposables = new DisposableCollection(),
      workspaceFolder = trackedFolder.folderSpec.folderType === 1 ? undefined : trackedFolder.folderSpec.workspaceFolder,
      [repoRoot, isRepo] = await this._findRepoRoot(folderPath)
    if (cancellationToken.isCancellationRequested) return
    let folderId = this._pathMap.openSourceFolder(folderPath, repoRoot)
    disposables.add(new St.Disposable(() => this._pathMap.closeSourceFolder(folderId))),
      disposables.addAll(...this._openFileManager.startTrackingFolder(folderName, folderId))
    let diskFileManager = new DiskFileManager(folderName, this._apiServer, this._pathHandler, this._pathMap)
    disposables.add(diskFileManager)
    let vcsRepo =
        trackedFolder.folderSpec.folderType === 0 && this._vcsWatcher !== undefined
          ? await ox(folderPath)
          : undefined,
      cacheDirPath = await this._migrateMtimeCache(folderPath, trackedFolder)
    return new SourceFolder(folderName, folderPath, repoRoot, workspaceFolder, vcsRepo, folderId, diskFileManager, cacheDirPath, disposables, childDisposables, trackedFolder.logger)
  }
  async _migrateMtimeCache(folderPath, trackedFolder) {
    let newCacheDirPath = this._computeCacheDirPath(folderPath)
    if (T2(newCacheDirPath)) return newCacheDirPath
    let oldCacheDirPath = this._computeCacheDirPath(trackedFolder.folderName)
    if (!T2(oldCacheDirPath)) return newCacheDirPath
    try {
      trackedFolder.logger.info(
        `Migrating mtime cache for ${trackedFolder.folderName} from "${oldCacheDirPath}" to "${newCacheDirPath}"`,
      ),
        await LIe(oldCacheDirPath, newCacheDirPath)
    } catch (error) {
      trackedFolder.logger.error(
        `Failed to migrate mtime cache for ${trackedFolder.folderName} from "${oldCacheDirPath}" to "${newCacheDirPath}": ${getErrorMessage(error)}`,
      )
    }
    return newCacheDirPath
  }
  _computeCacheDirPath(folderPath) {
    return WorkspaceManager.computeCacheDirPath(folderPath, this._storageUriProvider.storageUri)
  }
  static computeCacheDirPath(folderPath, storageUri) {
    let storagePath = getPathFromUri(storageUri),
      folderHash = createSHA256Hash(WorkspaceManager._textEncoder.encode(folderPath))
    return joinPaths(storagePath, folderHash)
  }
  async refreshSourceFolders() {
    this.requalifyLargeFolders()
    let refreshOperations = Array.from(this._trackedSourceFolders.values())
      .map((trackedFolder) => trackedFolder.sourceFolder)
      .filter((sourceFolder) => sourceFolder !== undefined)
      .map((sourceFolder) =>
        sourceFolder.enqueueSerializedOperation(async () => {
          await this._refreshSourceFolder(sourceFolder)
        }),
      )
    try {
      await Promise.allSettled(refreshOperations)
    } catch (error) {
      this._logger.info(
        `One or more source folders failed to refresh: ${getErrorMessage(error)}`,
      )
    }
  }
  async _refreshSourceFolder(sourceFolder, startupMetrics) {
    sourceFolder.logger.debug(`Refreshing source folder ${sourceFolder.folderName}`)
    let tracker = await this._createSourceFolderTracker(sourceFolder, startupMetrics)
    try {
      sourceFolder.setTracker(tracker) // =
    } catch (error) {
      sourceFolder.logger.info(
        `Failed to install SourceFolderTracker for ${sourceFolder.folderName}: ${getErrorMessage(error)}`,
      ),
        tracker.dispose()
      return
    }
    let vcsRepoDisposable = this._trackVcsRepo(sourceFolder, tracker.pathFilter)
    vcsRepoDisposable !== undefined && sourceFolder.addDisposable(vcsRepoDisposable)
    let fileEditsDisposable = this._trackFileEdits(sourceFolder)
    return (
      fileEditsDisposable !== undefined && sourceFolder.addDisposable(fileEditsDisposable),
      this._trackOpenDocuments(sourceFolder),
      await this._enumerateSourceFolder(sourceFolder, startupMetrics)
    )
  }
  async _enumerateSourceFolder(sourceFolder, startupMetrics) {
    let tracker = sourceFolder.tracker
    if (tracker === undefined) return
    let nextEntryTimestamp = this._pathMap.nextEntryTS,
      enumerationResult = await tracker.pathNotifier.enumeratePaths()
    if (!sourceFolder.stopped) // =
      return (
        startupMetrics?.charge("enumerate paths"),
        this._pathMap.purge(sourceFolder.folderId, nextEntryTimestamp),
        startupMetrics?.charge("purge stale PathMap entries"),
        enumerationResult
      )
  }
  async _createSourceFolderTracker(sourceFolder, startupMetrics) {
    let disposables = new DisposableCollection(),
      pathFilter = await buildIgnoreStack(
        St.Uri.file(sourceFolder.folderRoot),
        St.Uri.file(sourceFolder.repoRoot),
        new fC(WorkspaceManager.ignoreSources(sourceFolder.folderRoot)),
        this._fileExtensions,
      )
    startupMetrics?.charge("create PathFilter")
    let pathNotifier = this._createPathNotifier(sourceFolder, pathFilter)
    if (
      (disposables.add(pathNotifier),
      startupMetrics?.charge("create PathNotifier"),
      this._configListener.config.enableDebugFeatures)
    ) {
      let debugPathNotifier = new AN(St.Uri.file(sourceFolder.repoRoot), sourceFolder.folderName, sourceFolder.folderId)
      if (
        (disposables.add(debugPathNotifier),
        debugPathNotifier.listenForChanges(),
        this._vcsWatcher === undefined && sourceFolder.vcsDetails !== undefined)
      ) {
        let debugVcsWatcher = new gw(sourceFolder.folderName, sourceFolder.folderId, sourceFolder.vcsDetails)
        disposables.add(debugVcsWatcher), debugVcsWatcher.listenForChanges()
      }
    }
    return new M9(pathFilter, pathNotifier, disposables)
  }
  _createPathNotifier(sourceFolder, pathFilter) {
    let pathNotifier = new P2(sourceFolder.folderName, sourceFolder.folderRoot, sourceFolder.repoRoot, pathFilter, sourceFolder.workspaceFolder)
    return (
      pathNotifier.addDisposables(
        pathNotifier.onDidFindPath((event) => {
          this._handlePathFound(sourceFolder, event.relPath, event.fileType, event.acceptance)
        }),
        pathNotifier.onDidCreatePath((event) => {
          this._handlePathCreated(sourceFolder, event.relPath, event.fileType, event.acceptance)
        }),
        pathNotifier.onDidChangePath((event) => {
          event.fileType === "File" &&
            this._handleFileChanged(sourceFolder, event.relPath, event.acceptance)
        }),
        pathNotifier.onDidDeletePath((event) => {
          this._handlePathDeleted(sourceFolder, event)
        }),
      ),
      pathNotifier
    )
  }
  _trackFileEdits(sourceFolder) {
    if ( // =
      (sourceFolder.logger.debug(`_trackFileEdits was called on ${sourceFolder.folderName}`),
      this._fileEditManager === undefined)
    ) {
      sourceFolder.logger.debug("_fileEditManager is undefined")
      return
    }
    return (
      sourceFolder.logger.debug("_fileEditManager tracking the folder"),
      this._fileEditManager.startTracking(sourceFolder.folderId, sourceFolder.folderName, {
        directory: this._computeCacheDirPath(sourceFolder.folderRoot),
      })
    )
  }
  _trackVcsRepo(sourceFolder, pathFilter) {
    if ( // =
      (sourceFolder.logger.debug(`_trackVcsRepo was called on ${sourceFolder.folderName}`),
      this._vcsWatcher === undefined)
    ) {
      sourceFolder.logger.debug("_vcsWatcher is undefined")
      return
    }
    let i = sourceFolder.vcsDetails
    if (i === undefined) {
      sourceFolder.logger.debug("vcsDetails is undefined")
      return
    }
    if (!Xy(T9(i.root), sourceFolder.repoRoot)) {
      sourceFolder.logger.info(
        `Not creating VCSRepoWatcher: vcs root ${getPathFromUri(i.root)} !== repo root ${sourceFolder.repoRoot}`,
      )
      return
    }
    return (
      sourceFolder.logger.debug("_vcsWatcher tracking the folder"),
      this._vcsWatcher.startTracking(
        sourceFolder.folderName,
        sourceFolder.folderId,
        i,
        new Xm.FileChangeWatcherImpl(i.root, this.onDidChangeFile),
        new Xm.BlobNameRetrieverImpl(
          sourceFolder.repoRoot,
          this,
          this._blobNameCalculator,
        ),
        new Xm.FileUtilsImpl(pathFilter),
      )
    )
  }
  async _findRepoRoot(folderPath) {
    let repoRoot
    return (
      (repoRoot = await hM(folderPath, WorkspaceManager.augmentRootName)),
      repoRoot === undefined && (repoRoot = (await ox(folderPath))?.root),
      repoRoot !== undefined ? [T9(repoRoot), true] : [folderPath, false]
    )
  }
  _trackOpenDocuments(sourceFolder) {
    let trackedPaths = this._openFileManager.getTrackedPaths(sourceFolder.folderId)
    for (let path of trackedPaths) // =
      sourceFolder.acceptsPath(path) || this._openFileManager.stopTracking(sourceFolder.folderId, path)
    St.workspace.textDocuments.forEach((document) => {
      this._trackDocument(sourceFolder, document) !== undefined &&
        this._fileEditManager?.addInitialDocument({
          folderId: sourceFolder.folderId,
          relPath: sourceFolder.relativePathName(document.uri.fsPath),
          document: document,
        })
    }),
      St.workspace.notebookDocuments.forEach((document) => { // =
        this._trackDocument(sourceFolder, document)
      })
  }
  _trackDocument(sourceFolder, document) {
    let documentPath = getPathIfSupported(document.uri)
    if (documentPath === undefined) return
    let relativePath = sourceFolder.relativePathName(documentPath)
    if (relativePath === undefined || !sourceFolder.acceptsPath(relativePath)) return
    let blobName = this._pathMap.getBlobName(sourceFolder.folderId, relativePath)
    return (
      this._openFileManager.addOpenedDocument(
        { folderId: sourceFolder.folderId, relPath: relativePath, document: document },
        blobName,
      ),
      relativePath
    )
  }
  _stopTracking(trackedFolder) {
    if (trackedFolder.sourceFolder === undefined) {
      let cancellationSource = trackedFolder.cancel
      cancellationSource.cancel(),
        cancellationSource.dispose(),
        trackedFolder.logger.info("Cancelled in-progress tracking of source folder")
    } else {
      let sourceFolder = trackedFolder.sourceFolder
      ;(trackedFolder.sourceFolder = undefined),
        sourceFolder.dispose(),
        trackedFolder.logger.info("Stopped tracking source folder")
    }
    this._folderSyncedEmitter.fire(), this._folderEnumeratedEmitter.fire()
  }
  translateRange(absPath, startPosition, endPosition) {
    let resolvedPath = this._resolveAbsPath(absPath.absPath)
    if (resolvedPath === undefined) return
    let [sourceFolder, relativePath] = resolvedPath
    return this._openFileManager.translateRange(sourceFolder.folderId, relativePath, startPosition, endPosition)
  }
  getContext() {
    if (this._openFileManager === undefined || this._pathMap === undefined)
      return IndexingContext.empty()
    let recencySummary = this._openFileManager.getRecencySummary(
        this._completionServer.completionParams.chunkSize,
      ),
      blobNames = new Set(),
      blobNameCounts = new Map(),
      folderRootMap = new Map()
    for (let [folderId, folderMap] of recencySummary.folderMap) {
      let repoRoot = this._pathMap.getRepoRoot(folderId)
      repoRoot !== undefined && folderRootMap.set(repoRoot, folderMap)
      for (let [relativePath, blobName] of folderMap) {
        blobNames.add(blobName)
        let count = this._pathMap.getBlobName(folderId, relativePath)
        count !== undefined && count !== blobName && blobNameCounts.set(count, (blobNameCounts.get(count) ?? 0) + 1)
      }
    }
    let implicitBlobNames = new Set()
    for (let [blobName, count] of blobNameCounts)
      blobNames.has(blobName) || (count === this._pathMap.getUniquePathCount(blobName) && implicitBlobNames.add(blobName))
    let recentChunks = new Array()
    for (let chunk of recencySummary.recentChunks) {
      let repoRoot = this._pathMap.getRepoRoot(chunk.folderId)
      repoRoot !== undefined &&
        recentChunks.push({
          seq: chunk.seq,
          uploaded: chunk.uploaded,
          repoRoot: repoRoot,
          pathName: chunk.pathName,
          blobName: chunk.blobName,
          text: chunk.text,
          origStart: chunk.origStart,
          origLength: chunk.origLength,
          expectedBlobName: chunk.expectedBlobName,
        })
    }
    let editEvents = [],
      indexedBlobs = []
    if (this._configListener.config.openFileManager.v2Enabled) {
      let allEditEvents = this._openFileManager.getAllEditEvents()
      for (let folderEvents of allEditEvents.values()) editEvents.push(...folderEvents)
      let allIndexedBlobs = this._openFileManager.getAllPathToIndexedBlob()
      indexedBlobs = []
      for (let folderBlobs of allIndexedBlobs.values()) for (let blob of folderBlobs.values()) indexedBlobs.push(blob)
    }
    let blobsCheckpointManager = this._blobsCheckpointManager,
      useCheckpointManager = blobsCheckpointManager !== undefined && this._useCheckpointManagerContext,
      validateCheckpointManager = useCheckpointManager && this._validateCheckpointManagerContext,
      context
    if (!useCheckpointManager || validateCheckpointManager) {
      let allBlobNames = new Set(blobNames)
      for (let [folderId, relativePath, fileType, acceptance, blobName] of this._pathMap.pathsWithBlobNames())
        recencySummary.folderMap.get(folderId)?.has(fileType) || allBlobNames.add(blobName)
      let blobNameArray = Array.from(allBlobNames),
        blobs = this._blobNamesToBlobs(blobNameArray)
      if (((context = new IndexingContext(blobs, recentChunks, folderRootMap, editEvents, indexedBlobs, this._lastChatResponse, blobNameArray)), !useCheckpointManager)) return context
    }
    let checkpointContext = blobsCheckpointManager.getContextAdjusted(blobNames, implicitBlobNames)
    return (
      context !== undefined &&
        (blobsCheckpointManager.validateMatching(context.blobs, checkpointContext) ||
          this._clientMetricsReporter.report({
            client_metric: "blob_context_mismatch",
            value: 1,
          })),
      new IndexingContext(checkpointContext, recentChunks, folderRootMap, editEvents, indexedBlobs, this._lastChatResponse)
    )
  }
  getContextWithBlobNames() {
    let context = this.getContext()
    return context.blobNames !== undefined // =
      ? context
      : { ...context, blobNames: this._blobsCheckpointManager.expandBlobs(context.blobs) }
  }
  recordChatReponse(response) {
    this._lastChatResponse = { seq: this._sequenceGenerator.next(), text: response }
  }
  _blobNamesToBlobs(blobNames) {
    return this._blobsCheckpointManager === undefined
      ? { checkpointId: undefined, addedBlobs: blobNames, deletedBlobs: [] }
      : this._blobsCheckpointManager.blobsPayload(blobNames)
  }
  handleUnknownBlobs(recencySummary, unknownBlobs) {
    if (unknownBlobs.length === 0) return
    let unknownBlobSet = new Set(unknownBlobs),
      blobPathPairs = new Array()
    for (let [folderId, folderMap] of recencySummary.trackedPaths)
      if (folderId !== undefined)
        for (let [relativePath, blobName] of folderMap)
          unknownBlobSet.has(blobName) && (blobPathPairs.push([blobName, new QualifiedPathName(folderId, relativePath)]), unknownBlobSet.delete(blobName))
    for (let blobName of unknownBlobSet) {
      let pathName = this._pathMap.getAnyPathName(blobName)
      pathName !== undefined && blobPathPairs.push([blobName, pathName])
    }
    this._unknownBlobHandler.enqueue(blobPathPairs), this._vcsWatcher?.handleUnknownBlobs(unknownBlobs)
  }
  handleUnknownCheckpoint(requestId, checkpointId) {
    this._logger.info(`received checkpoint not found for request id ${requestId}`),
      this._blobsCheckpointManager.resetCheckpoint(),
      this._blobsCheckpointManager.updateBlob("")
  }
  notifyBlobMissing(pathName, blobName) {
    let pathInfo = this._pathMap.reportMissing(blobName)
    if (pathInfo !== undefined) {
      let sourceFolder = this._getSourceFolder(pathInfo.rootPath)
      if (sourceFolder !== undefined) {
        sourceFolder.diskFileManager.ingestPath(sourceFolder.folderId, pathName.relPath)
        return
      }
    }
    let sourceFolder = this._getSourceFolder(pathName.rootPath)
    sourceFolder !== undefined &&
      this._openFileManager.handleMissingBlob(sourceFolder.folderId, pathName.relPath, blobName)
  }
  _getSourceFolder(rootPath) {
    return this._trackedSourceFolders.get(rootPath)?.sourceFolder
  }
  resolvePathName(pathOrUri) {
    let absPath = typeof pathOrUri == "string" ? pathOrUri : getPathIfSupported(pathOrUri)
    if (absPath === undefined) return
    let resolvedPath = this._resolveAbsPath(absPath)
    if (resolvedPath === undefined) return
    let [sourceFolder, relativePath] = resolvedPath
    return new QualifiedPathName(sourceFolder.repoRoot, relativePath)
  }
  getFolderRoot(pathOrUri) {
    let absPath = typeof pathOrUri == "string" ? pathOrUri : getPathIfSupported(pathOrUri)
    if (absPath === undefined) return
    let resolvedPath = this._resolveAbsPath(absPath)
    if (resolvedPath === undefined) return
    let [sourceFolder, relativePath] = resolvedPath
    return sourceFolder.folderRoot
  }
  safeResolvePathName(pathOrUri) {
    let absPath = typeof pathOrUri == "string" ? pathOrUri : getPathIfSupported(pathOrUri)
    if (absPath === undefined) return
    let resolvedPath = this._resolveAbsPath(absPath)
    if (resolvedPath === undefined) return new QualifiedPathName("", absPath)
    let [sourceFolder, relativePath] = resolvedPath
    return new QualifiedPathName(sourceFolder.repoRoot, relativePath)
  }
  _resolveAbsPath(absPath) {
    for (let [folderRoot, trackedFolder] of this._trackedSourceFolders) {
      if (trackedFolder.sourceFolder === undefined) continue
      let relativePath = trackedFolder.sourceFolder.relativePathName(absPath)
      if (relativePath !== undefined) return [trackedFolder.sourceFolder, relativePath]
    }
  }
  hasFile(pathName) {
    let [sourceFolder, relativePath] = this._resolveAbsPath(pathName.absPath) ?? [undefined, undefined]
    return sourceFolder === undefined || relativePath === undefined
      ? false
      : this._pathMap.hasFile(sourceFolder.folderId, pathName.relPath)
  }
  getBlobName(pathName) {
    let [sourceFolder, relativePath] = this._resolveAbsPath(pathName.absPath) ?? [undefined, undefined]
    if (!(sourceFolder === undefined || relativePath === undefined))
      return (
        this._openFileManager.getBlobName(sourceFolder.folderId, pathName.relPath) ??
        this._pathMap.getBlobName(sourceFolder.folderId, pathName.relPath)
      )
  }
  getAllPathNames(blobName) {
    return this._pathMap.getAllPathNames(blobName)
  }
  getAllQualifiedPathInfos(blobName) {
    return this._pathMap.getAllQualifiedPathInfos(blobName)
  }
  getAllQualifiedPathNames(blobName) {
    return this._pathMap.getAllQualifiedPathNames(blobName)
  }
  getAllPathInfo(blobName) {
    return this._pathMap.getAllPathInfo(blobName)
  }
  _handlePathFound(sourceFolder, relativePath, fileType, acceptance) {
    let folderId = sourceFolder.folderId
    this._pathMap.insert(folderId, relativePath, fileType, acceptance),
      fileType === "File" && acceptance.accepted && sourceFolder.diskFileManager.ingestPath(folderId, relativePath)
  }
  _handlePathCreated(sourceFolder, relativePath, fileType, acceptance) {
    let folderId = sourceFolder.folderId
    if ((this._pathMap.insert(folderId, relativePath, fileType, acceptance), !!acceptance.accepted)) {
      if (fileType === "File")
        sourceFolder.diskFileManager.ingestPath(sourceFolder.folderId, relativePath),
          this._emitFileNotification(folderId, relativePath, "disk")
      else if (fileType === "Directory") {
        let pathFilter = sourceFolder.tracker?.pathFilter
        if (pathFilter === undefined) return
        sourceFolder.enqueueSerializedOperation(() =>
          this._handleDirectoryCreated(sourceFolder, relativePath, pathFilter),
        )
      }
    }
  }
  _handleFileChanged(sourceFolder, relativePath, acceptance) {
    let folderId = sourceFolder.folderId
    this._pathMap.insert(folderId, relativePath, "File", acceptance),
      acceptance.accepted &&
        (sourceFolder.diskFileManager.ingestPath(folderId, relativePath),
        this._emitFileNotification(folderId, relativePath, "disk"))
  }
  _handlePathDeleted(sourceFolder, relativePath) {
    let folderId = sourceFolder.folderId,
      pathInfo = this._pathMap.getPathInfo(folderId, relativePath)
    if (pathInfo === undefined) return
    this._deletePath(sourceFolder.folderId, relativePath)
    let [fileType, acceptance] = pathInfo
    if (!acceptance.accepted) return
    fileType === "Directory"
      ? this._handleDirectoryRemoved(sourceFolder, relativePath)
      : fileType === "File" && this._emitFileNotification(folderId, relativePath, "disk")
    let qualifiedPathName = new QualifiedPathName(sourceFolder.folderRoot, relativePath)
    this._fileDeletedEmitter.fire({
      folderId: folderId,
      relPath: relativePath,
      qualifiedPathName: qualifiedPathName,
    })
  }
  _deletePath(folderId, relativePath) {
    this._pathMap.remove(folderId, relativePath)
  }
  async _handleDirectoryCreated(sourceFolder, relativePath, pathFilter) {
    sourceFolder.logger.info(`Directory created: ${relativePath}`)
    let baseUri = St.Uri.file(sourceFolder.repoRoot),
      directoryEnumerator = new gC(sourceFolder.folderName, St.Uri.joinPath(baseUri, relativePath), baseUri, pathFilter)
    for await (let [folderId, relPath, fileType, acceptance] of directoryEnumerator) this._handlePathFound(sourceFolder, relPath, fileType, acceptance)
  }
  _handleDirectoryRemoved(sourceFolder, relativePath) {
    sourceFolder.logger.info(`Directory removed: ${relativePath}`)
    let folderId = sourceFolder.folderId,
      pathsToRemove = new Array()
    for (let [path] of this._pathMap.pathsInFolder(folderId))
      Zh(relativePath, path) !== undefined && pathsToRemove.push(path)
    for (let path of pathsToRemove) this._deletePath(folderId, path)
  }
  _notifyActiveEditorChanged(editor) {
    let document = editor?.document,
      pathInfo = this._uriToPathInfo(document?.uri)
    if (pathInfo === undefined) {
      this._openFileManager.loseFocus()
      return
    }
    let [folderId, relativePath] = pathInfo,
      blobName = this._pathMap.getBlobName(folderId, relativePath)
    this._openFileManager.addOpenedDocument(
      { folderId: folderId, relPath: relativePath, document: document },
      blobName,
    )
  }
  _notifyTextDocumentChanged(event) {
    let pathInfo = this._uriToPathInfo(event.document.uri)
    if (pathInfo === undefined) return
    let [folderId, relativePath] = pathInfo
    this._openFileManager.handleChangedDocument({
      folderId: folderId,
      relPath: relativePath,
      event: event,
    }),
      this._emitFileNotification(folderId, relativePath, "buffer"),
      this._textDocumentChangedEmitter.fire({
        folderId: folderId,
        relPath: relativePath,
        event: event,
      })
  }
  _notifyTextDocumentOpened(document) {
    let pathInfo = this._uriToPathInfo(document.uri)
    if (pathInfo === undefined) return
    let [folderId, relativePath] = pathInfo
    this._textDocumentOpenedEmitter.fire({
      folderId: folderId,
      relPath: relativePath,
      document: document,
    })
  }
  _notifyTextDocumentClosed(document) {
    let pathInfo = this._uriToPathInfo(document.uri)
    if (pathInfo === undefined) return
    let [folderId, relativePath] = pathInfo
    this._textDocumentClosedEmitter.fire({
      folderId: folderId,
      relPath: relativePath,
      document: document,
    })
  }
  _notifyNotebookDocumentChanged(event) {
    let pathInfo = this._uriToPathInfo(event.notebook.uri)
    if (pathInfo === undefined) return
    let [folderId, relativePath] = pathInfo
    this._openFileManager.handleChangedDocument({
      folderId: folderId,
      relPath: relativePath,
      event: event,
    }),
      this._emitFileNotification(folderId, relativePath, "buffer")
  }
  _uriToPathInfo(uri) {
    if (uri === undefined) return
    let absPath = getPathIfSupported(uri)
    if (absPath === undefined) return
    let resolvedPath = this._resolveAbsPath(absPath)
    if (resolvedPath === undefined) return
    let [sourceFolder, relativePath] = resolvedPath
    if (sourceFolder.acceptsPath(relativePath)) return [sourceFolder.folderId, relativePath]
  }
  _notifyWillRenameFile(event) {
    event.files.forEach((fileRename) => {
      let oldPathInfo = this._resolveAbsPath(fileRename.oldUri.fsPath),
        newPathInfo = this._resolveAbsPath(fileRename.newUri.fsPath)
      if (oldPathInfo === undefined || newPathInfo === undefined) return
      let [oldSourceFolder, oldRelativePath] = oldPathInfo,
        [newSourceFolder, newRelativePath] = newPathInfo
      if (oldSourceFolder.folderId !== newSourceFolder.folderId) {
        this._logger.debug(
          `[WARN] Rename should not cause a file to move between source folders.     old file: ${oldPathInfo[1]}     new file: ${newPathInfo[1]}    old source folder: ${oldSourceFolder.folderName}     new source folder: ${newSourceFolder.folderName}`,
        )
        return
      }
      this._fileWillRenameEmitter.fire({
        folderId: oldSourceFolder.folderId,
        oldRelPath: oldRelativePath,
        newRelPath: newRelativePath,
        type: getFileStats(fileRename.oldUri.fsPath).type,
      })
    })
  }
  _notifyDidRenameFile(event) {
    event.files.forEach((fileRename) => {
      let oldPathInfo = this._resolveAbsPath(fileRename.oldUri.fsPath),
        newPathInfo = this._resolveAbsPath(fileRename.newUri.fsPath)
      if (oldPathInfo === undefined || newPathInfo === undefined) return
      let [oldSourceFolder, oldRelativePath] = oldPathInfo,
        [newSourceFolder, newRelativePath] = newPathInfo,
        oldQualifiedPathName = new QualifiedPathName(oldSourceFolder.folderRoot, oldRelativePath),
        newQualifiedPathName = new QualifiedPathName(newSourceFolder.folderRoot, newRelativePath)
      this._fileDidMoveEmitter.fire({
        oldQualifiedPathName: oldQualifiedPathName,
        newQualifiedPathName: newQualifiedPathName,
      })
    })
  }
  _notifyDocumentClosed(document) {
    let uri = document.uri,
      absPath = getPathIfSupported(uri)
    if (absPath === undefined) return
    let resolvedPath = this._resolveAbsPath(absPath)
    if (resolvedPath === undefined) return
    let [sourceFolder, relativePath] = resolvedPath
    this._openFileManager.handleClosedDocument({
      folderId: sourceFolder.folderId,
      relPath: relativePath,
      document: document,
    })
  }
  _emitFileNotification(folderId, relativePath, origin) {
    this._fileChangedEmitter.fire({ folderId: folderId, relPath: relativePath, origin: origin })
  }
  getTabSwitchEvents() {
    return this._tabWatcher?.getTabSwitchEvents()
  }
  getFileEditEvents(folderRoot = undefined) {
    if (this._fileEditManager === undefined) return []
    let folderId
    if (folderRoot !== undefined) {
      let sourceFolder = this._trackedSourceFolders.get(folderRoot)?.sourceFolder
      if (sourceFolder === undefined) return []
      folderId = sourceFolder.folderId
    } else folderId = this._fileEditManager.findFolderIdWithMostRecentChanges()
    return folderId === -1 ? [] : this._fileEditManager.findEventsForFolder(folderId)
  }
  getMostRecentlyChangedFolderRoot() {
    if (this._fileEditManager === undefined) return
    let folderId = this._fileEditManager.findFolderIdWithMostRecentChanges()
    if (folderId !== -1) {
      for (let [folderRoot, trackedFolder] of this._trackedSourceFolders)
        if (trackedFolder.sourceFolder?.folderId === folderId) return folderRoot
    }
  }
  getBestFolderRoot() {
    return St.window.activeTextEditor
      ? this.getFolderRoot(St.window.activeTextEditor?.document.uri)
      : this.getMostRecentlyChangedFolderRoot()
  }
  findBestWorkspaceRootMatch(relativePath) {
    let pathParts = wG(relativePath).slice(0, -1),
      currentPath = "",
      bestMatch
    for (let part of pathParts) {
      currentPath = joinPaths(currentPath, part)
      let matches = this.getAllQualifiedPathInfos(currentPath).filter((f) => f.isAccepted)
      if (matches.length === 0) break
      bestMatch = matches[0]
    }
    if (bestMatch !== undefined) return bestMatch
    let recentFolderRoot = this.getMostRecentlyChangedFolderRoot(),
      repoRoot = recentFolderRoot ? this.getRepoRootForFolderRoot(recentFolderRoot) : undefined
    if (repoRoot !== undefined)
      return {
        qualifiedPathName: new QualifiedPathName(repoRoot, ""),
        fileType: "Directory",
        isAccepted: false,
      }
    let sourceFolders = this.listSourceFolders().filter(
      (folder) => folder.type === 0 && folder.syncingEnabled,
    )
    if (sourceFolders.length > 0)
      return {
        qualifiedPathName: new QualifiedPathName(sourceFolders[0].folderRoot, ""),
        fileType: "Directory",
        isAccepted: false,
      }
  }
  getRepoRootForFolderRoot(folderRoot) {
    return this._trackedSourceFolders.get(folderRoot)?.sourceFolder?.repoRoot
  }
  getVCSWatchedFolderIds() {
    return this?._vcsWatcher?.getWatchedFolderIds() ?? []
  }
  async getVCSChange() {
    return this._vcsWatcher === undefined
      ? { commits: [], workingDirectory: [] }
      : await this._vcsWatcher.getChanges()
  }
  getEnableCompletionFileEditEvents() {
    return this._featureFlagManager.currentFlags.enableCompletionFileEditEvents
  }
  async updateStatusTrace(trace) {
    trace.addSection("Syncing permission parameters"),
      trace.addValue(
        "enableFileLimitsForSyncingPermission",
        this.enableFileLimitsForSyncingPermission,
      ),
      trace.addValue("maxTrackableFiles", this.maxTrackableFiles),
      trace.addValue(
        "maxTrackableFilesWithoutPermission",
        this.maxTrackableFilesWithoutPermission,
      ),
      trace.addValue(
        "minUploadedFractionWithoutPermission",
        this.minUploadedFractionWithoutPermission,
      ),
      trace.addValue(
        "minUploadedFractionWithoutPermission as a percentage",
        this.minUploadedFractionWithoutPermission * 100,
      ),
      trace.addValue("verifyFolderIsSourceRepo", this.verifyFolderIsSourceRepo),
      trace.addValue(
        "refuseToSyncHomeDirectories",
        this.refuseToSyncHomeDirectories,
      )
    let folderCount = 0
    for (let [folderRoot, folderInfo] of this._registeredSourceFolders) {
      if (
        (folderCount++,
        trace.addSection(`Source folder: ${folderRoot}`),
        folderInfo.folderType === 0
          ? trace.addValue("Folder type", "vscode workspace folder")
          : trace.addValue("Folder type", "external folder"),
        folderInfo.containingFolderRoot !== undefined)
      ) {
        trace.addValue(
          "Not tracked: nested folder. Containing folder",
          folderInfo.containingFolderRoot,
        )
        continue
      }
      if (folderInfo.isHomeDir) {
        trace.addLine("Not tracked: home directory")
        continue
      }
      if (
        folderInfo.folderQualification !== undefined &&
        !folderInfo.folderQualification.trackable
      ) {
        trace.addLine("Not tracked: folder is too large")
        continue
      }
      let trackingStatus = getFolderStatus(folderInfo)
      if (trackingStatus === "permission denied") {
        trace.addLine("Not tracked: syncing permission denied")
        continue
      }
      if (trackingStatus === "permission needed") {
        trace.addLine("Not tracked: syncing permission not yet granted")
        continue
      }
      let sourceFolder = this._trackedSourceFolders.get(folderRoot)?.sourceFolder
      if (sourceFolder === undefined) {
        trace.addLine("Tracking in progress")
        continue
      }
      trace.addValue("Folder root", folderRoot),
        trace.addValue("Repo root", sourceFolder.repoRoot),
        trace.addValue("Mtime cache dir", sourceFolder.cacheDirPath),
        sourceFolder.diskFileManager.itemsInFlight === 0 ||
          trace.addValue("Source folder startup", "in progress"),
        trace.addValue("Source folder startup", "complete"),
        trace.addValue("Tracked files", this._pathMap.trackedFileCount(sourceFolder.folderId)),
        trace.addValue("Syncing backlog size", sourceFolder.diskFileManager.itemsInFlight)
    }
    if (
      (folderCount === 0 && trace.addSection("Source folders: no open source folders"),
      trace.addSection("Workspace status"),
      !this.initialFoldersSynced)
    )
      trace.addValue("Workspace startup", "in progress")
    else {
      trace.addValue("Workspace startup", "complete")
      let context = this.getContextWithBlobNames()
      trace.addValue("Blobs in context", context.blobNames.length)
      let savePoint = trace.savePoint()
      try {
        let unknownBlobCount = 0
        for (let index = 0; index < context.blobNames.length; index += 1e3) {
          trace.rollback(savePoint),
            trace.addLine(`Verifying blob names... ${index} / ${context.blobNames.length} `),
            trace.publish()
          let response = await this._apiServer.findMissing(
            context.blobNames.slice(index, index + 1e3),
          )
          unknownBlobCount += response.unknownBlobNames.length
        }
        trace.rollback(savePoint), trace.addValue("Unknown blob names", unknownBlobCount)
      } catch (error) {
        trace.rollback(savePoint), trace.addError(`Unable to verify blob names: ${error}`)
      }
    }
    folderCount === 0 && trace.addLine("No source folders in workspace")
    let checkpointManager = this._blobsCheckpointManager
    if (checkpointManager !== undefined) {
      let checkpointContext = checkpointManager.getContext(),
        checkpointedBlobCount = checkpointManager.getCheckpointedBlobNames().length
      trace.addValue("Current checkpoint", checkpointContext.checkpointId),
        trace.addValue("Blobs in current checkpoint", checkpointedBlobCount),
        trace.addValue("Added blobs not in checkpoint", checkpointContext.addedBlobs.length),
        trace.addValue("Deleted blobs not in checkpoint", checkpointContext.deletedBlobs.length)
    }
  }
  _reportSourceFolderStartup(logger, sourceFolder, pathMapMetrics, startupTime) {
    let diskFileManagerMetrics = sourceFolder.diskFileManager.metrics
    logger.info("Tracking enabled"),
      logger.info(startupTime.format()),
      logger.info(diskFileManagerMetrics.format()),
      logger.info(pathMapMetrics.format())
  }
  _reportWorkspaceStartup(startupTime) {
    this._logger.info(`Workspace startup complete in ${startupTime} ms`)
  }
  trackedSourceFolderNames() {
    return Array.from(this._registeredSourceFolders)
      .filter(([folderRoot, folderInfo]) => getFolderStatus(folderInfo) === "trackable")
      .map(([folderRoot, folderInfo]) => ({ folderRoot: folderRoot }))
  }
  getSourceFoldersReportDetails() {
    let sourceFolders = this.listSourceFolders(),
      folderDetails = (0, nc.mapValues)(
        (0, nc.groupBy)(sourceFolders, (folder) => wv[folder.type]),
        (folders) => folders.length,
      ),
      repoRootCountByType = (0, nc.mapValues)(
        (0, nc.groupBy)(sourceFolders, (folder) => wv[folder.type]),
        (folders) =>
          (0, nc.uniq)(
            folders.map((folder) => this.getRepoRootForFolderRoot(folder.folderRoot)),
          ).length,
      ),
      isWorkspaceFolder = (folder) => folder.type === 0 || folder.type === 1,
      isNestedFolder = (folder) => folder.type === 2 || folder.type === 3,
      isUntrackedFolder = (folder) => folder.type === 4,
      trackedFileCounts = sourceFolders.filter((folder) => isWorkspaceFolder(folder)).map((folder) => folder.trackedFileCount),
      nestedFolderCount = sourceFolders.filter((folder) => isNestedFolder(folder)).length,
      untrackedCountByReason = (0, nc.mapValues)(
        (0, nc.groupBy)(
          sourceFolders.filter((folder) => isUntrackedFolder(folder)),
          (folder) => folder.reason,
        ),
        (folders) => folders.length,
      )
    return {
      workspaceStorageUri: this._storageUriProvider.storageUri?.toString(),
      folderCountByType: folderDetails,
      repoRootCountByType: repoRootCountByType,
      trackedFileCount: trackedFileCounts,
      nestedFolderCount: nestedFolderCount,
      untrackedCountByReason: untrackedCountByReason,
    }
  }
  listSourceFolders() {
    if (this._syncingPermissionTracker.syncingPermissionDenied) return []
    let syncingDisabled = this.syncingEnabledState === "disabled",
      sourceFolders = new Array()
    for (let [folderRoot, folderInfo] of this._registeredSourceFolders) {
      if (folderInfo.containingFolderRoot !== undefined) {
        let folderType = folderInfo.folderType === 0 ? 2 : 3
        sourceFolders.push({
          type: folderType,
          name: folderInfo.folderName,
          syncingEnabled: false,
          folderRoot: folderRoot,
          containingFolderRoot: folderInfo.containingFolderRoot,
        })
        continue
      }
      if (folderInfo.isHomeDir) {
        sourceFolders.push({
          type: 4,
          name: folderInfo.folderName,
          syncingEnabled: false,
          folderRoot: folderRoot,
          reason: "home directory",
        })
        continue
      }
      if (
        folderInfo.folderQualification !== undefined &&
        !folderInfo.folderQualification.trackable
      ) {
        sourceFolders.push({
          type: 4,
          name: folderInfo.folderName,
          syncingEnabled: false,
          folderRoot: folderRoot,
          reason: "too large",
        })
        continue
      }
      if (folderInfo.syncingPermission === "denied") {
        sourceFolders.push({
          type: 4,
          name: folderInfo.folderName,
          syncingEnabled: false,
          folderRoot: folderRoot,
          reason: "permission not granted",
        })
        continue
      }
      let folderType = folderInfo.folderType === 0 ? 0 : 1,
        sourceFolder = this._trackedSourceFolders.get(folderRoot)?.sourceFolder
      if (!sourceFolder?.initialEnumerationComplete) {
        let syncingEnabled = !syncingDisabled && folderInfo.syncingPermission === "granted"
        sourceFolders.push({
          name: folderInfo.folderName,
          type: folderType,
          folderRoot: folderRoot,
          syncingEnabled: syncingEnabled,
          trackedFileCount: 0,
          containsExcludedItems: false,
          containsUnindexedItems: false,
          enumerationState: 0,
        })
        continue
      }
      let syncingEnabled = !syncingDisabled && folderInfo.syncingPermission === "granted",
        containsExcludedItems = false,
        containsUnindexedItems = false
      for (let [path, fileType, isIncluded, isIndexed] of this._pathMap.pathsInFolder(sourceFolder.folderId))
        isIncluded || (containsExcludedItems = true), fileType === "File" && isIncluded && !isIndexed && (containsUnindexedItems = true)
      sourceFolders.push({
        name: folderInfo.folderName,
        type: folderType,
        folderRoot: folderRoot,
        syncingEnabled: syncingEnabled,
        trackedFileCount: this._pathMap.trackedFileCount(sourceFolder.folderId),
        containsExcludedItems: containsExcludedItems,
        containsUnindexedItems: containsUnindexedItems,
        enumerationState: 1,
      })
    }
    return sourceFolders
  }
  listChildren(folderRoot, relativePath) {
    if (this._syncingPermissionTracker.syncingPermissionDenied) return []
    let sourceFolder = this._trackedSourceFolders.get(folderRoot)?.sourceFolder
    if (sourceFolder === undefined) throw new $F()
    if (!sourceFolder.initialEnumerationComplete) throw new YF()
    let absolutePath = joinPaths(folderRoot, relativePath),
      normalizedPath = ql(sourceFolder.repoRoot, absolutePath),
      fileTypeMap = new Map(),
      fileCountMap = new Map(),
      excludedDirs = new Set(),
      unindexedDirs = new Set(),
      folderId = sourceFolder.folderId
    for (let [path, fileType, isIncluded, isIndexed, exclusionReason] of this._pathMap.pathsInFolder(folderId)) {
      let relativePart = Zh(normalizedPath, path)
      if (relativePart === undefined) continue
      let pathParts = wG(relativePart)
      if (!(pathParts.length === 0 || pathParts[0].length === 0))
        if (pathParts.length === 1)
          fileTypeMap.set(pathParts[0], { type: fileType, included: isIncluded, indexed: isIndexed, reason: exclusionReason })
        else {
          let dirName = pathParts[0]
          if (!isIncluded) excludedDirs.add(dirName)
          else if (fileType === "File") {
            let fileCount = fileCountMap.get(dirName) ?? 0
            fileCountMap.set(dirName, fileCount + 1), isIndexed || unindexedDirs.add(dirName)
          }
        }
    }
    return Array.from(fileTypeMap.entries()).map(([name, info]) => {
      let baseInfo = {
        name: name,
        folderRoot: folderRoot,
        relPath: joinPaths(relativePath, name),
        included: info.included,
        reason: info.reason,
      }
      return info.type === "File"
        ? { ...baseInfo, type: "File", indexed: info.indexed }
        : info.type === "Directory"
          ? {
              ...baseInfo,
              type: "Directory",
              trackedFileCount: fileCountMap.get(name) ?? 0,
              containsExcludedItems: excludedDirs.has(name),
              containsUnindexedItems: unindexedDirs.has(name),
            }
          : { ...baseInfo, type: "Other" }
    })
  }
  clearFileEdits() {
    this._fileEditManager?.clearAll({ clearLastKnown: false })
  }
  unitTestOnlyGetRepoRoot(folderRoot) {
    let trackedFolder = this._trackedSourceFolders.get(folderRoot)
    if (trackedFolder !== undefined) return trackedFolder.sourceFolder?.repoRoot
  }
  unitTestOnlySourceFolderBacklog(folderRoot) {
    let trackedFolder = this._trackedSourceFolders.get(folderRoot)
    if (trackedFolder === undefined) return
    let sourceFolder = trackedFolder.sourceFolder
    if (sourceFolder !== undefined && sourceFolder.initialEnumerationComplete)
      return sourceFolder.diskFileManager.itemsInFlight
  }
}
var KIe = q(require("vscode"))
var WorkspaceStateManager = class extends DisposableContainer {
  constructor(actionsModel, workspaceManager) {
    super()
    this.actionsModel = actionsModel
    this.workspaceManager = workspaceManager
    this.setInitializing(),
      this.addDisposable(workspaceManager),
      this.checkWorkspaceSelected(),
      this.checkWorkspacePopulated()
  }
  checkWorkspaceSelected() {
    !!KIe.workspace.workspaceFolders?.length
      ? this._setWorkspaceSelected()
      : this._setWorkspaceNotSelected()
  }
  async checkWorkspacePopulated() {
    if (
      (await this.workspaceManager.awaitInitialFoldersEnumerated(),
      this._anyFilesExist())
    ) {
      this._setWorkspacePopulated()
      return
    }
    for (this._setWorkspaceEmpty(); !this._anyFilesExist(); )
      await createDisposablePromise(this.workspaceManager.onDidChangeSyncingProgress)
    this._setWorkspacePopulated()
  }
  _anyFilesExist() {
    return !!this.workspaceManager
      .getSyncingProgress()
      .some(
        (folderProgress) =>
          folderProgress.progress?.trackedFiles !== undefined && folderProgress.progress.trackedFiles > 0,
      )
  }
  setInitializing() {
    this.actionsModel.setSystemStateStatus(
      "workspacePopulated",
      "initializing",
    ),
      this.actionsModel.setSystemStateStatus(
        "workspaceSelected",
        "initializing",
      )
  }
  _setWorkspaceEmpty() {
    this.actionsModel.setSystemStateStatus("workspacePopulated", "incomplete")
  }
  _setWorkspacePopulated() {
    this.actionsModel.setSystemStateStatus("workspacePopulated", "complete")
  }
  _setWorkspaceSelected() {
    this.actionsModel.setSystemStateStatus("workspaceSelected", "complete")
  }
  _setWorkspaceNotSelected() {
    this.actionsModel.setSystemStateStatus("workspaceSelected", "incomplete")
  }
}
var AugmentExtension = class e extends DisposableContainer {
  constructor(extensionContext, globalState, augmentConfigListener, apiServer, auth, recentCompletions, recentInstructions, recentNextEditResults, recentChats, nextEditWebViewEvent, onExtensionUpdateEvent, mainPanelProvider, changeWebviewAppEvent, actionsModel, syncingEnabledTracker, chatExtensionEvent, onboardingSessionEventReporter, assetManager) {
    super()
    this._extensionContext = extensionContext
    this._globalState = globalState
    this._augmentConfigListener = augmentConfigListener
    this._apiServer = apiServer
    this._auth = auth
    this._recentCompletions = recentCompletions
    this._recentInstructions = recentInstructions
    this._recentNextEditResults = recentNextEditResults
    this._recentChats = recentChats
    this._nextEditWebViewEvent = nextEditWebViewEvent
    this._onExtensionUpdateEvent = onExtensionUpdateEvent
    this._mainPanelProvider = mainPanelProvider
    this._changeWebviewAppEvent = changeWebviewAppEvent
    this._actionsModel = actionsModel
    this._syncingEnabledTracker = syncingEnabledTracker
    this._chatExtensionEvent = chatExtensionEvent
    this._onboardingSessionEventReporter = onboardingSessionEventReporter
    this._assetManager = assetManager
    if (
      ((this._statusBar = new VN()),
      extensionContext.subscriptions.push(this._statusBar),
      (this.workTimer = new lN()),
      (this.featureFlagManager = new jk(
        {
          fetcher: this._fetchFeatureFlags.bind(this),
          refreshIntervalMSec: 30 * 60 * 1e3,
        },
        this._augmentConfigListener,
      )),
      (this._completionAcceptanceReporter = new eN(
        apiServer,
        this._onboardingSessionEventReporter,
      )),
      (this._codeEditReporter = new XQ(apiServer)),
      (this._nextEditResolutionReporter = new iN(apiServer)),
      (this._nextEditSessionEventReporter = new sN(apiServer)),
      (this.nextEditConfigManager = new NextEditConfigManager(
        this._augmentConfigListener,
        this.featureFlagManager,
        this._globalState,
      )),
      (this._clientMetricsReporter = new ClientMetricsReporter(apiServer)),
      (this._completionTimelineReporter = new tN(apiServer)),
      (this._extensionEventReporter = new ExtensionSessionEventReporter(apiServer)),
      (this.guidelinesWatcher = new ig(
        this._augmentConfigListener,
        this.featureFlagManager,
        this._clientMetricsReporter,
      )),
      (this._toolUseRequestEventReporter = new fI()),
      this.disposeOnDisable.push(this.guidelinesWatcher),
      this.addDisposable(new Ye.Disposable(() => this.disable())),
      (this._completionsModel = new CompletionsModel(
        this,
        this._augmentConfigListener,
        this._clientMetricsReporter,
      )),
      !eo("1.96.0"))
    )
      try {
        this._logger.info("Starting macCA"),
          (0, XIe.addToGlobalAgent)(),
          this._logger.info("macCa Done")
      } catch (B) {
        this._logger.error("Exception loading mac-ca certs:", B)
      }
  }
  static augmentRootName = ".augmentroot"
  static contentScheme = "augment"
  static displayStatusUri = Ye.Uri.from({
    scheme: this.contentScheme,
    path: "Augment Extension Status",
  })
  static modelConfigBackoffMsecMax = 3e4
  keybindingWatcher = undefined
  _completionServer = undefined
  workspaceManager = undefined
  syncingStatusReporter = undefined
  fuzzyFsSearcher = undefined
  fuzzySymbolSearcher = undefined
  _toolsModel = undefined
  get toolsModel() {
    return this._toolsModel
  }
  _toolConfigStore = undefined
  get toolConfigStore() {
    return this._toolConfigStore
  }
  _agentCheckpointManager = undefined
  guidelinesWatcher
  _statusBar
  _initState
  workTimer
  _enableCancel
  _defaultModel
  _modelInfo
  _blobNameCalculator
  _nextEditRequestManager
  _suggestionManager
  get modelInfo() {
    return this._modelInfo
  }
  userTier = "unknown"
  _availableModels = []
  _languages = []
  get languages() {
    return this._languages
  }
  featureFlagManager
  _onTextDocumentDidChange = new Ye.EventEmitter()
  _statusTrace
  _completionDisposables = []
  _completionAcceptanceReporter
  _codeEditReporter
  _nextEditResolutionReporter
  _nextEditSessionEventReporter
  nextEditConfigManager
  _clientMetricsReporter
  _completionTimelineReporter
  _extensionEventReporter
  _dataCollector
  _editorNextEdit
  _backgroundNextEdit
  _globalNextEdit
  _diagnosticsManager
  _nextEditVSCodeToWebviewMessage = new Ye.EventEmitter()
  _openChatHintManager
  _remoteWorkspaceResolver
  enabled = false
  _enableState
  disposeOnDisable = []
  _inlineCompletionProvider
  _completionsModel
  _logger = z("AugmentExtension")
  _chatModel
  _currentChatExtensionEventDisposable
  _toolUseRequestEventReporter
  get sessionId() {
    return this._apiServer.sessionId
  }
  get chatModel() {
    return this._chatModel
  }
  get editorNextEdit() {
    return this._editorNextEdit
  }
  get completionServer() {
    return this._completionServer
  }
  get completionsModel() {
    return this._completionsModel
  }
  get agentCheckpointManager() {
    return this._agentCheckpointManager
  }
  get enableInProgress() {
    return this._enableCancel !== undefined
  }
  get ready() {
    return this.enabled && !this.enableInProgress
  }
  async enable() {
    if (this.enabled || this.enableInProgress) return
    let cancellationTokenSource = new Ye.CancellationTokenSource()
    this._enableCancel = cancellationTokenSource
    try {
      await this._enable(cancellationTokenSource.token)
    } catch (error) {
      if (
        (this._logger.info(`Unable to enable extension: ${getErrorMessage(error)}`),
        process.env.JEST_WORKER_ID)
      )
        throw error
    } finally {
      cancellationTokenSource.dispose(), (this._enableCancel = undefined)
    }
  }
  _syncLastEnabledExtensionVersion() {
    if (this._extensionContext.extensionMode === Ye.ExtensionMode.Development)
      return false
    let currentVersion = this._extensionContext.extension.packageJSON.version
    return this._extensionVersion === currentVersion
      ? false
      : (this._globalState.update("lastEnabledExtensionVersion", currentVersion),
        this._onExtensionUpdateEvent.fire(),
        true)
  }
  get _extensionVersion() {
    return this._globalState.get("lastEnabledExtensionVersion") || ""
  }
  async _enable(cancellationToken) {
    ;(0, JIe.assert)(!this.enabled),
      this._initState?.dispose(),
      this._enableState?.dispose()
    let startTime = Date.now()
    if (
      (this.disposeOnDisable.push(
        new aN(this._clientMetricsReporter, this.workTimer, {
          periodMs: 100,
          debugThresholdMs: 50,
          infoThresholdMs: 2e3,
        }),
      ),
      this._auth.useOAuth)
    ) {
      if (!(await this._auth.getSession())) {
        this._enableState = this._statusBar.setState(iSe)
        return
      }
    } else {
      if (!this._augmentConfigListener.config.apiToken) {
        this._logger.warn("No API token is configured"),
          (this._enableState = this._statusBar.setState(oSe))
        return
      }
      if (!this._augmentConfigListener.config.completionURL) {
        this._logger.warn("No completion URL is configured"),
          (this._enableState = this._statusBar.setState(aSe))
        return
      }
    }
    let loadingStatus = this._statusBar.setState(lSe),
      modelConfig,
      modelsByName = new Map()
    try {
      if (((modelConfig = await this._getModelConfig(cancellationToken)), modelConfig.models.length === 0))
        throw new MQ()
      ;(this.userTier = modelConfig.userTier),
        Ye.commands.executeCommand(
          "setContext",
          "augment.userTier",
          this.userTier,
        ),
        (this._defaultModel = modelConfig.defaultModel),
        (this._languages = modelConfig.languages),
        (this._availableModels = modelConfig.models.map(
          (model) => `${model.name} - ${model.internalName}`,
        ))
      let selectedModelName = this._augmentConfigListener.config.modelName || modelConfig.defaultModel
      if (
        ((this._modelInfo = modelConfig.models.find(
          (model) =>
            [model.name, model.internalName].includes(selectedModelName) ||
            model.name === (0, jIe.createHash)("sha256").update(selectedModelName).digest("hex"),
        )),
        this._modelInfo === undefined)
      )
        throw new cw(selectedModelName)
      this.featureFlagManager.update(modelConfig.featureFlags)
      for (let model of modelConfig.models) modelsByName.set(model.name, model)
      this._initState?.dispose()
    } catch (error) {
      if (ApiError.isAPIErrorWithStatus(error, RequestStatus.unauthenticated)) {
        this._auth.useOAuth
          ? (this._enableState = this._statusBar.setState(cSe))
          : (this._enableState = this._statusBar.setState(uSe))
        return
      } else if (error instanceof InvalidCompletionUrlError) {
        this._enableState = this._statusBar.setState(dSe)
        return
      } else if (error instanceof Ye.CancellationError) return
      let errorMessage = getErrorMessage(error)
      throw (
        (this._logger.error(`Failed to get model config: ${errorMessage}`),
        (this._initState = this._statusBar.setState(g6)),
        error)
      )
    } finally {
      loadingStatus.dispose()
    }
    this.featureFlagManager.currentFlags.enableViewTextDocument &&
      (this._logger.debug("Enabling viewTextDocument background file scheme"),
      this.disposeOnDisable.push(uye()))
    let recentCompletionsTracker = new SyncingPermissionTracker(this._extensionContext.workspaceState)
    this.disposeOnDisable.push(recentCompletionsTracker),
      (this._completionServer = new DQ(
        this._apiServer,
        this._modelInfo.completionTimeoutMs,
        this._modelInfo.suggestedPrefixCharCount,
        this._modelInfo.suggestedSuffixCharCount,
      ))
    let maxUploadSizeBytes = this.featureFlagManager.currentFlags.maxUploadSizeBytes
    ;(this._blobNameCalculator = new HashCalculator(maxUploadSizeBytes)),
      (this.workspaceManager = new WorkspaceManager(
        this._actionsModel,
        new ExternalSourceFoldersManager(this._extensionContext.workspaceState),
        recentCompletionsTracker,
        this._extensionContext,
        this._apiServer,
        this._augmentConfigListener,
        this.featureFlagManager,
        this._clientMetricsReporter,
        this._completionServer,
        this._blobNameCalculator,
        maxUploadSizeBytes,
        this._syncingEnabledTracker,
        this._onboardingSessionEventReporter,
        modelConfig.languages,
      )),
      this.disposeOnDisable.push(this.workspaceManager)
    let reportSourceFoldersDebounced = (0, ZIe.debounce)(() => {
      let sourceFoldersReport = this.workspaceManager?.getSourceFoldersReportDetails() // =
      sourceFoldersReport !== undefined && this._extensionEventReporter.reportSourceFolders(sourceFoldersReport)
    }, 5e3)
    this.disposeOnDisable.push(
      this.workspaceManager.onDidEnumerateFolder(() => reportSourceFoldersDebounced()),
    ),
      this.disposeOnDisable.push(
        this.workspaceManager.onDidChangeSourceFolders(() => reportSourceFoldersDebounced()),
      ),
      (this.syncingStatusReporter = new SyncingStatusReporter(
        this.featureFlagManager,
        this.workspaceManager,
      )),
      this.disposeOnDisable.push(this.syncingStatusReporter),
      this.disposeOnDisable.push(
        new SyncingStatusTracker(
          this._statusBar,
          this.syncingStatusReporter.onDidChangeSyncingStatus,
        ),
      ),
      (this.keybindingWatcher = new jc(this._globalState)),
      this.disposeOnDisable.push(this.keybindingWatcher),
      (this._diagnosticsManager = new WQ()),
      this.disposeOnDisable.push(this._diagnosticsManager)
    let nextEditStatusReporter = new $m(this._statusBar)
    this.disposeOnDisable.push(nextEditStatusReporter)
    let documentContextTracker = new DocumentContextValue()
    this.disposeOnDisable.push(
      onCompletionAccepted((event) => {
        event.acceptedIdx >= 0 && documentContextTracker.set(true, event.document)
      }),
    ),
      this.disposeOnDisable.push(documentContextTracker)
    let nextEditEventEmitter = new gN()
    this.disposeOnDisable.push(nextEditEventEmitter),
      (this._suggestionManager = new SuggestionManager(
        this.workspaceManager,
        this._nextEditSessionEventReporter,
      )),
      this.disposeOnDisable.push(this._suggestionManager),
      (this._nextEditRequestManager = new NextEditRequestManager(
        this._apiServer,
        this._augmentConfigListener,
        this.workspaceManager,
        this._diagnosticsManager,
        this._nextEditSessionEventReporter,
        this._clientMetricsReporter,
        this._blobNameCalculator,
        this._suggestionManager,
        this._recentNextEditResults,
        nextEditStatusReporter,
        documentContextTracker,
        this.featureFlagManager,
      )),
      this.disposeOnDisable.push(this._nextEditRequestManager),
      (this._editorNextEdit = new EditorNextEdit(
        this._extensionContext,
        this.workspaceManager,
        this._nextEditSessionEventReporter,
        this.keybindingWatcher,
        this._augmentConfigListener,
        this._suggestionManager,
        this._nextEditRequestManager,
        this._globalState,
        this.nextEditConfigManager,
        nextEditEventEmitter,
        (suggestion) => {
          this._nextEditWebViewEvent.fire({
            type: "next-edit-active-suggestion",
            data: suggestion,
          })
        },
      )),
      this.disposeOnDisable.push(this._editorNextEdit),
      (this._globalNextEdit = new GlobalNextEdit(
        this.workspaceManager,
        this._nextEditRequestManager,
        this._suggestionManager,
        this._augmentConfigListener,
        this._nextEditSessionEventReporter,
      )),
      this.disposeOnDisable.push(this._globalNextEdit)
    let chatHintButtons = [
      {
        text: this.featureFlagManager.currentFlags.enableInstructions
          ? "Chat"
          : "Open in Augment Chat",
        keyBindingId: Separator.commandID,
      },
    ]
    this.featureFlagManager.currentFlags.enableInstructions &&
      chatHintButtons.push({ text: "Instruct", keyBindingId: InstructionCommand.commandID }),
      (this._openChatHintManager = new cC(
        this._augmentConfigListener,
        this._extensionContext,
        this.keybindingWatcher,
        this.featureFlagManager,
        chatHintButtons,
      )),
      this._openChatHintManager.enable(),
      this.disposeOnDisable.push(this._openChatHintManager),
      (this.fuzzyFsSearcher = new FuzzyFsSearcher(
        this._globalState,
        this.workspaceManager,
        this.syncingStatusReporter.onDidChangeSyncingStatus,
      )),
      (this.fuzzySymbolSearcher = new YM(
        this._globalState,
        this._augmentConfigListener,
        this.fuzzyFsSearcher,
        this.workspaceManager,
      )),
      this.disposeOnDisable.push(this.fuzzyFsSearcher),
      this.disposeOnDisable.push(this.fuzzySymbolSearcher),
      await gye(this._extensionContext.storageUri, this._logger)
    let getMemoriesDirectoryPath = () => {
      let storageUri = this._extensionContext.storageUri
      if (storageUri) return Ye.Uri.joinPath(storageUri, "Augment-Memories").fsPath
    }
    OY(new TF(this.workspaceManager)),
      this.disposeOnDisable.push(new Ye.Disposable(() => qY())),
      IK(new MF(this._apiServer, this.workspaceManager)),
      this.disposeOnDisable.push(new Ye.Disposable(() => BK())),
      BY(this._assetManager),
      this.disposeOnDisable.push(new Ye.Disposable(() => RY())),
      LK(new kF(this._extensionContext)),
      this.disposeOnDisable.push(new Ye.Disposable(() => UK())),
      NK(new kx(this.featureFlagManager)),
      this.disposeOnDisable.push(new Ye.Disposable(() => PK())),
      RK(
        new BF(
          this._extensionContext.extensionUri,
          this.workspaceManager,
          this._apiServer,
          this.keybindingWatcher,
          this.fuzzyFsSearcher,
          this.fuzzySymbolSearcher,
          this.workTimer,
        ),
      ),
      this.disposeOnDisable.push(new Ye.Disposable(() => TK())),
      (this._agentCheckpointManager = new aI(
        new zS(),
        getMemoriesDirectoryPath,
        (listener) =>
          Ye.workspace.onDidChangeTextDocument((event) => {
            let qualifiedPathName = this.workspaceManager?.safeResolvePathName(event.document.uri)
            if (!qualifiedPathName) return
            let documentChangeEvent = {
              document: {
                qualifiedPathName: qualifiedPathName,
                getText: () => event.document.getText(),
              },
              contentChanges: event.contentChanges.map((change) => ({
                text: change.text,
                range: change.range
                  ? {
                      start: {
                        line: change.range.start.line,
                        character: change.range.start.character,
                      },
                      end: {
                        line: change.range.end.line,
                        character: change.range.end.character,
                      },
                    }
                  : undefined,
              })),
            }
            listener(documentChangeEvent)
          }),
        this.workspaceManager.onFileDeleted,
        this.workspaceManager.onFileDidMove,
      )),
      this.disposeOnDisable.push(this._agentCheckpointManager),
      this.disposeOnDisable.push(
        this.syncingStatusReporter.onDidChangeSyncingStatus((syncStatus) => {
          syncStatus.prevStatus !== undefined &&
            syncStatus.prevStatus !== "done" &&
            syncStatus.status === "done" &&
            this.featureFlagManager.currentFlags.memoriesParams
              .enable_initial_orientation &&
            setTimeout(() => {
              if (this.workspaceManager === undefined)
                throw Error("Workspace manager is undefined")
              if (this._agentCheckpointManager === undefined)
                throw Error("Checkpoint manager is undefined")
              runAutomaticOrientation( // =
                this._apiServer,
                this.workspaceManager,
                this.featureFlagManager,
                this._agentCheckpointManager,
                this._extensionContext.workspaceState,
              )
            }, 3e3)
        }),
      ),
      (this._toolsModel = new WB(
        [],
        obe(
          this._apiServer,
          this.workspaceManager,
          this._agentCheckpointManager,
          this.featureFlagManager,
          this._extensionContext.extensionUri,
          this._globalState,
          startTime,
        ),
        new tF(this._apiServer, this._augmentConfigListener),
        (error) => {
          Ye.window.showErrorMessage(
            "Failed to start the MCP server. " + JSON.stringify(error),
          )
        },
        new kx(this.featureFlagManager),
        this._agentCheckpointManager,
        () => SM(getMemoriesDirectoryPath),
        getMemoriesDirectoryPath,
        () => this._toolUseRequestEventReporter,
        {
          userAgent: "Augment-VSCode/1.0",
          unsupportedSidecarTools: new Set([Hi.strReplaceEditor]),
        },
      )),
      OK(new KB(this._agentCheckpointManager, this._toolsModel)),
      this.disposeOnDisable.push(new Ye.Disposable(() => qK())),
      (this._toolConfigStore = new WN(
        this._globalState,
        this._toolsModel,
        () => this._augmentConfigListener.config.mcpServers,
      )),
      this.disposeOnDisable.push(
        new Ye.Disposable(() => {
          this._toolConfigStore = undefined
        }),
      ),
      this._toolConfigStore.updateSidecarMCPServers(),
      (async (toolsModel) => {
        let memoriesPath = toolsModel.memoriesAbsPath
        if (memoriesPath) {
          let memoriesUri = Ye.Uri.file(memoriesPath)
          try {
            await ev(memoriesUri.fsPath)
          } catch {
            let directoryPath = Ha(memoriesUri.fsPath)
            ;(await Vl(directoryPath)) || (await Hl(directoryPath)), await oa(memoriesUri.fsPath, "")
          }
        }
        this.addDisposable(
          Ye.window.onDidChangeActiveTextEditor(async (editor) => {
            await Aye(editor, getMemoriesDirectoryPath, this._globalState),
              await QG(editor, getMemoriesDirectoryPath, this._globalState)
          }),
        ),
          this.addDisposable(
            Ye.workspace.onDidChangeTextDocument((event) => {
              vye(event, Ye.window.activeTextEditor, getMemoriesDirectoryPath, this._globalState, toolsModel)
            }),
          ),
          this.addDisposable(mye())
      })(this._toolsModel),
      this.addDisposable(
        this._augmentConfigListener.onDidChange(
          ({ newConfig: newConfig, previousConfig: previousConfig }) => {
            this._toolsModel &&
              ((0, F9.default)(newConfig.mcpServers, previousConfig.mcpServers) ||
                this._toolConfigStore?.updateSidecarMCPServers())
          },
        ),
      )
    let chatModel = new ov(
      this._globalState,
      this._apiServer,
      this.workspaceManager,
      this._recentChats,
      this.fuzzySymbolSearcher,
      this._assetManager,
      this.featureFlagManager,
      this._agentCheckpointManager,
    )
    this._chatModel = chatModel
    let chatHistoryManager = new ChatHistoryManager(this._globalState, this.syncingStatusReporter),
      chatEventEmitter = new LN(),
      chatWebviewApp = new ChatApp(
        chatModel,
        modelsByName,
        this._apiServer,
        this.workspaceManager,
        this.keybindingWatcher,
        this._augmentConfigListener,
        this._extensionContext.extensionUri,
        this.featureFlagManager,
        this._clientMetricsReporter,
        this._actionsModel,
        this._syncingEnabledTracker,
        chatHistoryManager,
        this.syncingStatusReporter,
        this._onboardingSessionEventReporter,
        this.fuzzyFsSearcher,
        this.fuzzySymbolSearcher,
        this._toolsModel,
        chatEventEmitter,
        this._agentCheckpointManager,
        this.guidelinesWatcher,
        this._assetManager,
        this._globalState,
        this.workTimer,
      )
    ;(this._currentChatExtensionEventDisposable =
      this._chatExtensionEvent.event(chatWebviewApp.onChatExtensionMessage)),
      this.disposeOnDisable.push(this._currentChatExtensionEventDisposable),
      this._mainPanelProvider.changeApp(chatWebviewApp)
    let workspaceManagerRef = this.workspaceManager,
      keybindingWatcherRef = this.keybindingWatcher
    this.disposeOnDisable.push(
      this._changeWebviewAppEvent.event((appType) => {
        let newApp, newChatExtensionEventDisposable // =
        switch ((this._currentChatExtensionEventDisposable?.dispose(), appType)) {
          case "chat":
            ;(newApp = new ChatApp(
              chatModel,
              modelsByName,
              this._apiServer,
              workspaceManagerRef,
              keybindingWatcherRef,
              this._augmentConfigListener,
              this._extensionContext.extensionUri,
              this.featureFlagManager,
              this._clientMetricsReporter,
              this._actionsModel,
              this._syncingEnabledTracker,
              chatHistoryManager,
              this.syncingStatusReporter,
              this._onboardingSessionEventReporter,
              this.fuzzyFsSearcher,
              this.fuzzySymbolSearcher,
              this._toolsModel,
              chatEventEmitter,
              this._agentCheckpointManager,
              this.guidelinesWatcher,
              this._assetManager,
              this._globalState,
              this.workTimer,
            )),
              this._mainPanelProvider.changeApp(newApp),
              (newChatExtensionEventDisposable = this._chatExtensionEvent.event(newApp.onChatExtensionMessage)),
              (this._currentChatExtensionEventDisposable = newChatExtensionEventDisposable),
              this.disposeOnDisable.push(
                this._currentChatExtensionEventDisposable,
              )
            break
          case "sign-in":
            break
          case "workspace-context":
            this._mainPanelProvider.changeApp(
              new jQ(workspaceManagerRef, this.featureFlagManager, this.workTimer),
            )
            break
          case "awaiting-syncing-permission":
            this._mainPanelProvider.changeApp(
              new AwaitingSyncingPermissionApp(
                this._actionsModel,
                this._apiServer,
                this._augmentConfigListener,
                this._syncingEnabledTracker,
                this._changeWebviewAppEvent,
                this.featureFlagManager,
                modelConfig.userTier,
              ),
            )
            break
          case "folder-selection":
            this._mainPanelProvider.changeApp(
              new zQ(this._onboardingSessionEventReporter),
            )
            break
          default: {
            let unknownAppType = appType
            throw new Error(`Unhandled app case: ${unknownAppType}`)
          }
        }
      }),
    ),
      this.disposeOnDisable.push(
        this._augmentConfigListener.onDidChange(
          this._checkInlineCompletionsEnabled.bind(this),
        ),
      ),
      this._checkInlineCompletionsEnabled(),
      this.disposeOnDisable.push(
        new Ye.Disposable(() => this._disableInlineCompletions.bind(this)),
      )
    {
      let uploadStatusDisposable,
        automaticCompletionsStatusDisposable,
        debugFeaturesDisposable,
        automaticCompletionsKeyBindingDisposable,
        debugKeyBindingDisposable,
        codeActionsProviderDisposable,
        dataCollectionStatusDisposable,
        configChangeHandler = (newConfig, previousConfig) => {
          uploadStatusDisposable?.dispose(),
            automaticCompletionsStatusDisposable?.dispose(),
            debugFeaturesDisposable?.dispose(),
            debugKeyBindingDisposable?.dispose(),
            automaticCompletionsKeyBindingDisposable?.dispose(),
            codeActionsProviderDisposable?.dispose(),
            dataCollectionStatusDisposable?.dispose(),
            newConfig.completions.enableAutomaticCompletions ||
              (automaticCompletionsStatusDisposable = this._statusBar.setState(fSe)),
            newConfig.enableDebugFeatures && this.keybindingWatcher
              ? ((debugKeyBindingDisposable = new $Q(
                  this.keybindingWatcher,
                  this._inlineCompletionProvider,
                )),
                this.disposeOnDisable.push(debugKeyBindingDisposable))
              : newConfig.completions.enableAutomaticCompletions &&
                this.keybindingWatcher &&
                ((automaticCompletionsKeyBindingDisposable = new GQ(
                  this.keybindingWatcher,
                  this._inlineCompletionProvider,
                )),
                this.disposeOnDisable.push(automaticCompletionsKeyBindingDisposable)),
            (codeActionsProviderDisposable = Ye.languages.registerCodeActionsProvider("*", new B1())),
            this.disposeOnDisable.push(codeActionsProviderDisposable),
            newConfig.enableUpload || (uploadStatusDisposable = this._statusBar.setState(hSe))
          let isDataCollectionEnabled = newConfig.enableDataCollection || modelConfig.featureFlags.enableHindsight
          this._dataCollector && !isDataCollectionEnabled
            ? (this._logger.debug("Disabling Hindsight Data"),
              this._dataCollector.dispose(),
              (this._dataCollector = undefined))
            : !this._dataCollector &&
              isDataCollectionEnabled &&
              this.workspaceManager !== undefined &&
              (this._logger.debug("Enabling Hindsight Data"),
              (this._dataCollector = new VQ(
                this._apiServer,
                this.workspaceManager,
                this._recentInstructions,
                this._recentCompletions,
                this._recentNextEditResults,
              )))
          let isNextEditEnabled = iw(
              newConfig,
              this.featureFlagManager.currentFlags.vscodeNextEditMinVersion,
            ),
            wasNextEditEnabled =
              previousConfig &&
              iw(
                previousConfig,
                this.featureFlagManager.currentFlags.vscodeNextEditMinVersion,
              )
          if (isNextEditEnabled && !wasNextEditEnabled)
            if (
              this.workspaceManager &&
              this.keybindingWatcher &&
              this._suggestionManager &&
              this._nextEditRequestManager
            )
              try {
                ;(this._backgroundNextEdit = new BackgroundNextEdit(
                  this.workspaceManager,
                  this._nextEditSessionEventReporter,
                  this.keybindingWatcher,
                  this._augmentConfigListener,
                  this._suggestionManager,
                  this._nextEditRequestManager,
                  this._globalState,
                  this.nextEditConfigManager,
                  nextEditEventEmitter,
                )),
                  this.disposeOnDisable.push(this._backgroundNextEdit),
                  this._nextEditSessionEventReporter.reportEventWithoutIds(
                    "initialization-success",
                    "validation-expected",
                  )
              } catch (error) {
                this._logger.error(
                  "Error initializing background next edit: ",
                  error,
                ),
                  this._nextEditSessionEventReporter.reportEventWithoutIds(
                    "initialization-failure",
                    "error",
                  ),
                  this._apiServer.reportError(
                    null,
                    "background_next_edit_initialization_failure",
                    error instanceof Error ? error.stack || error.message : String(error),
                    [],
                  )
              }
            else {
              this._logger.error(
                "Failed to enable background next edit generation",
              ),
                this._nextEditSessionEventReporter.reportEventWithoutIds(
                  "initialization-skip",
                  "validation-unexpected",
                )
              let missingDependencies = [
                ["this.workspaceManager", this.workspaceManager],
                ["this.keybindingWatcher", this.keybindingWatcher],
                ["this._suggestionManager", this._suggestionManager],
                ["this._nextEditRequestManager", this._nextEditRequestManager],
              ]
                .map((dependency) => dependency.join("="))
                .join(", ")
              this._apiServer.reportError(
                null,
                "background_next_edit_initialization_failure",
                `Background next edit initialization failed because ${missingDependencies}`,
                [],
              )
            }
          else
            this._backgroundNextEdit && !isNextEditEnabled
              ? (this._backgroundNextEdit.dispose(),
                (this._backgroundNextEdit = undefined),
                this._nextEditSessionEventReporter.reportEventWithoutIds(
                  "disposed",
                  "validation-expected",
                ))
              : !isNextEditEnabled &&
                !wasNextEditEnabled &&
                this._nextEditSessionEventReporter.reportEventWithoutIds(
                  "initialization-skip",
                  "validation-expected",
                )
          let isNextEditSupported = isVersionSupported(
            newConfig,
            this.featureFlagManager.currentFlags.vscodeNextEditMinVersion ?? "",
          )
          isNextEditSupported &&
            previousConfig &&
            newConfig.nextEdit.enableBackgroundSuggestions !==
              previousConfig.nextEdit.enableBackgroundSuggestions &&
            this._nextEditSessionEventReporter.reportEventWithoutIds(
              newConfig.nextEdit.enableBackgroundSuggestions
                ? "background-suggestions-enabled"
                : "background-suggestions-disabled",
              "unknown",
            ),
            isNextEditSupported &&
              previousConfig &&
              newConfig.nextEdit.highlightSuggestionsInTheEditor !==
                previousConfig.nextEdit.highlightSuggestionsInTheEditor &&
              this._nextEditSessionEventReporter.reportEventWithoutIds(
                newConfig.nextEdit.highlightSuggestionsInTheEditor
                  ? "highlights-enabled"
                  : "highlights-disabled",
                "unknown",
              )
        }
      this.disposeOnDisable.push(
        this._augmentConfigListener.onDidChange((configChange) => {
          configChangeHandler(configChange.newConfig, configChange.previousConfig)
        }),
      ),
        configChangeHandler(this._augmentConfigListener.config)
    }
    {
      let reporters = [
        this._completionAcceptanceReporter,
        this._codeEditReporter,
        this._nextEditResolutionReporter,
        this._nextEditSessionEventReporter,
        this._onboardingSessionEventReporter,
        this._clientMetricsReporter,
        this._completionTimelineReporter,
        this._extensionEventReporter,
        this._toolUseRequestEventReporter,
      ]
      for (let reporter of reporters) reporter.enableUpload(), this.disposeOnDisable.push(reporter)
      this.disposeOnDisable.push(
        new Ye.Disposable(() => {
          GK(), WK()
        }),
      )
    }
    this.disposeOnDisable.push(
      Ye.window.registerWebviewViewProvider(
        "augment-next-edit",
        new NextEditWebviewProvider(
          this._augmentConfigListener,
          this.featureFlagManager,
          (webviewView) =>
            new NextEditSuggestionsPanel(
              this._extensionContext.extensionUri,
              webviewView,
              webviewView.webview,
              this._suggestionManager,
              this._globalNextEdit,
              this._editorNextEdit,
              this._nextEditSessionEventReporter,
              chatEventEmitter,
              this._nextEditVSCodeToWebviewMessage,
              this.workTimer,
            ),
        ),
        { webviewOptions: { retainContextWhenHidden: true } },
      ),
    ),
      (this.enabled = true),
      this._statusBar.setState(nSe),
      (this._remoteWorkspaceResolver = wm.initialize(
        this._apiServer,
        this._augmentConfigListener,
        this.featureFlagManager,
      )),
      this.disposeOnDisable.push(this._remoteWorkspaceResolver),
      this.disposeOnDisable.push(
        new SyncingStatusBarManager(this._statusBar, this._syncingEnabledTracker),
      )
    let updateChecker = new Im(this._augmentConfigListener, this._actionsModel)
    this.addDisposable(updateChecker), updateChecker.checkAndUpdateState()
    let workspaceStateManager = new WorkspaceStateManager(this._actionsModel, this.workspaceManager)
    this.disposeOnDisable.push(workspaceStateManager), this._syncLastEnabledExtensionVersion()
    let packageJson = this._extensionContext.extension.packageJSON,
      isPreRelease = "preRelease" in packageJson && packageJson.preRelease === true
    this._logger.debug(`Is the extension in pre-release? ${isPreRelease}`),
      this._extensionEventReporter.reportConfiguration(
        "configuration-snapshot",
        this._augmentConfigListener.config,
        this.featureFlagManager.currentFlags,
      )
  }
  async _fetchFeatureFlags(cancellationToken) {
    try {
      return (await this._getModelConfig(cancellationToken)).featureFlags
    } catch (error) {
      this._logger.error("Failed to fetch feature flags: ", error)
      return
    }
  }
  updateModelInfo(modelInfoUpdate) {
    if (!this._modelInfo) throw new Error("Model info not set")
    modelInfoUpdate.suggestedPrefixCharCount !== undefined &&
      (this._modelInfo.suggestedPrefixCharCount = modelInfoUpdate.suggestedPrefixCharCount),
      modelInfoUpdate.suggestedSuffixCharCount !== undefined &&
        (this._modelInfo.suggestedSuffixCharCount = modelInfoUpdate.suggestedSuffixCharCount),
      (this._modelInfo.completionTimeoutMs = modelInfoUpdate.completionTimeoutMs)
  }
  async _getModelConfig(cancellationToken) {
    let backoffTimeMs = 1e3,
      modelConfig,
      retryCount = 0,
      maxRetries = 6,
      statusBarItem = new $m(this._statusBar)
    try {
      for (;;) {
        if (cancellationToken.isCancellationRequested) throw new Ye.CancellationError()
        try {
          this._logger.info("Retrieving model config"),
            (modelConfig = await this._apiServer.getModelConfig()),
            this._logger.info("Retrieved model config")
        } catch (error) {
          if (
            (this._logger.error("Failed to retrieve model config: ", error),
            ApiError.isAPIErrorWithStatus(error, RequestStatus.unauthenticated))
          )
            throw error
          if (error instanceof InvalidCompletionUrlError) throw error
          retryCount++
        }
        if (cancellationToken.isCancellationRequested)
          throw (
            (this._logger.info("Model config retrieval cancelled"),
            new Ye.CancellationError())
          )
        if (modelConfig !== undefined) return this._logger.info("Returning model config"), modelConfig
        retryCount >= maxRetries && statusBarItem.setState(g6),
          this._logger.info(`Retrying model config retrieval in ${backoffTimeMs} msec`),
          await sleep(backoffTimeMs),
          (backoffTimeMs = Math.min(backoffTimeMs * 2, e.modelConfigBackoffMsecMax))
      }
    } finally {
      statusBarItem.dispose()
    }
  }
  disable() {
    for (this.enabled = false; this.disposeOnDisable.length; )
      this.disposeOnDisable.pop().dispose()
    ;(this._currentChatExtensionEventDisposable = undefined), this.reset()
  }
  reset() {
    this._enableCancel?.cancel(),
      this._enableCancel?.dispose(),
      (this._enableCancel = undefined),
      this._statusBar.reset(),
      this.workspaceManager?.dispose(),
      (this.workspaceManager = undefined),
      this._disableDataCollection()
  }
  _checkInlineCompletionsEnabled(configChange) {
    ;(configChange &&
      configChange.previousConfig.completions.addIntelliSenseSuggestions ===
        configChange.newConfig.completions.addIntelliSenseSuggestions) ||
      this._enableInlineCompletions()
  }
  _enableInlineCompletions() {
    if (
      (this._disableInlineCompletions(),
      this._logger.debug("Registering inline completions  provider."),
      (this._inlineCompletionProvider = new OQ(
        this._completionsModel,
        this._completionAcceptanceReporter,
        this._statusBar,
        this._augmentConfigListener,
        this._completionTimelineReporter,
      )),
      this._completionDisposables.push(this._inlineCompletionProvider),
      onCompletionAvailable((completionEvent) => {
        completionEvent && this._recentCompletions.addItem(completionEvent)
      }),
      this._completionDisposables.push(
        Ye.languages.registerInlineCompletionItemProvider(
          "*",
          this._inlineCompletionProvider,
        ),
      ),
      this._augmentConfigListener.config.completions.addIntelliSenseSuggestions)
    ) {
      this._logger.debug("Registering completion items provider.")
      let completionItemsProvider = new Kv(this._augmentConfigListener)
      this._completionDisposables.push(
        Ye.languages.registerCompletionItemProvider(
          Kv.languageSelector,
          completionItemsProvider,
          ...Kv.triggerCharacters,
        ),
      )
    }
  }
  _disableInlineCompletions() {
    for (let disposable of this._completionDisposables) disposable.dispose()
    this._completionDisposables = []
  }
  _disableDataCollection() {
    this._dataCollector?.dispose(), (this._dataCollector = undefined)
  }
  getRecencyInfo() {
    let recencyInfo = {},
      tabSwitchEvents = this.workspaceManager.getTabSwitchEvents()
    return (
      tabSwitchEvents !== undefined &&
        (recencyInfo.tab_switch_events = tabSwitchEvents.map((event) => ({
          path: event.relPathName,
          file_blob_name: event.blobName,
        }))),
      recencyInfo
    )
  }
  forceNextEditSuggestion(source) {
    let activeEditor = Ye.window.activeTextEditor
    if (!activeEditor || !this.workspaceManager) return
    let pathName = this.workspaceManager.safeResolvePathName(activeEditor.document.uri)
    pathName &&
      (this._nextEditSessionEventReporter.reportEventWithoutIds(
        "suggestion-forced",
        source ?? "command",
      ),
      this._nextEditRequestManager?.enqueueRequest(
        pathName,
        "FORCED",
        "CURSOR",
        rangeToLineRange(activeEditor.selection),
      ))
  }
  nextEditUpdate(query) {
    this._globalNextEdit?.startGlobalQuery(query)
  }
  nextEditBackgroundSuggestionsEnabled() {
    return iw(
      this._augmentConfigListener.config,
      this.featureFlagManager.currentFlags.vscodeNextEditMinVersion ?? "",
    )
  }
  noopClicked() {
    this._nextEditSessionEventReporter.reportEventWithoutIds(
      "noop-clicked",
      "command",
    )
  }
  nextEditTogglePanelHorizontalSplit(source) {
    this._nextEditVSCodeToWebviewMessage.fire({
      type: "next-edit-toggle-suggestion-tree",
    }),
      this._nextEditSessionEventReporter.reportEventWithoutIds(
        "toggle-panel-horizontal-split",
        source ?? "command",
      )
  }
  openNextEditPanel(source) {
    this._nextEditSessionEventReporter.reportEventWithoutIds(
      "panel-focus-executed",
      source ?? "command",
    ),
      Ye.commands.executeCommand("augment-next-edit.focus"),
      this._nextEditVSCodeToWebviewMessage.fire({
        type: "next-edit-panel-focus",
      })
  }
  nextEditLearnMore(source) {
    this._nextEditSessionEventReporter.reportEventWithoutIds(
      "learn-more-clicked",
      source ?? "command",
    ),
      Ye.env.openExternal(
        Ye.Uri.parse("https://docs.augmentcode.com/using-augment/next-edit"),
      )
  }
  async updateStatusTrace() {
    this._statusTrace?.dispose()
    let statusTraceBuilder = new UN(() => this._onTextDocumentDidChange.fire(e.displayStatusUri))
    this._statusTrace = statusTraceBuilder
    let savePointIndex = 0
    if (this.enableInProgress) {
      statusTraceBuilder.addLine("Augment extension is initializing"), statusTraceBuilder.publish()
      return
    }
    if (!this.enabled) {
      statusTraceBuilder.addLine("Augment is not enabled in this workspace"), statusTraceBuilder.publish()
      return
    }
    statusTraceBuilder.addSection("Extension version")
    let extension = Ye.extensions.getExtension("augment.vscode-augment")
    extension
      ? statusTraceBuilder.addValue("Extension version", extension.packageJSON.version)
      : statusTraceBuilder.addLine("Cannot retrieve extension version"),
      statusTraceBuilder.addSection("Session ID"),
      statusTraceBuilder.addValue("Session ID", this._apiServer.sessionId),
      statusTraceBuilder.addSection("Recent Completion Requests (oldest to newest)")
    let sortedCompletions = this._recentCompletions.items
      .sort((a, b) => a.occuredAt.getTime() - b.occuredAt.getTime())
      .slice(0, 10)
    for (let { requestId } of sortedCompletions) statusTraceBuilder.addLine(`${requestId}`)
    sortedCompletions.length === 0 && statusTraceBuilder.addLine("No recent completion requests"),
      statusTraceBuilder.addSection("Recent Instruction Requests (oldest to newest)")
    for (let { requestId } of this._recentInstructions.items)
      statusTraceBuilder.addLine(`${requestId}`)
    this._recentInstructions.items.length === 0 &&
      statusTraceBuilder.addLine("No recent instruction requests"),
      statusTraceBuilder.addSection("Recent Chat Requests (oldest to newest)")
    for (let { requestId } of this._recentChats.items) statusTraceBuilder.addLine(`${requestId}`)
    this._recentChats.items.length === 0 &&
      statusTraceBuilder.addLine("No recent chat requests"),
      statusTraceBuilder.addSection("Extension configuration")
    let config = this._augmentConfigListener.config
    statusTraceBuilder.addObject(config), statusTraceBuilder.addValue("Using API token", !this._auth.useOAuth)
    let completionUrl = ""
    if (this._auth.useOAuth) {
      let session = await this._auth.getSession()
      statusTraceBuilder.addValue("Tenant URL", session?.tenantURL), (completionUrl = session?.tenantURL || "")
    } else completionUrl = config.completionURL
    if (!this.ready) {
      statusTraceBuilder.addLine("Augment extension is initializing"), statusTraceBuilder.publish()
      return
    }
    statusTraceBuilder.addSection("Back-end Configuration"),
      statusTraceBuilder.addValue(
        "MaxUploadSizeBytes",
        this.featureFlagManager.currentFlags.maxUploadSizeBytes,
      ),
      statusTraceBuilder.addValue(
        "enableCompletionFileEditEvents",
        this.featureFlagManager.currentFlags.enableCompletionFileEditEvents,
      ),
      statusTraceBuilder.addSection("Supported languages (Augment name / VSCode name):")
    for (let language of this._languages) statusTraceBuilder.addLine(`${language.name} / ${language.vscodeName}`)
    statusTraceBuilder.addSection("Available Models")
    for (let model of this._availableModels) {
      let isDefault = this._defaultModel && model.startsWith(this._defaultModel),
        isCurrent = (!config.modelName && isDefault) || model === config.modelName,
        modelDisplay = model + (isDefault ? " (default)" : "") + (isCurrent ? " (current)" : "")
      statusTraceBuilder.addLine(modelDisplay)
    }
    this._availableModels.length === 0 && statusTraceBuilder.addLine("No models available"),
      statusTraceBuilder.addSection("Current Model"),
      (savePointIndex = statusTraceBuilder.savePoint()),
      statusTraceBuilder.addLine("Querying current model"),
      statusTraceBuilder.addLine("(in progress...)")
    try {
      statusTraceBuilder.publish(),
        statusTraceBuilder.rollback(savePointIndex),
        config.modelName || statusTraceBuilder.addLine("(Using default model)"),
        statusTraceBuilder.addObject(this.modelInfo)
    } catch (error) {
      statusTraceBuilder.rollback(savePointIndex),
        error instanceof cw
          ? statusTraceBuilder.addLine(`Model "${config.modelName}" not known.`)
          : statusTraceBuilder.addError(
              `Unable to query info about model "${config.modelName}": ${getErrorMessage(error)}`,
            )
    }
    if (
      (statusTraceBuilder.addSection("Blob upload"),
      config.enableUpload
        ? statusTraceBuilder.addLine("Blob upload enabled in configuration settings")
        : statusTraceBuilder.addLine("Blob upload disabled in configuration settings"),
      this.workspaceManager !== undefined &&
        (await this.workspaceManager.updateStatusTrace(statusTraceBuilder)),
      completionUrl !== "")
    ) {
      statusTraceBuilder.addSection("Completion status"),
        statusTraceBuilder.addLine(`Attempting completion from ${completionUrl}`)
      let requestId = this._apiServer.createRequestId()
      statusTraceBuilder.addValue("Request ID", requestId),
        (savePointIndex = statusTraceBuilder.savePoint()),
        statusTraceBuilder.addLine("(in progress...)")
      try {
        statusTraceBuilder.publish()
        let startTime = Date.now(),
          completionResponse = await this._apiServer.complete(
            requestId,
            "this is the prefix",
            "this is the suffix",
            "/this/is/the/path",
            undefined,
            { prefixBegin: 0, cursorPosition: 0, suffixEnd: 0 },
            "python",
            { checkpointId: undefined, addedBlobs: [], deletedBlobs: [] },
            [],
          )
        statusTraceBuilder.rollback(savePointIndex),
          statusTraceBuilder.addLine(`Response received in ${Date.now() - startTime} ms`),
          completionResponse.completionItems.length === 0
            ? statusTraceBuilder.addLine("No completion received")
            : statusTraceBuilder.addLine(`${completionResponse.completionItems.length} completion(s) received`)
      } catch (error) {
        statusTraceBuilder.rollback(savePointIndex), statusTraceBuilder.addError(`Completion request failed: ${error}`)
      }
    }
    statusTraceBuilder.addSection("Feature Flags"),
      statusTraceBuilder.addObject(this.featureFlagManager.currentFlags),
      statusTraceBuilder.publish()
  }
  async provideTextDocumentContent(uri) {
    return uri.toString() === e.displayStatusUri.toString()
      ? this._statusTrace === undefined
        ? "Internal error. Cannot get Augment extension status."
        : this._statusTrace.content
      : ""
  }
  get onDidChange() {
    return this._onTextDocumentDidChange.event
  }
  clearFileEdits() {
    this.workspaceManager?.clearFileEdits()
  }
}
function eBe(e) {
  let t = e.get("sessionId")
  return (t === undefined || !I5(t)) && ((t = Oh()), e.update("sessionId", t)), t
}
function activate(e) {
  let t = z("activate()")
  t.debug("======== Activating extension ========")
  let r
  function n(J) {
    J.enable()
  }
  function i(J) {
    J.disable()
  }
  function s() {
    r && (t.debug("======== Deactivating extension ========"), i(r)),
      (r = undefined)
  }
  function o() {
    t.info("======== Reloading extension ========"), i(r), n(r)
  }
  e.subscriptions.push(
    new Ye.Disposable(() => {
      s()
    }),
  ),
    e.subscriptions.push(
      Ye.window.registerUriHandler({
        handleUri(J) {
          if (J.authority.toLowerCase() !== e.extension.id.toLowerCase()) {
            t.warn(`Ignoring URI ${J.toString()}`)
            return
          }
          switch (J.path) {
            case U.authRedirectURI.path:
              U.handleAuthURI(J)
              break
            default:
              t.error(
                `Unhandled URI ${Ye.Uri.from({ scheme: J.scheme, authority: J.authority, path: J.path }).toString()}`,
              )
          }
        },
      }),
    )
  let a = `${W2.default.platform()}; ${W2.default.arch()}; ${W2.default.release()}`,
    l = `${e.extension.id}/${e.extension.packageJSON.version} (${a}) ${Ye.env.uriScheme}/${Ye.version}`,
    c = new CM(e)
  e.subscriptions.push(c)
  let u = eBe(c),
    f = new sM()
  f.migrateLegacyConfig()
  let p = new lM(e, f)
  e.subscriptions.push(p)
  let syncingEnabledTracker = new SyncingEnabledTracker()
  e.subscriptions.push(syncingEnabledTracker), setClientConfig(new DF(f)), setClientAuth(new RF(p, f))
  let m = new APIServer(f, p, u, l, global.fetch),
    y = new qQ(),
    v = new yg(10),
    C = new yg(10),
    E = new yg(10),
    w = new Ye.EventEmitter(),
    B = new Ye.EventEmitter(),
    changeWebviewAppEventEmitter = new Ye.EventEmitter(),
    N = new Ye.EventEmitter(),
    W = new rF(e),
    mainPanelProvider = new MainPanelWebviewProvider(e.extensionUri)
  mainPanelProvider.onVisibilityChange((J) => {
    J || Tv.currentPanel?.dispose()
  })
  let actionsStateModel = new ActionsStateModel(c)
  e.subscriptions.push(actionsStateModel)
  let Y = new oN(m),
    U = new uM(e, f, m, p, Y),
    ce = new JQ(m, f, U, actionsStateModel)
  function Ie(J) {
    e: for (let ie of J)
      switch (ie.name) {
        case "UserShouldSignIn": {
          mainPanelProvider.changeApp(ce), Q()
          break e
        }
        case "WorkspaceNotSelected": {
          actionsStateModel.isSystemStateComplete("authenticated") &&
            changeWebviewAppEventEmitter.fire("folder-selection")
          break e
        }
        case "ShouldDisableCopilot":
        case "ShouldDisableCodeium":
        case "SyncingPermissionNeeded":
        case "uploadingHomeDir":
        case "workspaceTooLarge":
          Q()
          break e
      }
    ;(actionsStateModel.isDerivedStateSatisfied("SyncingPermissionNeeded") ||
      actionsStateModel.isDerivedStateSatisfied("uploadingHomeDir") ||
      actionsStateModel.isDerivedStateSatisfied("workspaceTooLarge")) &&
      changeWebviewAppEventEmitter.fire("awaiting-syncing-permission")
  }
  e.subscriptions.push(
    p.onDidChangeSession(() => {
      o()
    }),
  ),
    e.subscriptions.push(new oM(actionsStateModel, p, f)),
    e.subscriptions.push(
      Ye.window.registerWebviewViewProvider("augment-chat", mainPanelProvider, {
        webviewOptions: { retainContextWhenHidden: true },
      }),
    ),
    (r = new AugmentExtension(e, c, f, m, p, y, v, E, C, w, N, mainPanelProvider, changeWebviewAppEventEmitter, actionsStateModel, syncingEnabledTracker, B, Y, W))
  function Q() {
    mainPanelProvider.isVisible() || Ye.commands.executeCommand(Separator.commandID)
  }
  e.subscriptions.push(actionsStateModel.onDerivedStatesSatisfied(Ie)),
    Ie(actionsStateModel.satisfiedStates),
    f.onDidChange((J) => {
      J.newConfig.enableDebugFeatures, J.previousConfig.enableDebugFeatures
    }),
    e.subscriptions.push(
      f.onDidChange((J) => {
        let ie = false,
          Ue = ["apiToken", "completionURL", "oauth", "modelName"]
        for (let At of Ue)
          if (!(0, F9.default)(J.previousConfig[At], J.newConfig[At])) {
            ie = true
            break
          }
        ie && (t.info("Reloading extension due to config change"), o())
      }),
    ),
    e.subscriptions.push(
      Ye.workspace.registerTextDocumentContentProvider(AugmentExtension.contentScheme, r),
    ),
    nEe(e),
    tBe(r, f, e)
  let se = registerCommands(e, r, f, p, U, m, y, v, E, changeWebviewAppEventEmitter, B, syncingEnabledTracker, c, e.workspaceState)
  e.subscriptions.push(se), e.subscriptions.push(N), n(r)
}
function zIe(e) {
  for (let [t, r] of Object.entries(e))
    Ye.commands.executeCommand("setContext", t, r)
}
function tBe(e, t, r) {
  let n = () => {
    let o = t.config
    zIe({
      "vscode-augment.enableDebugFeatures": o.enableDebugFeatures,
      "vscode-augment.enableReviewerWorkflows": o.enableReviewerWorkflows,
      "vscode-augment.enableNextEdit": isVersionSupported(
        t.config,
        e?.featureFlagManager.currentFlags.vscodeNextEditMinVersion ?? "",
      ),
      "vscode-augment.enableNextEditBackgroundSuggestions": iw(
        t.config,
        e?.featureFlagManager.currentFlags.vscodeNextEditMinVersion ?? "",
      ),
      "vscode-augment.enableGenerateCommitMessage": isMinVersionMet(
        e?.featureFlagManager.currentFlags
          .vscodeGenerateCommitMessageMinVersion ?? "",
      ),
      "vscode-augment.nextEdit.enablePanel":
        e.nextEditConfigManager.config.enablePanel,
    })
  }
  n(), r.subscriptions.push(t.onDidChange(n))
  let i = [
      "enableWorkspaceManagerUi",
      "enableSmartPaste",
      "enableSmartPasteMinVersion",
      "enableInstructions",
      "vscodeSourcesMinVersion",
      "vscodeChatHintDecorationMinVersion",
      "vscodeEnableCpuProfile",
      "vscodeNextEditMinVersion",
      "vscodeGenerateCommitMessageMinVersion",
    ],
    s = () => {
      if (!e) return
      let o = e.featureFlagManager.currentFlags
      zIe({
        "vscode-augment.workspace-manager-ui.enabled":
          o.enableWorkspaceManagerUi,
        "vscode-augment.internal-new-instructions.enabled":
          o.enableInstructions,
        "vscode-augment.internal-dv.enabled":
          isMinVersionMet(o.enableSmartPasteMinVersion) || o.enableInstructions,
        "vscode-augment.sources-enabled": isMinVersionMet(o.vscodeSourcesMinVersion) ?? false,
        "vscode-augment.chat-hint.decoration":
          isMinVersionMet(o.vscodeChatHintDecorationMinVersion) ?? false,
        "vscode-augment.cpu-profile.enabled": o.vscodeEnableCpuProfile,
        "vscode-augment.enableGenerateCommitMessage":
          isMinVersionMet(o.vscodeGenerateCommitMessageMinVersion) ?? false,
        "vscode-augment.nextEdit.enablePanel":
          e.nextEditConfigManager.config.enablePanel,
      })
    }
  s(),
    r.subscriptions.push(e.featureFlagManager.subscribe(i, s)),
    r.subscriptions.push(e.featureFlagManager.subscribe(i, n))
}
var iEt = { setupContextKeySync: tBe }
0 &&
  (module.exports = {
    AugmentExtension,
    _exportedForTesting,
    activate,
    getSessionId,
  })
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

@mixmark-io/domino/lib/style_parser.js:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

undici/lib/web/fetch/body.js:
  (*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)

undici/lib/web/websocket/frame.js:
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
